;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::Host(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address, long lFlags)
{
	HRESULT hr;
	DPN_APPLICATION_DESC	desc;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR wszSessionName[MAX_PATH];
    WCHAR wszPassword[MAX_PATH];

	__try {
		DPF(1,"-----Entering (DplayPeer) Host call...\n");
		if (!IsEmptyString(AppDesc->SessionName)) wcscpy(wszSessionName,AppDesc->SessionName);
		if (!IsEmptyString(AppDesc->Password)) wcscpy(wszPassword,AppDesc->Password);
		
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpAddress, Address);

		ZeroMemory(&desc, sizeof(DPN_APPLICATION_DESC) );

		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = AppDesc->lFlags;
		desc.dwMaxPlayers = AppDesc->lMaxPlayers;
		desc.dwCurrentPlayers = AppDesc->lCurrentPlayers;
		if (!IsEmptyString(AppDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(AppDesc->Password))
			desc.pwszPassword = wszPassword;

		if (AppDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, AppDesc->guidApplication) ) )
				return hr;
			desc.guidApplication = guidApp;
		}

		if (AppDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, AppDesc->guidInstance) ) )
				return hr;
			desc.guidInstance = guidInst;
		}

		if (FAILED (hr = m__dxj_DirectPlayPeer->Host(&desc, &lpAddress, 1, NULL, NULL, NULL, (DWORD) lFlags ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SendTo(long idSend, SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_BUFFER_DESC		lpBuf;
	DWORD				dwBufSize = ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		DPF(1,"-----Entering (DplayPeer) SendTo call...\n");
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}
			
		lpBuf.dwBufferSize = dwBufSize;
		lpBuf.pBufferData  = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

		hr = m__dxj_DirectPlayPeer->SendTo((DPNID) idSend, &lpBuf, 1, (DWORD) lTimeOut, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::CreateGroup(DPN_GROUP_INFO_CDESC *GroupInfo, long lFlags, long *hAsyncHandle)
{
	HRESULT			hr;
	DPN_GROUP_INFO	dpnGroup;
    WCHAR			wszName[MAX_PATH];
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) CreateGroup call...\n");
		if (!IsEmptyString(GroupInfo->Name)) wcscpy(wszName,GroupInfo->Name);
		
		ZeroMemory(&dpnGroup, sizeof(DPN_GROUP_INFO) );
		dpnGroup.dwSize = sizeof(DPN_GROUP_INFO);
		dpnGroup.dwInfoFlags = GroupInfo->lInfoFlags;
		dpnGroup.dwGroupFlags = GroupInfo->lGroupFlags;
		dpnGroup.pwszName = wszName;

		hr = m__dxj_DirectPlayPeer->CreateGroup(&dpnGroup, NULL, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::AddPlayerToGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) AddPlayerToGroup call...\n");
		hr = m__dxj_DirectPlayPeer->AddPlayerToGroup((DPNID) idGroup, (DPNID) idClient, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetSendQueueInfo(long idPlayer, long *lNumMsgs, long *lNumBytes, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetSendQueueInfo call...\n");
		if (FAILED (hr = m__dxj_DirectPlayPeer->GetSendQueueInfo((DPNID) idPlayer, (DWORD*)lNumMsgs, (DWORD*)lNumBytes, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SetGroupInfo(long idGroup, DPN_GROUP_INFO_CDESC *PlayerInfo, long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_GROUP_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) SetGroupInfo call...\n");

		ZeroMemory(&dpInfo, sizeof(DPN_GROUP_INFO) );

		dpInfo.dwSize = sizeof(DPN_GROUP_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwGroupFlags = PlayerInfo->lGroupFlags;

		hr = m__dxj_DirectPlayPeer->SetGroupInfo((DPNID) idGroup, &dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetGroupInfo(long idGroup,long lFlags, DPN_GROUP_INFO_CDESC *layerInfo)
{
	HRESULT			hr;
	DPN_GROUP_INFO	*PlayerInfo = NULL;
	DWORD			dwInfoSize = 0;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetGroupInfo call...\n");
		hr = m__dxj_DirectPlayPeer->GetGroupInfo( (DPNID) idGroup, NULL, &dwInfoSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_GROUP_INFO*) new BYTE[ dwInfoSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		ZeroMemory( PlayerInfo, dwInfoSize );
		PlayerInfo->dwSize = sizeof(DPN_GROUP_INFO);
		hr = m__dxj_DirectPlayPeer->GetGroupInfo( (DPNID) idGroup, PlayerInfo, &dwInfoSize, (DWORD)lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_GROUP_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lGroupFlags = PlayerInfo->dwGroupFlags;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SetPeerInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_PLAYER_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) SetPeerInfo call...\n");
		ZeroMemory(&dpInfo, sizeof(DPN_PLAYER_INFO) );

		dpInfo.dwSize = sizeof(DPN_PLAYER_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwPlayerFlags = PlayerInfo->lPlayerFlags;

		hr = m__dxj_DirectPlayPeer->SetPeerInfo(&dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetPeerInfo(long idPeer,long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo)
{
	HRESULT				hr;
    DWORD				dwSize = 0;
    DPN_PLAYER_INFO		*PlayerInfo = NULL;
    
	DPF(1,"-----Entering (DplayPeer) GetPeerInfo call...\n");

	__try
	{
		hr = m__dxj_DirectPlayPeer->GetPeerInfo( (DPNID) idPeer, NULL, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		ZeroMemory( PlayerInfo, dwSize );
		PlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
		hr = m__dxj_DirectPlayPeer->GetPeerInfo( (DPNID) idPeer, PlayerInfo, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_PLAYER_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lPlayerFlags = PlayerInfo->dwPlayerFlags;
		// We no longer need the playerinfo we got.. get rid of it..
		SAFE_DELETE(PlayerInfo);
		return S_OK;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DPF(1,"***** GetPeerInfo ERROR...\n");
		return E_FAIL;
	}
}

HRESULT C_dxj_DirectPlayPeerObject::GetCountServiceProviders(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetCountSP call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(lFlags) ) )
				return hr;
		
		*ret = (long)m_dwSPCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret)
{
	HRESULT hr;
	GUID	*guidSP = NULL;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetSP call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(0) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwSPCount))
			return E_INVALIDARG;

		// Fill out our structure
		ret->lFlags = (long) m_SPInfo[lIndex-1].dwFlags;
		ret->Name = SysAllocString(m_SPInfo[lIndex-1].pwszName);

		guidSP = new GUID;
		if (!guidSP)
			return E_OUTOFMEMORY;

		memcpy(guidSP,&m_SPInfo[lIndex-1].guid,sizeof(GUID));
		ret->Guid = GUIDtoBSTR(guidSP);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetSP(long lFlags)
{
    // Enumerate all DirectPlay sevice providers
    
	HRESULT		hr;
	DWORD		dwSize=0;
	DWORD		dwItems=0;

	__try {
		SAFE_DELETE(m_SPInfo);
		hr = m__dxj_DirectPlayPeer->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_SPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
		if (!m_SPInfo)
			return E_OUTOFMEMORY;

		ZeroMemory(m_SPInfo, dwSize);
		if( FAILED( hr = m__dxj_DirectPlayPeer->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags ) ) )
			return hr;

		m_dwSPCount = dwItems;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetClientsAndGroups(long lFlags)
{
    // Enumerate all DirectPlay clients and groups
    
	HRESULT		hr;
	DWORD		dwSize=0;

	__try {
		SAFE_DELETE(m_ClientsGroups);
		hr = m__dxj_DirectPlayPeer->EnumPlayersAndGroups(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_ClientsGroups = (DPNID*) new BYTE[dwSize * sizeof(DPNID)];
		if (!m_ClientsGroups)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayPeer->EnumPlayersAndGroups(m_ClientsGroups, &dwSize, (DWORD) lFlags) ) )
			return hr;

		m_dwClientCount = dwSize;// sizeof(DPNID);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetGroupMembers(long lFlags, DPNID dpGroupID)
{
    // Enumerate all DirectPlay group members for this group
    
	HRESULT		hr;
	DWORD		dwSize=0;

	__try {
		SAFE_DELETE(m_GroupMembers);
		hr = m__dxj_DirectPlayPeer->EnumGroupMembers (dpGroupID, NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_GroupMembers = (DPNID*) new BYTE[dwSize * sizeof(DPNID)];
		if (!m_GroupMembers)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayPeer->EnumGroupMembers (dpGroupID, m_GroupMembers, &dwSize, (DWORD) lFlags) ) )
			return hr;

		m_dwGroupMemberCount = dwSize;
		m_dwGroupID = dpGroupID;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayPeerObject::RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) RegisterLobby call...\n");
		DO_GETOBJECT_NOTNULL( IDirectPlay8LobbiedApplication*, lpLobby, LobbyApp);

		if (FAILED( hr = m__dxj_DirectPlayPeer->RegisterLobby((DPNHANDLE) dpnHandle, lpLobby,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetConnectionInfo(long idPlayer, long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetConnectionInfo call...\n");
		pdpConnectionInfo->lSize = sizeof(DPN_CONNECTION_INFO);
		if (FAILED( hr = m__dxj_DirectPlayPeer->GetConnectionInfo((DPNID) idPlayer, (DPN_CONNECTION_INFO*)pdpConnectionInfo, lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetPeerAddress(long idPlayer,long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetPeerAddress call...\n");
		if (FAILED (hr = m__dxj_DirectPlayPeer->GetPeerAddress( (DPNID) idPlayer, &lpAdd, (DWORD) lFlags) ) )
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetLocalHostAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;
	DWORD	dwItems = 0;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetLocalHostAddress call...\n");
		hr = m__dxj_DirectPlayPeer->GetLocalHostAddresses( &lpAdd,&dwItems, (DWORD) lFlags);
		if (FAILED (hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		if (dwItems>1) 
			return E_INVALIDARG;

		if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address, (LPVOID*) &lpAdd ) ) )
				return hr;
		
		hr = m__dxj_DirectPlayPeer->GetLocalHostAddresses( &lpAdd,&dwItems, (DWORD) lFlags);
		if (FAILED (hr))
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DplayPeer) SetSPCaps call...\n");
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		spCaps->lSize = sizeof(DPN_SP_CAPS);
		//
		//	MiNara: Added 0 for dwFlags parameter
		//
		if (FAILED(hr = m__dxj_DirectPlayPeer->SetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetSPCaps call...\n");
		spCaps->lSize = sizeof(DPN_SP_CAPS);

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		if (FAILED(hr = m__dxj_DirectPlayPeer->GetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::TerminateSession(long lFlags, void *UserData, long UserDataSize)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) TerminateSession call...\n");
		if (FAILED (hr = m__dxj_DirectPlayPeer->TerminateSession(UserData,UserDataSize,(DWORD) lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT									hr = S_OK;
	LPUNKNOWN								lpUnk = NULL;
	BOOL									fCallCoUninit = FALSE;
	VARIANT_BOOL							fRejectMsg = VARIANT_FALSE;

	
	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayPeerObject	*lpPeer = (C_dxj_DirectPlayPeerObject*)pvUserContext;

	if (!lpPeer) 
		return S_OK; //Object must be gone

	DPF2(1,"-----Entering (DplayPeer) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageId );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer->m_fHandleEvents)
	{
		DPF(1,"-----Leaving (DplayPeer) MessageHandler call (*Not Handling Events*)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	if (!lpPeer->m_pEventStream) 
	{
		DPF(1,"-----Leaving (DplayPeer) MessageHandler call (Stream Not Present)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	
	I_dxj_DirectPlayEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			DPF1(1,"-----Calling CoInitEx... HR = %d\n", hr);
			CoInitializeEx(NULL,COINIT_MULTITHREADED);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF1(1,"-----Leaving (DplayPeer) MessageHandler call (No event interface)... HR = %d\n", hr);
			InterlockedDecrement(&lpPeer->m_dwMsgCount);
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DplayPeer) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPN_MSGID_RECEIVE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback Receive\n");
			DPNMSG_RECEIVE				*pMsgReceive = (DPNMSG_RECEIVE*)pMsgBuffer;
			DPNMSG_RECEIVE_CDESC		m_dpReceive;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPNMSG_RECEIVE_CDESC));
			m_dpReceive.idSender = pMsgReceive->dpnidSender;
			
			// Let's load our SafeArray

			if (pMsgReceive->dwReceiveDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = pMsgReceive->dwReceiveDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = pMsgReceive->pReceiveData;
				m_dpReceive.lDataSize = pMsgReceive->dwReceiveDataSize;
				m_dpReceive.ReceivedData = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Send complete
	case DPN_MSGID_SEND_COMPLETE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback SendComplete\n");
			DPNMSG_SEND_COMPLETE				*msg = (DPNMSG_SEND_COMPLETE*)pMsgBuffer;
			DPNMSG_SEND_COMPLETE_CDESC			m_dpSend;

			ZeroMemory(&m_dpSend, sizeof(DPNMSG_SEND_COMPLETE_CDESC));
			m_dpSend.AsyncOpHandle = (long)msg->hAsyncOp;
			m_dpSend.hResultCode = (long)msg->hResultCode;
			m_dpSend.lSendTime = (long)msg->dwSendTime;

			lpEvent->SendComplete(&m_dpSend, &fRejectMsg);
			break;
		}

	//Async Op complete
	case DPN_MSGID_ASYNC_OP_COMPLETE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback AsyncOpComplete\n");
			DPNMSG_ASYNC_OP_COMPLETE				*msg = (DPNMSG_ASYNC_OP_COMPLETE*)pMsgBuffer;
			DPNMSG_ASYNC_OP_COMPLETE_CDESC			m_dpAsynOp;
			
			ZeroMemory(&m_dpAsynOp, sizeof(DPNMSG_ASYNC_OP_COMPLETE_CDESC));
			m_dpAsynOp.AsyncOpHandle = (long) msg->hAsyncOp;
			m_dpAsynOp.hResultCode = (long) msg->hResultCode;

			lpEvent->AsyncOpComplete(&m_dpAsynOp, &fRejectMsg);
			break;
		}

	// Add/Remove players from groups
	case DPN_MSGID_ADD_PLAYER_TO_GROUP:
	case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
		{
			DPF(1,"-----DirectPlayPeer8 Callback Add/Remove Group\n");
			DPNMSG_ADD_PLAYER_TO_GROUP				*msg = (DPNMSG_ADD_PLAYER_TO_GROUP*)pMsgBuffer;
			DPNID									m_dpnidAddRemoveGroupID = 0;
			DPNID									m_dpnidAddRemovePlayerID = 0;

			m_dpnidAddRemoveGroupID = msg->dpnidGroup;
			m_dpnidAddRemovePlayerID = msg->dpnidPlayer;

			lpEvent->AddRemovePlayerGroup(dwMessageId, m_dpnidAddRemovePlayerID, m_dpnidAddRemoveGroupID, &fRejectMsg);
			break;
		}

	// App Desc
	case DPN_MSGID_APPLICATION_DESC:
		{
			DPF(1,"-----DirectPlayPeer8 Callback App desc\n");
			lpEvent->AppDesc(&fRejectMsg);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATE_CONNECT:
		{
			DPF(1,"-----DirectPlayPeer8 Callback Indicate Connect\n");
			DPNMSG_INDICATE_CONNECT				*msg = (DPNMSG_INDICATE_CONNECT*)pMsgBuffer;
			DPNMSG_INDICATE_CONNECT_CDESC		m_dpIndConnect;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;


			ZeroMemory(&m_dpIndConnect, sizeof(DPNMSG_INDICATE_CONNECT_CDESC));
			lpPeer->m_pUserData = msg->pvUserConnectData;
			lpPeer->m_dwUserDataSize = msg->dwUserConnectDataSize;

			__try {
				if (msg->pAddressPlayer)
				{
					hr = msg->pAddressPlayer->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						if (FAILED (hr = msg->pAddressPlayer->GetURLW(&wszAddress[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpIndConnect.AddressPlayerUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
						DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpIndConnect.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect -  Part2)...\n");
			}

			lpEvent->IndicateConnect(&m_dpIndConnect, &fRejectMsg);
			msg->pvReplyData = lpPeer->m_pReplyData;
			msg->dwReplyDataSize = lpPeer->m_dwReplyDataSize;
			// Get rid of these addresses
			if (m_dpIndConnect.AddressPlayerUrl)
				SysFreeString(m_dpIndConnect.AddressPlayerUrl);

			if (m_dpIndConnect.AddressDeviceUrl)
				SysFreeString(m_dpIndConnect.AddressDeviceUrl);
		break;
		}

	// Connect complete
	case DPN_MSGID_CONNECT_COMPLETE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback ConnectComplete\n");
			DPNMSG_CONNECT_COMPLETE				*msg = (DPNMSG_CONNECT_COMPLETE*)pMsgBuffer;
			DPNMSG_CONNECT_COMPLETE_CDESC		m_dpConnectComp;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpConnectComp, sizeof(DPNMSG_CONNECT_COMPLETE_CDESC));
			m_dpConnectComp.hResultCode = (long) msg->hResultCode;
			m_dpConnectComp.AsyncOpHandle =(long) msg->hAsyncOp;
			// Let's load our SafeArray

			if (msg->dwApplicationReplyDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwApplicationReplyDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvApplicationReplyData;
				m_dpConnectComp.ReplyData = lpData;
			}

			lpEvent->ConnectComplete(&m_dpConnectComp, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
		break;
		}

	// Host migrated
	case DPN_MSGID_HOST_MIGRATE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback HostMigrate\n");
			DPNMSG_HOST_MIGRATE				*msg = (DPNMSG_HOST_MIGRATE*)pMsgBuffer;
			DPNID							m_dpnidNewHostID = 0;

			m_dpnidNewHostID = msg->dpnidNewHost;

			lpEvent->HostMigrate(m_dpnidNewHostID, &fRejectMsg);
	
			break;
		}

	// Terminate Session
	case DPN_MSGID_TERMINATE_SESSION:
		{
			DPF(1,"-----DirectPlayPeer8 Callback TerminateSession\n");
			DPNMSG_TERMINATE_SESSION		*msg = (DPNMSG_TERMINATE_SESSION*)pMsgBuffer;
			DPNMSG_TERMINATE_SESSION_CDESC			m_dpTerm;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpTerm, sizeof(DPNMSG_TERMINATE_SESSION_CDESC));
			m_dpTerm.hResultCode = msg->hResultCode;

			// Let's load our SafeArray

			if (msg->dwTerminateDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwTerminateDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvTerminateData;
				m_dpTerm.TerminateData = lpData;
			}

			lpEvent->TerminateSession(&m_dpTerm,&fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

		break;
		}

	// Enum Host query
	case DPN_MSGID_ENUM_HOSTS_QUERY:
		{
			DPF(1,"-----DirectPlayPeer8 Callback EnumHostQuery\n");
			DPNMSG_ENUM_HOSTS_QUERY				*msg = (DPNMSG_ENUM_HOSTS_QUERY*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_QUERY_CDESC			m_dpEnumHostQuery;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;

			
			ZeroMemory(&m_dpEnumHostQuery, sizeof(DPNMSG_ENUM_HOSTS_QUERY_CDESC));

			__try {
				hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressSender->GetURLW(&wszAddress[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressSenderUrl = SysAllocString(wszAddress);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part2)...\n");
			}
			lpEvent->EnumHostsQuery(&m_dpEnumHostQuery, &fRejectMsg);

			// Get rid of these addresses
			if (m_dpEnumHostQuery.AddressSenderUrl)
				SysFreeString(m_dpEnumHostQuery.AddressSenderUrl);

			if (m_dpEnumHostQuery.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostQuery.AddressDeviceUrl);

			break;
		}
	
	// Create Player
	case DPN_MSGID_CREATE_PLAYER:
		{
			DPF(1,"-----DirectPlayPeer8 Callback CreatePlayer\n");
			DPNMSG_CREATE_PLAYER	*msg = (DPNMSG_CREATE_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;

			lpEvent->CreatePlayer(m_dpnidPlayerID, &fRejectMsg);
			
		break;
		}

	// Destroy Player
	case DPN_MSGID_DESTROY_PLAYER:
		{
			DPF(1,"-----DirectPlayPeer8 Callback DestroyPlayer\n");
			DPNMSG_DESTROY_PLAYER	*msg = (DPNMSG_DESTROY_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;
			m_dwReason = msg->dwReason;
			
			lpEvent->DestroyPlayer(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}

	// Create Group
	case DPN_MSGID_CREATE_GROUP:
		{
			DPF(1,"-----DirectPlayPeer8 Callback CreateGroup\n");
			DPNMSG_CREATE_GROUP	*msg = (DPNMSG_CREATE_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DPNID									m_dpnidOwnerID = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dpnidOwnerID = msg->dpnidOwner;
			
			lpEvent->CreateGroup(m_dpnidPlayerID, m_dpnidOwnerID, &fRejectMsg);
		break;
		}

	//Destroy Group
	case DPN_MSGID_DESTROY_GROUP:
		{
			DPF(1,"-----DirectPlayPeer8 Callback DestroyGroup\n");
			DPNMSG_DESTROY_GROUP	*msg = (DPNMSG_DESTROY_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dwReason = msg->dwReason;
			

			lpEvent->DestroyGroup(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}


	// Info
	case DPN_MSGID_PEER_INFO:
	case DPN_MSGID_CLIENT_INFO:
	case DPN_MSGID_SERVER_INFO:
	case DPN_MSGID_GROUP_INFO:
		{
			DPF(1,"-----DirectPlayPeer8 Callback Info\n");
			DPNMSG_PEER_INFO	*msg = (DPNMSG_PEER_INFO*)pMsgBuffer;
			DPNID									m_dpnidInfoID = 0;
			
			m_dpnidInfoID = msg->dpnidPeer;

			lpEvent->InfoNotify(dwMessageId, m_dpnidInfoID, &fRejectMsg);
			break;
		}

	// EnumHostRes
	case DPN_MSGID_ENUM_HOSTS_RESPONSE:
		{
			DPF(1,"-----DirectPlayPeer8 Callback EnumHostResponse\n");
			DPNMSG_ENUM_HOSTS_RESPONSE	*msg = (DPNMSG_ENUM_HOSTS_RESPONSE*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_RESPONSE_CDESC		m_dpEnumHostRes;
			DWORD									dwNumChars = 0;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];

			
			ZeroMemory(&m_dpEnumHostRes, sizeof(DPNMSG_ENUM_HOSTS_RESPONSE_CDESC));

			m_dpEnumHostRes.ApplicationDescription.lSize = (long)msg->pApplicationDescription->dwSize;
			m_dpEnumHostRes.ApplicationDescription.lFlags = msg->pApplicationDescription->dwFlags;
			m_dpEnumHostRes.ApplicationDescription.guidInstance = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidInstance);
			m_dpEnumHostRes.ApplicationDescription.guidApplication = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidApplication);
			m_dpEnumHostRes.ApplicationDescription.lMaxPlayers = (long)msg->pApplicationDescription->dwMaxPlayers;
			m_dpEnumHostRes.ApplicationDescription.lCurrentPlayers = (long)msg->pApplicationDescription->dwCurrentPlayers;
			m_dpEnumHostRes.ApplicationDescription.SessionName = SysAllocString(msg->pApplicationDescription->pwszSessionName);
			m_dpEnumHostRes.ApplicationDescription.Password = SysAllocString(msg->pApplicationDescription->pwszPassword);
			m_dpEnumHostRes.lRoundTripLatencyMS = (long) msg->dwRoundTripLatencyMS;

			__try {
				if (msg->pAddressSender)
				{
					DPF(1,"-----About to get AdressSender...\n");
					hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						DPF1(1,"--- About to call GetURLW, NumChars= %d\n",dwNumChars);
						if (FAILED (hr = msg->pAddressSender->GetURLW(&wszAddress[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressSenderUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				if (msg->pAddressDevice)
				{
					DPF(1,"-----About to get AdressDevice...\n");
					hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else {
						DPF1(1,"--- About to call GetURLW, NumChars= %d\n",dwNumChars);
						if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressDeviceUrl = SysAllocString(wszDevice);
						}
					}
				}
			
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}

			lpEvent->EnumHostsResponse(&m_dpEnumHostRes, &fRejectMsg);

			if (m_dpEnumHostRes.AddressSenderUrl)
				SysFreeString(m_dpEnumHostRes.AddressSenderUrl);

			if (m_dpEnumHostRes.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostRes.AddressDeviceUrl);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATED_CONNECT_ABORTED:
		{
			DPF(1,"-----DirectPlayServer8 Callback Indicated Connect Abort\n");

			lpEvent->IndicatedConnectAborted(&fRejectMsg);

		break;
		}
	}

	__try {
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DplayPeer) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

	if (fCallCoUninit)
		CoUninitialize();

	InterlockedDecrement(&lpPeer->m_dwMsgCount);
	DPF(1,"-----Leaving (DplayPeer) MessageHandler call...\n");
	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::RegisterMessageHandler(I_dxj_DirectPlayEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	if (!event) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		DPF(1,"-----Entering (DplayPeer) RegisterMessageHandler call...\n");
		SAFE_RELEASE(m_pEventStream);

		// Create a global stream.  The stream needs to be global so we can 
		// marshal once, and unmarshal as many times as necessary
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
		// so we can unmarshal any number of times
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;

		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayPeer->Initialize( this, DirectPlayMessageHandler, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayPeerObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DplayPeer) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	//Clear out the messages currently waiting
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (DplayPeer) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	while (m_dwMsgCount > dwNumMessagesLeft)
	{
		if (GetTickCount() - dwTime > 1000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (DplayPeer) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		Sleep(0);
	}
	DPF(1,"-----Leaving (DplayPeer) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}

DWORD WINAPI ClosePeerThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Peer	*lpPeer = (IDirectPlay8Peer*)lpParam;

	DPF(1,"-----Entering (DplayPeer) ClosePeerThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DplayPeer) ClosePeerThreadProc call ...\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplaypeerobj.h ===
#include "resource.h"       // main symbols
#include "dplay8.h"

//Forward declare the class
class C_dxj_DirectPlayPeerObject;

#define typedef__dxj_DirectPlayPeer IDirectPlay8Peer*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayPeerObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayPeer, &IID_I_dxj_DirectPlayPeer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayPeer,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayPeerObject() ;
	virtual ~C_dxj_DirectPlayPeerObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayPeerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayPeer)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayPeerObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayPeer
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE DestroyGroup(long idGroup,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE RemovePlayerFromGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE DestroyPeer(long idClient, long lFlags, void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE Connect(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address,I_dxj_DirectPlayAddress *DeviceInfo, long lFlags, void *UserData, long UserDataSize, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayEvent *event);
		HRESULT STDMETHODCALLTYPE EnumHosts(DPN_APPLICATION_DESC_CDESC *ApplicationDesc,I_dxj_DirectPlayAddress *AddrHost,I_dxj_DirectPlayAddress *DeviceInfo,long lRetryCount, long lRetryInterval, long lTimeOut,long lFlags, void *UserData, long UserDataSize, long *lAsync);
		HRESULT STDMETHODCALLTYPE GetCountServiceProviders(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret);

		// Enum for Clients/Groups
		HRESULT STDMETHODCALLTYPE GetCountPlayersAndGroups(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetPlayerOrGroup(long lIndex, long *ret);
		// Enum Players in groups
		HRESULT STDMETHODCALLTYPE GetCountGroupMembers(long dpid,long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetGroupMember(long lIndex,long dpid, long *ret);

		HRESULT STDMETHODCALLTYPE ReturnBuffer(long lBufferHandle);
		HRESULT STDMETHODCALLTYPE Host(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address, long lFlags );

		HRESULT STDMETHODCALLTYPE CancelAsyncOperation(long lAsyncHandle, long lFlags);
		HRESULT STDMETHODCALLTYPE GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC __RPC_FAR *ret);
		HRESULT STDMETHODCALLTYPE SetApplicationDesc(DPN_APPLICATION_DESC_CDESC *AppDesc, long lFlags);
		HRESULT STDMETHODCALLTYPE Close(long lFlags);
		HRESULT STDMETHODCALLTYPE GetCaps(long lFlags, DPNCAPS_CDESC __RPC_FAR *ret);
		HRESULT STDMETHODCALLTYPE SetCaps(DPNCAPS_CDESC __RPC_FAR *Caps, long lFlags);

		HRESULT STDMETHODCALLTYPE SendTo(long idSend ,SAFEARRAY **Buffer,long lTimeOut,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE CreateGroup(DPN_GROUP_INFO_CDESC *GroupInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE AddPlayerToGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetSendQueueInfo(long idPlayer, long *lNumMsgs, long *lNumBytes, long lFlags);
		HRESULT STDMETHODCALLTYPE SetGroupInfo(long idGroup, DPN_GROUP_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetGroupInfo(long idGroup,long lFlags, DPN_GROUP_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE SetPeerInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetPeerInfo(long idPeer,long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags);
		HRESULT STDMETHODCALLTYPE GetConnectionInfo(long idPlayer, long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo);
		
		HRESULT STDMETHODCALLTYPE GetPeerAddress(long idPlayer, long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE GetLocalHostAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags);
		HRESULT STDMETHODCALLTYPE GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps);
		HRESULT STDMETHODCALLTYPE TerminateSession(long lFlags, void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE GetUserData(void *UserData, long *UserDataSize);
		HRESULT STDMETHODCALLTYPE SetUserData(void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayPeer);

private:
    DPN_SERVICE_PROVIDER_INFO	*m_SPInfo;
	DWORD						m_dwSPCount;
	DPNID						*m_ClientsGroups;
	DPNID						*m_GroupMembers;
	DPNID						m_dwGroupID;
	DWORD						m_dwClientCount;
	DWORD						m_dwGroupMemberCount;
	BOOL						m_fInit;

	HRESULT STDMETHODCALLTYPE	GetSP(long lFlags);
	HRESULT STDMETHODCALLTYPE	GetClientsAndGroups(long lFlags);
	HRESULT STDMETHODCALLTYPE	GetGroupMembers(long lFlags, DPNID dpGroupID);
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayPeer);

	DWORD InternalAddRef();
	DWORD InternalRelease();
	
	// We need these for our user data vars
	void			*m_pUserData;
	DWORD			m_dwUserDataSize;
	// For our reply data
	void			*m_pReplyData;
	DWORD			m_dwReplyDataSize;

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

	//We need to keep a count of the messages
	LONG			m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayserverobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayServerObj.h"					   
#include "dplayaddressobj.h"

extern void *g_dxj_DirectPlayAddress;
extern void *g_dxj_DirectPlayServer;
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayServer SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

HRESULT WINAPI DirectPlayServerMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer );

DWORD WINAPI CloseServerThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayServerObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"----- DXVB: DirectPlayServer8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayServerObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"----- DXVB: DirectPlayServer8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayServerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayServerObject::C_dxj_DirectPlayServerObject(){ 
		
	DPF(1,"Constructor Creation  DirectPlayServer8 Object\n ");

	m__dxj_DirectPlayServer = NULL;

	m_fHandleEvents = FALSE;
	m_SPInfo = NULL;
	m_dwSPCount = 0;
	m_ClientsGroups = NULL;
	m_GroupMembers = NULL;
	m_dwGroupID = 0;
	m_dwClientCount = 0;
	m_dwGroupMemberCount = 0;
	m_ClientsGroups = NULL;
	m_GroupMembers = NULL;
	m_dwGroupID = 0;
	m_dwClientCount = 0;
	m_dwGroupMemberCount = 0;
	m_fInit = FALSE;
	m_pUserData = NULL;
	m_dwUserDataSize = 0;
	m_pReplyData = NULL;
	m_dwReplyDataSize = 0;

	m_fHandleEvents = FALSE;
	m_pEventStream=NULL;
	m_dwMsgCount = 0;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayServerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayServerObject::~C_dxj_DirectPlayServerObject()
{

	DPF(1,"----- Entering ~C_dxj_DirectPlayServerObject destructor \n");

	// Stop handling events and flush the buffer
	m_fHandleEvents = FALSE;
	FlushBuffer(0);

	SAFE_RELEASE(m__dxj_DirectPlayServer);
	SAFE_DELETE(m_SPInfo);
	SAFE_DELETE(m_ClientsGroups);
	SAFE_DELETE(m_GroupMembers);

	if (m_pEventStream) 
		m_pEventStream->Release();
}

HRESULT C_dxj_DirectPlayServerObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayServer;
	
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayServer=(IDirectPlay8Server*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetCountPlayersAndGroups(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetCountPlayersAndGroups call...\n");
		// On the GetCount call we will always get the latest info
		if (FAILED ( hr = GetClientsAndGroups(lFlags) ) )
			return hr;
		
		*ret = m_dwClientCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetPlayerOrGroup(long lIndex, long *ret)
{
	__try {
		DPF(1,"-----Entering (DPlayServer) GetPlayerOrGroup call...\n");
		if (!m_ClientsGroups)
			return E_INVALIDARG;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwClientCount))
			return E_INVALIDARG;

		// Fill out our structure
		*ret = m_ClientsGroups[lIndex - 1];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetCountGroupMembers(long dpid,long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetCountGroupMemberss call...\n");
		// On the GetCount call we will always get the latest info
		if (FAILED ( hr = GetGroupMembers(lFlags, (DPNID) dpid) ) )
			return hr;
		
		*ret = m_dwGroupMemberCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetGroupMember(long lIndex,long dpid, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetGroupMember call...\n");
		if ((!m_GroupMembers) || ((DPNID)dpid != m_dwGroupID) )
			if (FAILED (hr = GetGroupMembers(0, (DPNID) dpid) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwGroupMemberCount))
			return E_INVALIDARG;

		// Fill out our structure
		if (!m_GroupMembers)
			return E_INVALIDARG;

		*ret = m_GroupMembers[lIndex - 1];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::CancelAsyncOperation(long lAsyncHandle, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) CancelAsyncOperation call...\n");
		if (FAILED( hr= m__dxj_DirectPlayServer->CancelAsyncOperation((DPNHANDLE) lAsyncHandle, (DWORD) lFlags) ) ) 
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SendTo(long idSend ,SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_BUFFER_DESC		lpBuf;
	DWORD				dwBufSize = ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		DPF(1,"-----Entering (DPlayServer) SendTo call...\n");
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}
			
		lpBuf.dwBufferSize = dwBufSize;
		lpBuf.pBufferData  = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

		hr = m__dxj_DirectPlayServer->SendTo((DPNID) idSend, &lpBuf, 1, (DWORD) lTimeOut, NULL, dpAsync, (DWORD) lFlags);
		
		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::CreateGroup(DPN_GROUP_INFO_CDESC *GroupInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT			hr;
	DPN_GROUP_INFO	dpnGroup;
    WCHAR			wszName[MAX_PATH];
	DPNHANDLE		*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) CreateGroup call...\n");
		if (!IsEmptyString(GroupInfo->Name)) wcscpy(wszName,GroupInfo->Name);

		ZeroMemory(&dpnGroup, sizeof(DPN_GROUP_INFO) );
		dpnGroup.dwSize = sizeof(DPN_GROUP_INFO);
		dpnGroup.dwInfoFlags = GroupInfo->lInfoFlags;
		dpnGroup.dwGroupFlags = GroupInfo->lGroupFlags;
		dpnGroup.pwszName = wszName;

		hr = m__dxj_DirectPlayServer->CreateGroup(&dpnGroup, NULL, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::AddPlayerToGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) AddPlayerToGroup call...\n");
		hr = m__dxj_DirectPlayServer->AddPlayerToGroup((DPNID) idGroup, (DPNID) idClient, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetSendQueueInfo(long idPlayer, long *lNumMsgs, long *lNumBytes, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetSendQueueInfo call...\n");
		if (FAILED (hr = m__dxj_DirectPlayServer->GetSendQueueInfo((DPNID) idPlayer, (DWORD*)lNumMsgs, (DWORD*)lNumBytes, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetGroupInfo(long idGroup, DPN_GROUP_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_GROUP_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) SetGroupInfo call...\n");
		ZeroMemory(&dpInfo, sizeof(DPN_GROUP_INFO) );

		dpInfo.dwSize = sizeof(DPN_GROUP_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwGroupFlags = PlayerInfo->lGroupFlags;

		hr = m__dxj_DirectPlayServer->SetGroupInfo((DPNID) idGroup, &dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetGroupInfo(long idGroup,long lFlags, DPN_GROUP_INFO_CDESC *layerInfo)
{
	HRESULT			hr;
	DPN_GROUP_INFO	*PlayerInfo = NULL;
	DWORD			dwInfoSize = 0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetGroupInfo call...\n");
		hr = m__dxj_DirectPlayServer->GetGroupInfo( (DPNID) idGroup, NULL, &dwInfoSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_GROUP_INFO*) new BYTE[ dwInfoSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		ZeroMemory( PlayerInfo, dwInfoSize );
		PlayerInfo->dwSize = sizeof(DPN_GROUP_INFO);
		hr = m__dxj_DirectPlayServer->GetGroupInfo( (DPNID) idGroup, PlayerInfo, &dwInfoSize, (DWORD) lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_GROUP_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lGroupFlags = PlayerInfo->dwGroupFlags;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetServerInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_PLAYER_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) SetServerInfo call...\n");
		ZeroMemory(&dpInfo, sizeof(DPN_PLAYER_INFO) );

		dpInfo.dwSize = sizeof(DPN_PLAYER_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwPlayerFlags = PlayerInfo->lPlayerFlags;

		hr = m__dxj_DirectPlayServer->SetServerInfo(&dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetClientInfo(long idPeer,long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo)
{
	HRESULT				hr;
    DWORD				dwSize = 0;
    DPN_PLAYER_INFO		*PlayerInfo = NULL;
    
	__try {
		DPF(1,"-----Entering (DPlayServer) GetClientInfo call...\n");
		hr = m__dxj_DirectPlayServer->GetClientInfo( (DPNID) idPeer, NULL, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		ZeroMemory( PlayerInfo, dwSize );
		PlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
		hr = m__dxj_DirectPlayServer->GetClientInfo( (DPNID) idPeer, PlayerInfo, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_PLAYER_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lPlayerFlags = PlayerInfo->dwPlayerFlags;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;

}

HRESULT C_dxj_DirectPlayServerObject::GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret)
{
	HRESULT					hr;
	DWORD					dwSize = 0;
	DPN_APPLICATION_DESC	*desc = NULL;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetApplicationDesc call...\n");
		//First get the size
		hr = m__dxj_DirectPlayServer->GetApplicationDesc(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPN_APPLICATION_DESC*) new BYTE[dwSize];
		if (!desc)
			return E_OUTOFMEMORY;

		ZeroMemory(desc, dwSize);

		desc->dwSize = sizeof(DPN_APPLICATION_DESC);
		if (FAILED( hr= m__dxj_DirectPlayServer->GetApplicationDesc(desc, &dwSize, (DWORD) lFlags) ) )
			return hr;

		// Now return the vals 
		ret->lSize = dwSize;
		ret->lFlags = desc->dwFlags;
		ret->guidInstance = GUIDtoBSTR(&desc->guidInstance);
		ret->guidApplication = GUIDtoBSTR(&desc->guidApplication);
		ret->lMaxPlayers = desc->dwMaxPlayers;
		ret->lCurrentPlayers = desc->dwCurrentPlayers;
		ret->SessionName = SysAllocString(desc->pwszSessionName);
		ret->Password = SysAllocString(desc->pwszPassword);
		SAFE_DELETE(desc);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetApplicationDesc(DPN_APPLICATION_DESC_CDESC *AppDesc, long lFlags)
{
	HRESULT					hr;
	DPN_APPLICATION_DESC	*desc = NULL;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	GUID					guidApp;
	DWORD					dwSize = 0;

	__try {
		DPF(1,"-----Entering (DPlayServer) SetApplicationDesc call...\n");
	
		desc = new DPN_APPLICATION_DESC;
		if (!desc)
			return E_OUTOFMEMORY;

		ZeroMemory(desc, sizeof(DPN_APPLICATION_DESC));

		desc->dwSize = sizeof(DPN_APPLICATION_DESC);

		if (!IsEmptyString(AppDesc->SessionName))
		{
			wcscpy(wszSessionName,AppDesc->SessionName);
			desc->pwszSessionName = wszSessionName;
		}
		if (!IsEmptyString(AppDesc->Password)) 
		{
			wcscpy(wszPassword,AppDesc->Password);
			desc->pwszPassword = wszPassword;
		}
		
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, AppDesc->guidApplication) ) )
			return hr;
		desc->guidApplication = guidApp;

		desc->dwMaxPlayers = AppDesc->lMaxPlayers;

		if (FAILED( hr= m__dxj_DirectPlayServer->SetApplicationDesc(desc, (DWORD) lFlags) ) )
			return hr;

		SAFE_DELETE(desc);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayServerObject::Host(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address, long lFlags)
{
	HRESULT hr;
	DPN_APPLICATION_DESC	desc;
    WCHAR wszSessionName[MAX_PATH];
    WCHAR wszPassword[MAX_PATH];

	__try {
		DPF(1,"-----Entering (DPlayServer) Host call...\n");
		if (!IsEmptyString(AppDesc->SessionName)) wcscpy(wszSessionName,AppDesc->SessionName);
		if (!IsEmptyString(AppDesc->Password)) wcscpy(wszPassword,AppDesc->Password);
		
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpAddress, Address);

		ZeroMemory(&desc, sizeof(DPN_APPLICATION_DESC) );

		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = AppDesc->lFlags;
		desc.dwMaxPlayers = AppDesc->lMaxPlayers;
		desc.dwCurrentPlayers = AppDesc->lCurrentPlayers;
		if (!IsEmptyString(AppDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(AppDesc->Password))
			desc.pwszPassword = wszPassword;

		if (AppDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidApplication, AppDesc->guidApplication) ) )
				return hr;
		}

		if (AppDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidInstance , AppDesc->guidInstance) ) )
				return hr;
		}

		if (FAILED (hr = m__dxj_DirectPlayServer->Host(&desc, &lpAddress, 1, NULL, NULL, NULL, (DWORD) lFlags ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::Close(long lFlags)
{
	HRESULT hr;
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;

	__try {
		DPF(1,"-----Entering (DPlayServer) Close call...\n");
		FlushBuffer(0);

		HANDLE hThread = NULL;
		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, &CloseServerThreadProc, this->m__dxj_DirectPlayServer, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetCaps(long lFlags, DPNCAPS_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetCaps call...\n");
		ret->lSize = sizeof(DPN_CAPS);
		if (FAILED (hr=m__dxj_DirectPlayServer->GetCaps( (DPN_CAPS*) ret, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetCaps(DPNCAPS_CDESC *Caps, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) SetCaps call...\n");
		if (FAILED( hr = m__dxj_DirectPlayServer->SetCaps((DPN_CAPS*)Caps, (DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::RemovePlayerFromGroup(long idGroup, long idClient,long lFlags,long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) RemovePlayerFromGroup call...\n");
		hr = m__dxj_DirectPlayServer->RemovePlayerFromGroup( (DPNID) idGroup,
						(DPNID) idClient, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::ReturnBuffer(long lBufferHandle)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) ReturnBuffer call...\n");
		if (FAILED(hr = m__dxj_DirectPlayServer->ReturnBuffer( (DPNHANDLE) lBufferHandle, 0 ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::DestroyClient(long idClient, long lFlags, void *UserData, long UserDataSize)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) DestroyClient call...\n");
		if (FAILED( hr= m__dxj_DirectPlayServer->DestroyClient((DPNID) idClient, UserData, UserDataSize, (DWORD) lFlags) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::DestroyGroup(long idGroup,long lFlags,long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayServer) DestroyGroup call...\n");
		hr= m__dxj_DirectPlayServer->DestroyGroup((DPNID) idGroup, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayServerObject::RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) RegisterLobby call...\n");
		DO_GETOBJECT_NOTNULL( IDirectPlay8LobbiedApplication*, lpLobby, LobbyApp);

		if (FAILED( hr = m__dxj_DirectPlayServer->RegisterLobby((DPNHANDLE) dpnHandle, lpLobby,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetCountServiceProviders(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetCountServiceProviders call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(lFlags) ) )
				return hr;
		
		*ret = (long)m_dwSPCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetServiceProvider call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(0) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwSPCount))
			return E_INVALIDARG;

		// Fill out our structure
		ret->lFlags = (long) m_SPInfo[lIndex-1].dwFlags;
		ret->Name = SysAllocString(m_SPInfo[lIndex-1].pwszName);

		ret->Guid = GUIDtoBSTR(&m_SPInfo[lIndex-1].guid);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetSP(long lFlags)
{
    // Enumerate all DirectPlay sevice providers
    
	HRESULT		hr;
	DWORD		dwSize=0;
	DWORD		dwItems=0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetSP call...\n");
		SAFE_DELETE(m_SPInfo);
		hr = m__dxj_DirectPlayServer->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_SPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
		if (!m_SPInfo)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayServer->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags ) ) )
			return hr;

		m_dwSPCount = dwItems;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
HRESULT C_dxj_DirectPlayServerObject::GetClientsAndGroups(long lFlags)
{
    // Enumerate all DirectPlay clients and groups
    
	HRESULT		hr;
	DWORD		dwSize=0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetClientsAndGroups call...\n");
		SAFE_DELETE(m_ClientsGroups);
		hr = m__dxj_DirectPlayServer->EnumPlayersAndGroups(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_ClientsGroups = (DPNID*) new BYTE[dwSize * sizeof(DPNID)];
		if (!m_ClientsGroups)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayServer->EnumPlayersAndGroups(m_ClientsGroups, &dwSize, (DWORD) lFlags) ) )
			return hr;

		m_dwClientCount = dwSize;// sizeof(DPNID);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetGroupMembers(long lFlags, DPNID dpGroupID)
{
    // Enumerate all DirectPlay group members for this group
    
	HRESULT		hr;
	DWORD		dwSize=0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetGroupMembers call...\n");
		SAFE_DELETE(m_GroupMembers);
		hr = m__dxj_DirectPlayServer->EnumGroupMembers(dpGroupID, NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_GroupMembers = new DPNID[dwSize];
		if (!m_GroupMembers)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayServer->EnumGroupMembers(dpGroupID, m_GroupMembers, &dwSize, (DWORD) lFlags) ) )
			return hr;

		m_dwGroupMemberCount = dwSize;
		m_dwGroupID = dpGroupID;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetConnectionInfo(long idPlayer, long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetConnectionInfo call...\n");
		pdpConnectionInfo->lSize = sizeof(DPN_CONNECTION_INFO);
		if (FAILED( hr = m__dxj_DirectPlayServer->GetConnectionInfo((DPNID) idPlayer, (DPN_CONNECTION_INFO*)pdpConnectionInfo, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetClientAddress(long idPlayer,long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetClientAddress call...\n");
		if (FAILED (hr = m__dxj_DirectPlayServer->GetClientAddress( (DPNID) idPlayer, &lpAdd, (DWORD) lFlags) ) )
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetLocalHostAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;
	DWORD	dwItems = 0;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetLocalHostAddress call...\n");
		hr = m__dxj_DirectPlayServer->GetLocalHostAddresses( &lpAdd,&dwItems, (DWORD) lFlags);
		if (FAILED (hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		if (dwItems>1) 
			return E_INVALIDARG;

		if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address, (LPVOID*) &lpAdd ) ) )
				return hr;
		
		hr = m__dxj_DirectPlayServer->GetLocalHostAddresses( &lpAdd,&dwItems, (DWORD) lFlags);
		if (FAILED (hr))
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DPlayServer) SetSPCaps call...\n");
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		spCaps->lSize = sizeof(DPN_SP_CAPS);
		//
		//	MiNara: Added 0 for dwFlags parameter
		//
		if (FAILED(hr = m__dxj_DirectPlayServer->SetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps,(DWORD) lFlags) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DPlayServer) GetSPCaps call...\n");
		spCaps->lSize = sizeof(DPN_SP_CAPS);
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		if (FAILED(hr = m__dxj_DirectPlayServer->GetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps, (DWORD) lFlags) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}


HRESULT WINAPI DirectPlayServerMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT					hr=S_OK;
	LPUNKNOWN			    lpUnk=NULL;
	BOOL					fCallCoUninit = FALSE;
	VARIANT_BOOL			fRejectMsg = VARIANT_FALSE;
	
	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayServerObject	*lpPeer = (C_dxj_DirectPlayServerObject*)pvUserContext;

	if (!lpPeer) 
		return S_OK; //Object must be gone

	DPF2(1,"-----Entering (DPlayServer) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageId );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer->m_fHandleEvents)
	{
		DPF(1,"-----Leaving (DPlayServer) MessageHandler call (*Not Handling Events*)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	if (!lpPeer->m_pEventStream) 
	{
		DPF(1,"-----Leaving (DPlayServer) MessageHandler call (Stream Not Present)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	
	I_dxj_DirectPlayEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			CoInitializeEx(NULL,COINIT_MULTITHREADED);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF(1,"-----Leaving (DPlayServer) MessageHandler call (No event interface)...\n");
			InterlockedDecrement(&lpPeer->m_dwMsgCount);
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DPlayServer) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPN_MSGID_RECEIVE:
		{
			DPF(1,"-----DirectPlayServer8 Callback Receive\n");
			DPNMSG_RECEIVE				*pMsgReceive = (DPNMSG_RECEIVE*)pMsgBuffer;
			DPNMSG_RECEIVE_CDESC		m_dpReceive;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPNMSG_RECEIVE_CDESC));
			m_dpReceive.idSender = pMsgReceive->dpnidSender;
			
			// Let's load our SafeArray

			if (pMsgReceive->dwReceiveDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = pMsgReceive->dwReceiveDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = pMsgReceive->pReceiveData;
				m_dpReceive.lDataSize = pMsgReceive->dwReceiveDataSize;
				m_dpReceive.ReceivedData = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Send complete
	case DPN_MSGID_SEND_COMPLETE:
		{
			DPF(1,"-----DirectPlayServer8 Callback SendComplete\n");
			DPNMSG_SEND_COMPLETE				*msg = (DPNMSG_SEND_COMPLETE*)pMsgBuffer;
			DPNMSG_SEND_COMPLETE_CDESC			m_dpSend;

			ZeroMemory(&m_dpSend, sizeof(DPNMSG_SEND_COMPLETE_CDESC));
			m_dpSend.AsyncOpHandle = (long)msg->hAsyncOp;
			m_dpSend.hResultCode = (long)msg->hResultCode;
			m_dpSend.lSendTime = (long)msg->dwSendTime;

			lpEvent->SendComplete(&m_dpSend, &fRejectMsg);
			break;
		}

	//Async Op complete
	case DPN_MSGID_ASYNC_OP_COMPLETE:
		{
			DPF(1,"-----DirectPlayServer8 Callback AsyncOpComplete\n");
			DPNMSG_ASYNC_OP_COMPLETE				*msg = (DPNMSG_ASYNC_OP_COMPLETE*)pMsgBuffer;
			DPNMSG_ASYNC_OP_COMPLETE_CDESC			m_dpAsynOp;
			
			ZeroMemory(&m_dpAsynOp, sizeof(DPNMSG_ASYNC_OP_COMPLETE_CDESC));
			m_dpAsynOp.AsyncOpHandle = (long) msg->hAsyncOp;
			m_dpAsynOp.hResultCode = (long) msg->hResultCode;

			lpEvent->AsyncOpComplete(&m_dpAsynOp, &fRejectMsg);
			break;
		}

	// Add/Remove players from groups
	case DPN_MSGID_ADD_PLAYER_TO_GROUP:
	case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
		{
			DPF(1,"-----DirectPlayServer8 Callback Add/Remove Group\n");
			DPNMSG_ADD_PLAYER_TO_GROUP				*msg = (DPNMSG_ADD_PLAYER_TO_GROUP*)pMsgBuffer;
			DPNID									m_dpnidAddRemoveGroupID = 0;
			DPNID									m_dpnidAddRemovePlayerID = 0;

			m_dpnidAddRemoveGroupID = msg->dpnidGroup;
			m_dpnidAddRemovePlayerID = msg->dpnidPlayer;

			lpEvent->AddRemovePlayerGroup(dwMessageId, m_dpnidAddRemovePlayerID, m_dpnidAddRemoveGroupID, &fRejectMsg);
			break;
		}

	// App Desc
	case DPN_MSGID_APPLICATION_DESC:
		{
			DPF(1,"-----DirectPlayServer8 Callback App desc\n");
			lpEvent->AppDesc(&fRejectMsg);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATE_CONNECT:
		{
			DPF(1,"-----DirectPlayServer8 Callback Indicate Connect\n");
			DPNMSG_INDICATE_CONNECT				*msg = (DPNMSG_INDICATE_CONNECT*)pMsgBuffer;
			DPNMSG_INDICATE_CONNECT_CDESC		m_dpIndConnect;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;


			ZeroMemory(&m_dpIndConnect, sizeof(DPNMSG_INDICATE_CONNECT_CDESC));
			lpPeer->m_pUserData = msg->pvUserConnectData;
			lpPeer->m_dwUserDataSize = msg->dwUserConnectDataSize;

			__try {
				if (msg->pAddressPlayer)
				{
					hr = msg->pAddressPlayer->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						if (FAILED (hr = msg->pAddressPlayer->GetURLW(&wszAddress[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpIndConnect.AddressPlayerUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
						DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpIndConnect.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect -  Part2)...\n");
			}

			lpEvent->IndicateConnect(&m_dpIndConnect, &fRejectMsg);
			msg->pvReplyData = lpPeer->m_pReplyData;
			msg->dwReplyDataSize = lpPeer->m_dwReplyDataSize;
			// Get rid of these addresses
			if (m_dpIndConnect.AddressPlayerUrl)
				SysFreeString(m_dpIndConnect.AddressPlayerUrl);

			if (m_dpIndConnect.AddressDeviceUrl)
				SysFreeString(m_dpIndConnect.AddressDeviceUrl);
		break;
		}

	// Connect complete
	case DPN_MSGID_CONNECT_COMPLETE:
		{
			DPF(1,"-----DirectPlayServer8 Callback ConnectComplete\n");
			DPNMSG_CONNECT_COMPLETE				*msg = (DPNMSG_CONNECT_COMPLETE*)pMsgBuffer;
			DPNMSG_CONNECT_COMPLETE_CDESC		m_dpConnectComp;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpConnectComp, sizeof(DPNMSG_CONNECT_COMPLETE_CDESC));
			m_dpConnectComp.hResultCode = (long) msg->hResultCode;
			m_dpConnectComp.AsyncOpHandle =(long) msg->hAsyncOp;
			// Let's load our SafeArray

			if (msg->dwApplicationReplyDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwApplicationReplyDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvApplicationReplyData;
				m_dpConnectComp.ReplyData = lpData;
			}

			lpEvent->ConnectComplete(&m_dpConnectComp, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
		break;
		}

	// Host migrated
	case DPN_MSGID_HOST_MIGRATE:
		{
			DPF(1,"-----DirectPlayServer8 Callback HostMigrate\n");
			DPNMSG_HOST_MIGRATE				*msg = (DPNMSG_HOST_MIGRATE*)pMsgBuffer;
			DPNID							m_dpnidNewHostID = 0;

			m_dpnidNewHostID = msg->dpnidNewHost;

			lpEvent->HostMigrate(m_dpnidNewHostID, &fRejectMsg);
	
			break;
		}

	// Terminate Session
	case DPN_MSGID_TERMINATE_SESSION:
		{
			DPF(1,"-----DirectPlayServer8 Callback TerminateSession\n");
			DPNMSG_TERMINATE_SESSION		*msg = (DPNMSG_TERMINATE_SESSION*)pMsgBuffer;
			DPNMSG_TERMINATE_SESSION_CDESC			m_dpTerm;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpTerm, sizeof(DPNMSG_TERMINATE_SESSION_CDESC));
			m_dpTerm.hResultCode = msg->hResultCode;

			// Let's load our SafeArray

			if (msg->dwTerminateDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwTerminateDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvTerminateData;
				m_dpTerm.TerminateData = lpData;
			}

			lpEvent->TerminateSession(&m_dpTerm,&fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

		break;
		}

	// Enum Host query
	case DPN_MSGID_ENUM_HOSTS_QUERY:
		{
			DPF(1,"-----DirectPlayServer8 Callback EnumHostQuery\n");
			DPNMSG_ENUM_HOSTS_QUERY				*msg = (DPNMSG_ENUM_HOSTS_QUERY*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_QUERY_CDESC			m_dpEnumHostQuery;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;

			
			ZeroMemory(&m_dpEnumHostQuery, sizeof(DPNMSG_ENUM_HOSTS_QUERY_CDESC));

			__try {
				hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressSender->GetURLW(&wszAddress[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressSenderUrl = SysAllocString(wszAddress);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part2)...\n");
			}
			lpEvent->EnumHostsQuery(&m_dpEnumHostQuery, &fRejectMsg);

			// Get rid of these addresses
			if (m_dpEnumHostQuery.AddressSenderUrl)
				SysFreeString(m_dpEnumHostQuery.AddressSenderUrl);

			if (m_dpEnumHostQuery.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostQuery.AddressDeviceUrl);

			break;
		}
	
	// Create Player
	case DPN_MSGID_CREATE_PLAYER:
		{
			DPF(1,"-----DirectPlayServer8 Callback CreatePlayer\n");
			DPNMSG_CREATE_PLAYER	*msg = (DPNMSG_CREATE_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;

			lpEvent->CreatePlayer(m_dpnidPlayerID, &fRejectMsg);
			
		break;
		}

	// Destroy Player
	case DPN_MSGID_DESTROY_PLAYER:
		{
			DPF(1,"-----DirectPlayServer8 Callback DestroyPlayer\n");
			DPNMSG_DESTROY_PLAYER	*msg = (DPNMSG_DESTROY_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;
			m_dwReason = msg->dwReason;
			
			lpEvent->DestroyPlayer(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}

	// Create Group
	case DPN_MSGID_CREATE_GROUP:
		{
			DPF(1,"-----DirectPlayServer8 Callback CreateGroup\n");
			DPNMSG_CREATE_GROUP	*msg = (DPNMSG_CREATE_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DPNID									m_dpnidOwnerID = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dpnidOwnerID = msg->dpnidOwner;
			
			lpEvent->CreateGroup(m_dpnidPlayerID, m_dpnidOwnerID, &fRejectMsg);
		break;
		}

	//Destroy Group
	case DPN_MSGID_DESTROY_GROUP:
		{
			DPF(1,"-----DirectPlayServer8 Callback DestroyGroup\n");
			DPNMSG_DESTROY_GROUP	*msg = (DPNMSG_DESTROY_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dwReason = msg->dwReason;
			

			lpEvent->DestroyGroup(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}


	// Info
	case DPN_MSGID_PEER_INFO:
	case DPN_MSGID_CLIENT_INFO:
	case DPN_MSGID_SERVER_INFO:
	case DPN_MSGID_GROUP_INFO:
		{
			DPF(1,"-----DirectPlayServer8 Callback Info\n");
			DPNMSG_PEER_INFO	*msg = (DPNMSG_PEER_INFO*)pMsgBuffer;
			DPNID									m_dpnidInfoID = 0;
			
			m_dpnidInfoID = msg->dpnidPeer;

			lpEvent->InfoNotify(dwMessageId, m_dpnidInfoID, &fRejectMsg);
			break;
		}

	// EnumHostRes
	case DPN_MSGID_ENUM_HOSTS_RESPONSE:
		{
			DPF(1,"-----DirectPlayServer8 Callback EnumHostResponse\n");
			DPNMSG_ENUM_HOSTS_RESPONSE	*msg = (DPNMSG_ENUM_HOSTS_RESPONSE*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_RESPONSE_CDESC		m_dpEnumHostRes;
			DWORD									dwNumChars = 0;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];

			
			ZeroMemory(&m_dpEnumHostRes, sizeof(DPNMSG_ENUM_HOSTS_RESPONSE_CDESC));

			m_dpEnumHostRes.ApplicationDescription.lSize = (long)msg->pApplicationDescription->dwSize;
			m_dpEnumHostRes.ApplicationDescription.lFlags = msg->pApplicationDescription->dwFlags;
			m_dpEnumHostRes.ApplicationDescription.guidInstance = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidInstance);
			m_dpEnumHostRes.ApplicationDescription.guidApplication = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidApplication);
			m_dpEnumHostRes.ApplicationDescription.lMaxPlayers = (long)msg->pApplicationDescription->dwMaxPlayers;
			m_dpEnumHostRes.ApplicationDescription.lCurrentPlayers = (long)msg->pApplicationDescription->dwCurrentPlayers;
			m_dpEnumHostRes.ApplicationDescription.SessionName = SysAllocString(msg->pApplicationDescription->pwszSessionName);
			m_dpEnumHostRes.ApplicationDescription.Password = SysAllocString(msg->pApplicationDescription->pwszPassword);
			m_dpEnumHostRes.lRoundTripLatencyMS = (long) msg->dwRoundTripLatencyMS;

			__try {
				if (msg->pAddressSender)
				{
					DPF(1,"-----About to get AdressSender...\n");
					hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						if (FAILED (hr = msg->pAddressSender->GetURLW(&wszAddress[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressSenderUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				if (msg->pAddressDevice)
				{
					DPF(1,"-----About to get AdressDevice...\n");
					hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else {
						if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressDeviceUrl = SysAllocString(wszDevice);
						}
					}
				}
			
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}
			lpEvent->EnumHostsResponse(&m_dpEnumHostRes, &fRejectMsg);
			if (m_dpEnumHostRes.AddressSenderUrl)
				SysFreeString(m_dpEnumHostRes.AddressSenderUrl);

			if (m_dpEnumHostRes.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostRes.AddressDeviceUrl);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATED_CONNECT_ABORTED:
		{
			DPF(1,"-----DirectPlayServer8 Callback Indicated Connect Abort\n");

			lpEvent->IndicatedConnectAborted(&fRejectMsg);

		break;
		}
	}

	__try {
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DPlayServer) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

	if (fCallCoUninit)
		CoUninitialize();

	InterlockedDecrement(&lpPeer->m_dwMsgCount);
	DPF(1,"-----Leaving (DPlayServer) MessageHandler call...\n");

	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::RegisterMessageHandler(I_dxj_DirectPlayEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	DPF(1,"-----Entering (DPlayServer) RegisterMessageHandler call...\n");
	if (!event) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		if (m_pEventStream) 
			m_pEventStream->Release();

		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;

		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayServer->Initialize( this, DirectPlayServerMessageHandler, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayServerObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DPlayServer) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	//Clear out the messages currently waiting
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayServerObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (DPlayServer) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	while (m_dwMsgCount > dwNumMessagesLeft)
	{
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (DPlayServer) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		Sleep(0);
	}
	DPF(1,"-----Leaving (DPlayServer) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}


DWORD WINAPI CloseServerThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Server	*lpPeer = (IDirectPlay8Server*)lpParam;

	DPF(1,"-----Entering (DplayPeer) CloseServerThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DplayPeer) CloseServerThreadProc call ...\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayvoiceclientobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dPlayVoiceClientObj.h"	
#include "dPlayVoiceServerObj.h"				   
#include "dvoice.h"
#include "dSound3DBuffer.h"

extern void *g_dxj_DirectPlayVoiceClient;
extern BSTR GUIDtoBSTR(LPGUID pGuid);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { DPF(1,"------ DXVB: SafeRelease About to call release:"); int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayVoiceClient SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { DPF(1,"------ DXVB: SafeRelease Exception Handler hit(??):") (p) = NULL;} } 

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceClientObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayVoiceClient AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceClientObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"DirectPlayVoiceClient Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayVoiceClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceClientObject::C_dxj_DirectPlayVoiceClientObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectPlayVoiceClient Object\n ");

	m__dxj_DirectPlayVoiceClient = NULL;
	m__dxj_DirectSound = NULL;
	m__dxj_DirectSoundCapture = NULL;
	m_pEventStream=NULL;
	m_fInit = FALSE;
	m_fHandleVoiceClientEvents = FALSE;
	m_dwMsgCount = 0;

}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayVoiceClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceClientObject::~C_dxj_DirectPlayVoiceClientObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayVoiceClientObject destructor \n");

	DPF(1,"------ DXVB: Turning off message handling\n");
	m_fHandleVoiceClientEvents = FALSE;

	DPF(1,"------ DXVB: Releasing Stream\n");
	SAFE_RELEASE(m_pEventStream);

	FlushBuffer(0);
	/*DPF(1,"------ DXVB: Releasing DirectSoundObject\n");
	SAFE_RELEASE(m__dxj_DirectSound);
	DPF(1,"------ DXVB: Releasing DirectSoundCaptureObject\n");
	SAFE_RELEASE(m__dxj_DirectSoundCapture);
	DPF(1,"------ DXVB: Releasing DPVoiceClient\n");*/
	SAFE_RELEASE(m__dxj_DirectPlayVoiceClient);
	DPF(1,"------ DXVB: Leaving ~C_dxj_DirectPlayVoiceClientObject destructor \n");

}

HRESULT C_dxj_DirectPlayVoiceClientObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayVoiceClient;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayVoiceClientObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayVoiceClient=(LPDIRECTPLAYVOICECLIENT)pUnk;
	return S_OK;
}

HRESULT CALLBACK VoiceMessageHandlerClient(LPVOID lpvUserContext, DWORD dwMessageType, LPVOID lpMessage)
{
	HRESULT					hr=S_OK;

	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayVoiceClientObject	*lpPeer = (C_dxj_DirectPlayVoiceClientObject*)lpvUserContext;
	
	DPF2(1,"-----Entering (VoiceClient) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageType );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceClient) MessageHandler call (No lpPeer member)...\n");
		return E_FAIL;
	}

	if (!lpPeer->m_pEventStream) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceClient) MessageHandler call (No stream)...\n");
		return E_FAIL;
	}

	if (!lpPeer->m_fHandleVoiceClientEvents)
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceClient) MessageHandler call (Not handling events)...\n");
		return S_OK;
	}

	if (!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST))
	{
		DPF(1,"-----(VoiceClient) SetThreadPri Failed... \n");	
	}
	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	LARGE_INTEGER l;
	I_dxj_DPVoiceEvent	*lpEvent = NULL;

	l.QuadPart = 0;
	lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

	DPF(1,"-----(VoiceClient) About to CoUnmarshal the interface... \n");	
	hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DPVoiceEvent, (void**)&lpEvent);
	if (!lpEvent) 
	{
		DPF(1,"-----(VoiceClient) CoUnmarshal Failed... \n");	
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return hr;
	}
	
	switch (dwMessageType)
	{
		case DVMSGID_LOCALHOSTSETUP:
		{
			DVMSG_LOCALHOSTSETUP		*msg = (DVMSG_LOCALHOSTSETUP*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive LocalHostSetup Msg... \n");	
			msg->pvContext = lpvUserContext;
			msg->pMessageHandler = VoiceMessageHandlerClient;
			break;
		}

		case DVMSGID_SESSIONLOST:
		{
			DVMSG_SESSIONLOST			*msg = (DVMSG_SESSIONLOST*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive SessionLost Msg... \n");	
			lpEvent->SessionLost(msg->hrResult);
			DPF(1,"-----(VoiceClient) Returning from VB -  SessionLost Msg... \n");	
			break;
		}
        
		case DVMSGID_HOSTMIGRATED:
		{
			DVMSG_HOSTMIGRATED			*msg = (DVMSG_HOSTMIGRATED*)lpMessage;
			I_dxj_DirectPlayVoiceServer	*lpServer = NULL;

			INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceServer, msg->pdvServerInterface, &lpServer);
			DPF(1,"-----(VoiceClient) Receive HostMigrated Msg... \n");	
			lpEvent->HostMigrated(msg->dvidNewHostID, lpServer);
			DPF(1,"-----(VoiceClient) Returning from VB -  HostMigrated Msg... \n");	
            break;
		}

        case DVMSGID_RECORDSTART:             
		{
			DVMSG_RECORDSTART *pMsg = (DVMSG_RECORDSTART*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive RecordStart Msg... \n");	
			lpEvent->RecordStart(pMsg->dwPeakLevel);
			DPF(1,"-----(VoiceClient) Returning from VB -  RecordStart Msg... \n");	
            break;
		}

        case DVMSGID_RECORDSTOP:             
		{
			DVMSG_RECORDSTOP *pMsg = (DVMSG_RECORDSTOP*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive RecordStop Msg... \n");	
			lpEvent->RecordStop(pMsg->dwPeakLevel);
			DPF(1,"-----(VoiceClient) Returning from VB -  RecordStop Msg... \n");	
            break;
		}
            
        case DVMSGID_PLAYERVOICESTART:
		{
			DVMSG_PLAYERVOICESTART *pMsg = (DVMSG_PLAYERVOICESTART*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive PlayerVoiceStart Msg... \n");	
			lpEvent->PlayerVoiceStart(pMsg->dvidSourcePlayerID);
			DPF(1,"-----(VoiceClient) Returning from VB -  PlayerVoiceStart Msg... \n");	
            break;
		}

        case DVMSGID_PLAYERVOICESTOP:
		{
			DVMSG_PLAYERVOICESTOP *pMsg = (DVMSG_PLAYERVOICESTOP*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive PlayerVoiceStop Msg... \n");	
			lpEvent->PlayerVoiceStop(pMsg->dvidSourcePlayerID);
			DPF(1,"-----(VoiceClient) Returning from VB -  PlayerVoiceStop Msg... \n");	
            break;
		}
		
		case DVMSGID_CONNECTRESULT:
		{
			DVMSG_CONNECTRESULT			*msg = (DVMSG_CONNECTRESULT*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive ConnectResult Msg... \n");	
			lpEvent->ConnectResult(msg->hrResult);
			DPF(1,"-----(VoiceClient) Returning from VB -  ConnectResult Msg... \n");	
			break;
		}

		case DVMSGID_DISCONNECTRESULT:
		{
			DVMSG_DISCONNECTRESULT *pMsg = (DVMSG_DISCONNECTRESULT*)lpMessage;
			DPF(1,"-----(VoiceClient) Receive DisconnectResult Msg... \n");	
			lpEvent->DisconnectResult(pMsg->hrResult);
			DPF(1,"-----(VoiceClient) Returning from VB -  DisconnectResult Msg... \n");	
			break;
		}
		
		case DVMSGID_INPUTLEVEL:
		{
			DVMSG_INPUTLEVEL *pMsg = (DVMSG_INPUTLEVEL*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive InputLevel Msg... \n");	
			lpEvent->InputLevel(pMsg->dwPeakLevel,pMsg->lRecordVolume);
			DPF(1,"-----(VoiceClient) Returning from VB -  InputLevel Msg... \n");	
			break;
		}

		case DVMSGID_OUTPUTLEVEL:
		{
			DVMSG_OUTPUTLEVEL *pMsg = (DVMSG_OUTPUTLEVEL*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive Output Level Msg... \n");	
			lpEvent->OutputLevel(pMsg->dwPeakLevel,pMsg->lOutputVolume);
			DPF(1,"-----(VoiceClient) Returning from VB -  Output Level Msg... \n");	
			break;
		}

		case DVMSGID_PLAYEROUTPUTLEVEL:
		{
			DVMSG_PLAYEROUTPUTLEVEL *pMsg = (DVMSG_PLAYEROUTPUTLEVEL*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive PlayerOutputLevel Msg... \n");	
			lpEvent->PlayerOutputLevel(pMsg->dvidSourcePlayerID,pMsg->dwPeakLevel);
			DPF(1,"-----(VoiceClient) Returning from VB -  PlayerOutputLevel Msg... \n");	
			break;
		}

		case DVMSGID_CREATEVOICEPLAYER:
		{
			DVMSG_CREATEVOICEPLAYER *pMsg = (DVMSG_CREATEVOICEPLAYER*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive CreateVoicePlayer Msg... \n");	
			lpEvent->CreateVoicePlayer(pMsg->dvidPlayer, pMsg->dwFlags);
			DPF(1,"-----(VoiceClient) Returning from VB -  CreateVoicePlayer Msg... \n");	
			break;
		}

		case DVMSGID_DELETEVOICEPLAYER:
		{
			DVMSG_DELETEVOICEPLAYER *pMsg = (DVMSG_DELETEVOICEPLAYER*)lpMessage;

			DPF(1,"-----(VoiceClient) Receive DeleteVoicePlayer Msg... \n");	
			lpEvent->DeleteVoicePlayer(pMsg->dvidPlayer);
			DPF(1,"-----(VoiceClient) Returning from VB -  DeleteVoicePlayer Msg... \n");	
			break;
		}

		case DVMSGID_SETTARGETS:
			DPF(1,"-----(VoiceClient) Receive SetTargets Msg... \n");	
			break;
	}

	__try {
		DPF(1,"-----(VoiceClient) Releasing MarshalData... \n");	
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleVoiceClientEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	DPF(1,"-----Leaving (VoiceClient) MessageHandler call...\n");
	InterlockedDecrement(&lpPeer->m_dwMsgCount);
	return S_OK;
}


STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Initialize ( 
	IUnknown *DplayObj,
	long lFlags)
{
	HRESULT					hr;
	IUnknown				*lpDplay = NULL;
	I_dxj_DirectPlayPeer	*lpPeer = NULL;
	I_dxj_DirectPlayClient	*lpClient = NULL;
	I_dxj_DirectPlayServer	*lpServer = NULL;

	__try {
		DPF(1,"-----Entering (VoiceClient) Initialize call...\n");
		// First we need to get our IUnknown pointer from whatever we pass in
		hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayPeer, (void**)&lpPeer);
		if (SUCCEEDED(hr))
		{
			lpPeer->InternalGetObject(&lpDplay);
			SAFE_RELEASE(lpPeer);
		}
		else
		{
			hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayClient, (void**)&lpClient);
			if (SUCCEEDED(hr))
			{
				lpClient->InternalGetObject(&lpDplay);
				SAFE_RELEASE(lpClient);
			}
			else
			{
				hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayServer, (void**)&lpServer);
				if (SUCCEEDED(hr))
				{
					lpServer->InternalGetObject(&lpDplay);
					SAFE_RELEASE(lpServer);
				}
			}
		}

		if (!lpDplay)
			return E_INVALIDARG;

		if (!m_fInit)
		{
			if (FAILED( hr=m__dxj_DirectPlayVoiceClient->Initialize(lpDplay, &VoiceMessageHandlerClient,
								this,0,(DWORD)lFlags)))
				return hr;
			m_fInit = TRUE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
										
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Connect ( 
	DVSOUNDDEVICECONFIG_CDESC *SoundDeviceConfig,
	DVCLIENTCONFIG_CDESC *ClientConfig,
	long lFlags)
{
	HRESULT						hr;
	DVCLIENTCONFIG				dvClient;
	DVSOUNDDEVICECONFIG			dvSound;
	GUID						guidPlayback;
	GUID						guidCapture;
	LPDIRECTSOUND8				lpDSoundOut = NULL;
	LPDIRECTSOUNDCAPTURE8		lpDSoundCaptureOut = NULL;

	__try {
		DPF(1,"-----Entering (VoiceClient) Connect call...\n");
		//FlushBuffer(0);
		//Set up the sound config
		ZeroMemory ( &dvSound, sizeof(DVSOUNDDEVICECONFIG));
		dvSound.dwSize						= sizeof(DVSOUNDDEVICECONFIG);
		dvSound.dwFlags						= (DWORD)SoundDeviceConfig->lFlags;

		//Set up the default playback device (or whatever they picked)
		if (SoundDeviceConfig->guidPlaybackDevice == NULL)
			dvSound.guidPlaybackDevice			= DSDEVID_DefaultVoicePlayback;
		else
		{
			hr = DPLAYBSTRtoGUID(&guidPlayback, SoundDeviceConfig->guidPlaybackDevice);
			dvSound.guidPlaybackDevice = guidPlayback;
		}

		// Set up the default capture device (or whatever they picked)
		if (SoundDeviceConfig->guidCaptureDevice == NULL)
			dvSound.guidCaptureDevice			= DSDEVID_DefaultVoiceCapture;
		else
		{
			hr = DPLAYBSTRtoGUID(&guidCapture, SoundDeviceConfig->guidCaptureDevice);
			dvSound.guidCaptureDevice = guidCapture;
		}

		// Is there a current Playback device?
		if (m__dxj_DirectSound)
			dvSound.lpdsPlaybackDevice = m__dxj_DirectSound;
		else
			dvSound.lpdsPlaybackDevice			= NULL;
		
		// Is there a current Capture device?
		if (m__dxj_DirectSoundCapture)
			dvSound.lpdsCaptureDevice			= m__dxj_DirectSoundCapture;
		else
			dvSound.lpdsCaptureDevice			= NULL;

		dvSound.lpdsPlaybackDevice		= lpDSoundOut;
		dvSound.lpdsCaptureDevice		= lpDSoundCaptureOut;
		dvSound.hwndAppWindow				= (HWND)SoundDeviceConfig->hwndAppWindow;

		if (SoundDeviceConfig->MainSoundBuffer)
		{
			DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDBUFFER8, lpDSoundBuffer, SoundDeviceConfig->MainSoundBuffer);
			dvSound.lpdsMainBuffer = lpDSoundBuffer;
			dvSound.dwMainBufferFlags = SoundDeviceConfig->lMainBufferFlags;	
			dvSound.dwMainBufferPriority = SoundDeviceConfig->lMainBufferPriority;	
		}

		//Set up the client config
		ZeroMemory ( &dvClient, sizeof(DVCLIENTCONFIG) );
		dvClient.dwSize						= sizeof(DVCLIENTCONFIG);
		dvClient.dwFlags					= ClientConfig->lFlags;
		dvClient.lRecordVolume				= ClientConfig->lRecordVolume;     
		dvClient.lPlaybackVolume			= ClientConfig->lPlaybackVolume;   
		dvClient.dwThreshold				= ClientConfig->lThreshold;
		dvClient.dwBufferQuality			= ClientConfig->lBufferQuality;
		dvClient.dwBufferAggressiveness		= ClientConfig->lBufferAggressiveness;
		dvClient.dwNotifyPeriod				= ClientConfig->lNotifyPeriod;

		if (FAILED ( hr = m__dxj_DirectPlayVoiceClient->Connect(&dvSound, &dvClient, (DWORD)lFlags)))
			return hr;
		
		//Now set the devices that were used.
		m__dxj_DirectSound = lpDSoundOut;
		m__dxj_DirectSoundCapture = lpDSoundCaptureOut;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Disconnect ( 
	long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceClient) Disconnect call...\n");

		FlushBuffer(0);
		if (FAILED (hr = m__dxj_DirectPlayVoiceClient->Disconnect((DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetSessionDesc ( 
	DVSESSIONDESC_CDESC *SessionDesc)
{
	HRESULT				hr;
	DVSESSIONDESC		dvSession;
	
	__try {
		DPF(1,"-----Entering (VoiceClient) GetSessionDesc call...\n");
		//FlushBuffer(0);
		dvSession.dwSize = sizeof(DVSESSIONDESC);
		//Now get the buffer
		if ( FAILED(hr = m__dxj_DirectPlayVoiceClient->GetSessionDesc(&dvSession)))
			return hr;
	
		//Cast into return buffer
		SessionDesc->lFlags = (long)dvSession.dwFlags;
		SessionDesc->lSessionType = (long)dvSession.dwSessionType;
		SessionDesc->guidCT = GUIDtoBSTR(&dvSession.guidCT);
		SessionDesc->lBufferQuality = (long)dvSession.dwBufferQuality;
		SessionDesc->lBufferAggressiveness = (long)dvSession.dwBufferAggressiveness;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetClientConfig ( 
	DVCLIENTCONFIG_CDESC *ClientConfig)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetClientConfig call...\n");
		//FlushBuffer(0);
		ClientConfig->lSize = sizeof(DVCLIENTCONFIG);
		if (FAILED ( hr = m__dxj_DirectPlayVoiceClient->GetClientConfig((DVCLIENTCONFIG*)ClientConfig)))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::SetClientConfig ( 
	DVCLIENTCONFIG_CDESC *ClientConfig)
{
	HRESULT hr;
	DVCLIENTCONFIG dvClient;

	__try {
		DPF(1,"-----Entering (VoiceClient) SetClientConfig call...\n");
		//FlushBuffer(0);
		ZeroMemory ( &dvClient, sizeof(DVCLIENTCONFIG) );
		
		// Fill our copy of DVCLIENTCONFIG
		dvClient.dwSize							= sizeof(DVCLIENTCONFIG);
		dvClient.dwFlags						= ClientConfig->lFlags;
		dvClient.lRecordVolume					= ClientConfig->lRecordVolume;     
		dvClient.lPlaybackVolume				= ClientConfig->lPlaybackVolume;   
		dvClient.dwThreshold					= ClientConfig->lThreshold;
		dvClient.dwBufferQuality				= ClientConfig->lBufferQuality;
		dvClient.dwBufferAggressiveness			= ClientConfig->lBufferAggressiveness;
		dvClient.dwNotifyPeriod					= ClientConfig->lNotifyPeriod;
		
		if (FAILED ( hr = m__dxj_DirectPlayVoiceClient->SetClientConfig(&dvClient)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetCaps ( 
	DVCAPS_CDESC *Caps)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetCaps call...\n");
		//FlushBuffer(0);
		Caps->lSize = sizeof(DVCAPS);
		if (FAILED ( hr = m__dxj_DirectPlayVoiceClient->GetCaps((DVCAPS*)Caps)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetCompressionTypeCount ( 
	long *retval)
{
	HRESULT			hr;
	DWORD			dwSize = 0;
	DWORD			dwNumElements = 0;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetCompressionTypeCount call...\n");
		//FlushBuffer(0);
		hr = m__dxj_DirectPlayVoiceClient->GetCompressionTypes(NULL, &dwSize, &dwNumElements ,0);
		
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;

		*retval = (long)dwNumElements;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetCompressionType ( 
	long lIndex,
	DVCOMPRESSIONINFO_CDESC *Data,
	long lFlags)
{
	HRESULT					hr;
	LPBYTE					pBuffer = NULL;	
	DWORD					dwSize = 0;
	DWORD					dwNumElements = 0;
	LPDVCOMPRESSIONINFO		pdvCompressionInfo;
	LPGUID					pGuid;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetCompressionTypes call...\n");
		//FlushBuffer(0);
		hr = m__dxj_DirectPlayVoiceClient->GetCompressionTypes(pBuffer, &dwSize, &dwNumElements ,0);
		
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;

		pBuffer = new BYTE[dwSize];
		if (!pBuffer)
			return E_OUTOFMEMORY;
		
		if ( FAILED ( hr = m__dxj_DirectPlayVoiceClient->GetCompressionTypes(pBuffer, &dwSize, &dwNumElements, (DWORD)lFlags)))
			return hr;

		if (lIndex > (long)dwNumElements)
			return DVERR_INVALIDPARAM;

		pdvCompressionInfo = (LPDVCOMPRESSIONINFO) pBuffer;

		pGuid = new GUID;
		if (!pGuid)
			return E_OUTOFMEMORY;

		// Ok, fill up our struct
		ZeroMemory(Data, sizeof(DVCOMPRESSIONINFO_CDESC));
		Data->lSize				= sizeof(DVCOMPRESSIONINFO_CDESC);
		Data->lFlags				= pdvCompressionInfo[lIndex-1].dwFlags;
		Data->lMaxBitsPerSecond	= pdvCompressionInfo[lIndex-1].dwMaxBitsPerSecond;
		Data->strDescription		= SysAllocString(pdvCompressionInfo[lIndex-1].lpszDescription);
		Data->strName				= SysAllocString(pdvCompressionInfo[lIndex-1].lpszName);

		(*pGuid) = pdvCompressionInfo[lIndex-1].guidType;

		Data->guidType				= GUIDtoBSTR(pGuid);
		SAFE_DELETE(pGuid);
		SAFE_DELETE(pBuffer);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::SetTransmitTargets ( 
	SAFEARRAY **playerIDs,
	long lFlags)
{
	HRESULT hr;
	DWORD	dwNumTarget = ((SAFEARRAY*)*playerIDs)->rgsabound[0].cElements;
	
	__try {
		DPF(1,"-----Entering (VoiceClient) SetTransmitTargets call...\n");
		//FlushBuffer(0);
		if (FAILED( hr = m__dxj_DirectPlayVoiceClient->SetTransmitTargets((DVID*)(((SAFEARRAY*)*playerIDs)->pvData),
						dwNumTarget, (DWORD) lFlags )))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetTransmitTargets ( 
	long lFlags,
	SAFEARRAY **ret)
{
	HRESULT hr;
	DVID	*dwPlayers = NULL;
	DWORD	dwNumPlayers=0;
	SAFEARRAY					*lpData = NULL;
	SAFEARRAYBOUND				rgsabound[1];
	BYTE						*lpByte = NULL;

	__try {
		DPF(1,"-----Entering (VoiceClient) GetTransmitTargets call...\n");
		//FlushBuffer(0);
		
		hr =m__dxj_DirectPlayVoiceClient->GetTransmitTargets(NULL, &dwNumPlayers, (DWORD) lFlags );

		if (FAILED(hr) && ( hr != DVERR_BUFFERTOOSMALL))
			return hr;

		dwPlayers = (DVID*)new BYTE[sizeof(DVID) * dwNumPlayers];
		if (!dwPlayers)
			return E_OUTOFMEMORY;

		if (FAILED( hr = m__dxj_DirectPlayVoiceClient->GetTransmitTargets(dwPlayers, &dwNumPlayers, (DWORD) lFlags )))
			return hr;

		if (dwNumPlayers)
		{
			// Now let's create a safearray to pass back
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = dwNumPlayers;
			
			lpData = SafeArrayCreate(VT_UI4, 1, rgsabound);
			memcpy(lpData->pvData,dwPlayers,sizeof(DVID) * dwNumPlayers);
		}
		*ret = lpData;
		SAFE_DELETE(dwPlayers);
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::SetCurrentSoundDevices (
	I_dxj_DirectSound *DirectSoundObj, 
	I_dxj_DirectSoundCapture *DirectCaptureObj)
{
	__try {
		DPF(1,"-----Entering (VoiceClient) SetCurrentSoundDevices call...\n");
		//FlushBuffer(0);
		DO_GETOBJECT_NOTNULL( LPDIRECTSOUND8, lpSound, DirectSoundObj);
		DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDCAPTURE8, lpSoundCapture, DirectCaptureObj);

		m__dxj_DirectSound = lpSound;
		m__dxj_DirectSoundCapture = lpSoundCapture;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetSoundDevices (
	I_dxj_DirectSound *DirectSoundObj, 
	I_dxj_DirectSoundCapture *DirectCaptureObj)
{
	__try {
		DPF(1,"-----Entering (VoiceClient) GetSoundDevices call...\n");
		//FlushBuffer(0);
		if (m__dxj_DirectSound)
			INTERNAL_CREATE_NOADDREF(_dxj_DirectSound,m__dxj_DirectSound,&DirectSoundObj);

		if (m__dxj_DirectSoundCapture)
			INTERNAL_CREATE_NOADDREF(_dxj_DirectSoundCapture ,m__dxj_DirectSoundCapture,&DirectCaptureObj);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Create3DSoundBuffer (
	long playerID,
	I_dxj_DirectSoundBuffer *Buffer,
	long lPriority,
	long lFlags, 
	I_dxj_DirectSound3dBuffer **UserBuffer)
{
	HRESULT						hr;
	IDirectSound3DBuffer		*lpDSound3DBuffer = NULL;

	__try {
		DPF(1,"-----Entering (VoiceClient) Create3DSoundBuffer call...\n");
		//FlushBuffer(0);

		if (Buffer)
		{
			DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDBUFFER8, lpDSoundBuffer, Buffer);
			//First let's go ahead and get the real DirectSoundBuffer
			if ( FAILED ( hr = m__dxj_DirectPlayVoiceClient->Create3DSoundBuffer(
						(DVID)playerID, lpDSoundBuffer, (DWORD)lPriority, (DWORD) lFlags, &lpDSound3DBuffer)))
				return hr;
		}
		else
		{
			//First let's go ahead and get the real DirectSoundBuffer
			if ( FAILED ( hr = m__dxj_DirectPlayVoiceClient->Create3DSoundBuffer(
						(DVID)playerID, NULL, 0, 0, &lpDSound3DBuffer)))
				return hr;
		}

		//We need to do an AddRef() on this buffer so when we release it, it will go away
		lpDSound3DBuffer->AddRef();
		// Now let's get a I_dxj_DirectSound3dBuffer to pass back..
		INTERNAL_CREATE_ADDRESS(_dxj_DirectSound3dBuffer,lpDSound3DBuffer,UserBuffer);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
				
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::Delete3DSoundBuffer (
	long playerID, 
	I_dxj_DirectSound3dBuffer *UserBuffer)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceClient) Delete3DSoundBuffer call...\n");
		//FlushBuffer(0);
		DO_GETOBJECT_NOTNULL( LPDIRECTSOUND3DBUFFER, lpBuffer, UserBuffer);
		DPF(1,"-----Calling Delete3DSoundBuffer on core obj...\n");
		if (FAILED( hr=m__dxj_DirectPlayVoiceClient->Delete3DSoundBuffer((DVID)playerID, &lpBuffer)))
			return hr;

		/*int i = UserBuffer->AddRef();
		DPF1(1,"-----New Ref: %d...\n",i);*/
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DPF(1,"-----Leaving (VoiceClient) Delete3DSoundBuffer call (Exception Handler)...\n");
		return E_FAIL;
	}
	
	DPF(1,"-----Leaving (VoiceClient) Delete3DSoundBuffer call (No error)...\n");
	return S_OK;
}
STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::GetSoundDeviceConfig(DVSOUNDDEVICECONFIG_CDESC *SoundDeviceConfig)
{
	HRESULT hr;
	DWORD dwSize = 0;
	DVSOUNDDEVICECONFIG *pdvConfig = NULL;

	DPF(1,"-----Entering (VoiceClient) GetSoundDeviceConfig call...\n");
	__try {
		//FlushBuffer(0);

		hr = m__dxj_DirectPlayVoiceClient->GetSoundDeviceConfig(NULL, &dwSize);
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;
		pdvConfig = (DVSOUNDDEVICECONFIG*) new BYTE[dwSize];
		if (!pdvConfig)
			return E_OUTOFMEMORY;

		pdvConfig->dwSize = sizeof(DVSOUNDDEVICECONFIG);
		hr = m__dxj_DirectPlayVoiceClient->GetSoundDeviceConfig(pdvConfig, &dwSize);
		if ( FAILED(hr) ) //We didn't expect this error
			return hr;
		
		SoundDeviceConfig->lSize = (long)pdvConfig->dwSize;
		SoundDeviceConfig->lFlags = (long)pdvConfig->dwFlags;
#ifdef _WIN64
		SoundDeviceConfig->hwndAppWindow = pdvConfig->hwndAppWindow;
#else
		SoundDeviceConfig->hwndAppWindow = (long)pdvConfig->hwndAppWindow;
#endif
		SoundDeviceConfig->guidPlaybackDevice = GUIDtoBSTR(&pdvConfig->guidPlaybackDevice);
		SoundDeviceConfig->guidCaptureDevice = GUIDtoBSTR(&pdvConfig->guidCaptureDevice);

		SAFE_DELETE(pdvConfig);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceClientObject::StartClientNotification(I_dxj_DPVoiceEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;
    IUnknown *pUnk=NULL;

	DPF(1,"-----Entering (VoiceClient) StartClientNotification call...\n");
	if (!event) return E_INVALIDARG;
    
	SAFE_RELEASE(m_pEventStream);

	// Create a global stream.  The stream needs to be global so we can 
	// marshal once, and unmarshal as many times as necessary
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
    if FAILED(hr) return hr;

	// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
	// so we can unmarshal any number of times
	hr = CoMarshalInterface(pStm, IID_I_dxj_DPVoiceEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
    if FAILED(hr) return hr;

	// Now we need to set the seek location of the stream to the beginning
	LARGE_INTEGER l;
	l.QuadPart = 0;
	pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
	m_pEventStream=pStm;

	m_fHandleVoiceClientEvents = TRUE;

	return hr;
}

HRESULT C_dxj_DirectPlayVoiceClientObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (VoiceClient) UnregisterMessageHandler call...\n");
	m_fHandleVoiceClientEvents = FALSE;
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayVoiceClientObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (VoiceClient) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	while (m_dwMsgCount > dwNumMessagesLeft)
	{
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (VoiceClient) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		Sleep(0);
	}
	DPF(1,"-----Leaving (VoiceClient) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayserverobj.h ===
#include "resource.h"       // main symbols
#include "dplay8.h"

//Forward declare the class
class C_dxj_DirectPlayServerObject;

#define typedef__dxj_DirectPlayServer IDirectPlay8Server*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayServerObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayServer, &IID_I_dxj_DirectPlayServer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayServer,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayServerObject() ;
	virtual ~C_dxj_DirectPlayServerObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayServerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayServer)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayServerObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayServer
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayEvent *event);

		// Enum for Clients/Groups
		HRESULT STDMETHODCALLTYPE GetCountPlayersAndGroups(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetPlayerOrGroup(long lIndex, long *ret);
		// Enum Players in groups
		HRESULT STDMETHODCALLTYPE GetCountGroupMembers(long dpid,long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetGroupMember(long lIndex,long dpid, long *ret);

		HRESULT STDMETHODCALLTYPE GetCountServiceProviders(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret);
		HRESULT STDMETHODCALLTYPE CancelAsyncOperation(long lAsyncHandle, long lFlags);
		HRESULT STDMETHODCALLTYPE SendTo(long idSend ,SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE CreateGroup(DPN_GROUP_INFO_CDESC *GroupInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE AddPlayerToGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetSendQueueInfo(long idPlayer, long *lNumMsgs, long *lNumBytes, long lFlags);
		HRESULT STDMETHODCALLTYPE SetGroupInfo(long idGroup, DPN_GROUP_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetGroupInfo(long idGroup,long lFlags, DPN_GROUP_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE SetServerInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetClientInfo(long idPeer,long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret);
		HRESULT STDMETHODCALLTYPE SetApplicationDesc(DPN_APPLICATION_DESC_CDESC *AppDesc, long lFlags);
		HRESULT STDMETHODCALLTYPE Host(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address, long lFlags);
		HRESULT STDMETHODCALLTYPE Close(long lFlags);
		HRESULT STDMETHODCALLTYPE GetCaps(long lFlags, DPNCAPS_CDESC *ret);
		HRESULT STDMETHODCALLTYPE SetCaps(DPNCAPS_CDESC *Caps, long lFlags);
		HRESULT STDMETHODCALLTYPE RemovePlayerFromGroup(long idGroup, long idClient,long lFlags,long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE ReturnBuffer(long lBufferHandle);
		HRESULT STDMETHODCALLTYPE DestroyClient(long idClient, long lFlags, void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE DestroyGroup(long idGroup,long lFlags,long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags);
		HRESULT STDMETHODCALLTYPE GetConnectionInfo(long idPlayer, long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo);

		HRESULT STDMETHODCALLTYPE GetClientAddress(long idPlayer,long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE GetLocalHostAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags);
		HRESULT STDMETHODCALLTYPE GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps);
		HRESULT STDMETHODCALLTYPE GetUserData(void *UserData, long *UserDataSize);
		HRESULT STDMETHODCALLTYPE SetUserData(void *UserData, long UserDataSize);
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayServer);

private:
	BOOL									m_fInit;
    DPN_SERVICE_PROVIDER_INFO	*m_SPInfo;
	DWORD						m_dwSPCount;
	DPNID						*m_ClientsGroups;
	DPNID						*m_GroupMembers;
	DPNID						m_dwGroupID;
	DWORD						m_dwClientCount;
	DWORD						m_dwGroupMemberCount;

	HRESULT STDMETHODCALLTYPE	GetSP(long lFlags);
	HRESULT STDMETHODCALLTYPE	GetClientsAndGroups(long lFlags);
	HRESULT STDMETHODCALLTYPE	GetGroupMembers(long lFlags, DPNID dpGroupID);
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayServer);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	// We need these for our user data vars
	void			*m_pUserData;
	DWORD			m_dwUserDataSize;
	// For our reply data
	void			*m_pReplyData;
	DWORD			m_dwReplyDataSize;

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

	//We need to keep a count of the messages
	LONG									m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayvoiceclientobj.h ===
#include "resource.h"       // main symbols
#include "dSoundObj.h"
#include "dSoundCaptureObj.h"

#define typedef__dxj_DirectPlayVoiceClient LPDIRECTPLAYVOICECLIENT

	/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayVoiceClientObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayVoiceClient, &IID_I_dxj_DirectPlayVoiceClient, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayVoiceClient,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayVoiceClientObject() ;
	virtual ~C_dxj_DirectPlayVoiceClientObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayVoiceClientObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayVoiceClient)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayVoiceClientObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayVoiceClient
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

        HRESULT STDMETHODCALLTYPE Initialize ( 
            /* [in] */ IUnknown __RPC_FAR *DplayObj,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE Connect ( 
            /* [in] */ DVSOUNDDEVICECONFIG_CDESC __RPC_FAR *SoundDeviceConfig,
            /* [in] */ DVCLIENTCONFIG_CDESC __RPC_FAR *ClientConfig,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE Disconnect ( 
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE GetSessionDesc ( 
            /* [out][in] */ DVSESSIONDESC_CDESC __RPC_FAR *SessionDesc);
        
        HRESULT STDMETHODCALLTYPE GetClientConfig ( 
            /* [out][in] */ DVCLIENTCONFIG_CDESC __RPC_FAR *ClientConfig);
        
        HRESULT STDMETHODCALLTYPE SetClientConfig ( 
            /* [in] */ DVCLIENTCONFIG_CDESC __RPC_FAR *ClientConfig);
        
        HRESULT STDMETHODCALLTYPE GetCaps ( 
            /* [out][in] */ DVCAPS_CDESC __RPC_FAR *Caps);
        
        HRESULT STDMETHODCALLTYPE GetCompressionTypeCount ( 
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE GetCompressionType ( 
            /* [in] */ long lIndex,
            /* [out][in] */ DVCOMPRESSIONINFO_CDESC __RPC_FAR *Data,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE SetTransmitTargets ( 
            /* [in] */ SAFEARRAY **playerIDs,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE GetTransmitTargets ( 
            /* [in] */ long lFlags,
            /* [retval][out] */ SAFEARRAY **ret);
 
		HRESULT STDMETHODCALLTYPE SetCurrentSoundDevices (
			/* [in] */ I_dxj_DirectSound *DirectSoundObj, 
			/* [in] */ I_dxj_DirectSoundCapture *DirectCaptureObj);

		HRESULT STDMETHODCALLTYPE GetSoundDevices (
			/* [in,out] */ I_dxj_DirectSound __RPC_FAR *DirectSoundObj, 
			/* [in,out] */ I_dxj_DirectSoundCapture __RPC_FAR *DirectCaptureObj);
		
		HRESULT STDMETHODCALLTYPE Create3DSoundBuffer (
			/* [in] */ long playerID, 
						I_dxj_DirectSoundBuffer __RPC_FAR *Buffer,
						long lPriority,
						long lFlags, 
			/* [out,retval] */ I_dxj_DirectSound3dBuffer __RPC_FAR **UserBuffer);

		HRESULT STDMETHODCALLTYPE Delete3DSoundBuffer (
			/* [in] */ long playerID, 
			/* [in] */ I_dxj_DirectSound3dBuffer __RPC_FAR *UserBuffer);
		HRESULT STDMETHODCALLTYPE GetSoundDeviceConfig(
			/* [out,retval] */ DVSOUNDDEVICECONFIG_CDESC __RPC_FAR *SoundDeviceConfig);

		HRESULT STDMETHODCALLTYPE StartClientNotification(
			/* [in] */ I_dxj_DPVoiceEvent __RPC_FAR *event);
		
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();

		////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayVoiceClient);

private:
    DECL_VARIABLE(_dxj_DirectSound);
    DECL_VARIABLE(_dxj_DirectSoundCapture);
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);


public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayVoiceClient);

	DWORD InternalAddRef();
	DWORD InternalRelease();
	
	BOOL						m_fHandleVoiceClientEvents;
	IStream						*m_pEventStream;
	BOOL						m_fInit;
	//We need to keep a count of the messages
	LONG									m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayvoicesetupobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dPlayVoiceSetupObj.h"					   

extern void *g_dxj_DirectPlayVoiceSetup;
extern BSTR GUIDtoBSTR(LPGUID pGuid);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceSetupObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectPlayVoiceTest [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceSetupObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectPlayVoiceTest [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayVoiceSetupObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceSetupObject::C_dxj_DirectPlayVoiceSetupObject(){ 
		
	DPF1(1,"Constructor Creation  DirectPlayVoiceTest Object[%d] \n ",g_creationcount);

	m__dxj_DirectPlayVoiceSetup = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectPlayVoiceSetup;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectPlayVoiceSetup = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayVoiceSetupObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceSetupObject::~C_dxj_DirectPlayVoiceSetupObject()
{

	DPF(1,"Entering ~C_dxj_DirectPlayVoiceSetupObject destructor \n");

     C_dxj_DirectPlayVoiceSetupObject *prev=NULL; 
	for(C_dxj_DirectPlayVoiceSetupObject *ptr=(C_dxj_DirectPlayVoiceSetupObject *)g_dxj_DirectPlayVoiceSetup ; ptr; ptr=(C_dxj_DirectPlayVoiceSetupObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectPlayVoiceSetup = (void*)ptr->nextobj; 
			
			DPF(1,"DirectPlayVoiceTestObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectPlayVoiceSetup){
		int count = IUNK(m__dxj_DirectPlayVoiceSetup)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectPlayVoiceTest Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectPlayVoiceSetup = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectPlayVoiceSetupObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayVoiceSetup;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayVoiceSetupObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayVoiceSetup=(LPDIRECTPLAYVOICETEST)pUnk;
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceSetupObject::CheckAudioSetup ( 
	BSTR guidPlaybackDevice,
	BSTR guidCaptureDevice,
#ifdef _WIN64
	HWND hwndOwner,
#else
	long hwndOwner,
#endif
	long lFlags,
	long *retval)
{
	HRESULT hr;
	LPGUID pPlayback = NULL;
	LPGUID pCapture = NULL;

	__try {
		hr = BSTRtoGUID(pPlayback, guidPlaybackDevice);
		hr = BSTRtoGUID(pCapture, guidCaptureDevice);

		if ( FAILED (hr = m__dxj_DirectPlayVoiceSetup->CheckAudioSetup(pPlayback, pCapture, (HWND) hwndOwner, (DWORD) lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayvoiceserverobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dPlayVoiceServerObj.h"					   
#include "dvoice.h"

extern BSTR GUIDtoBSTR(LPGUID pGuid);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern void *g_dxj_DirectPlayVoiceServer;

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayVoiceServer SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceServerObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayVoiceServer AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayVoiceServerObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"DirectPlayVoiceServer Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayVoiceServerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceServerObject::C_dxj_DirectPlayVoiceServerObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectPlayVoiceServer Object \n ");

	m__dxj_DirectPlayVoiceServer = NULL;
	m_pEventStream=NULL;
	m_fInit = FALSE;
	m_fHandleVoiceClientEvents = FALSE;
	m_dwMsgCount = 0;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayVoiceServerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayVoiceServerObject::~C_dxj_DirectPlayVoiceServerObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayVoiceServerObject destructor \n");

	m_fHandleVoiceClientEvents = FALSE;
	FlushBuffer(0);
	SAFE_RELEASE(m__dxj_DirectPlayVoiceServer);
	SAFE_RELEASE(m_pEventStream);

}

HRESULT C_dxj_DirectPlayVoiceServerObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayVoiceServer;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayVoiceServerObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayVoiceServer=(LPDIRECTPLAYVOICESERVER)pUnk;
	return S_OK;
}

HRESULT CALLBACK VoiceMessageHandlerServer(LPVOID lpvUserContext, DWORD dwMessageType,
		LPVOID lpMessage)
{
	HRESULT					hr=S_OK;

	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayVoiceServerObject	*lpPeer = (C_dxj_DirectPlayVoiceServerObject*)lpvUserContext;
	
	DPF2(1,"-----Entering (VoiceServer) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageType );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceServer) MessageHandler call (No lpPeer member)...\n");
		return E_FAIL;
	}

	if (!lpPeer->m_pEventStream) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceServer) MessageHandler call (No stream)...\n");
		return E_FAIL;
	}

	if (!lpPeer->m_fHandleVoiceClientEvents)
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (VoiceServer) MessageHandler call (Not handling events)...\n");
		return S_OK;
	}

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	LARGE_INTEGER l;
	I_dxj_DPVoiceEvent	*lpEvent = NULL;

	l.QuadPart = 0;
	lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

	hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DPVoiceEvent, (void**)&lpEvent);
	if (!lpEvent) 
	{
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return hr;
	}
	
	switch (dwMessageType)
	{
		case DVMSGID_LOCALHOSTSETUP:
		{
			DVMSG_LOCALHOSTSETUP		*msg = (DVMSG_LOCALHOSTSETUP*)lpMessage;

			msg->pvContext = lpvUserContext;
			msg->pMessageHandler = VoiceMessageHandlerServer;
			break;
		}

		case DVMSGID_SESSIONLOST:
		{
			DVMSG_SESSIONLOST			*msg = (DVMSG_SESSIONLOST*)lpMessage;

			lpEvent->SessionLost(msg->hrResult);
			break;
		}
        
		case DVMSGID_HOSTMIGRATED:
		{
			DVMSG_HOSTMIGRATED			*msg = (DVMSG_HOSTMIGRATED*)lpMessage;
			I_dxj_DirectPlayVoiceServer	*lpServer = NULL;

			INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceServer, msg->pdvServerInterface, &lpServer);
			lpEvent->HostMigrated(msg->dvidNewHostID, lpServer);
            break;
		}

        case DVMSGID_RECORDSTART:             
		{
			DVMSG_RECORDSTART *pMsg = (DVMSG_RECORDSTART*)lpMessage;

			lpEvent->RecordStart(pMsg->dwPeakLevel);
            break;
		}

        case DVMSGID_RECORDSTOP:             
		{
			DVMSG_RECORDSTOP *pMsg = (DVMSG_RECORDSTOP*)lpMessage;

			lpEvent->RecordStop(pMsg->dwPeakLevel);
            break;
		}
            
        case DVMSGID_PLAYERVOICESTART:
		{
			DVMSG_PLAYERVOICESTART *pMsg = (DVMSG_PLAYERVOICESTART*)lpMessage;

			lpEvent->PlayerVoiceStart(pMsg->dvidSourcePlayerID);
            break;
		}

        case DVMSGID_PLAYERVOICESTOP:
		{
			DVMSG_PLAYERVOICESTOP *pMsg = (DVMSG_PLAYERVOICESTOP*)lpMessage;

			lpEvent->PlayerVoiceStop(pMsg->dvidSourcePlayerID);
            break;
		}
		
		case DVMSGID_CONNECTRESULT:
		{
			DVMSG_CONNECTRESULT			*msg = (DVMSG_CONNECTRESULT*)lpMessage;

			lpEvent->ConnectResult(msg->hrResult);
			break;
		}

		case DVMSGID_DISCONNECTRESULT:
		{
			DVMSG_DISCONNECTRESULT *pMsg = (DVMSG_DISCONNECTRESULT*)lpMessage;
			lpEvent->DisconnectResult(pMsg->hrResult);
			break;
		}
		
		case DVMSGID_INPUTLEVEL:
		{
			DVMSG_INPUTLEVEL *pMsg = (DVMSG_INPUTLEVEL*)lpMessage;

			lpEvent->InputLevel(pMsg->dwPeakLevel,pMsg->lRecordVolume);
			break;
		}

		case DVMSGID_OUTPUTLEVEL:
		{
			DVMSG_OUTPUTLEVEL *pMsg = (DVMSG_OUTPUTLEVEL*)lpMessage;

			lpEvent->OutputLevel(pMsg->dwPeakLevel,pMsg->lOutputVolume);
			break;
		}

		case DVMSGID_PLAYEROUTPUTLEVEL:
		{
			DVMSG_PLAYEROUTPUTLEVEL *pMsg = (DVMSG_PLAYEROUTPUTLEVEL*)lpMessage;

			lpEvent->PlayerOutputLevel(pMsg->dvidSourcePlayerID,pMsg->dwPeakLevel);
			break;
		}

		case DVMSGID_CREATEVOICEPLAYER:
		{
			DVMSG_CREATEVOICEPLAYER *pMsg = (DVMSG_CREATEVOICEPLAYER*)lpMessage;

			lpEvent->CreateVoicePlayer(pMsg->dvidPlayer, pMsg->dwFlags);
			break;
		}

		case DVMSGID_DELETEVOICEPLAYER:
		{
			DVMSG_DELETEVOICEPLAYER *pMsg = (DVMSG_DELETEVOICEPLAYER*)lpMessage;

			lpEvent->DeleteVoicePlayer(pMsg->dvidPlayer);
			break;
		}

		case DVMSGID_SETTARGETS:
			break;
	}

	__try {
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleVoiceClientEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	DPF(1,"-----Leaving (VoiceServer) MessageHandler call...\n");
	InterlockedDecrement(&lpPeer->m_dwMsgCount);
    
	return S_OK;
}


STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::Initialize ( 
	IUnknown *DplayObj,
	long lFlags)
{
	HRESULT hr;
	IUnknown				*lpDplay = NULL;
	I_dxj_DirectPlayPeer	*lpPeer = NULL;
	I_dxj_DirectPlayClient	*lpClient = NULL;
	I_dxj_DirectPlayServer	*lpServer = NULL;

	__try {
		DPF(1,"-----Entering (VoiceServer) Initialize call...\n");
		// First we need to get our IUnknown pointer from whatever we pass in
		hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayPeer, (void**)&lpPeer);
		if (SUCCEEDED(hr))
		{
			lpPeer->InternalGetObject(&lpDplay);
			SAFE_RELEASE(lpPeer);
		}
		else
		{
			hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayClient, (void**)&lpClient);
			if (SUCCEEDED(hr))
			{
				lpClient->InternalGetObject(&lpDplay);
				SAFE_RELEASE(lpClient);
			}
			else
			{
				hr = DplayObj->QueryInterface(IID_I_dxj_DirectPlayServer, (void**)&lpServer);
				if (SUCCEEDED(hr))
				{
					lpServer->InternalGetObject(&lpDplay);
					SAFE_RELEASE(lpServer);
				}
			}
		}

		if (!lpDplay)
			return E_INVALIDARG;

		if (!m_fInit)
		{
			if (FAILED( hr=m__dxj_DirectPlayVoiceServer->Initialize(lpDplay, &VoiceMessageHandlerServer,
								this,0,(DWORD)lFlags)))
				return hr;
			m_fInit = TRUE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::StartSession ( 
	DVSESSIONDESC_CDESC *SessionDesc,
	long lFlags)
{
	DVSESSIONDESC dvSession;
	HRESULT hr;
	GUID pguidCT;
	
	__try {
		DPF(1,"-----Entering (VoiceServer) StartSession call...\n");
		FlushBuffer(0);
		ZeroMemory(&dvSession, sizeof(DVSESSIONDESC));

		dvSession.dwSize						= sizeof(DVSESSIONDESC);
		dvSession.dwBufferAggressiveness		= SessionDesc->lBufferAggressiveness;
		dvSession.dwBufferQuality				= SessionDesc->lBufferQuality;
		dvSession.dwFlags						= SessionDesc->lFlags;
		dvSession.dwSessionType					= SessionDesc->lSessionType;

		if ( SessionDesc->guidCT == NULL )
			dvSession.guidCT						= DPVCTGUID_DEFAULT;
		else
		{
			hr = DPLAYBSTRtoGUID(&pguidCT, SessionDesc->guidCT);
			dvSession.guidCT = pguidCT;
		}
		
		if (FAILED ( hr = m__dxj_DirectPlayVoiceServer->StartSession( &dvSession, (DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::StopSession ( 
	long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (VoiceServer) StopSession call...\n");
		FlushBuffer(0);
		if (FAILED ( hr = m__dxj_DirectPlayVoiceServer->StopSession((DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetSessionDesc ( 
	DVSESSIONDESC_CDESC *SessionDesc)
{
	HRESULT				hr;
	DVSESSIONDESC		dvSession;
	
	__try {
		DPF(1,"-----Entering (VoiceServer) GetSessionDesc call...\n");
		FlushBuffer(0);
		dvSession.dwSize = sizeof(DVSESSIONDESC);
		//Now get the buffer
		if ( FAILED(hr = m__dxj_DirectPlayVoiceServer->GetSessionDesc(&dvSession)))
			return hr;
		
		//Cast into return buffer
		SessionDesc->lFlags = (long)dvSession.dwFlags;
		SessionDesc->lSessionType = (long)dvSession.dwSessionType;
		SessionDesc->guidCT = GUIDtoBSTR(&dvSession.guidCT);
		SessionDesc->lBufferQuality = (long)dvSession.dwBufferQuality;
		SessionDesc->lBufferAggressiveness = (long)dvSession.dwBufferAggressiveness;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::SetSessionDesc ( 
	DVSESSIONDESC_CDESC *SessionDesc)
{
	DVSESSIONDESC dvSession;
	HRESULT hr;
	GUID pguidCT;
	
	__try {
		DPF(1,"-----Entering (VoiceServer) SetSessionDesc call...\n");
		FlushBuffer(0);
		ZeroMemory(&dvSession, sizeof(DVSESSIONDESC));

		dvSession.dwSize						= sizeof(DVSESSIONDESC);
		dvSession.dwBufferAggressiveness		= SessionDesc->lBufferAggressiveness;
		dvSession.dwBufferQuality				= SessionDesc->lBufferQuality;
		dvSession.dwFlags						= SessionDesc->lFlags;
		dvSession.dwSessionType					= SessionDesc->lSessionType;

		if ( SessionDesc->guidCT == NULL )
			dvSession.guidCT						= DPVCTGUID_DEFAULT;
		else
		{
			hr = DPLAYBSTRtoGUID(&pguidCT, SessionDesc->guidCT);
			dvSession.guidCT = pguidCT;
		}

		if (FAILED ( hr = m__dxj_DirectPlayVoiceServer->SetSessionDesc(&dvSession)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetCaps ( 
	DVCAPS_CDESC *Caps)
{
	HRESULT				hr;

	__try {
		DPF(1,"-----Entering (VoiceServer) GetCaps call...\n");
		FlushBuffer(0);
		Caps->lSize=sizeof(DVCAPS);
		if (FAILED ( hr = m__dxj_DirectPlayVoiceServer->GetCaps((DVCAPS*)Caps))) 
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetCompressionTypeCount ( 
	long *retval)
{
	HRESULT			hr;
	DWORD			dwSize = 0;
	DWORD			dwNumElements = 0;

	__try {
		DPF(1,"-----Entering (VoiceServer) GetCompressionTypeCount call...\n");
		FlushBuffer(0);
		hr = m__dxj_DirectPlayVoiceServer->GetCompressionTypes(NULL, &dwSize, &dwNumElements ,0);
		
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;

		*retval = (long)dwNumElements;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetCompressionType ( 
	long lIndex,
	DVCOMPRESSIONINFO_CDESC *Data,
	long lFlags)
{
	HRESULT					hr;
	LPBYTE					pBuffer = NULL;	
	DWORD					dwSize = 0;
	DWORD					dwNumElements = 0;
	LPDVCOMPRESSIONINFO		pdvCompressionInfo;
	LPGUID					pGuid;

	__try {
		DPF(1,"-----Entering (VoiceServer) GetCompressionType call...\n");
		FlushBuffer(0);
		hr = m__dxj_DirectPlayVoiceServer->GetCompressionTypes(pBuffer, &dwSize, &dwNumElements ,0);
		
		if ( hr != DVERR_BUFFERTOOSMALL && FAILED(hr) ) //We didn't expect this error
			return hr;

		pBuffer = new BYTE[dwSize];
		if (!pBuffer)
			return E_OUTOFMEMORY;
		
		if ( FAILED ( hr = m__dxj_DirectPlayVoiceServer->GetCompressionTypes(pBuffer, &dwSize, &dwNumElements, (DWORD)lFlags)))
			return hr;

		if (lIndex > (long)dwNumElements)
			return DVERR_INVALIDPARAM;

		pdvCompressionInfo = (LPDVCOMPRESSIONINFO) pBuffer;
		pGuid = new GUID;
		if (!pGuid)
			return E_OUTOFMEMORY;

		// Ok, fill up our struct
		ZeroMemory(Data, sizeof(DVCOMPRESSIONINFO_CDESC));
		Data->lSize				= sizeof(DVCOMPRESSIONINFO_CDESC);
		Data->lFlags				= pdvCompressionInfo[lIndex-1].dwFlags;
		Data->lMaxBitsPerSecond		= pdvCompressionInfo[lIndex-1].dwMaxBitsPerSecond;
		Data->strDescription		= SysAllocString(pdvCompressionInfo[lIndex-1].lpszDescription);
		Data->strName				= SysAllocString(pdvCompressionInfo[lIndex-1].lpszName);
		(*pGuid) = pdvCompressionInfo[lIndex-1].guidType;

		Data->guidType				= GUIDtoBSTR(pGuid);
		SAFE_DELETE(pGuid);
		SAFE_DELETE(pBuffer);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::SetTransmitTargets ( 
	long playerSourceID,
	SAFEARRAY **playerTargetIDs,
	long lFlags)
{
	HRESULT hr;
	DWORD	dwNumTarget = ((SAFEARRAY*)*playerTargetIDs)->rgsabound[0].cElements;

	__try {
		DPF(1,"-----Entering (VoiceServer) SetTransmitTargets call...\n");
		FlushBuffer(0);
		if (FAILED( hr = m__dxj_DirectPlayVoiceServer->SetTransmitTargets((DVID)playerSourceID , 
				(DVID*)((SAFEARRAY*)*playerTargetIDs)->pvData, dwNumTarget, (DWORD) lFlags )))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::GetTransmitTargets ( 
	long playerSourceID,
	long lFlags,
	SAFEARRAY **ret)
{
	HRESULT hr;
	DVID	*dwPlayers = NULL;
	DWORD	dwNumPlayers=0;
	SAFEARRAY					*lpData = NULL;
	SAFEARRAYBOUND				rgsabound[1];

	__try {
		DPF(1,"-----Entering (VoiceServer) GetTransmitTargets call...\n");
		FlushBuffer(0);
		hr =m__dxj_DirectPlayVoiceServer->GetTransmitTargets((DVID)playerSourceID, NULL, &dwNumPlayers, (DWORD) lFlags );

		if (FAILED(hr) && ( hr != DVERR_BUFFERTOOSMALL))
			return hr;

		dwPlayers = (DVID*)new BYTE[sizeof(DVID) * dwNumPlayers];
		if (!dwPlayers)
			return E_OUTOFMEMORY;

		if (FAILED( hr = m__dxj_DirectPlayVoiceServer->GetTransmitTargets((DVID)playerSourceID, dwPlayers, &dwNumPlayers, (DWORD) lFlags )))
			return hr;

		
		if (dwNumPlayers)
		{
			// Now let's create a safearray to pass back
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = dwNumPlayers;
			
			lpData = SafeArrayCreate(VT_UI4, 1, rgsabound);
			memcpy(lpData->pvData,dwPlayers,sizeof(DVID) * dwNumPlayers);
		}
		*ret = lpData;
		SAFE_DELETE(dwPlayers);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


STDMETHODIMP C_dxj_DirectPlayVoiceServerObject::StartServerNotification(I_dxj_DPVoiceEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	if (!event) return E_INVALIDARG;
    
	DPF(1,"-----Entering (VoiceServer) StartServerNotification call...\n");
	SAFE_RELEASE(m_pEventStream);

	// Create a global stream.  The stream needs to be global so we can 
	// marshal once, and unmarshal as many times as necessary
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
    if FAILED(hr) return hr;
	// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
	// so we can unmarshal any number of times
	hr = CoMarshalInterface(pStm, IID_I_dxj_DPVoiceEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
    if FAILED(hr) return hr;

	// Now we need to set the seek location of the stream to the beginning
	LARGE_INTEGER l;
	l.QuadPart = 0;
	pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
	m_pEventStream=pStm;

	m_fHandleVoiceClientEvents = TRUE;
	return hr;
}

HRESULT C_dxj_DirectPlayVoiceServerObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (VoiceServer) UnregisterMessageHandler call...\n");
	m_fHandleVoiceClientEvents = FALSE;
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayVoiceServerObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (VoiceServer) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	while (m_dwMsgCount > dwNumMessagesLeft)
	{
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (VoiceServer) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
		//Give another thread a chance
		Sleep(0);
	}
	DPF(1,"-----Leaving (VoiceServer) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayvoiceserverobj.h ===
#include "resource.h"       // main symbols
#define typedef__dxj_DirectPlayVoiceServer LPDIRECTPLAYVOICESERVER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayVoiceServerObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayVoiceServer, &IID_I_dxj_DirectPlayVoiceServer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayVoiceServer,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayVoiceServerObject() ;
	virtual ~C_dxj_DirectPlayVoiceServerObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayVoiceServerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayVoiceServer)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayVoiceServerObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayVoiceServer
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

        HRESULT STDMETHODCALLTYPE Initialize ( 
            /* [in] */ IUnknown __RPC_FAR *DplayObj,
           /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE StartSession ( 
            /* [in] */ DVSESSIONDESC_CDESC __RPC_FAR *SessionDesc,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE StopSession ( 
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE GetSessionDesc ( 
            /* [out][in] */ DVSESSIONDESC_CDESC __RPC_FAR *SessionDesc);
        
        HRESULT STDMETHODCALLTYPE SetSessionDesc ( 
            /* [in] */ DVSESSIONDESC_CDESC __RPC_FAR *ClientConfig);
        
        HRESULT STDMETHODCALLTYPE GetCaps ( 
            /* [out][in] */ DVCAPS_CDESC __RPC_FAR *Caps);
        
        HRESULT STDMETHODCALLTYPE GetCompressionTypeCount ( 
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE GetCompressionType ( 
            /* [in] */ long lIndex,
            /* [out][in] */ DVCOMPRESSIONINFO_CDESC __RPC_FAR *Data,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE SetTransmitTargets ( 
            /* [in] */ long playerSourceID,
            /* [in] */ SAFEARRAY **playerTargetIDs,
            /* [in] */ long lFlags);
        
        HRESULT STDMETHODCALLTYPE GetTransmitTargets ( 
            /* [in] */ long playerSourceID,
            /* [in] */ long lFlags,
            /* [retval][out] */ SAFEARRAY **ret);

		HRESULT STDMETHODCALLTYPE StartServerNotification(
			/* [in] */ I_dxj_DPVoiceEvent __RPC_FAR *event);

		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayVoiceServer);

private:
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayVoiceServer);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	BOOL						m_fHandleVoiceClientEvents;
	IStream						*m_pEventStream;
	BOOL						m_fInit;
	//We need to keep a count of the messages
	LONG									m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsenumobj.cpp
//
//--------------------------------------------------------------------------

#define OLDDSENUM 1

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglob7obj.h"
#include "DSEnumObj.h"
 

extern BSTR GUIDtoBSTR(LPGUID pGuid);

extern "C" BOOL PASCAL  objDirectSoundEnumCallback( 

#ifdef OLDDSENUM
	LPGUID lpGuid,
#else
	LPCGUID lpGuid,
#endif

  LPCSTR lpDriverDescription,  
  LPCSTR lpDriverName,         
  LPVOID lpArg            
)
{
        GUID guid;
        ZeroMemory(&guid,sizeof(GUID));
        if (lpGuid){
           memcpy(&guid,lpGuid,sizeof(GUID));
        }

	
	DPF(1,"Entered objDirectDrawEnumCallback \r\n");

	
	C_dxj_DSEnumObject *pObj=(C_dxj_DSEnumObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(DXDRIVERINFO_CDESC*)realloc(pObj->m_pList,sizeof(DXDRIVERINFO_CDESC)* pObj->m_nMax);
		else
			pObj->m_pList=(DXDRIVERINFO_CDESC*)malloc(sizeof(DXDRIVERINFO_CDESC)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DXDRIVERINFO_CDESC));
        pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)&guid);
//      pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGuid); 
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DSEnumObject::C_dxj_DSEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DSEnumObject::~C_dxj_DSEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DSEnumObject::create(DSOUNDENUMERATE pcbFunc,DSOUNDCAPTUREENUMERATE pcbFunc2,I_dxj_DSEnum **ppRet)
{
	HRESULT hr=S_OK;	
	C_dxj_DSEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DSEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DSEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	if (pcbFunc) 
	{
		hr=pcbFunc(objDirectSoundEnumCallback,pNew);	
	}
	else if (pcbFunc2)
	{
		hr=pcbFunc2(objDirectSoundEnumCallback,pNew);
	}
	else {
		hr = E_INVALIDARG;
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		//let destructor do the clean up
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DSEnum,(void**)ppRet);
	return hr;
}




HRESULT C_dxj_DSEnumObject::getName( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	
	*ret=SysAllocString(m_pList[index-1].strName);		

	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getDescription( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	

	*ret=SysAllocString(m_pList[index-1].strDescription);

	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getGuid( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	

	*ret=SysAllocString(m_pList[index-1].strGuid);
	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsenumobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DSEnumObject : 
	public I_dxj_DSEnum,
	public CComObjectRoot
{
public:
	C_dxj_DSEnumObject() ;
	virtual ~C_dxj_DSEnumObject() ;

BEGIN_COM_MAP(C_dxj_DSEnumObject)
	COM_INTERFACE_ENTRY(I_dxj_DSEnum)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DSEnumObject)

public:
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count) ;
				
		static HRESULT create(DSOUNDENUMERATE pcbFunc,DSOUNDCAPTUREENUMERATE pcbFunc2,I_dxj_DSEnum **ppRet);		

public:
		DXDRIVERINFO_CDESC 	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayvoicesetupobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectPlayVoiceSetup LPDIRECTPLAYVOICETEST

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayVoiceSetupObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayVoiceSetup, &IID_I_dxj_DirectPlayVoiceSetup, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayVoiceSetup,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayVoiceSetupObject() ;
	virtual ~C_dxj_DirectPlayVoiceSetupObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayVoiceSetupObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayVoiceSetup)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayVoiceSetupObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayVoiceSetup
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

        HRESULT STDMETHODCALLTYPE CheckAudioSetup ( 
            /* [in] */ BSTR guidPlaybackDevice,
            /* [in] */ BSTR guidCaptureDevice,
#ifdef _WIN64
			/* [in] */ HWND hwndOwner,
#else
			/* [in] */ long hwndOwner,
#endif
            /* [in] */ long lFlags,
            /* [retval][out] */ long __RPC_FAR *v1);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayVoiceSetup);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayVoiceSetup);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsound3dbuffer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsound3dbuffer.cpp
//
//--------------------------------------------------------------------------

// dSound3DBuffer.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file


#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DBuffer.h"
#include "dSound3DListener.h"
#define SAFE_RELEASE(p)      { __try { if(p) { DPF(1,"------ DXVB: SafeRelease About to call release:"); int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlaySound3DBuffer SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { DPF(1,"------ DXVB: SafeRelease Exception Handler hit(??):") (p) = NULL;} } 

C_dxj_DirectSound3dBufferObject::C_dxj_DirectSound3dBufferObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectSound3DBuffer Object\n ");
	m__dxj_DirectSound3dBuffer = NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayVoiceClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSound3dBufferObject::~C_dxj_DirectSound3dBufferObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectSound3dBufferObject destructor \n");
	SAFE_RELEASE(m__dxj_DirectSound3dBuffer);
	DPF(1,"------ DXVB: Leaving ~C_dxj_DirectPlayVoiceClientObject destructor \n");

}

GETSET_OBJECT(_dxj_DirectSound3dBuffer);

	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, getConeAngles, GetConeAngles, long*,(DWORD*), long*,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getConeOrientation, GetConeOrientation, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getConeOutsideVolume, GetConeOutsideVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getMaxDistance, GetMaxDistance, float*);
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getMinDistance, GetMinDistance, float*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getMode, GetMode,  long *,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getPosition, GetPosition, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getVelocity, GetVelocity, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_3_R(_dxj_DirectSound3dBuffer, setConeAngles, SetConeAngles, long,(DWORD) ,long,(DWORD) ,long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setConeOrientation,  SetConeOrientation, float,(float), float,(float), float,(float), long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setConeOutsideVolume, SetConeOutsideVolume, long, (long),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMaxDistance, SetMaxDistance, float, (float),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMinDistance, SetMinDistance, float,(float),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMode, SetMode, long,(unsigned long) , long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setPosition, SetPosition, float,(float), float,(float), float,(float), long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setVelocity, SetVelocity, float,(float), float,(float), float,(float), long,(DWORD));

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getAllParameters( DS3DBUFFER_CDESC* lobj )
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DBUFFER);
	return m__dxj_DirectSound3dBuffer->GetAllParameters( (LPDS3DBUFFER)lobj );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::setAllParameters( DS3DBUFFER_CDESC *lobj, long apply)
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DBUFFER);
	return m__dxj_DirectSound3dBuffer->SetAllParameters( (LPDS3DBUFFER)lobj, (DWORD)apply );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getDirectSoundBuffer( I_dxj_DirectSoundBuffer **retv)
{
	HRESULT hr;
	IDirectSoundBuffer *pdsb;
	hr=m__dxj_DirectSound3dBuffer->QueryInterface(IID_IDirectSoundBuffer,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSoundBuffer,pdsb,retv);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsound3dbuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsound3dbuffer.h
//
//--------------------------------------------------------------------------

// dSound3DBuffer.h : Declaration of the C_dxj_DirectSound3dBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound3dBuffer LPDIRECTSOUND3DBUFFER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSound3dBufferObject : 
	public I_dxj_DirectSound3dBuffer,
	//public CComCoClass<C_dxj_DirectSound3dBufferObject, &CLSID__dxj_DirectSound3dBuffer>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSound3dBufferObject() ;
	virtual ~C_dxj_DirectSound3dBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSound3dBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound3dBuffer)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSound3dBuffer,	"DIRECT.DirectSound3dBuffer.3",		"DIRECT.DirectSound3dBuffer.3",			IDS_DSOUND3DBUFFER_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_DirectSound3dBufferObject)

// I_dxj_DirectSound3dBuffer
public:
	/*** IDirectSoundBuffer3D methods ***/
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSoundBuffer( 
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *retVal);
        
         HRESULT STDMETHODCALLTYPE getAllParameters( 
            /* [out][in] */ DS3DBUFFER_CDESC __RPC_FAR *buffer);
        
         HRESULT STDMETHODCALLTYPE getConeAngles( 
            /* [out][in] */ long __RPC_FAR *inCone,
            /* [out][in] */ long __RPC_FAR *outCone);
        
         HRESULT STDMETHODCALLTYPE getConeOrientation( 
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *orientation);
        
         HRESULT STDMETHODCALLTYPE getConeOutsideVolume( 
            /* [retval][out] */ long __RPC_FAR *coneOutsideVolume);
        
         HRESULT STDMETHODCALLTYPE getMaxDistance( 
            /* [retval][out] */ float __RPC_FAR *maxDistance);
        
         HRESULT STDMETHODCALLTYPE getMinDistance( 
            /* [retval][out] */ float __RPC_FAR *minDistance);
        
         HRESULT STDMETHODCALLTYPE getMode( 
            /* [retval][out] */ long __RPC_FAR *mode);
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *position);
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *velocity);
        
         HRESULT STDMETHODCALLTYPE setAllParameters( 
            /* [in] */ DS3DBUFFER_CDESC __RPC_FAR *buffer,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeAngles( 
            /* [in] */ long inCone,
            /* [in] */ long outCone,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeOrientation( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeOutsideVolume( 
            /* [in] */ long coneOutsideVolume,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMaxDistance( 
            /* [in] */ float maxDistance,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMinDistance( 
            /* [in] */ float minDistance,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMode( 
            /* [in] */ long mode,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
private:
    DECL_VARIABLE(_dxj_DirectSound3dBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound3dBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundbufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundbufferobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundBuffer LPDIRECTSOUNDBUFFER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundBuffer, &IID_I_dxj_DirectSoundBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundBuffer,
#endif

	//public CComCoClass<C_dxj_DirectSoundBufferObject, &CLSID__dxj_DirectSoundBuffer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundBufferObject() ;
	virtual ~C_dxj_DirectSoundBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//y	DECLARE_REGISTRY(CLSID__dxj_DirectSoundBuffer,	"DIRECT.DirectSoundBuffer.3",		"DIRECT.DirectSoundBuffer.3",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundBuffer
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dBuffer( 
            /* [retval][out] */ I_dxj_DirectSound3dBuffer __RPC_FAR *__RPC_FAR *lpdsb);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSBCAPS_CDESC __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( 
            /* [out] */ DSCURSORS_CDESC __RPC_FAR *cursors);
        
         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WAVEFORMATEX_CDESC __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE getVolume( 
            /* [retval][out] */ long __RPC_FAR *volume);
        
         HRESULT STDMETHODCALLTYPE getPan( 
            /* [retval][out] */ long __RPC_FAR *pan);
        
         HRESULT STDMETHODCALLTYPE getFrequency( 
            /* [retval][out] */ long __RPC_FAR *frequency);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSound __RPC_FAR *directSound,
            /* [out][in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [out][in] */ byte __RPC_FAR *wbuf);
        
         HRESULT STDMETHODCALLTYPE writeBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *buffer,
			void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE readBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *buffer,
				void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE play( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setCurrentPosition( 
            /* [in] */ long newPosition);
        
         HRESULT STDMETHODCALLTYPE setVolume( 
            /* [in] */ long volume);
        
         HRESULT STDMETHODCALLTYPE setPan( 
            /* [in] */ long pan);
        
         HRESULT STDMETHODCALLTYPE setFrequency( 
            /* [in] */ long frequency);
        
         HRESULT STDMETHODCALLTYPE stop( void);
        
         HRESULT STDMETHODCALLTYPE restore( void);
		 
		 HRESULT STDMETHODCALLTYPE setNotificationPositions(long nElements,SAFEARRAY  **ppsa);

		 HRESULT STDMETHODCALLTYPE saveToFile(BSTR b);
		 
		 HRESULT STDMETHODCALLTYPE SetFX(long lEffectsCount, SAFEARRAY **Buffers, SAFEARRAY **lResultIDs);
		 
		 HRESULT STDMETHODCALLTYPE AcquireResources(long lFlags, SAFEARRAY **lEffects);

		 HRESULT STDMETHODCALLTYPE GetObjectinPath(BSTR guidFX, long lIndex, BSTR iidInterface, IUnknown **ret);

#if 0
		 HRESULT STDMETHODCALLTYPE SetChannelVolume(long lChannelCount, SAFEARRAY **lChannels, SAFEARRAY **lVolumes);
#endif

private:
    DECL_VARIABLE(_dxj_DirectSoundBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundcapturebufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsoundcapturebufferobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundCaptureBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundCaptureBuffer LPDIRECTSOUNDCAPTUREBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundCaptureBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundCaptureBuffer, &IID_I_dxj_DirectSoundCaptureBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundCaptureBuffer,
#endif

//	public CComCoClass<C_dxj_DirectSoundCaptureBufferObject, &CLSID__dxj_DirectSoundCaptureBuffer>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundCaptureBufferObject() ;
	virtual ~C_dxj_DirectSoundCaptureBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundCaptureBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundCaptureBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSoundCaptureBuffer,	"DIRECT.DirectSoundCaptureBuffer.5",		"DIRECT.DirectSoundCaptureBuffer.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundCaptureBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundCaptureBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundCaptureBuffer
public:
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCBCAPS_CDESC __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( DSCURSORS_CDESC *desc);                  			

         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WAVEFORMATEX_CDESC __RPC_FAR *waveformat);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSoundCaptureBuffer __RPC_FAR *captureBuffer,
            /* [in] */ DSCBUFFERDESC_CDESC __RPC_FAR *bufferDesc);
        
         HRESULT STDMETHODCALLTYPE start( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE stop( void);

		 HRESULT  STDMETHODCALLTYPE setNotificationPositions(long nElements,SAFEARRAY  **ppsa);

		 HRESULT STDMETHODCALLTYPE readBuffer(long start, long totsz, 
													void  *buf,  long flags) ;
		 HRESULT STDMETHODCALLTYPE writeBuffer(long start, long totsz, 
													void  *buf,  long flags) ;


private:
    DECL_VARIABLE(_dxj_DirectSoundCaptureBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundCaptureBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundcapturebufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundcapturebufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundCaptureBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file


#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundObj.h"
#include "dSoundCaptureBufferObj.h"
#include "dSoundCaptureObj.h"

CONSTRUCTOR(_dxj_DirectSoundCaptureBuffer, {});
DESTRUCTOR(_dxj_DirectSoundCaptureBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundCaptureBuffer);

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getCaps(DSCBCAPS_CDESC *caps)
{    
	((DSCBCAPS*)caps)->dwSize=sizeof(DSCBCAPS);
    return m__dxj_DirectSoundCaptureBuffer->GetCaps((DSCBCAPS*)caps);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getCurrentPosition(DSCURSORS_CDESC *desc) 
{    	
	/////////////////////////////////////////////////////////////////////////////
	if(!desc)
		return E_POINTER;

	return (m__dxj_DirectSoundCaptureBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
}


STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getStatus(long *stat)
{    	
    return m__dxj_DirectSoundCaptureBuffer->GetStatus((DWORD*)stat);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::start(long flags)
{    	
    return m__dxj_DirectSoundCaptureBuffer->Start((DWORD)flags);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::stop()
{    	
    return m__dxj_DirectSoundCaptureBuffer->Stop();
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getFormat(WAVEFORMATEX_CDESC *format)
{    	
	DWORD cb=0;
    return m__dxj_DirectSoundCaptureBuffer->GetFormat((WAVEFORMATEX*)format,sizeof(WAVEFORMATEX_CDESC),&cb);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::initialize(I_dxj_DirectSoundCaptureBuffer *buffer,DSCBUFFERDESC_CDESC *desc)
{    	
	((DSCBUFFERDESC*)desc)->dwSize=sizeof(DSCBUFFERDESC);
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDCAPTURE, lpref, buffer);
    return m__dxj_DirectSoundCaptureBuffer->Initialize(lpref,(DSCBUFFERDESC*)desc);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::setNotificationPositions (long nElements,SAFEARRAY  **ppsa)
{
	if (!ISSAFEARRAY1D(ppsa,(DWORD)nElements))
		return E_INVALIDARG;
	
	HRESULT hr;
	LPDIRECTSOUNDNOTIFY pDSN=NULL;

	if (nElements == 0)
	{
		// There is absolutely nothing to do if we want to set 0 notification positions
		return S_OK;
	}

	hr=m__dxj_DirectSoundCaptureBuffer->QueryInterface(IID_IDirectSoundNotify,(void**)&pDSN);
	if FAILED(hr) return hr;

    hr=pDSN->SetNotificationPositions((DWORD)nElements,(LPCDSBPOSITIONNOTIFY)((SAFEARRAY*)*ppsa)->pvData);	
		
	pDSN->Release();

	return hr;
}

        

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::writeBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 
	#pragma message ("SoundBuffer writeBuffer ")

	byte *buffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!buffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	__try {
	DPF1(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) Lock buffer (Total size = %d )\n",totsz);
	if ((val = m__dxj_DirectSoundCaptureBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	DPF1(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
	if (p1)	
	{
		DPF1(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
		memcpy (p1, buffer, size1);
	}

	if (p2)	 //There was wrapping
	{
		DPF1(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) about to copy to buffer (size2 = %d )\n",size2);
		memcpy(p2, &buffer[size1], size2);
	}

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	DPF(1,"----- DXVB: DSoundCaptureBuffer (WriteBuffer) Unlocking buffer.\n");
	val= m__dxj_DirectSoundCaptureBuffer->Unlock(p1, size1, p2, size2);
   }
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DPF(1,"----- DXVB: (WriteBuffer) Exception.\n");
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::readBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 

	//byte *buffer=(byte*)((SAFEARRAY*)*ppsa)->pvData;
	byte *buffer=(byte*)buf;

	if(!buffer)
		return E_POINTER;
	
	LPVOID	p1 = NULL, p2 = NULL;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	DPF1(1,"----- DXVB: DSoundCaptureBuffer (ReadBuffer) Lock buffer (Total size = %d )\n",totsz);
	if ((val = m__dxj_DirectSoundCaptureBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (p1)	
	{
		DPF1(1,"----- DXVB: DSoundCaptureBuffer (ReadBuffer) about to copy to buffer (size1 = %d )\n",size1);
		memcpy (buffer,p1,  size1);
	}

	if (p2)	 //There was wrapping
	{
		DPF1(1,"----- DXVB: DSoundCaptureBuffer (ReadBuffer) about to copy to buffer (size2 = %d )\n",size2);
		memcpy(&buffer[size1],p2,  size2);
	}

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	DPF(1,"----- DXVB: DSoundCaptureBuffer (ReadBuffer) Unlocking buffer.\n");
	val= m__dxj_DirectSoundCaptureBuffer->Unlock(p1, size1, p2, size2);
   }
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		DPF(1,"----- DXVB: (ReadBuffer) Exception.\n");
		return E_FAIL;
	}
   return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsound3dlistener.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsound3dlistener.cpp
//
//--------------------------------------------------------------------------

// dSound3DListener.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DListener.h"
#include "dSoundPrimaryBufferObj.h"

extern void *g_dxj_DirectSoundPrimaryBuffer;

CONSTRUCTOR(_dxj_DirectSound3dListener, {});
DESTRUCTOR(_dxj_DirectSound3dListener,  {});
GETSET_OBJECT(_dxj_DirectSound3dListener);

	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getDistanceFactor, GetDistanceFactor, float*);
	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getDopplerFactor, GetDopplerFactor, float*);
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, getOrientation, GetOrientation, D3DVECTOR_CDESC*, (_D3DVECTOR*) , D3DVECTOR_CDESC*, (_D3DVECTOR*) );
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dListener, getPosition, GetPosition, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getRolloffFactor, GetRolloffFactor, float*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dListener, getVelocity, GetVelocity, D3DVECTOR_CDESC*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setDistanceFactor, SetDistanceFactor, float ,(float),long,( DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setDopplerFactor, SetDopplerFactor, float , (float),long,(DWORD));
	PASS_THROUGH_CAST_7_R(_dxj_DirectSound3dListener, setOrientation, SetOrientation, 
		float,(float), float, (float), float,(float),float,(float),float, (float),
		float,(float),long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dListener, setPosition, SetPosition, float,(float), float, (float),float,(float),long,( DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setRolloffFactor, SetRolloffFactor,float,(float),  long, (DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dListener, setVelocity, SetVelocity, float,(float), float,(float), float,(float),long,(DWORD));
	PASS_THROUGH_R(_dxj_DirectSound3dListener, commitDeferredSettings, CommitDeferredSettings);

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::getAllParameters( DS3DLISTENER_CDESC* lobj )
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DLISTENER);
	return m__dxj_DirectSound3dListener->GetAllParameters( (LPDS3DLISTENER)lobj );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::setAllParameters( DS3DLISTENER_CDESC *lobj, long apply)
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DLISTENER);
	return m__dxj_DirectSound3dListener->SetAllParameters( (LPDS3DLISTENER)lobj, (DWORD)apply );
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::getDirectSoundBuffer( I_dxj_DirectSoundPrimaryBuffer **retv)
{
	HRESULT hr;
	IDirectSoundBuffer *pdsb;
	hr=m__dxj_DirectSound3dListener->QueryInterface(IID_IDirectSoundBuffer,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSoundPrimaryBuffer,pdsb,retv);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundbufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundbufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundBufferObj.h"
#include "dSoundObj.h"
#include "dSound3DListener.h"
#include "dSound3DBuffer.h"
#include "dsoundFXGargleobj.h"
#include "dsoundFXEchoobj.h"
#include "dsoundFXChorusobj.h"
#include "dsoundFXCompressorobj.h"
#include "dsoundFXDistortionobj.h"
#include "dsoundFXFlangerobj.h"
#include "dsoundfxi3dl2reverbobj.h"
#if 0
#include "dsoundfxi3dl2sourceobj.h"
#include "dsoundfxsendobj.h"
#endif
#include "dsoundfxparameqobj.h"
#include "dsoundfxwavesreverbobj.h"

extern void *g_dxj_DirectSoundFXWavesReverb;
extern void *g_dxj_DirectSoundFXCompressor;
extern void *g_dxj_DirectSoundFXChorus;
extern void *g_dxj_DirectSoundFXGargle;
extern void *g_dxj_DirectSoundFXEcho;
extern void *g_dxj_DirectSoundFXSend;
extern void *g_dxj_DirectSoundFXDistortion;
extern void *g_dxj_DirectSoundFXFlanger;
extern void *g_dxj_DirectSoundFXParamEQ;
extern void *g_dxj_DirectSoundFXI3DL2Reverb;
#if 0
extern void *g_dxj_DirectSoundFXI3DL2Source;
#endif
#define SAFE_DELETE(p) { if (p) {free(p); p = NULL;} }

extern HRESULT AudioBSTRtoGUID(LPGUID,BSTR);
extern HRESULT InternalSaveToFile(IDirectSoundBuffer *pBuff,BSTR file);

CONSTRUCTOR(_dxj_DirectSoundBuffer, {});
DESTRUCTOR(_dxj_DirectSoundBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundBuffer);

	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, getVolume, GetVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, getPan, GetPan, long*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, getFrequency, GetFrequency, long*,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, getStatus, GetStatus, long*,(DWORD*));

	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setCurrentPosition, SetCurrentPosition, long,(DWORD));
	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, setPan, SetPan, LONG);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setFrequency, SetFrequency, long,(DWORD));
	PASS_THROUGH_R(_dxj_DirectSoundBuffer, stop, Stop);
	PASS_THROUGH_R(_dxj_DirectSoundBuffer, restore, Restore);


STDMETHODIMP C_dxj_DirectSoundBufferObject::setVolume(LONG vol)
{
	__try {
		return m__dxj_DirectSoundBuffer->SetVolume(vol); 
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getDirectSound3dBuffer(I_dxj_DirectSound3dBuffer **retval)
{
    IDirectSound3DBuffer *lp3db;
	HRESULT hr = S_OK;

	__try {
		if( (hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSound3DBuffer, (void**) &lp3db)) != S_OK)
			return hr;

		INTERNAL_CREATE(_dxj_DirectSound3dBuffer, lp3db, retval);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getCaps(DSBCAPS_CDESC* caps)
{
	__try {
		if(!caps)
			return E_POINTER;

		caps->lSize = sizeof(DSBCAPS);
		return m__dxj_DirectSoundBuffer->GetCaps((LPDSBCAPS)caps); 
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::getCurrentPosition(DSCURSORS_CDESC *desc) 
{ 
	__try {
		if(!desc) return E_POINTER;
		return (m__dxj_DirectSoundBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

}

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::writeBuffer(long start, long totsz, 
					void  *buf,  long flags) 
{ 
	#pragma message ("SoundBuffer writeBuffer ")

	byte *buffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!buffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;

	__try {
		if ((val = m__dxj_DirectSoundBuffer->Lock((DWORD)start, (DWORD)totsz,
			 &p1, &size1, &p2, &size2,
			(DWORD)flags)) != DS_OK)
			return val;

		// Copy to buffer end, then do a wrapped portion if it exists, then unlock
		DPF1(1,"----- DXVB: DSoundBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
		if (p1)	
		{
			DPF1(1,"----- DXVB: DSoundBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
			memcpy (p1, buffer, size1);
		}

		if (p2)	 //There was wrapping
		{
			DPF1(1,"----- DXVB: DSoundBuffer (WriteBuffer) about to copy to buffer (size2 = %d )\n",size2);
			memcpy(p2, &buffer[size1], size2);
		}

		//docdoc: because Lock and Unlock are tied together within WriteBuffer,
		//        DSBufferDesc no longer needs to save Lock's system pointers.
		DPF(1,"----- DXVB: DSoundBuffer (WriteBuffer) Unlocking buffer.\n");
		val=m__dxj_DirectSoundBuffer->Unlock(p1, size1, p2, size2);
	}
	__except(0,0){
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::readBuffer(long start, long totsz,
	void  *buf,  long flags) 
{ 

	byte *buffer=(byte*)buf;

	if(!buffer)
		return E_POINTER;
	
	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	if ((val = m__dxj_DirectSoundBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (p1)	
	{
		DPF1(1,"----- DXVB: DSoundBuffer (ReadBuffer) about to copy to buffer (size1 = %d )\n",size1);
		memcpy (buffer,p1,  size1);
	}

	if (p2)	 //There was wrapping
	{
		DPF1(1,"----- DXVB: DSoundBuffer (ReadBuffer) about to copy to buffer (size2 = %d )\n",size2);
		memcpy(&buffer[size1],p2,  size2);
	}

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	DPF(1,"----- DXVB: DSoundBuffer (ReadBuffer) Unlocking buffer.\n");
	val= m__dxj_DirectSoundBuffer->Unlock(p1, size1, p2, size2);
   }
   __except(1,1){
	return E_FAIL;
   }
   return val;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::getFormat(WAVEFORMATEX_CDESC *format) 
{ 
	DWORD *wsize=0;	// docdoc: throw away returned written size

	HRESULT hr=DS_OK;
	__try {
		hr=m__dxj_DirectSoundBuffer->GetFormat((LPWAVEFORMATEX)format, (DWORD)sizeof(WAVEFORMATEX_CDESC), wsize);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
			
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::initialize(I_dxj_DirectSound *ds,
		 DSBUFFERDESC_CDESC *buf, unsigned char *wave) 
{
	if(! (ds && buf && wave) )
		return E_POINTER;


	LPDSBUFFERDESC lpds = NULL;

	__try {
		lpds = (LPDSBUFFERDESC)malloc(sizeof(DSBUFFERDESC));
		if (!lpds)
			return E_OUTOFMEMORY;

		ZeroMemory(lpds, sizeof(DSBUFFERDESC));

		lpds->dwSize = sizeof(DSBUFFERDESC);
		lpds->dwFlags = buf->lFlags;
		lpds->dwBufferBytes = buf->lBufferBytes;
		lpds->dwReserved = buf->lReserved;
#ifdef _WIN64
		lpds->lpwfxFormat = (WAVEFORMATEX*)wave;
#else
		lpds->lpwfxFormat = (WAVEFORMATEX*)PtrToLong(wave);
#endif
		AudioBSTRtoGUID(&lpds->guid3DAlgorithm, buf->guid3DAlgorithm);

		DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpdsound, ds)

		m__dxj_DirectSoundBuffer->Initialize(lpdsound, (LPDSBUFFERDESC)lpds);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::play(long flags) 
{
	HRESULT hr=DS_OK;
	__try {
		if((hr=m__dxj_DirectSoundBuffer->Play(0, 0, (DWORD)flags)) != DS_OK)
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return hr;
}



STDMETHODIMP C_dxj_DirectSoundBufferObject::setNotificationPositions (long nElements,SAFEARRAY  **ppsa)
{
	if (!ISSAFEARRAY1D(ppsa,(DWORD)nElements))
		return E_INVALIDARG;
	
	HRESULT hr;
	LPDIRECTSOUNDNOTIFY pDSN=NULL;

	__try {
		if (nElements == 0)
		{
			// There is absolutely nothing to do if we want to set 0 notification positions
			return S_OK;
		}

		hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSoundNotify,(void**)&pDSN);
		if FAILED(hr) return hr;

		hr=pDSN->SetNotificationPositions((DWORD)nElements,(LPCDSBPOSITIONNOTIFY)((SAFEARRAY*)*ppsa)->pvData);	
			
		pDSN->Release();

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


STDMETHODIMP C_dxj_DirectSoundBufferObject::saveToFile(BSTR file)
{

	HRESULT hr= InternalSaveToFile(m__dxj_DirectSoundBuffer,file);
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::SetFX(long lEffectsCount, SAFEARRAY **Buffers, SAFEARRAY **lResultIDs)
{
	HRESULT hr;

	DSEFFECTDESC		*dsec = NULL;
	DSEFFECTDESC_CDESC	*bufTemp = NULL;
	
	DWORD				*dwRetStatus = NULL;

	__try {
		if (lEffectsCount != 0)
		{
			// Get memory for our effects buffers
			dsec = (DSEFFECTDESC*)malloc(sizeof(DSEFFECTDESC) * lEffectsCount);
			if (!dsec) return E_OUTOFMEMORY;

			//Get memory for our Status
			dwRetStatus = (DWORD*)malloc(sizeof(DWORD) * lEffectsCount);
			if (!dwRetStatus)
			{
				SAFE_DELETE(dsec);
				return E_OUTOFMEMORY;
			}
			ZeroMemory(dwRetStatus,sizeof(DWORD) * lEffectsCount);

			bufTemp = (DSEFFECTDESC_CDESC*)malloc(sizeof(DSEFFECTDESC_CDESC) * lEffectsCount);
			if (!bufTemp) return E_OUTOFMEMORY;

			memcpy(bufTemp, (DSEFFECTDESC_CDESC*)((SAFEARRAY*)*Buffers)->pvData, sizeof(DSEFFECTDESC_CDESC) * lEffectsCount);

			// Set up our effect
			for (int i=0 ; i<=lEffectsCount-1 ; i++)
			{
				ZeroMemory(&dsec[i], sizeof(DSEFFECTDESC));
				dsec[i].dwSize = sizeof(DSEFFECTDESC);
				dsec[i].dwFlags	= (DWORD) bufTemp[i].lFlags;
				#if 0
				DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDBUFFER, lpBuf, bufTemp[i].SendBuffer);
				dsec[i].lpSendBuffer = lpBuf;
				#endif
				if (FAILED (hr = AudioBSTRtoGUID(&dsec[i].guidDSFXClass, bufTemp[i].guidDSFXClass ) ) )
				{
					SAFE_DELETE(dsec);
					SAFE_DELETE(bufTemp);
					return hr;
				}
			}
			// We no longer need this 
			SAFE_DELETE(bufTemp);
		}

		if (FAILED (hr = m__dxj_DirectSoundBuffer->SetFX((DWORD)lEffectsCount, dsec, dwRetStatus) ))
		{
			SAFE_DELETE(dsec);
			return hr;
		}

		SAFE_DELETE(dsec);
		// Now we can return our status's
		if (dwRetStatus)
			memcpy(((SAFEARRAY*)*lResultIDs)->pvData, dwRetStatus, sizeof(DWORD) * lEffectsCount);

		SAFE_DELETE(dwRetStatus);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}
		 
STDMETHODIMP C_dxj_DirectSoundBufferObject::AcquireResources(long lFlags, SAFEARRAY **lEffects)
{
	HRESULT hr;
	DWORD				*dwRetStatus = NULL;
	DWORD				dwEffectsCount = 0;

	__try {
		dwEffectsCount = (DWORD)((SAFEARRAY*)*lEffects)->rgsabound[0].cElements;
		//Get memory for our Status
		dwRetStatus = (DWORD*)malloc(sizeof(DWORD) * dwEffectsCount);
		if (!dwRetStatus)
			return E_OUTOFMEMORY;

		ZeroMemory(dwRetStatus,sizeof(DWORD) * dwEffectsCount);

		if (FAILED ( hr = m__dxj_DirectSoundBuffer->AcquireResources((DWORD) lFlags, dwEffectsCount, dwRetStatus) ) )
			return hr;
		
		// Now we can return our status's
		memcpy(((SAFEARRAY*)*lEffects)->pvData, dwRetStatus, sizeof(DWORD) * dwEffectsCount);
		SAFE_DELETE(dwRetStatus);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::GetObjectinPath(BSTR guidFX, long lIndex, BSTR iidInterface, IUnknown **ret)
{
	HRESULT hr;
	GUID guidEffect;
	GUID guidIID;

	__try {
		if (FAILED (hr = AudioBSTRtoGUID(&guidEffect, guidFX ) ) )
			return hr;

		if (FAILED (hr = AudioBSTRtoGUID(&guidIID, iidInterface ) ) )
			return hr;


		if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_gargle")){
			IDirectSoundFXGargle	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXGargle, lpRetObj, ret);
		}
#if 0
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_send")){
			IDirectSoundFXSend	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXSend, lpRetObj, ret);
		}
#endif
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_echo")){
			IDirectSoundFXEcho	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXEcho, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_chorus")){
			IDirectSoundFXChorus	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXChorus, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_compressor")){
			IDirectSoundFXCompressor	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXCompressor, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_distortion")){
			IDirectSoundFXDistortion	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXDistortion, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_flanger")){
			IDirectSoundFXFlanger	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXFlanger, lpRetObj, ret);
		}
#if 0
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_i3dl2source")){
			IDirectSoundFXI3DL2Source	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXI3DL2Source, lpRetObj, ret);
		}
#endif
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_i3dl2reverb")){
			IDirectSoundFXI3DL2Reverb	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXI3DL2Reverb, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_standard_parameq")){
			IDirectSoundFXParamEq	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXParamEQ, lpRetObj, ret);
		}
		else if( 0==_wcsicmp(guidFX,L"guid_dsfx_waves_reverb")){
			IDirectSoundFXWavesReverb	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectSoundBuffer->GetObjectInPath(guidEffect, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXWavesReverb, lpRetObj, ret);
		}
		else
			return E_INVALIDARG;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

#if 0
STDMETHODIMP C_dxj_DirectSoundBufferObject::SetChannelVolume(long lChannelCount, SAFEARRAY **lChannels, SAFEARRAY **lVolumes)
{
	HRESULT hr;

	__try {
		if (FAILED(hr = m__dxj_DirectSoundBuffer->SetChannelVolume((DWORD) lChannelCount, (DWORD*) ((SAFEARRAY*)*lChannels)->pvData, (long*) ((SAFEARRAY*)*lVolumes)->pvData) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsound3dlistener.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsound3dlistener.h
//
//--------------------------------------------------------------------------

// dSound3DListener.h : Declaration of the C_dxj_DirectSound3dListenerObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound3dListener LPDIRECTSOUND3DLISTENER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSound3dListenerObject : 
	public I_dxj_DirectSound3dListener,
	//public CComCoClass<C_dxj_DirectSound3dListenerObject, &CLSID__dxj_DirectSound3dListener>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSound3dListenerObject() ;
	virtual ~C_dxj_DirectSound3dListenerObject() ;

BEGIN_COM_MAP(C_dxj_DirectSound3dListenerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound3dListener)
END_COM_MAP()

//y	DECLARE_REGISTRY(CLSID__dxj_DirectSound3dListener,	"DIRECT.DirectSound3dListener.3",	"DIRECT.DirectSound3dListener.3",		IDS_DSOUND3DLISTENER_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_DirectSound3dListenerObject)

// I_dxj_DirectSound3dListener
public:
	/*** IDirectSound3D methods ***/
	//
	//updated

	     /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE getAllParameters( 
            /* [out][in] */ DS3DLISTENER_CDESC __RPC_FAR *listener) ;
        
         HRESULT STDMETHODCALLTYPE getDistanceFactor( 
            /* [retval][out] */ float __RPC_FAR *distanceFactor) ;
        
         HRESULT STDMETHODCALLTYPE getDopplerFactor( 
            /* [retval][out] */ float __RPC_FAR *dopplerFactor) ;
        
         HRESULT STDMETHODCALLTYPE getOrientation( 
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *orientFront,
            /* [out][in] */ D3DVECTOR_CDESC __RPC_FAR *orientTop) ;
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [out] */ D3DVECTOR_CDESC __RPC_FAR *position) ;
        
         HRESULT STDMETHODCALLTYPE getRolloffFactor( 
            /* [retval][out] */ float __RPC_FAR *rolloffFactor) ;
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [retval][out] */ D3DVECTOR_CDESC __RPC_FAR *velocity) ;
        
         HRESULT STDMETHODCALLTYPE setAllParameters( 
            /* [in] */ DS3DLISTENER_CDESC __RPC_FAR *listener,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setDistanceFactor( 
            /* [in] */ float distanceFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setDopplerFactor( 
            /* [in] */ float dopplerFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setOrientation( 
            /* [in] */ float xFront,
            /* [in] */ float yFront,
            /* [in] */ float zFront,
            /* [in] */ float xTop,
            /* [in] */ float yTop,
            /* [in] */ float zTop,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setRolloffFactor( 
            /* [in] */ float rolloffFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE commitDeferredSettings( void) ;
        
         HRESULT STDMETHODCALLTYPE getDirectSoundBuffer( 
            /* [retval][out] */ I_dxj_DirectSoundPrimaryBuffer __RPC_FAR *__RPC_FAR *retVal) ;
private:
    DECL_VARIABLE(_dxj_DirectSound3dListener);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound3dListener )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundcaptureobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundcaptureobj.cpp
//
//--------------------------------------------------------------------------

// dSoundCaptureObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundObj.h"
#include "dSoundCaptureObj.h"
#include "dSoundCaptureBufferObj.h"

CONSTRUCTOR(_dxj_DirectSoundCapture, {});
DESTRUCTOR(_dxj_DirectSoundCapture, {});
GETSET_OBJECT(_dxj_DirectSoundCapture);

   

STDMETHODIMP C_dxj_DirectSoundCaptureObject::createCaptureBuffer(
	DSCBUFFERDESC_CDESC *desc,I_dxj_DirectSoundCaptureBuffer **retval)
{
    
	HRESULT						hr = S_OK;
	IDirectSoundCaptureBuffer	*lpBuffer=NULL;
	DSCBUFFERDESC				realDesc;
	
	ZeroMemory(&realDesc, sizeof(DSCBUFFERDESC));

	realDesc.dwSize = sizeof(DSCBUFFERDESC);
	
	realDesc.dwBufferBytes = desc->lBufferBytes;
	realDesc.dwReserved = desc->lReserved;
	realDesc.lpwfxFormat = (WAVEFORMATEX*)&desc->fxFormat;

    hr=m__dxj_DirectSoundCapture->CreateCaptureBuffer(&realDesc,&lpBuffer,NULL);	
	if FAILED(hr) return hr;
	
	INTERNAL_CREATE(_dxj_DirectSoundCaptureBuffer, lpBuffer, retval);
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundCaptureObject::getCaps(DSCCAPS_CDESC *caps){
	((DSCCAPS*)caps)->dwSize=sizeof(DSCCAPS);
	return m__dxj_DirectSoundCapture->GetCaps((DSCCAPS*)caps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxchorusobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXChorus LPDIRECTSOUNDFXCHORUS8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXChorusObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXChorus, &IID_I_dxj_DirectSoundFXChorus, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXChorus,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXChorusObject() ;
	virtual ~C_dxj_DirectSoundFXChorusObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXChorusObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXChorus)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXChorusObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXChorus
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXCHORUS_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXCHORUS_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXChorus);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXChorus);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundcaptureobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsoundcaptureobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundCaptureObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundCapture LPDIRECTSOUNDCAPTURE8
#ifndef _DSOUNDCAPTUREOBJ_H_
#define _DSOUNDCAPTUREOBJ_H_
/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundCaptureObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundCapture, &IID_I_dxj_DirectSoundCapture, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundCapture,
#endif

	//public CComCoClass<C_dxj_DirectSoundCaptureObject, &CLSID__dxj_DirectSoundCapture>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundCaptureObject() ;
	virtual ~C_dxj_DirectSoundCaptureObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundCaptureObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundCapture)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSoundCapture,	"DIRECT.DirectSoundCapture.5",		"DIRECT.DirectSoundCapture.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundCaptureObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundCaptureObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundCapture
public:
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE createCaptureBuffer( 
            /* [in] */ DSCBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundCaptureBuffer __RPC_FAR *__RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCCAPS_CDESC __RPC_FAR *caps) ;

private:
    DECL_VARIABLE(_dxj_DirectSoundCapture);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundCapture )
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxcompressorobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXCompressor LPDIRECTSOUNDFXCOMPRESSOR8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXCompressorObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXCompressor, &IID_I_dxj_DirectSoundFXCompressor, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXCompressor,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXCompressorObject() ;
	virtual ~C_dxj_DirectSoundFXCompressorObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXCompressorObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXCompressor)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXCompressorObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXCompressor
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXCOMPRESSOR_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXCOMPRESSOR_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXCompressor);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXCompressor);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsounddownloadedwaveobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectSoundDownloadedWave LPDIRECTSOUNDDOWNLOADEDWAVE8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundDownloadedWaveObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundDownloadedWave, &IID_I_dxj_DirectSoundDownloadedWave, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundDownloadedWave,
#endif

	public CComObjectRoot
{

public:
	C_dxj_DirectSoundDownloadedWaveObject() ;
	virtual ~C_dxj_DirectSoundDownloadedWaveObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundDownloadedWaveObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundDownloadedWave)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundDownloadedWaveObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundDownloadedWave
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundDownloadedWave);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundDownloadedWave);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsounddownloadedwaveobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundDownloadedWaveObj.h"

extern void *g_dxj_DirectSoundDownloadedWave;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundDownloadedWaveObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundDownloadedWave [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundDownloadedWaveObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundDownloadedWave [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundDownloadedWaveObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundDownloadedWaveObject::C_dxj_DirectSoundDownloadedWaveObject(){ 
		
	DPF1(1,"Constructor Creation DirectSoundDownloadedWave Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundDownloadedWave = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundDownloadedWave;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundDownloadedWave = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundDownloadedWaveObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundDownloadedWaveObject::~C_dxj_DirectSoundDownloadedWaveObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundDownloadedWaveObject destructor \n");

     C_dxj_DirectSoundDownloadedWaveObject *prev=NULL; 
	for(C_dxj_DirectSoundDownloadedWaveObject *ptr=(C_dxj_DirectSoundDownloadedWaveObject*)g_dxj_DirectSoundDownloadedWave ; ptr; ptr=(C_dxj_DirectSoundDownloadedWaveObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundDownloadedWave = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundDownloadedWave found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundDownloadedWave){
		int count = IUNK(m__dxj_DirectSoundDownloadedWave)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundDownloadedWave Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundDownloadedWave = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();
	
}

HRESULT C_dxj_DirectSoundDownloadedWaveObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundDownloadedWave;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundDownloadedWaveObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundDownloadedWave=(LPDIRECTSOUNDDOWNLOADEDWAVE)pUnk;
	return S_OK;
}

//////////////
/// No Methods
//////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxchorusobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXChorusObj.h"					   

extern void *g_dxj_DirectSoundFXChorus;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXChorusObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXChorus [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXChorusObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXChorus [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXChorusObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXChorusObject::C_dxj_DirectSoundFXChorusObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXChorus Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXChorus = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXChorus;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXChorus = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXChorusObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXChorusObject::~C_dxj_DirectSoundFXChorusObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXChorusObject destructor \n");

     C_dxj_DirectSoundFXChorusObject *prev=NULL; 
	for(C_dxj_DirectSoundFXChorusObject *ptr=(C_dxj_DirectSoundFXChorusObject *)g_dxj_DirectSoundFXChorus ; ptr; ptr=(C_dxj_DirectSoundFXChorusObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXChorus = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXChorusObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXChorus){
		int count = IUNK(m__dxj_DirectSoundFXChorus)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXChorus Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXChorus = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXChorusObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXChorus;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXChorusObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXChorus=(LPDIRECTSOUNDFXCHORUS8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXChorusObject::SetAllParameters(DSFXCHORUS_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXChorus->SetAllParameters((DSFXChorus*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXChorusObject::GetAllParameters(DSFXCHORUS_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXChorus->GetAllParameters((DSFXChorus*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxcompressorobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXCompressorObj.h"					   

extern void *g_dxj_DirectSoundFXCompressor;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXCompressorObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXCompressor [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXCompressorObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXCompressor [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXCompressorObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXCompressorObject::C_dxj_DirectSoundFXCompressorObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXCompressor Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXCompressor = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXCompressor;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXCompressor = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXCompressorObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXCompressorObject::~C_dxj_DirectSoundFXCompressorObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXCompressorObject destructor \n");

     C_dxj_DirectSoundFXCompressorObject *prev=NULL; 
	for(C_dxj_DirectSoundFXCompressorObject *ptr=(C_dxj_DirectSoundFXCompressorObject *)g_dxj_DirectSoundFXCompressor ; ptr; ptr=(C_dxj_DirectSoundFXCompressorObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXCompressor = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXCompressorObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXCompressor){
		int count = IUNK(m__dxj_DirectSoundFXCompressor)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXCompressor Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXCompressor = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXCompressorObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXCompressor;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXCompressorObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXCompressor=(LPDIRECTSOUNDFXCOMPRESSOR8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXCompressorObject::SetAllParameters(DSFXCOMPRESSOR_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXCompressor->SetAllParameters((DSFXCompressor*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXCompressorObject::GetAllParameters(DSFXCOMPRESSOR_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXCompressor->GetAllParameters((DSFXCompressor*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxdistortionobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXDistortionObj.h"					   

extern void *g_dxj_DirectSoundFXDistortion;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXDistortionObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXDistortion [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXDistortionObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXDistortion [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXDistortionObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXDistortionObject::C_dxj_DirectSoundFXDistortionObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXDistortion Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXDistortion = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXDistortion;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXDistortion = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXDistortionObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXDistortionObject::~C_dxj_DirectSoundFXDistortionObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXDistortionObject destructor \n");

     C_dxj_DirectSoundFXDistortionObject *prev=NULL; 
	for(C_dxj_DirectSoundFXDistortionObject *ptr=(C_dxj_DirectSoundFXDistortionObject *)g_dxj_DirectSoundFXDistortion ; ptr; ptr=(C_dxj_DirectSoundFXDistortionObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXDistortion = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXDistortionObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXDistortion){
		int count = IUNK(m__dxj_DirectSoundFXDistortion)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXDistortion Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXDistortion = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXDistortionObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXDistortion;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXDistortionObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXDistortion=(LPDIRECTSOUNDFXDISTORTION8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXDistortionObject::SetAllParameters(DSFXDISTORTION_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXDistortion->SetAllParameters((DSFXDistortion*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXDistortionObject::GetAllParameters(DSFXDISTORTION_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXDistortion->GetAllParameters((DSFXDistortion*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxdistortionobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXDistortion LPDIRECTSOUNDFXDISTORTION8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXDistortionObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXDistortion, &IID_I_dxj_DirectSoundFXDistortion, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXDistortion,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXDistortionObject() ;
	virtual ~C_dxj_DirectSoundFXDistortionObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXDistortionObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXDistortion)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXDistortionObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXDistortion
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXDISTORTION_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXDISTORTION_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXDistortion);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXDistortion);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxechoobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXEcho LPDIRECTSOUNDFXECHO8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXEchoObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXEcho, &IID_I_dxj_DirectSoundFXEcho, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXEcho,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXEchoObject() ;
	virtual ~C_dxj_DirectSoundFXEchoObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXEchoObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXEcho)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXEchoObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXEcho
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXECHO_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXECHO_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXEcho);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXEcho);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxflangerobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXFlanger LPDIRECTSOUNDFXFLANGER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXFlangerObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXFlanger, &IID_I_dxj_DirectSoundFXFlanger, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXFlanger,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXFlangerObject() ;
	virtual ~C_dxj_DirectSoundFXFlangerObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXFlangerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXFlanger)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXFlangerObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXFlanger
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXFLANGER_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXFLANGER_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXFlanger);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXFlanger);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxechoobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXEchoObj.h"					   

extern void *g_dxj_DirectSoundFXEcho;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXEchoObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXEcho [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXEchoObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXEcho [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXEchoObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXEchoObject::C_dxj_DirectSoundFXEchoObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXEcho Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXEcho = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXEcho;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXEcho = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXEchoObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXEchoObject::~C_dxj_DirectSoundFXEchoObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXEchoObject destructor \n");

     C_dxj_DirectSoundFXEchoObject *prev=NULL; 
	for(C_dxj_DirectSoundFXEchoObject *ptr=(C_dxj_DirectSoundFXEchoObject *)g_dxj_DirectSoundFXEcho ; ptr; ptr=(C_dxj_DirectSoundFXEchoObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXEcho = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXEchoObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXEcho){
		int count = IUNK(m__dxj_DirectSoundFXEcho)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXEcho Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXEcho = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXEchoObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXEcho;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXEchoObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXEcho=(LPDIRECTSOUNDFXECHO8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXEchoObject::SetAllParameters(DSFXECHO_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXEcho->SetAllParameters((DSFXEcho*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXEchoObject::GetAllParameters(DSFXECHO_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXEcho->GetAllParameters((DSFXEcho*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxgargleobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXGargleObj.h"					   

extern void *g_dxj_DirectSoundFXGargle;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXGargleObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXGargle [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXGargleObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXGargle [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXGargleObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXGargleObject::C_dxj_DirectSoundFXGargleObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXGargle Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXGargle = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXGargle;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXGargle = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXGargleObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXGargleObject::~C_dxj_DirectSoundFXGargleObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXGargleObject destructor \n");

     C_dxj_DirectSoundFXGargleObject *prev=NULL; 
	for(C_dxj_DirectSoundFXGargleObject *ptr=(C_dxj_DirectSoundFXGargleObject *)g_dxj_DirectSoundFXGargle ; ptr; ptr=(C_dxj_DirectSoundFXGargleObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXGargle = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXGargleObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXGargle){
		int count = IUNK(m__dxj_DirectSoundFXGargle)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXGargle Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXGargle = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXGargleObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXGargle;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXGargleObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXGargle=(LPDIRECTSOUNDFXGARGLE8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXGargleObject::SetAllParameters(DSFXGARGLE_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXGargle->SetAllParameters((DSFXGargle*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXGargleObject::GetAllParameters(DSFXGARGLE_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXGargle->GetAllParameters((DSFXGargle*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxflangerobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXFlangerObj.h"					   

extern void *g_dxj_DirectSoundFXFlanger;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXFlangerObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXFlanger [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXFlangerObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXFlanger [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXFlangerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXFlangerObject::C_dxj_DirectSoundFXFlangerObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXFlanger Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXFlanger = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXFlanger;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXFlanger = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXFlangerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXFlangerObject::~C_dxj_DirectSoundFXFlangerObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXFlangerObject destructor \n");

     C_dxj_DirectSoundFXFlangerObject *prev=NULL; 
	for(C_dxj_DirectSoundFXFlangerObject *ptr=(C_dxj_DirectSoundFXFlangerObject *)g_dxj_DirectSoundFXFlanger ; ptr; ptr=(C_dxj_DirectSoundFXFlangerObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXFlanger = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXFlangerObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXFlanger){
		int count = IUNK(m__dxj_DirectSoundFXFlanger)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXFlanger Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXFlanger = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXFlangerObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXFlanger;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXFlangerObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXFlanger=(LPDIRECTSOUNDFXFLANGER8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXFlangerObject::SetAllParameters(DSFXFLANGER_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXFlanger->SetAllParameters((DSFXFlanger*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXFlangerObject::GetAllParameters(DSFXFLANGER_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXFlanger->GetAllParameters((DSFXFlanger*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxi3dl2reverbobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXI3DL2ReverbObj.h"					   

extern void *g_dxj_DirectSoundFXI3DL2Reverb;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXI3DL2ReverbObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXI3DL2Reverb [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXI3DL2ReverbObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXI3DL2Reverb [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXI3DL2ReverbObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXI3DL2ReverbObject::C_dxj_DirectSoundFXI3DL2ReverbObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXI3DL2Reverb Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXI3DL2Reverb = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXI3DL2Reverb;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXI3DL2Reverb = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXI3DL2ReverbObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXI3DL2ReverbObject::~C_dxj_DirectSoundFXI3DL2ReverbObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXI3DL2ReverbObject destructor \n");

     C_dxj_DirectSoundFXI3DL2ReverbObject *prev=NULL; 
	for(C_dxj_DirectSoundFXI3DL2ReverbObject *ptr=(C_dxj_DirectSoundFXI3DL2ReverbObject *)g_dxj_DirectSoundFXI3DL2Reverb ; ptr; ptr=(C_dxj_DirectSoundFXI3DL2ReverbObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXI3DL2Reverb = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXI3DL2ReverbObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXI3DL2Reverb){
		int count = IUNK(m__dxj_DirectSoundFXI3DL2Reverb)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXI3DL2Reverb Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXI3DL2Reverb = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXI3DL2Reverb;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXI3DL2Reverb=(LPDIRECTSOUNDFXI3DL2REVERB8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::SetAllParameters(DSFXI3DL2REVERB_CDESC *params)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->SetAllParameters((DSFXI3DL2Reverb*) params) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::GetAllParameters(DSFXI3DL2REVERB_CDESC *params)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->GetAllParameters((DSFXI3DL2Reverb*) params) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::SetPreset(long lPreset)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->SetPreset((DWORD) lPreset) ))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::GetPreset(long *ret)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->GetPreset((DWORD*) ret) ))
			return hr;
	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::SetQuality(long lQuality)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->SetQuality(lQuality) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2ReverbObject::GetQuality(long *ret)
{
	HRESULT hr;

	__try {
		if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Reverb->GetQuality(ret) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxgargleobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXGargle LPDIRECTSOUNDFXGARGLE8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXGargleObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXGargle, &IID_I_dxj_DirectSoundFXGargle, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXGargle,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXGargleObject() ;
	virtual ~C_dxj_DirectSoundFXGargleObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXGargleObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXGargle)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXGargleObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXGargle
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXGARGLE_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXGARGLE_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXGargle);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXGargle);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxi3dl2sourceobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXI3DL2Source LPDIRECTSOUNDFXI3DL2SOURCE8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXI3DL2SourceObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXI3DL2Source, &IID_I_dxj_DirectSoundFXI3DL2Source, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXI3DL2Source,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXI3DL2SourceObject() ;
	virtual ~C_dxj_DirectSoundFXI3DL2SourceObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXI3DL2SourceObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXI3DL2Source)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXI3DL2SourceObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXI3DL2Source
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXI3DL2SOURCE_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXI3DL2SOURCE_CDESC *params);
		HRESULT STDMETHODCALLTYPE SetObstructionPreset(long lObstruction);
		HRESULT STDMETHODCALLTYPE GetObstructionPreset(long *ret);
		HRESULT STDMETHODCALLTYPE SetOcclusionPreset(long lOcclusion);
		HRESULT STDMETHODCALLTYPE GetOcclusionPreset(long *ret);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXI3DL2Source);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXI3DL2Source);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxsendobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXSend LPDIRECTSOUNDFXSEND8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXSendObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXSend, &IID_I_dxj_DirectSoundFXSend, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXSend,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXSendObject() ;
	virtual ~C_dxj_DirectSoundFXSendObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXSendObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXSend)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXSendObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXSend
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXSEND_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXSEND_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXSend);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXSend);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxi3dl2reverbobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXI3DL2Reverb LPDIRECTSOUNDFXI3DL2REVERB8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXI3DL2ReverbObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXI3DL2Reverb, &IID_I_dxj_DirectSoundFXI3DL2Reverb, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXI3DL2Reverb,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXI3DL2ReverbObject() ;
	virtual ~C_dxj_DirectSoundFXI3DL2ReverbObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXI3DL2ReverbObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXI3DL2Reverb)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXI3DL2ReverbObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXI3DL2Reverb
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXI3DL2REVERB_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXI3DL2REVERB_CDESC *params);
		HRESULT STDMETHODCALLTYPE SetPreset(long lPreset);
		HRESULT STDMETHODCALLTYPE GetPreset(long *ret);
		HRESULT STDMETHODCALLTYPE SetQuality(long lQuality);
		HRESULT STDMETHODCALLTYPE GetQuality(long *ret);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXI3DL2Reverb);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXI3DL2Reverb);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxsendobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXSendObj.h"					   

extern void *g_dxj_DirectSoundFXSend;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXSendObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXSend [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXSendObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXSend [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXSendObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXSendObject::C_dxj_DirectSoundFXSendObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXSend Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXSend = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXSend;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXSend = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXSendObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXSendObject::~C_dxj_DirectSoundFXSendObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXSendObject destructor \n");

     C_dxj_DirectSoundFXSendObject *prev=NULL; 
	for(C_dxj_DirectSoundFXSendObject *ptr=(C_dxj_DirectSoundFXSendObject *)g_dxj_DirectSoundFXSend ; ptr; ptr=(C_dxj_DirectSoundFXSendObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXSend = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXSendObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXSend){
		int count = IUNK(m__dxj_DirectSoundFXSend)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXSend Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXSend = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXSendObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXSend;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXSendObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXSend=(LPDIRECTSOUNDFXSEND8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXSendObject::SetAllParameters(DSFXSEND_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXSend->SetAllParameters((DSFXSend*)params) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXSendObject::GetAllParameters(DSFXSEND_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXSend->GetAllParameters((DSFXSend*)params) ) )
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxi3dl2sourceobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXI3DL2SourceObj.h"					   

extern void *g_dxj_DirectSoundFXI3DL2Source;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXI3DL2SourceObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXI3DL2Source [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXI3DL2SourceObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXI3DL2Source [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXI3DL2SourceObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXI3DL2SourceObject::C_dxj_DirectSoundFXI3DL2SourceObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXI3DL2Source Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXI3DL2Source = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXI3DL2Source;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXI3DL2Source = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXI3DL2SourceObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXI3DL2SourceObject::~C_dxj_DirectSoundFXI3DL2SourceObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXI3DL2SourceObject destructor \n");

     C_dxj_DirectSoundFXI3DL2SourceObject *prev=NULL; 
	for(C_dxj_DirectSoundFXI3DL2SourceObject *ptr=(C_dxj_DirectSoundFXI3DL2SourceObject *)g_dxj_DirectSoundFXI3DL2Source ; ptr; ptr=(C_dxj_DirectSoundFXI3DL2SourceObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXI3DL2Source = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXI3DL2SourceObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXI3DL2Source){
		int count = IUNK(m__dxj_DirectSoundFXI3DL2Source)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXI3DL2Source Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXI3DL2Source = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXI3DL2Source;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXI3DL2Source=(LPDIRECTSOUNDFXI3DL2SOURCE8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::SetAllParameters(DSFXI3DL2SOURCE_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->SetAllParameters((DSFXI3DL2Source*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::GetAllParameters(DSFXI3DL2SOURCE_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->GetAllParameters((DSFXI3DL2Source*) params) ))
		return hr;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::SetObstructionPreset(long lObstruction)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->SetObstructionPreset((DWORD) lObstruction) ))
		return hr;
	
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::GetObstructionPreset(long *ret)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->GetObstructionPreset((DWORD*) ret) ))
		return hr;
	
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::SetOcclusionPreset(long lOcclusion)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->SetOcclusionPreset((DWORD) lOcclusion) ))
		return hr;
	
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXI3DL2SourceObject::GetOcclusionPreset(long *ret)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXI3DL2Source->GetOcclusionPreset((DWORD*) ret) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxparameqobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXParamEQ LPDIRECTSOUNDFXPARAMEQ8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXParamEQObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXParamEQ, &IID_I_dxj_DirectSoundFXParamEQ, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXParamEQ,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXParamEQObject() ;
	virtual ~C_dxj_DirectSoundFXParamEQObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXParamEQObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXParamEQ)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXParamEQObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXParamEQ
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXPARAMEQ_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXPARAMEQ_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXParamEQ);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXParamEQ);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxparameqobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXParamEQObj.h"					   

extern void *g_dxj_DirectSoundFXParamEQ;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXParamEQObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXParamEQ [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXParamEQObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXParamEQ [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXParamEQObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXParamEQObject::C_dxj_DirectSoundFXParamEQObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXParamEQ Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXParamEQ = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXParamEQ;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXParamEQ = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXParamEQObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXParamEQObject::~C_dxj_DirectSoundFXParamEQObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXParamEQObject destructor \n");

     C_dxj_DirectSoundFXParamEQObject *prev=NULL; 
	for(C_dxj_DirectSoundFXParamEQObject *ptr=(C_dxj_DirectSoundFXParamEQObject *)g_dxj_DirectSoundFXParamEQ ; ptr; ptr=(C_dxj_DirectSoundFXParamEQObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXParamEQ = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXParamEQObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXParamEQ){
		int count = IUNK(m__dxj_DirectSoundFXParamEQ)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXParamEQ Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXParamEQ = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXParamEQObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXParamEQ;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXParamEQObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXParamEQ=(LPDIRECTSOUNDFXPARAMEQ8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXParamEQObject::SetAllParameters(DSFXPARAMEQ_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXParamEQ->SetAllParameters((DSFXParamEq*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXParamEQObject::GetAllParameters(DSFXPARAMEQ_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXParamEQ->GetAllParameters((DSFXParamEq*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxwavesreverbobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundFXWavesReverb IDirectSoundFXWavesReverb*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundFXWavesReverbObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundFXWavesReverb, &IID_I_dxj_DirectSoundFXWavesReverb, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundFXWavesReverb,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectSoundFXWavesReverbObject() ;
	virtual ~C_dxj_DirectSoundFXWavesReverbObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundFXWavesReverbObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundFXWavesReverb)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundFXWavesReverbObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundFXWavesReverb
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE SetAllParameters(DSFXWAVESREVERB_CDESC *params);
		HRESULT STDMETHODCALLTYPE GetAllParameters(DSFXWAVESREVERB_CDESC *params);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundFXWavesReverb);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundFXWavesReverb);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundfxwavesreverbobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundFXWavesReverbObj.h"					   

extern void *g_dxj_DirectSoundFXWavesReverb;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXWavesReverbObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundFXWavesReverb [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundFXWavesReverbObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundFXWavesReverb [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundFXWavesReverbObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXWavesReverbObject::C_dxj_DirectSoundFXWavesReverbObject(){ 
		
	DPF1(1,"Constructor Creation  DirectSoundFXWavesReverb Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundFXWavesReverb = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundFXWavesReverb;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundFXWavesReverb = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundFXWavesReverbObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundFXWavesReverbObject::~C_dxj_DirectSoundFXWavesReverbObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundFXWavesReverbObject destructor \n");

     C_dxj_DirectSoundFXWavesReverbObject *prev=NULL; 
	for(C_dxj_DirectSoundFXWavesReverbObject *ptr=(C_dxj_DirectSoundFXWavesReverbObject *)g_dxj_DirectSoundFXWavesReverb ; ptr; ptr=(C_dxj_DirectSoundFXWavesReverbObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundFXWavesReverb = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundFXWavesReverbObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundFXWavesReverb){
		int count = IUNK(m__dxj_DirectSoundFXWavesReverb)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundFXWavesReverb Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundFXWavesReverb = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectSoundFXWavesReverbObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundFXWavesReverb;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundFXWavesReverbObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundFXWavesReverb=(IDirectSoundFXWavesReverb*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundFXWavesReverbObject::SetAllParameters(DSFXWAVESREVERB_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXWavesReverb->SetAllParameters((DSFXWavesReverb*) params) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundFXWavesReverbObject::GetAllParameters(DSFXWAVESREVERB_CDESC *params)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectSoundFXWavesReverb->GetAllParameters((DSFXWavesReverb*) params) ))
		return hr;
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundsinkobj.h ===
#include "resource.h"       // main symbols
#include "dsound.h"

#define typedef__dxj_DirectSoundSink LPDIRECTSOUNDSINK8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundSinkObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundSink, &IID_I_dxj_DirectSoundSink, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundSink,
#endif

	public CComObjectRoot
{

public:
	C_dxj_DirectSoundSinkObject() ;
	virtual ~C_dxj_DirectSoundSinkObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundSinkObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundSink)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundSinkObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundSink
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE AddSource(I_dxj_DirectSoundSource __RPC_FAR *Source); 

		HRESULT STDMETHODCALLTYPE RemoveSource(I_dxj_DirectSoundSource __RPC_FAR *Source); 

		HRESULT STDMETHODCALLTYPE SetMasterClock(I_dxj_ReferenceClock __RPC_FAR *MasterClock);

		HRESULT STDMETHODCALLTYPE GetSoundBuffer(long lBuffer, I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *SoundBuffer);

		HRESULT STDMETHODCALLTYPE GetBusIDs(SAFEARRAY **lBusIDs);

		HRESULT STDMETHODCALLTYPE GetSoundBufferBusIDs(I_dxj_DirectSoundBuffer __RPC_FAR *buffer, SAFEARRAY **lBusIDs);

		HRESULT STDMETHODCALLTYPE GetLatencyClock(
			/* [in,out] */ I_dxj_ReferenceClock __RPC_FAR *__RPC_FAR *Clock);

		HRESULT STDMETHODCALLTYPE Activate(
			/* [in] */ long fEnable);

		HRESULT STDMETHODCALLTYPE CreateSoundBuffer(
			/* [in] */ DSBUFFERDESC_CDESC __RPC_FAR *BufferDesc, 
			/* [in] */ long lBusID,
			/* [out,retval] */ I_dxj_DirectSoundBuffer __RPC_FAR **Buffer);

		HRESULT STDMETHODCALLTYPE CreateSoundBufferFromFile(
			/* [in] */ BSTR fileName,
			/* [in] */ DSBUFFERDESC_CDESC __RPC_FAR *BufferDesc, 
			/* [in] */ long lBusID,
			/* [out,retval] */ I_dxj_DirectSoundBuffer __RPC_FAR **Buffer);

		HRESULT STDMETHODCALLTYPE GetBusCount(
			/* [out,retval] */ long *lCount); 

		HRESULT STDMETHODCALLTYPE PlayWave(
			/* [in] */ long rt, 
			/* [in] */ I_dxj_DirectSoundWave __RPC_FAR *Wave, 
			/* [in] */ long lFlags);

	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundSink);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundSink);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundsinkobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundSinkObj.h"
#include "dSoundBufferObj.h"

extern void *g_dxj_DirectSoundSink;
extern HRESULT InternalCreateSoundBufferFromFileSink(LPDIRECTSOUNDSINK8 lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer, DWORD dwBusID) ;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundSinkObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundSink [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundSinkObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundSink [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundSinkObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundSinkObject::C_dxj_DirectSoundSinkObject(){ 
		
	DPF1(1,"Constructor Creation DirectSoundSink Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundSink = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundSink;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundSink = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundSinkObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundSinkObject::~C_dxj_DirectSoundSinkObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundSinkObject destructor \n");

     C_dxj_DirectSoundSinkObject *prev=NULL; 
	for(C_dxj_DirectSoundSinkObject *ptr=(C_dxj_DirectSoundSinkObject*)g_dxj_DirectSoundSink ; ptr; ptr=(C_dxj_DirectSoundSinkObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundSink = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundSink found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundSink){
		int count = IUNK(m__dxj_DirectSoundSink)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundSink Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundSink = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();
	
}

HRESULT C_dxj_DirectSoundSinkObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundSink;
	
	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundSink=(LPDIRECTSOUNDSINK)pUnk;
	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::Activate(long fEnable){
	HRESULT hr;

	if ( FAILED ( hr = m__dxj_DirectSoundSink->Activate(fEnable) ) )
		return hr;

	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::CreateSoundBuffer(DSBUFFERDESC_CDESC *BufferDesc, 
	long lBusID, I_dxj_DirectSoundBuffer **Buffer){

	LPDIRECTSOUNDBUFFER			dsb;	// Need to get the buffer first

	BufferDesc->lSize = sizeof(DSBUFFERDESC);
	
	LPDSBUFFERDESC lpds ;
	lpds = (LPDSBUFFERDESC)&BufferDesc;
	HRESULT hr=S_OK;
	hr = m__dxj_DirectSoundSink->CreateSoundBuffer(lpds, (DWORD*)&lBusID, (DWORD)lBusID, &dsb );
 
	if SUCCEEDED(hr)
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, Buffer );

	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::CreateSoundBufferFromFile(BSTR fileName,
	DSBUFFERDESC_CDESC *BufferDesc, 
	long lBusID, I_dxj_DirectSoundBuffer **Buffer){

	LPDIRECTSOUNDBUFFER		dsb;	
	LPDSBUFFERDESC			lpds ;
	HRESULT					hr=S_OK;

		
	*Buffer=NULL;	
	BufferDesc->lSize = sizeof(DSBUFFERDESC);
	lpds = (LPDSBUFFERDESC)&BufferDesc;
	
	hr=InternalCreateSoundBufferFromFileSink(m__dxj_DirectSoundSink,(LPDSBUFFERDESC)&BufferDesc,
			(WCHAR*)fileName,&dsb, (DWORD) lBusID); 

	if SUCCEEDED(hr)
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, Buffer);
	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::GetBusCount(long *lCount){
	
	HRESULT hr;

	if ( FAILED ( hr = m__dxj_DirectSoundSink->GetBusCount((DWORD*)lCount) ) )
		return hr;
	
	return S_OK;
}


HRESULT C_dxj_DirectSoundSinkObject::PlayWave(long rt, 
									I_dxj_DirectSoundWave *Wave, 
									long lFlags)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDWAVE8, lpDSoundWave, Wave);

	if ( FAILED ( hr = m__dxj_DirectSoundSink->PlayWave((REFERENCE_TIME) rt, lpDSoundWave, (DWORD)lFlags) ) )
		return hr;

	return S_OK;
}
HRESULT C_dxj_DirectSoundSinkObject::GetLatencyClock(I_dxj_ReferenceClock **Clock)
{
	return S_OK;
}
HRESULT C_dxj_DirectSoundSinkObject::AddSource(I_dxj_DirectSoundSource *Source)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDSOURCE8, lpDSoundSource, Source);

	if (FAILED ( hr = m__dxj_DirectSoundSink->AddSource(lpDSoundSource) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::RemoveSource(I_dxj_DirectSoundSource *Source)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDSOURCE8, lpDSoundSource, Source);

	if (FAILED ( hr = m__dxj_DirectSoundSink->RemoveSource(lpDSoundSource) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::SetMasterClock(I_dxj_ReferenceClock *MasterClock)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL( IReferenceClock*, lpRefClock, MasterClock);

	if (FAILED ( hr = m__dxj_DirectSoundSink->SetMasterClock(lpRefClock) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::GetSoundBuffer(long lBuffer, I_dxj_DirectSoundBuffer **SoundBuffer)
{
	return S_OK;
}

	
HRESULT C_dxj_DirectSoundSinkObject::GetBusIDs(SAFEARRAY **lBusIDs)
{
	return S_OK;
}

HRESULT C_dxj_DirectSoundSinkObject::GetSoundBufferBusIDs(I_dxj_DirectSoundBuffer *buffer, SAFEARRAY **lBusIDs)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundprimarybufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundPrimaryBufferobj.h
//
//--------------------------------------------------------------------------

// dSoundPrimaryBufferObj.h : Declaration of the C_dxj_DirectSoundPrimaryBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundPrimaryBuffer LPDIRECTSOUNDBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundPrimaryBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundPrimaryBuffer, &IID_I_dxj_DirectSoundPrimaryBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundPrimaryBuffer,
#endif

	//public CComCoClass<C_dxj_DirectSoundPrimaryBufferObject, &CLSID__dxj_DirectSoundPrimaryBuffer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundPrimaryBufferObject() ;
	virtual ~C_dxj_DirectSoundPrimaryBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundPrimaryBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundPrimaryBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundPrimaryBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundPrimaryBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundPrimaryBuffer
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dListener( 
            /* [retval][out] */ I_dxj_DirectSound3dListener __RPC_FAR *__RPC_FAR *lpdsl);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSBCAPS_CDESC __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( 
            /* [out] */ DSCURSORS_CDESC __RPC_FAR *cursors);
        
         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WAVEFORMATEX_CDESC __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE getVolume( 
            /* [retval][out] */ long __RPC_FAR *volume);
        
         HRESULT STDMETHODCALLTYPE getPan( 
            /* [retval][out] */ long __RPC_FAR *pan);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSound __RPC_FAR *directSound,
            /* [out][in] */ DSBUFFERDESC_CDESC __RPC_FAR *BufferDesc,
            /* [out][in] */ byte __RPC_FAR *wbuf);
        
         HRESULT STDMETHODCALLTYPE writeBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *PrimaryBuffer,
			void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE readBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *PrimaryBuffer,
				void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE play( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setFormat( 
            /* [in] */ WAVEFORMATEX_CDESC __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE setVolume( 
            /* [in] */ long volume);
        
         HRESULT STDMETHODCALLTYPE setPan( 
            /* [in] */ long pan);
        
         HRESULT STDMETHODCALLTYPE stop( void);
        
         HRESULT STDMETHODCALLTYPE restore( void);
		 


private:
    DECL_VARIABLE(_dxj_DirectSoundPrimaryBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundPrimaryBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundprimarybufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundPrimaryBufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundPrimaryBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundPrimaryBufferObj.h"
#include "dSoundObj.h"
#include "dSound3DListener.h"

#define SAFE_DELETE(p) { free(p); p = NULL; }

extern HRESULT AudioBSTRtoGUID(LPGUID,BSTR);
extern void *g_dxj_DirectSoundPrimaryBuffer;

CONSTRUCTOR(_dxj_DirectSoundPrimaryBuffer, {});
DESTRUCTOR(_dxj_DirectSoundPrimaryBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundPrimaryBuffer);

	PASS_THROUGH1_R(_dxj_DirectSoundPrimaryBuffer, getVolume, GetVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSoundPrimaryBuffer, getPan, GetPan, long*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundPrimaryBuffer, getStatus, GetStatus, long*,(DWORD*));

	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundPrimaryBuffer, setFormat, SetFormat, WAVEFORMATEX_CDESC*, (LPWAVEFORMATEX));
	PASS_THROUGH1_R(_dxj_DirectSoundPrimaryBuffer, setPan, SetPan, LONG);
	PASS_THROUGH_R(_dxj_DirectSoundPrimaryBuffer, stop, Stop);
	PASS_THROUGH_R(_dxj_DirectSoundPrimaryBuffer, restore, Restore);


STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::setVolume(LONG vol)
{

	return m__dxj_DirectSoundPrimaryBuffer->SetVolume(vol); 
}

STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::getDirectSound3dListener(I_dxj_DirectSound3dListener **retval)
{
    IDirectSound3DListener *lp3dl;
    HRESULT hr = S_OK;

    if((hr=m__dxj_DirectSoundPrimaryBuffer->QueryInterface(IID_IDirectSound3DListener, (void**) &lp3dl)) != S_OK)
		return hr;

	INTERNAL_CREATE(_dxj_DirectSound3dListener, lp3dl, retval);

	return hr;
}

STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::getCaps(DSBCAPS_CDESC* caps)
{
	if(!caps)
		return E_POINTER;

	caps->lSize = sizeof(DSBCAPS);
	return m__dxj_DirectSoundPrimaryBuffer->GetCaps((LPDSBCAPS)caps); 
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::getCurrentPosition(DSCURSORS_CDESC *desc) 
{ 
   if(!desc) return E_POINTER;

  return (m__dxj_DirectSoundPrimaryBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
}

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own PrimaryBuffer
//which is passed into WritePrimaryBuffer(). Because the environment is now double
//PrimaryBuffered there is no need to Lock Java memory. WritePrimaryBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::writeBuffer(long start, long totsz, 
					void  *buf,  long flags) 
{ 
	#pragma message ("SoundPrimaryBuffer writePrimaryBuffer ")

	byte *PrimaryBuffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!PrimaryBuffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;

	__try {
		if ((val = m__dxj_DirectSoundPrimaryBuffer->Lock((DWORD)start, (DWORD)totsz,
			 &p1, &size1, &p2, &size2,
			(DWORD)flags)) != DS_OK)
			return val;

		// Copy to buffer end, then do a wrapped portion if it exists, then unlock
		DPF1(1,"----- DXVB: DSoundPrimaryBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
		if (p1)	
		{
			DPF1(1,"----- DXVB: DSoundPrimaryBuffer (WriteBuffer) about to copy to buffer (size1 = %d )\n",size1);
			memcpy (p1, PrimaryBuffer, size1);
		}

		if (p2)	 //There was wrapping
		{
			DPF1(1,"----- DXVB: DSoundPrimaryBuffer (WriteBuffer) about to copy to buffer (size2 = %d )\n",size2);
			memcpy(p2, &PrimaryBuffer[size1], size2);
		}

		//docdoc: because Lock and Unlock are tied together within WriteBuffer,
		//        DSBufferDesc no longer needs to save Lock's system pointers.
		DPF(1,"----- DXVB: DSoundPrimaryBuffer (WriteBuffer) Unlocking buffer.\n");
		val=m__dxj_DirectSoundPrimaryBuffer->Unlock(p1, size1, p2, size2);
	}
	__except(0,0){
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own PrimaryBuffer
//which is passed into WritePrimaryBuffer(). Because the environment is now double
//PrimaryBuffered there is no need to Lock Java memory. WritePrimaryBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::readBuffer(long start, long totsz,
	void  *buf,  long flags) 
{ 

	byte *PrimaryBuffer=(byte*)buf;

	if(!PrimaryBuffer)
		return E_POINTER;
	
	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	if ((val = m__dxj_DirectSoundPrimaryBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (p1)	
	{
		DPF1(1,"----- DXVB: DSoundPrimaryBuffer (ReadBuffer) about to copy to buffer (size1 = %d )\n",size1);
		memcpy (PrimaryBuffer,p1,  size1);
	}

	if (p2)	 //There was wrapping
	{
		DPF1(1,"----- DXVB: DSoundPrimaryBuffer (ReadBuffer) about to copy to buffer (size2 = %d )\n",size2);
		memcpy(&PrimaryBuffer[size1],p2,  size2);
	}

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	DPF(1,"----- DXVB: DSoundPrimaryBuffer (ReadBuffer) Unlocking buffer.\n");
	val= m__dxj_DirectSoundPrimaryBuffer->Unlock(p1, size1, p2, size2);
   }
   __except(1,1){
	return E_FAIL;
   }
   return val;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::getFormat(WAVEFORMATEX_CDESC *format) 
{ 
	DWORD *wsize=0;	// docdoc: throw away returned written size

	HRESULT hr=DS_OK;
	hr=m__dxj_DirectSoundPrimaryBuffer->GetFormat((LPWAVEFORMATEX)format, (DWORD)sizeof(WAVEFORMATEX_CDESC), wsize);
			
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::initialize(I_dxj_DirectSound *ds,
		 DSBUFFERDESC_CDESC *buf, unsigned char *wave) 
{
	if(! (ds && buf && wave) )
		return E_POINTER;


	LPDSBUFFERDESC lpds = NULL;
	lpds = (LPDSBUFFERDESC)malloc(sizeof(DSBUFFERDESC));
	if (!lpds)
		return E_OUTOFMEMORY;

	ZeroMemory(lpds, sizeof(DSBUFFERDESC));

	lpds->dwSize = sizeof(DSBUFFERDESC);
	lpds->dwFlags = buf->lFlags;
	lpds->dwBufferBytes = buf->lBufferBytes;
	lpds->dwReserved = buf->lReserved;
#ifdef _WIN64
	lpds->lpwfxFormat = (WAVEFORMATEX*)wave;
#else
	lpds->lpwfxFormat = (WAVEFORMATEX*)PtrToLong(wave);
#endif
	AudioBSTRtoGUID(&lpds->guid3DAlgorithm, buf->guid3DAlgorithm);

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpdsound, ds)

	m__dxj_DirectSoundPrimaryBuffer->Initialize(lpdsound, (LPDSBUFFERDESC)lpds);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundPrimaryBufferObject::play(long flags) 
{
	HRESULT hr=DS_OK;
	if((hr=m__dxj_DirectSoundPrimaryBuffer->Play(0, 0, (DWORD)flags)) != DS_OK)
		return hr;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundobj.cpp
//
//--------------------------------------------------------------------------

// dSoundObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file


#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dsoundprimarybufferobj.h"
extern	BOOL IsAllZeros(void *pStruct,DWORD size); 
extern HRESULT AudioBSTRtoGUID(LPGUID,BSTR);

extern HRESULT InternalCreateSoundBufferFromFile(LPDIRECTSOUND8 lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer) ;
extern HRESULT InternalCreateSoundBufferFromResource(LPDIRECTSOUND8 lpDirectSound,LPDSBUFFERDESC pDesc,HANDLE resHandle,WCHAR *resName,LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer);
extern void *g_dxj_DirectSoundPrimaryBuffer;

CONSTRUCTOR(_dxj_DirectSound, {m__dxj_DirectSound=NULL;m_pDriverGuid=NULL;});
DESTRUCTOR(_dxj_DirectSound,  {if (m_pDriverGuid) delete m_pDriverGuid;});
GETSET_OBJECT(_dxj_DirectSound);
	//
    /*** IDirectSound methods ***/
	//

PASS_THROUGH_CAST_1_R(_dxj_DirectSound, getSpeakerConfig, GetSpeakerConfig, long*,(DWORD*)); 
PASS_THROUGH_CAST_1_R(_dxj_DirectSound, setSpeakerConfig, SetSpeakerConfig, long,(DWORD)); 

STDMETHODIMP C_dxj_DirectSoundObject::getCaps(DSCAPS_CDESC* caps)
{
	caps->lSize = sizeof(DSCAPS);
	return m__dxj_DirectSound->GetCaps((LPDSCAPS)caps); 
}

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////

#ifdef _WIN64
STDMETHODIMP C_dxj_DirectSoundObject::setCooperativeLevel(HWND h, long d)
#else
STDMETHODIMP C_dxj_DirectSoundObject::setCooperativeLevel(LONG h, long d)
#endif
{
	if( m__dxj_DirectSound == NULL )
		return E_FAIL;

	return m__dxj_DirectSound->SetCooperativeLevel((HWND)h, (DWORD)d); 
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectSoundObject::duplicateSoundBuffer(I_dxj_DirectSoundBuffer *src, 
		I_dxj_DirectSoundBuffer **val) 
{
	if(! (src && val) )
		return E_POINTER;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDBUFFER, lpdsb, src);

	//Need to create a second one
	LPDIRECTSOUNDBUFFER		dsb=0;
	HRESULT hr=S_OK;
	hr=m__dxj_DirectSound->DuplicateSoundBuffer((LPDIRECTSOUNDBUFFER)lpdsb, &dsb); 
	if SUCCEEDED(hr)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectSoundObject::CreatePrimarySoundBuffer(DSBUFFERDESC_CDESC *desc, 
			I_dxj_DirectSoundPrimaryBuffer **val) 
{
	LPDIRECTSOUNDBUFFER 		dsb = NULL;	// Need to get the buffer first
	DSBUFFERDESC				lpds;
	HRESULT						hr;

	if ((desc->lFlags & DSBCAPS_PRIMARYBUFFER) == 0)
		return E_INVALIDARG;

	lpds.dwSize = sizeof(DSBUFFERDESC);
	lpds.dwFlags = desc->lFlags;
	lpds.dwBufferBytes = desc->lBufferBytes;
	lpds.dwReserved = desc->lReserved;
	lpds.lpwfxFormat = NULL;
	AudioBSTRtoGUID(&lpds.guid3DAlgorithm, desc->guid3DAlgorithm);

	if (FAILED(hr = m__dxj_DirectSound->CreateSoundBuffer(&lpds, &dsb, NULL) ) )
		return hr;

	INTERNAL_CREATE(_dxj_DirectSoundPrimaryBuffer, dsb, val);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectSoundObject::createSoundBuffer(DSBUFFERDESC_CDESC *desc, 
			I_dxj_DirectSoundBuffer **val) 
{
	LPDIRECTSOUNDBUFFER 		dsb = NULL;	// Need to get the buffer first
	DSBUFFERDESC				lpds;
	LPDIRECTSOUNDBUFFER8		dsbReal = NULL;
	HRESULT						hr;
	WAVEFORMATEX				fxWave;

	if (desc->lFlags & DSBCAPS_PRIMARYBUFFER)
		return E_INVALIDARG;

	ZeroMemory(&lpds, sizeof(DSBUFFERDESC));
	ZeroMemory(&fxWave, sizeof(WAVEFORMATEX));

	lpds.dwSize = sizeof(DSBUFFERDESC);

	lpds.dwFlags = desc->lFlags;
	lpds.dwBufferBytes = desc->lBufferBytes;
	lpds.dwReserved = desc->lReserved;
	if (!IsAllZeros(&desc->fxFormat, sizeof(WAVEFORMATEX)))
	{
		memcpy(&fxWave, &desc->fxFormat, sizeof(WAVEFORMATEX));
	}
	else
	{
		// Do a default one
		fxWave.cbSize = sizeof(WAVEFORMATEX);
		fxWave.wFormatTag = WAVE_FORMAT_PCM;
		fxWave.nChannels = 2;
		fxWave.nSamplesPerSec = 22050;
		fxWave.wBitsPerSample = 16;
		fxWave.nBlockAlign = fxWave.wBitsPerSample / 8 * fxWave.nChannels;
		fxWave.nAvgBytesPerSec = fxWave.nSamplesPerSec * fxWave.nBlockAlign;
#if 0
		if ((desc->lFlags & DSBCAPS_MIXIN) == 0)
		    lpds.dwBufferBytes = fxWave.nSamplesPerSec;
#endif
	}
		lpds.lpwfxFormat = &fxWave;

	AudioBSTRtoGUID(&lpds.guid3DAlgorithm, desc->guid3DAlgorithm);

	if (FAILED(hr = m__dxj_DirectSound->CreateSoundBuffer(&lpds, &dsb, NULL) ) )
		return hr;

	hr = dsb->QueryInterface(IID_IDirectSoundBuffer8, (void**) &dsbReal);
	dsb->Release();
	if (FAILED(hr)) return hr;

	INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsbReal, val);

	return S_OK;
}

STDMETHODIMP C_dxj_DirectSoundObject::createSoundBufferFromFile(BSTR fileName, DSBUFFERDESC_CDESC *desc, 
			I_dxj_DirectSoundBuffer **val) 
{
	LPDIRECTSOUNDBUFFER8	dsb;	// Need to get the buffer first
	LPDSBUFFERDESC			lpds = NULL;
	HRESULT					hr=S_OK;

		
	*val=NULL;	

	lpds = (LPDSBUFFERDESC)malloc(sizeof(DSBUFFERDESC));
	if (!lpds)
		return E_OUTOFMEMORY;

	ZeroMemory(lpds, sizeof(DSBUFFERDESC));

	lpds->dwSize = sizeof(DSBUFFERDESC);
	lpds->dwFlags = desc->lFlags;
	lpds->dwBufferBytes = desc->lBufferBytes;
	lpds->dwReserved = desc->lReserved;
	lpds->lpwfxFormat = (WAVEFORMATEX*)&desc->fxFormat;
	AudioBSTRtoGUID(&lpds->guid3DAlgorithm, desc->guid3DAlgorithm);
	
	if (FAILED( hr=InternalCreateSoundBufferFromFile(m__dxj_DirectSound,(LPDSBUFFERDESC)lpds,
			(WCHAR*)fileName,&dsb) ) )
			return hr;

	// Return our information now
	desc->lFlags = lpds->dwFlags;
	desc->lBufferBytes = lpds->dwBufferBytes;

	INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);

	DWORD *wsize=0;	

	hr = dsb->GetFormat((LPWAVEFORMATEX)&desc->fxFormat, (DWORD)sizeof(WAVEFORMATEX_CDESC), wsize);

	return S_OK;

}



STDMETHODIMP C_dxj_DirectSoundObject::createSoundBufferFromResource(BSTR resFile, BSTR resName, 
			DSBUFFERDESC_CDESC *desc, 
			 I_dxj_DirectSoundBuffer **val) 
{

		
	
	LPDIRECTSOUNDBUFFER8	dsb;	// Need to get the buffer first
	LPDSBUFFERDESC			lpds = NULL ;
	HRESULT					hr=S_OK;	
	HMODULE					hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// BUG BUG: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		 LPCTSTR pszName = W2T(resFile);
		 hMod= GetModuleHandle(pszName);
	}

		
	*val=NULL;	

	lpds = (LPDSBUFFERDESC)malloc(sizeof(DSBUFFERDESC));
	if (!lpds)
		return E_OUTOFMEMORY;

	ZeroMemory(lpds, sizeof(DSBUFFERDESC));

	lpds->dwSize = sizeof(DSBUFFERDESC);
	lpds->dwFlags = desc->lFlags;
	lpds->dwBufferBytes = desc->lBufferBytes;
	lpds->dwReserved = desc->lReserved;
	lpds->lpwfxFormat = (WAVEFORMATEX*)&desc->fxFormat;
	AudioBSTRtoGUID(&lpds->guid3DAlgorithm, desc->guid3DAlgorithm);
	
	hr=InternalCreateSoundBufferFromResource(m__dxj_DirectSound,(LPDSBUFFERDESC)lpds,
			(HANDLE)hMod,(WCHAR*)resName,&dsb);

	
	if SUCCEEDED(hr)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}


	return hr;
}

#if 0
//DEAD CODE
STDMETHODIMP C_dxj_DirectSoundObject::AllocSink(
		long lBusCount, WAVEFORMATEX_CDESC *format, 
		I_dxj_DirectSoundSink **ret)
{
	HRESULT hr;
	LPDIRECTSOUNDSINK8	lpdsink = NULL;
	
	hr = m__dxj_DirectSound->AllocSink((DWORD) lBusCount, sizeof(lBusCount), (WAVEFORMATEX*)format, &lpdsink);
 
	if (FAILED(hr))
		return hr;

	INTERNAL_CREATE(_dxj_DirectSoundSink, lpdsink , ret);

	return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundobj.h
//
//--------------------------------------------------------------------------

// dSoundObj.h : Declaration of the C_dxj_DirectSoundObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound  LPDIRECTSOUND8
#ifndef _DSOUNDOBJ_H_
#define _DSOUNDOBJ_H_

#ifndef Hwnd
	#define HWnd long
#endif
 
/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSound, &IID_I_dxj_DirectSound, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSound,
#endif

	//public CComCoClass<C_dxj_DirectSoundObject, &CLSID__dxj_DirectSound>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundObject() ;
	virtual ~C_dxj_DirectSoundObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSound, "DIRECT.DirectSound.3",				"DIRECT.DirectSound.3",					IDS_DSOUND_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundBuffer
public:


         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE createSoundBuffer( 
            /* [in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE createSoundBufferFromFile( 
            /* [in] */ BSTR fileName,
            /* [out][in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE createSoundBufferFromResource( 
            /* [in] */ BSTR resourceFile,
            /* [in] */ BSTR resourceName,
            /* [out][in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCAPS_CDESC __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE duplicateSoundBuffer( 
            /* [in] */ I_dxj_DirectSoundBuffer __RPC_FAR *original,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *duplicate);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
#ifdef _WIN64
		    /* [in] */ HWND hwnd,
#else
		    /* [in] */ LONG hwnd,
#endif
            /* [in] */ long level);
        
        
         HRESULT STDMETHODCALLTYPE getSpeakerConfig( 
            /* [retval][out] */ long __RPC_FAR *speakerConfig);
        
         HRESULT STDMETHODCALLTYPE setSpeakerConfig( 
            /* [in] */ long speakerConfig);


         HRESULT STDMETHODCALLTYPE CreatePrimarySoundBuffer( 
            /* [in] */ DSBUFFERDESC_CDESC __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundPrimaryBuffer __RPC_FAR *__RPC_FAR *soundBuffer);

			
#if 0
		HRESULT STDMETHODCALLTYPE AllocSink(
			long lBusCount, WAVEFORMATEX_CDESC __RPC_FAR *format, 
			I_dxj_DirectSoundSink __RPC_FAR *__RPC_FAR *ret);
#endif

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectSound);
	GUID *m_pDriverGuid;

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound )
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundsourceobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dsoundsourceobj.h"

extern void *g_dxj_DirectSoundSource;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundSource::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundSource [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundSource::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundSource [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundSource
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundSource::C_dxj_DirectSoundSource(){ 
		
	DPF1(1,"Constructor Creation DirectSoundSource Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundSource = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundSource;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundSource = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundSource
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundSource::~C_dxj_DirectSoundSource()
{

	DPF(1,"Entering ~C_dxj_DirectSoundSource destructor \n");

     C_dxj_DirectSoundSource *prev=NULL; 
	for(C_dxj_DirectSoundSource *ptr=(C_dxj_DirectSoundSource*)g_dxj_DirectSoundSource ; ptr; ptr=(C_dxj_DirectSoundSource *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundSource = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundSource found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundSource){
		int count = IUNK(m__dxj_DirectSoundSource)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundSource Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundSource = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();
	
}

HRESULT C_dxj_DirectSoundSource::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundSource;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundSource::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundSource=(LPDIRECTSOUNDSOURCE)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundSource::GetFormat(WAVEFORMATEX_CDESC *WaveFormatEx)
{

	HRESULT hr;
	DWORD dwSize;

	WAVEFORMATEX *fxFormat = (WAVEFORMATEX*)WaveFormatEx;

	fxFormat->cbSize = sizeof(WAVEFORMATEX);

	dwSize = sizeof(WAVEFORMATEX);

	if ( FAILED ( hr = m__dxj_DirectSoundSource->GetFormat(fxFormat, &dwSize) ) )
		return hr;

	//WaveFormatEx = (WAVEFORMATEX_CDESC)*fxFormat;
	return S_OK;
}


HRESULT C_dxj_DirectSoundSource::SetSink(I_dxj_DirectSoundSink *SoundSink)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL( LPDIRECTSOUNDSINK8, lpDSoundSink, SoundSink);

	if ( FAILED ( hr = m__dxj_DirectSoundSource->SetSink(lpDSoundSink) ) )
		return hr;
	return S_OK;
}

HRESULT C_dxj_DirectSoundSource::Seek(long lPosition)
{
	HRESULT hr;

	if ( FAILED ( hr = m__dxj_DirectSoundSource->Seek(lPosition) ) )
		return hr;
	return S_OK;
}

HRESULT C_dxj_DirectSoundSource::Read(I_dxj_DirectSoundBuffer *Buffers[], long *busIDs, long lBusCount)
{
	HRESULT hr;

	return S_OK;
}

HRESULT C_dxj_DirectSoundSource::GetSize(long *ret)
{
	HRESULT hr;

	if ( FAILED ( hr = m__dxj_DirectSoundSource->GetSize((ULONGLONG*)ret) ) )
		return hr;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundwaveobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dSoundWaveObj.h"
#include "dmdls.h"

extern void *g_dxj_DirectSoundWave;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundWaveObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectSoundWave [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectSoundWaveObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectSoundWave [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectSoundWaveObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundWaveObject::C_dxj_DirectSoundWaveObject(){ 
		
	DPF1(1,"Constructor Creation DirectSoundWave Object[%d] \n ",g_creationcount);

	m__dxj_DirectSoundWave = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectSoundWave;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectSoundWave = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectSoundWaveObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectSoundWaveObject::~C_dxj_DirectSoundWaveObject()
{

	DPF(1,"Entering ~C_dxj_DirectSoundWaveObject destructor \n");

     C_dxj_DirectSoundWaveObject *prev=NULL; 
	for(C_dxj_DirectSoundWaveObject *ptr=(C_dxj_DirectSoundWaveObject*)g_dxj_DirectSoundWave ; ptr; ptr=(C_dxj_DirectSoundWaveObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectSoundWave = (void*)ptr->nextobj; 
			
			DPF(1,"DirectSoundWave found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectSoundWave){
		int count = IUNK(m__dxj_DirectSoundWave)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectSoundWave Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectSoundWave = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();
	
}

HRESULT C_dxj_DirectSoundWaveObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectSoundWave;
	
	return S_OK;
}
HRESULT C_dxj_DirectSoundWaveObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectSoundWave=(LPDIRECTSOUNDWAVE)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectSoundWaveObject::GetWaveArticulation(DMUS_WAVEART_CDESC *Articulation)
{
	HRESULT hr;

	DMUS_WAVEART *wavart = NULL;

	wavart = (DMUS_WAVEART*)malloc(sizeof(DMUS_WAVEART));
	ZeroMemory(wavart, sizeof(DMUS_WAVEART));

	if (FAILED (hr = m__dxj_DirectSoundWave->GetWaveArticulation(wavart) ) )
		return hr;
	
	Articulation = (DMUS_WAVEART_CDESC*)wavart;
	return S_OK;
}
HRESULT C_dxj_DirectSoundWaveObject::CreateSource(WAVEFORMATEX_CDESC format, long lFlags, I_dxj_DirectSoundSource **Source)
{
	HRESULT hr;

	return S_OK;
}
			
HRESULT C_dxj_DirectSoundWaveObject::GetFormat(WAVEFORMATEX_CDESC *format, long lFlags)        
{
	HRESULT hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dxerr8.h ===
/*==========================================================================;
 *
 *
 *  File:   dxerr8.h
 *  Content:    DirectX Error Library Include File
 *
 ****************************************************************************/

#ifndef _DXERR8_H_
#define _DXERR8_H_


//
//  DXGetErrorString8
//  
//  Desc:  Converts an DirectX HRESULT to a string 
//
//  Args:  HRESULT hr   Can be any error code from
//                      DPLAY D3D8 D3DX8 DMUSIC DSOUND
//
//  Return: Converted string 
//
const char*  __stdcall DXGetErrorString8A(HRESULT hr);
const WCHAR* __stdcall DXGetErrorString8W(HRESULT hr);

#ifdef UNICODE
    #define DXGetErrorString8 DXGetErrorString8W
#else
    #define DXGetErrorString8 DXGetErrorString8A
#endif 


//
//  DXTrace
//
//  Desc:  Outputs a formatted error message to the debug stream
//
//  Args:  CHAR* strFile   The current file, typically passed in using the 
//                         __FILE__ macro.
//         DWORD dwLine    The current line number, typically passed in using the 
//                         __LINE__ macro.
//         HRESULT hr      An HRESULT that will be traced to the debug stream.
//         CHAR* strMsg    A string that will be traced to the debug stream (may be NULL)
//         BOOL bPopMsgBox If TRUE, then a message box will popup also containing the passed info.
//
//  Return: The hr that was passed in.  
//
HRESULT __stdcall DXTraceA( char* strFile, DWORD dwLine, HRESULT hr, char* strMsg, BOOL bPopMsgBox = FALSE );
HRESULT __stdcall DXTraceW( char* strFile, DWORD dwLine, HRESULT hr, WCHAR* strMsg, BOOL bPopMsgBox = FALSE );

#ifdef UNICODE
    #define DXTrace DXTraceW
#else
    #define DXTrace DXTraceA
#endif 


//
// Helper macros
//
#if defined(DEBUG) | defined(_DEBUG)
    #define DXTRACE_MSG(str)              DXTrace( __FILE__, (DWORD)__LINE__, 0, str, FALSE )
    #define DXTRACE_ERR(str,hr)           DXTrace( __FILE__, (DWORD)__LINE__, hr, str, TRUE )
    #define DXTRACE_ERR_NOMSGBOX(str,hr)  DXTrace( __FILE__, (DWORD)__LINE__, hr, str, FALSE )
#else
    #define DXTRACE_MSG(str)              (0L)
    #define DXTRACE_ERR(str,hr)           (hr)
    #define DXTRACE_ERR_NOMSGBOX(str,hr)  (hr)
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dxglob7obj.h ===
//+-------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //
    //  Copyright (C) Microsoft Corporation, 1998 - 1999
    //
    //  File:       dxglob7obj.h
    //
    //--------------------------------------------------------------------------
    
    
    #include "resource.h"       // main symbols
    
    
    typedef HRESULT (__stdcall *DSOUNDCREATE)(GUID FAR * lpGUID, LPDIRECTSOUND8 * ppDS, IUnknown FAR *pUnkOuter );
    typedef HRESULT (__stdcall *DSOUNDCAPTURECREATE)(GUID FAR * lpGUID, LPDIRECTSOUNDCAPTURE * ppDS, IUnknown FAR *pUnkOuter );
    typedef HRESULT (CALLBACK *DSOUNDENUMERATE)(LPDSENUMCALLBACK lpCallback, LPVOID lpContext );
    typedef HRESULT (CALLBACK *DSOUNDCAPTUREENUMERATE)(LPDSENUMCALLBACK lpCallback, LPVOID lpContext );
    typedef LPDIRECT3DDEVICE8 (__stdcall *D3DCREATE8)(DWORD ver);

    
    typedef struct tag_EVENTTHREADINFO {
    	HANDLE hEvent;
    	struct tag_EVENTTHREADINFO *pNext;
    	IStream *pStream;
    	I_dxj_DirectXEvent8 *pCallback;
    	DWORD threadID;
    	HANDLE hThread;
    	BOOL	fEnd;
    	HANDLE  hEndEvent;
    } EVENTTHREADINFO;
    
    
    class C_dxj_DirectX7Object :
    	public I_dxj_DirectX8,
    	public CComCoClass<C_dxj_DirectX7Object, &CLSID__dxj_DirectX8>, public CComObjectRoot
    {
    public:
    	C_dxj_DirectX7Object() ;
    	virtual ~C_dxj_DirectX7Object() ;
    
    BEGIN_COM_MAP(C_dxj_DirectX7Object)
    	COM_INTERFACE_ENTRY(I_dxj_DirectX8)
    END_COM_MAP()
    
    	DECLARE_REGISTRY(CLSID__dxj_DirectX8,	"DIRECT.DirectX8.0",		"DIRECT.DirectX8.0",	IDS_DIRECTX8_DESC, THREADFLAGS_BOTH)
    
    // Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundResourceObject) if you don't want your object
    // to support aggregation
    DECLARE_AGGREGATABLE(C_dxj_DirectX7Object)
    
    
    public:
    
            
            HRESULT STDMETHODCALLTYPE directSoundCreate( 
                /* [in] */ BSTR guid,
                /* [retval][out] */ I_dxj_DirectSound __RPC_FAR *__RPC_FAR *ret);
            
            HRESULT STDMETHODCALLTYPE directSoundCaptureCreate( 
                /* [in] */ BSTR guid,
                /* [retval][out] */ I_dxj_DirectSoundCapture __RPC_FAR *__RPC_FAR *ret);
            
            HRESULT STDMETHODCALLTYPE getDSEnum( 
                /* [retval][out] */ I_dxj_DSEnum __RPC_FAR *__RPC_FAR *retVal);
            
            HRESULT STDMETHODCALLTYPE getDSCaptureEnum( 
                /* [retval][out] */ I_dxj_DSEnum __RPC_FAR *__RPC_FAR *retVal);
            
            HRESULT STDMETHODCALLTYPE directInputCreate( 
                /* [retval][out] */ I_dxj_DirectInput8 __RPC_FAR *__RPC_FAR *ret);
            
           HRESULT STDMETHODCALLTYPE DirectPlayVoiceClientCreate( 
               /* [retval][out] */ I_dxj_DirectPlayVoiceClient __RPC_FAR *__RPC_FAR *ret);
   
           HRESULT STDMETHODCALLTYPE DirectPlayVoiceServerCreate( 
               /* [retval][out] */ I_dxj_DirectPlayVoiceServer __RPC_FAR *__RPC_FAR *ret);
   
   		HRESULT STDMETHODCALLTYPE DirectPlayVoiceTestCreate( 
               /* [retval][out] */ I_dxj_DirectPlayVoiceSetup __RPC_FAR *__RPC_FAR *ret);
   
          
            HRESULT STDMETHODCALLTYPE directMusicLoaderCreate( 
                /* [retval][out] */ I_dxj_DirectMusicLoader __RPC_FAR *__RPC_FAR *ret);
            
            HRESULT STDMETHODCALLTYPE directMusicComposerCreate( 
                /* [retval][out] */ I_dxj_DirectMusicComposer __RPC_FAR *__RPC_FAR *ret);
            
            HRESULT STDMETHODCALLTYPE directMusicPerformanceCreate( 
                /* [retval][out] */ I_dxj_DirectMusicPerformance __RPC_FAR *__RPC_FAR *ret);
    			
        
            
#ifdef _WIN64
			HRESULT STDMETHODCALLTYPE createEvent( 
                /* [in] */ I_dxj_DirectXEvent8 __RPC_FAR *event,
                /* [retval][out] */ HANDLE __RPC_FAR *h) ;
            
            HRESULT STDMETHODCALLTYPE setEvent( 
                /* [in] */ HANDLE eventId) ;
            
            HRESULT STDMETHODCALLTYPE destroyEvent( 
                /* [in] */ HANDLE eventId) ;
#else
			HRESULT STDMETHODCALLTYPE createEvent( 
                /* [in] */ I_dxj_DirectXEvent8 __RPC_FAR *event,
                /* [retval][out] */ LONG __RPC_FAR *h) ;
            
            HRESULT STDMETHODCALLTYPE setEvent( 
                /* [in] */ LONG eventId) ;
            
            HRESULT STDMETHODCALLTYPE destroyEvent( 
                /* [in] */ LONG eventId) ;
#endif
    
          
 	    HRESULT STDMETHODCALLTYPE createNewGuid(BSTR *ret);

	    HRESULT STDMETHODCALLTYPE DirectXFileCreate(I_dxj_DirectXFile **ret);
   
		HRESULT STDMETHODCALLTYPE DirectPlayPeerCreate(I_dxj_DirectPlayPeer **ret);

		HRESULT STDMETHODCALLTYPE DirectPlayServerCreate(I_dxj_DirectPlayServer **ret);

		HRESULT STDMETHODCALLTYPE DirectPlayClientCreate(I_dxj_DirectPlayClient **ret);
		
		HRESULT STDMETHODCALLTYPE DirectPlayAddressCreate(I_dxj_DirectPlayAddress **ret);
        
		HRESULT STDMETHODCALLTYPE Direct3DCreate(IUnknown **ppRet);

		HRESULT STDMETHODCALLTYPE DirectPlayLobbyClientCreate(I_dxj_DirectPlayLobbyClient **ret);
		
		HRESULT STDMETHODCALLTYPE DirectPlayLobbiedApplicationCreate(I_dxj_DirectPlayLobbiedApplication **ret);

	
            void LoadDSOUND();
            void LoadDINPUT();
            void LoadD3D8();
    
    private:
    
    	DSOUNDCREATE			m_pDirectSoundCreate;
    	DSOUNDCAPTURECREATE		m_pDirectSoundCaptureCreate;
    	DSOUNDENUMERATE			m_pDirectSoundEnumerate;
    	DSOUNDCAPTUREENUMERATE		m_pDirectSoundCaptureEnumerate;
    	D3DCREATE8   			m_pDirect3DCreate8;
    	EVENTTHREADINFO			*m_pEventList;
    
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dxglob7obj.cpp ===
//+-------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //
    //  Copyright (C) Microsoft Corporation, 1998 - 1999
    //
    //  File:       dxglob7obj.cpp
    //
    //--------------------------------------------------------------------------
          
    
    #include "windows.h"
    #include "mmsystem.h"

	
    #include "stdafx.h"
    #include "d3d8.h"
    #include "d3dx8.h"
    #include "Direct.h"
    #include "dms.h"
    #include "math.h"
    
    #include "dxGlob7Obj.h"
    
    #include "dmusici.h"
    #include "dmusicf.h"
    #include "dvoice.h"
    #include "dxfile.h"
    
    #include "dsoundObj.h"
    #include "dsoundCaptureObj.h"
    #include "DSEnumObj.h"    
    
    #include "DPlayPeerObj.h"
    #include "DPlayServerObj.h"
    #include "DPlayClientObj.h"
    #include "DPlayLobbyClientObj.h"
    #include "DPlayLobbiedAppObj.h"
    #include "DPlayVoiceClientObj.h"
    #include "DPlayVoiceServerObj.h"
    #include "DPlayVoiceSetupObj.h"
    #include "DPlayAddressObj.h"
    
    #include "dinput1Obj.h"
    
    #include "dmSegmentObj.h"
    #include "dmSegmentStateObj.h"
    #include "dmChordMapObj.h"
    #include "dmBandObj.h"
    #include "dmCollectionObj.h"
    #include "dmStyleObj.h"
    #include "dmPerformanceObj.h"
    #include "dmLoaderObj.h"
    #include "dmComposerObj.h"

    #include "xfileobj.h"    
    #include "verinfo.h"

    extern HINSTANCE g_hDSoundHandle;
    extern HINSTANCE g_hDPlay;
    extern HINSTANCE g_hInstDINPUTDLL;
    extern HINSTANCE g_hInst;
    extern HINSTANCE g_hD3D8;
    
    extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR);
    extern HRESULT BSTRtoGUID(LPGUID,BSTR);
    
    extern void *g_dxj_DirectMusic;
    extern void *g_dxj_DirectMusicLoader;
    extern void *g_dxj_DirectMusicComposer;
    extern void *g_dxj_DirectMusicPerformance;
    extern void *g_dxj_DirectPlay;
    extern void *g_dxj_DirectPlayPeer;
    extern void *g_dxj_DirectPlayLobbyClient;
    extern void *g_dxj_DirectPlayLobbiedApplication;
    extern void *g_dxj_DirectPlayServer;
    extern void *g_dxj_DirectPlayClient;
    extern void *g_dxj_DirectPlayAddress;
    
    extern BSTR GUIDtoBSTR(LPGUID);
    extern HRESULT DPLBSTRtoGUID(LPGUID pGuid,BSTR str);
    
    extern HINSTANCE LoadD3D8DLL();
    extern HINSTANCE LoadD3DXOFDLL();
    extern HINSTANCE LoadDPlayDLL();
    extern HINSTANCE LoadDSoundDLL();
    extern HINSTANCE LoadDINPUTDLL();
    
    DWORD WINAPI ThreadFunc(LPVOID param);
        
#ifndef DX_FINAL_RELEASE

// shut 'em down if they try to use the beta bits too long
HRESULT TimeBomb() 
{
    #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
    SYSTEMTIME st;
    GetSystemTime(&st);

    if ( st.wYear > DX_EXPIRE_YEAR ||
         ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
    ) {
        MessageBox(0, DX_EXPIRE_TEXT,
                      TEXT("Microsoft DirectX For Visual Basic"), MB_OK);
        return S_OK;// let it work anyway.
    }
     return S_OK;   
} // TimeBomb

#endif
    
    C_dxj_DirectX7Object::C_dxj_DirectX7Object(){
            	
    
        m_pDirectSoundCreate=NULL;
        m_pDirectSoundEnumerate=NULL;
        m_pDirectSoundCaptureEnumerate=NULL;
    	m_pDirectSoundCaptureCreate=NULL;
	m_pDirect3DCreate8=NULL;
        m_pEventList=NULL;
    }
    
    void C_dxj_DirectX7Object::LoadDSOUND()
    {   
    	if (!g_hDSoundHandle )	LoadDSoundDLL();  
        if (!m_pDirectSoundCreate)              m_pDirectSoundCreate = (DSOUNDCREATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCreate8" );
        if (!m_pDirectSoundCaptureCreate)       m_pDirectSoundCaptureCreate = (DSOUNDCAPTURECREATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCaptureCreate" );
        if (!m_pDirectSoundEnumerate)           m_pDirectSoundEnumerate = (DSOUNDENUMERATE)GetProcAddress( g_hDSoundHandle, "DirectSoundEnumerateA" );
        if (!m_pDirectSoundCaptureEnumerate)    m_pDirectSoundCaptureEnumerate = (DSOUNDCAPTUREENUMERATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCaptureEnumerateA" );
        
    }
    
    void C_dxj_DirectX7Object::LoadD3D8()
    {   
    	if (!g_hD3D8 )	LoadD3D8DLL();  
        if (!m_pDirect3DCreate8)             m_pDirect3DCreate8 = (D3DCREATE8)GetProcAddress( g_hD3D8, "Direct3DCreate8" );        
    }
    
    
    C_dxj_DirectX7Object::~C_dxj_DirectX7Object()
    {
        DWORD i=1;
    
        while (m_pEventList) {
    
#ifdef _WIN64
        destroyEvent((HANDLE)m_pEventList->hEvent);
#else
        destroyEvent((LONG)PtrToLong(m_pEventList->hEvent));
#endif
        }
    }
    
    
    
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayVoiceClientCreate(I_dxj_DirectPlayVoiceClient **ret){
  
      HRESULT						hr;
      LPDIRECTPLAYVOICECLIENT		realvoice=NULL;
      DWORD						i=0;
  

  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
      if( FAILED(hr = CoCreateInstance(CLSID_DirectPlayVoiceClient,NULL,
  						CLSCTX_INPROC_SERVER,
  						IID_IDirectPlayVoiceClient,
  						(LPVOID*) &realvoice)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceClient,realvoice,ret);
      
      if (*ret==NULL) {
          i=realvoice->Release();
          return E_FAIL;
      }
  	return hr;
  }
  
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayLobbyClientCreate(I_dxj_DirectPlayLobbyClient **ret) {
      HRESULT						hr;
      IDirectPlay8LobbyClient		*realLC=NULL;
  
  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if( FAILED(hr = CoCreateInstance(CLSID_DirectPlay8LobbyClient,NULL,
  										CLSCTX_INPROC_SERVER,
  										IID_IDirectPlay8LobbyClient,
  										(void**) &realLC)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayLobbyClient,realLC,ret);
      
      if (*ret==NULL) {
          realLC->Release();
          return E_FAIL;
      }
  	return hr;
  }

		
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayLobbiedApplicationCreate(I_dxj_DirectPlayLobbiedApplication **ret) {
      HRESULT						hr;
      IDirectPlay8LobbiedApplication	*realLA=NULL;
  
  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if( FAILED(hr = CoCreateInstance(CLSID_DirectPlay8LobbiedApplication,NULL,
  										CLSCTX_INPROC_SERVER,
  										IID_IDirectPlay8LobbiedApplication,
  										(void**) &realLA)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayLobbiedApplication,realLA,ret);
      
      if (*ret==NULL) {
          realLA->Release();
          return E_FAIL;
      }
  	return hr;
  }

  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayVoiceServerCreate(I_dxj_DirectPlayVoiceServer **ret){
  
      HRESULT						hr;
      LPDIRECTPLAYVOICESERVER		realvoice=NULL;
      DWORD						i=0;
  
  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
  	if( FAILED(hr = CoCreateInstance(CLSID_DirectPlayVoiceServer,NULL,
  										CLSCTX_INPROC_SERVER,
  										IID_IDirectPlayVoiceServer,
  										(LPVOID*) &realvoice)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceServer,realvoice,ret);
      
      if (*ret==NULL) {
          i=realvoice->Release();
          return E_FAIL;
      }
  	return hr;
  }
  
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayVoiceTestCreate(I_dxj_DirectPlayVoiceSetup **ret){
  
      HRESULT						hr;
      LPDIRECTPLAYVOICETEST		realsetup=NULL;
      DWORD						i=0;
  
  
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
  	if( FAILED(hr = CoCreateInstance(CLSID_DirectPlayVoiceTest,NULL,
  										CLSCTX_INPROC_SERVER,
  										IID_IDirectPlayVoiceTest,
  										(LPVOID*) &realsetup)))
  		return hr;
  
      INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayVoiceSetup,realsetup,ret);
      
      if (*ret==NULL) {
          i=realsetup->Release();
          return E_FAIL;
      }
  	return hr;
  }  	  	
    
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayPeerCreate(I_dxj_DirectPlayPeer **ret)
  {
	HRESULT				hr;
	IDirectPlay8Peer	*lpDplayPeer = NULL;


#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Peer, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Peer, (LPVOID*) &lpDplayPeer ) ) )
				return hr;

	INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayPeer, lpDplayPeer, ret);

	if (*ret == NULL) 
	{
		lpDplayPeer->Release();
		return E_FAIL;
	}
	return hr;
  
  }
    
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayServerCreate(I_dxj_DirectPlayServer **ret)
  {
	HRESULT					hr;
	IDirectPlay8Server		*lpDplayServer = NULL;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Server, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Server, (LPVOID*) &lpDplayServer ) ) )
				return hr;

	INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayServer, lpDplayServer, ret);

	if (*ret == NULL) 
	{
		lpDplayServer->Release();
		return E_FAIL;
	}
	return hr;
  
  }
    
  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayAddressCreate(I_dxj_DirectPlayAddress **ret)
  {
	HRESULT					hr;
	IDirectPlay8Address		*lpDplayAddress = NULL;


#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address, (LPVOID*) &lpDplayAddress ) ) )
				return hr;

	INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress, lpDplayAddress, ret);

	if (*ret == NULL) 
	{
		lpDplayAddress->Release();
		return E_FAIL;
	}
	return hr;
  
  }

  STDMETHODIMP C_dxj_DirectX7Object::DirectPlayClientCreate(I_dxj_DirectPlayClient **ret)
  {
	HRESULT					hr;
	IDirectPlay8Client		*lpDplayClient = NULL;


#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	if ( FAILED (hr = CoCreateInstance( CLSID_DirectPlay8Client, NULL,CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Client, (LPVOID*) &lpDplayClient ) ) )
				return hr;

	INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayClient, lpDplayClient, ret);

	if (*ret == NULL) 
	{
		lpDplayClient->Release();
		return E_FAIL;
	}
	return hr;
  
  }

  STDMETHODIMP C_dxj_DirectX7Object::directSoundCreate(BSTR  strGuid, I_dxj_DirectSound **ret){
        HRESULT			hr;
        LPDIRECTSOUND8		realsound8=NULL;
        GUID			guid;
        LPGUID			pguid=&guid;
    
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
        LoadDSOUND();
    
        hr=BSTRtoPPGUID(&pguid,strGuid);
        if FAILED(hr) return hr;
    
        if (!m_pDirectSoundCreate) return E_FAIL;
    
        hr=(m_pDirectSoundCreate)((GUID*)pguid,&realsound8,NULL);
        if FAILED(hr) return  hr;
      
        INTERNAL_CREATE(_dxj_DirectSound,realsound8,ret);
        
        if (*ret==NULL) {
            realsound8->Release();
            return E_FAIL;
        }
    
        return hr;		
    }
    
    
    STDMETHODIMP C_dxj_DirectX7Object::directSoundCaptureCreate(BSTR strGuid, I_dxj_DirectSoundCapture **ret){
        HRESULT		  hr;
        LPDIRECTSOUNDCAPTURE realsound1=NULL;
        LPDIRECTSOUNDCAPTURE8 realsound8=NULL;
        GUID			guid;
        LPGUID			pguid=&guid;
        hr=BSTRtoPPGUID(&pguid,strGuid);
        if FAILED(hr) return hr;
    
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
    	LoadDSOUND();
    
    
        if (!m_pDirectSoundCaptureCreate) return E_FAIL;
    
        hr=(m_pDirectSoundCaptureCreate)(pguid,&realsound1,NULL); 
        if FAILED(hr) return  hr;
        
		// I'm getting No Such interface on this call. - BUG
		hr=realsound1->QueryInterface(IID_IDirectSoundCapture8,(void**)&realsound8);
		realsound1->Release();
		if FAILED(hr) return hr;
	  
    
        INTERNAL_CREATE(_dxj_DirectSoundCapture,realsound8,ret);
        
        if (*ret==NULL) {
            realsound8->Release();
            return E_FAIL;
        }
    
        if (*ret==NULL) {
            realsound1->Release();
            return E_FAIL;
        }
        return hr;		
    }
    
    
    STDMETHODIMP C_dxj_DirectX7Object::getDSCaptureEnum( I_dxj_DSEnum **retVal)
    {	
        HRESULT hr;
    
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
        LoadDSOUND();
    
        if (!m_pDirectSoundCaptureEnumerate) return E_FAIL;	
        hr=C_dxj_DSEnumObject::create(NULL,m_pDirectSoundCaptureEnumerate,retVal);
    
        return hr;
    
    }
            
    
    
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    
    
    STDMETHODIMP C_dxj_DirectX7Object::getDSEnum( I_dxj_DSEnum **retVal)
    {	
        HRESULT hr;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
        LoadDSOUND();
    
        if (!m_pDirectSoundEnumerate) return E_FAIL;	
        hr=C_dxj_DSEnumObject::create(m_pDirectSoundEnumerate,NULL,retVal);
    
        return hr;
    
    }
    
    
    ////////////////////////////////////////////////////////////////
    
  STDMETHODIMP C_dxj_DirectX7Object::directInputCreate(I_dxj_DirectInput8 **ret){
      
      HRESULT hr;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
      LoadDINPUTDLL();
    

      //DirectInput8Create(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
      static HRESULT (WINAPI *ProcAdd)(HINSTANCE , DWORD , REFIID , LPVOID *, LPUNKNOWN)=NULL;  
  
      if (ProcAdd==NULL){
        if (g_hInstDINPUTDLL==NULL) return E_NOINTERFACE;
        ProcAdd = (HRESULT (WINAPI *)(HINSTANCE , DWORD , REFIID , LPVOID *, LPUNKNOWN)) GetProcAddress(g_hInstDINPUTDLL, "DirectInput8Create"); 
        if (ProcAdd==NULL) return E_FAIL;
      }	
     
      LPDIRECTINPUT8W lpInput8=NULL;
  
      hr= (ProcAdd)(g_hInst,(DWORD)DIRECTINPUT_VERSION,IID_IDirectInput8W,(void**)&lpInput8,NULL);
      if FAILED(hr) return hr;
        
   
      INTERNAL_CREATE(_dxj_DirectInput8,lpInput8,ret);	
    
      return hr;
    }
    
    

//    STDMETHODIMP C_dxj_DirectX7Object::systemBpp(long *retval)
//    {
//        HDC hdc;
//    
//        hdc = ::GetDC(NULL);
//        *retval = GetDeviceCaps(hdc, BITSPIXEL);
//        ::ReleaseDC(NULL, hdc);
//    
//        return S_OK;
//    }

    
    
    
    STDMETHODIMP C_dxj_DirectX7Object::directMusicLoaderCreate ( 
                /* [retval][out] */ I_dxj_DirectMusicLoader __RPC_FAR *__RPC_FAR *ret)
    {
        HRESULT hr;
    
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
        IDirectMusicLoader8 *pLoader=NULL;    

        hr =CoCreateInstance(
                CLSID_DirectMusicLoader, 
            	NULL,
                CLSCTX_INPROC,   
            	IID_IDirectMusicLoader8,
                (void**)&pLoader);
    
        if (FAILED(hr)) return E_NOINTERFACE;
        
        if (!pLoader) return E_FAIL;

		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicLoader,pLoader,ret);
    
        return S_OK;
    }
            
    STDMETHODIMP C_dxj_DirectX7Object::directMusicComposerCreate ( 
                /* [retval][out] */ I_dxj_DirectMusicComposer __RPC_FAR *__RPC_FAR *ret)
    {
        
        IDirectMusicComposer8	*pComp=NULL;    
        HRESULT hr;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
    
        if (FAILED(CoCreateInstance(
                CLSID_DirectMusicComposer, 
            	NULL,
                CLSCTX_INPROC,   
            	IID_IDirectMusicComposer8,
                (void**)&pComp        )))   {
             return E_NOINTERFACE;
        }
        if (!pComp) return E_FAIL;

        INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicComposer,pComp,ret);
        return S_OK;
    }
    
    
    STDMETHODIMP C_dxj_DirectX7Object::directMusicPerformanceCreate ( 
                /* [retval][out] */ I_dxj_DirectMusicPerformance __RPC_FAR *__RPC_FAR *ret)
    {
    
        IDirectMusicPerformance8 *pPerf=NULL;    
        HRESULT hr;

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
            
    
        if (FAILED(CoCreateInstance(
                CLSID_DirectMusicPerformance, 
            	NULL,
                CLSCTX_INPROC,   
            	IID_IDirectMusicPerformance8,
                (void**)&pPerf        )))   {
             return E_NOINTERFACE;
        }
        if (!pPerf) return E_FAIL;
		
        INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicPerformance,pPerf,ret);
        return S_OK;
    }
    
    
    
    
    
#ifdef _WIN64
    STDMETHODIMP C_dxj_DirectX7Object::createEvent( 
                /* [in] */ I_dxj_DirectXEvent8 __RPC_FAR *event,
                /* [retval][out] */ HANDLE __RPC_FAR *h) 
#else
    STDMETHODIMP C_dxj_DirectX7Object::createEvent( 
                /* [in] */ I_dxj_DirectXEvent8 __RPC_FAR *event,
                /* [retval][out] */ LONG __RPC_FAR *h) 
#endif
    {
    
        HRESULT	  hr;
        LPSTREAM  pStm=NULL;
        IUnknown *pUnk=NULL;
    
        HANDLE hEvent=NULL;	
        EVENTTHREADINFO *pNewEvent=NULL;
        EVENTTHREADINFO *pTemp=NULL;
        if (!event) return E_INVALIDARG;
        if (!h) return E_INVALIDARG;
    
        pNewEvent=(EVENTTHREADINFO*)malloc(sizeof(EVENTTHREADINFO));
        if (!pNewEvent) return E_OUTOFMEMORY;
		ZeroMemory(pNewEvent, sizeof(EVENTTHREADINFO));
        pNewEvent->pNext=NULL;
        pNewEvent->fEnd=FALSE;	
        pNewEvent->pCallback=event;
        pNewEvent->pStream=NULL;
        event->AddRef();
    
    
    
        pNewEvent->hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
        if (!pNewEvent->hEvent){
            free(pNewEvent);
            event->Release();
            return E_FAIL;
        }
    
        //pNewEvent->hEndEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
        
        hr=event->QueryInterface(IID_IUnknown,(void**)&pUnk);
        if FAILED(hr) {
          	free(pNewEvent);
          	event->Release();
          	return E_FAIL;
        }
    
        hr=CoMarshalInterThreadInterfaceInStream(IID_IUnknown,pUnk,&pStm);
        if (pUnk) pUnk->Release();
        if FAILED(hr) {  			
          	free(pNewEvent);
          	event->Release();			
          	return E_FAIL;
        }
    
        pNewEvent->pStream=pStm;
    
        pNewEvent->hThread=CreateThread(NULL,0,ThreadFunc,(unsigned long*)pNewEvent,CREATE_SUSPENDED ,&pNewEvent->threadID);
        if (!pNewEvent->threadID) {
            	CloseHandle(pNewEvent->hEvent);
            	free(pNewEvent);
            	event->Release();
            	return E_FAIL;
        }
    
    
        if (!m_pEventList){
            m_pEventList=pNewEvent;
        }
        else{
            pTemp=m_pEventList;
            m_pEventList=pNewEvent;	
            pNewEvent->pNext=pTemp;
        }
    
    
        ResumeThread(pNewEvent->hThread);
            
    
#ifdef _WIN64
		*h=(pNewEvent->hEvent); 
#else
		*h=(LONG)PtrToLong(pNewEvent->hEvent); 
#endif
        return S_OK;
    }
            
#ifdef _WIN64
    STDMETHODIMP C_dxj_DirectX7Object::setEvent( 
                /* [in] */ HANDLE eventId)  
	{
        SetEvent(eventId);
        return S_OK;
    }
#else
    STDMETHODIMP C_dxj_DirectX7Object::setEvent( 
                /* [in] */ LONG eventId)  
	{
        SetEvent((HANDLE)eventId);
        return S_OK;
    }
#endif
    
#ifdef _WIN64
    STDMETHODIMP C_dxj_DirectX7Object::destroyEvent( 
                /* [in] */ HANDLE eventId)  
#else
    STDMETHODIMP C_dxj_DirectX7Object::destroyEvent( 
                /* [in] */ LONG eventId)  
#endif
    {
        //find the info on the stack
        if (!m_pEventList) return E_INVALIDARG;
    
        EVENTTHREADINFO *pTemp=NULL;
        EVENTTHREADINFO *pLast=NULL;
    
        //rely on lazy evaluation
        for (pTemp=m_pEventList; ((pTemp)&&(pTemp->hEvent!=(HANDLE)eventId));pLast=pTemp,pTemp=pTemp->pNext);
        if (!pTemp) return E_INVALIDARG;
    
        //remove it from our Link List
        if (!pLast) {
            m_pEventList=pTemp->pNext;		
        }
        else {
            pLast->pNext=pTemp->pNext;
        }
    
        //indicate that we want to kill the thread
        pTemp->fEnd=TRUE;
    
        //Fire the event in case we are waiting	
        if (pTemp->hEvent) SetEvent(pTemp->hEvent);
    
        //Wait for it to finish out
        if (pTemp->hThread) WaitForSingleObject(pTemp->hThread,1000);
    
        //wait for the end event to signal
        //if (pTemp->hEndEvent) WaitForSingleObject(pTemp->hEndEvent,1000);
    
        //desctroy the event
        if (pTemp->hEvent) CloseHandle(pTemp->hEvent);
        //if (pTemp->hEndEvent) CloseHandle (pTemp->hEndEvent);
        
        if (pTemp->pCallback) pTemp->pCallback->Release();
        
        //thread is gone..
        
        //free the memory
        free(pTemp);
    
        return S_OK;
    }
    
    DWORD WINAPI ThreadFunc(LPVOID param){
        HRESULT hr;
        IUnknown *pUnk=NULL;
        EVENTTHREADINFO *pCntrl=(EVENTTHREADINFO *)param;
        I_dxj_DirectXEvent8	*pVBCallback=NULL;
            
    
        OleInitialize(NULL);
    
    
        LCID LOCAL_SYSTEM_DEFAULT=GetSystemDefaultLCID();
    
    
        //note pstrm is released even on failure
        hr=CoGetInterfaceAndReleaseStream(pCntrl->pStream,IID_IUnknown,(void**)&pUnk);
        pCntrl->pCallback=NULL;	//since released to 0
    
        if FAILED(hr) return -1;
        if (!pUnk) return -1;
        
    
        
        hr=pUnk->QueryInterface(IID_I_dxj_DirectXEvent8,(void**)&pVBCallback);
        pUnk->Release();
    
        if FAILED(hr) return -1;  
    
        while (pCntrl->fEnd==FALSE) 
        {
            WaitForSingleObject(pCntrl->hEvent,INFINITE);
          	if ((pVBCallback )&&(pCntrl->fEnd==FALSE))
        	{
         		pVBCallback->AddRef();
#ifdef _WIN64
        		pVBCallback->DXCallback(pCntrl->hEvent); 
#else
        		pVBCallback->DXCallback((LONG)PtrToLong(pCntrl->hEvent)); 
#endif
          		pVBCallback->Release();
         	}
        }
    
    
        if (pVBCallback) pVBCallback->Release();
    
        OleUninitialize();
    
        //we need to syncronize the ending of the thread..
        //if (pCntrl->hEndEvent) SetEvent(pCntrl->hEndEvent);		
        
        return 0;
    }
    
    
    STDMETHODIMP C_dxj_DirectX7Object::createNewGuid(BSTR *ret)
    {
      	GUID g=GUID_NULL;
      	if (!ret) return E_INVALIDARG;
    
      	::CoCreateGuid(&g);
      	*ret=GUIDtoBSTR(&g);
      	return S_OK;
    }
    
    STDMETHODIMP C_dxj_DirectX7Object::DirectXFileCreate(I_dxj_DirectXFile **ret)
    {
		HRESULT hr;
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
		hr=C_dxj_DirectXFileObject::create(ret);
		return hr;

    }


    STDMETHODIMP C_dxj_DirectX7Object::Direct3DCreate(IUnknown **ppRet)
    {
        HRESULT hr;
#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif
	LoadD3D8();
	if (!m_pDirect3DCreate8) return E_FAIL;
	
	*ppRet=(IUnknown*) m_pDirect3DCreate8(D3D_SDK_VERSION);

       	return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundsourceobj.h ===
#include "resource.h"       // main symbols
#include "dsound.h"

#define typedef__dxj_DirectSoundSource LPDIRECTSOUNDSOURCE

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundSource : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundSource, &IID_I_dxj_DirectSoundSource, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundSource,
#endif

	public CComObjectRoot
{

public:
	C_dxj_DirectSoundSource() ;
	virtual ~C_dxj_DirectSoundSource() ;

BEGIN_COM_MAP(C_dxj_DirectSoundSource)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundSource)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundSource)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundSource
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

			HRESULT STDMETHODCALLTYPE GetFormat(
			/* [in] */ WAVEFORMATEX_CDESC __RPC_FAR *WaveFormatEx);

			HRESULT STDMETHODCALLTYPE SetSink(
			/* [in] */ I_dxj_DirectSoundSink __RPC_FAR *SoundSink);

			HRESULT STDMETHODCALLTYPE Seek(long lPosition);

			HRESULT STDMETHODCALLTYPE Read(I_dxj_DirectSoundBuffer *Buffers[], long *busIDs, long lBusCount);

			HRESULT STDMETHODCALLTYPE GetSize(long *ret);

	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundSource);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundSource);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\frmsave.h ===
//**************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999 All Rights Reserved.
//
//  File:   frmsave.h
//
//  Description:    Save LPDIRECT3DRMFRAME to an x file.
//
//  History:
//      011/06/98    CongpaY     Created
//
//**************************************************************************

typedef struct _Header {
    WORD major;
    WORD minor;
    DWORD flags;
} Header;

typedef struct _ColorRGBA {
    float r;
    float g;
    float b;
    float a;
} ColorRGBA;

typedef struct _ColorRGB {
    float r;
    float g;
    float b;
} ColorRGB;

typedef struct _IndexedColor {
    DWORD index;
    ColorRGBA color;
} IndexedColor;

typedef struct _VertexColors {
    DWORD cVertices;
    IndexedColor vertexColors[1];
} VertexColors;

typedef struct _Boolean2d {
    BOOL u;
    BOOL v;
} Boolean2d;

typedef struct _FaceWraps {
    DWORD cFaces;
    Boolean2d faceWraps[1];
} FaceWraps;

typedef struct _Coords2d {
    float u;
    float v;
} Coords2d;

typedef struct _TextureCoords {
    DWORD cVertices;
    Coords2d textureCoords[1];
} TextureCoords;

typedef struct _FaceMaterials {
    DWORD cMaterials;
    DWORD cFaceIndexes;
    DWORD faceIndexes[1];
} FaceMaterials;

typedef struct _BaseMaterial {
    ColorRGBA faceColor;
    float power;
    ColorRGB specularColor;
    ColorRGB emissiveColor;
} BaseMaterial;

typedef struct _FaceMaterial {
    D3DCOLOR faceColor;
    LPDIRECT3DRMMATERIAL pMaterial;
    LPDIRECT3DRMTEXTURE pTexture;
    _FaceMaterial *pNext;
} FaceMaterial;

typedef void (__stdcall *CREATEXFILE)( IDirectXFile **);

class FaceMaterialList
{
    DWORD cElements;
    FaceMaterial *pFirst;	

public:
    FaceMaterialList();
    ~FaceMaterialList();

    DWORD Find(D3DCOLOR faceColor,
               LPDIRECT3DRMMATERIAL pMaterial,
               LPDIRECT3DRMTEXTURE pTexture);

    DWORD Count() { return cElements; }
    FaceMaterial *First() { return pFirst; }
};

class NameEntry {
public:
    LPSTR pName;
    NameEntry *pNext;
};

class NameList
{
    NameEntry *pFirst;
    NameEntry **ppLast;
public:
    NameList();
    ~NameList();
    void Add(LPSTR pName);
};

class Saver {
public:
    Saver();
    ~Saver();

    HRESULT Init(LPCSTR filename,
                 D3DRMXOFFORMAT d3dFormat,
                 D3DRMSAVEOPTIONS d3dSaveFlags);

    HRESULT SaveHeaderObject();
    
    HRESULT SaveFrame(LPDIRECT3DRMFRAME3 pFrame,
                      LPDIRECT3DRMFRAME3 pRefFrame = NULL,
                      LPDIRECTXFILEDATA  pRefFrameObj = NULL);
private:	
    LPDIRECTXFILE pXFile;
    LPDIRECTXFILESAVEOBJECT pSave;
    D3DRMXOFFORMAT d3dFormat;
    D3DRMSAVEOPTIONS d3dSaveFlags;
    NameList lNames;

    HRESULT SaveFrameTransform(LPDIRECTXFILEDATA pFrameObj,
                               LPDIRECT3DRMFRAME3 pFrame,
                               LPDIRECT3DRMFRAME3 pRefFrame);
    
    HRESULT SaveMeshBuilder(LPDIRECTXFILEDATA pFrameObj,
                            LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateMeshObject(DWORD cVertices,
                             DWORD cFaces,
                             DWORD dwFaceData,
                             LPDWORD pdwFaceData,
                             LPDIRECT3DRMMESHBUILDER3 pMeshBuilder,
                             LPDIRECTXFILEDATA *ppMeshObj);
    
    HRESULT CreateNormalsObject(LPDIRECTXFILEDATA pMeshObj,
                                DWORD cNormals,
                                DWORD cFaces,
                                DWORD dwFaceData,
                                LPDWORD pdwFaceData,
                                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateVertexColorsObject(LPDIRECTXFILEDATA pMeshObj,
                                     DWORD cVertices,
                                     LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateMaterialListObject(LPDIRECTXFILEDATA pMeshObj,
                                     LPDIRECT3DRMFACEARRAY pFaceArray);
    
    HRESULT CreateMaterialObject(LPDIRECTXFILEDATA pMatListObj,
                                 FaceMaterial *pMat);
    
    HRESULT CreateTextureWrapsObject(LPDIRECTXFILEDATA pMeshObj,
                                     LPDIRECT3DRMFACEARRAY pFaceArray);
    
    HRESULT CreateTextureCoordsObject(LPDIRECTXFILEDATA pMeshObj,
                                      DWORD cVertices,
                                      LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dsoundwaveobj.h ===
#include "resource.h"       // main symbols
#include "dsound.h"

#define typedef__dxj_DirectSoundWave LPDIRECTSOUNDWAVE

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundWaveObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundWave, &IID_I_dxj_DirectSoundWave, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundWave,
#endif

	public CComObjectRoot
{

public:
	C_dxj_DirectSoundWaveObject() ;
	virtual ~C_dxj_DirectSoundWaveObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundWaveObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundWave)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectSoundWaveObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundWave
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

			HRESULT STDMETHODCALLTYPE GetWaveArticulation(DMUS_WAVEART_CDESC *Articulation);             
			
			HRESULT STDMETHODCALLTYPE CreateSource(WAVEFORMATEX_CDESC format, long lFlags, I_dxj_DirectSoundSource **Source); 
			
			HRESULT STDMETHODCALLTYPE GetFormat(WAVEFORMATEX_CDESC *format, long lFlags);                                           

	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectSoundWave);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectSoundWave);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\filestrm.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: filestrm.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 09/23/99 (mikemarr)  - copyright, started history
// -@- 07/15/00 (andrewke)  - replicated in DXVB dir
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "Filestrm.h"

CFileStream::CFileStream(LPCTSTR filename, BOOL bRead, BOOL bTruncate, HRESULT *error)
{
    m_hfile = CreateFile(filename, bRead ? GENERIC_READ : GENERIC_WRITE, 0, NULL, 
						  (bTruncate ? CREATE_ALWAYS : OPEN_EXISTING), FILE_ATTRIBUTE_NORMAL,
						  NULL);
	if (error)
	{
        ULONG foo = GetLastError();
		if (m_hfile == INVALID_HANDLE_VALUE)
			*error = E_FAIL;
		else
			*error = NOERROR;
	}
	m_cRef = 1;
}

CFileStream::~CFileStream()
{
	CloseHandle(m_hfile);
}

STDMETHODIMP_(ULONG) CFileStream::AddRef(void)
{
	return m_cRef++;	
}

STDMETHODIMP_(ULONG) CFileStream::Release(void)
{
	if (--m_cRef != 0)	
		return m_cRef;	
	
	delete this;
	return 0;
}


STDMETHODIMP CFileStream::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{	
	*ppv=NULL;
	if (riid == IID_IUnknown)
		*ppv=(IUnknown*)this;
	else if (riid == IID_IStream)
		*ppv=(IStream*)this;
	else
		return E_NOINTERFACE;
	((LPUNKNOWN)*ppv)->AddRef();
	return NOERROR;
}


STDMETHODIMP CFileStream::Read(void __RPC_FAR *pv, ULONG cb, ULONG __RPC_FAR *pcbRead)
{
	DWORD read;
	BOOL result = ReadFile(m_hfile, pv, cb, &read, NULL);
	if (pcbRead)
		*pcbRead = read;
	if (result)
		return S_OK;
	else
		return E_FAIL;
}


STDMETHODIMP CFileStream::Write(const void __RPC_FAR *pv, ULONG cb, ULONG __RPC_FAR *pcbWritten)
{
	DWORD written;
	BOOL result = WriteFile(m_hfile, pv, cb, &written, NULL);
	if (pcbWritten)
		*pcbWritten = written;
	if (result)
		return S_OK;
	else
		return E_FAIL;
}

STDMETHODIMP CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	LONG movelow;
	LONG movehigh;

	movelow = dlibMove.LowPart;
	movehigh = dlibMove.HighPart;

	DWORD moveMethod;
	switch (dwOrigin)
	{
	case STREAM_SEEK_SET: moveMethod = FILE_BEGIN; break;
	case STREAM_SEEK_CUR: moveMethod = FILE_CURRENT; break;
	case STREAM_SEEK_END: moveMethod = FILE_END; break;
	default: return E_INVALIDARG;
	}



	DWORD result = SetFilePointer(m_hfile, movelow, &movehigh, moveMethod);

	if (plibNewPosition)
	{
		plibNewPosition->LowPart = result;
		plibNewPosition->HighPart = movehigh;
	}

	if (result != -1)
		return NOERROR;
	else
		return E_FAIL;
}


STDMETHODIMP CFileStream::Stat(STATSTG __RPC_FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    pstatstg->pwcsName = NULL; 
    pstatstg->type = STGTY_STREAM; 

    pstatstg->cbSize.LowPart = GetFileSize(m_hfile, &pstatstg->cbSize.HighPart); 

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dxerr8.cpp ===
/*==========================================================================;
 *
 *
 *  File:   dxerr8.cpp
 *  Content:    DirectX Error Library 
 *
 ****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <MMsystem.h>


#include"d3d8.h"
#include"d3dx8.h"
#include"d3dxerr.h"
#include"dsound.h"
#include"dmusici.h"
#include"dplay8.h"
#include"dvoice.h"
#include"dinput.h"
#include"dinputd.h"

//#include"appman.h"

#define BUFFER_SIZE 3000
#define  CHK_ERR(hrchk, strOut) \
        case hrchk: \
             return strOut;     


/****************************************************/
/* DXGetErrorString8A                                */
/*                                                  */
/****************************************************/

const char * __stdcall  DXGetErrorString8A(HRESULT hr)
{
   switch(hr)
   {     
        // Common Win32 error codes
        CHK_ERR(S_OK, "S_OK")
        CHK_ERR(S_FALSE, "S_FALSE")
        
        CHK_ERR(E_UNEXPECTED, "E_UNEXPECTED")
        CHK_ERR(E_NOTIMPL, "E_NOTIMPL")
        CHK_ERR(E_OUTOFMEMORY, "E_OUTOFMEMORY")
        CHK_ERR(E_INVALIDARG, "E_INVALIDARG")
        CHK_ERR(E_NOINTERFACE, "E_NOINTERFACE")
        CHK_ERR(E_POINTER, "E_POINTER")
        CHK_ERR(E_HANDLE, "E_HANDLE")
        CHK_ERR(E_ABORT, "E_ABORT")
        CHK_ERR(E_FAIL, "E_FAIL")
        CHK_ERR(E_ACCESSDENIED, "E_ACCESSDENIED")
        CHK_ERR(E_PENDING, "E_PENDING")
        CHK_ERR(REGDB_E_CLASSNOTREG, "REGDB_E_CLASSNOTREG")
        CHK_ERR(CO_E_NOTINITIALIZED, "CO_E_NOTINITIALIZED")
        CHK_ERR(CO_E_ALREADYINITIALIZED, "CO_E_ALREADYINITIALIZED")

//      CHK_ERR(DIERR_GENERIC, "E_FAIL")
        CHK_ERR(DIERR_NOAGGREGATION, "E_NOAGGREGATION")
        CHK_ERR(DIERR_INSUFFICIENTPRIVS, "DIERR_INSUFFICIENTPRIVS")
        CHK_ERR(DIERR_DEVICEFULL, "DIERR_DEVICEFULL")
        CHK_ERR(DIERR_MOREDATA, "DIERR_MOREDATA")
        CHK_ERR(DIERR_NOTDOWNLOADED, "DIERR_NOTDOWNLOADED")
        CHK_ERR(DIERR_HASEFFECTS, "DIERR_HASEFFECTS")
        CHK_ERR(DIERR_NOTEXCLUSIVEACQUIRED, "DIERR_NOTEXCLUSIVEACQUIRED")
        CHK_ERR(DIERR_INCOMPLETEEFFECT, "DIERR_INCOMPLETEEFFECT")
        CHK_ERR(DIERR_NOTBUFFERED, "DIERR_NOTBUFFERED")
        CHK_ERR(DIERR_EFFECTPLAYING, "DIERR_EFFECTPLAYING")
        CHK_ERR(DIERR_UNPLUGGED, "DIERR_UNPLUGGED")
        CHK_ERR(DIERR_REPORTFULL, "DIERR_REPORTFULL")
        CHK_ERR(DIERR_DRIVERFIRST, "DIERR_DRIVERFIRST")
        CHK_ERR(DIERR_DRIVERLAST, "DIERR_DRIVERLAST")
        CHK_ERR(DIERR_INVALIDCLASSINSTALLER, "DIERR_INVALIDCLASSINSTALLER")
        CHK_ERR(DIERR_CANCELLED, "DIERR_CANCELLED")
        CHK_ERR(DIERR_BADINF, "DIERR_BADINF")
        CHK_ERR(DIERR_NOTFOUND, "DIERR_NOTFOUND or DIERR_NOTFOUND")
//      CHK_ERR(DIERR_READONLY, "DIERR_READONLY or DIERR_OTHERAPPHASPRIO or DIERR_HANDLEEXISTS or DSERR_ACCESSDENIED")
        CHK_ERR(DIERR_NOTACQUIRED, "DIERR_NOTACQUIRED")
//      CHK_ERR(DIERR_OUTOFMEMORY, "E_OUTOFMEMORY")
        CHK_ERR(DIERR_NOTINITIALIZED, "DIERR_NOTINITIALIZED")
        CHK_ERR(DIERR_INPUTLOST, "DIERR_INPUTLOST")
        CHK_ERR(DIERR_BADDRIVERVER, "DIERR_BADDRIVERVER")
        CHK_ERR(DIERR_ACQUIRED, "DIERR_ACQUIRED")
        CHK_ERR(DIERR_NOMOREITEMS, "DIERR_NOMOREITEMS")
        CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, "DIERR_OLDDIRECTINPUTVERSION")
        CHK_ERR(DIERR_BETADIRECTINPUTVERSION, "DIERR_BETADIRECTINPUTVERSION")
        CHK_ERR(DIERR_ALREADYINITIALIZED, "DIERR_ALREADYINITIALIZED")
        
        CHK_ERR(DVERR_BUFFERTOOSMALL, "DVERR_BUFFERTOOSMALL")
        CHK_ERR(DVERR_EXCEPTION, "DVERR_EXCEPTION")
        CHK_ERR(DVERR_INVALIDFLAGS, "DVERR_INVALIDFLAGS")
        CHK_ERR(DVERR_INVALIDOBJECT, "DVERR_INVALIDOBJECT")
        CHK_ERR(DVERR_INVALIDPLAYER, "DVERR_INVALIDPLAYER")
        CHK_ERR(DVERR_INVALIDGROUP, "DVERR_INVALIDGROUP")
        CHK_ERR(DVERR_INVALIDHANDLE, "DVERR_INVALIDHANDLE")
        CHK_ERR(DVERR_SESSIONLOST, "DVERR_SESSIONLOST")
        CHK_ERR(DVERR_NOVOICESESSION, "DVERR_NOVOICESESSION")
        CHK_ERR(DVERR_CONNECTIONLOST, "DVERR_CONNECTIONLOST")
        CHK_ERR(DVERR_NOTINITIALIZED, "DVERR_NOTINITIALIZED")
        CHK_ERR(DVERR_CONNECTED, "DVERR_CONNECTED")
        CHK_ERR(DVERR_NOTCONNECTED, "DVERR_NOTCONNECTED")
        CHK_ERR(DVERR_CONNECTABORTING, "DVERR_CONNECTABORTING")
        CHK_ERR(DVERR_NOTALLOWED, "DVERR_NOTALLOWED")
        CHK_ERR(DVERR_INVALIDTARGET, "DVERR_INVALIDTARGET")
        CHK_ERR(DVERR_TRANSPORTNOTHOST, "DVERR_TRANSPORTNOTHOST")
        CHK_ERR(DVERR_COMPRESSIONNOTSUPPORTED, "DVERR_COMPRESSIONNOTSUPPORTED")
        CHK_ERR(DVERR_ALREADYPENDING, "DVERR_ALREADYPENDING")
        CHK_ERR(DVERR_SOUNDINITFAILURE, "DVERR_SOUNDINITFAILURE")
        CHK_ERR(DVERR_TIMEOUT, "DVERR_TIMEOUT")
        CHK_ERR(DVERR_CONNECTABORTED, "DVERR_CONNECTABORTED")
        CHK_ERR(DVERR_NO3DSOUND, "DVERR_NO3DSOUND")
        CHK_ERR(DVERR_ALREADYBUFFERED, "DVERR_ALREADYBUFFERED")
        CHK_ERR(DVERR_NOTBUFFERED, "DVERR_NOTBUFFERED")
        CHK_ERR(DVERR_HOSTING, "DVERR_HOSTING")
        CHK_ERR(DVERR_NOTHOSTING, "DVERR_NOTHOSTING")
        CHK_ERR(DVERR_INVALIDDEVICE, "DVERR_INVALIDDEVICE")
        CHK_ERR(DVERR_RECORDSYSTEMERROR, "DVERR_RECORDSYSTEMERROR")
        CHK_ERR(DVERR_PLAYBACKSYSTEMERROR, "DVERR_PLAYBACKSYSTEMERROR")
        CHK_ERR(DVERR_SENDERROR, "DVERR_SENDERROR")
        CHK_ERR(DVERR_USERCANCEL, "DVERR_USERCANCEL")
        CHK_ERR(DVERR_RUNSETUP, "DVERR_RUNSETUP")
        CHK_ERR(DVERR_INCOMPATIBLEVERSION, "DVERR_INCOMPATIBLEVERSION")
        CHK_ERR(DVERR_INITIALIZED, "DVERR_INITIALIZED")
        CHK_ERR(DVERR_NOTRANSPORT, "DVERR_NOTRANSPORT")
        CHK_ERR(DVERR_NOCALLBACK, "DVERR_NOCALLBACK")
        CHK_ERR(DVERR_TRANSPORTNOTINIT, "DVERR_TRANSPORTNOTINIT")
        CHK_ERR(DVERR_TRANSPORTNOSESSION, "DVERR_TRANSPORTNOSESSION")
        CHK_ERR(DVERR_TRANSPORTNOPLAYER, "DVERR_TRANSPORTNOPLAYER")
        CHK_ERR(DVERR_USERBACK, "DVERR_USERBACK")
        CHK_ERR(DVERR_NORECVOLAVAILABLE, "DVERR_NORECVOLAVAILABLE")
        
        CHK_ERR(DPNERR_ABORTED, "DPNERR_ABORTED")
        CHK_ERR(DPNERR_ADDRESSING, "DPNERR_ADDRESSING")
        CHK_ERR(DPNERR_ALREADYCONNECTED, "DPNERR_ALREADYCONNECTED")
        CHK_ERR(DPNERR_ALREADYDISCONNECTING, "DPNERR_ALREADYDISCONNECTING")
        CHK_ERR(DPNERR_ALREADYINITIALIZED, "DPNERR_ALREADYINITIALIZED")
        CHK_ERR(DPNERR_ALREADYREGISTERED, "DPNERR_ALREADYREGISTERED")
        CHK_ERR(DPNERR_BUFFERTOOSMALL, "DPNERR_BUFFERTOOSMALL")
        CHK_ERR(DPNERR_CANNOTCANCEL, "DPNERR_CANNOTCANCEL")
        CHK_ERR(DPNERR_CANTCREATEGROUP, "DPNERR_CANTCREATEGROUP")
        CHK_ERR(DPNERR_CANTCREATEPLAYER, "DPNERR_CANTCREATEPLAYER")
        CHK_ERR(DPNERR_CANTLAUNCHAPPLICATION, "DPNERR_CANTLAUNCHAPPLICATION")
        CHK_ERR(DPNERR_CONNECTING, "DPNERR_CONNECTING")
        CHK_ERR(DPNERR_CONNECTIONLOST, "DPNERR_CONNECTIONLOST")
        CHK_ERR(DPNERR_CONVERSION, "DPNERR_CONVERSION")
        CHK_ERR(DPNERR_DOESNOTEXIST, "DPNERR_DOESNOTEXIST")
        CHK_ERR(DPNERR_DUPLICATECOMMAND, "DPNERR_DUPLICATECOMMAND")
        CHK_ERR(DPNERR_ENDPOINTNOTRECEIVING, "DPNERR_ENDPOINTNOTRECEIVING")
        CHK_ERR(DPNERR_EXCEPTION, "DPNERR_EXCEPTION")
        CHK_ERR(DPNERR_GROUPNOTEMPTY, "DPNERR_GROUPNOTEMPTY")
        CHK_ERR(DPNERR_HOSTING, "DPNERR_HOSTING")
        CHK_ERR(DPNERR_HOSTREJECTEDCONNECTION, "DPNERR_HOSTREJECTEDCONNECTION")
        CHK_ERR(DPNERR_INCOMPLETEADDRESS, "DPNERR_INCOMPLETEADDRESS")
        CHK_ERR(DPNERR_INVALIDADDRESSFORMAT, "DPNERR_INVALIDADDRESSFORMAT")
        CHK_ERR(DPNERR_INVALIDAPPLICATION, "DPNERR_INVALIDAPPLICATION")
        CHK_ERR(DPNERR_INVALIDCOMMAND, "DPNERR_INVALIDCOMMAND")
        CHK_ERR(DPNERR_INVALIDENDPOINT, "DPNERR_INVALIDENDPOINT")
        CHK_ERR(DPNERR_INVALIDFLAGS, "DPNERR_INVALIDFLAGS")
        CHK_ERR(DPNERR_INVALIDGROUP, "DPNERR_INVALIDGROUP")
        CHK_ERR(DPNERR_INVALIDHANDLE, "DPNERR_INVALIDHANDLE")
        CHK_ERR(DPNERR_INVALIDINSTANCE, "DPNERR_INVALIDINSTANCE")
        CHK_ERR(DPNERR_INVALIDINTERFACE, "DPNERR_INVALIDINTERFACE")
        CHK_ERR(DPNERR_INVALIDDEVICEADDRESS, "DPNERR_INVALIDDEVICEADDRESS")
        CHK_ERR(DPNERR_INVALIDOBJECT, "DPNERR_INVALIDOBJECT")
        CHK_ERR(DPNERR_INVALIDPASSWORD, "DPNERR_INVALIDPASSWORD")
        CHK_ERR(DPNERR_INVALIDPLAYER, "DPNERR_INVALIDPLAYER")
        CHK_ERR(DPNERR_INVALIDPRIORITY, "DPNERR_INVALIDPRIORITY")
        CHK_ERR(DPNERR_INVALIDHOSTADDRESS, "DPNERR_INVALIDHOSTADDRESS")
        CHK_ERR(DPNERR_INVALIDSTRING, "DPNERR_INVALIDSTRING")
        CHK_ERR(DPNERR_INVALIDURL, "DPNERR_INVALIDURL")
        CHK_ERR(DPNERR_NOCAPS, "DPNERR_NOCAPS")
        CHK_ERR(DPNERR_NOCONNECTION, "DPNERR_NOCONNECTION")
        CHK_ERR(DPNERR_NOHOSTPLAYER, "DPNERR_NOHOSTPLAYER")
        CHK_ERR(DPNERR_NOMOREADDRESSCOMPONENTS, "DPNERR_NOMOREADDRESSCOMPONENTS")
        CHK_ERR(DPNERR_NORESPONSE, "DPNERR_NORESPONSE")
        CHK_ERR(DPNERR_NOTALLOWED, "DPNERR_NOTALLOWED")
        CHK_ERR(DPNERR_NOTHOST, "DPNERR_NOTHOST")
        CHK_ERR(DPNERR_NOTREADY, "DPNERR_NOTREADY")
        CHK_ERR(DPNERR_NOTREGISTERED, "DPNERR_NOTREGISTERED")
        CHK_ERR(DPNERR_PLAYERLOST, "DPNERR_PLAYERLOST")
        CHK_ERR(DPNERR_SENDTOOLARGE, "DPNERR_SENDTOOLARGE")
        CHK_ERR(DPNERR_SESSIONFULL, "DPNERR_SESSIONFULL")
        CHK_ERR(DPNERR_TABLEFULL, "DPNERR_TABLEFULL")
        CHK_ERR(DPNERR_TIMEDOUT, "DPNERR_TIMEDOUT")
        CHK_ERR(DPNERR_UNINITIALIZED, "DPNERR_UNINITIALIZED")
        CHK_ERR(DPNERR_USERCANCEL, "DPNERR_USERCANCEL")
        
        CHK_ERR(DXFILEERR_BADOBJECT, "DXFILEERR_BADOBJECT")
        CHK_ERR(DXFILEERR_BADVALUE, "DXFILEERR_BADVALUE")
        CHK_ERR(DXFILEERR_BADTYPE, "DXFILEERR_BADTYPE")
        CHK_ERR(DXFILEERR_BADSTREAMHANDLE, "DXFILEERR_BADSTREAMHANDLE")
        CHK_ERR(DXFILEERR_BADALLOC, "DXFILEERR_BADALLOC")
        CHK_ERR(DXFILEERR_NOTFOUND, "DXFILEERR_NOTFOUND")
        CHK_ERR(DXFILEERR_NOTDONEYET, "DXFILEERR_NOTDONEYET")
        CHK_ERR(DXFILEERR_FILENOTFOUND, "DXFILEERR_FILENOTFOUND")
        CHK_ERR(DXFILEERR_RESOURCENOTFOUND, "DXFILEERR_RESOURCENOTFOUND")
        CHK_ERR(DXFILEERR_URLNOTFOUND, "DXFILEERR_URLNOTFOUND")
        CHK_ERR(DXFILEERR_BADRESOURCE, "DXFILEERR_BADRESOURCE")
        CHK_ERR(DXFILEERR_BADFILETYPE, "DXFILEERR_BADFILETYPE")
        CHK_ERR(DXFILEERR_BADFILEVERSION, "DXFILEERR_BADFILEVERSION")
        CHK_ERR(DXFILEERR_BADFILEFLOATSIZE, "DXFILEERR_BADFILEFLOATSIZE")
        CHK_ERR(DXFILEERR_BADFILECOMPRESSIONTYPE, "DXFILEERR_BADFILECOMPRESSIONTYPE")
        CHK_ERR(DXFILEERR_BADFILE, "DXFILEERR_BADFILE")
        CHK_ERR(DXFILEERR_PARSEERROR, "DXFILEERR_PARSEERROR")
        CHK_ERR(DXFILEERR_NOTEMPLATE, "DXFILEERR_NOTEMPLATE")
        CHK_ERR(DXFILEERR_BADARRAYSIZE, "DXFILEERR_BADARRAYSIZE")
        CHK_ERR(DXFILEERR_BADDATAREFERENCE, "DXFILEERR_BADDATAREFERENCE")
        CHK_ERR(DXFILEERR_INTERNALERROR, "DXFILEERR_INTERNALERROR")
        CHK_ERR(DXFILEERR_NOMOREOBJECTS, "DXFILEERR_NOMOREOBJECTS")
        CHK_ERR(DXFILEERR_BADINTRINSICS, "DXFILEERR_BADINTRINSICS")
        CHK_ERR(DXFILEERR_NOMORESTREAMHANDLES, "DXFILEERR_NOMORESTREAMHANDLES")
        CHK_ERR(DXFILEERR_NOMOREDATA, "DXFILEERR_NOMOREDATA")
        CHK_ERR(DXFILEERR_BADCACHEFILE, "DXFILEERR_BADCACHEFILE")
        CHK_ERR(DXFILEERR_NOINTERNET, "DXFILEERR_NOINTERNET")
        
        CHK_ERR(D3DERR_OUTOFVIDEOMEMORY, "D3DERR_OUTOFVIDEOMEMORY")
        CHK_ERR(D3DERR_WRONGTEXTUREFORMAT, "D3DERR_WRONGTEXTUREFORMAT")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLOROPERATION, "D3DERR_UNSUPPORTEDCOLOROPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLORARG, "D3DERR_UNSUPPORTEDCOLORARG")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAOPERATION, "D3DERR_UNSUPPORTEDALPHAOPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAARG, "D3DERR_UNSUPPORTEDALPHAARG")
        CHK_ERR(D3DERR_TOOMANYOPERATIONS, "D3DERR_TOOMANYOPERATIONS")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREFILTER, "D3DERR_CONFLICTINGTEXTUREFILTER")
        CHK_ERR(D3DERR_UNSUPPORTEDFACTORVALUE, "D3DERR_UNSUPPORTEDFACTORVALUE")
        CHK_ERR(D3DERR_CONFLICTINGRENDERSTATE, "D3DERR_CONFLICTINGRENDERSTATE")
        CHK_ERR(D3DERR_UNSUPPORTEDTEXTUREFILTER, "D3DERR_UNSUPPORTEDTEXTUREFILTER")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREPALETTE, "D3DERR_CONFLICTINGTEXTUREPALETTE")
        CHK_ERR(D3DERR_DRIVERINTERNALERROR, "D3DERR_DRIVERINTERNALERROR")
        CHK_ERR(D3DERR_NOTFOUND, "D3DERR_NOTFOUND")
        CHK_ERR(D3DERR_MOREDATA, "D3DERR_MOREDATA")
        CHK_ERR(D3DERR_DEVICELOST, "D3DERR_DEVICELOST")
        CHK_ERR(D3DERR_DEVICENOTRESET, "D3DERR_DEVICENOTRESET")
        CHK_ERR(D3DERR_NOTAVAILABLE, "D3DERR_NOTAVAILABLE")
        CHK_ERR(D3DERR_INVALIDDEVICE, "D3DERR_INVALIDDEVICE")
        CHK_ERR(D3DERR_INVALIDCALL, "D3DERR_INVALIDCALL")
        
        CHK_ERR(DSERR_ALLOCATED, "DSERR_ALLOCATED")
        CHK_ERR(DSERR_CONTROLUNAVAIL, "DSERR_CONTROLUNAVAIL")
        CHK_ERR(DSERR_INVALIDCALL, "DSERR_INVALIDCALL")
        CHK_ERR(DSERR_PRIOLEVELNEEDED, "DSERR_PRIOLEVELNEEDED")
        CHK_ERR(DSERR_BADFORMAT, "DSERR_BADFORMAT")
        CHK_ERR(DSERR_NODRIVER, "DSERR_NODRIVER")
        CHK_ERR(DSERR_ALREADYINITIALIZED, "DSERR_ALREADYINITIALIZED")
        CHK_ERR(DSERR_BUFFERLOST, "DSERR_BUFFERLOST")
        CHK_ERR(DSERR_OTHERAPPHASPRIO, "DSERR_OTHERAPPHASPRIO")
        CHK_ERR(DSERR_UNINITIALIZED, "DSERR_UNINITIALIZED")
      
        CHK_ERR(DMUS_E_DRIVER_FAILED, "DMUS_E_DRIVER_FAILED")
        CHK_ERR(DMUS_E_PORTS_OPEN, "DMUS_E_PORTS_OPEN")
        CHK_ERR(DMUS_E_DEVICE_IN_USE, "DMUS_E_DEVICE_IN_USE")
        CHK_ERR(DMUS_E_INSUFFICIENTBUFFER, "DMUS_E_INSUFFICIENTBUFFER")
        CHK_ERR(DMUS_E_BUFFERNOTSET, "DMUS_E_BUFFERNOTSET")
        CHK_ERR(DMUS_E_BUFFERNOTAVAILABLE, "DMUS_E_BUFFERNOTAVAILABLE")
        CHK_ERR(DMUS_E_NOTADLSCOL, "DMUS_E_NOTADLSCOL")
        CHK_ERR(DMUS_E_INVALIDOFFSET, "DMUS_E_INVALIDOFFSET")
        CHK_ERR(DMUS_E_ALREADY_LOADED, "DMUS_E_ALREADY_LOADED")
        CHK_ERR(DMUS_E_INVALIDPOS, "DMUS_E_INVALIDPOS")
        CHK_ERR(DMUS_E_INVALIDPATCH, "DMUS_E_INVALIDPATCH")
        CHK_ERR(DMUS_E_CANNOTSEEK, "DMUS_E_CANNOTSEEK")
        CHK_ERR(DMUS_E_CANNOTWRITE, "DMUS_E_CANNOTWRITE")
        CHK_ERR(DMUS_E_CHUNKNOTFOUND, "DMUS_E_CHUNKNOTFOUND")
        CHK_ERR(DMUS_E_INVALID_DOWNLOADID, "DMUS_E_INVALID_DOWNLOADID")
        CHK_ERR(DMUS_E_NOT_DOWNLOADED_TO_PORT, "DMUS_E_NOT_DOWNLOADED_TO_PORT")
        CHK_ERR(DMUS_E_ALREADY_DOWNLOADED, "DMUS_E_ALREADY_DOWNLOADED")
        CHK_ERR(DMUS_E_UNKNOWN_PROPERTY, "DMUS_E_UNKNOWN_PROPERTY")
        CHK_ERR(DMUS_E_SET_UNSUPPORTED, "DMUS_E_SET_UNSUPPORTED")
        CHK_ERR(DMUS_E_GET_UNSUPPORTED, "DMUS_E_GET_UNSUPPORTED")
        CHK_ERR(DMUS_E_NOTMONO, "DMUS_E_NOTMONO")
        CHK_ERR(DMUS_E_BADARTICULATION, "DMUS_E_BADARTICULATION")
        CHK_ERR(DMUS_E_BADINSTRUMENT, "DMUS_E_BADINSTRUMENT")
        CHK_ERR(DMUS_E_BADWAVELINK, "DMUS_E_BADWAVELINK")
        CHK_ERR(DMUS_E_NOARTICULATION, "DMUS_E_NOARTICULATION")
        CHK_ERR(DMUS_E_NOTPCM, "DMUS_E_NOTPCM")
        CHK_ERR(DMUS_E_BADWAVE, "DMUS_E_BADWAVE")
        CHK_ERR(DMUS_E_BADOFFSETTABLE, "DMUS_E_BADOFFSETTABLE")
        CHK_ERR(DMUS_E_UNKNOWNDOWNLOAD, "DMUS_E_UNKNOWNDOWNLOAD")
        CHK_ERR(DMUS_E_NOSYNTHSINK, "DMUS_E_NOSYNTHSINK")
        CHK_ERR(DMUS_E_ALREADYOPEN, "DMUS_E_ALREADYOPEN")
        CHK_ERR(DMUS_E_ALREADYCLOSED, "DMUS_E_ALREADYCLOSED")
        CHK_ERR(DMUS_E_SYNTHNOTCONFIGURED, "DMUS_E_SYNTHNOTCONFIGURED")
        CHK_ERR(DMUS_E_SYNTHACTIVE, "DMUS_E_SYNTHACTIVE")
        CHK_ERR(DMUS_E_CANNOTREAD, "DMUS_E_CANNOTREAD")
        CHK_ERR(DMUS_E_DMUSIC_RELEASED, "DMUS_E_DMUSIC_RELEASED")
        CHK_ERR(DMUS_E_BUFFER_EMPTY, "DMUS_E_BUFFER_EMPTY")
        CHK_ERR(DMUS_E_BUFFER_FULL, "DMUS_E_BUFFER_FULL")
        CHK_ERR(DMUS_E_PORT_NOT_CAPTURE, "DMUS_E_PORT_NOT_CAPTURE")
        CHK_ERR(DMUS_E_PORT_NOT_RENDER, "DMUS_E_PORT_NOT_RENDER")
        CHK_ERR(DMUS_E_DSOUND_NOT_SET, "DMUS_E_DSOUND_NOT_SET")
        CHK_ERR(DMUS_E_ALREADY_ACTIVATED, "DMUS_E_ALREADY_ACTIVATED")
        CHK_ERR(DMUS_E_INVALIDBUFFER, "DMUS_E_INVALIDBUFFER")
        CHK_ERR(DMUS_E_WAVEFORMATNOTSUPPORTED, "DMUS_E_WAVEFORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_SYNTHINACTIVE, "DMUS_E_SYNTHINACTIVE")
        CHK_ERR(DMUS_E_DSOUND_ALREADY_SET, "DMUS_E_DSOUND_ALREADY_SET")
        CHK_ERR(DMUS_E_INVALID_EVENT, "DMUS_E_INVALID_EVENT")
        CHK_ERR(DMUS_E_UNSUPPORTED_STREAM, "DMUS_E_UNSUPPORTED_STREAM")
        CHK_ERR(DMUS_E_ALREADY_INITED, "DMUS_E_ALREADY_INITED")
        CHK_ERR(DMUS_E_INVALID_BAND, "DMUS_E_INVALID_BAND")
        CHK_ERR(DMUS_E_TRACK_HDR_NOT_FIRST_CK, "DMUS_E_TRACK_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_TOOL_HDR_NOT_FIRST_CK, "DMUS_E_TOOL_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_INVALID_TRACK_HDR, "DMUS_E_INVALID_TRACK_HDR")
        CHK_ERR(DMUS_E_INVALID_TOOL_HDR, "DMUS_E_INVALID_TOOL_HDR")
        CHK_ERR(DMUS_E_ALL_TOOLS_FAILED, "DMUS_E_ALL_TOOLS_FAILED")
        CHK_ERR(DMUS_E_ALL_TRACKS_FAILED, "DMUS_E_ALL_TRACKS_FAILED")
        CHK_ERR(DMUS_E_NOT_FOUND, "DMUS_E_NOT_FOUND")
        CHK_ERR(DMUS_E_NOT_INIT, "DMUS_E_NOT_INIT")
        CHK_ERR(DMUS_E_TYPE_DISABLED, "DMUS_E_TYPE_DISABLED")
        CHK_ERR(DMUS_E_TYPE_UNSUPPORTED, "DMUS_E_TYPE_UNSUPPORTED")
        CHK_ERR(DMUS_E_TIME_PAST, "DMUS_E_TIME_PAST")
        CHK_ERR(DMUS_E_TRACK_NOT_FOUND, "DMUS_E_TRACK_NOT_FOUND")
        CHK_ERR(DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT, "DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT")
        CHK_ERR(DMUS_E_NO_MASTER_CLOCK, "DMUS_E_NO_MASTER_CLOCK")
        CHK_ERR(DMUS_E_LOADER_NOCLASSID, "DMUS_E_LOADER_NOCLASSID")
        CHK_ERR(DMUS_E_LOADER_BADPATH, "DMUS_E_LOADER_BADPATH")
        CHK_ERR(DMUS_E_LOADER_FAILEDOPEN, "DMUS_E_LOADER_FAILEDOPEN")
        CHK_ERR(DMUS_E_LOADER_FORMATNOTSUPPORTED, "DMUS_E_LOADER_FORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_LOADER_FAILEDCREATE, "DMUS_E_LOADER_FAILEDCREATE")
        CHK_ERR(DMUS_E_LOADER_OBJECTNOTFOUND, "DMUS_E_LOADER_OBJECTNOTFOUND")
        CHK_ERR(DMUS_E_LOADER_NOFILENAME, "DMUS_E_LOADER_NOFILENAME")
        CHK_ERR(DMUS_E_INVALIDFILE, "DMUS_E_INVALIDFILE")
        CHK_ERR(DMUS_E_ALREADY_EXISTS, "DMUS_E_ALREADY_EXISTS")
        CHK_ERR(DMUS_E_OUT_OF_RANGE, "DMUS_E_OUT_OF_RANGE")
        CHK_ERR(DMUS_E_SEGMENT_INIT_FAILED, "DMUS_E_SEGMENT_INIT_FAILED")
        CHK_ERR(DMUS_E_ALREADY_SENT, "DMUS_E_ALREADY_SENT")
        CHK_ERR(DMUS_E_CANNOT_FREE, "DMUS_E_CANNOT_FREE")
        CHK_ERR(DMUS_E_CANNOT_OPEN_PORT, "DMUS_E_CANNOT_OPEN_PORT")
        CHK_ERR(DMUS_E_CANNOT_CONVERT, "DMUS_E_CANNOT_CONVERT")
        CHK_ERR(DMUS_E_DESCEND_CHUNK_FAIL, "DMUS_E_DESCEND_CHUNK_FAIL")
        CHK_ERR(DMUS_E_NOT_LOADED, "DMUS_E_NOT_LOADED")
        CHK_ERR(DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE, "DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE")
        CHK_ERR(DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE, "DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE")
        CHK_ERR(DMUS_E_SCRIPT_ERROR_IN_SCRIPT, "DMUS_E_SCRIPT_ERROR_IN_SCRIPT")
        CHK_ERR(DMUS_E_SCRIPT_CANTLOAD_OLEAUT32, "DMUS_E_SCRIPT_CANTLOAD_OLEAUT32")
        CHK_ERR(DMUS_E_SCRIPT_LOADSCRIPT_ERROR, "DMUS_E_SCRIPT_LOADSCRIPT_ERROR")
        CHK_ERR(DMUS_E_SCRIPT_INVALID_FILE, "DMUS_E_SCRIPT_INVALID_FILE")
        CHK_ERR(DMUS_E_INVALID_SCRIPTTRACK, "DMUS_E_INVALID_SCRIPTTRACK")
        CHK_ERR(DMUS_E_SCRIPT_VARIABLE_NOT_FOUND, "DMUS_E_SCRIPT_VARIABLE_NOT_FOUND")
        CHK_ERR(DMUS_E_SCRIPT_ROUTINE_NOT_FOUND, "DMUS_E_SCRIPT_ROUTINE_NOT_FOUND")
        CHK_ERR(DMUS_E_INVALID_SEGMENTTRIGGERTRACK, "DMUS_E_INVALID_SEGMENTTRIGGERTRACK")
        CHK_ERR(DMUS_E_INVALID_LYRICSTRACK, "DMUS_E_INVALID_LYRICSTRACK")
        CHK_ERR(DMUS_E_INVALID_PARAMCONTROLTRACK, "DMUS_E_INVALID_PARAMCONTROLTRACK")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR, "DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR, "DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE, "DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE")
        CHK_ERR(DMUS_E_AUDIOPATHS_NOT_VALID, "DMUS_E_AUDIOPATHS_NOT_VALID")
        CHK_ERR(DMUS_E_AUDIOPATHS_IN_USE, "DMUS_E_AUDIOPATHS_IN_USE")
        CHK_ERR(DMUS_E_NO_AUDIOPATH_CONFIG, "DMUS_E_NO_AUDIOPATH_CONFIG")
        CHK_ERR(DMUS_E_AUDIOPATH_INACTIVE, "DMUS_E_AUDIOPATH_INACTIVE")
        CHK_ERR(DMUS_E_AUDIOPATH_NOBUFFER, "DMUS_E_AUDIOPATH_NOBUFFER")
        CHK_ERR(DMUS_E_AUDIOPATH_NOPORT, "DMUS_E_AUDIOPATH_NOPORT")
        CHK_ERR(DMUS_E_NO_AUDIOPATH, "DMUS_E_NO_AUDIOPATH")
        CHK_ERR(DMUS_E_INVALIDCHUNK, "DMUS_E_INVALIDCHUNK")      
        CHK_ERR(DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER, "DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER")
        CHK_ERR(DMUS_E_INVALID_CONTAINER_OBJECT, "DMUS_E_INVALID_CONTAINER_OBJECT")    

        /* NO APPMAN SUPPORT FOR NOW
        CHK_ERR(APPMAN_E_NOTINITIALIZED, "APPMAN_E_NOTINITIALIZED")
        CHK_ERR(APPMAN_E_INVALIDPROPERTYSIZE, "APPMAN_E_INVALIDPROPERTYSIZE")
        CHK_ERR(APPMAN_E_INVALIDDATA, "APPMAN_E_INVALIDDATA")
        CHK_ERR(APPMAN_E_INVALIDPROPERTY, "APPMAN_E_INVALIDPROPERTY")
        CHK_ERR(APPMAN_E_READONLYPROPERTY, "APPMAN_E_READONLYPROPERTY")
        CHK_ERR(APPMAN_E_PROPERTYNOTSET, "APPMAN_E_PROPERTYNOTSET")
        CHK_ERR(APPMAN_E_OVERFLOW, "APPMAN_E_OVERFLOW")
        CHK_ERR(APPMAN_E_INVALIDPROPERTYVALUE, "APPMAN_E_INVALIDPROPERTYVALUE")
        CHK_ERR(APPMAN_E_ACTIONINPROGRESS, "APPMAN_E_ACTIONINPROGRESS")
        CHK_ERR(APPMAN_E_ACTIONNOTINITIALIZED, "APPMAN_E_ACTIONNOTINITIALIZED")
        CHK_ERR(APPMAN_E_REQUIREDPROPERTIESMISSING, "APPMAN_E_REQUIREDPROPERTIESMISSING")
        CHK_ERR(APPMAN_E_APPLICATIONALREADYEXISTS, "APPMAN_E_APPLICATIONALREADYEXISTS")
        CHK_ERR(APPMAN_E_APPLICATIONALREADYLOCKED, "APPMAN_E_APPLICATIONALREADYLOCKED")
        CHK_ERR(APPMAN_E_NODISKSPACEAVAILABLE, "APPMAN_E_NODISKSPACEAVAILABLE")
        CHK_ERR(APPMAN_E_UNKNOWNAPPLICATION, "APPMAN_E_UNKNOWNAPPLICATION")
        CHK_ERR(APPMAN_E_INVALIDPARAMETERS, "APPMAN_E_INVALIDPARAMETERS")
        CHK_ERR(APPMAN_E_OBJECTLOCKED, "APPMAN_E_OBJECTLOCKED")
        CHK_ERR(APPMAN_E_INVALIDINDEX, "APPMAN_E_INVALIDINDEX")
        CHK_ERR(APPMAN_E_REGISTRYCORRUPT, "APPMAN_E_REGISTRYCORRUPT")
        CHK_ERR(APPMAN_E_CANNOTASSOCIATE, "APPMAN_E_CANNOTASSOCIATE")
        CHK_ERR(APPMAN_E_INVALIDASSOCIATION, "APPMAN_E_INVALIDASSOCIATION")
        CHK_ERR(APPMAN_E_ALREADYASSOCIATED, "APPMAN_E_ALREADYASSOCIATED")
        CHK_ERR(APPMAN_E_APPLICATIONREQUIRED, "APPMAN_E_APPLICATIONREQUIRED")
        CHK_ERR(APPMAN_E_INVALIDEXECUTECMDLINE, "APPMAN_E_INVALIDEXECUTECMDLINE")
        CHK_ERR(APPMAN_E_INVALIDDOWNSIZECMDLINE, "APPMAN_E_INVALIDDOWNSIZECMDLINE")
        CHK_ERR(APPMAN_E_INVALIDREINSTALLCMDLINE, "APPMAN_E_INVALIDREINSTALLCMDLINE")
        CHK_ERR(APPMAN_E_INVALIDUNINSTALLCMDLINE, "APPMAN_E_INVALIDUNINSTALLCMDLINE")
        CHK_ERR(APPMAN_E_INVALIDSELFTESTCMDLINE, "APPMAN_E_INVALIDSELFTESTCMDLINE")
        CHK_ERR(APPMAN_E_PARENTAPPNOTREADY, "APPMAN_E_PARENTAPPNOTREADY")
        CHK_ERR(APPMAN_E_INVALIDSTATE, "APPMAN_E_INVALIDSTATE")
        CHK_ERR(APPMAN_E_INVALIDROOTPATH, "APPMAN_E_INVALIDROOTPATH")
        CHK_ERR(APPMAN_E_CACHEOVERRUN, "APPMAN_E_CACHEOVERRUN")
        CHK_ERR(APPMAN_E_REINSTALLDX, "APPMAN_E_REINSTALLDX")
        */
   }
   
   return "Unknown";
}

















/****************************************************/
/* DXGetErrorString8W                               */
/*                                                  */
/****************************************************/
const WCHAR * __stdcall DXGetErrorString8W(HRESULT hr)
{
   switch(hr)
   {             
        // Common Win32 error codes
        CHK_ERR(S_OK, L"S_OK")
        CHK_ERR(S_FALSE, L"S_FALSE")

        CHK_ERR(E_UNEXPECTED, L"E_UNEXPECTED")
        CHK_ERR(E_NOTIMPL, L"E_NOTIMPL")
        CHK_ERR(E_OUTOFMEMORY, L"E_OUTOFMEMORY")
        CHK_ERR(E_INVALIDARG, L"E_INVALIDARG")
        CHK_ERR(E_NOINTERFACE, L"E_NOINTERFACE")
        CHK_ERR(E_POINTER, L"E_POINTER")
        CHK_ERR(E_HANDLE, L"E_HANDLE")
        CHK_ERR(E_ABORT, L"E_ABORT")
        CHK_ERR(E_FAIL, L"E_FAIL")
        CHK_ERR(E_ACCESSDENIED, L"E_ACCESSDENIED")
        CHK_ERR(E_PENDING, L"E_PENDING")
        CHK_ERR(REGDB_E_CLASSNOTREG, L"REGDB_E_CLASSNOTREG")
        CHK_ERR(CO_E_NOTINITIALIZED, L"CO_E_NOTINITIALIZED")
        CHK_ERR(CO_E_ALREADYINITIALIZED, L"CO_E_ALREADYINITIALIZED")

//      CHK_ERR(DIERR_GENERIC, L"E_FAIL")
        CHK_ERR(DIERR_NOAGGREGATION, L"E_NOAGGREGATION")
        CHK_ERR(DIERR_INSUFFICIENTPRIVS, L"DIERR_INSUFFICIENTPRIVS")
        CHK_ERR(DIERR_DEVICEFULL, L"DIERR_DEVICEFULL")
        CHK_ERR(DIERR_MOREDATA, L"DIERR_MOREDATA")
        CHK_ERR(DIERR_NOTDOWNLOADED, L"DIERR_NOTDOWNLOADED")
        CHK_ERR(DIERR_HASEFFECTS, L"DIERR_HASEFFECTS")
        CHK_ERR(DIERR_NOTEXCLUSIVEACQUIRED, L"DIERR_NOTEXCLUSIVEACQUIRED")
        CHK_ERR(DIERR_INCOMPLETEEFFECT, L"DIERR_INCOMPLETEEFFECT")
        CHK_ERR(DIERR_NOTBUFFERED, L"DIERR_NOTBUFFERED")
        CHK_ERR(DIERR_EFFECTPLAYING, L"DIERR_EFFECTPLAYING")
        CHK_ERR(DIERR_UNPLUGGED, L"DIERR_UNPLUGGED")
        CHK_ERR(DIERR_REPORTFULL, L"DIERR_REPORTFULL")
        CHK_ERR(DIERR_DRIVERFIRST, L"DIERR_DRIVERFIRST")
        CHK_ERR(DIERR_DRIVERLAST, L"DIERR_DRIVERLAST")
        CHK_ERR(DIERR_INVALIDCLASSINSTALLER, L"DIERR_INVALIDCLASSINSTALLER")
        CHK_ERR(DIERR_CANCELLED, L"DIERR_CANCELLED")
        CHK_ERR(DIERR_BADINF, L"DIERR_BADINF")
        CHK_ERR(DIERR_NOTFOUND, L"DIERR_NOTFOUND or DIERR_NOTFOUND")
//      CHK_ERR(DIERR_READONLY, L"DIERR_READONLY or DIERR_OTHERAPPHASPRIO or DIERR_HANDLEEXISTS or DSERR_ACCESSDENIED")
        CHK_ERR(DIERR_NOTACQUIRED, L"DIERR_NOTACQUIRED")
//      CHK_ERR(DIERR_OUTOFMEMORY, L"E_OUTOFMEMORY")
        CHK_ERR(DIERR_NOTINITIALIZED, L"DIERR_NOTINITIALIZED")
        CHK_ERR(DIERR_INPUTLOST, L"DIERR_INPUTLOST")
        CHK_ERR(DIERR_BADDRIVERVER, L"DIERR_BADDRIVERVER")
        CHK_ERR(DIERR_ACQUIRED, L"DIERR_ACQUIRED")
        CHK_ERR(DIERR_NOMOREITEMS, L"DIERR_NOMOREITEMS")
        CHK_ERR(DIERR_OLDDIRECTINPUTVERSION, L"DIERR_OLDDIRECTINPUTVERSION")
        CHK_ERR(DIERR_BETADIRECTINPUTVERSION, L"DIERR_BETADIRECTINPUTVERSION")
        CHK_ERR(DIERR_ALREADYINITIALIZED, L"DIERR_ALREADYINITIALIZED")
                
        CHK_ERR(DVERR_BUFFERTOOSMALL, L"DVERR_BUFFERTOOSMALL")
        CHK_ERR(DVERR_EXCEPTION, L"DVERR_EXCEPTION")
        CHK_ERR(DVERR_INVALIDFLAGS, L"DVERR_INVALIDFLAGS")
        CHK_ERR(DVERR_INVALIDOBJECT, L"DVERR_INVALIDOBJECT")
        CHK_ERR(DVERR_INVALIDPLAYER, L"DVERR_INVALIDPLAYER")
        CHK_ERR(DVERR_INVALIDGROUP, L"DVERR_INVALIDGROUP")
        CHK_ERR(DVERR_INVALIDHANDLE, L"DVERR_INVALIDHANDLE")
        CHK_ERR(DVERR_SESSIONLOST, L"DVERR_SESSIONLOST")
        CHK_ERR(DVERR_NOVOICESESSION, L"DVERR_NOVOICESESSION")
        CHK_ERR(DVERR_CONNECTIONLOST, L"DVERR_CONNECTIONLOST")
        CHK_ERR(DVERR_NOTINITIALIZED, L"DVERR_NOTINITIALIZED")
        CHK_ERR(DVERR_CONNECTED, L"DVERR_CONNECTED")
        CHK_ERR(DVERR_NOTCONNECTED, L"DVERR_NOTCONNECTED")
        CHK_ERR(DVERR_CONNECTABORTING, L"DVERR_CONNECTABORTING")
        CHK_ERR(DVERR_NOTALLOWED, L"DVERR_NOTALLOWED")
        CHK_ERR(DVERR_INVALIDTARGET, L"DVERR_INVALIDTARGET")
        CHK_ERR(DVERR_TRANSPORTNOTHOST, L"DVERR_TRANSPORTNOTHOST")
        CHK_ERR(DVERR_COMPRESSIONNOTSUPPORTED, L"DVERR_COMPRESSIONNOTSUPPORTED")
        CHK_ERR(DVERR_ALREADYPENDING, L"DVERR_ALREADYPENDING")
        CHK_ERR(DVERR_SOUNDINITFAILURE, L"DVERR_SOUNDINITFAILURE")
        CHK_ERR(DVERR_TIMEOUT, L"DVERR_TIMEOUT")
        CHK_ERR(DVERR_CONNECTABORTED, L"DVERR_CONNECTABORTED")
        CHK_ERR(DVERR_NO3DSOUND, L"DVERR_NO3DSOUND")
        CHK_ERR(DVERR_ALREADYBUFFERED, L"DVERR_ALREADYBUFFERED")
        CHK_ERR(DVERR_NOTBUFFERED, L"DVERR_NOTBUFFERED")
        CHK_ERR(DVERR_HOSTING, L"DVERR_HOSTING")
        CHK_ERR(DVERR_NOTHOSTING, L"DVERR_NOTHOSTING")
        CHK_ERR(DVERR_INVALIDDEVICE, L"DVERR_INVALIDDEVICE")
        CHK_ERR(DVERR_RECORDSYSTEMERROR, L"DVERR_RECORDSYSTEMERROR")
        CHK_ERR(DVERR_PLAYBACKSYSTEMERROR, L"DVERR_PLAYBACKSYSTEMERROR")
        CHK_ERR(DVERR_SENDERROR, L"DVERR_SENDERROR")
        CHK_ERR(DVERR_USERCANCEL, L"DVERR_USERCANCEL")
        CHK_ERR(DVERR_RUNSETUP, L"DVERR_RUNSETUP")
        CHK_ERR(DVERR_INCOMPATIBLEVERSION, L"DVERR_INCOMPATIBLEVERSION")
        CHK_ERR(DVERR_INITIALIZED, L"DVERR_INITIALIZED")
        CHK_ERR(DVERR_NOTRANSPORT, L"DVERR_NOTRANSPORT")
        CHK_ERR(DVERR_NOCALLBACK, L"DVERR_NOCALLBACK")
        CHK_ERR(DVERR_TRANSPORTNOTINIT, L"DVERR_TRANSPORTNOTINIT")
        CHK_ERR(DVERR_TRANSPORTNOSESSION, L"DVERR_TRANSPORTNOSESSION")
        CHK_ERR(DVERR_TRANSPORTNOPLAYER, L"DVERR_TRANSPORTNOPLAYER")
        CHK_ERR(DVERR_USERBACK, L"DVERR_USERBACK")
        CHK_ERR(DVERR_NORECVOLAVAILABLE, L"DVERR_NORECVOLAVAILABLE")
        
        CHK_ERR(DPNERR_ABORTED, L"DPNERR_ABORTED")
        CHK_ERR(DPNERR_ADDRESSING, L"DPNERR_ADDRESSING")
        CHK_ERR(DPNERR_ALREADYCONNECTED, L"DPNERR_ALREADYCONNECTED")
        CHK_ERR(DPNERR_ALREADYDISCONNECTING, L"DPNERR_ALREADYDISCONNECTING")
        CHK_ERR(DPNERR_ALREADYINITIALIZED, L"DPNERR_ALREADYINITIALIZED")
        CHK_ERR(DPNERR_ALREADYREGISTERED, L"DPNERR_ALREADYREGISTERED")
        CHK_ERR(DPNERR_BUFFERTOOSMALL, L"DPNERR_BUFFERTOOSMALL")
        CHK_ERR(DPNERR_CANNOTCANCEL, L"DPNERR_CANNOTCANCEL")
        CHK_ERR(DPNERR_CANTCREATEGROUP, L"DPNERR_CANTCREATEGROUP")
        CHK_ERR(DPNERR_CANTCREATEPLAYER, L"DPNERR_CANTCREATEPLAYER")
        CHK_ERR(DPNERR_CANTLAUNCHAPPLICATION, L"DPNERR_CANTLAUNCHAPPLICATION")
        CHK_ERR(DPNERR_CONNECTING, L"DPNERR_CONNECTING")
        CHK_ERR(DPNERR_CONNECTIONLOST, L"DPNERR_CONNECTIONLOST")
        CHK_ERR(DPNERR_CONVERSION, L"DPNERR_CONVERSION")
        CHK_ERR(DPNERR_DOESNOTEXIST, L"DPNERR_DOESNOTEXIST")
        CHK_ERR(DPNERR_DUPLICATECOMMAND, L"DPNERR_DUPLICATECOMMAND")
        CHK_ERR(DPNERR_ENDPOINTNOTRECEIVING, L"DPNERR_ENDPOINTNOTRECEIVING")
        CHK_ERR(DPNERR_EXCEPTION, L"DPNERR_EXCEPTION")
        CHK_ERR(DPNERR_GROUPNOTEMPTY, L"DPNERR_GROUPNOTEMPTY")
        CHK_ERR(DPNERR_HOSTING, L"DPNERR_HOSTING")
        CHK_ERR(DPNERR_HOSTREJECTEDCONNECTION, L"DPNERR_HOSTREJECTEDCONNECTION")
        CHK_ERR(DPNERR_INCOMPLETEADDRESS, L"DPNERR_INCOMPLETEADDRESS")
        CHK_ERR(DPNERR_INVALIDADDRESSFORMAT, L"DPNERR_INVALIDADDRESSFORMAT")
        CHK_ERR(DPNERR_INVALIDAPPLICATION, L"DPNERR_INVALIDAPPLICATION")
        CHK_ERR(DPNERR_INVALIDCOMMAND, L"DPNERR_INVALIDCOMMAND")
        CHK_ERR(DPNERR_INVALIDENDPOINT, L"DPNERR_INVALIDENDPOINT")
        CHK_ERR(DPNERR_INVALIDFLAGS, L"DPNERR_INVALIDFLAGS")
        CHK_ERR(DPNERR_INVALIDGROUP, L"DPNERR_INVALIDGROUP")
        CHK_ERR(DPNERR_INVALIDHANDLE, L"DPNERR_INVALIDHANDLE")
        CHK_ERR(DPNERR_INVALIDINSTANCE, L"DPNERR_INVALIDINSTANCE")
        CHK_ERR(DPNERR_INVALIDINTERFACE, L"DPNERR_INVALIDINTERFACE")
        CHK_ERR(DPNERR_INVALIDDEVICEADDRESS, L"DPNERR_INVALIDDEVICEADDRESS")
        CHK_ERR(DPNERR_INVALIDOBJECT, L"DPNERR_INVALIDOBJECT")
        CHK_ERR(DPNERR_INVALIDPASSWORD, L"DPNERR_INVALIDPASSWORD")
        CHK_ERR(DPNERR_INVALIDPLAYER, L"DPNERR_INVALIDPLAYER")
        CHK_ERR(DPNERR_INVALIDPRIORITY, L"DPNERR_INVALIDPRIORITY")
        CHK_ERR(DPNERR_INVALIDHOSTADDRESS, L"DPNERR_INVALIDHOSTADDRESS")
        CHK_ERR(DPNERR_INVALIDSTRING, L"DPNERR_INVALIDSTRING")
        CHK_ERR(DPNERR_INVALIDURL, L"DPNERR_INVALIDURL")
        CHK_ERR(DPNERR_NOCAPS, L"DPNERR_NOCAPS")
        CHK_ERR(DPNERR_NOCONNECTION, L"DPNERR_NOCONNECTION")
        CHK_ERR(DPNERR_NOHOSTPLAYER, L"DPNERR_NOHOSTPLAYER")
        CHK_ERR(DPNERR_NOMOREADDRESSCOMPONENTS, L"DPNERR_NOMOREADDRESSCOMPONENTS")
        CHK_ERR(DPNERR_NORESPONSE, L"DPNERR_NORESPONSE")
        CHK_ERR(DPNERR_NOTALLOWED, L"DPNERR_NOTALLOWED")
        CHK_ERR(DPNERR_NOTHOST, L"DPNERR_NOTHOST")
        CHK_ERR(DPNERR_NOTREADY, L"DPNERR_NOTREADY")
        CHK_ERR(DPNERR_NOTREGISTERED, L"DPNERR_NOTREGISTERED")
        CHK_ERR(DPNERR_PLAYERLOST, L"DPNERR_PLAYERLOST")
        CHK_ERR(DPNERR_SENDTOOLARGE, L"DPNERR_SENDTOOLARGE")
        CHK_ERR(DPNERR_SESSIONFULL, L"DPNERR_SESSIONFULL")
        CHK_ERR(DPNERR_TABLEFULL, L"DPNERR_TABLEFULL")
        CHK_ERR(DPNERR_TIMEDOUT, L"DPNERR_TIMEDOUT")
        CHK_ERR(DPNERR_UNINITIALIZED, L"DPNERR_UNINITIALIZED")
        CHK_ERR(DPNERR_USERCANCEL, L"DPNERR_USERCANCEL")
        
        CHK_ERR(DXFILEERR_BADOBJECT, L"DXFILEERR_BADOBJECT")
        CHK_ERR(DXFILEERR_BADVALUE, L"DXFILEERR_BADVALUE")
        CHK_ERR(DXFILEERR_BADTYPE, L"DXFILEERR_BADTYPE")
        CHK_ERR(DXFILEERR_BADSTREAMHANDLE, L"DXFILEERR_BADSTREAMHANDLE")
        CHK_ERR(DXFILEERR_BADALLOC, L"DXFILEERR_BADALLOC")
        CHK_ERR(DXFILEERR_NOTFOUND, L"DXFILEERR_NOTFOUND")
        CHK_ERR(DXFILEERR_NOTDONEYET, L"DXFILEERR_NOTDONEYET")
        CHK_ERR(DXFILEERR_FILENOTFOUND, L"DXFILEERR_FILENOTFOUND")
        CHK_ERR(DXFILEERR_RESOURCENOTFOUND, L"DXFILEERR_RESOURCENOTFOUND")
        CHK_ERR(DXFILEERR_URLNOTFOUND, L"DXFILEERR_URLNOTFOUND")
        CHK_ERR(DXFILEERR_BADRESOURCE, L"DXFILEERR_BADRESOURCE")
        CHK_ERR(DXFILEERR_BADFILETYPE, L"DXFILEERR_BADFILETYPE")
        CHK_ERR(DXFILEERR_BADFILEVERSION, L"DXFILEERR_BADFILEVERSION")
        CHK_ERR(DXFILEERR_BADFILEFLOATSIZE, L"DXFILEERR_BADFILEFLOATSIZE")
        CHK_ERR(DXFILEERR_BADFILECOMPRESSIONTYPE, L"DXFILEERR_BADFILECOMPRESSIONTYPE")
        CHK_ERR(DXFILEERR_BADFILE, L"DXFILEERR_BADFILE")
        CHK_ERR(DXFILEERR_PARSEERROR, L"DXFILEERR_PARSEERROR")
        CHK_ERR(DXFILEERR_NOTEMPLATE, L"DXFILEERR_NOTEMPLATE")
        CHK_ERR(DXFILEERR_BADARRAYSIZE, L"DXFILEERR_BADARRAYSIZE")
        CHK_ERR(DXFILEERR_BADDATAREFERENCE, L"DXFILEERR_BADDATAREFERENCE")
        CHK_ERR(DXFILEERR_INTERNALERROR, L"DXFILEERR_INTERNALERROR")
        CHK_ERR(DXFILEERR_NOMOREOBJECTS, L"DXFILEERR_NOMOREOBJECTS")
        CHK_ERR(DXFILEERR_BADINTRINSICS, L"DXFILEERR_BADINTRINSICS")
        CHK_ERR(DXFILEERR_NOMORESTREAMHANDLES, L"DXFILEERR_NOMORESTREAMHANDLES")
        CHK_ERR(DXFILEERR_NOMOREDATA, L"DXFILEERR_NOMOREDATA")
        CHK_ERR(DXFILEERR_BADCACHEFILE, L"DXFILEERR_BADCACHEFILE")
        CHK_ERR(DXFILEERR_NOINTERNET, L"DXFILEERR_NOINTERNET")

        CHK_ERR(D3DERR_OUTOFVIDEOMEMORY, L"D3DERR_OUTOFVIDEOMEMORY")
        CHK_ERR(D3DERR_WRONGTEXTUREFORMAT, L"D3DERR_WRONGTEXTUREFORMAT")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLOROPERATION, L"D3DERR_UNSUPPORTEDCOLOROPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDCOLORARG, L"D3DERR_UNSUPPORTEDCOLORARG")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAOPERATION, L"D3DERR_UNSUPPORTEDALPHAOPERATION")
        CHK_ERR(D3DERR_UNSUPPORTEDALPHAARG, L"D3DERR_UNSUPPORTEDALPHAARG")
        CHK_ERR(D3DERR_TOOMANYOPERATIONS, L"D3DERR_TOOMANYOPERATIONS")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREFILTER, L"D3DERR_CONFLICTINGTEXTUREFILTER")
        CHK_ERR(D3DERR_UNSUPPORTEDFACTORVALUE, L"D3DERR_UNSUPPORTEDFACTORVALUE")
        CHK_ERR(D3DERR_CONFLICTINGRENDERSTATE, L"D3DERR_CONFLICTINGRENDERSTATE")
        CHK_ERR(D3DERR_UNSUPPORTEDTEXTUREFILTER, L"D3DERR_UNSUPPORTEDTEXTUREFILTER")
        CHK_ERR(D3DERR_CONFLICTINGTEXTUREPALETTE, L"D3DERR_CONFLICTINGTEXTUREPALETTE")
        CHK_ERR(D3DERR_DRIVERINTERNALERROR, L"D3DERR_DRIVERINTERNALERROR")
        CHK_ERR(D3DERR_NOTFOUND, L"D3DERR_NOTFOUND")
        CHK_ERR(D3DERR_MOREDATA, L"D3DERR_MOREDATA")
        CHK_ERR(D3DERR_DEVICELOST, L"D3DERR_DEVICELOST")
        CHK_ERR(D3DERR_DEVICENOTRESET, L"D3DERR_DEVICENOTRESET")
        CHK_ERR(D3DERR_NOTAVAILABLE, L"D3DERR_NOTAVAILABLE")
        CHK_ERR(D3DERR_INVALIDDEVICE, L"D3DERR_INVALIDDEVICE")
        CHK_ERR(D3DERR_INVALIDCALL, L"D3DERR_INVALIDCALL")
        
        CHK_ERR(DSERR_ALLOCATED, L"DSERR_ALLOCATED")
        CHK_ERR(DSERR_CONTROLUNAVAIL, L"DSERR_CONTROLUNAVAIL")
        CHK_ERR(DSERR_INVALIDCALL, L"DSERR_INVALIDCALL")
        CHK_ERR(DSERR_PRIOLEVELNEEDED, L"DSERR_PRIOLEVELNEEDED")
        CHK_ERR(DSERR_BADFORMAT, L"DSERR_BADFORMAT")
        CHK_ERR(DSERR_NODRIVER, L"DSERR_NODRIVER")
        CHK_ERR(DSERR_ALREADYINITIALIZED, L"DSERR_ALREADYINITIALIZED")
        CHK_ERR(DSERR_BUFFERLOST, L"DSERR_BUFFERLOST")
        CHK_ERR(DSERR_OTHERAPPHASPRIO, L"DSERR_OTHERAPPHASPRIO")
        CHK_ERR(DSERR_UNINITIALIZED, L"DSERR_UNINITIALIZED")
        
        CHK_ERR(DMUS_E_DRIVER_FAILED, L"DMUS_E_DRIVER_FAILED")
        CHK_ERR(DMUS_E_PORTS_OPEN, L"DMUS_E_PORTS_OPEN")
        CHK_ERR(DMUS_E_DEVICE_IN_USE, L"DMUS_E_DEVICE_IN_USE")
        CHK_ERR(DMUS_E_INSUFFICIENTBUFFER, L"DMUS_E_INSUFFICIENTBUFFER")
        CHK_ERR(DMUS_E_BUFFERNOTSET, L"DMUS_E_BUFFERNOTSET")
        CHK_ERR(DMUS_E_BUFFERNOTAVAILABLE, L"DMUS_E_BUFFERNOTAVAILABLE")
        CHK_ERR(DMUS_E_NOTADLSCOL, L"DMUS_E_NOTADLSCOL")
        CHK_ERR(DMUS_E_INVALIDOFFSET, L"DMUS_E_INVALIDOFFSET")
        CHK_ERR(DMUS_E_ALREADY_LOADED, L"DMUS_E_ALREADY_LOADED")
        CHK_ERR(DMUS_E_INVALIDPOS, L"DMUS_E_INVALIDPOS")
        CHK_ERR(DMUS_E_INVALIDPATCH, L"DMUS_E_INVALIDPATCH")
        CHK_ERR(DMUS_E_CANNOTSEEK, L"DMUS_E_CANNOTSEEK")
        CHK_ERR(DMUS_E_CANNOTWRITE, L"DMUS_E_CANNOTWRITE")
        CHK_ERR(DMUS_E_CHUNKNOTFOUND, L"DMUS_E_CHUNKNOTFOUND")
        CHK_ERR(DMUS_E_INVALID_DOWNLOADID, L"DMUS_E_INVALID_DOWNLOADID")
        CHK_ERR(DMUS_E_NOT_DOWNLOADED_TO_PORT, L"DMUS_E_NOT_DOWNLOADED_TO_PORT")
        CHK_ERR(DMUS_E_ALREADY_DOWNLOADED, L"DMUS_E_ALREADY_DOWNLOADED")
        CHK_ERR(DMUS_E_UNKNOWN_PROPERTY, L"DMUS_E_UNKNOWN_PROPERTY")
        CHK_ERR(DMUS_E_SET_UNSUPPORTED, L"DMUS_E_SET_UNSUPPORTED")
        CHK_ERR(DMUS_E_GET_UNSUPPORTED, L"DMUS_E_GET_UNSUPPORTED")
        CHK_ERR(DMUS_E_NOTMONO, L"DMUS_E_NOTMONO")
        CHK_ERR(DMUS_E_BADARTICULATION, L"DMUS_E_BADARTICULATION")
        CHK_ERR(DMUS_E_BADINSTRUMENT, L"DMUS_E_BADINSTRUMENT")
        CHK_ERR(DMUS_E_BADWAVELINK, L"DMUS_E_BADWAVELINK")
        CHK_ERR(DMUS_E_NOARTICULATION, L"DMUS_E_NOARTICULATION")
        CHK_ERR(DMUS_E_NOTPCM, L"DMUS_E_NOTPCM")
        CHK_ERR(DMUS_E_BADWAVE, L"DMUS_E_BADWAVE")
        CHK_ERR(DMUS_E_BADOFFSETTABLE, L"DMUS_E_BADOFFSETTABLE")
        CHK_ERR(DMUS_E_UNKNOWNDOWNLOAD, L"DMUS_E_UNKNOWNDOWNLOAD")
        CHK_ERR(DMUS_E_NOSYNTHSINK, L"DMUS_E_NOSYNTHSINK")
        CHK_ERR(DMUS_E_ALREADYOPEN, L"DMUS_E_ALREADYOPEN")
        CHK_ERR(DMUS_E_ALREADYCLOSED, L"DMUS_E_ALREADYCLOSED")
        CHK_ERR(DMUS_E_SYNTHNOTCONFIGURED, L"DMUS_E_SYNTHNOTCONFIGURED")
        CHK_ERR(DMUS_E_SYNTHACTIVE, L"DMUS_E_SYNTHACTIVE")
        CHK_ERR(DMUS_E_CANNOTREAD, L"DMUS_E_CANNOTREAD")
        CHK_ERR(DMUS_E_DMUSIC_RELEASED, L"DMUS_E_DMUSIC_RELEASED")
        CHK_ERR(DMUS_E_BUFFER_EMPTY, L"DMUS_E_BUFFER_EMPTY")
        CHK_ERR(DMUS_E_BUFFER_FULL, L"DMUS_E_BUFFER_FULL")
        CHK_ERR(DMUS_E_PORT_NOT_CAPTURE, L"DMUS_E_PORT_NOT_CAPTURE")
        CHK_ERR(DMUS_E_PORT_NOT_RENDER, L"DMUS_E_PORT_NOT_RENDER")
        CHK_ERR(DMUS_E_DSOUND_NOT_SET, L"DMUS_E_DSOUND_NOT_SET")
        CHK_ERR(DMUS_E_ALREADY_ACTIVATED, L"DMUS_E_ALREADY_ACTIVATED")
        CHK_ERR(DMUS_E_INVALIDBUFFER, L"DMUS_E_INVALIDBUFFER")
        CHK_ERR(DMUS_E_WAVEFORMATNOTSUPPORTED, L"DMUS_E_WAVEFORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_SYNTHINACTIVE, L"DMUS_E_SYNTHINACTIVE")
        CHK_ERR(DMUS_E_DSOUND_ALREADY_SET, L"DMUS_E_DSOUND_ALREADY_SET")
        CHK_ERR(DMUS_E_INVALID_EVENT, L"DMUS_E_INVALID_EVENT")
        CHK_ERR(DMUS_E_UNSUPPORTED_STREAM, L"DMUS_E_UNSUPPORTED_STREAM")
        CHK_ERR(DMUS_E_ALREADY_INITED, L"DMUS_E_ALREADY_INITED")
        CHK_ERR(DMUS_E_INVALID_BAND, L"DMUS_E_INVALID_BAND")
        CHK_ERR(DMUS_E_TRACK_HDR_NOT_FIRST_CK, L"DMUS_E_TRACK_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_TOOL_HDR_NOT_FIRST_CK, L"DMUS_E_TOOL_HDR_NOT_FIRST_CK")
        CHK_ERR(DMUS_E_INVALID_TRACK_HDR, L"DMUS_E_INVALID_TRACK_HDR")
        CHK_ERR(DMUS_E_INVALID_TOOL_HDR, L"DMUS_E_INVALID_TOOL_HDR")
        CHK_ERR(DMUS_E_ALL_TOOLS_FAILED, L"DMUS_E_ALL_TOOLS_FAILED")
        CHK_ERR(DMUS_E_ALL_TRACKS_FAILED, L"DMUS_E_ALL_TRACKS_FAILED")
        CHK_ERR(DMUS_E_NOT_FOUND, L"DMUS_E_NOT_FOUND")
        CHK_ERR(DMUS_E_NOT_INIT, L"DMUS_E_NOT_INIT")
        CHK_ERR(DMUS_E_TYPE_DISABLED, L"DMUS_E_TYPE_DISABLED")
        CHK_ERR(DMUS_E_TYPE_UNSUPPORTED, L"DMUS_E_TYPE_UNSUPPORTED")
        CHK_ERR(DMUS_E_TIME_PAST, L"DMUS_E_TIME_PAST")
        CHK_ERR(DMUS_E_TRACK_NOT_FOUND, L"DMUS_E_TRACK_NOT_FOUND")
        CHK_ERR(DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT, L"DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT")
        CHK_ERR(DMUS_E_NO_MASTER_CLOCK, L"DMUS_E_NO_MASTER_CLOCK")
        CHK_ERR(DMUS_E_LOADER_NOCLASSID, L"DMUS_E_LOADER_NOCLASSID")
        CHK_ERR(DMUS_E_LOADER_BADPATH, L"DMUS_E_LOADER_BADPATH")
        CHK_ERR(DMUS_E_LOADER_FAILEDOPEN, L"DMUS_E_LOADER_FAILEDOPEN")
        CHK_ERR(DMUS_E_LOADER_FORMATNOTSUPPORTED, L"DMUS_E_LOADER_FORMATNOTSUPPORTED")
        CHK_ERR(DMUS_E_LOADER_FAILEDCREATE, L"DMUS_E_LOADER_FAILEDCREATE")
        CHK_ERR(DMUS_E_LOADER_OBJECTNOTFOUND, L"DMUS_E_LOADER_OBJECTNOTFOUND")
        CHK_ERR(DMUS_E_LOADER_NOFILENAME, L"DMUS_E_LOADER_NOFILENAME")
        CHK_ERR(DMUS_E_INVALIDFILE, L"DMUS_E_INVALIDFILE")
        CHK_ERR(DMUS_E_ALREADY_EXISTS, L"DMUS_E_ALREADY_EXISTS")
        CHK_ERR(DMUS_E_OUT_OF_RANGE, L"DMUS_E_OUT_OF_RANGE")
        CHK_ERR(DMUS_E_SEGMENT_INIT_FAILED, L"DMUS_E_SEGMENT_INIT_FAILED")
        CHK_ERR(DMUS_E_ALREADY_SENT, L"DMUS_E_ALREADY_SENT")
        CHK_ERR(DMUS_E_CANNOT_FREE, L"DMUS_E_CANNOT_FREE")
        CHK_ERR(DMUS_E_CANNOT_OPEN_PORT, L"DMUS_E_CANNOT_OPEN_PORT")
        CHK_ERR(DMUS_E_CANNOT_CONVERT, L"DMUS_E_CANNOT_CONVERT")
        CHK_ERR(DMUS_E_DESCEND_CHUNK_FAIL, L"DMUS_E_DESCEND_CHUNK_FAIL")
        CHK_ERR(DMUS_E_NOT_LOADED, L"DMUS_E_NOT_LOADED")
        CHK_ERR(DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE, L"DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE")
        CHK_ERR(DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE, L"DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE")
        CHK_ERR(DMUS_E_SCRIPT_ERROR_IN_SCRIPT, L"DMUS_E_SCRIPT_ERROR_IN_SCRIPT")
        CHK_ERR(DMUS_E_SCRIPT_CANTLOAD_OLEAUT32, L"DMUS_E_SCRIPT_CANTLOAD_OLEAUT32")
        CHK_ERR(DMUS_E_SCRIPT_LOADSCRIPT_ERROR, L"DMUS_E_SCRIPT_LOADSCRIPT_ERROR")
        CHK_ERR(DMUS_E_SCRIPT_INVALID_FILE, L"DMUS_E_SCRIPT_INVALID_FILE")
        CHK_ERR(DMUS_E_INVALID_SCRIPTTRACK, L"DMUS_E_INVALID_SCRIPTTRACK")
        CHK_ERR(DMUS_E_SCRIPT_VARIABLE_NOT_FOUND, L"DMUS_E_SCRIPT_VARIABLE_NOT_FOUND")
        CHK_ERR(DMUS_E_SCRIPT_ROUTINE_NOT_FOUND, L"DMUS_E_SCRIPT_ROUTINE_NOT_FOUND")
        CHK_ERR(DMUS_E_INVALID_SEGMENTTRIGGERTRACK, L"DMUS_E_INVALID_SEGMENTTRIGGERTRACK")
        CHK_ERR(DMUS_E_INVALID_LYRICSTRACK, L"DMUS_E_INVALID_LYRICSTRACK")
        CHK_ERR(DMUS_E_INVALID_PARAMCONTROLTRACK, L"DMUS_E_INVALID_PARAMCONTROLTRACK")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR, L"DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR, L"DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR")
        CHK_ERR(DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE, L"DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE")
        CHK_ERR(DMUS_E_AUDIOPATHS_NOT_VALID, L"DMUS_E_AUDIOPATHS_NOT_VALID")
        CHK_ERR(DMUS_E_AUDIOPATHS_IN_USE, L"DMUS_E_AUDIOPATHS_IN_USE")
        CHK_ERR(DMUS_E_NO_AUDIOPATH_CONFIG, L"DMUS_E_NO_AUDIOPATH_CONFIG")
        CHK_ERR(DMUS_E_AUDIOPATH_INACTIVE, L"DMUS_E_AUDIOPATH_INACTIVE")
        CHK_ERR(DMUS_E_AUDIOPATH_NOBUFFER, L"DMUS_E_AUDIOPATH_NOBUFFER")
        CHK_ERR(DMUS_E_AUDIOPATH_NOPORT, L"DMUS_E_AUDIOPATH_NOPORT")
        CHK_ERR(DMUS_E_NO_AUDIOPATH, L"DMUS_E_NO_AUDIOPATH")
        CHK_ERR(DMUS_E_INVALIDCHUNK, L"DMUS_E_INVALIDCHUNK")      
        CHK_ERR(DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER, L"DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER")
        CHK_ERR(DMUS_E_INVALID_CONTAINER_OBJECT, L"DMUS_E_INVALID_CONTAINER_OBJECT")    

        
        /* APP MAN NOT SUPPORTED
        CHK_ERR(APPMAN_E_NOTINITIALIZED, L"APPMAN_E_NOTINITIALIZED")
        CHK_ERR(APPMAN_E_INVALIDPROPERTYSIZE, L"APPMAN_E_INVALIDPROPERTYSIZE")
        CHK_ERR(APPMAN_E_INVALIDDATA, L"APPMAN_E_INVALIDDATA")
        CHK_ERR(APPMAN_E_INVALIDPROPERTY, L"APPMAN_E_INVALIDPROPERTY")
        CHK_ERR(APPMAN_E_READONLYPROPERTY, L"APPMAN_E_READONLYPROPERTY")
        CHK_ERR(APPMAN_E_PROPERTYNOTSET, L"APPMAN_E_PROPERTYNOTSET")
        CHK_ERR(APPMAN_E_OVERFLOW, L"APPMAN_E_OVERFLOW")
        CHK_ERR(APPMAN_E_INVALIDPROPERTYVALUE, L"APPMAN_E_INVALIDPROPERTYVALUE")
        CHK_ERR(APPMAN_E_ACTIONINPROGRESS, L"APPMAN_E_ACTIONINPROGRESS")
        CHK_ERR(APPMAN_E_ACTIONNOTINITIALIZED, L"APPMAN_E_ACTIONNOTINITIALIZED")
        CHK_ERR(APPMAN_E_REQUIREDPROPERTIESMISSING, L"APPMAN_E_REQUIREDPROPERTIESMISSING")
        CHK_ERR(APPMAN_E_APPLICATIONALREADYEXISTS, L"APPMAN_E_APPLICATIONALREADYEXISTS")
        CHK_ERR(APPMAN_E_APPLICATIONALREADYLOCKED, L"APPMAN_E_APPLICATIONALREADYLOCKED")
        CHK_ERR(APPMAN_E_NODISKSPACEAVAILABLE, L"APPMAN_E_NODISKSPACEAVAILABLE")
        CHK_ERR(APPMAN_E_UNKNOWNAPPLICATION, L"APPMAN_E_UNKNOWNAPPLICATION")
        CHK_ERR(APPMAN_E_INVALIDPARAMETERS, L"APPMAN_E_INVALIDPARAMETERS")
        CHK_ERR(APPMAN_E_OBJECTLOCKED, L"APPMAN_E_OBJECTLOCKED")
        CHK_ERR(APPMAN_E_INVALIDINDEX, L"APPMAN_E_INVALIDINDEX")
        CHK_ERR(APPMAN_E_REGISTRYCORRUPT, L"APPMAN_E_REGISTRYCORRUPT")
        CHK_ERR(APPMAN_E_CANNOTASSOCIATE, L"APPMAN_E_CANNOTASSOCIATE")
        CHK_ERR(APPMAN_E_INVALIDASSOCIATION, L"APPMAN_E_INVALIDASSOCIATION")
        CHK_ERR(APPMAN_E_ALREADYASSOCIATED, L"APPMAN_E_ALREADYASSOCIATED")
        CHK_ERR(APPMAN_E_APPLICATIONREQUIRED, L"APPMAN_E_APPLICATIONREQUIRED")
        CHK_ERR(APPMAN_E_INVALIDEXECUTECMDLINE, L"APPMAN_E_INVALIDEXECUTECMDLINE")
        CHK_ERR(APPMAN_E_INVALIDDOWNSIZECMDLINE, L"APPMAN_E_INVALIDDOWNSIZECMDLINE")
        CHK_ERR(APPMAN_E_INVALIDREINSTALLCMDLINE, L"APPMAN_E_INVALIDREINSTALLCMDLINE")
        CHK_ERR(APPMAN_E_INVALIDUNINSTALLCMDLINE, L"APPMAN_E_INVALIDUNINSTALLCMDLINE")
        CHK_ERR(APPMAN_E_INVALIDSELFTESTCMDLINE, L"APPMAN_E_INVALIDSELFTESTCMDLINE")
        CHK_ERR(APPMAN_E_PARENTAPPNOTREADY, L"APPMAN_E_PARENTAPPNOTREADY")
        CHK_ERR(APPMAN_E_INVALIDSTATE, L"APPMAN_E_INVALIDSTATE")
        CHK_ERR(APPMAN_E_INVALIDROOTPATH, L"APPMAN_E_INVALIDROOTPATH")
        CHK_ERR(APPMAN_E_CACHEOVERRUN, L"APPMAN_E_CACHEOVERRUN")
        CHK_ERR(APPMAN_E_REINSTALLDX, L"APPMAN_E_REINSTALLDX")
        */
    }

    return L"Unknown";
}




//-----------------------------------------------------------------------------
// Name: DXTraceW()
// Desc: Outputs a formatted error message to the debug stream
//-----------------------------------------------------------------------------
HRESULT __stdcall DXTraceW( CHAR* strFile, DWORD dwLine, HRESULT hr, 
                            WCHAR* strMsg, BOOL bPopMsgBox )
{
    WCHAR strLine[50];
    WCHAR strError[200];
    WCHAR strBuffer[BUFFER_SIZE];
        
    swprintf( strLine, L"%ld", dwLine );
            
    if( strFile != NULL )
    {
        if( strlen(strFile) + 200 < BUFFER_SIZE )
        {        
           swprintf( strBuffer, L"%S(%s): ", strFile, strLine );
           OutputDebugStringW( strBuffer );
        }
    }

    if( strMsg != NULL )
        OutputDebugStringW( strMsg );

    swprintf( strError, L"%s (0x%0.8x)", DXGetErrorString8W(hr), hr );
    swprintf( strBuffer, L" (hr=%s)", strError );
    OutputDebugStringW( strBuffer );

    OutputDebugStringW( L"\n" );
    
    if( bPopMsgBox )
    {
        if( wcslen(strMsg) + strlen(strFile) + 
            wcslen(strLine) + wcslen(strError) + 200 < BUFFER_SIZE )
        {
            swprintf( strBuffer, L"File: %S\nLine: %s\nError Code: %s\nCalling: %s", 
                      strFile, strLine, strError, strMsg );
            MessageBoxW( NULL, strBuffer, L"Unexpected error encountered", MB_OK|MB_ICONERROR );
        }                              
    }
    
    return hr;
}




//-----------------------------------------------------------------------------
// Name: DXTraceA()
// Desc: Outputs a formatted error message to the debug stream
//-----------------------------------------------------------------------------
HRESULT __stdcall DXTraceA( char* strFile, DWORD dwLine, HRESULT hr, 
                            char* strMsg, BOOL bPopMsgBox )                 
{
    CHAR strLine[50];
    CHAR strError[200];
    CHAR strBuffer[BUFFER_SIZE];
        
    sprintf( strLine, "%ld", dwLine );
            
    if( strFile != NULL )
    {
        if( strlen(strFile) + 200 < BUFFER_SIZE )
        {
           sprintf( strBuffer, "%s(%s): ", strFile, strLine );
           OutputDebugStringA( strBuffer );
        }
    }

    if( strMsg != NULL )
        OutputDebugStringA( strMsg );

    sprintf( strError, "%s (0x%0.8x)", DXGetErrorString8A(hr), hr );
    sprintf( strBuffer, " (hr=%s)", strError );
    OutputDebugStringA( strBuffer );
    
    OutputDebugStringA( "\n" );
    
    if( bPopMsgBox )
    {
        if( strlen(strMsg) + strlen(strFile) + 
            strlen(strLine) + strlen(strError) + 200 < BUFFER_SIZE )
        {
            sprintf( strBuffer, "File: %s\nLine: %s\nError Code: %s\nCalling: %s", 
                     strFile, strLine, strError, strMsg );
            MessageBoxA( NULL, strBuffer, "Unexpected error encountered", MB_OK|MB_ICONERROR );
        }                              
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\filestrm.h ===
#pragma once

#ifndef __FILESTRM_H_
#define __FILESTRM_H_

/*//////////////////////////////////////////////////////////////////////////////
//
// File: filestrm.h
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 09/23/99 (mikemarr)  - copyright, started history
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include <objidl.h>


class CFileStream : public IStream
{
public: 
    
    CFileStream(LPCTSTR filename, BOOL bReadOnly, BOOL bTruncate, HRESULT *error);
    ~CFileStream();
    
    // IUnknown methods
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR*);
    
    // Implemented IStream methods
    STDMETHODIMP Read(void __RPC_FAR *pv, ULONG cb, ULONG __RPC_FAR *pcbRead);
    STDMETHODIMP Write(const void __RPC_FAR *pv, ULONG cb, ULONG __RPC_FAR *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER __RPC_FAR *plibNewPosition);
    STDMETHODIMP Stat(STATSTG __RPC_FAR *pstatstg, DWORD grfStatFlag);
    
    // Unimplemented IStream methods
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) {return E_NOTIMPL;}
    STDMETHODIMP CopyTo(IStream __RPC_FAR *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER __RPC_FAR *pcbRead, ULARGE_INTEGER __RPC_FAR *pcbWritten) {return E_NOTIMPL;}
    STDMETHODIMP Commit(DWORD grfCommitFlags) {return E_NOTIMPL;}
    STDMETHODIMP Revert(void) {return E_NOTIMPL;}
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {return E_NOTIMPL;}
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) {return E_NOTIMPL;}
    STDMETHODIMP Clone(IStream __RPC_FAR *__RPC_FAR *ppstm) {return E_NOTIMPL;}
    
private:
    
    DWORD m_cRef;
    HANDLE m_hfile;	
    
};

#endif // #ifndef __FILESTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\guids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       guids.cpp
//
//--------------------------------------------------------------------------


#define INITGUID 1
#include "objbase.h"
#include "dmusici.h"
#include "dsound.h"
#include "d3d8.h"
#include "dinput.h"
#include "dvoice.h"
#include "rmxfguid.h"
#include "dplay8.h"
#include "dpaddr.h"
#include "dplobby8.h"
#include "dvoice.h"
#include "d3dx8.h"
//#include "rmxftmpl.h"
#include <dxfile.h>

//BUGBUG TODO this is not a unique guid
DEFINE_GUID(g_GUIDDXVBLOCK, 0x5dd2e8da, 0x1c77, 0x4d40, 0xb0, 0xcf, 0x98, 0xfe, 0xfd, 0xff, 0x95, 0x12);

int pad;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\frmsave.cpp ===
//**************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999 All Rights Reserved.
//
//  File:   frmsave.cpp
//
//  Description:    Save LPDIRECT3DRMFRAME to an x file.
//
//  History:
//      011/06/98    CongpaY     Created
//
//**************************************************************************


#include <d3drm.h>
#include <dxfile.h>
#include <rmxftmpl.h>
#include <rmxfguid.h>
#include "frmsave.h"

extern HINSTANCE g_hInstD3DXOFDLL;

#define MyD3DRMColorGetAlpha(color)  ((float)((color & 0xFF000000)>>24)/(float)255)
#define MyD3DRMColorGetRed(color)  ((float)((color & 0x00FF0000)>>16)/(float)255)
#define MyD3DRMColorGetGreen(color)  ((float)((color & 0x0000FF00)>>8)/(float)255)
#define MyD3DRMColorGetBlue(color)  ((float)((color & 0x000000FF))/(float)255)


HRESULT FrameToXFile(LPDIRECT3DRMFRAME3 pFrame,
                     LPCSTR filename,
                     D3DRMXOFFORMAT d3dFormat,
                     D3DRMSAVEOPTIONS d3dSaveFlags)
{
    Saver saver;
    saver.Init(filename, d3dFormat, d3dSaveFlags);
    saver.SaveHeaderObject();
    saver.SaveFrame(pFrame);
    return S_OK;
}

Saver::Saver()
  : pXFile(NULL),
    pSave(NULL)
{
}

Saver::~Saver()
{
    if (pSave) pSave->Release();
    if (pXFile) pXFile->Release();
}

HRESULT Saver::Init(LPCSTR filename,
                    D3DRMXOFFORMAT d3dFormatArg,
                    D3DRMSAVEOPTIONS d3dSaveFlagsArg)
{
    d3dFormat = d3dFormatArg;
    d3dSaveFlags = d3dSaveFlagsArg;


	CREATEXFILE pCreateXFile=(CREATEXFILE)GetProcAddress( g_hInstD3DXOFDLL, "DirectXFileCreate" );	
	if (!pCreateXFile) return E_NOTIMPL;
		
	
    DXFILEFORMAT xFormat;

    if (d3dFormat == D3DRMXOF_BINARY)
        xFormat = DXFILEFORMAT_BINARY;
    else if (d3dFormat == D3DRMXOF_TEXT)
        xFormat = DXFILEFORMAT_TEXT;
    else
        xFormat = DXFILEFORMAT_COMPRESSED;

    //DirectXFileCreate(&pXFile);
	pCreateXFile(&pXFile);
    pXFile->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES);

    pXFile->CreateSaveObject(filename, xFormat, &pSave);

    return S_OK;
}

HRESULT Saver::SaveHeaderObject()
{
    LPDIRECTXFILEDATA pHeader;
    Header data;

    data.major = 1;
    data.minor = 0;
    data.flags = (d3dFormat == D3DRMXOF_TEXT)? 1 : 0;

    pSave->CreateDataObject(TID_DXFILEHeader,
                            NULL,
                            NULL,
                            sizeof(Header),
                            &data,
                            &pHeader);

    pSave->SaveData(pHeader);
    pHeader->Release();
    return S_OK;
}

HRESULT Saver::SaveFrame(LPDIRECT3DRMFRAME3 pFrame,
                         LPDIRECT3DRMFRAME3 pRefFrame,
                         LPDIRECTXFILEDATA pRefFrameObj)
{
    DWORD i;
    HRESULT hr;
    LPDIRECTXFILEDATA pFrameObj;
    
    pSave->CreateDataObject(TID_D3DRMFrame,
                            NULL, 
                            NULL,
                            0,
                            NULL,
                            &pFrameObj);

    SaveFrameTransform(pFrameObj, pFrame, pRefFrame);

    // Enumerate visuals.

    DWORD cVisuals;

    pFrame->GetVisuals(&cVisuals, NULL);

    if (cVisuals)
    {
        LPUNKNOWN *ppUnk = new LPUNKNOWN[cVisuals];

        pFrame->GetVisuals(&cVisuals, ppUnk);

        for (i = 0; i < cVisuals; i++)
        {
            LPDIRECT3DRMFRAME3 pChildFrame;
            hr = ppUnk[i]->QueryInterface(IID_IDirect3DRMFrame3, (LPVOID *)&pChildFrame);

            if (SUCCEEDED(hr))
            {
                SaveFrame(pChildFrame, pFrame, pFrameObj);
                pChildFrame->Release();
            }
            else
            {
                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder;
                hr = ppUnk[i]->QueryInterface(IID_IDirect3DRMMeshBuilder3, (LPVOID *)&pMeshBuilder);
    
                if (SUCCEEDED(hr))
                {
                    SaveMeshBuilder(pFrameObj, pMeshBuilder);
                    pMeshBuilder->Release();
                }
            }

            ppUnk[i]->Release();
        }

        delete[] ppUnk;
    }

    // Enumerate child frames.

    LPDIRECT3DRMFRAMEARRAY pFrameArray;

    pFrame->GetChildren(&pFrameArray);

    for (i = 0; i < pFrameArray->GetSize(); i++)
    {
        LPDIRECT3DRMFRAME pTmpFrame;
        LPDIRECT3DRMFRAME3 pChildFrame;
        pFrameArray->GetElement(i, &pTmpFrame);
        pTmpFrame->QueryInterface(IID_IDirect3DRMFrame3, (LPVOID *)&pChildFrame);
        pTmpFrame->Release();
        SaveFrame(pChildFrame, pFrame, pFrameObj);
        pChildFrame->Release();
    }

    pFrameArray->Release();

    // Add frame object to the saved list.

    if (pRefFrameObj)
        pRefFrameObj->AddDataObject(pFrameObj);
    else
        pSave->SaveData(pFrameObj);

    pFrameObj->Release();

    return S_OK;
}

HRESULT Saver::SaveFrameTransform(LPDIRECTXFILEDATA pFrameObj,
                                  LPDIRECT3DRMFRAME3 pFrame,
                                  LPDIRECT3DRMFRAME3 pRefFrame)
{
    LPDIRECTXFILEDATA pFrameTransformObj;
    D3DRMMATRIX4D rmMatrix;

    pFrame->GetTransform(pRefFrame, rmMatrix);

    pSave->CreateDataObject(TID_D3DRMFrameTransformMatrix,
                            NULL,
                            NULL,
                            sizeof(D3DRMMATRIX4D),
                            &rmMatrix,
                            &pFrameTransformObj);

    pFrameObj->AddDataObject(pFrameTransformObj);
    pFrameTransformObj->Release();
    return S_OK;
}

HRESULT Saver::SaveMeshBuilder(LPDIRECTXFILEDATA pFrameObj,
                               LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    LPDIRECTXFILEDATA pMeshObj;
    DWORD cVertices, cNormals, cFaces, dwFaceData, *pdwFaceData;
    LPDIRECT3DRMFACEARRAY pFaceArray = NULL;

    pMeshBuilder->GetGeometry(&cVertices, NULL,
                              &cNormals, NULL,
                              &dwFaceData, NULL);

    cFaces = pMeshBuilder->GetFaceCount();

    if (!cVertices || !cNormals || !dwFaceData || !cFaces)
        return S_OK;

    pdwFaceData = new DWORD[dwFaceData];

    pMeshBuilder->GetGeometry(NULL, NULL,
                              NULL, NULL,
                              &dwFaceData, pdwFaceData);

    CreateMeshObject(cVertices, cFaces, dwFaceData, pdwFaceData,
                     pMeshBuilder, &pMeshObj);

    D3DRMCOLORSOURCE clrSrc = pMeshBuilder->GetColorSource();

    if (clrSrc == D3DRMCOLOR_FROMVERTEX)
    {
        CreateVertexColorsObject(pMeshObj, cVertices, pMeshBuilder);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_MATERIALS)
    {
        if (!pFaceArray)
            pMeshBuilder->GetFaces(&pFaceArray);
        CreateMaterialListObject(pMeshObj, pFaceArray);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_NORMALS)
    {
        CreateNormalsObject(pMeshObj,
                            cNormals, cFaces, dwFaceData, pdwFaceData,
                            pMeshBuilder);
    }
    

    if (d3dSaveFlags & D3DRMXOFSAVE_TEXTURETOPOLOGY)
    {
        if (!pFaceArray)
            pMeshBuilder->GetFaces(&pFaceArray);
        CreateTextureWrapsObject(pMeshObj, pFaceArray);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_TEXTURECOORDINATES)
    {
        CreateTextureCoordsObject(pMeshObj, cVertices, pMeshBuilder);
    }

    if (pFrameObj)
        pFrameObj->AddDataObject(pMeshObj);
    else
        pSave->SaveData(pMeshObj);

    pMeshObj->Release();
    delete[] pdwFaceData;
    if (pFaceArray)
        pFaceArray->Release();

    return S_OK;
}

HRESULT Saver::CreateMeshObject(DWORD cVertices,
                                DWORD cFaces,
                                DWORD dwFaceData,
                                LPDWORD pdwFaceData,
                                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder,
                                LPDIRECTXFILEDATA *ppMeshObj)
{
    // mesh data is vertex_count + vertices + face_count + face_vertex_data;

    DWORD cbSize, *data;
    cbSize = cVertices * sizeof(D3DVECTOR) +
        (1 + (dwFaceData + cFaces + 1)/2) * sizeof(DWORD);

    data = (LPDWORD) new BYTE[cbSize];
    data[0] = cVertices;
    LPD3DVECTOR pVertices = (LPD3DVECTOR)&data[1];
    pMeshBuilder->GetGeometry(&cVertices, pVertices,
                              NULL, NULL,
                              NULL, NULL);

    LPDWORD pdwTmp = (LPDWORD)&pVertices[cVertices];
    *pdwTmp++ = cFaces;

    while (*pdwFaceData)
    {
        DWORD cFaceVertices = *pdwFaceData++;
        *pdwTmp++ = cFaceVertices;

        for (DWORD i = 0; i < cFaceVertices; i++)
        {
            *pdwTmp++ = *pdwFaceData++;
            pdwFaceData++; // skip normal index.
        }
    }

    DWORD dwSize;
    pMeshBuilder->GetName(&dwSize, NULL);
    
    LPSTR szName = NULL;
    if (dwSize)
    {
        szName = new char[dwSize];
        pMeshBuilder->GetName(&dwSize, szName);
    }

    pSave->CreateDataObject(TID_D3DRMMesh,
                            szName,
                            NULL,
                            cbSize,
                            data,
                            ppMeshObj);

    if (szName) lNames.Add(szName);
    delete[] data;
    return S_OK;
}

HRESULT Saver::CreateNormalsObject(LPDIRECTXFILEDATA pMeshObj,
                                   DWORD cNormals,
                                   DWORD cFaces,
                                   DWORD dwFaceData,
                                   LPDWORD pdwFaceData,
                                   LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{                                
    // normals data is normal_count + normals + face_count + face_normal_data;

    DWORD cbSize, *data;
    cbSize = cNormals * sizeof(D3DVECTOR) +
        (1 + (dwFaceData + cFaces + 1)/2) * sizeof(DWORD);

    data = (LPDWORD) new BYTE[cbSize];
    data[0] = cNormals;

    LPD3DVECTOR pNormals = (LPD3DVECTOR)&data[1];

    pMeshBuilder->GetGeometry(NULL, NULL,
                              &cNormals, pNormals,
                              NULL, NULL);

    LPDWORD pdwTmp = (LPDWORD)&pNormals[cNormals];
    *pdwTmp++ = cFaces;

    while (*pdwFaceData)
    {
        DWORD cFaceVertices = *pdwFaceData++;
        *pdwTmp++ = cFaceVertices;

        for (DWORD i = 0; i < cFaceVertices; i++)
        {
            pdwFaceData++; // skip vertex index.
            *pdwTmp++ = *pdwFaceData++;
        }
    }

    LPDIRECTXFILEDATA pNormalsObj;

    pSave->CreateDataObject(TID_D3DRMMeshNormals,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pNormalsObj);

    pMeshObj->AddDataObject(pNormalsObj);
    pNormalsObj->Release();
    delete[] data;

    return S_OK;
}

HRESULT Saver::CreateVertexColorsObject(LPDIRECTXFILEDATA pMeshObj,
                                        DWORD cVertices,
                                        LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    DWORD cbSize;
    VertexColors *data;

    cbSize = sizeof(DWORD) + cVertices * sizeof(IndexedColor);

    data = (VertexColors *) new BYTE[cbSize];
    data->cVertices = cVertices;

    for (DWORD i = 0; i < cVertices; i++)
    {
        D3DCOLOR color = pMeshBuilder->GetVertexColor(i);
        data->vertexColors[i].index = i;
        data->vertexColors[i].color.r = MyD3DRMColorGetRed(color);
        data->vertexColors[i].color.g = MyD3DRMColorGetGreen(color);
        data->vertexColors[i].color.b = MyD3DRMColorGetBlue(color);
        data->vertexColors[i].color.a = MyD3DRMColorGetAlpha(color);
    }

    LPDIRECTXFILEDATA pVertexColorsObj;

    pSave->CreateDataObject(TID_D3DRMMeshVertexColors,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pVertexColorsObj);

    pMeshObj->AddDataObject(pVertexColorsObj);
    pVertexColorsObj->Release();
    delete[] data;                        

    return S_OK;
}

HRESULT Saver::CreateMaterialListObject(LPDIRECTXFILEDATA pMeshObj,
                                        LPDIRECT3DRMFACEARRAY pFaceArray)
{
    DWORD cbSize, cFaces;
    FaceMaterials *data;
    FaceMaterialList lMat;

    cFaces = pFaceArray->GetSize();
    cbSize = (2 + cFaces) * sizeof(DWORD);

    data = (FaceMaterials *) new BYTE[cbSize];
    data->cFaceIndexes = cFaces;
    LPDWORD pdwIndex = data->faceIndexes;

    for (DWORD i = 0; i < cFaces; i++, pdwIndex++)
    {
        LPDIRECT3DRMFACE pFace;
        pFaceArray->GetElement(i, &pFace);

        D3DCOLOR faceColor;
        LPDIRECT3DRMMATERIAL pMaterial;
        LPDIRECT3DRMTEXTURE pTexture;

        faceColor = pFace->GetColor();
        pFace->GetMaterial(&pMaterial);
        pFace->GetTexture(&pTexture);
        
        *pdwIndex = lMat.Find(faceColor, pMaterial, pTexture);

        pMaterial->Release();
        if (pTexture) pTexture->Release();
        pFace->Release();
    }

    data->cMaterials = lMat.Count();

    if (data->cMaterials == 1)
    {
        data->cFaceIndexes = 1;
        data->faceIndexes[0] = 0;
        cbSize = 3 * sizeof(DWORD);
    }

    LPDIRECTXFILEDATA pMatListObj;

    pSave->CreateDataObject(TID_D3DRMMeshMaterialList,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pMatListObj);

    FaceMaterial *pMat;
    for (pMat = lMat.First(); pMat; pMat = pMat->pNext)
    {
        CreateMaterialObject(pMatListObj,
                             pMat);
    }

    pMeshObj->AddDataObject(pMatListObj);
    pMatListObj->Release();
    delete[] data;
    
    return S_OK;
}

HRESULT Saver::CreateMaterialObject(LPDIRECTXFILEDATA pMatListObj,
                                    FaceMaterial *pMat)
{
    BaseMaterial data;

    data.faceColor.r = MyD3DRMColorGetRed(pMat->faceColor);
    data.faceColor.g = MyD3DRMColorGetGreen(pMat->faceColor);
    data.faceColor.b = MyD3DRMColorGetBlue(pMat->faceColor);
    data.faceColor.a = MyD3DRMColorGetAlpha(pMat->faceColor);

    data.power = pMat->pMaterial->GetPower();

    pMat->pMaterial->GetSpecular(&data.specularColor.r,
                                 &data.specularColor.g,
                                 &data.specularColor.b);

    pMat->pMaterial->GetEmissive(&data.emissiveColor.r,
                                 &data.emissiveColor.g,
                                 &data.emissiveColor.b);

    LPDIRECTXFILEDATA pMaterialObj;

    pSave->CreateDataObject(TID_D3DRMMaterial,
                            NULL,
                            NULL,
                            sizeof(BaseMaterial),
                            &data,
                            &pMaterialObj);

    if (pMat->pTexture)
    {
        IDirectXFileData *pTextureObj;

        DWORD dwSize;
        pMat->pTexture->GetName(&dwSize, NULL);

        if (dwSize)
        {
            LPSTR szName = new char[dwSize];
            pMat->pTexture->GetName(&dwSize, szName);
    
            pSave->CreateDataObject(TID_D3DRMTextureFilename,
                                    NULL,
                                    NULL,
                                    sizeof(LPSTR),
                                    &szName,
                                    &pTextureObj);
    
            pMaterialObj->AddDataObject(pTextureObj);
            pTextureObj->Release();
            lNames.Add(szName);
        }
    }

    pMatListObj->AddDataObject(pMaterialObj);
    pMaterialObj->Release();

    return S_OK;
}

HRESULT Saver::CreateTextureWrapsObject(LPDIRECTXFILEDATA pMeshObj,
                                        LPDIRECT3DRMFACEARRAY pFaceArray)
{
    DWORD cbSize, cFaces;
    FaceWraps *data;

    cFaces = pFaceArray->GetSize();
    cbSize = sizeof(DWORD) + cFaces * sizeof(Boolean2d);

    data = (FaceWraps *) new BYTE[cbSize];
    data->cFaces = cFaces;
    Boolean2d *pWrap = data->faceWraps;

    for (DWORD i = 0; i < cFaces; i++, pWrap++)
    {
        LPDIRECT3DRMFACE pFace;
        pFaceArray->GetElement(i, &pFace);
        pFace->GetTextureTopology(&pWrap->u, &pWrap->v);
        pFace->Release();
    }

    LPDIRECTXFILEDATA pTextureWrapsObj;

    pSave->CreateDataObject(TID_D3DRMMeshFaceWraps,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pTextureWrapsObj);

    pMeshObj->AddDataObject(pTextureWrapsObj);
    pTextureWrapsObj->Release();
    delete[] data;                        

    return S_OK;
}

HRESULT Saver::CreateTextureCoordsObject(LPDIRECTXFILEDATA pMeshObj,
                                         DWORD cVertices,
                                         LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    DWORD cbSize;
    TextureCoords *data;

    cbSize = sizeof(DWORD) + cVertices * sizeof(Coords2d);

    data = (TextureCoords *) new BYTE[cbSize];
    data->cVertices = cVertices;
    Coords2d *pCoords = data->textureCoords;

    for (DWORD i = 0; i < cVertices; i++, pCoords++)
    {
        pMeshBuilder->GetTextureCoordinates(i, &pCoords->u, &pCoords->v);
    }

    LPDIRECTXFILEDATA pTexCoordsObj;

    pSave->CreateDataObject(TID_D3DRMMeshTextureCoords,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pTexCoordsObj);

    pMeshObj->AddDataObject(pTexCoordsObj);
    pTexCoordsObj->Release();
    delete[] data;                        

    return S_OK;
}

FaceMaterialList::FaceMaterialList()
  : cElements(0), pFirst(NULL)
{
}

FaceMaterialList::~FaceMaterialList()
{
    FaceMaterial *pMat = pFirst;
    while (pMat)
    {
        FaceMaterial *pNext = pMat->pNext;
        pMat->pMaterial->Release();
        if (pMat->pTexture) pMat->pTexture->Release();
        delete pMat;
        pMat = pNext;
    }
}

DWORD FaceMaterialList::Find(D3DCOLOR faceColor,
                             LPDIRECT3DRMMATERIAL pMaterial,
                             LPDIRECT3DRMTEXTURE pTexture)
{
    FaceMaterial *pTmp = pFirst;
    FaceMaterial **ppNew = &pFirst;

    for (DWORD i = 0; pTmp; i++, pTmp = pTmp->pNext)
    {
        if (pTmp->faceColor == faceColor &&
            pTmp->pMaterial == pMaterial &&
            pTmp->pTexture == pTexture)
            return i;

        if (!pTmp->pNext)
            ppNew = &pTmp->pNext;
    }

    FaceMaterial *pNew = new FaceMaterial;
    pNew->faceColor = faceColor;
    pNew->pMaterial = pMaterial;
    pNew->pTexture = pTexture;
    pNew->pNext = NULL;
    pMaterial->AddRef();
    if (pTexture) pTexture->AddRef();

    *ppNew = pNew;
    cElements++;
    return i;
}

NameList::NameList()
 : pFirst(NULL),
   ppLast(NULL)
{
}

NameList::~NameList()
{
    NameEntry *pEntry = pFirst;

    while (pEntry)
    {
        NameEntry *pNext = pEntry->pNext;
        delete[] pEntry->pName;
        delete pEntry;
        pEntry = pNext;
    }
}

void NameList::Add(LPSTR pName)
{
    NameEntry *pNew = new NameEntry;

    pNew->pName = pName;
    pNew->pNext = NULL;

    if (ppLast)
        *ppLast = pNew;
    else
        pFirst = pNew;

    ppLast = &pNew->pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
#include <statreg.h>
#include <statreg.cpp>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\pchmath.h ===
#include "d3dx8math.h"

#undef D3DXINLINE
#define D3DXINLINE
#define D3DVBINLINE 
#define D3DVBCALL WINAPI 
#include "d3dxmathVB.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

RegisterBin: $(TARGET)
!ifndef NTDEBUG
!MESSAGE Registering $(TARGETNAME)
	regsvr32 -s -u $(?F)
	regsvr32 -s $?
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\guids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       guids.h
//
//--------------------------------------------------------------------------

#if 0
DEFINE_GUID( IID_IDirectDraw,			0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,		0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );

DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,		0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl, 	0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

DEFINE_GUID(IID_IDirectSound3DListener,0x279AFA84,0x4981,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60);
DEFINE_GUID(IID_IDirectSound3DBuffer,0x279AFA86,0x4981,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60);
DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);
DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);
DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);
DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);



DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3D2,            0x6aae1ec1,0x662a,0x11d0,0x88,0x9d,0x00,0xaa,0x00,0xbb,0xb7,0x6a);
DEFINE_GUID( IID_IDirect3D3,            0xbb223240,0xe72b,0x11d0,0xa9,0xb4,0x00,0xaa,0x00,0xc0,0x99,0x3e);
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DRefDevice,    0x50936643, 0x13e9, 0x11d1, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DNullDevice, 0x8767df22, 0xbacc, 0x11d1, 0x89, 0x69, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( IID_IDirect3DDevice,       0x64108800,0x957d,0X11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DDevice2,  0x93281501, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DDevice3,  0xb0ab3b60, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DTexture2, 0x93281502, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial2,    0x93281503, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DMaterial3,    0xca9c46f4, 0xd3c5, 0x11d1, 0xb7, 0x5a, 0x0, 0x60, 0x8, 0x52, 0xb3, 0x12);
DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport2,    0x93281500, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DViewport3,    0xb0ab3b61, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DVertexBuffer, 0x7a503555, 0x4a83, 0x11d1, 0xa5, 0xdb, 0x0, 0xa0, 0xc9, 0x3, 0x67, 0xf8);




DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);
DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject,          0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice,          0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,         0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport,        0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame,           0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,          0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual,          0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh,            0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,     0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0xff6b7f71, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMFace,            0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLight,           0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture,         0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap,            0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial,        0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation,       0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,     0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,     0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray,      0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,     0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray,      0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,     0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,       0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray,  0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,      0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,          0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,         0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);
DEFINE_GUID(IID_IDirect3DRMWinDevice,   0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);



DEFINE_GUID(IID_IDirect3DRM2,   0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x2e34065, 0xc243, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ConstantForce,0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,    0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,       0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,         0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,     0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,   0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown, 0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,       0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,       0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,      0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,     0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,  0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Direct.rc
//
#define IDS_DSOUND_DESC                 1
#define IDS_GENERIC_DESC                2
#define IDS_DIRECTX8_DESC               3
#define IDS_D3DX8_DESC               	4

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        209
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\referenceclockobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "ReferenceClockObj.h"					   

extern void *g_dxj_ReferenceClock;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_ReferenceClockObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"ReferenceClock [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_ReferenceClockObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"ReferenceClock [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_ReferenceClockObject
///////////////////////////////////////////////////////////////////
C_dxj_ReferenceClockObject::C_dxj_ReferenceClockObject(){ 
		
	DPF1(1,"Constructor Creation  ReferenceClock Object[%d] \n ",g_creationcount);

	m__dxj_ReferenceClock = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_ReferenceClock;
	creationid = ++g_creationcount;
	 	
	g_dxj_ReferenceClock = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_ReferenceClockObject
///////////////////////////////////////////////////////////////////
C_dxj_ReferenceClockObject::~C_dxj_ReferenceClockObject()
{

	DPF(1,"Entering ~C_dxj_ReferenceClockObject destructor \n");

     C_dxj_ReferenceClockObject *prev=NULL; 
	for(C_dxj_ReferenceClockObject *ptr=(C_dxj_ReferenceClockObject *)g_dxj_ReferenceClock ; ptr; ptr=(C_dxj_ReferenceClockObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_ReferenceClock = (void*)ptr->nextobj; 
			
			DPF(1,"ReferenceClockObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_ReferenceClock){
		int count = IUNK(m__dxj_ReferenceClock)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IReferenceClock Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_ReferenceClock = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_ReferenceClockObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_ReferenceClock;
	
	return S_OK;
}
HRESULT C_dxj_ReferenceClockObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_ReferenceClock=(IReferenceClock*)pUnk;
	return S_OK;
}
HRESULT C_dxj_ReferenceClockObject::GetTime(REFERENCE_TIME *ret)
{
	HRESULT hr;
	
	if (FAILED(hr=m__dxj_ReferenceClock->GetTime(ret) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_ReferenceClockObject::AdviseTime(REFERENCE_TIME time1, REFERENCE_TIME time2, long lHandle, long *lRet)
{
	HRESULT hr;
	
	if (FAILED(hr=m__dxj_ReferenceClock->AdviseTime(time1, time2, (HANDLE) lHandle, (DWORD*) lRet) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_ReferenceClockObject::AdvisePeriodic(REFERENCE_TIME time1, REFERENCE_TIME time2, long lHandle, long *lRet)
{
	HRESULT hr;

	if (FAILED(hr=m__dxj_ReferenceClock->AdvisePeriodic(time1, time2, (HANDLE) lHandle, (DWORD*) lRet) ) )
		return hr;
	
	return S_OK;
}

HRESULT C_dxj_ReferenceClockObject::Unadvise(long lUnadvise)
{
	HRESULT hr;
	
	if (FAILED(hr=m__dxj_ReferenceClock->Unadvise((DWORD) lUnadvise) ) )
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\sources.inc ===
!IF 0


Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Andrew Kertesz (Andrewke) 20-DEC-98

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF


MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dx8vb
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=direct.def
!IF 0
        DLLENTRY=_DllMainCRTStartup
!ENDIF

DLLENTRY=DllMain

USE_LIBCMT=1
USE_CRTDLL=1
USE_MAPSYM=1
USE_STATIC_ATL=1
DX7=1
DX6=1


PLAT_DIR           = daytona
# ALT_PROJECT_TARGET = .
!if defined(NTDEBUG) && "$(NTDEBUG)" != "ntsdnodebug"
DEBUG=1
!endif

C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT

# 11/21/2000
# new compiler causing error linking in d3dx8dt
# talk with d3dx team to see if we need to link in C runtime
LINK_LIB_IGNORE = 4210

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(BASEDIR)\public\sdk\lib\*\libcmt.lib		\
           $(BASEDIR)\public\sdk\lib\*\kernel32.lib		\
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib		\
           $(BASEDIR)\public\sdk\lib\*\uuid.lib                 \
           $(BASEDIR)\public\sdk\lib\*\ole32.lib                \
           $(BASEDIR)\public\sdk\lib\*\gdi32.lib                \
           $(BASEDIR)\public\sdk\lib\*\winmm.lib                \
           $(SDK_LIB_PATH)\dinput.lib             		\
           $(BASEDIR)\public\sdk\lib\*\msacm32.lib              \
           $(BASEDIR)\public\sdk\lib\*\USER32.lib              \
           $(BASEDIR)\public\sdk\lib\*\OLEAUT32.lib            \
           $(SDK_LIB_PATH)\d3dxof.lib              
#          $(SDK_LIB_PATH)\d3d8.lib    
!if $(FREEBUILD)
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\d3dx8.lib  
             

!else
TARGETLIBS=$(TARGETLIBS) \
 $(SDK_LIB_PATH)\d3dx8dt.lib
                       
!endif      


           

PASS0_HEADERDIR=$O

INCLUDES=$(DXROOT)\inc; \
	 $(SDK_INC_PATH); \
        $(PASS0_HEADERDIR);




SOURCES=   \
        ..\direct.idl              \
	..\directvb.idl            \
        ..\direct.cpp              \
        ..\dxGlob7Obj.cpp          \
        ..\StdAfx.cpp              \
        ..\wave.cpp                \
        ..\dmLoaderObj.cpp         \
        ..\dmSegmentObj.cpp        \
        ..\dmBandObj.cpp           \
        ..\dmChordMapObj.cpp       \
        ..\dmCollectionObj.cpp     \
        ..\dmPerformanceObj.cpp    \
        ..\dmSegmentStateObj.cpp   \
        ..\dmStyleObj.cpp          \
        ..\dmComposerObj.cpp       \
        ..\dmusAudioPathObj.cpp       \
        ..\DIEnumDeviceObjectsObj.cpp \
        ..\DIEnumDevicesObj.cpp \
        ..\dInput1Obj.cpp \
        ..\dInputDeviceObj.cpp \
        ..\dInputEffectObj.cpp \
        ..\dIDevObjInstObj.cpp \
        ..\dIDevInstObj.cpp \
	..\dIEnumEffectsObj.cpp \
	..\DPlayPeerObj.cpp \
	..\DPlayServerObj.cpp \
	..\DPlayClientObj.cpp \
	..\DPlayAddressObj.cpp \
	..\DPlayLobbyClientObj.cpp \
	..\DPlayLobbiedAppObj.cpp \
	..\DplayvoiceClientObj.cpp \
	..\DplayvoiceserverObj.cpp \
	..\DplayvoiceSetupObj.cpp \
	..\DplayBufHelp.cpp \
        ..\DSEnumObj.cpp \
        ..\dSound3DBuffer.cpp \
        ..\dSound3DListener.cpp \
        ..\dSoundBufferObj.cpp \
        ..\dSoundPrimaryBufferObj.cpp \
        ..\dSoundCaptureBufferObj.cpp \
        ..\dSoundCaptureObj.cpp \
        ..\dSoundObj.cpp      \
	..\dSoundFXGargleObj.cpp \
	..\dSoundFXParamEQObj.cpp \
	..\dSoundFXWavesReverbObj.cpp \
	..\dSoundFXchorusObj.cpp \
	..\dSoundFXCompressorObj.cpp \
	..\dSoundFXDistortionObj.cpp \
	..\dSoundFXEchoObj.cpp \
	..\dSoundFXFlangerObj.cpp \
	..\dSoundFXi3dl2reverbObj.cpp \
	..\XFileObj.cpp \
	..\XFileEnumObj.cpp \
	..\XFileReferenceObj.cpp \
	..\XFileDataObj.cpp \
	..\XFileSaveObj.cpp \
	..\XFileBinaryObj.cpp \
	..\XFileSaveObj.cpp \
	..\d3dxmathvb.cpp \
	..\d3dxtexvb.cpp \
	..\d3dx8obj.cpp \
        ..\dxvb.rc \
        ..\guids.cpp \
        ..\filestrm.cpp \
        ..\dxerr8.cpp

!if "$(__PRODUCT)" == "DX7"
!if  "$(ALPHA)"=="1" || "$(WIN95)"=="1"
NTTARGETFILE1=RegisterBin
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#define DX6 1
#define DX7 1

#include "windows.h"
#include "mmsystem.h"

#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include "atlcom.h"



#ifndef _DEBUG
__inline void* __cdecl malloc(size_t cbSize)
{
    return (void*) LocalAlloc(LMEM_FIXED, cbSize);
}

__inline void* __cdecl realloc(void* oldptr, size_t cbSize)
{
    return (void*) LocalReAlloc(oldptr, cbSize, LMEM_MOVEABLE);
}

__inline void __cdecl free(void *pv)
{
    LocalFree((HLOCAL)pv);
}

__inline void* __cdecl operator new(size_t cbSize)
{
    return (void*) malloc(cbSize);
}

__inline void __cdecl operator delete(void *pv)
{
    free(pv);
}

__inline int __cdecl _purecall(void)
{
    return(0);
}
#endif

//#define _D3DTYPES_H_ 1


#include <d3d8.h>
#include <dSound.h>
#include <dPlay8.h>
#include <dpLobby8.h>
#include <dinput.h>
#include <dvoice.h>

#define DECL_VARIABLE(c) typedef_##c m_##c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\referenceclockobj.h ===
#include "resource.h"       // main symbols

#define typedef__dxj_ReferenceClock IReferenceClock*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_ReferenceClockObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_ReferenceClock, &IID_I_dxj_ReferenceClock, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_ReferenceClock,
#endif

	public CComObjectRoot
{
public:
	C_dxj_ReferenceClockObject() ;
	virtual ~C_dxj_ReferenceClockObject() ;

BEGIN_COM_MAP(C_dxj_ReferenceClockObject)
	COM_INTERFACE_ENTRY(I_dxj_ReferenceClock)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_ReferenceClockObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_ReferenceClock
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE GetTime(REFERENCE_TIME __RPC_FAR *ret);
		HRESULT STDMETHODCALLTYPE AdviseTime(REFERENCE_TIME time1, REFERENCE_TIME time2, long lHandle, long __RPC_FAR *lRet);
		HRESULT STDMETHODCALLTYPE AdvisePeriodic(REFERENCE_TIME time1, REFERENCE_TIME time2, long lHandle, long __RPC_FAR *lRet);
		HRESULT STDMETHODCALLTYPE Unadvise(long lUnadvise);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_ReferenceClock);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_ReferenceClock);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\wave.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wave.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include <mmreg.h>
#include <msacm.h>


// FOURCC codes
#undef FOURCC_RIFF
#define FOURCC_RIFF         'FFIR'

#undef FOURCC_MEM
#define FOURCC_MEM          ' MEM'

#undef FOURCC_WAVE
#define FOURCC_WAVE         'EVAW'

#undef FOURCC_FORMAT
#define FOURCC_FORMAT       ' tmf'

#undef FOURCC_DATA
#define FOURCC_DATA         'atad'

#define RPF(level,str,err) \
	{ char outBuf[MAX_PATH]; \
	  wsprintf(outBuf,str,err); \
	  OutputDebugString(outBuf); \
	}


#define DPFLVL_ERROR 1



/***************************************************************************
 *
 *  FillWfx
 *
 *  Description:
 *      Fills a WAVEFORMATEX structure, given only the necessary values.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: structure to fill.
 *      WORD [in]: number of channels.
 *      DWORD [in]: samples per second.
 *      WORD [in]: bits per sample.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME

void FillWfx(LPWAVEFORMATEX pwfx, WORD wChannels, DWORD dwSamplesPerSec, WORD wBitsPerSample)
{
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = min(2, max(1, wChannels));
    pwfx->nSamplesPerSec = min(DSBFREQUENCY_MAX, max(DSBFREQUENCY_MIN, dwSamplesPerSec));
    
    if(wBitsPerSample < 12)
    {
        pwfx->wBitsPerSample = 8;
    }
    else
    {
        pwfx->wBitsPerSample = 16;
    }

    pwfx->nBlockAlign = pwfx->nChannels * pwfx->wBitsPerSample / 8;
    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;
    pwfx->cbSize = 0;
}


#if 0

HRESULT InternalCreateSoundBuffer(LPDSBUFFERDESC pDsbDesc, byte *pbWaveData,DWORD cbWaveData,LPDIRECTSOUND lpDirectSound, LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer)
{

    HRESULT                 hr                  = DS_OK;
    HACMSTREAM              has                 = NULL;
    BOOL                    fPrep               = FALSE;
    ACMSTREAMHEADER         ash;
    DWORD                   dwBufferBytes;
    LPVOID                  pvWrite;
    DWORD                   cbWrite;
    HMMIO                   hmm                 = NULL;
	MMRESULT                mmr;
	MMIOINFO                mmioinfo;
    MMCKINFO                ckiRiff;
    MMCKINFO                cki;
	LPWAVEFORMATEX          pwfxSrcFormat       = NULL;
    LPWAVEFORMATEX          pwfxDestFormat      = NULL;
	BOOL					bNULLFORMAT			= FALSE;    
	


    ZeroMemory(&mmioinfo, sizeof(mmioinfo));

	if(SUCCEEDED(hr)){
		mmioinfo.fccIOProc = FOURCC_MEM;
		mmioinfo.pchBuffer = (HPSTR)pbWaveData;
		mmioinfo.cchBuffer = cbWaveData;
    
		hmm = mmioOpen(NULL, &mmioinfo, MMIO_READ);
		
		if(!hmm)
		{
			DPF1(1, "Unable to open file via MMIO.  Error %lu", mmioinfo.wErrorRet);
			hr = E_FAIL; 
		}
	 }

    // Decend into the RIFF chunk
    if(SUCCEEDED(hr))
    {
        ckiRiff.ckid = FOURCC_RIFF;
        mmr = mmioDescend(hmm, &ckiRiff, NULL, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to descend into RIFF chunk.  Error %lu", mmr);
            hr = E_FAIL; 
        }
    }

    // Verify that this is a wave file
    if(SUCCEEDED(hr) && FOURCC_WAVE != ckiRiff.fccType)
    {
        DPF1(1, "File is not type WAVE %d",GetLastError());
        hr = DSERR_BADFORMAT;
    }

    // Decend into the format chunk
    if(SUCCEEDED(hr))
    {
        cki.ckid = FOURCC_FORMAT;
        mmr = mmioDescend(hmm, &cki, &ckiRiff, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to descend into format chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }

        if(SUCCEEDED(hr))
        {
            pwfxSrcFormat = (LPWAVEFORMATEX)(pbWaveData + cki.dwDataOffset);
        }
    }



    // Ascend out of the format chunk
    if(SUCCEEDED(hr))
    {
        mmr = mmioAscend(hmm, &cki, 0);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Unable to ascend out of format chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
    }

    // Descend into the data chunk
    if(SUCCEEDED(hr))
    {
        cki.ckid = FOURCC_DATA;
        mmr = mmioDescend(hmm, &cki, &ckiRiff, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            RPF(DPFLVL_ERROR, "Unable to descend into data chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
    }

    // Prepare PCM conversion
    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
        {
            // Populate the buffer description
            dwBufferBytes = cki.cksize;
            pwfxDestFormat = pwfxSrcFormat;
        }
        else
        {
            // Open an ACM conversion stream
            mmr = acmStreamOpen(&has, NULL, (LPWAVEFORMATEX)pwfxSrcFormat, pwfxDestFormat, NULL, 0, 0, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                RPF(DPFLVL_ERROR, "Unable to open an ACM stream.  Error %lu", mmr);
                hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
            }

            // Get the size of the PCM data
            if(SUCCEEDED(hr))
            {
                mmr = acmStreamSize(has, cki.cksize, &dwBufferBytes, ACM_STREAMSIZEF_SOURCE);

                if(MMSYSERR_NOERROR != mmr)
                {
                    RPF(DPFLVL_ERROR, "Unable to determine converted data size.  Error %lu", mmr);
                    hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
                }
            }

            // Create the destination format
            if(SUCCEEDED(hr))
            {
                pwfxDestFormat = (WAVEFORMATEX*)malloc(sizeof(WAVEFORMATEX));
                if (pwfxDestFormat==NULL) hr=E_OUTOFMEMORY;				
            }
        
            if(SUCCEEDED(hr))
            {
                FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
            }
        }
    }

	
	LPDIRECTSOUNDBUFFER lpDirectSoundBuffer=NULL;
	
    if(SUCCEEDED(hr))
    {
		//hr = InitializeEmpty(pDsbDesc->dwFlags, dwBufferBytes, pwfxDestFormat, NULL);
		pDsbDesc->dwBufferBytes=dwBufferBytes;
		
		if (pDsbDesc->lpwfxFormat){
			memcpy(pDsbDesc->lpwfxFormat,pwfxDestFormat,sizeof(WAVEFORMATEX));
		}
		else {
			pDsbDesc->lpwfxFormat=pwfxDestFormat;
		}

		hr=lpDirectSound->CreateSoundBuffer(pDsbDesc,lplpDirectSoundBuffer,NULL);
		if (*lplpDirectSoundBuffer==NULL) hr= E_FAIL;
		lpDirectSoundBuffer=*lplpDirectSoundBuffer;
	}


    

    // Lock the buffer in order to write the PCM data to it
    if(SUCCEEDED(hr))
    {
        hr = lpDirectSoundBuffer->Lock(0, dwBufferBytes, &pvWrite, &cbWrite, NULL, NULL,0);
    }

    // Convert to PCM
    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
        {
            CopyMemory(pvWrite, pbWaveData + cki.dwDataOffset, cbWrite);
        }
        else
        {
            // Prepare the conversion header
            ZeroMemory(&ash, sizeof(ash));

            ash.cbStruct = sizeof(ash);
            ash.pbSrc = pbWaveData + cki.dwDataOffset;
            ash.cbSrcLength = cki.cksize;
            ash.pbDst = (LPBYTE)pvWrite;
            ash.cbDstLength = cbWrite;

            mmr = acmStreamPrepareHeader(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                RPF(DPFLVL_ERROR, "Unable to prepare ACM stream header.  Error %lu", mmr);
                hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
            }

            fPrep = SUCCEEDED(hr);

            // Convert the buffer
            if(SUCCEEDED(hr))
            {
                mmr = acmStreamConvert(has, &ash, 0);

                if(MMSYSERR_NOERROR != mmr)
                {
                    RPF(DPFLVL_ERROR, "Unable to convert wave data.  Error %lu", mmr);
                    hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
                }
            }
        }
    }

    // Unlock the buffer
    if(SUCCEEDED(hr))
    {
        hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
    }

    // Clean up
    if(fPrep)
    {
        acmStreamUnprepareHeader(has, &ash, 0);
    }

    if(has)
    {
        acmStreamClose(has, 0);
    }
    
    if(hmm)
    {
        mmioClose(hmm, 0);
    }

    if(pwfxDestFormat != pwfxSrcFormat)
    {
        free(pwfxDestFormat);
    }

    return hr;

}

#endif


















///////////////////////////////////////////////////////////////////////////////////////////
		

HRESULT InternalCreateSoundBuffer(LPDSBUFFERDESC pDsbDesc, byte *pbWaveData, DWORD cbWaveData,LPDIRECTSOUND lpDirectSound, LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer)
{

    HRESULT                 hr                  = DS_OK;
    HACMSTREAM              has                 = NULL;
    BOOL                    fPrep               = FALSE;    
    DWORD                   dwBufferBytes		= 0;
    LPVOID                  pvWrite				= NULL;
    DWORD                   cbWrite				= 0;
	LPWAVEFORMATEX			pwfxFormat			= NULL;
	LPWAVEFORMATEX          pwfxSrcFormat       = NULL;
    LPWAVEFORMATEX          pwfxDestFormat      = NULL;    
	MMRESULT                mmr					= 0;
	DWORD					dwDataLength		= 0;
	DWORD					dwOffset			= 0;
	char					*pChunk				= NULL;
	LPDIRECTSOUNDBUFFER		lpDirectSoundBuffer	= NULL;
	ACMSTREAMHEADER         ash;
	BOOL					bNULLFORMAT			=FALSE;
	BOOL					bDirty				=FALSE;

	
	struct tag_FileHeader
	{
		DWORD       dwRiff;
		DWORD       dwFileSize;
		DWORD       dwWave;
		DWORD       dwFormat;
		DWORD       dwFormatLength;		
	} FileHeader;
	
	ZeroMemory(&FileHeader,sizeof(struct tag_FileHeader));
	
	//	If our file is big enough to have a header copy it over
	//	other wise error out
	if (cbWaveData>sizeof(struct tag_FileHeader)) 
	{
		memcpy(&FileHeader,pbWaveData,sizeof(struct tag_FileHeader));
	}
	else 
	{
		hr= E_INVALIDARG;
	}

	// File must be a riff file ( 52 R, 49 I, 46 F, 46 F)
	if (FileHeader.dwRiff != 0x46464952) 
	{
		DPF(1, "DXVB: not a RIFF file\n");
		return E_INVALIDARG;	
	}

	//  must be a WAVE format ( 57 W, 41 A, 56 V, 45 E )
	if (FileHeader.dwWave != 0x45564157)
	{
		DPF(1, "DXVB: not a WAVE file\n");
		return E_INVALIDARG;	
	}

	//  check for odd stuff
	//  note 18bytes is a typical WAVEFORMATEX
	if (FileHeader.dwFormatLength <= 14) return E_INVALIDARG;
	if (FileHeader.dwFormatLength > 1000) return E_INVALIDARG;

	//allocate the waveformat
	pwfxFormat=(WAVEFORMATEX*)alloca(FileHeader.dwFormatLength);
	if (!pwfxFormat) return E_OUTOFMEMORY;

	//copy it to our own data structure
	pChunk=(char*)(pbWaveData+sizeof (struct tag_FileHeader));
	memcpy(pwfxFormat,pChunk,FileHeader.dwFormatLength);

	
	// Now look for the next chunk after the WaveFormat
	pChunk=(char*)(pChunk+FileHeader.dwFormatLength);
		
	// Look for option FACT chunk and skip it
	//	(66 F, 61 A, 63 C, 74 T)
	// this chunk is required for compressed wave files
	// but is optional for PCM
	//
	if ( ((DWORD*)pChunk)[0]==0x74636166) 
	{
		dwOffset=((DWORD*)pChunk)[1];
		dwBufferBytes=((DWORD*)pChunk)[2];	//number of bytes of PCM data
		pChunk =(char*)(pChunk+ dwOffset+8);	
		
	}

	//Look for required data chunk
	// (64 D, 61 A, 74 T, 61 A)
	if (((DWORD*)pChunk)[0]!=0x61746164) 
	{
				DPF(1, "DXVB: no DATA chunk in wave file\n");
				return E_INVALIDARG;	
	}

	dwDataLength=((DWORD*)pChunk)[1];
	pChunk=(char*)(pChunk+8);
								
	
	//IF we assume PCM 
	//pcm files are not required to have their fact chunk 
	//so be ware they may missreport the data length			
	dwBufferBytes=dwDataLength;	
	pwfxDestFormat=pwfxSrcFormat=pwfxFormat;

	// if we are not PCM then we need to do some things first
	if (pwfxFormat->wFormatTag!=WAVE_FORMAT_PCM)
	{
	

		// source format is from the file 
	
		pwfxSrcFormat=pwfxFormat;				//from file
		pwfxDestFormat=pDsbDesc->lpwfxFormat ;	//from user	
		

		
		//pick the format of the file passed in
		FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
		

		// Open an ACM conversion stream
		mmr = acmStreamOpen(&has, NULL, (LPWAVEFORMATEX)pwfxSrcFormat, pwfxDestFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );
		if(MMSYSERR_NOERROR != mmr)
		{
			DPF1(1, "Unable to open an ACM stream.  Error %lu\n", mmr);
			return E_FAIL;
		}

	
        // Get the size of the PCM data
        mmr = acmStreamSize(has, dwDataLength, &dwBufferBytes, ACM_STREAMSIZEF_SOURCE);
        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to determine converted data size.  Error %lu\n", mmr);
            return E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
   

		// Allocate a DestFormat struct
        //pwfxDestFormat = (WAVEFORMATEX*)alloca(sizeof(WAVEFORMATEX));
        //if (!pwfxDestFormat) return E_OUTOFMEMORY;				
        

		// Fill the format with information from the source but
		// FillWfx sets the format to PCM
        //FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
        

    }

	
	// fill the buffer desc the user passed in with the buffer bytes
	// this is the number of PCM bytes
	pDsbDesc->dwBufferBytes=dwBufferBytes;
	
	// if they provide us a pointer to a waveformatex
	// copy over the format to the input desc and use it
	// otherwise have it point to our data format temprarily
	if (pDsbDesc->lpwfxFormat){
			memcpy(pDsbDesc->lpwfxFormat,pwfxDestFormat,sizeof(WAVEFORMATEX));
		}
	else {
		pDsbDesc->lpwfxFormat=pwfxDestFormat;
		//make sure we null out the format before passing it back to the user
		//NOTE: consider the problems in a multithreaded enviroment
		//where the users data structures are being accesed by multiple
		//threads... on the other hand if thats going on..
		//then the user would need to syncronize things on his or her own 
		//for everything else including calling into apis that fill structures..
		bNULLFORMAT=TRUE;		
	}

	LPDIRECTSOUNDBUFFER		dsbTemp = NULL;
	// Create the buffer
	if (FAILED(hr=lpDirectSound->CreateSoundBuffer(pDsbDesc,&dsbTemp,NULL) ) )
		return hr;

	hr = dsbTemp->QueryInterface(IID_IDirectSoundBuffer8, (void**) lplpDirectSoundBuffer);
	dsbTemp->Release();
	if (FAILED(hr)) return hr;

	if (*lplpDirectSoundBuffer==NULL) return E_FAIL;	//todo ASSERT this instead..
	
	// for more convenient referencing...
	lpDirectSoundBuffer=*lplpDirectSoundBuffer;
	
    
    // Lock the buffer in order to write the PCM data to it
	// cbWrite will contain the number of locked bytes
    hr = lpDirectSoundBuffer->Lock(0, dwBufferBytes, &pvWrite, &cbWrite, NULL, NULL,0);
	if FAILED(hr) return hr;


	// If the sorce format was pcm then copy from the file to the buffer
    if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
    {
    	CopyMemory(pvWrite, pChunk, cbWrite);


		// Unlock the buffer
		hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
    
		if (FAILED(hr)) 
		{
			 DPF(1, "DXVB: lpDirectSoundBuffer->Unlock failed.. \n");
			 return hr;
		}

    }

	// if the source format is compressed then convert first then copy
    else
    {
            // Prepare the conversion header
            ZeroMemory(&ash, sizeof(ash));

            ash.cbStruct = sizeof(ash);
            ash.pbSrc = (unsigned char*)pChunk;	//start of compressed data
            ash.cbSrcLength = dwDataLength;		//number of bytes of compressed data
            ash.pbDst = (LPBYTE)pvWrite;		//where to put the decompressed data
            ash.cbDstLength = cbWrite;			//how big is that buffer

            mmr = acmStreamPrepareHeader(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                DPF1(1, "DXVB: Unable to prepare ACM stream header.  Error %lu \n", mmr);
                return E_FAIL;
            }

            
            mmr = acmStreamConvert(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
				DPF1(1, "DXVB:  Unable to convert wave data.  Error %lu \n", mmr);
                return hr;  
            }

			// Unlock the buffer
			hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
			if (FAILED(hr)) 
			{
				DPF(1, "DXVB: lpDirectSoundBuffer->Unlock failed.. \n");
				return hr;
			}

		    acmStreamUnprepareHeader(has, &ash, 0);
	        acmStreamClose(has, 0);
    }
    
	
	if (bNULLFORMAT){
		pDsbDesc->lpwfxFormat=NULL;
	}

    return hr;

}





HRESULT InternalCreateSoundBufferFromFile(LPDIRECTSOUND8 lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer) 
{
		HRESULT					hr=S_OK;
	    HANDLE                  hFile               = NULL;
	    HANDLE                  hFileMapping        = NULL;
	    DWORD                   cbWaveData;
		LPBYTE                  pbWaveData          = NULL;

		#pragma message("CreateFileW should be used for localization why wont it work")
		//hFile = CreateFileW(file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);        
		
		USES_CONVERSION;
		LPSTR pStrA=W2T(file);

		hFile = CreateFileA(pStrA, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);        
		
        if(INVALID_HANDLE_VALUE == hFile)
        {
            hFile = NULL;
        }

        if(!hFile)
        {
            RPF(DPFLVL_ERROR, "Unable to open file.  Error %lu", GetLastError());
            hr=STG_E_FILENOTFOUND;
			return hr;
        }

        if(hFile)
        {
            cbWaveData = GetFileSize(hFile, NULL);

            if(-1 == cbWaveData)
            {
                RPF(DPFLVL_ERROR, "Unable to get file size.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

        if(SUCCEEDED(hr))
        {
            hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbWaveData, NULL);

            if(INVALID_HANDLE_VALUE == hFileMapping)
            {
                hFileMapping = NULL;
            }
            
            if(!hFileMapping)
            {
                RPF(DPFLVL_ERROR, "Unable to create file mapping.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

        if(SUCCEEDED(hr))
        {
            pbWaveData = (LPBYTE)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, cbWaveData);

            if(!pbWaveData)
            {
                RPF(DPFLVL_ERROR, "Unable to map view of file.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

		if(SUCCEEDED(hr)) {
			hr=InternalCreateSoundBuffer(pDesc, pbWaveData, cbWaveData,lpDirectSound, lplpDirectSoundBuffer);
		}

	    if(pbWaveData)
        {
            UnmapViewOfFile(pbWaveData);
        }

        if(hFileMapping)
        {
            CloseHandle(hFileMapping);
        }
        
        if(hFile)
        {
            CloseHandle(hFile);
        }
		

		return hr;
    

}

HRESULT InternalCreateSoundBufferFromResource(LPDIRECTSOUND8 lpDirectSound,LPDSBUFFERDESC pDesc,HANDLE resHandle,WCHAR *resName,LPDIRECTSOUNDBUFFER8 *lplpDirectSoundBuffer)
{
    const LPCSTR            apszResourceTypeA[] = { "WAVE", "WAV" };
    const LPCWSTR           apszResourceTypeW[] = { L"WAVE", L"WAV" };
    UINT                    cResourceType       = 2;
    HRSRC                   hRsrc               = NULL;
    DWORD                   cbWaveData;
    LPBYTE                  pbWaveData          = NULL;
	HRESULT					hr=S_OK;
	
	LPCDSBUFFERDESC	pDsbDesc=pDesc;

    
	while(!hRsrc && cResourceType--)
    {
        hRsrc = FindResourceW((HINSTANCE)resHandle, resName, apszResourceTypeW[cResourceType]);            
    }

    if(!hRsrc)
    {
		RPF(DPFLVL_ERROR,"Unable to find resource.  Error %lu", GetLastError());
        hr = STG_E_FILENOTFOUND;
    }

    if(SUCCEEDED(hr))
    {
        cbWaveData = SizeofResource((HINSTANCE)resHandle, hRsrc);
        if(!cbWaveData)
        {

            RPF(DPFLVL_ERROR, "Unable to get resource size.  Error %lu", GetLastError());
            hr = E_FAIL;
        }
    }
        
    if(SUCCEEDED(hr))
    {                
        pbWaveData = (LPBYTE)LoadResource((HINSTANCE)resHandle, hRsrc);            
        if(!pbWaveData)
        {
            RPF(DPFLVL_ERROR, "Unable to load resource.  Error %lu", GetLastError());
            hr = E_FAIL;
        }
    }

	if(SUCCEEDED(hr)) {
		hr=InternalCreateSoundBuffer(pDesc, pbWaveData, cbWaveData,lpDirectSound, lplpDirectSoundBuffer);
	}

	//loadResource
   return hr;
}




HRESULT InternalSaveToFile(IDirectSoundBuffer *pBuff,BSTR file)
{
	WAVEFORMATEX waveFormat;
	DWORD dwWritten=0;
	DWORD dwBytes=0;
	LPBYTE lpByte=NULL;
	HRESULT hr;
	HANDLE hFile=NULL;

	if (!pBuff) return E_FAIL;
	if (!file) return E_INVALIDARG;

	
	pBuff->GetFormat(&waveFormat,sizeof(WAVEFORMATEX),NULL);


    

	USES_CONVERSION;
	LPSTR pStrA=W2T(file);

    hFile = CreateFile 
                (
                    pStrA,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                );
	if (INVALID_HANDLE_VALUE != hFile)
    {
			
		struct tag_FileHeader
		{
			DWORD       dwRiff;
			DWORD       dwFileSize;
			DWORD       dwWave;
			DWORD       dwFormat;
			DWORD       dwFormatLength;
			WORD        wFormatTag;
			WORD        nChannels;
			DWORD       nSamplesPerSec;
			DWORD       nAvgBytesPerSec;
			WORD        nBlockAlign;
			WORD        wBitsPerSample;
			DWORD       dwData;
			DWORD       dwDataLength;
		} FileHeader;    

		hr=pBuff->Lock(0,0,(void**)&lpByte,&dwBytes,NULL,NULL,DSBLOCK_ENTIREBUFFER);
		if FAILED(hr) {
			CloseHandle(hFile);
			return hr;
		}

        FileHeader.dwRiff             = 0x46464952;                // RIFF
        FileHeader.dwWave             = 0x45564157;                // WAVE
        FileHeader.dwFormat           = 0x20746D66;                // fmt_chnk
        FileHeader.dwFormatLength     = 16; 
	    FileHeader.wFormatTag         = WAVE_FORMAT_PCM;
	    FileHeader.nChannels          = waveFormat.nChannels ;
	    FileHeader.nSamplesPerSec     = waveFormat.nSamplesPerSec ;
	    FileHeader.wBitsPerSample     = waveFormat.wBitsPerSample ;
	    FileHeader.nBlockAlign        = FileHeader.wBitsPerSample / 8 * FileHeader.nChannels;
	    FileHeader.nAvgBytesPerSec    = FileHeader.nSamplesPerSec * FileHeader.nBlockAlign;
        FileHeader.dwData             = 0x61746164;					// data_chnk
        FileHeader.dwDataLength       = dwBytes;
        FileHeader.dwFileSize         = dwBytes + sizeof(FileHeader);


        WriteFile(hFile, &FileHeader, sizeof(FileHeader), &dwWritten, NULL);
        

        WriteFile(hFile, lpByte, dwBytes, &dwWritten, NULL);

		hr=pBuff->Unlock(lpByte,0,NULL,0); 

        CloseHandle(hFile);
    }
    else{
		return E_FAIL;
	}
    

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfilebinaryobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "XFileBinaryObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern BSTR XFILEGUIDtoBSTR(LPGUID);

C_dxj_DirectXFileBinaryObject::C_dxj_DirectXFileBinaryObject()
{
	m_pXFileBinary=NULL;
}
C_dxj_DirectXFileBinaryObject::~C_dxj_DirectXFileBinaryObject()
{
	if (m_pXFileBinary) m_pXFileBinary->Release();

}

HRESULT C_dxj_DirectXFileBinaryObject::create(IDirectXFileBinary *pBin,I_dxj_DirectXFileBinary **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectXFileBinaryObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileBinaryObject>;
	if( c == NULL ) return E_OUTOFMEMORY;

	c->Init(pBin);

	hr=c->QueryInterface(IID_I_dxj_DirectXFileBinary, (void**)ret);
	return hr;

}


HRESULT C_dxj_DirectXFileBinaryObject::Init(IDirectXFileBinary *pBin)
{
	m_pXFileBinary=pBin;
	return S_OK;
}

STDMETHODIMP C_dxj_DirectXFileBinaryObject::GetName( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	USES_CONVERSION;

	char szName[1024];
	DWORD dwSize=1024;
	hr=m_pXFileBinary->GetName(szName,&dwSize);
	if FAILED(hr) return hr;
	*name=T2BSTR(szName);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectXFileBinaryObject::GetId( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	GUID g;
	ZeroMemory(&g,sizeof(GUID));

	hr=m_pXFileBinary->GetId(&g);
	if FAILED(hr) return hr;

	*name=XFILEGUIDtoBSTR(&g);
	return hr;
}

STDMETHODIMP C_dxj_DirectXFileBinaryObject::GetSize( 
    /* [retval][out] */ long __RPC_FAR *size)
{
	HRESULT hr;

	hr=m_pXFileBinary->GetSize((DWORD*)size);
	
	return hr;
}

    

        
HRESULT C_dxj_DirectXFileBinaryObject::GetMimeType( 
            /* [retval][out] */ BSTR __RPC_FAR *mime)
{
	{
	HRESULT hr;
	USES_CONVERSION;
	const char **ppMime=NULL;

	hr=m_pXFileBinary->GetMimeType(ppMime);
	if FAILED(hr) return hr;
	if (!ppMime) return E_FAIL;

	*mime=T2BSTR(*ppMime);

	return S_OK;
}

}

        
HRESULT C_dxj_DirectXFileBinaryObject::Read( 
            /* [out][in] */ void __RPC_FAR *data,
            /* [in] */ long size,
            /* [retval][out] */ long __RPC_FAR *read)
{	
	HRESULT hr;
	__try
	{
		hr=m_pXFileBinary->Read(data,(DWORD)size,(DWORD*)read);

	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfilebinaryobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileBinaryObject :
		public I_dxj_DirectXFileBinary,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileBinaryObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileBinary)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileBinaryObject)

public:
		C_dxj_DirectXFileBinaryObject();	
		~C_dxj_DirectXFileBinaryObject();

        
        HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE GetId( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE GetSize( 
            /* [retval][out] */ long __RPC_FAR *size);
        
        HRESULT STDMETHODCALLTYPE GetMimeType( 
            /* [retval][out] */ BSTR __RPC_FAR *mime);
        
        HRESULT STDMETHODCALLTYPE Read( 
            /* [out][in] */ void __RPC_FAR *data,
            /* [in] */ long size,
            /* [retval][out] */ long __RPC_FAR *read);
        

		HRESULT Init(IDirectXFileBinary *pBin);

		 static HRESULT C_dxj_DirectXFileBinaryObject::create(IDirectXFileBinary *pBin, I_dxj_DirectXFileBinary **ret);		

		
private:

		IDirectXFileBinary *m_pXFileBinary;
	
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfileenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "XfileDataObj.h"
#include "XfileEnumObj.h"

	
extern HRESULT XFILEBSTRtoGUID(LPGUID,BSTR);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);

C_dxj_DirectXFileEnumObject::C_dxj_DirectXFileEnumObject()
{
	m_pXFileEnum=NULL;
}
C_dxj_DirectXFileEnumObject::~C_dxj_DirectXFileEnumObject()
{
	if (m_pXFileEnum) m_pXFileEnum->Release();
}

HRESULT C_dxj_DirectXFileEnumObject::create( IDirectXFileEnumObject *pEnum,I_dxj_DirectXFileEnum **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	
	//caller must addref
	

	C_dxj_DirectXFileEnumObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileEnumObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	c->Init(pEnum);
	hr=c->QueryInterface(IID_I_dxj_DirectXFileEnum, (void**)ret);
	return hr;

}


HRESULT C_dxj_DirectXFileEnumObject::Init( IDirectXFileEnumObject *pEnum)
{
	m_pXFileEnum=pEnum;
	return S_OK;
}
    


STDMETHODIMP C_dxj_DirectXFileEnumObject::GetNextDataObject( 
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) 
{
	HRESULT hr;
	IDirectXFileData *pXFData=NULL;
	hr=m_pXFileEnum->GetNextDataObject(&pXFData);
	if (hr==DXFILEERR_NOMOREOBJECTS){
		*ret=NULL;
		return S_OK;
	}

	if FAILED(hr) return hr;

	if (pXFData==NULL) {
		*ret=NULL;
		return S_OK;
	}

	hr=C_dxj_DirectXFileDataObject::create(pXFData,ret);
	if FAILED(hr)	pXFData->Release();
	return hr;

}
        
STDMETHODIMP C_dxj_DirectXFileEnumObject::GetDataObjectById( 
            /* [in] */ BSTR id,
            I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) 
{
	
	HRESULT hr;

	GUID g;
	ZeroMemory(&g,sizeof(GUID));
	hr=XFILEBSTRtoGUID(&g,id);
	if FAILED(hr) return hr;


	IDirectXFileData *pXFData=NULL;
	hr=m_pXFileEnum->GetDataObjectById(g,&pXFData);
	if FAILED(hr) return hr;

	if (pXFData==NULL) {
		*ret=NULL;
		return S_OK;
	}

	hr=C_dxj_DirectXFileDataObject::create(pXFData,ret);
	if FAILED(hr)	pXFData->Release();
	return hr;
}

        
STDMETHODIMP C_dxj_DirectXFileEnumObject::GetDataObjectByName( 
            /* [in] */ BSTR id,
            I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret)
{
	USES_CONVERSION;

	HRESULT hr;
	LPSTR szName=W2T(id);


	IDirectXFileData *pXFData=NULL;
	hr=m_pXFileEnum->GetDataObjectByName(szName,&pXFData);
	if FAILED(hr) return hr;

	if (pXFData==NULL) {
		*ret=NULL;
		return S_OK;
	}

	hr=C_dxj_DirectXFileDataObject::create(pXFData,ret);
	if FAILED(hr)	pXFData->Release();
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfiledataobj.cpp ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       xfiledataobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "XFileBinaryObj.h"
#include "XFileReferenceObj.h"
#include "XFileDataObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern BSTR XFILEGUIDtoBSTR(LPGUID);
extern HRESULT XFILEBSTRtoGUID(LPGUID,BSTR);


C_dxj_DirectXFileDataObject::C_dxj_DirectXFileDataObject()
{
	m_pXFileData=NULL;
}
C_dxj_DirectXFileDataObject::~C_dxj_DirectXFileDataObject()
{
	if (m_pXFileData) m_pXFileData->Release();
}


HRESULT C_dxj_DirectXFileDataObject::create( IDirectXFileData *pData,I_dxj_DirectXFileData **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectXFileDataObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileDataObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	
	hr=c->InternalSetObject((IUnknown*)pData);
	if FAILED(hr){
		delete c;
		return hr;
	}

        hr=IUNK(c)->QueryInterface(IID_I_dxj_DirectXFileData, (void**)ret);
	return hr;

}

HRESULT C_dxj_DirectXFileDataObject::InternalSetObject(IUnknown *pUnk)
{
	m_pXFileData=(IDirectXFileData*)pUnk;
	return S_OK;
}


HRESULT C_dxj_DirectXFileDataObject::InternalGetObject(IUnknown **pUnk)
{
	*pUnk=(IUnknown*)m_pXFileData;
	return S_OK;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::GetName( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	USES_CONVERSION;

	char szName[1024];
	DWORD dwSize=1024;
	hr=m_pXFileData->GetName(szName,&dwSize);
	if FAILED(hr) return hr;
	*name=T2BSTR(szName);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::GetId( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	GUID g;
	ZeroMemory(&g,sizeof(GUID));

	hr=m_pXFileData->GetId(&g);
	if FAILED(hr) return hr;

	*name=XFILEGUIDtoBSTR(&g);
	return hr;
}

STDMETHODIMP C_dxj_DirectXFileDataObject::GetDataSize( 
    /* [in] */ BSTR name,
    /* [retval][out] */ long __RPC_FAR *size)
{
	USES_CONVERSION;
	HRESULT hr;

	
	LPVOID  pvData=NULL;
	DWORD	dwSize=0;

	if (name[0]==0)
	{
		hr=m_pXFileData->GetData(NULL,&dwSize,&pvData);
	}
	else
	{
		LPSTR szName=W2T(name);
		hr=m_pXFileData->GetData(szName,&dwSize,&pvData);
	}

	*size=dwSize;

	return hr;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::GetData( 
    /* [in] */ BSTR name,
    /* [in] */ void __RPC_FAR *data)
{
	USES_CONVERSION;
	HRESULT hr;

	
	LPVOID  pvData=NULL;
	DWORD	dwSize=0;

	if (name[0]==0)
	{
		hr=m_pXFileData->GetData(NULL,&dwSize,&pvData);
	}
	else
	{
		LPSTR szName=W2T(name);
		hr=m_pXFileData->GetData(szName,&dwSize,&pvData);
	}

	__try{
		memcpy(data,pvData,dwSize);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

STDMETHODIMP C_dxj_DirectXFileDataObject::GetType( 
    /* [retval][out] */ BSTR __RPC_FAR *type)
{
		
	
	HRESULT hr;
	const GUID* pGUID;

	hr=m_pXFileData->GetType(&pGUID);
	if FAILED(hr) return hr;

	*type=XFILEGUIDtoBSTR((GUID*)pGUID);
	return hr;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::GetNextObject( 
    /* [retval][out] */ I_dxj_DirectXFileObject __RPC_FAR *__RPC_FAR *type)
{
	HRESULT hr;
	IDirectXFileObject *pObj=NULL;
	hr=m_pXFileData->GetNextObject(&pObj);

	if (hr==DXFILEERR_NOMOREOBJECTS){
			*type=NULL;
			return S_OK;
	}

	if FAILED(hr) return hr;

	LPUNKNOWN  pUnk=NULL;
	LPUNKNOWN  pCover=NULL;
	if (!pObj){
		*type=NULL;
		return S_OK;
	}

	hr=pObj->QueryInterface(IID_IDirectXFileData,(void**)&pUnk);
	if SUCCEEDED(hr)
	{
		pObj->Release();
		
		hr=C_dxj_DirectXFileDataObject::create((IDirectXFileData*)pUnk,(I_dxj_DirectXFileData**)&pCover);
		if FAILED(hr) 
		{
			pUnk->Release();
			return hr;
		}
		
		hr=pCover->QueryInterface(IID_I_dxj_DirectXFileObject,(void**)type);
		pCover->Release();
		if FAILED(hr) pUnk->Release();

		return hr;
	}

	
	hr=pObj->QueryInterface(IID_IDirectXFileBinary,(void**)&pUnk);
	if SUCCEEDED(hr)
	{
		pObj->Release();
		
		hr=C_dxj_DirectXFileBinaryObject::create((IDirectXFileBinary*)pUnk,(I_dxj_DirectXFileBinary**)&pCover);
		if FAILED(hr) 
		{
			pUnk->Release();
			return hr;
		}
		
		hr=pCover->QueryInterface(IID_I_dxj_DirectXFileObject,(void**)type);
		pCover->Release();
		if FAILED(hr) pUnk->Release();
		
		return hr;
	}

	
	
	hr=pObj->QueryInterface(IID_IDirectXFileDataReference,(void**)&pUnk);
	if SUCCEEDED(hr)
	{
		pObj->Release();
		
		hr=C_dxj_DirectXFileReferenceObject::create((IDirectXFileDataReference*)pUnk,(I_dxj_DirectXFileReference**)&pCover);
		if FAILED(hr) 
		{
			pUnk->Release();
			return hr;
		}
		
		hr=pCover->QueryInterface(IID_I_dxj_DirectXFileObject,(void**)type);
		pCover->Release();
		if FAILED(hr) pUnk->Release();
		
		return hr;
	}

	return E_NOTIMPL;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::AddDataObject( 
    /* [in] */ I_dxj_DirectXFileData __RPC_FAR *data)
{
	HRESULT hr;

	if (!data) return E_INVALIDARG;
	IDirectXFileData *pData=NULL;

	//note does not addref
	data->InternalGetObject((IUnknown**)&pData);
	if (!pData) return E_FAIL;

	hr=m_pXFileData->AddDataObject(pData);

	return hr;
	

}


STDMETHODIMP C_dxj_DirectXFileDataObject::AddDataReference( 
    /* [in] */ BSTR name,
    /* [in] */ BSTR guid)
{
	USES_CONVERSION;
	HRESULT hr;

	LPSTR  szName=NULL;
	GUID  *lpGuid=NULL;
	GUID   g;
	ZeroMemory(&g,sizeof(GUID));

	if (name[0]!=0)
	{
		szName=W2T(name);
	}

	if (guid[0]!=0)
	{
		hr=XFILEBSTRtoGUID(&g,guid);
		if FAILED(hr) return hr;
		lpGuid=&g;
	}

	hr=m_pXFileData->AddDataReference(szName,lpGuid);

	return hr;
}


STDMETHODIMP C_dxj_DirectXFileDataObject::AddBinaryObject( 
    /* [in] */ BSTR name,
    /* [in] */ BSTR guidObject,
    /* [in] */ BSTR MimeType,
    void __RPC_FAR *data,
    /* [in] */ long size)
{

	USES_CONVERSION;

	HRESULT hr;
	GUID gObj;
	GUID *lpGuid=NULL;
	LPSTR szMime=NULL;
	LPSTR szName=NULL;

	ZeroMemory(&gObj,sizeof(GUID));

	if (!data) return E_INVALIDARG;


	if ((guidObject) && (guidObject[0]!=0))
	{
		hr=XFILEBSTRtoGUID(&gObj,guidObject);
		if FAILED(hr) return hr;
		lpGuid=&gObj;	
	}



	if ((name) && (name[0]!=0))
	{
		szName=W2T(name);
	}


	if ((MimeType) && (MimeType[0]!=0))
	{
		szMime=W2T(MimeType);
	}

	IDirectXFileData *pData=NULL;


	__try
	{
		hr=m_pXFileData->AddBinaryObject(szName,lpGuid,szMime,data,size);
	}
	__except(1,1)
	{
		return E_INVALIDARG;
	}
		

	return hr;
	
}

STDMETHODIMP C_dxj_DirectXFileDataObject::GetDataFromOffset(
			/* [in] */ BSTR name,
			/* [in] */ long offset, 
			/* [in] */ long bytecount, 
			/* [in] */ void *data)	
{
	USES_CONVERSION;
	HRESULT hr;

	
	LPVOID  pvData=NULL;
	DWORD	dwSize=0;

	if (name[0]==0)
	{
		hr=m_pXFileData->GetData(NULL,&dwSize,&pvData);
	}
	else
	{
		LPSTR szName=W2T(name);
		hr=m_pXFileData->GetData(szName,&dwSize,&pvData);
	}

	__try{
		memcpy(data,&((char*)pvData)[offset],bytecount);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfiledataobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileDataObject :
		public I_dxj_DirectXFileData,
		public I_dxj_DirectXFileObject,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileDataObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileData)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileObject)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileDataObject)

public:
		C_dxj_DirectXFileDataObject();	
		~C_dxj_DirectXFileDataObject();

		HRESULT STDMETHODCALLTYPE InternalGetObject(IUnknown **pUnk);
		HRESULT STDMETHODCALLTYPE InternalSetObject(IUnknown *pUnk);

		HRESULT STDMETHODCALLTYPE InternalGetData( IUnknown **pprealInterface); 
            
		HRESULT STDMETHODCALLTYPE InternalSetData( IUnknown *prealInterface);            

        HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
       
        
        HRESULT STDMETHODCALLTYPE GetId( 
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE GetDataSize( 
            /* [in] */ BSTR name,
            /* [retval][out] */ long __RPC_FAR *size);
        
        HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ BSTR name,
            /* [in] */ void __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE GetType( 
            /* [retval][out] */ BSTR __RPC_FAR *type);
        
        HRESULT STDMETHODCALLTYPE GetNextObject( 
            /* [retval][out] */ I_dxj_DirectXFileObject __RPC_FAR *__RPC_FAR *type);
        
        HRESULT STDMETHODCALLTYPE AddDataObject( 
            /* [in] */ I_dxj_DirectXFileData __RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE AddDataReference( 
            /* [in] */ BSTR name,
            /* [in] */ BSTR guid);
        
        HRESULT STDMETHODCALLTYPE AddBinaryObject( 
            /* [in] */ BSTR name,
            /* [in] */ BSTR guidObject,
            /* [in] */ BSTR MimeType,
            void __RPC_FAR *data,
            /* [in] */ long size);

		HRESULT STDMETHODCALLTYPE	GetDataFromOffset(
			/* [in] */ BSTR name,
			/* [in] */ long offset, 
			/* [in] */ long bytecount, 
			/* [in] */ void *data);		

		static HRESULT C_dxj_DirectXFileDataObject::create( IDirectXFileData *pData,I_dxj_DirectXFileData **ret);		

private:
		IDirectXFileData *m_pXFileData;
	
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfileobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileObject :
		public I_dxj_DirectXFile,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFile)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileObject)

public:
		C_dxj_DirectXFileObject();	
		~C_dxj_DirectXFileObject();

      
        HRESULT STDMETHODCALLTYPE CreateEnumObject( 
            /* [in] */ BSTR __RPC_FAR filename,
            /* [retval][out] */ I_dxj_DirectXFileEnum __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE CreateSaveObject( 
            /* [in] */ BSTR filename,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectXFileSave __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE RegisterTemplates( 
            /* [in] */ void __RPC_FAR *temp,
            /* [in] */ long size) ;
        
        HRESULT STDMETHODCALLTYPE RegisterDefaultTemplates( void) ;
        
		HRESULT Init();    

		static HRESULT C_dxj_DirectXFileObject::create( I_dxj_DirectXFile **ret);		

private:
		IDirectXFile *m_pDirectXFile;
	
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfilereferenceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "xfileDataobj.h"
#include "XFileReferenceObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT XFILEBSTRtoGUID(LPGUID,BSTR);
extern BSTR XFILEGUIDtoBSTR(LPGUID);

C_dxj_DirectXFileReferenceObject::C_dxj_DirectXFileReferenceObject()
{
	m_pXFileReference=NULL;
}
C_dxj_DirectXFileReferenceObject::~C_dxj_DirectXFileReferenceObject()
{
	if (m_pXFileReference) m_pXFileReference->Release();
}

HRESULT C_dxj_DirectXFileReferenceObject::create( IDirectXFileDataReference *pRef,I_dxj_DirectXFileReference **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectXFileReferenceObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileReferenceObject>;
	if( c == NULL ) return E_OUTOFMEMORY;

	c->Init(pRef);

	hr=IUNK(c)->QueryInterface(IID_I_dxj_DirectXFileReference, (void**)ret);
	return hr;

}

HRESULT C_dxj_DirectXFileReferenceObject::Init(IDirectXFileDataReference *pRef)
{
	m_pXFileReference=pRef;
	return S_OK;
}



STDMETHODIMP C_dxj_DirectXFileReferenceObject::GetName( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	USES_CONVERSION;

	char szName[1024];
	DWORD dwSize=1024;
	hr=m_pXFileReference->GetName(szName,&dwSize);
	if FAILED(hr) return hr;
	*name=T2BSTR(szName);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectXFileReferenceObject::GetId( 
    /* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;
	GUID g;
	ZeroMemory(&g,sizeof(GUID));

	hr=m_pXFileReference->GetId(&g);
	if FAILED(hr) return hr;

	*name=XFILEGUIDtoBSTR(&g);
	return hr;
}

HRESULT C_dxj_DirectXFileReferenceObject::Resolve( 
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *obj) 
{
	HRESULT hr;
	IDirectXFileData *pData=NULL;
	hr=m_pXFileReference->Resolve(&pData);
	if FAILED(hr) return hr;
	if (!pData) 
	{
		*obj=NULL;
		return S_OK;
	}

	hr=C_dxj_DirectXFileDataObject::create(pData,obj);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfileenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileEnumObject :
		public I_dxj_DirectXFileEnum,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileEnumObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileEnum)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileEnumObject)

public:
		C_dxj_DirectXFileEnumObject();	
		~C_dxj_DirectXFileEnumObject();

         HRESULT STDMETHODCALLTYPE GetNextDataObject( 
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE GetDataObjectById( 
            /* [in] */ BSTR id,
            I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE GetDataObjectByName( 
            /* [in] */ BSTR id,
            I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret);

		HRESULT Init( IDirectXFileEnumObject *pEnum);
		 static HRESULT C_dxj_DirectXFileEnumObject::create(IDirectXFileEnumObject  *pEnum, I_dxj_DirectXFileEnum **ret);		

private:
		IDirectXFileEnumObject *m_pXFileEnum;
	
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\daytona\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\win9x\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfileobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
//#include "rmxftmpl.h"
#include "rmxfguid.h"

unsigned char D3DRM_XTEMPLATES2[] = {
        0x78, 0x6f, 0x66, 0x20, 0x30, 0x33, 0x30, 0x32, 0x62, 
        0x69, 0x6e, 0x20, 0x30, 0x30, 0x36, 0x34, 0x1f, 0, 0x1, 
        0, 0x6, 0, 0, 0, 0x48, 0x65, 0x61, 0x64, 0x65, 
        0x72, 0xa, 0, 0x5, 0, 0x43, 0xab, 0x82, 0x3d, 0xda, 
        0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
        0x33, 0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x6d, 
        0x61, 0x6a, 0x6f, 0x72, 0x14, 0, 0x28, 0, 0x1, 0, 
        0x5, 0, 0, 0, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x14, 
        0, 0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x66, 
        0x6c, 0x61, 0x67, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
        0x6f, 0x72, 0xa, 0, 0x5, 0, 0x5e, 0xab, 0x82, 0x3d, 
        0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 
        0xe4, 0x33, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 0, 
        0x78, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
        0, 0x79, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
        0, 0, 0x7a, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
        0x73, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x44, 0x3f, 0xf2, 
        0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 0x1, 0, 0, 
        0, 0x75, 0x14, 0, 0x2a, 0, 0x1, 0, 0x1, 0, 
        0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x34, 0x78, 0x34, 0xa, 0, 0x5, 0, 0x45, 0x3f, 
        0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
        0x33, 0x35, 0x94, 0xa3, 0x34, 0, 0x2a, 0, 0x1, 0, 
        0x6, 0, 0, 0, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 
        0xe, 0, 0x3, 0, 0x10, 0, 0, 0, 0xf, 0, 
        0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 
        0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
        0x41, 0xa, 0, 0x5, 0, 0xe0, 0x44, 0xff, 0x35, 0x7c, 
        0x6c, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 
        0xa3, 0x2a, 0, 0x1, 0, 0x3, 0, 0, 0, 0x72, 
        0x65, 0x64, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 
        0, 0, 0x67, 0x72, 0x65, 0x65, 0x6e, 0x14, 0, 0x2a, 
        0, 0x1, 0, 0x4, 0, 0, 0, 0x62, 0x6c, 0x75, 
        0x65, 0x14, 0, 0x2a, 0, 0x1, 0, 0x5, 0, 0, 
        0, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 
        0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0xa, 0, 0x5, 0, 
        0x81, 0x6e, 0xe1, 0xd3, 0x35, 0x78, 0xcf, 0x11, 0x8f, 0x52, 
        0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x2a, 0, 0x1, 0, 
        0x3, 0, 0, 0, 0x72, 0x65, 0x64, 0x14, 0, 0x2a, 
        0, 0x1, 0, 0x5, 0, 0, 0, 0x67, 0x72, 0x65, 
        0x65, 0x6e, 0x14, 0, 0x2a, 0, 0x1, 0, 0x4, 0, 
        0, 0, 0x62, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x49, 0x6e, 
        0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0xa, 0, 0x5, 0, 0x20, 0xb8, 0x30, 0x16, 0x42, 0x78, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0x5, 0, 0, 0, 0x69, 0x6e, 
        0x64, 0x65, 0x78, 0x14, 0, 0x1, 0, 0x9, 0, 0, 
        0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 
        0x1, 0, 0xa, 0, 0, 0, 0x69, 0x6e, 0x64, 0x65, 
        0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 
        0x6f, 0x6c, 0x65, 0x61, 0x6e, 0xa, 0, 0x5, 0, 0xa0, 
        0xa6, 0x7d, 0x53, 0x37, 0xca, 0xd0, 0x11, 0x94, 0x1c, 0, 
        0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 0, 0x9, 
        0, 0, 0, 0x74, 0x72, 0x75, 0x65, 0x66, 0x61, 0x6c, 
        0x73, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0x9, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 
        0x6e, 0x32, 0x64, 0xa, 0, 0x5, 0, 0x63, 0xae, 0x85, 
        0x48, 0xe8, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x1, 0, 0x7, 0, 0, 0, 0x42, 
        0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 
        0, 0, 0x75, 0x14, 0, 0x1, 0, 0x7, 0, 0, 
        0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 
        0x1, 0, 0, 0, 0x76, 0x14, 0, 0xb, 0, 0x1f, 
        0, 0x1, 0, 0xc, 0, 0, 0, 0x4d, 0x61, 0x74, 
        0x65, 0x72, 0x69, 0x61, 0x6c, 0x57, 0x72, 0x61, 0x70, 0xa, 
        0, 0x5, 0, 0x60, 0xae, 0x85, 0x48, 0xe8, 0x78, 0xcf, 
        0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
        0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 
        0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 0x75, 0x14, 
        0, 0x1, 0, 0x7, 0, 0, 0, 0x42, 0x6f, 0x6f, 
        0x6c, 0x65, 0x61, 0x6e, 0x1, 0, 0x1, 0, 0, 0, 
        0x76, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0xf, 
        0, 0, 0, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 
        0x46, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0xa, 0, 
        0x5, 0, 0xe1, 0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 
        0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x31, 0, 
        0x1, 0, 0x8, 0, 0, 0, 0x66, 0x69, 0x6c, 0x65, 
        0x6e, 0x61, 0x6d, 0x65, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x8, 0, 0, 0, 0x4d, 0x61, 0x74, 0x65, 
        0x72, 0x69, 0x61, 0x6c, 0xa, 0, 0x5, 0, 0x4d, 0xab, 
        0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 
        0xaf, 0x71, 0xe4, 0x33, 0x1, 0, 0x9, 0, 0, 0, 
        0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 0x41, 0x1, 
        0, 0x9, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x43, 
        0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x2a, 0, 0x1, 0, 
        0x5, 0, 0, 0, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x14, 
        0, 0x1, 0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6c, 
        0x6f, 0x72, 0x52, 0x47, 0x42, 0x1, 0, 0xd, 0, 0, 
        0, 0x73, 0x70, 0x65, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x43, 
        0x6f, 0x6c, 0x6f, 0x72, 0x14, 0, 0x1, 0, 0x8, 0, 
        0, 0, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x52, 0x47, 0x42, 
        0x1, 0, 0xd, 0, 0, 0, 0x65, 0x6d, 0x69, 0x73, 
        0x73, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x14, 
        0, 0xe, 0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 
        0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x8, 0, 0, 
        0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 0xa, 
        0, 0x5, 0, 0x5f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
        0, 0x1, 0, 0x12, 0, 0, 0, 0x6e, 0x46, 0x61, 
        0x63, 0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 
        0x64, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 
        0, 0x1, 0, 0x11, 0, 0, 0, 0x66, 0x61, 0x63, 
        0x65, 0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 
        0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 0, 0x12, 0, 
        0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x56, 0x65, 0x72, 
        0x74, 0x65, 0x78, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 
        0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0xd, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 
        0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x73, 0xa, 0, 0x5, 
        0, 0xc0, 0xc5, 0x1e, 0xed, 0xa8, 0xc0, 0xd0, 0x11, 0x94, 
        0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 0x29, 0, 0x1, 
        0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
        0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 
        0x14, 0, 0x34, 0, 0x1, 0, 0x9, 0, 0, 0, 
        0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x32, 0x64, 0x1, 
        0, 0xe, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 0x57, 
        0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0xe, 
        0, 0x1, 0, 0xf, 0, 0, 0, 0x6e, 0x46, 0x61, 
        0x63, 0x65, 0x57, 0x72, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75, 
        0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x11, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
        0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 
        0x72, 0x64, 0x73, 0xa, 0, 0x5, 0, 0x40, 0x3f, 0xf2, 
        0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xe, 0, 0, 
        0, 0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 
        0x6f, 0x6f, 0x72, 0x64, 0x73, 0x14, 0, 0x34, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
        0x73, 0x32, 0x64, 0x1, 0, 0xd, 0, 0, 0, 0x74, 
        0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6f, 0x72, 
        0x64, 0x73, 0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 
        0x6e, 0x54, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 
        0x6f, 0x72, 0x64, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x4d, 0x65, 
        0x73, 0x68, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 
        0x4c, 0x69, 0x73, 0x74, 0xa, 0, 0x5, 0, 0x42, 0x3f, 
        0xf2, 0xf6, 0x86, 0x76, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 
        0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 0, 
        0, 0, 0x6e, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 
        0x6c, 0x73, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 0, 
        0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x49, 0x6e, 0x64, 
        0x65, 0x78, 0x65, 0x73, 0x14, 0, 0x34, 0, 0x29, 0, 
        0x1, 0, 0xb, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
        0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xe, 0, 0x1, 
        0, 0xc, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 
        0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x73, 0xf, 0, 0x14, 
        0, 0xe, 0, 0x1, 0, 0x8, 0, 0, 0, 0x4d, 
        0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x4d, 
        0x65, 0x73, 0x68, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xa, 0, 0x5, 0, 0x43, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0x8, 0, 0, 0, 0x6e, 0x4e, 
        0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 0x74, 
        0x6f, 0x72, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x6f, 
        0x72, 0x6d, 0x61, 0x6c, 0x73, 0xe, 0, 0x1, 0, 0x8, 
        0, 0, 0, 0x6e, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 
        0x73, 0xf, 0, 0x14, 0, 0x29, 0, 0x1, 0, 0xc, 
        0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 0x65, 0x4e, 0x6f, 
        0x72, 0x6d, 0x61, 0x6c, 0x73, 0x14, 0, 0x34, 0, 0x1, 
        0, 0x8, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 
        0x61, 0x63, 0x65, 0x1, 0, 0xb, 0, 0, 0, 0x66, 
        0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xe, 0, 0x1, 0, 0xc, 0, 0, 0, 0x6e, 0x46, 
        0x61, 0x63, 0x65, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x73, 
        0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0x10, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 0x56, 0x65, 
        0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 
        0xa, 0, 0x5, 0, 0x21, 0xb8, 0x30, 0x16, 0x42, 0x78, 
        0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 
        0x29, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 0x56, 
        0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0xc, 0, 0, 
        0, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x43, 0x6f, 
        0x6c, 0x6f, 0x72, 0x1, 0, 0xc, 0, 0, 0, 0x76, 
        0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 
        0x73, 0xe, 0, 0x1, 0, 0xd, 0, 0, 0, 0x6e, 
        0x56, 0x65, 0x72, 0x74, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6f, 
        0x72, 0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x4, 0, 0, 0, 0x4d, 0x65, 0x73, 0x68, 
        0xa, 0, 0x5, 0, 0x44, 0xab, 0x82, 0x3d, 0xda, 0x62, 
        0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
        0x29, 0, 0x1, 0, 0x9, 0, 0, 0, 0x6e, 0x56, 
        0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0x14, 0, 0x34, 
        0, 0x1, 0, 0x6, 0, 0, 0, 0x56, 0x65, 0x63, 
        0x74, 0x6f, 0x72, 0x1, 0, 0x8, 0, 0, 0, 0x76, 
        0x65, 0x72, 0x74, 0x69, 0x63, 0x65, 0x73, 0xe, 0, 0x1, 
        0, 0x9, 0, 0, 0, 0x6e, 0x56, 0x65, 0x72, 0x74, 
        0x69, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0x29, 0, 
        0x1, 0, 0x6, 0, 0, 0, 0x6e, 0x46, 0x61, 0x63, 
        0x65, 0x73, 0x14, 0, 0x34, 0, 0x1, 0, 0x8, 0, 
        0, 0, 0x4d, 0x65, 0x73, 0x68, 0x46, 0x61, 0x63, 0x65, 
        0x1, 0, 0x5, 0, 0, 0, 0x66, 0x61, 0x63, 0x65, 
        0x73, 0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x6e, 
        0x46, 0x61, 0x63, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xe, 
        0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0x14, 0, 0, 0, 0x46, 
        0x72, 0x61, 0x6d, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 
        0x6f, 0x72, 0x6d, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0xa, 
        0, 0x5, 0, 0x41, 0x3f, 0xf2, 0xf6, 0x86, 0x76, 0xcf, 
        0x11, 0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x1, 
        0, 0x9, 0, 0, 0, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x34, 0x78, 0x34, 0x1, 0, 0xb, 0, 0, 0, 
        0x66, 0x72, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x74, 0x72, 0x69, 
        0x78, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x46, 0x72, 0x61, 0x6d, 0x65, 0xa, 0, 
        0x5, 0, 0x46, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 0x11, 
        0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 0, 
        0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 0, 
        0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 0x46, 0x6c, 
        0x6f, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73, 0xa, 0, 0x5, 
        0, 0xa9, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 0x8f, 
        0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 
        0, 0x7, 0, 0, 0, 0x6e, 0x56, 0x61, 0x6c, 0x75, 
        0x65, 0x73, 0x14, 0, 0x34, 0, 0x2a, 0, 0x1, 0, 
        0x6, 0, 0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 
        0xe, 0, 0x1, 0, 0x7, 0, 0, 0, 0x6e, 0x56, 
        0x61, 0x6c, 0x75, 0x65, 0x73, 0xf, 0, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 
        0x69, 0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 
        0x65, 0x79, 0x73, 0xa, 0, 0x5, 0, 0x80, 0xb1, 0x6, 
        0xf4, 0x3b, 0x7b, 0xcf, 0x11, 0x8f, 0x52, 0, 0x40, 0x33, 
        0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x4, 0, 0, 
        0, 0x74, 0x69, 0x6d, 0x65, 0x14, 0, 0x1, 0, 0x9, 
        0, 0, 0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
        0x79, 0x73, 0x1, 0, 0x6, 0, 0, 0, 0x74, 0x66, 
        0x6b, 0x65, 0x79, 0x73, 0x14, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0xc, 0, 0, 0, 0x41, 0x6e, 0x69, 0x6d, 
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4b, 0x65, 0x79, 0xa, 0, 
        0x5, 0, 0xa8, 0x46, 0xdd, 0x10, 0x5b, 0x77, 0xcf, 0x11, 
        0x8f, 0x52, 0, 0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 
        0x1, 0, 0x7, 0, 0, 0, 0x6b, 0x65, 0x79, 0x54, 
        0x79, 0x70, 0x65, 0x14, 0, 0x29, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x6e, 0x4b, 0x65, 0x79, 0x73, 0x14, 0, 
        0x34, 0, 0x1, 0, 0xe, 0, 0, 0, 0x54, 0x69, 
        0x6d, 0x65, 0x64, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4b, 0x65, 
        0x79, 0x73, 0x1, 0, 0x4, 0, 0, 0, 0x6b, 0x65, 
        0x79, 0x73, 0xe, 0, 0x1, 0, 0x5, 0, 0, 0, 
        0x6e, 0x4b, 0x65, 0x79, 0x73, 0xf, 0, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0x10, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4f, 0x70, 
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa, 0, 0x5, 0, 0xc0, 
        0x56, 0xbf, 0xe2, 0xf, 0x84, 0xcf, 0x11, 0x8f, 0x52, 0, 
        0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0xa, 
        0, 0, 0, 0x6f, 0x70, 0x65, 0x6e, 0x63, 0x6c, 0x6f, 
        0x73, 0x65, 0x64, 0x14, 0, 0x29, 0, 0x1, 0, 0xf, 
        0, 0, 0, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 
        0x6e, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x14, 0, 
        0xb, 0, 0x1f, 0, 0x1, 0, 0x9, 0, 0, 0, 
        0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xa, 
        0, 0x5, 0, 0x4f, 0xab, 0x82, 0x3d, 0xda, 0x62, 0xcf, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0xe, 
        0, 0x12, 0, 0x12, 0, 0x12, 0, 0xf, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xc, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 
        0x74, 0xa, 0, 0x5, 0, 0x50, 0xab, 0x82, 0x3d, 0xda, 
        0x62, 0xcf, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 
        0x33, 0xe, 0, 0x1, 0, 0x9, 0, 0, 0, 0x41, 
        0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0xf, 0, 
        0xb, 0, 0x1f, 0, 0x1, 0, 0xa, 0, 0, 0, 
        0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 
        0xa, 0, 0x5, 0, 0xa0, 0xee, 0x23, 0x3a, 0xb1, 0x94, 
        0xd0, 0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 
        0xe, 0, 0x1, 0, 0x6, 0, 0, 0, 0x42, 0x49, 
        0x4e, 0x41, 0x52, 0x59, 0xf, 0, 0xb, 0, 0x1f, 0, 
        0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 0x6c, 0xa, 
        0, 0x5, 0, 0xa1, 0xee, 0x23, 0x3a, 0xb1, 0x94, 0xd0, 
        0x11, 0xab, 0x39, 0, 0x20, 0xaf, 0x71, 0xe4, 0x33, 0x29, 
        0, 0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 
        0x6c, 0x73, 0x14, 0, 0x34, 0, 0x31, 0, 0x1, 0, 
        0x4, 0, 0, 0, 0x75, 0x72, 0x6c, 0x73, 0xe, 0, 
        0x1, 0, 0x5, 0, 0, 0, 0x6e, 0x55, 0x72, 0x6c, 
        0x73, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 0, 0x1, 
        0, 0xf, 0, 0, 0, 0x50, 0x72, 0x6f, 0x67, 0x72, 
        0x65, 0x73, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x65, 0x73, 0x68, 
        0xa, 0, 0x5, 0, 0x60, 0xc3, 0x63, 0x8a, 0x7d, 0x99, 
        0xd0, 0x11, 0x94, 0x1c, 0, 0x80, 0xc8, 0xc, 0xfa, 0x7b, 
        0xe, 0, 0x1, 0, 0x3, 0, 0, 0, 0x55, 0x72, 
        0x6c, 0x13, 0, 0x1, 0, 0xa, 0, 0, 0, 0x49, 
        0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x61, 0x74, 0x61, 0xf, 
        0, 0xb, 0, 0x1f, 0, 0x1, 0, 0x4, 0, 0, 
        0, 0x47, 0x75, 0x69, 0x64, 0xa, 0, 0x5, 0, 0xe0, 
        0x90, 0x27, 0xa4, 0x10, 0x78, 0xcf, 0x11, 0x8f, 0x52, 0, 
        0x40, 0x33, 0x35, 0x94, 0xa3, 0x29, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x31, 0x14, 0, 
        0x28, 0, 0x1, 0, 0x5, 0, 0, 0, 0x64, 0x61, 
        0x74, 0x61, 0x32, 0x14, 0, 0x28, 0, 0x1, 0, 0x5, 
        0, 0, 0, 0x64, 0x61, 0x74, 0x61, 0x33, 0x14, 0, 
        0x34, 0, 0x2d, 0, 0x1, 0, 0x5, 0, 0, 0, 
        0x64, 0x61, 0x74, 0x61, 0x34, 0xe, 0, 0x3, 0, 0x8, 
        0, 0, 0, 0xf, 0, 0x14, 0, 0xb, 0, 0x1f, 
        0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 0x72, 
        0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 
        0x79, 0xa, 0, 0x5, 0, 0xe0, 0x21, 0xf, 0x7f, 0xe1, 
        0xbf, 0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 
        0x71, 0x31, 0, 0x1, 0, 0x3, 0, 0, 0, 0x6b, 
        0x65, 0x79, 0x14, 0, 0x31, 0, 0x1, 0, 0x5, 0, 
        0, 0, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x14, 0, 0xb, 
        0, 0x1f, 0, 0x1, 0, 0xb, 0, 0, 0, 0x50, 
        0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x42, 0x61, 0x67, 
        0xa, 0, 0x5, 0, 0xe1, 0x21, 0xf, 0x7f, 0xe1, 0xbf, 
        0xd1, 0x11, 0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 
        0xe, 0, 0x1, 0, 0xe, 0, 0, 0, 0x53, 0x74, 
        0x72, 0x69, 0x6e, 0x67, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 
        0x74, 0x79, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0xe, 0, 0, 0, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 
        0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0xa, 0, 
        0x5, 0, 0xa0, 0x6a, 0x11, 0x98, 0xba, 0xbd, 0xd1, 0x11, 
        0x82, 0xc0, 0, 0xa0, 0xc9, 0x69, 0x72, 0x71, 0x1, 0, 
        0x4, 0, 0, 0, 0x47, 0x75, 0x69, 0x64, 0x1, 0, 
        0x12, 0, 0, 0, 0x67, 0x75, 0x69, 0x64, 0x45, 0x78, 
        0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x56, 0x69, 0x73, 0x75, 
        0x61, 0x6c, 0x14, 0, 0xe, 0, 0x12, 0, 0x12, 0, 
        0x12, 0, 0xf, 0, 0xb, 0, 0x1f, 0, 0x1, 0, 
        0xb, 0, 0, 0, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
        0x61, 0x6e, 0x64, 0x65, 0x64, 0xa, 0, 0x5, 0, 0xa0, 
        0x5e, 0x5d, 0x7f, 0x3a, 0xd5, 0xd1, 0x11, 0x82, 0xc0, 0, 
        0xa0, 0xc9, 0x69, 0x72, 0x71, 0x29, 0, 0x1, 0, 0xc, 
        0, 0, 0, 0x62, 0x52, 0x69, 0x67, 0x68, 0x74, 0x48, 
        0x61, 0x6e, 0x64, 0x65, 0x64, 0x14, 0, 0xb, 0
};

#define D3DRM_XTEMPLATE_BYTES 3278

#include "rmxfguid.h"

#include "XfileObj.h"
#include "XfileSaveObj.h"
#include "XfileEnumObj.h"

WCHAR *szXFileGuids[]={
	L"TID_D3DRMInfo",
	L"TID_D3DRMMesh",
	L"TID_D3DRMVector",
	L"TID_D3DRMMeshFace",
	L"TID_D3DRMMaterial",
	L"TID_D3DRMMaterialArray",
	L"TID_D3DRMFrame",
	L"TID_D3DRMFrameTransformMatrix",
	L"TID_D3DRMMeshMaterialList",
	L"TID_D3DRMMeshTextureCoords",
	L"TID_D3DRMMeshNormals",
	L"TID_D3DRMCoords2d",
	L"TID_D3DRMMatrix4x4",
	L"TID_D3DRMAnimation",
	L"TID_D3DRMAnimationSet",
	L"TID_D3DRMAnimationKey",
	L"TID_D3DRMFloatKeys",
	L"TID_D3DRMMaterialAmbientColor",
	L"TID_D3DRMMaterialDiffuseColor",
	L"TID_D3DRMMaterialSpecularColor",
	L"TID_D3DRMMaterialEmissiveColor",
	L"TID_D3DRMMaterialPower",
	L"TID_D3DRMColorRGBA",
	L"TID_D3DRMColorRGB",
	L"TID_D3DRMGuid",
	L"TID_D3DRMTextureFilename",
	L"TID_D3DRMTextureReference",
	L"TID_D3DRMIndexedColor",
	L"TID_D3DRMMeshVertexColors",
	L"TID_D3DRMMaterialWrap",
	L"TID_D3DRMBoolean",
	L"TID_D3DRMMeshFaceWraps",
	L"TID_D3DRMBoolean2d",
	L"TID_D3DRMTimedFloatKeys",
	L"TID_D3DRMAnimationOptions",
	L"TID_D3DRMFramePosition",
	L"TID_D3DRMFrameVelocity",
	L"TID_D3DRMFrameRotation",
	L"TID_D3DRMLight",
	L"TID_D3DRMCamera",
	L"TID_D3DRMAppData",
	L"TID_D3DRMLightUmbra",
	L"TID_D3DRMLightRange",
	L"TID_D3DRMLightPenumbra",
	L"TID_D3DRMLightAttenuation",
	L"TID_D3DRMInlineData",
	L"TID_D3DRMUrl",
	L"TID_D3DRMProgressiveMesh",
	L"TID_D3DRMExternalVisual",
	L"TID_D3DRMStringProperty",
	L"TID_D3DRMPropertyBag",
	L"TID_D3DRMRightHanded"
};

const GUID *XFileGuids[]={
	&TID_D3DRMInfo,
	&TID_D3DRMMesh,
	&TID_D3DRMVector,
	&TID_D3DRMMeshFace,
	&TID_D3DRMMaterial,
	&TID_D3DRMMaterialArray,
	&TID_D3DRMFrame,
	&TID_D3DRMFrameTransformMatrix,
	&TID_D3DRMMeshMaterialList,
	&TID_D3DRMMeshTextureCoords,
	&TID_D3DRMMeshNormals,
	&TID_D3DRMCoords2d,
	&TID_D3DRMMatrix4x4,
	&TID_D3DRMAnimation,
	&TID_D3DRMAnimationSet,
	&TID_D3DRMAnimationKey,
	&TID_D3DRMFloatKeys,
	&TID_D3DRMMaterialAmbientColor,
	&TID_D3DRMMaterialDiffuseColor,
	&TID_D3DRMMaterialSpecularColor,
	&TID_D3DRMMaterialEmissiveColor,
	&TID_D3DRMMaterialPower,
	&TID_D3DRMColorRGBA,
	&TID_D3DRMColorRGB,
	&TID_D3DRMGuid,
	&TID_D3DRMTextureFilename,
	&TID_D3DRMTextureReference,
	&TID_D3DRMIndexedColor,
	&TID_D3DRMMeshVertexColors,
	&TID_D3DRMMaterialWrap,
	&TID_D3DRMBoolean,
	&TID_D3DRMMeshFaceWraps,
	&TID_D3DRMBoolean2d,
	&TID_D3DRMTimedFloatKeys,
	&TID_D3DRMAnimationOptions,
	&TID_D3DRMFramePosition,
	&TID_D3DRMFrameVelocity,
	&TID_D3DRMFrameRotation,
	&TID_D3DRMLight,
	&TID_D3DRMCamera,
	&TID_D3DRMAppData,
	&TID_D3DRMLightUmbra,
	&TID_D3DRMLightRange,
	&TID_D3DRMLightPenumbra,
	&TID_D3DRMLightAttenuation,
	&TID_D3DRMInlineData,
	&TID_D3DRMUrl,
	&TID_D3DRMProgressiveMesh,
	&TID_D3DRMExternalVisual,
	&TID_D3DRMStringProperty,
	&TID_D3DRMPropertyBag,
	&TID_D3DRMRightHanded
};

#define NUM_XFILE_GUIDS 52

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);

HRESULT XFILEBSTRtoGUID(LPGUID lpG,BSTR strG)
{
	if (!strG) {
		ZeroMemory(lpG,sizeof(GUID));
		return S_OK;
	}

	if (strG[0]==0) {
		ZeroMemory(lpG,sizeof(GUID));
		return S_OK;
	}

	for(int i=0;i<NUM_XFILE_GUIDS;i++){
		if (0==_wcsicmp((WCHAR*)strG,szXFileGuids[i]))
		{
			memcpy(lpG,XFileGuids[i],sizeof(GUID));
			return S_OK;
		}		
	}

	return BSTRtoGUID (lpG,strG);
}

    #define GUIDS_EQUAL2(g,g2) (\
    	(g->Data1==g2->Data1) && \
    	(g->Data2==g2->Data2) && \
    	(g->Data3==g2->Data3) && \
    	(g->Data4[0]==g2->Data4[0]) && \
    	(g->Data4[1]==g2->Data4[1]) && \
    	(g->Data4[2]==g2->Data4[2]) && \
    	(g->Data4[3]==g2->Data4[3]) && \
    	(g->Data4[4]==g2->Data4[4]) && \
    	(g->Data4[5]==g2->Data4[5]) && \
    	(g->Data4[6]==g2->Data4[6]) && \
    	(g->Data4[7]==g2->Data4[7]) )

BSTR XFILEGUIDtoBSTR(LPGUID lpG)
{
	if (!lpG) return NULL;

	for(int i=0;i<NUM_XFILE_GUIDS;i++)
	{
		//
		if (GUIDS_EQUAL2(XFileGuids[i],lpG)){
			return SysAllocString(szXFileGuids[i]);	
		}
		
	}
	

	return GUIDtoBSTR(lpG);
}


C_dxj_DirectXFileObject::C_dxj_DirectXFileObject()
{
	m_pDirectXFile=NULL;
}
C_dxj_DirectXFileObject::~C_dxj_DirectXFileObject()
{
	if (m_pDirectXFile) m_pDirectXFile->Release();
}

HRESULT C_dxj_DirectXFileObject::create( I_dxj_DirectXFile **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	
	
	C_dxj_DirectXFileObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileObject>;
	if( c == NULL ) return E_OUTOFMEMORY;

	hr=c->Init();

	if FAILED(hr) {
		delete c;
		return hr;
	}
	hr=c->QueryInterface(IID_I_dxj_DirectXFile, (void**)ret);
	return hr;

}

HRESULT C_dxj_DirectXFileObject::Init ()
{
	HRESULT hr;
	hr=DirectXFileCreate(&m_pDirectXFile);	
	return hr;
}

HRESULT C_dxj_DirectXFileObject::CreateEnumObject( 
            /* [in] */ BSTR __RPC_FAR filename,
            /* [retval][out] */ I_dxj_DirectXFileEnum __RPC_FAR *__RPC_FAR *ret)
{
	USES_CONVERSION;
	HRESULT hr;

	LPSTR szName=W2T(filename);	
	LPDIRECTXFILEENUMOBJECT pEnum=NULL;

	hr=m_pDirectXFile->CreateEnumObject(szName,DXFILELOAD_FROMFILE ,&pEnum);
	if FAILED(hr) return hr;

	hr=C_dxj_DirectXFileEnumObject::create (pEnum,ret);
	if FAILED(hr) {
		pEnum->Release();
	}
	return hr;

}

        
HRESULT C_dxj_DirectXFileObject::CreateSaveObject( 
            /* [in] */ BSTR filename,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectXFileSave __RPC_FAR *__RPC_FAR *ret)
{
	USES_CONVERSION;
	HRESULT hr;

	LPSTR szName=W2T(filename);	
	LPDIRECTXFILESAVEOBJECT pSave=NULL;

	hr=m_pDirectXFile->CreateSaveObject(szName,(DWORD)flags, &pSave);
	if FAILED(hr) return hr;

	//Note ::create does addref pSave on success
	hr=C_dxj_DirectXFileSaveObject::create (pSave,ret);
	if (pSave) pSave->Release();

	return hr;
}

        
HRESULT C_dxj_DirectXFileObject::RegisterTemplates( 
            /* [in] */ void __RPC_FAR *temp,
            /* [in] */ long size)
{
	HRESULT hr;

	__try{

		hr=m_pDirectXFile->RegisterTemplates(temp,(DWORD)size);
		if FAILED(hr) return hr;
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

        
HRESULT C_dxj_DirectXFileObject::RegisterDefaultTemplates( void) 
{
	HRESULT hr;
	hr=m_pDirectXFile->RegisterTemplates(D3DRM_XTEMPLATES2,D3DRM_XTEMPLATE_BYTES );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfilereferenceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileReferenceObject :
		public I_dxj_DirectXFileReference,
		public I_dxj_DirectXFileObject,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileReferenceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileReference)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileObject)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileReferenceObject)

public:
		C_dxj_DirectXFileReferenceObject();	
		~C_dxj_DirectXFileReferenceObject();

		HRESULT STDMETHODCALLTYPE GetName( /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
		HRESULT STDMETHODCALLTYPE GetId( 	 /* [retval][out] */ BSTR __RPC_FAR *name);
        
		HRESULT STDMETHODCALLTYPE Resolve( /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *obj) ;
        

		HRESULT Init(IDirectXFileDataReference *pref);

		 static HRESULT C_dxj_DirectXFileReferenceObject::create( IDirectXFileDataReference *pref, I_dxj_DirectXFileReference **ret);		


private:
		IDirectXFileDataReference *m_pXFileReference;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfilesaveobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"

#include "dxfile.h"
#include "XFileSaveObj.h"
#include "XFileDataObj.h"



extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);

C_dxj_DirectXFileSaveObject::C_dxj_DirectXFileSaveObject()
{
	m_pXfileSave=NULL;
}
C_dxj_DirectXFileSaveObject::~C_dxj_DirectXFileSaveObject()
{
	if (m_pXfileSave) m_pXfileSave->Release();
} 

HRESULT C_dxj_DirectXFileSaveObject::create( IDirectXFileSaveObject *pSave, I_dxj_DirectXFileSave **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;	
	if (!pSave) return E_INVALIDARG;

	C_dxj_DirectXFileSaveObject *c=NULL;
	c=new CComObject<C_dxj_DirectXFileSaveObject>;
	if( c == NULL ) return E_OUTOFMEMORY;

	c->m_pXfileSave=pSave;
	pSave->AddRef();

	hr=c->QueryInterface(IID_I_dxj_DirectXFileSave, (void**)ret);
	return hr;

}



STDMETHODIMP C_dxj_DirectXFileSaveObject::SaveTemplates( 
            /* [in] */ long count,
            SAFEARRAY __RPC_FAR * __RPC_FAR *templateGuids) 
{
	HRESULT hr;
	GUID *pGuids=NULL;
	GUID **ppGuids=NULL;

	if (count<=0) return E_INVALIDARG;
	if (!templateGuids) return E_INVALIDARG;
	if (!((SAFEARRAY*)*templateGuids)->pvData) return E_INVALIDARG;

	pGuids=(GUID*)alloca(sizeof(GUID)*count);
	ppGuids=(GUID**)alloca(sizeof(GUID*)*count);
	if (!pGuids) return E_OUTOFMEMORY;	

	__try 
        {	
	   for (long i=0;i<count;i++)
           {
  	   	hr=BSTRtoGUID(&(pGuids[i]),((BSTR*)(((SAFEARRAY*)*templateGuids)->pvData))[i]);
	   	if FAILED(hr) return E_INVALIDARG;
		ppGuids[i]=&(pGuids[i]);
           }
        }
	__except(1,1)
        {
	   return E_INVALIDARG;
        }

	hr=m_pXfileSave->SaveTemplates((DWORD)count,(const GUID **) ppGuids);

	return hr;

}
        
STDMETHODIMP C_dxj_DirectXFileSaveObject::CreateDataObject( 
            /* [in] */ BSTR templateGuid,
            /* [in] */ BSTR name,
            /* [in] */ BSTR dataTypeGuid,
            /* [in] */ long bytecount,
            /* [in] */ void __RPC_FAR *data,
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) 
{
	USES_CONVERSION;

	HRESULT hr;
	IDirectXFileData *pXFileData=NULL;
	GUID *lpGuidTemplate=NULL;
	GUID *lpGuidDataType=NULL;
	char *szName=NULL;

	//use lazy evaluation
	if ((templateGuid)&&(templateGuid[0]!=0)) 
	{
	  lpGuidTemplate=(GUID*)alloca(sizeof(GUID));
	  ZeroMemory(lpGuidTemplate,sizeof(GUID));
	  hr=BSTRtoGUID(lpGuidTemplate,templateGuid);
	  if FAILED(hr) return hr;
	}

	if (!lpGuidTemplate) return E_INVALIDARG;
	

	//use lazy evaluation
	if ((name)&&(name[0]!=0))
	{	
	   szName=W2T(name);
	}

	//use lazy evaluation
	if ((dataTypeGuid)&&(dataTypeGuid[0]!=0)) 
	{
	  lpGuidDataType=(GUID*)alloca(sizeof(GUID));
	  ZeroMemory(lpGuidDataType,sizeof(GUID));
	  hr=BSTRtoGUID(lpGuidDataType,dataTypeGuid);
	  if FAILED(hr) return hr;
	}

	__try {
		hr=m_pXfileSave->CreateDataObject(*lpGuidTemplate,szName,lpGuidDataType,(DWORD)bytecount,data,&pXFileData);
	}
	__except (1,1)
	{
		return E_INVALIDARG;
	}


	if FAILED(hr) return hr;
		
	hr=C_dxj_DirectXFileDataObject::create(pXFileData,ret);
	
	return hr;
}
 
       
STDMETHODIMP C_dxj_DirectXFileSaveObject::SaveData( 
            /* [in] */ I_dxj_DirectXFileData __RPC_FAR *dataObj) 
{
	HRESULT hr;

	if (!dataObj) return E_INVALIDARG;
	
	IDirectXFileData *pDataObj=NULL;

	dataObj->InternalGetObject((IUnknown**)&pDataObj);	

	hr=m_pXfileSave->SaveData(pDataObj);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\xfilesaveobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectXFileSaveObject :
		public I_dxj_DirectXFileSave,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectXFileSaveObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectXFileSave)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectXFileSaveObject)

public:
	C_dxj_DirectXFileSaveObject();	
	~C_dxj_DirectXFileSaveObject();

	HRESULT STDMETHODCALLTYPE SaveTemplates( 
            /* [in] */ long count,
            SAFEARRAY __RPC_FAR * __RPC_FAR *templateGuids) ;
        
        HRESULT STDMETHODCALLTYPE CreateDataObject( 
            /* [in] */ BSTR templateGuid,
            /* [in] */ BSTR name,
            /* [in] */ BSTR dataTypeGuid,
            /* [in] */ long bytecount,
            /* [in] */ void __RPC_FAR *data,
            /* [retval][out] */ I_dxj_DirectXFileData __RPC_FAR *__RPC_FAR *ret) ;
        
	HRESULT STDMETHODCALLTYPE SaveData( 
            /* [in] */ I_dxj_DirectXFileData __RPC_FAR *dataObj) ;
        

	static HRESULT C_dxj_DirectXFileSaveObject::create( IDirectXFileSaveObject *pSave ,I_dxj_DirectXFileSave **ret);		

	
	IDirectXFileSaveObject *m_pXfileSave;	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\advanced.cpp ===
/*
File:       Advanced.cpp
Project:    Joystick Control Panel OLE Client
Author: Brycej
Date:       02/07/97
Comments:
    Window proc for Avanced page in cpanel

Copyright (c) 1997, Microsoft Corporation
*/
// This is necessary LVS_EX_INFOTIP
/*
#if (_WIN32_IE < 0x0500)
#undef _WIN32_IE
#define  _WIN32_IE  0x0500
#endif
*/

#include <afxcmn.h>
#include <windowsx.h>

#include <cpl.h>

#include <winuser.h>  // For RegisterDeviceNotification stuff!
#include <dbt.h>      // for DBT_ defines!!!

#include "cpanel.h"
#include "hsvrguid.h"

#include "resource.h"
#include "joyarray.h"

// MyListCtrl prototypes
#include "inplace.h"

#define USE_DEFAULT     0x1000      // If this bit is set, the device is going to use GCDEF!
#define SHOW_DEFAULT 0x2000     // Show default check box if clsidConfig is != CLSID_LegacyServer

// constants
const short NO_ITEM     = -1;                                    

#define DEVICE_ID       0 
#define DEVICE_FRIENDLY 1
#define DEVICE_TYPE     2
#define DEVICE_PORT     3

LPCWSTR lpMSANALOG_VXD = L"MSANALOG.VXD";
LPTSTR  lpstrNone;

#define ADVANCED_ID_COLUMN      0
#define ADVANCED_DEVICE_COLUMN  1

extern const DWORD gaHelpIDs[];

// externs for arguements!
extern BYTE nID, nStartPageDef, nStartPageCPL;

// Update flag!
extern short nFlags;

// local (module-scope) variables
HWND hAdvListCtrl;

#ifdef _UNICODE
static PVOID hAdvNotifyDevNode;
#endif

extern short iItem;
static HWND ghDlg;

//static UINT JoyCfgChangedMsg;
static BOOL bProcess;

// Message Procedures for handling VK_DELETE in Advanced window
static WNDPROC fpMainWndProc;
static BOOL WINAPI SubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Message Procedures for handling the VK_ENTER/VK_DELETE in Adv Window
static WNDPROC fpPageWndProc;
static BOOL WINAPI KeySubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

short iAdvItem = NO_ITEM;   // index of selected item
char  iGameportDriverItem = NO_ITEM;
short nOldID;

// externs
extern IDirectInputJoyConfig *pDIJoyConfig;
extern LPDIRECTINPUT lpDIInterface;

extern BYTE nGameportBus;
extern PJOY pAssigned[MAX_ASSIGNED];  // List of assigned devices
extern BYTE nAssigned;                // Number of elements in pAssigned array
extern HINSTANCE ghInstance;

#ifdef WINNT
    // external function defined in CPANEL.CPP
    extern void RunWDMJOY            ( void );
#endif

// local message handlers
static BOOL OnInitDialog    (HWND, HWND, LPARAM);
static void OnCommand       (HWND, int, HWND, UINT);
static BOOL OnNotify           (HWND, WPARAM, LPNMHDR);
static void OnDestroy       (HWND);
static void OnAdvHelp       (LPARAM);
static void OnContextMenu   (WPARAM wParam, LPARAM lParam);
static void OnListviewContextMenu ( LPARAM lParam );

// local utility fns
static BOOL SetActiveGlobalDriver ( void );
static BOOL AdvUpdateListCtrl        ( void );
static BOOL UpdateChangeListCtrl  ( HWND hCtrl );

#ifndef _UNICODE
static void PopulateGlobalPortDriverComboBox( void );
extern WCHAR *pwszGameportDriverArray[MAX_GLOBAL_PORT_DRIVERS];
extern BYTE nGameportDriver;          // Global Port Driver Enumeration Counter
    #define POLL_FLAGS_REG_STR  TEXT("PollFlags")
#endif

static void LaunchChange             ( HWND     hTmp );
int CALLBACK CompareIDItems      (LPARAM item1, LPARAM item2, LPARAM uDirection);

void EditSubLabel( BYTE nItem, BYTE nCol );

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    AdvancedProc(HWND hDlg, ULONG uMsg, WPARAM wParam,  LPARAM lParam)
//
// PARAMETERS:  hDlg    - 
//             uMsg    - 
//             wParam  -
//             lParam  -
//
// PURPOSE:     Main callback function for "Advanced"  sheet
///////////////////////////////////////////////////////////////////////////////

BOOL WINAPI AdvancedProc(HWND hDlg, ULONG uMsg, WPARAM wParam,  LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_ACTIVATEAPP:
        if( wParam )
            SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
        break;

    case WM_DEVICECHANGE:
        switch( (UINT)wParam )
        {
        case DBT_DEVICEARRIVAL:
//         case DBT_DEVICEREMOVECOMPLETE:
            // Clear the old "known devices" list
            nFlags |= UPDATE_ALL;

            // Clear pAssigned 
            while( nAssigned )
            {
                if( pAssigned[--nAssigned] )
                {
                    delete[] (pAssigned[nAssigned]);

                    pAssigned[nAssigned] = 0;
                }
            }

            // Rebuild the "known devices" list - pAssigned
            lpDIInterface->EnumDevices(DIDEVTYPE_JOYSTICK, (LPDIENUMDEVICESCALLBACK)DIEnumDevicesProc, (LPVOID)hDlg, DIEDFL_ALLDEVICES);

            AdvUpdateListCtrl();
            break;
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hDlg), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        if( !HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, OnInitDialog) )
        {
            // Fix #108983 NT, Remove Flash on Error condition.
            SetWindowPos(::GetParent(hDlg), HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
            DestroyWindow(hDlg);
        }
        return(TRUE);

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, OnCommand);
        return(TRUE);

    case WM_DESTROY:
        return(HANDLE_WM_DESTROY(hDlg, wParam, lParam, OnDestroy));

    case WM_NOTIFY:
        return(HANDLE_WM_NOTIFY(hDlg, wParam, lParam, OnNotify));

    case WM_HELP:
        OnAdvHelp(lParam);
        return(TRUE);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam, lParam);
        return(TRUE);

    default:
        break;
    }
    return(0);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
//
// PARAMETERS:  hDlg    - 
//                 hWnd    - 
//                 lParam  -
//
// PURPOSE:     WM_INITDIALOG message handler
///////////////////////////////////////////////////////////////////////////////
BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
{
    bProcess = TRUE;

    // Just in case Advanced is launched as the startup page!
    if( !lpDIInterface )
    {
        if( FAILED(DirectInputCreate(ghInstance, DIRECTINPUT_VERSION, &lpDIInterface, NULL)) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: DirectInputCreate() failed\n"));
#endif
            Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
            return(FALSE);
        }

        if( !pDIJoyConfig )
        {
            if( FAILED(lpDIInterface->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID*)&pDIJoyConfig)) )
            {
#ifdef _DEBUG
                OutputDebugString (TEXT("JOY.CPL: CoCreateInstance Failed... Closing CPL!\n"));
#endif
                Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);

                return(FALSE);
            }

            VERIFY(SUCCEEDED(pDIJoyConfig->SetCooperativeLevel(hDlg, DISCL_EXCLUSIVE | DISCL_BACKGROUND)));

            // Enumerate all the Types! 
            VERIFY(SUCCEEDED(pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL)));

            // If you're here, you came in via the CMD line arg and you need to enumerate for devices so...
            lpDIInterface->EnumDevices(DIDEVTYPE_JOYSTICK, (LPDIENUMDEVICESCALLBACK)DIEnumDevicesProc, (LPVOID)hDlg, DIEDFL_ALLDEVICES);
        }
    }

    // if we find an object, then enable the Change... button
    //HWND hChangeCtrl = GetDlgItem(hDlg, IDC_ADV_CHANGE);

    // Determine Privilege and disable Change accordingly!
    if( pDIJoyConfig->Acquire() == DIERR_INSUFFICIENTPRIVS )
    {
        // Assign here because the Advanced sheet could be launched first
        // via command line args!
        nFlags |= USER_MODE;

        //PostEnableWindow(hChangeCtrl, FALSE);
    }
#ifdef WINNT
    else
    {
        // Run the WDMJOY.INF file!!!
        RunWDMJOY();
    }
#endif

    // set the global dialog handle
    ghDlg = hDlg;

    // blj: TODO: Make advanced page update on JOYCONFIGCHANGED message!
    // JOY_CONFIGCHANGED_MSGSTRING defined in MMDDK.H   
    //JoyCfgChangedMsg = RegisterWindowMessage(JOY_CONFIGCHANGED_MSGSTRING);

    // initialize our list control
    hAdvListCtrl = GetDlgItem(hDlg, IDC_ADV_LIST_DEVICE);

#ifdef _UNICODE
    // Set the Attributes!                                                   Removed LVS_EX_ONECLICKACTIVATE per GSeirra  | LVS_EX_INFOTIP
    ::SendMessage(hAdvListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP);
#else
    ::SendMessage(hAdvListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
#endif

    RECT rc;
    GetClientRect(hAdvListCtrl, &rc);
    rc.left = (short)((rc.right-GetSystemMetrics(SM_CXVSCROLL))/5);

    // Set up the columns!
#ifdef _UNICODE
    InsertColumn(hAdvListCtrl, DEVICE_ID,         IDS_ADV_DEVICE_HEADING,  (USHORT)(rc.left >> 1 ));
    InsertColumn(hAdvListCtrl, DEVICE_FRIENDLY, IDS_ADV_DEVICE_FRIENDLY, (USHORT)(rc.left + (rc.left>>1)));
    InsertColumn(hAdvListCtrl, DEVICE_TYPE,       IDS_ADV_GAME_CONTROLLERS,    (USHORT)(rc.left << 1    ));
    InsertColumn(hAdvListCtrl, DEVICE_PORT,       IDS_ADV_DEVICE_PORT,     (USHORT)(rc.left         ));

    // Remove the Global Port Driver stuff!!!
    const USHORT nCtrlArray[] = {IDC_TEXT_PORTDRIVER, IDC_COMBO1, IDC_ADV_GRP2, IDC_TEXT_DRIVER};
    BYTE nIndex = sizeof(nCtrlArray)/sizeof(short);

    while( DestroyWindow(GetDlgItem(hDlg, nCtrlArray[--nIndex])) );

#else
    rc.right = (rc.left << 1) + (rc.left >> 2);
    InsertColumn(hAdvListCtrl, DEVICE_ID,         IDS_ADV_DEVICE_HEADING,  (USHORT)(rc.left >> 1));
    InsertColumn(hAdvListCtrl, DEVICE_FRIENDLY, IDS_ADV_DEVICE_FRIENDLY, (USHORT)rc.right);
    InsertColumn(hAdvListCtrl, DEVICE_TYPE,       IDS_ADV_GAME_CONTROLLERS,    (USHORT)rc.right);
#endif


    lpstrNone = new TCHAR[STR_LEN_32];
    ASSERT (lpstrNone);

    // everyone needs the "None" string so I've loaded it here!
    VERIFY(LoadString(ghInstance, IDS_NONE, lpstrNone, STR_LEN_32));

    fpMainWndProc = (WNDPROC)SetWindowLongPtr(hAdvListCtrl, GWLP_WNDPROC, (LONG_PTR)SubClassProc);

    // Only center the dialog if this was the page that we started on!
    if( nStartPageCPL == 1 )
    {
        HWND hParentWnd = GetParent(hDlg);

        GetWindowRect(hParentWnd, &rc);

        // Centre the Dialog!
        SetWindowPos(hParentWnd, NULL, 
                     (GetSystemMetrics(SM_CXSCREEN) - (rc.right-rc.left))>>1, 
                     (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom-rc.top))>>1, 
                     NULL, NULL, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        // Do that move button thing!
        MoveOK(hParentWnd);

        // Set the Update flag...
        nFlags |= UPDATE_FOR_ADV;
    }

    // the user is requesting that the CPL be shown
    // and an extention associated with nID be Launched.
    if( nID < NUMJOYDEVS )
    {
        LaunchExtention(hDlg);

        // Zero out so you don't do it twice!
        nID = 0;
    }

    // SetActive will use this flag to make sure that the ListCtrl is populated!
    nFlags |= UPDATE_FOR_ADV;

    return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
//
// PARAMETERS:  hDlg    - 
//             id      - 
//             hWndCtl -
//             code    -
//
// PURPOSE:     WM_COMMAND message handler
///////////////////////////////////////////////////////////////////////////////
void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
{
    // Hit the "What's This..."
    switch( id )
    {
    case IDC_RENAME:
        // Only SubClass when we need to!
        if( !(nFlags & USER_MODE) )
        {
            HWND hParentWnd = GetParent(GetDlgItem(hDlg, IDC_ADV_LIST_DEVICE));
            // this is required because the CPL can be launched via RUNDLL32
            if( ::IsWindow(hParentWnd) )
                hParentWnd = GetParent(hParentWnd);

            if( !fpPageWndProc )
                fpPageWndProc = (WNDPROC)SetWindowLongPtr(hParentWnd, GWLP_WNDPROC, (LONG_PTR)KeySubClassProc);

            nFlags |= UPDATE_INPROCESS;

            // Find the column as it Could have been moved!
            LPTSTR szName = new (TCHAR[STR_LEN_32]);
            ASSERT (szName);

            // First, Load the string of the column we are looking to find!
            if( LoadString(ghInstance, IDS_ADV_DEVICE_FRIENDLY, szName, STR_LEN_32) )
            {
                // Now, traverse the columns to find the one with the title that matches szName!
                HWND hHeader = GetDlgItem(hAdvListCtrl, 0);

                BYTE nColumns = (BYTE)::SendMessage(hHeader, HDM_GETITEMCOUNT, 0, 0L);


                HDITEM *phdItem = new (HDITEM);
                ASSERT (phdItem);

                ZeroMemory(phdItem, sizeof(HD_ITEM));


                phdItem->pszText      = new TCHAR[STR_LEN_32];
                ASSERT (phdItem->pszText);

                phdItem->cchTextMax = STR_LEN_32;
                phdItem->mask         = HDI_TEXT | HDI_ORDER;

                do
                {
                    ::SendMessage(hHeader, HDM_GETITEM, (WPARAM)(int)--nColumns, (LPARAM)(LPHDITEM)phdItem);

                    if( _tcscmp(phdItem->pszText, szName) == 0 )
                    {
                        nColumns = (BYTE)phdItem->iOrder;
                        break;  
                    }
                } while( nColumns );

                if( phdItem->pszText )
                    delete[] (phdItem->pszText);

                if( phdItem )
                    delete (phdItem);

                EditSubLabel( (BYTE)iAdvItem, nColumns );
            }

            if( szName )
                delete[] (szName);
        }
        break;

    case IDS_WHATSTHIS:
        {
            // point to help file
            LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
            ASSERT (pszHelpFileName);

            if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
                WinHelp((HWND)hAdvListCtrl, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
            else OutputDebugString(TEXT("JOY.CPL: Advanced.cpp: OnCommand: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

            if( pszHelpFileName )
                delete[] (pszHelpFileName);
        }
        break;

#ifndef _UNICODE
        // this is the handler for the Global Port Driver Combo box
    case IDC_COMBO1:
        if( code == CBN_SELCHANGE )
            SetActiveGlobalDriver();
        break;

        // handler for PollFlags entry in the registry for the Global Port Driver
    case IDC_POLLFLAGS:
        if( iGameportDriverItem == NO_ITEM )
            break;

        if( SUCCEEDED(pDIJoyConfig->Acquire()) )
        {
            HKEY hKey; 

            VERIFY(SUCCEEDED(pDIJoyConfig->OpenTypeKey(pwszGameportDriverArray[iGameportDriverItem], KEY_ALL_ACCESS, &hKey)));

            // this entry is only valid if the user is running MSANALOG.VXD!
            DWORD nFlags = (IsDlgButtonChecked(hDlg, id)) ? 1 : 0;

            RegSetValueEx(hKey, POLL_FLAGS_REG_STR, 0, REG_BINARY, (PBYTE)&nFlags, sizeof(nFlags));

            RegCloseKey(hKey);

            pDIJoyConfig->SendNotify();

            pDIJoyConfig->Unacquire();
        }
        break;
#endif // _UNICODE

        // this is the handler for the Device list box
    case IDC_ADV_LIST_DEVICE:
        // Fall into Change on DBLCLK
        if( code != LBN_DBLCLK )
            break;

    case IDC_ADV_CHANGE:
        if( nFlags & USER_MODE )
            Error((short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
        else
        {
            LaunchChange(hDlg);           
        }
        break;

    case IDC_ADV_USEOEMPAGE:
        if( !nAssigned ) {
            break;
        }

        if( IsWindowVisible(GetDlgItem(hDlg,IDC_ADV_USEOEMPAGE)) )
        {
            // Boy are you going to pay the price for making that selection...
            LPDIJOYCONFIG_DX5 lpDIJoyConfig = new (DIJOYCONFIG_DX5);
            ASSERT (lpDIJoyConfig);

            ZeroMemory(lpDIJoyConfig, sizeof(DIJOYCONFIG_DX5));

            lpDIJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);

            // Get the index from the selected item (iAdvItem)
            BYTE n1 = (BYTE)GetItemData(hAdvListCtrl, (BYTE)iAdvItem);
            BYTE n = 0;
            do
            {
                if( pAssigned[n] && (n1 == pAssigned[n]->ID) )
                    break;
                n++;
            } while( n < NUMJOYDEVS );

            // Find out the type name...
            if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[n]->ID, (LPDIJOYCONFIG)lpDIJoyConfig, DIJC_REGHWCONFIGTYPE)) )
            {
                LPDIJOYTYPEINFO lpDIJoyTypeInfo = new (DIJOYTYPEINFO);
                ASSERT (lpDIJoyTypeInfo);

                ZeroMemory(lpDIJoyTypeInfo, sizeof(DIJOYTYPEINFO));

                lpDIJoyTypeInfo->dwSize = sizeof(DIJOYTYPEINFO);

                // Get the TypeInfo you start with!
                if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(lpDIJoyConfig->wszType, lpDIJoyTypeInfo, DITC_FLAGS1 | DITC_CLSIDCONFIG)) )
                {
                    DWORD dwFlags = GetItemData(hAdvListCtrl, (BYTE)iAdvItem);

                    // If it's checked... you want the OEM supplied property sheet page!
                    if( IsDlgButtonChecked(hDlg, IDC_ADV_USEOEMPAGE) )
                    {
                        // Turn off the USE_DEFAULT flag
                        dwFlags &= ~USE_DEFAULT;

                        // Update the global pointer!!!
                        pAssigned[n]->clsidPropSheet = lpDIJoyTypeInfo->clsidConfig;

                        // Update the pointer being sent to the registry
                        lpDIJoyTypeInfo->dwFlags1 &= ~JOYTYPE_DEFAULTPROPSHEET;
                    } else
                    {
                        // Turn on the USE_DEFAULT flag
                        dwFlags |= USE_DEFAULT;

                        // Update the global list!
                        pAssigned[n]->clsidPropSheet = CLSID_LegacyServer;

                        // Update the pointer being sent to the registry
                        lpDIJoyTypeInfo->dwFlags1 |= JOYTYPE_DEFAULTPROPSHEET;
                    }

                    if( SUCCEEDED(pDIJoyConfig->Acquire()) ) {
                    
                        // Update the registry
                        VERIFY(SUCCEEDED(pDIJoyConfig->SetTypeInfo(lpDIJoyConfig->wszType, lpDIJoyTypeInfo, DITC_FLAGS1)));
    
                        // Set the data in the list control!
                        SetItemData(hAdvListCtrl, (BYTE)iAdvItem, dwFlags);
                    }
                    
                    pDIJoyConfig->Unacquire();
                }

                if( lpDIJoyTypeInfo )
                    delete (lpDIJoyTypeInfo);
            }

            if( lpDIJoyConfig )
                delete (lpDIJoyConfig);
        }
        break;

    default:
        break;
    }
}

////////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION:    OnNotify(HWND hDlg, WPARAM idFrom, NMHDR* pnmhdr)
//
// PARAMETERS:  hDlg   - 
//             idFrom - ID of control sending WM_NOTIFY message
//             pnmhdr -
//
// PURPOSE:     WM_NOTIFY message handler
////////////////////////////////////////////////////////////////////////////////
BOOL OnNotify(HWND hDlg, WPARAM idFrom, LPNMHDR pnmhdr)
{
    switch( pnmhdr->code )
    {
    case PSN_QUERYCANCEL:
        if( nFlags & UPDATE_INPROCESS )
        {
            nFlags &= ~UPDATE_INPROCESS;
            SetFocus(hAdvListCtrl);
        }
        break;
/*
    case LVN_GETINFOTIP:
        {
        LPLVHITTESTINFO lpHit = new (LVHITTESTINFO);
        ASSERT (lpHit);

        BOOL bRet = FALSE;

        POINT pt;
        GetCursorPos(&pt);
        ScreenToClient(hAdvListCtrl, &pt);

        lpHit->pt    = pt;
        lpHit->flags = lpHit->iItem = lpHit->iSubItem = 0;

        ::SendMessage(hAdvListCtrl, LVM_SUBITEMHITTEST, 0, (LPARAM)(LPLVHITTESTINFO)lpHit);

        if (lpHit->flags & LVHT_ONITEMLABEL)
        {
            // Determine the text length of the column text
            LPTSTR lpStr = new (TCHAR[MAX_STR_LEN+1]);
            ASSERT (lpStr);

            GetItemText(hAdvListCtrl, lpHit->iItem, lpHit->iSubItem, lpStr, MAX_STR_LEN);

            // Determine if the latter will fit inside the former...
            SIZE size;
            HDC hDC = GetDC(hAdvListCtrl);
           GetTextExtentPoint(hDC, lpStr, lstrlen(lpStr), &size);
            ReleaseDC(hAdvListCtrl, hDC);

            // Determine how wide the column is!
            short nWidth = (short)::SendMessage(hAdvListCtrl, LVM_GETCOLUMNWIDTH, lpHit->iSubItem, 0);

            bRet = (BOOL)(size.cx > nWidth);

            if (bRet)
                // if not, copy the text into lpHit->pszText
                _tcscpy(((LPNMLVGETINFOTIP)pnmhdr)->pszText, lpStr);

            if (lpStr)
                delete[] (lpStr);
        }
        if (lpHit)
            delete (lpHit);

        return bRet;
        }
*/

    case LVN_BEGINLABELEDIT:
        if( !(GetItemData(hAdvListCtrl, (BYTE)iAdvItem) & ID_NONE) )
            OnCommand(hDlg, IDC_RENAME, 0, 0);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 1);
        break;

    case LVN_ENDLABELEDIT:
        if( !(nFlags & UPDATE_INPROCESS) )
            return(FALSE);

        if( !bProcess )
            return(FALSE);

        nFlags &= ~UPDATE_INPROCESS;

        if( fpPageWndProc )
        {
            HWND hParentWnd = GetParent(hDlg);
            // this is required because the CPL can be launched via RUNDLL32
            if( ::IsWindow(hParentWnd) )
                hParentWnd = GetParent(hParentWnd);
            // Reset the subclass proc
//         SetWindowLongPtr(hParentWnd, GWLP_WNDPROC, (LONG_PTR)fpPageWndProc);
        }

        // Make sure the name is usable!
        if( _tcschr(((NMLVDISPINFO *)pnmhdr)->item.pszText, TEXT('\\')) )
        {
            Error((short)IDS_INVALID_NAME_TITLE, (short)IDS_INVALID_NAME);
        } else
        {
            nFlags |= UPDATE_ALL;

            LPDIPROPSTRING pDIPropString = new (DIPROPSTRING);
            ASSERT (pDIPropString);

            ZeroMemory(pDIPropString, sizeof(DIPROPSTRING));

            pDIPropString->diph.dwSize       = sizeof(DIPROPSTRING);
            pDIPropString->diph.dwHeaderSize = sizeof(DIPROPHEADER);
            pDIPropString->diph.dwHow        = DIPH_DEVICE;

#ifdef _UNICODE
            wcscpy(pDIPropString->wsz, ((NMLVDISPINFO *)pnmhdr)->item.pszText);
#else
            USES_CONVERSION;
            wcscpy(pDIPropString->wsz, A2W(((NMLVDISPINFO *)pnmhdr)->item.pszText));
#endif
            // Search nAssigned for the ID...
            BYTE n = nAssigned;

            do
            {
                if( pAssigned[--n]->ID == ((NMLVDISPINFO *)pnmhdr)->item.iItem )
                    break;

            } while( n );

            if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->SetProperty(DIPROP_INSTANCENAME, &pDIPropString->diph)) )
            {
                SetItemText(hAdvListCtrl, (BYTE)((NMLVDISPINFO *)pnmhdr)->item.iItem, 1, ((NMLVDISPINFO *)pnmhdr)->item.pszText);
            } else
            {
                Error((short)IDS_NO_RENAME_TITLE, (short)IDS_NO_RENAME);
            }

            if( pDIPropString )
                delete (pDIPropString);
        }
        break;

#if 0
    case LVN_COLUMNCLICK:
        switch( ((NM_LISTVIEW*)pnmhdr)->iSubItem )
        {
        case DEVICE_ID:
            {
                static BOOL bIDDirection = TRUE;
                ::SendMessage(hAdvListCtrl, LVM_SORTITEMS, (WPARAM)(LPARAM)(bIDDirection =! bIDDirection), (LPARAM)(PFNLVCOMPARE)CompareIDItems);
            }
            break;

        default:
            {
                BOOL bDirection;

                CListCtrl *pCtrl = new (CListCtrl);
                ASSERT(pCtrl);

                pCtrl->Attach(hAdvListCtrl);

                switch( ((NM_LISTVIEW*)pnmhdr)->iSubItem )
                {
                case DEVICE_FRIENDLY:
                    {
                        static BOOL bFriendlyDirection   = FALSE;
                        bDirection = (bFriendlyDirection =! bFriendlyDirection);
                    }
                    break;

                case DEVICE_TYPE:
                    {
                        static BOOL bTypeDirection       = FALSE;
                        bDirection = (bTypeDirection        =! bTypeDirection);
                    }
                    break;

                case DEVICE_PORT:
                    {
                        static BOOL bPortDirection          = FALSE;
                        bDirection = (bPortDirection        =! bPortDirection);
                    }
                    break;
                }

                SortTextItems(pCtrl, (short)((NM_LISTVIEW*)pnmhdr)->iSubItem, bDirection, 0, 15);

                pCtrl->Detach();

                if( pCtrl )
                    delete (pCtrl);
            }
            break;
        }

        if( nAssigned )
        {
            iAdvItem = (short)::SendMessage(hAdvListCtrl, LVM_GETNEXTITEM, (WPARAM)(int)-1, MAKELPARAM(LVNI_SELECTED, 0));
            ::PostMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, iAdvItem, TRUE);

            if( !(nFlags & USER_MODE) )
                PostDlgItemEnableWindow(hDlg, IDC_ADV_CHANGE, (GetItemData(hAdvListCtrl, (BYTE)iAdvItem) & ID_NONE) ? FALSE : TRUE);

            SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
        }
        break;
#endif

    case PSN_KILLACTIVE:
        if( nFlags & UPDATE_INPROCESS )
            SetFocus(hAdvListCtrl);

#ifdef _UNICODE
        if( hAdvNotifyDevNode )
            UnregisterDeviceNotification(hAdvNotifyDevNode);
#endif
        break;

    case NM_DBLCLK:
        switch( idFrom )
        {
        case IDC_ADV_LIST_DEVICE:
            if( !(GetItemData(hAdvListCtrl, (BYTE)iAdvItem) & ID_NONE) )
                LaunchChange(hDlg);
            break;
        }
        break;

    case PSN_SETACTIVE:
#ifdef _UNICODE
        RegisterForDevChange(hDlg, &hAdvNotifyDevNode);
#endif 

        if( nFlags & UPDATE_FOR_ADV )
        {
            if( !AdvUpdateListCtrl() )
            {
#ifdef _DEBUG
                OutputDebugString(TEXT("JOY.CPL: OnNotify: Failed UpdateListCtrl!\n"));
#endif
            }
        }

        if( nAssigned )
        {
            iAdvItem = 0;

            // This will happen when the user comes in via the CMD line!
            if( iItem != NO_ITEM )
            {
                // Find the ID of the device... the Brute Force Method!
                do
                {
                    if( (pAssigned[iItem] != NULL) && ((BYTE)GetItemData(hAdvListCtrl, (BYTE)iAdvItem) == pAssigned[iItem]->ID) )
                        break;

                    iAdvItem++;
                } while( iAdvItem < NUMJOYDEVS );
            }

            if( iAdvItem == NUMJOYDEVS ) {
                iAdvItem = 0;
            }

            SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
            ::PostMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, iAdvItem, FALSE );
        }

        // No global port drivers in NT so...
        //if (nGameportDriver)
#ifndef _UNICODE
        if( !(nFlags & ON_NT) )
            PopulateGlobalPortDriverComboBox();
#endif

        // disable the Change button if iAdvItem points to a (none) selection
        if( !(nFlags & USER_MODE) )
            PostDlgItemEnableWindow(hDlg, IDC_ADV_CHANGE,  (nAssigned) ? ((iAdvItem & ID_NONE) ? FALSE : TRUE) : FALSE);
        break;

    case LVN_ITEMCHANGED:
        if( iAdvItem != (short)((NM_LISTVIEW*)pnmhdr)->iItem )
        {
            iAdvItem = (short)((NM_LISTVIEW*)pnmhdr)->iItem;

            HWND hCtrl = GetDlgItem(hDlg, IDC_ADV_USEOEMPAGE);

            if( nAssigned )
            {
                SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | 
                              ((((NM_LISTVIEW*)pnmhdr)->lParam & SHOW_DEFAULT) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW) );

                // Check the box appropriatly!
                if( ((NM_LISTVIEW*)pnmhdr)->lParam & SHOW_DEFAULT )
                    ::PostMessage(GetDlgItem(hDlg, IDC_ADV_USEOEMPAGE), BM_SETCHECK, (((NM_LISTVIEW*)pnmhdr)->lParam & USE_DEFAULT) ? BST_UNCHECKED : BST_CHECKED, 0);

                if( ((NM_LISTVIEW*)pnmhdr)->lParam )
                    PostEnableWindow(hCtrl, (BOOL)!(((NM_LISTVIEW*)pnmhdr)->lParam & ID_NONE));

                if( !(nFlags & USER_MODE) )
                    PostDlgItemEnableWindow(hDlg, IDC_ADV_CHANGE, (BOOL)!(((NM_LISTVIEW*)pnmhdr)->lParam & ID_NONE));
            } else SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW);
        }
        break;

    case LVN_KEYDOWN:
        switch( ((LV_KEYDOWN*)pnmhdr)->wVKey )
        {
        case    VK_DELETE:
            iAdvItem = (short)::SendMessage(hAdvListCtrl, LVM_GETNEXTITEM, (WPARAM)(int)-1, MAKELPARAM(LVNI_SELECTED, 0));
            {
                BYTE nRet = (BYTE)GetItemData(hAdvListCtrl, (BYTE)iAdvItem);
                DeleteSelectedItem((PBYTE)&nRet);
            }
            // Missing break intentional!

        case VK_F5:
            Enumerate( hDlg );
            AdvUpdateListCtrl();
            SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
            ::PostMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, iAdvItem, FALSE );
            break;
        }
        break;
    }
    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnDestroy ( HWND hWnd )
//
// PARAMETERS:  hWnd - Handle to window being destroyed
//
// PURPOSE:     WM_DESTROY message handler
////////////////////////////////////////////////////////////////////////////////////////
void OnDestroy(HWND hWnd)
{
    ASSERT (hWnd);

    if( lpstrNone )
        delete[] (lpstrNone);

    // Reset the subclass proc
    SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)fpMainWndProc);

    // release the DI JoyConfig interface pointer
    if( pDIJoyConfig )
    {
        pDIJoyConfig->Release();
        pDIJoyConfig = 0;
    }
}

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnAdvHelp ( LPARAM lParam )
//
// PARAMETERS:  lParam - Pointer to HELPINFO struct
//
// PURPOSE:     WM_HELP message handler
////////////////////////////////////////////////////////////////////////////////////////
void OnAdvHelp(LPARAM lParam)
{
    ASSERT (lParam);

    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    ASSERT (pszHelpFileName);

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
    {
        if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: Advanced.cpp: OnAdvHelp: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnContextMenu ( WPARAM wParam )
//
// PARAMETERS:  wParam - HWND of window under the pointer
//
// PURPOSE:     Handle WM_RBUTTONDOWN over all client windows 
// (except the list control... that's OnListviewContextMenu() job)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    ASSERT (wParam);

    // If you are on the ListCtrl...
    if( (HWND)wParam == hAdvListCtrl )
    {
        SetFocus(hAdvListCtrl);

        // Don't attempt if nothing selected
        if( iAdvItem != NO_ITEM )
            OnListviewContextMenu(lParam);
    } else
    {
        // point to help file
        LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
        ASSERT (pszHelpFileName);

        if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
            WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
        else OutputDebugString(TEXT("JOY.CPL: Advanced.cpp: OnContextMenu: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

        if( pszHelpFileName )
            delete[] (pszHelpFileName);
    }
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SetActiveGlobalDriver( void )
//
// PURPOSE:     Commit user selection to persistent storage.
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
#ifndef _UNICODE
BOOL SetActiveGlobalDriver( void )
{
    // It's Perfectly valid to not have a Global Port Driver so... be prepared!
    short n = (short)SendDlgItemMessage(ghDlg, IDC_COMBO1, CB_GETCURSEL, 0, 0);

    if( n == CB_ERR )
        return(FALSE);

    LPDIJOYUSERVALUES pDIJoyUserValues = new (DIJOYUSERVALUES);
    ASSERT (pDIJoyUserValues);

    ZeroMemory(pDIJoyUserValues, sizeof(DIJOYUSERVALUES));

    pDIJoyUserValues->dwSize = sizeof(DIJOYUSERVALUES);

    HWND hCtrl = GetDlgItem(ghDlg, IDC_COMBO1);

    // Don't worry about this not being a TCHAR, this code will never be executed in NT!
    LPSTR pszDisplayName = new char[SendMessage(hCtrl, LB_GETTEXTLEN, (WPARAM)n, 0)+1];
    ASSERT (pszDisplayName);

    SendMessage(hCtrl, CB_GETLBTEXT, n, (LPARAM)(LPCTSTR)pszDisplayName);

    hCtrl = GetDlgItem(ghDlg, IDC_POLLFLAGS);

    SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW );

    // Fix #9815, Set wszGlobalDriver to 
    if( _tcsncmp(pszDisplayName, lpstrNone, sizeof(lpstrNone)/sizeof(TCHAR)) == 0 )
    {
        //wcscpy(pDIJoyUserValues->wszGlobalDriver, L"");

        if( SUCCEEDED(pDIJoyConfig->Acquire()) )
        {
            if( FAILED(pDIJoyConfig->SetUserValues(pDIJoyUserValues, DIJU_GLOBALDRIVER)) )
            {
                TRACE (TEXT("JOY.CPL: SetUserValues failed to set DIJU_GLOBALDRIVER!\n"));
            }
        }
    } else
    {
        LPDIJOYTYPEINFO lpdiJoyInfo = new DIJOYTYPEINFO;
        ASSERT (lpdiJoyInfo);

        ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO));

        lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO);

        USES_CONVERSION;

        short nIndex = 0;

        // traverse the list of Global Port Drivers 'till you find the matching display name
        // this also disallows the user from doing something ugly when they only have "standard gameport"
        while( pwszGameportDriverArray[nIndex] )
        {
            // populate the Type Info                                         
            if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszGameportDriverArray[nIndex], lpdiJoyInfo, DITC_DISPLAYNAME | DITC_CALLOUT)) )
            {
                if( _wcsicmp(lpdiJoyInfo->wszDisplayName, A2W(pszDisplayName)) == 0 )
                {
                    wcscpy(pDIJoyUserValues->wszGlobalDriver, lpdiJoyInfo->wszCallout );

                    if( SUCCEEDED(pDIJoyConfig->Acquire()) )
                    {
                        if( FAILED(pDIJoyConfig->SetUserValues(pDIJoyUserValues, DIJU_GLOBALDRIVER)) )
                        {
                            TRACE (TEXT("JOY.CPL: SetUserValues failed to set DIJU_GLOBALDRIVER!\n"));
                        }

                        // check to see if you need to display the poll flags check box!
                        if( _wcsicmp(pDIJoyUserValues->wszGlobalDriver, lpMSANALOG_VXD) == 0 )
                        {
                            SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                                          SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW );

                            // Get the state from the registry and update the check mark
                            HKEY hKey; 

                            if( FAILED(pDIJoyConfig->OpenTypeKey(pwszGameportDriverArray[nIndex], KEY_ALL_ACCESS, &hKey)) )
                            {
                                TRACE (TEXT("JOY.CPL: OpenTypeKey failed to open key %s!\n"), pwszGameportDriverArray[nIndex]);
                            }

                            DWORD dwFlag;
                            ULONG ulType = REG_BINARY;
                            ULONG ulSize = sizeof(dwFlag);

                            // this will happen if there is no entry for POLL_FLAGS_REG_STR
                            if( ERROR_SUCCESS != RegQueryValueEx(hKey, POLL_FLAGS_REG_STR, NULL, &ulType, (PBYTE)&dwFlag, &ulSize) )
                                dwFlag = 0;

                            ::PostMessage(GetDlgItem(ghDlg, IDC_POLLFLAGS), BM_SETCHECK, (dwFlag) ? BST_CHECKED : BST_UNCHECKED, 0);

                            RegCloseKey(hKey);
                        }
                    }
                    break;
                }
            }
            nIndex++;
        }

        // delete the DIJOYTYPEINFO variable
        if( lpdiJoyInfo )
            delete (lpdiJoyInfo);
    }

    pDIJoyConfig->SendNotify();

    pDIJoyConfig->Unacquire();

    if( pszDisplayName )
        delete[] (pszDisplayName);

    if( pDIJoyUserValues )
        delete pDIJoyUserValues;

    return(TRUE);
}
#endif // _UNICODE


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnListviewContextMenu( void )
//
// PURPOSE:     Handle Context menu in Listview
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
static void OnListviewContextMenu( LPARAM lParam )
{
    HMENU hPopupMenu = CreatePopupMenu();
    ASSERT (hPopupMenu);

    // unlike life, bRet defaults to bliss
    BOOL bRet = TRUE;

    LPTSTR pszText = new TCHAR[STR_LEN_32];
    ASSERT (pszText);

    // Don't display Rename/Change if on (none) entry
    if( !(GetItemData(hAdvListCtrl, (BYTE)iAdvItem) & ID_NONE) )
    {
        if( !(nFlags & USER_MODE) )
        {
            // add the "Change..." string
            ::SendDlgItemMessage(GetParent(hAdvListCtrl), IDC_ADV_CHANGE, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)pszText);

            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_ADV_CHANGE, pszText); 
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

            // Add the Rename text
            VERIFY(LoadString(ghInstance, IDS_RENAME, pszText, STR_LEN_32));
            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_RENAME, pszText);
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

            // Add the SEPERATOR and "What's this?"

            //PREFIX #WI279965. False positive.
            //MSDN: if uFlags==MF_SEPARATOR, LPCTSTR lpNewItem is ignored.
            bRet = AppendMenu(hPopupMenu, MF_SEPARATOR, 0, 0); 
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert SEPERATOR!\n"));
#endif //_DEBUG
        }
    }

    VERIFY(LoadString(ghInstance, IDS_WHATSTHIS, pszText, STR_LEN_32));
    bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDS_WHATSTHIS, pszText); 
#ifdef _DEBUG
    if( !bRet )
        TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

    if( pszText ) delete[] (pszText);

    POINT pt;

    // lParam is -1 if we got here via Shift+F10
    if( lParam > 0 )
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    } else
    {
        // Centre the popup on the selected item!

        // This get's a good X pos, but the y is the start of the control!
        ::SendMessage(hAdvListCtrl, LVM_GETITEMPOSITION, iAdvItem, (LPARAM)&pt);

        RECT rc;
        ::GetClientRect(hAdvListCtrl, &rc);

        pt.x = rc.right>>1;

        ClientToScreen(hAdvListCtrl, &pt);
    }

    bRet = TrackPopupMenu (hPopupMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, 0, ghDlg, NULL);
#ifdef _DEBUG
    if( !bRet )
        TRACE (TEXT("JOY.CPL: OnListviewContextMenu: TrackPopupMenu Failed!\n"));
#endif //_DEBUG

    if(hPopupMenu) DestroyMenu (hPopupMenu); // PREFIX 45089
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    UpdateListCtrl( void )
//
// PURPOSE:     Refreshes enumerated device list
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
static BOOL AdvUpdateListCtrl()
{
    // Turn Redraw off here else it will flicker!
    ::SendMessage(hAdvListCtrl, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // Out with the old...
    ::SendMessage(hAdvListCtrl, LVM_DELETEALLITEMS, 0, 0);

    // This buffer is so large because it is used to hold IDS_GEN_STATUS_UNKNOWN
    TCHAR sz1[16];

    // find and assign ID's 
    BYTE n = NUMJOYDEVS;
    BYTE nIndex;

    SendMessage(hAdvListCtrl, LVM_SETITEMCOUNT, (WPARAM)(int)NUMJOYDEVS, (LPARAM)LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL);

    // Set everything to NONE to start!
    do
    {
        itoa((BYTE)n--, (LPTSTR)&sz1);

        // Insert the ID
        // Set the device ID and ID_NONE in Extended info...
        nIndex = InsertItem( hAdvListCtrl, sz1, n);

        // Populate the columns with "(none)"
        SetItemText(hAdvListCtrl, nIndex, DEVICE_FRIENDLY, lpstrNone);
        SetItemText(hAdvListCtrl, nIndex, DEVICE_TYPE,     lpstrNone);
#ifdef _UNICODE
        SetItemText(hAdvListCtrl, nIndex, DEVICE_PORT,      lpstrNone);
#endif
    }   while( n );

    if( nAssigned )
    {
        // insert the assigned ones!
        n = nAssigned;

        DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
        ASSERT (pDIPropStr);

        ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

        pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
        pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
        pDIPropStr->diph.dwHow        = DIPH_DEVICE;


#ifndef _UNICODE
        USES_CONVERSION;
#endif               

        // The low half will be populated by the ID, the upper by bit flags!
        DWORD dwData;

        do
        {
            // Set the Product Column!
            if( SUCCEEDED(pAssigned[--n]->fnDeviceInterface->GetProperty(DIPROP_PRODUCTNAME, &pDIPropStr->diph)) )
            {
#ifdef _UNICODE
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_TYPE, (LPTSTR)pDIPropStr->wsz);
#else
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_TYPE, (LPTSTR)W2A(pDIPropStr->wsz));
#endif
            }

            // Set the Friendly Name!
            if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph)) )
            {
#ifdef _UNICODE
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_FRIENDLY, (LPTSTR)pDIPropStr->wsz);
#else
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_FRIENDLY, (LPTSTR)W2A(pDIPropStr->wsz));
#endif
            }

#ifdef _UNICODE
            // Set the Game Port Column!
            if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->GetProperty(DIPROP_GETPORTDISPLAYNAME, &pDIPropStr->diph)) )
            {
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_PORT, (LPTSTR)pDIPropStr->wsz);
            } else
            {
                VERIFY(LoadString(ghInstance, IDS_GEN_STATUS_UNKNOWN, sz1, sizeof(sz1)/sizeof(TCHAR)));
                SetItemText(hAdvListCtrl, pAssigned[n]->ID, DEVICE_PORT, (LPTSTR)sz1);
            }
#endif // _UNICODE

            // Set the ID in the data... 
            // This is necessary for Sorting!
            dwData = pAssigned[n]->ID;

            //if( pAssigned[n]->clsidPropSheet != CLSID_LegacyServer )
            if( pAssigned[n]->fHasOemSheet )
            {
                LPDIJOYCONFIG_DX5 lpDIJoyConfig = new (DIJOYCONFIG_DX5);
                ASSERT (lpDIJoyConfig);

                ZeroMemory(lpDIJoyConfig, sizeof(DIJOYCONFIG_DX5));

                lpDIJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);


                // Set the DefaultPropertySheet flag 
                if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[n]->ID, (LPDIJOYCONFIG)lpDIJoyConfig, DIJC_REGHWCONFIGTYPE)) )
                {
                    LPDIJOYTYPEINFO lpDIJoyTypeInfo = new (DIJOYTYPEINFO);
                    ASSERT (lpDIJoyTypeInfo);

                    ZeroMemory(lpDIJoyTypeInfo, sizeof(DIJOYTYPEINFO));

                    lpDIJoyTypeInfo->dwSize = sizeof (DIJOYTYPEINFO);

                    if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(lpDIJoyConfig->wszType, lpDIJoyTypeInfo, DITC_FLAGS1 )) )
                    {
                        if( lpDIJoyTypeInfo->dwFlags1 & JOYTYPE_DEFAULTPROPSHEET )
                        {
                            // Set the USE_DEFAULT mask!
                            dwData |= USE_DEFAULT;

                            // Update the global list!
                            pAssigned[n]->clsidPropSheet = CLSID_LegacyServer;
                        }
                    }

                    if( lpDIJoyTypeInfo )
                        delete (lpDIJoyTypeInfo);
                }

                dwData |= SHOW_DEFAULT;

                if( lpDIJoyConfig )
                    delete (lpDIJoyConfig);
            }

            // Set the Item Data to the ID!                        
            SetItemData(hAdvListCtrl, pAssigned[n]->ID, dwData);

        }  while( n );

        // clean up, clean up... everybody do your share!
        if( pDIPropStr )
            delete (pDIPropStr);
    }

    // turn the flag off!
    if( nFlags & UPDATE_FOR_ADV )
        nFlags &= ~UPDATE_FOR_ADV;

    // Turn the redraw flag back on!
    ::SendMessage (hAdvListCtrl, WM_SETREDRAW, (WPARAM)TRUE, 0);
    InvalidateRect(hAdvListCtrl, NULL, TRUE);

    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION:    ChangeDialogProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam)
//
// PARAMETERS:  HWND     hDlg   -
//             ULONG    uMsg   -
//             WPARAM   wParam -
//             LPARAM   lParam -
//
// PURPOSE:     
////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI ChangeDialogProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(hDlg, WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam, lParam);
        return(TRUE);

    case WM_INITDIALOG:
        {
            HICON hIcon = (HICON)LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CPANEL), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
            ASSERT (hIcon);

            if( hIcon )
                ::PostMessage(hDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);

            HWND hCtrl = GetDlgItem(hDlg, IDC_CHANGE_LIST);
            ASSERT (hCtrl);

            UpdateChangeListCtrl( hCtrl );

            BYTE nCounter = nAssigned;
            while( nCounter-- )
            {
                if( (BYTE)::SendMessage(hCtrl, LB_GETITEMDATA, (WPARAM)nCounter, 0) == nOldID )
                    break;
            }

            // Set the list box selections!
            ::PostMessage(hCtrl, LB_SETCURSEL, (WPARAM)nCounter, 0);

            // Done with the ListCtrl, now... on to the ComboBox
            if( nFlags & ON_NT )
            {

                if( !PopulatePortList(hDlg) )
                {
#ifdef _DEBUG 
                    OutputDebugString(TEXT("JOY.CPL: ADVANCED.CPP: PopulatePortList failed!\n"));
#endif
                }
            }

            // Set up the Spin Control!
            HWND hSpinCtrl = GetDlgItem(hDlg, IDC_SPIN);

            ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(NUMJOYDEVS, 1));
            ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
            ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(nOldID+1, 0));
        }
        return(FALSE);

    case WM_COMMAND:
        {
            switch( LOWORD(wParam) )
            {
            /* I'll leave this commented out, as it's likely they'll want double clicking back once I take it out
        case IDC_CHANGE_LIST:
        // Fall into Change on DBLCLK
           if (HIWORD(wParam) != LBN_DBLCLK)
               break;
            */
            
            case IDOK:
                {
                    HWND hCtrl = GetDlgItem(hDlg, IDC_CHANGE_LIST);
                    ASSERT (hCtrl);

                    char nSelectedItem = (char)(SendMessage(hCtrl, LB_GETITEMDATA, SendMessage(hCtrl, LB_GETCURSEL, 0, 0), 0));

                    TCHAR tsz[4];

                    hCtrl = GetDlgItem(hDlg, IDC_SPINBUDDY);

                    tsz[0] = 4;

                    SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM)(LPCSTR)&tsz);

                    // The '-1' is to account for the 1 based list
                    // and the 0 based id's!
                    char nSelectedID = (char)atoi((LPCTSTR)&tsz)-1;

                    pDIJoyConfig->Acquire();

                    // first check to see if the user has selected NONE!
                    if( nSelectedItem == -2 )
                    {
                        // User has selected NONE!
                        VERIFY (SUCCEEDED(pDIJoyConfig->DeleteConfig(nSelectedID)));
                    } else
                    {
                        // see if the selected item and the ID match!
                        // if so... get out of here!
                        if( nSelectedID == nSelectedItem )
                        {
#ifdef _DEBUG
                            OutputDebugString(TEXT("JOY.CPL: ADVANCED.CPP: OnChangeCommand: IDOK: Device already at selected ID!\n"));
#endif
                        } else
                        {
                            SwapIDs(nSelectedID, nSelectedItem);
//                          SetListCtrlItemFocus(hAdvListCtrl, (BYTE)nSelectedID);
                        }
                    }

                    pDIJoyConfig->Unacquire();
                }
                // missing break intentional!

            case IDCANCEL:
                EndDialog(hDlg, LOWORD(wParam));
                break;
            }
        }
        return(1);

    case WM_DESTROY:
        DestroyIcon((HICON)SendMessage(hDlg, WM_GETICON, (WPARAM)ICON_SMALL, 0));
        return(TRUE);
    }
    return(FALSE);
} 



///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    PopulateGlobalPortDriverComboBox( void )
//
// PARAMETERS:  
//
// PURPOSE:     
///////////////////////////////////////////////////////////////////////////////
#ifndef UNICODE
void PopulateGlobalPortDriverComboBox( void )
{
    HWND hCtrl = GetDlgItem(ghDlg, IDC_COMBO1);

    // make sure the combo is clear before we start populating it!
    SendMessage(hCtrl, CB_RESETCONTENT, 0, 0);

    // Type info
    LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
    ASSERT (lpdiJoyInfo);

    ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

    lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

    BYTE nIndex = nGameportDriver;
    USES_CONVERSION;

    // Populate the Combobox
    while( nIndex-- )
    {
        // populate the Type Info and place the Index in the extra memory!
        if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszGameportDriverArray[nIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_DISPLAYNAME)) )
          ::SendMessage(hCtrl, CB_SETITEMDATA, ::SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)W2A(lpdiJoyInfo->wszDisplayName)), nIndex);
    #ifdef _DEBUG
        else
          OutputDebugString (TEXT("JOY.CPL: ADVANCED.CPP: PopulateGlobalPortDriverComboBox: GetTypeInfo failed!\n"));
    #endif
    }

    // Display the Current selected GlobalPortDriver or None!
    LPDIJOYUSERVALUES pDIJoyUserValues = new DIJOYUSERVALUES;
    ASSERT (pDIJoyUserValues);

    ZeroMemory(pDIJoyUserValues, sizeof(DIJOYUSERVALUES));

    pDIJoyUserValues->dwSize = sizeof(DIJOYUSERVALUES);

    VERIFY (SUCCEEDED(pDIJoyConfig->GetUserValues(pDIJoyUserValues, DIJU_GLOBALDRIVER)));

    // Fix #9815, If the user has No Global port driver label as NONE!
    if( !(*pDIJoyUserValues->wszGlobalDriver && pDIJoyUserValues->wszGlobalDriver) )
    {
        iGameportDriverItem = NO_ITEM; 

        PostMessage(hCtrl, CB_SETCURSEL, (WPARAM)SendMessage(hCtrl, CB_FINDSTRING, (WPARAM)-1, (LPARAM)lpstrNone), (LPARAM)0);
    } else
    {
        ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

        lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

        nIndex = 0;

        // get type info 'till you find the one you want and place it's callout 
        while( pwszGameportDriverArray[nIndex] )
        {
            VERIFY(SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszGameportDriverArray[nIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_CALLOUT | DITC_DISPLAYNAME)));

            if( _wcsicmp(lpdiJoyInfo->wszCallout, pDIJoyUserValues->wszGlobalDriver) == 0 )
            {
                ::PostMessage(hCtrl, CB_SETCURSEL, (WPARAM)::SendMessage(hCtrl, CB_FINDSTRING, (WPARAM)-1, (LPARAM)W2A(lpdiJoyInfo->wszDisplayName)), (LPARAM)0);

                iGameportDriverItem = nIndex; 

                // enable the PollFlags checkbox!
                if( _wcsicmp(pDIJoyUserValues->wszGlobalDriver, lpMSANALOG_VXD) == 0 )
                {
                    SetWindowPos( GetDlgItem( ghDlg, IDC_POLLFLAGS), NULL, NULL, NULL, NULL, NULL, 
                                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW );

                    VERIFY(SUCCEEDED(pDIJoyConfig->Acquire()));

                    // Get the state from the registry and update the check mark
                    HKEY hKey; 
                    DWORD dwFlag;

                    if( SUCCEEDED(pDIJoyConfig->OpenTypeKey(pwszGameportDriverArray[nIndex], KEY_ALL_ACCESS, &hKey)) )
                    {
                        ULONG ulType = REG_BINARY;
                        ULONG ulSize = sizeof(dwFlag);

                        // this will happen if there is no entry for POLL_FLAGS_REG_STR
                        if( ERROR_SUCCESS != RegQueryValueEx(hKey, POLL_FLAGS_REG_STR, NULL, &ulType, (PBYTE)&dwFlag, &ulSize) )
                            dwFlag = 0;

                        RegCloseKey(hKey);
                    }

                    pDIJoyConfig->Unacquire();

                    ::PostMessage(GetDlgItem(ghDlg, IDC_POLLFLAGS), BM_SETCHECK, (dwFlag) ? BST_CHECKED : BST_UNCHECKED, 0);
                }
                break;
            }
            nIndex++;
        }
    }

    // delete the DIJOYUSERVALUES variable
    if( pDIJoyUserValues )
        delete pDIJoyUserValues;

    // clean up, clean up... everybody do your share!
    if( lpdiJoyInfo )
        delete (lpdiJoyInfo);

//    VERIFY(SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCSTR)lpstrNone) != CB_ERR);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// PARAMETERS:  HWND   hWnd   -
//             UINT   uMsg   -
//             WPARAM wParam -
//             LPARAM lParam -
//
// PURPOSE:     SubClass Procedure for Setting the ID to NONE on VK_DELETE on the Advanced Page
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI KeySubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_COMMAND:
        switch( LOWORD(wParam) )
        {
        case IDCANCEL:
        case IDOK:     
            if( nFlags & UPDATE_INPROCESS )
            {
                bProcess = (LOWORD(wParam) == IDOK) ? TRUE : FALSE;
                SetFocus(hAdvListCtrl);
                nFlags &= ~UPDATE_INPROCESS;
                return(FALSE);
            }
            break;
        }
        break;
    }
    return(BOOL)CallWindowProc(fpPageWndProc, hWnd, uMsg, wParam, lParam);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// PARAMETERS:  HWND   hWnd   -
//             UINT   uMsg   -
//             WPARAM wParam -
//             LPARAM lParam -
//
// PURPOSE:     SubClass Procedure for Setting the ID to NONE on VK_DELETE on the Advanced Page
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI SubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_PARENTNOTIFY:
        if( LOWORD(wParam) == WM_LBUTTONDOWN )
        {
            if( nFlags & UPDATE_INPROCESS )
                SetFocus(hAdvListCtrl);
        }
        break;

    case WM_SYSCOMMAND:
        if( wParam & SC_VSCROLL )
        {
            if( nFlags & UPDATE_INPROCESS )
                SetFocus(hAdvListCtrl);
        }
        break;
    }

    return(BOOL)CallWindowProc(fpMainWndProc, hWnd, uMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    UpdateChangeListCtrl ( HWND hCtrl )
//
// PARAMETERS:  HWND   hCtrl - Handle to Change list box
//
// PURPOSE: Update the Change List box
///////////////////////////////////////////////////////////////////////////////
static BOOL UpdateChangeListCtrl ( HWND hCtrl )
{
#ifndef _UNICODE
    USES_CONVERSION;
#endif

    DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
    ASSERT (pDIPropStr);

    ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

    pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
    pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropStr->diph.dwHow        = DIPH_DEVICE;

    BYTE n = nAssigned;

    LPTSTR lpStr = new (TCHAR[MAX_STR_LEN]);
    ASSERT (lpStr);

    // find and assign ID's
    while( n-- )
    {
        if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph)) )
        {

            // Our buffer is Only soooo big...
            // besides, it just doesn't make sence to display Everything!
            if( wcslen(pDIPropStr->wsz) > STR_LEN_64 )
            {
                pDIPropStr->wsz[60] = pDIPropStr->wsz[61] = pDIPropStr->wsz[62] = TEXT('.');
                pDIPropStr->wsz[63] = TEXT('\0');
            }

#ifdef _UNICODE
            _tcscpy(lpStr, pDIPropStr->wsz);
#else
            _tcscpy(lpStr, W2A(pDIPropStr->wsz));
#endif

            // Put the first bracket on...
            _tcscat(lpStr, TEXT("  ("));

            // Now, get the productname of the device!
            if( SUCCEEDED(pAssigned[n]->fnDeviceInterface->GetProperty(DIPROP_PRODUCTNAME, &pDIPropStr->diph)) )
            {
#ifdef _UNICODE
                _tcscat(lpStr, pDIPropStr->wsz);
#else
                _tcscat(lpStr, W2A(pDIPropStr->wsz));
#endif
            }

            // put the end bracket on...
            _tcscat(lpStr, TEXT(")"));

            BYTE n1 = (BYTE)SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpStr);
            SendMessage(hCtrl, LB_SETITEMDATA, n1, pAssigned[n]->ID);
        }
#ifdef _DEBUG
        else OutputDebugString(TEXT("JOY.CPL: Advanced.cpp: UpdateChangeListCtrl: GetProperty failed!\n"));
#endif // _DEBUG
    }

    if( lpStr )
        delete[] (lpStr);

    if( pDIPropStr )
        delete (pDIPropStr);

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    itoa(BYTE n, LPTSTR lpStr)
//
// PARAMETERS:  BYTE   n     - Number to be translated
//             LPTSTR lpStr - Buffer to recieve translated value
//
// PURPOSE: Convert BYTE values < 20 to strings.
///////////////////////////////////////////////////////////////////////////////
void itoa(BYTE n, LPTSTR lpStr)
{
    // designed for use with the CPL ONLY!
    // Only supports values < NUMJOYDEVS!
    if( n > NUMJOYDEVS )
    {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: itoa: n > NUMJOYDEVS!\n"));
#endif      
        return;
    }

    lpStr[0] = n % 10 + '0';

    if( n > 9 )
    {
        // Reverse the string and send it back...
        lpStr[1] = lpStr[0];
        lpStr[0] = '1';
        lpStr[2] = '\0';
    } else lpStr[1] = '\0';
}

int CALLBACK CompareIDItems(LPARAM item1, LPARAM item2, LPARAM uDirection)
{
    if( LOWORD(item1) == LOWORD(item2) )
        return(0);

    short nRet = (LOWORD(item1) > LOWORD(item2)) ? 1 : -1;

    return(uDirection) ? nRet : (nRet < 0) ? 1 : -1;
}

void LaunchChange( HWND hTmp )
{
    // Don't allow if you're in USER mode!
    if( (nFlags & USER_MODE) )
        return;

    iAdvItem = (short)::SendMessage(hAdvListCtrl, LVM_GETNEXTITEM, (WPARAM)(int)-1, MAKELPARAM(LVNI_SELECTED, 0));

    nOldID = (BYTE)GetItemData(hAdvListCtrl, (BYTE)iAdvItem);

    if( nOldID & ID_NONE )
        return;

    // valid returns are IDOK, IDCANCEL, and IDC_CHANGE_LIST
    if( IDCANCEL != DialogBox(ghInstance, (PTSTR)IDD_ADV_CHANGE, ghDlg, (DLGPROC)ChangeDialogProc) )
    {
        // Yeah, it's not really a DEVICEARRIVAL...
        ::SendMessage(hTmp, WM_DEVICECHANGE, DBT_DEVICEARRIVAL, 0);
        ::PostMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, (BYTE)iAdvItem, TRUE);
        SetFocus(hAdvListCtrl);
        SetListCtrlItemFocus(hAdvListCtrl, (BYTE)iAdvItem);
    }
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION: SortTextItems( CListCtrl *pCtrl, short nCol, BOOL bAscending, int low, int high )
//
//    SortTextItems - Sort the list based on column text
//
// PARAMETERS:  
//    pCtrl          - pointer to list to sort
//    nCol             - column that contains the text to be sorted
//    bAscending        - indicate sort order
//    low              - row to start scanning from - default row is 0
//    high             - row to end scan. -1 indicates last row
//
// PURPOSE: Sort text items in ListCtrl
//    Returns          - Returns true for success
///////////////////////////////////////////////////////////////////////////////
BOOL SortTextItems( CListCtrl *pCtrl, short nCol, BOOL bAscending, short low, short high )
{
    CHeaderCtrl* pHeader = (CHeaderCtrl*) pCtrl->GetDlgItem(0);

    if( nCol >= pHeader->GetItemCount() )
        return(FALSE);

    if( high == -1 )
        high = pCtrl->GetItemCount() - 1;

    short lo = low; 
    short hi = high;

    if( hi <= lo ) return(FALSE);

    // The choices here are to malloc a buffer large enough for the largest
    // string, or malloc an LV_ITEM struct to get the length, then malloc 
    // just the size we need.
    CString midItem = pCtrl->GetItemText( (lo+hi)/2, nCol );

    // loop through the list until indices cross    
    while( lo <= hi )
    {
        // rowText will hold all column text for one row        
        CStringArray rowText;

        // find the first element that is greater than or equal to 
        // the partition element starting from the left Index.      
        if( bAscending )
            while( ( lo < high ) && ( pCtrl->GetItemText(lo, nCol) < midItem ) )
                ++lo;
        else
            while( ( lo < high ) && ( pCtrl->GetItemText(lo, nCol) > midItem ) )
                ++lo;

        // find an element that is smaller than or equal to 
        // the partition element starting from the right Index.     
        if( bAscending )
            while( ( hi > low ) && ( pCtrl->GetItemText(hi, nCol) > midItem ) )
                --hi;
        else
            while( ( hi > low ) && ( pCtrl->GetItemText(hi, nCol) < midItem ) )
                --hi;

        // if the indexes have not crossed, swap        
        // and if the items are not equal
        if( lo <= hi )
        {
            // swap only if the items are not equal
            if( pCtrl->GetItemText(lo, nCol) != pCtrl->GetItemText(hi, nCol) )
            {
                // swap the rows
                LV_ITEM lvitemlo, lvitemhi;             
                BYTE nColCount = (BYTE)pHeader->GetItemCount();
                rowText.SetSize( nColCount );                

                for( BYTE i = 0; i < nColCount; i++ )
                    rowText[i] = pCtrl->GetItemText(lo, i);

                lvitemlo.mask      = LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                lvitemlo.iItem     = lo;                
                lvitemlo.iSubItem  = 0;
                lvitemlo.stateMask = LVIS_CUT | LVIS_DROPHILITED | LVIS_FOCUSED | LVIS_SELECTED | LVIS_OVERLAYMASK | LVIS_STATEIMAGEMASK;               
                lvitemhi           = lvitemlo;
                lvitemhi.iItem     = hi;                

                ListView_GetItem(pCtrl->GetSafeHwnd(), &lvitemlo );

                ListView_GetItem(pCtrl->GetSafeHwnd(), &lvitemhi );

                for( i=0; i<nColCount; i++ )
                    pCtrl->SetItemText(lo, i, pCtrl->GetItemText(hi, i));

                lvitemhi.iItem = lo;                
                ListView_SetItem(pCtrl->GetSafeHwnd(), &lvitemhi );

                for( i=0; i<nColCount; i++ )
                    pCtrl->SetItemText(hi, i, rowText[i]);              

                lvitemlo.iItem = hi;
                ListView_SetItem(pCtrl->GetSafeHwnd(), &lvitemlo );
            }

            ++lo;            
            --hi;        
        }
    }

    // If the right index has not reached the left side of array
    // must now sort the left partition.    
    if( low < hi )
        SortTextItems( pCtrl, nCol, bAscending, low, hi);

    // If the left index has not reached the right side of array
    // must now sort the right partition.   
    if( lo < high )
        SortTextItems( pCtrl, nCol, bAscending, lo, high);

    return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION: EditSubLabel( BYTE nItem, BYTE nCol )
//
// PARAMETERS:  
//       EditSubLabel - Start edit of a sub item label
//       Returns         - Temporary pointer to the new edit control
//       nItem           - The row index of the item to edit
//       nCol            - The column of the sub item.
// PURPOSE:  Provide editing services for any column in a CListCtrl
///////////////////////////////////////////////////////////////////////////////
void EditSubLabel( BYTE nItem, BYTE nCol )
{
#ifdef _DEBUG
    // Make sure that the item is visible
    if( !SendMessage(hAdvListCtrl, LVM_ENSUREVISIBLE, nItem, TRUE ) )
    {
        OutputDebugString(TEXT("JOY.CPL: ADVANCED.CPP: EditSubLabel: requested item not visible!\n"));
        return;
    }
#endif // _DEBUG

    // Get the column offset
    short offset = 0;
    BYTE i = 0;

    // OK, so here's what we have to do...
    // Traverse the columns incrementing the widths of the ones lesser than the one we're looking for!

    HDITEM *phdItem = new (HDITEM);
    ASSERT (phdItem);

    phdItem->mask = HDI_ORDER | HDI_WIDTH;

    HWND hHeader   = GetDlgItem(hAdvListCtrl, 0);
    BYTE nColumns  = (BYTE)::SendMessage(hHeader, HDM_GETITEMCOUNT, 0, 0L);
    BYTE nColWidth;

    do
    {
        ::SendMessage(hHeader, HDM_GETITEM, (WPARAM)(int)--nColumns, (LPARAM)(LPHDITEM)phdItem);

        if( phdItem->iOrder < nCol )
            offset += (short)phdItem->cxy;

        if( phdItem->iOrder == nCol )
            nColWidth = (BYTE)phdItem->cxy;
    } while( nColumns ); 

    if( phdItem )
        delete (phdItem);

    RECT rect;
    ListView_GetItemRect(hAdvListCtrl, nItem, &rect, LVIR_BOUNDS );

    // Now scroll if we need to expose the column
    CRect rcClient;
    ::GetClientRect(hAdvListCtrl, &rcClient);

    if( offset + rect.left < 0 || offset + rect.left > rcClient.right )
    {
        ::SendMessage(hAdvListCtrl, LVM_SCROLL, (WPARAM)(int)offset + rect.left, (LPARAM)(int)0);
        rect.left -= (offset + rect.left);
    }

    rect.left += offset+4;
    rect.right = rect.left + nColWidth - 3;  // + ::SendMessage(hAdvListCtrl, LVM_GETCOLUMNWIDTH, (WPARAM)(int)nCol, (LPARAM)0L) - 3 ;

    if( rect.right > rcClient.right )
        rect.right = rcClient.right;

    CEdit *pEdit = new CInPlaceEdit(nItem, 1); 
    ASSERT (pEdit);

    // malloc the list ctrl
    CWnd  *pListCtrl = new (CWnd);
    ASSERT (pListCtrl);

    pListCtrl->Attach(hAdvListCtrl);

    pEdit->Create(WS_BORDER | WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | ES_CENTER, rect, pListCtrl, IDC_IPEDIT );

    pListCtrl->Detach();

    if( pListCtrl )
        delete (pListCtrl);
}

#ifdef _UNICODE
void SwapIDs(BYTE nSource, BYTE nTarget)
{
    // malloc and retrieve the data from the selected item
    LPDIJOYCONFIG lpSelectedID = new (DIJOYCONFIG);
    ASSERT (lpSelectedID);

    ZeroMemory(lpSelectedID, sizeof(DIJOYCONFIG));

    lpSelectedID->dwSize = sizeof(DIJOYCONFIG);

    // Get the Config of device on ID taken from Change List box!
    HRESULT hr = pDIJoyConfig->GetConfig(nSource, lpSelectedID, DIJC_ALL);

    if( hr == DIERR_NOTFOUND || hr == S_FALSE )
    {
        // No Object on Selected ID!
        if( lpSelectedID )
            delete (lpSelectedID);

        lpSelectedID = NULL;
    }

    // malloc and retrieve the data from the item associated 
    // with the ID taken from the Item selected in the List box!
    LPDIJOYCONFIG lpSelectedItem = new (DIJOYCONFIG);
    ASSERT (lpSelectedItem);

    ZeroMemory(lpSelectedItem, sizeof(DIJOYCONFIG));

    lpSelectedItem->dwSize = sizeof (DIJOYCONFIG);

    hr = pDIJoyConfig->GetConfig(nTarget, lpSelectedItem, DIJC_ALL);

    if( hr == DIERR_NOTFOUND || hr == S_FALSE )
    {
        if( lpSelectedItem )
            delete (lpSelectedItem);

        lpSelectedItem = NULL;
    }

    // ***********************************************************
    // Delete the configurations!
    // ***********************************************************

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    // ********************************************************
    // OK, now... at this point you have:
    //    lpSelectedID: containing NULL if the device wasn't present or...
    //                  a valid pointer containing the configuration of nSelectedID
    //    lpSelected  : containing NULL if the device wasn't present or...
    //                  a valid pointer containing the configuration of id
    // ********************************************************
    // Time to Set the Configurations!

    if( lpSelectedID )
    {
        hr = pDIJoyConfig->SetConfig(nTarget, lpSelectedID, DIJC_ALL);

        if( lpSelectedID )
            delete (lpSelectedID);
    } else pDIJoyConfig->DeleteConfig(nSource);

    // delete both configurations
    // pointers will be NULL if the config was not found!
    if( lpSelectedItem )
    {
        hr = pDIJoyConfig->SetConfig(nSource, lpSelectedItem, DIJC_ALL );

        if( lpSelectedItem )
            delete (lpSelectedItem);
    }

    pDIJoyConfig->SendNotify();

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_ARROW));
}

#else

// Memphis version of SwapIDs... 
// Caution!!! Very Sensitive!!!
void SwapIDs(BYTE nSelectedID, BYTE nSelectedItem)
{
    // malloc and retrieve the data from the selected item
    LPDIJOYCONFIG lpSelectedID = new (DIJOYCONFIG);

    DWORD dwSelectedID = 0, dwSelectedItem = 0;

    ASSERT (lpSelectedID);

    ZeroMemory(lpSelectedID, sizeof(DIJOYCONFIG));

    lpSelectedID->dwSize = sizeof(DIJOYCONFIG);

    // Get the Config of device on ID taken from Change List box!
    HRESULT hr = pDIJoyConfig->GetConfig(nSelectedID, lpSelectedID, DIJC_ALL);

    if( hr == DIERR_NOTFOUND || hr == S_FALSE )
    {
        // No Object on Selected ID!
        if( lpSelectedID )
            delete (lpSelectedID);

        lpSelectedID = NULL;
    } else {
        if( lpSelectedID )
            delete (lpSelectedID);

        lpSelectedID = NULL;
        
        Error((short)IDS_DEST_ID_OCCUPIED_TITLE, (short)IDS_DEST_ID_OCCUPIED);
        
        return;
    }


    // malloc and retrieve the data from the item associated 
    // with the ID taken from the Item selected in the List box!
    LPDIJOYCONFIG lpSelectedItem = new (DIJOYCONFIG);
    ASSERT (lpSelectedItem);

    ZeroMemory(lpSelectedItem, sizeof(DIJOYCONFIG));

    lpSelectedItem->dwSize = sizeof (DIJOYCONFIG);

    hr = pDIJoyConfig->GetConfig(nSelectedItem, lpSelectedItem, DIJC_ALL);

    if( hr == DIERR_NOTFOUND || hr == S_FALSE )
    {
        if( lpSelectedItem )
            delete (lpSelectedItem);

        lpSelectedItem = NULL;
        
        return;
    }

    // ***********************************************************
    // Delete the configurations!
    // ***********************************************************

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    // ********************************************************
    // OK, now... at this point you have:
    //    lpSelectedID: containing NULL if the device wasn't present or...
    //                  a valid pointer containing the configuration of nSelectedID
    //    lpSelected  : containing NULL if the device wasn't present or...
    //                  a valid pointer containing the configuration of id
    // ********************************************************
    // Time to Set the Configurations!


    if( lpSelectedID )
    {
        DWORD dwFlags = DIJC_REGHWCONFIGTYPE |  DIJC_CALLOUT  | DIJC_GAIN | DIJC_GUIDINSTANCE;
        USES_CONVERSION;

        // if the callout is joyhid.vxd then the device is USB so...
        // OR on the DIJC_WDMGAMEPORT flag!
        if( !_stricmp(TEXT("joyhid.vxd"), W2A(lpSelectedID->wszCallout)) )
        {
//            dwFlags |= DIJC_WDMGAMEPORT;
            dwSelectedID = 2;
        } else
        {
            dwSelectedID = 1;
        }

        if( dwSelectedID == 1 ) {
            hr = pDIJoyConfig->DeleteConfig(nSelectedID);
    
            /*
             * This notify is to fix the bug changing id on 2-axis 2-button joystick.
             */
            pDIJoyConfig->SendNotify();
    
            if( SUCCEEDED(hr) )
            {
                hr = pDIJoyConfig->SetConfig(nSelectedItem, lpSelectedID, dwFlags );
                
                if( SUCCEEDED(hr) ) {
                    pDIJoyConfig->SendNotify();
                }
            }
        } else {
            hr = pDIJoyConfig->SetConfig(nSelectedItem, lpSelectedID, dwFlags);
    
            pDIJoyConfig->SendNotify();

            if( SUCCEEDED(hr) )
            {
                hr = pDIJoyConfig->DeleteConfig(nSelectedID);
                
                pDIJoyConfig->SendNotify();

                if( nSelectedID < nSelectedItem ) {
                    pDIJoyConfig->SendNotify();
                }
            
            }
        }

        if( lpSelectedID )
            delete (lpSelectedID);
    }

    // delete both configurations
    // pointers will be NULL if the config was not found!
    if( lpSelectedItem )
    {
        DWORD dwFlags = DIJC_REGHWCONFIGTYPE |  DIJC_CALLOUT  | DIJC_GAIN | DIJC_GUIDINSTANCE;
        USES_CONVERSION;

        if( _tcsicmp(TEXT("joyhid.vxd"), W2A(lpSelectedItem->wszCallout)) == 0 )
        {
//            dwFlags |= DIJC_WDMGAMEPORT;
            dwSelectedItem = 2;  //joyhid.vxd
        } 
#if 0
        /*
         * Since MSGAME.VXD will directly write to the registry with some unhealthy data.
         * We have to change it before we move to other ID.
         */
        else if( _tcsicmp(TEXT("MSGAME.VXD"), W2A(lpSelectedItem->wszCallout)) == 0 )
        {
            lpSelectedItem->hwc.dwType += 1;
            dwSelectedItem = 3;  //msgame.vxd (Sidewinder driver)
        } 
#endif        
        else {
            dwSelectedItem = 1;  //vjoyd.vxd
        }

        if( dwSelectedItem == 1     // VJOYD.VXD,
//         || dwSelectedItem == 3 
         ){  // MSGAME.VXD
            hr = pDIJoyConfig->DeleteConfig(nSelectedItem);
    
            /*
             * This notify is to fix the bug changing id on 2-axis 2-button joystick.
             */
            pDIJoyConfig->SendNotify();
    
            if( SUCCEEDED(hr) )
            {
                hr = pDIJoyConfig->SetConfig(nSelectedID, lpSelectedItem, dwFlags );
                
                if( SUCCEEDED(hr) ) {
                    pDIJoyConfig->SendNotify();
                }
            }
        } else {
            hr = pDIJoyConfig->SetConfig(nSelectedID, lpSelectedItem, dwFlags );
    
            /*
             * This notify is to fix the bug changing id on 2-axis 2-button joystick.
             */
            pDIJoyConfig->SendNotify();
    
            if( SUCCEEDED(hr) )
            {
                hr = pDIJoyConfig->DeleteConfig(nSelectedItem);
                
                pDIJoyConfig->SendNotify();
                
                if( nSelectedID < nSelectedItem ) {
                    pDIJoyConfig->SendNotify();
                }
            
            }

        }

        if( lpSelectedItem )
        {
            delete (lpSelectedItem);
        }
    }

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_ARROW));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\applock.cpp ===
/*
File:		AppLock.cpp
Project:	
Author:	ScottLe
Date:		1/31/00
Comments:
    AppMan application locking (pinning) Tab in Game Control Panel.

Copyright (c) 1999, 2000 Microsoft Corporation
*/

// This is necessary LVS_EX_INFOTIP

#if (_WIN32_IE < 0x400)
#undef _WIN32_IE
#define  _WIN32_IE  0x400
	#if 0
	typedef struct tagNMITEMACTIVATE{
		NMHDR   hdr;
		int     iItem;
		int     iSubItem;
		UINT    uNewState;
		UINT    uOldState;
		UINT    uChanged;
		POINT   ptAction;
	    LPARAM  lParam;
	    UINT    uKeyFlags;
	} NMITEMACTIVATE, FAR *LPNMITEMACTIVATE;
	#endif
#endif

#include <afxcmn.h>
#include <windowsx.h>

#include <cpl.h>

#include <winuser.h>  // For RegisterDeviceNotification stuff!
#include <dbt.h>      // for DBT_ defines!!!
#include <commctrl.h>  // for listview
#include <tchar.h>    // for TCHAR
#include <malloc.h>	 // for _alloca

#include "hsvrguid.h"

#include "cpanel.h"
#include "resource.h"
#include "joyarray.h"

#ifdef MAX_DEVICES		// The control panel and the addman both define MAX_DEVICES, we'll use the AppMan supplied version
#undef MAX_DEVICES
#endif

#include <AppManAdmin.h>

#if _DEBUG
#define Assert(x) { if(!(x)) { DebugBreak(); }}
#else
#define Assert(x)
#endif

static HWND ghDlg;
static HWND hAppManCheckBox;
extern const DWORD gaHelpIDs[];
extern HINSTANCE ghInstance;

//
// GLOBALS
//
static BOOL g_ListPopulated = FALSE;
static int  g_nm_click = -1;
static BOOL g_nm_click_state = FALSE;
static BOOL g_DlgInitialized = FALSE;
static BOOL g_ChkBoxUpdate = FALSE;

static GUID *g_lpsGUID = NULL;

extern IApplicationManagerAdmin *g_IAppManAdmin;

static struct {
BOOL isValid;
int  iItem;
BOOL isClicked;
} g_ItemChanged;

// constants
const short NO_ITEM     = -1;                                    
static short iItem = NO_ITEM;   // index of selected item

// Forwards

//
// local forwards
//
static BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam);
static void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code);
static BOOL OnNotify(HWND hDlg, WPARAM idFrom, LPARAM lParam);

static void OnScroll(HWND hDlg, WPARAM wParam);
static void OnListCtrl_Select(HWND hDlg);
static void OnListCtrl_DblClick(HWND hDlg);
static void OnListCtrl_UpdateFromCheckBoxes( HWND hDlg );

static void OnAdvHelp       (LPARAM);
//static void OnContextMenu   (WPARAM wParam, LPARAM lParam);
static void OnListviewContextMenu (HWND hWnd, LPARAM lParam );


// util fcns
static int  MyInsertItem( HWND hCtrl, LPTSTR lpszBuff, int iItem );  // replaced from cpanel.cpp
static void PostDlgItemEnableWindow( HWND hDlg, USHORT nItem, BOOL bEnabled );
static void EnableDiskManageControls( HWND hDlg, BOOL bEnable );
static void EnableScrollBarAndText( HWND hDlg, BOOL bEnable );
//static void EnableAllControls( HWND hDlg, BOOL bEnable );
DWORD GetCurrentDeviceFromList( HWND hDlg, BYTE *nItem = NULL );

static void ConfigureListControl( HWND hDlg );
static void PopulateListControl( HWND hDlg, BYTE nItem );

void UpdateCurrentDeviceFromScrollBar( HWND hDlg, DWORD newPos );

//void UpdateListAndScrollBar( HWND hDlg, BOOL bJustScrollBar = FALSE );


// From AppMan.cpp
extern HRESULT AppManShutdown();
extern HRESULT AppManInit();
extern BOOL    AppManInitialized();

//
// from cpanel.cpp
//
extern void SetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpStr);
extern void InsertColumn(HWND hCtrl, BYTE nColumn, USHORT nStrID, USHORT nWidth);
extern BOOL SetItemData( HWND hCtrl, BYTE nItem, DWORD dwFlag );
extern DWORD GetItemData(HWND hCtrl, BYTE nItem );
extern void SetListCtrlItemFocus ( HWND hCtrl, BYTE nItem );


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	AppManLockProc(HWND hDlg,	ULONG uMsg,	WPARAM wParam,	LPARAM lParam)
//
// PARAMETERS:	hDlg    - 
//             uMsg    - 
//             wParam  -
//             lParam  -
//
// PURPOSE:		Main callback function for "Appman"  sheet
///////////////////////////////////////////////////////////////////////////////

BOOL WINAPI AppManLockProc(HWND hDlg, ULONG uMsg, WPARAM wParam,  LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_ACTIVATEAPP:
      if( wParam ) {
	    HWND hListCtrl = NULL;

		hListCtrl = GetDlgItem((HWND) wParam, IDC_APPMAN_DRIVE_LIST);

		SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);
      }
      break;

    case WM_DEVICECHANGE:
        switch( (UINT)wParam )
        {
        case DBT_DEVICEARRIVAL:
//         case DBT_DEVICEREMOVECOMPLETE:
            break;
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
      //PostMessage(GetParent(hDlg), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        if( !HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, OnInitDialog) )
        {
            // Fix #108983 NT, Remove Flash on Error condition.
            SetWindowPos(::GetParent(hDlg), HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
            DestroyWindow(hDlg);
        }
        return(TRUE);

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, OnCommand);
        return(TRUE);


    case WM_DESTROY:
      //return(HANDLE_WM_DESTROY(hDlg, wParam, lParam, OnDestroy));
        //jchauvin 04/10/2000  Fix Build break in Win64
		    free( g_lpsGUID );
        g_lpsGUID = NULL;
        return(TRUE);

    case WM_NOTIFY:
      return OnNotify(hDlg, wParam, lParam);

    case WM_HELP:
//      OnAdvHelp(lParam);
        return(TRUE);

    case WM_CONTEXTMENU:
//      OnContextMenu(wParam, lParam);
        return(TRUE);

    default:
        break;
    }
    return(0);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
//
// PARAMETERS:	hDlg    - 
//				   hWnd    - 
//				   lParam  -
//
// PURPOSE:		WM_INITDIALOG message handler
///////////////////////////////////////////////////////////////////////////////
BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
{
  HRESULT hr = S_OK;

  hr = AppManInit();

  //
  // init globals
  //
  ZeroMemory( &g_ItemChanged, sizeof(g_ItemChanged));
  g_DlgInitialized = FALSE;

  if( FAILED(hr) ) {
    //
    // Disable everything
    //

//    EnableAllControls(hDlg, FALSE);

    // 
    // popup saying: hey you need appman installed ?
    //

  } else {

    ghDlg = hDlg;

    //
    // Set defaults
    //
    
    //
    // Configure the List control, and then fill it in
    //
    ConfigureListControl( hDlg );
    PopulateListControl( hDlg, 0 );

    g_DlgInitialized = TRUE;

  }

  return(TRUE);
}






///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
//
// PARAMETERS:	hDlg    - 
//             id      - 
//             hWndCtl -
//             code    -
//
// PURPOSE:		WM_COMMAND message handler
///////////////////////////////////////////////////////////////////////////////
void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
{
  HRESULT hr = S_OK;

#if 0
  switch( id )    
    {

    case IDS_WHATSTHIS:
        {
            // point to help file
            LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
            ASSERT (pszHelpFileName);

            if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
                WinHelp((HWND)hDlg, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
            else OutputDebugString(TEXT("JOY.CPL: AppMan.cpp: OnCommand: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

            if( pszHelpFileName )
                delete[] (pszHelpFileName);
        }
        break;

	/*
    case IDC_APPMAN_MANAGE_DISK:
      {
	BOOL isChecked = (IsDlgButtonChecked(hDlg, id)) ? TRUE : FALSE;
	EnableDiskManageControls( hDlg, !isChecked );
      }
      break;
      */
    default:
      break;
    }
#endif
}


////////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION:	OnNotify(HWND hDlg, WPARAM idFrom, NMHDR* pnmhdr)
//
// PARAMETERS:	hDlg   - 
//             idFrom - ID of control sending WM_NOTIFY message
//             pnmhdr -
//
// PURPOSE:		WM_NOTIFY message handler
////////////////////////////////////////////////////////////////////////////////

static DWORD ct=0L;

BOOL OnNotify(HWND hDlg, WPARAM idFrom, LPARAM lParam)
{
	NMLISTVIEW     *pnmv = NULL;
	LPNMHDR         pnmhdr = (LPNMHDR)lParam;


	switch (pnmhdr->code)
  {
    //  4/13/2000(RichGr): Repopulate the List Control if we reacquire the focus.
    //     This keeps the data in sync with installs and uninstalls. 
    case NM_SETFOCUS:
    {
      PopulateListControl(hDlg, 0);
      break;
    }  

  	case LVN_ITEMCHANGED:
    	pnmv = (LPNMLISTVIEW) lParam;

      if( idFrom == IDC_APPMAN_PIN_LIST ) 
    	{
	      // this is called if a new item has been selected
	      // or if the user clicked on the checkbox, changing state
				
#ifdef _DEBUG
        {    
  			TCHAR tstring[256];
	  		NMITEMACTIVATE *pitemact = (LPNMITEMACTIVATE)lParam;
		  	_stprintf(tstring, TEXT("JOY.CPL: AppLock.cpp: OnNotify: LVN_ITEMCHANGED, ct=%ld,idFrom=%lx, item=%lx uChanged=%lx uNewState=%lx uOldState=%lx lParam=%lx\n"),
			          	++ct,idFrom,pitemact->iItem,pitemact->uChanged,pitemact->uNewState,pitemact->uOldState,pitemact->lParam);
			  OutputDebugString(tstring);
		    }
#endif // _DEBUG
				
		    if ( AppManInitialized() && 
		      g_DlgInitialized && 
			    (pnmv->uNewState & LVIS_SELECTED || 
			    pnmv->uNewState == 0x1000 || pnmv->uNewState == 0x2000) && 
			    // TODO: Find definitions for x1000 and x2000 (check box state change in a list view control)
			    g_ChkBoxUpdate ) 
		    {
    			NMITEMACTIVATE *ll = (LPNMITEMACTIVATE)lParam;
		    	HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_PIN_LIST);

			    g_ItemChanged.isValid = TRUE;
			    g_ItemChanged.iItem = ll->iItem;
			    g_ItemChanged.isClicked = FALSE;

			    //
			    // this flag is VERY important for consistent state changes 
			    // and eliminating race conditions
			    //
			    g_ChkBoxUpdate = FALSE;
			    OnListCtrl_UpdateFromCheckBoxes( hDlg );
			    g_ChkBoxUpdate = TRUE;

			    g_ItemChanged.isValid = FALSE;

			    g_ItemChanged.iItem = ll->iItem;
			    OnListCtrl_Select( hDlg );
		    }

        return TRUE;
        break;
	    } // if
    } // switch

  return(0);
}


  
void OnListCtrl_UpdateFromCheckBoxes( HWND hDlg )
{
#if 1
  HRESULT hResult;
  BOOL bIsAppManPinned = FALSE;
  BOOL bDoToggle = FALSE;
  BYTE nItem = 0;
  GUID *pGuid = NULL;
  IApplicationManager * lpApplicationManager;
  IApplicationEntry   * lpApplicationEntry;
  DWORD dwIndex;

  //
  // go through each item, check the box & set pinning
  //
  HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_PIN_LIST);
  if( !hLC ) return;

  int iItem = -1;
  //while( (iItem = ListView_GetNextItem( hLC, iItem, LVNI_ALL )) >= 0 ) 
  if( g_ItemChanged.isValid )
    {
      
		//
		// very important: tell the system that this information is no longer
		// valid.  Hence we won't recurse mysteriously or unpredictably.
		//
		g_ItemChanged.isValid = FALSE;

		iItem = g_ItemChanged.iItem;
		BOOL bIsCheckBoxPinned = !(ListView_GetCheckState( hLC, iItem )); // Check box has the new state NOW

		// Set the pin state using the GUID to identify the app

		//JWC  4/10/2000 Added to fix Win64 Build problem
		dwIndex = (DWORD) GetItemData(hLC, (BYTE)iItem );	  
		pGuid =  (GUID *) ((ULONG_PTR)g_lpsGUID + (ULONG_PTR)dwIndex*sizeof(GUID));	  
		

		// Find out what the pin state is in AppMan
		// Get an Application Manager interface
		hResult = CoCreateInstance(CLSID_ApplicationManager, NULL, CLSCTX_INPROC_SERVER, IID_ApplicationManager, (LPVOID *) &lpApplicationManager);
		if (SUCCEEDED(hResult))
		{

			// Get an application entry object.  
			hResult = lpApplicationManager->CreateApplicationEntry(&lpApplicationEntry);
			if (SUCCEEDED(hResult))
			{

				// Set the app's GUID
				hResult = lpApplicationEntry->SetProperty(APP_PROPERTY_GUID, pGuid, sizeof(GUID));
				if (SUCCEEDED(hResult))
				{

					// Populate the app info structure
					hResult = lpApplicationManager->GetApplicationInfo(lpApplicationEntry);
					if (SUCCEEDED(hResult))
					{
					
						// Get the current PIN state of the app
						hResult = lpApplicationEntry->GetProperty(APP_PROPERTY_PIN, &bIsAppManPinned, sizeof(bIsAppManPinned));
						if (SUCCEEDED(hResult))
						{

							// bIsAppManPinned is the state appman has for the application.
							// bIsCheckBoxPinned is the check box state (checked = true = not pinned)
							// Since AppMan's pinning state for an app is a toggle we could get out of sync
							// due to redraw or timing issues with the list view control -- so,
							// we need to make sure that the check box's state is insync with AppMan.
							// When in doubt, force it to the displayed state of the check box.

							// Truth table:
							//			
							// AppManPinned	CheckBoxPinned (T=not checked) DoToggle	Reason
							//		T			T							No		Same State Already (sync error!)
							//		F			F							No		Same State Already (sync error!)
							//		T			F							Yes		New State Selected
							//		F			T							Yes		New State Selected
							//
							if (bIsAppManPinned != bIsCheckBoxPinned) 
								bDoToggle = TRUE;
							else
							{
								// ERR: BUG BUG: The control panel and appman are out of sync, this is an error.
								bDoToggle = FALSE;
								#ifdef _DEBUG
									OutputDebugString(TEXT("JOY.CPL: AppLock.cpp: Pinning Update, AppMan and Check box states are out of sync!\n"));
								#endif // _DEBUG

							}
	  
							if (bDoToggle && pGuid && g_IAppManAdmin) // Toggle the pin state
								hResult = g_IAppManAdmin->DoApplicationAction(ACTION_APP_PIN, pGuid, 0, (LPVOID) NULL, sizeof(DWORD));

							// ERR: Handle error conditions
						}
					}
				}
				lpApplicationEntry->Release();
			}
			lpApplicationManager->Release();
		}
    }
      
	g_ChkBoxUpdate = TRUE;
#endif
}


void OnListCtrl_Select(HWND hDlg)
{
  //
  // set focus on that item
  //
  HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_PIN_LIST);
  SetListCtrlItemFocus( hLC, (BYTE)g_ItemChanged.iItem );
}

int MyInsertItem( HWND hCtrl, LPTSTR lpszBuff, int iItem )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    ZeroMemory( plvItem, sizeof( LVITEM ) );

    plvItem->mask         = LVIF_TEXT;
    plvItem->pszText      = lpszBuff;
    plvItem->cchTextMax = lstrlen(lpszBuff);
    plvItem->iItem       = iItem;

    return ListView_InsertItem(hCtrl, (const LPLVITEM)plvItem);
}


#define APPMAN_ADV_PIN_CHECKBOX 0
#define APPMAN_ADV_PIN_TITLENAME 1

#define IDS_APPMANPIN_CHECKBOX			40043
#define IDS_APPMANPIN_TITLENAME			40044



void ConfigureListControl( HWND hDlg )
{
#if 1
	HWND hLC;

  hLC = GetDlgItem(hDlg, IDC_APPMAN_PIN_LIST);
  ::SendMessage( hLC , LVM_SETEXTENDEDLISTVIEWSTYLE, 0, 
		 LVS_EX_FULLROWSELECT
		 | LVS_EX_CHECKBOXES
		 | LVS_EX_HEADERDRAGDROP
		 // LVS_EX_TWOCLICKACTIVATE    // LVN_ITEMACTIVATE (WM_NOTIFY)
		 );

  RECT rc;
  GetClientRect(hLC, &rc);
  DWORD w = rc.right-rc.left;
  DWORD w1 = w / 3;            // 1/3 of width
  DWORD w2 = w - w1;           // 2/3 of the width
  InsertColumn(hLC, APPMAN_ADV_PIN_CHECKBOX, IDS_APPMANPIN_CHECKBOX, (USHORT)(w1));
  InsertColumn(hLC, APPMAN_ADV_PIN_TITLENAME,IDS_APPMANPIN_TITLENAME,  (USHORT)(w2));

#endif
}


//STDMETHODIMP CApplicationManagerAdmin::DoApplicationAction(const DWORD dwAction, const GUID * lpGuid, LPVOID lpData, const DWORD dwDataLen)
//STDMETHODIMP CApplicationManagerAdmin::EnumApplications(const DWORD dwApplicationIndex, IApplicationEntry * lpObject)


// populates from appman state
void PopulateListControl( HWND hDlg, BYTE nItem )
{
#if 1
	HRESULT                 hr = S_OK;
  BOOL                    isExcluded = FALSE;
  UCHAR                   listIndex = (UCHAR)0;
  IApplicationManager    *lpApplicationManager;
  IApplicationEntry      *lpApplicationEntry;
  HRESULT                 hResult;
  DWORD                   dwIndex = 0L;
  TCHAR                   szString[MAX_PATH];
  GUID                    sGuid;


  g_ListPopulated = FALSE;
  g_ChkBoxUpdate = FALSE;

  Assert( AppManInitialized() );

  HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_PIN_LIST);

  // Turn Redraw off here else it will flicker!
  ::SendMessage(hLC, WM_SETREDRAW, (WPARAM)FALSE, 0);
  
  // Out with the old...
  ::SendMessage(hLC, LVM_DELETEALLITEMS, 0, 0);

   //JWC 04/10/2000  Fixing build break in Win64 code
   g_lpsGUID = (GUID *)malloc(sizeof(GUID));
   if (g_lpsGUID == NULL) 
   {
	   //Cannot allocate memory
	   hResult = E_UNEXPECTED;
   }
	// Get an Application Manager interface
    hResult = CoCreateInstance(CLSID_ApplicationManager, NULL, CLSCTX_INPROC_SERVER, IID_ApplicationManager, (LPVOID *) &lpApplicationManager);
    if (SUCCEEDED(hResult) && g_IAppManAdmin)
    {

		// Get an application entry object.  This will be populated during the Enumeration loop
		hResult = lpApplicationManager->CreateApplicationEntry(&lpApplicationEntry);
		if (SUCCEEDED(hResult))
		{
			// Enumerate all the applications AppMan knows about
			dwIndex = 0;
			while (SUCCEEDED(g_IAppManAdmin->EnumApplications(dwIndex, lpApplicationEntry)))
			{
				// For each app, get information about it (Pinning state, title, GUID etc) and put in the list
				DWORD dwState = 0L;

				// App must be in a good state
				hResult = lpApplicationEntry->GetProperty(APP_PROPERTY_STATE, &dwState, sizeof(dwState));

				dwState &= APP_STATE_MASK;

				if (!SUCCEEDED(hResult) ||
					dwState == APP_STATE_INSTALLING || 
					dwState == APP_STATE_UNSTABLE)
				{
					dwIndex++;
					continue; // Skip bad apps
				}
				else // Good app...
				{
					// Create the check box
					int actualListIndex = MyInsertItem( hLC, _T(""), dwIndex );

					// Get the app's GUID
					hResult = lpApplicationEntry->GetProperty(APP_PROPERTY_GUID, &sGuid, sizeof(sGuid));
			        if (SUCCEEDED(hResult))
					{
						// Allocate a GUID
						// ISSUE-2001/03/29-timgill Need error handling

						//JWC 04/10/2000  Fixing problem with GUID for Win64

						g_lpsGUID = (GUID *)realloc((void*)g_lpsGUID,(dwIndex+1)* sizeof(GUID));
						
						*(GUID *)((ULONG_PTR)g_lpsGUID+((ULONG_PTR)(dwIndex)*sizeof(GUID)))= sGuid;

						SetItemData(hLC, (BYTE)actualListIndex,  dwIndex );
					}

					// Get Pin state
					{
						DWORD bPinned = FALSE;
						hResult = lpApplicationEntry->GetProperty(APP_PROPERTY_PIN, &bPinned, sizeof(bPinned));
					    if (SUCCEEDED(hResult))
							ListView_SetCheckState( hLC, actualListIndex, (BOOL)!bPinned ); // Checked=not pinned
					}

					// TODO:  Company name and/or signature...?
					//				hResult = lpApplicationEntry->GetProperty(APP_PROPERTY_COMPANYNAME | APP_PROPERTY_STR_ANSI, &szString, sizeof(szString));

#ifdef _UNICODE
					hResult = lpApplicationEntry->GetProperty(APP_PROPERTY_SIGNATURE | APP_PROPERTY_STR_UNICODE, &szString, sizeof(szString));
#else
					hResult = lpApplicationEntry->GetProperty(APP_PROPERTY_SIGNATURE | APP_PROPERTY_STR_ANSI, &szString, sizeof(szString));
#endif
					// Set the title name in the "title column"
					if (SUCCEEDED(hResult))
						SetItemText(hLC, (BYTE)actualListIndex, APPMAN_ADV_PIN_TITLENAME, szString);
				}
				dwIndex++;
			}
		}
		lpApplicationEntry->Release();
    }

    lpApplicationManager->Release();

  //
  // set focus on that item
  //
  SetListCtrlItemFocus( hLC, nItem );

  //
  // Turn the redraw flag back on!
  // 
  ::SendMessage (hLC, WM_SETREDRAW, (WPARAM)TRUE, 0);

  g_ListPopulated = TRUE;
  g_ChkBoxUpdate = TRUE;
#endif
}


void EnableScrollBarAndText( HWND hDlg, BOOL bEnable )
{
#if 0
	HWND hwnd;

  // SCROLLBAR
  //PostDlgItemEnableWindow( hDlg, IDC_APPMAN_SCROLLBAR, enableManageDiskSpace );
  hwnd =  GetDlgItem(hDlg, IDC_APPMAN_SCROLLBAR);
  EnableWindow( hwnd, bEnable );

  // TEXT
  hwnd = GetDlgItem(hDlg, IDC_APPMAN_TEXT_PERCENT_DISK_USED);
  EnableWindow( hwnd, bEnable );
#endif
}

///////////////////////////////////////////////////////////////////
//  AppMan functions
///////////////////////////////////////////////////////////////////

#define RELEASE(p) { if((p)) { (p)->Release(); p = NULL; } }

#if 0					       
////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnAdvHelp ( LPARAM lParam )
//
// PARAMETERS:  lParam - Pointer to HELPINFO struct
//
// PURPOSE:     WM_HELP message handler
////////////////////////////////////////////////////////////////////////////////////////
void OnAdvHelp(LPARAM lParam)
{
    ASSERT (lParam);

    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    ASSERT (pszHelpFileName);

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
    {
        if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: AppMan.cpp: OnAdvHelp: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnContextMenu ( WPARAM wParam )
//
// PARAMETERS:  wParam - HWND of window under the pointer
//
// PURPOSE:     Handle WM_RBUTTONDOWN over all client windows 
// (except the list control... that's OnListviewContextMenu() job)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam, LPARAM lParam)
{
//    HWND hListCtrl = NULL
    ASSERT (wParam);

#if 0
    hListCtrl = GetDlgItem((HWND) wParam, IDC_APPMAN_DRIVE_LIST);

    // If you are on the ListCtrl...
    if( (HWND)wParam == hListCtrl )
    {
        SetFocus(hListCtrl);

        // Don't attempt if nothing selected
        if( iItem != NO_ITEM )
            OnListviewContextMenu(hListCtrl,lParam);
    } else
#endif
    {
        // point to help file
        LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
        ASSERT (pszHelpFileName);

        if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
            WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
        else OutputDebugString(TEXT("JOY.CPL: appman.cpp: OnContextMenu: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

        if( pszHelpFileName )
            delete[] (pszHelpFileName);
    }
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnListviewContextMenu( void )
//
// PURPOSE:     Handle Context menu in Listview
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
static void OnListviewContextMenu( HWND hWnd, LPARAM lParam )
{
    HMENU hPopupMenu = CreatePopupMenu();
    HWND hListCtrl = NULL;

    hListCtrl = GetDlgItem(hWnd, IDC_APPMAN_DRIVE_LIST);
    ASSERT (hPopupMenu);

    // unlike life, bRet defaults to bliss
    BOOL bRet = TRUE;

    LPTSTR pszText = new TCHAR[STR_LEN_32];
    ASSERT (pszText);

    // Don't display Rename/Change if on (none) entry
    if( !(GetItemData(hListCtrl, (BYTE)iItem) & ID_NONE) )
    {
        if( TRUE ) // Borrowed code...
        {
            // add the "Change..." string
            ::SendDlgItemMessage(GetParent(hListCtrl), IDC_ADV_CHANGE, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)pszText);

            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_ADV_CHANGE, pszText); 
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

            // Add the Rename text
            VERIFY(LoadString(ghInstance, IDS_RENAME, pszText, STR_LEN_32));
            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_RENAME, pszText);
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

            // Add the SEPERATOR and "What's this?"
            bRet = AppendMenu(hPopupMenu, MF_SEPARATOR, 0, 0); 
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert SEPERATOR!\n"));
#endif //_DEBUG
        }
    }

    VERIFY(LoadString(ghInstance, IDS_WHATSTHIS, pszText, STR_LEN_32));
    bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDS_WHATSTHIS, pszText); 
#ifdef _DEBUG
    if( !bRet )
        TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

    if( pszText ) delete[] (pszText);

    POINT pt;

    // lParam is -1 if we got here via Shift+F10
    if( lParam > 0 )
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    } else
    {
        // Centre the popup on the selected item!

        // This get's a good X pos, but the y is the start of the control!
        ::SendMessage(hListCtrl, LVM_GETITEMPOSITION, iItem, (LPARAM)&pt);

        RECT rc;
        ::GetClientRect(hListCtrl, &rc);

        pt.x = rc.right>>1;

        ClientToScreen(hListCtrl, &pt);
    }

    bRet = TrackPopupMenu (hPopupMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, 0, ghDlg, NULL);
#ifdef _DEBUG
    if( !bRet )
        TRACE (TEXT("JOY.CPL: OnListviewContextMenu: TrackPopupMenu Failed!\n"));
#endif //_DEBUG

    DestroyMenu (hPopupMenu);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\add.cpp ===
/*
File:		add.cpp
Project:	Universal Joystick Control Panel OLE Client
Author:  Brycej	
Date:		14/Feb/97
Comments:
    window proc for add dialog

Copyright (c) 1995, Microsoft Corporation
*/

#include <afxcmn.h>
#include <windowsx.h>
#include <regstr.h>		  // for REGSTR_VAL_JOYOEMNAME reference!

#include "cpanel.h"
#include "joyarray.h"

#include <initguid.h>

#pragma warning(disable:4200) 
#include <gameport.h>
#pragma warning(default:4200)

// table of default joystick configs
extern WCHAR *pwszTypeArray[MAX_DEVICES];    // List of enumerated gameport devices
extern WCHAR *pwszGameportBus[MAX_BUSSES];   // List of enumerated gameport buses 
extern PJOY  pAssigned[MAX_ASSIGNED];        // List of assigned devices
extern BYTE  nAssigned;                      // Number of elements in pAssigned array
extern BYTE  nTargetAssigned;                // Number of elements expected when pending adds complete
extern BYTE  nReEnum;                        // Counter used to decide when to reenumerate

extern GUID guidOccupied[MAX_BUSSES];    //Whether the gameport bus has been occupied.

extern BYTE  nGameportBus, nGamingDevices;

extern IDirectInputJoyConfig *pDIJoyConfig;
extern short iItem;
extern short nFlags;        // Flags set in CPANEL.CPP!

// extern functions defined in CPANEL.CPP
extern void OnContextMenu(WPARAM wParam, LPARAM lParam);
extern void OnHelp       (LPARAM);


// local message handlers
static BOOL OnInitDialog(HWND, HWND, LPARAM);
static void OnClose(HWND);
static void OnCommand(HWND, int, HWND, UINT);

static char AddSelectedItem( HWND hDlg );
static BOOL UpdateListCtrl ( HWND hCtrl );
static char GetNextAvailableID( void );
static BOOL IsTypeActive( short *nArrayIndex );
static BOOL GetNextAvailableVIDPID(LPWSTR lpwszType );
//static BOOL IsCustomType(BYTE nIndex);

static void PostHScrollBar(HWND hCtrl, LPCTSTR lpStr, BYTE nStrLen);

extern const DWORD g_aHelpIDs[];

extern HINSTANCE ghInstance;

LPTSTR lpszAutoDetect;

const int NO_ITEM = -1;
#define MAX_ANALOG_BUTTONS 4
#define MAX_ANALOG_AXIS    4

// This will become a problem when we support > 500 ports!
#define AUTODETECT_PORT	   100  

// Consider achieving this from calculation of width of listview
static short iAddItem = NO_ITEM;


BOOL WINAPI AddDialogProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_DESTROY:
        DestroyIcon((HICON)SendMessage(hDlg, WM_GETICON, (WPARAM)ICON_SMALL, 0));

        if( nGameportBus > 1 )
            if( lpszAutoDetect )
                delete[] (lpszAutoDetect);
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(hDlg, WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        return(BOOL)HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, OnInitDialog);

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, OnCommand);
        return(1);

    case WM_VKEYTOITEM:
        if( LOWORD(wParam) == VK_DELETE )
        {
            HWND hWnd = GetDlgItem(hDlg, IDC_DEVICE_LIST);

            // determine if it's a custom type... if so... delete it
            // Get the next object with the SELECTED attribute
            iAddItem = (short)::SendMessage(hWnd, LB_GETCURSEL, 0, 0);

            short nArrayIndex = (short)::SendMessage(hWnd, LB_GETITEMDATA, (WPARAM)iAddItem, 0);

            // test to make sure they aren't trying to delete a standard type
            if( *pwszTypeArray[nArrayIndex] == L'#' )
                break;

            // test that the device is a custom type (user or IHV defined)
            // ISSUE-2001/03/29-timgill the number of times we retrieve the same data is ridiculous
            LPDIJOYTYPEINFO lpdiJoyInfo = new (DIJOYTYPEINFO);
            ASSERT (lpdiJoyInfo);

            if( lpdiJoyInfo )
            {
                /*
                 *  warning, abuse of S_OK == 0 == strcmp( identical strings ) ahead
                 */
                HRESULT CmpRes;

                ZeroMemory(lpdiJoyInfo, sizeof(*lpdiJoyInfo));

                lpdiJoyInfo->dwSize = sizeof(*lpdiJoyInfo);

                /*
                 *  Test the hardware ID
                 */
                CmpRes = pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_HARDWAREID);
                if( SUCCEEDED( CmpRes ) )
                {
#ifndef WINNT
                    if( lpdiJoyInfo->wszHardwareId[0] == L'\0' )
                    {
                        /*
                         *  No hardware ID, so look for a callout VxD
                         *  If there is none, we have a custom type.
                         */
                        CmpRes = pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_CALLOUT);
                        CmpRes = ( SUCCEEDED( CmpRes ) && ( lpdiJoyInfo->wszCallout[0] == L'\0' ) )
                               ? S_OK : S_FALSE;
                    }
                    else 
#endif
                    {
                        const WCHAR wszAnalogRoot[] = L"gameport\\vid_045e&pid_01";

                        CmpRes = (HRESULT)_wcsnicmp( lpdiJoyInfo->wszHardwareId, wszAnalogRoot, 
                                (sizeof(wszAnalogRoot)/sizeof(wszAnalogRoot[0]) ) - 1 );
                    }
                }
                else
                {
                    CmpRes = S_FALSE;
                }

                // clean-up!
                delete (lpdiJoyInfo);

                if( CmpRes != S_OK )
                {
                    // This is not an analog type so leave alone
                    break;
                }
            }
            else
            {
                //  If we can't test the type, do nothing
                break;
            }


            // test to make sure you are not deleting objects
            if( IsTypeActive(&nArrayIndex) )
            {
                Error((short)IDS_GEN_AREYOUSURE_TITLE, (short)IDS_NO_REMOVE);
                break;
            }

            // This buffer has to be big enough for the name and the "are you sure..." message!
            LPTSTR pszMsg   = new TCHAR[MAX_STR_LEN+STR_LEN_64];
            ASSERT (pszMsg);

            LPTSTR pszTitle = new TCHAR[STR_LEN_128];
            ASSERT (pszTitle);

            // Query user if they are sure!
            VERIFY(LoadString(ghInstance, IDS_GEN_AREYOUSURE, pszTitle, MAX_STR_LEN));

            LPTSTR pszTmp = new TCHAR[(short)SendMessage(hWnd, LB_GETTEXTLEN, (WPARAM)iAddItem, 0)+1];
            ASSERT (pszTmp);

            SendMessage(hWnd, LB_GETTEXT, (WPARAM)iAddItem, (LPARAM)(LPCTSTR)pszTmp);

            wsprintf( pszMsg, pszTitle, pszTmp);

            if( pszTmp )
                delete[] (pszTmp);

            VERIFY(LoadString(ghInstance, IDS_GEN_AREYOUSURE_TITLE, pszTitle, STR_LEN_128));

            HRESULT hr = MessageBox(hWnd, pszMsg, pszTitle, MB_ICONQUESTION | MB_YESNO | MB_APPLMODAL);

            if( pszMsg )     delete[] (pszMsg);
            if( pszTitle )   delete[] (pszTitle);

            if( IDYES == hr )
            {

                if( SUCCEEDED(hr = pDIJoyConfig->Acquire()) )
                {
                    // traverse the list and delete any configuration that may have this type assigned to it!
                    //DeleteAssignedType( pwszTypeArray[nArrayIndex] );

                    // returns E_ACCESSDENIED if it's a default item.
                    hr = pDIJoyConfig->DeleteType(pwszTypeArray[nArrayIndex]);
                    ASSERT(SUCCEEDED(hr));

                    pDIJoyConfig->Unacquire();

                    // the dec is for the zero based device list!
                    // decrement the indexes
                    nGamingDevices--;

                    // don't move if you're on the last entry!
                    if( nArrayIndex != nGamingDevices )
                    {
                        // To avoid deleting and recreating...
                        // Let's see if we have room to put this string!
                        BYTE nLen = (BYTE)wcslen(pwszTypeArray[nArrayIndex])+1;

                        // Make sure pwszTypeArray[nArrayIndex] is larger than pwszTypeArray[nCount]
                        if( nLen < (BYTE)wcslen(pwszTypeArray[nGamingDevices])+1 )
                        {
                            if( pwszTypeArray[nArrayIndex] )
                                free(pwszTypeArray[nArrayIndex]);

                            pwszTypeArray[nArrayIndex] = _wcsdup(pwszTypeArray[nGamingDevices]);
                            ASSERT (pwszTypeArray[nArrayIndex]);
                        }
                        // move the end element to the place of the deleted one
                        else wcsncpy(pwszTypeArray[nArrayIndex], pwszTypeArray[nGamingDevices], wcslen(pwszTypeArray[nGamingDevices])+1);

                        // update the extra memory to reflect the new index!
                        // First, find the item in the listbox and get the index...
                        LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
                        ASSERT (lpdiJoyInfo);

                        ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

                        lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

                        if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_DISPLAYNAME)) )
                        {
                            char n = (char)SendMessage(hWnd, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)lpdiJoyInfo->wszDisplayName);
                            SendMessage(hWnd, LB_SETITEMDATA, (WPARAM)n, (LPARAM)nArrayIndex);
                        }

                        // clean-up!
                        if( lpdiJoyInfo )
                            delete (lpdiJoyInfo);
                    }

                    // delete the end element from the array
                    if( pwszTypeArray[nGamingDevices] )
                    {
                        free(pwszTypeArray[nGamingDevices]);
                        pwszTypeArray[nGamingDevices] = 0;
                    }

                    // Remove the entry from the list control
                    SendMessage(hWnd, LB_DELETESTRING, (WPARAM)iAddItem, 0);

                    // Enable the buttons!
                    if( nGamingDevices < MAX_DEVICES-1 )
                    {
                        HWND hParent = GetParent(hWnd);
                        ASSERT (hParent);

                        PostDlgItemEnableWindow(hParent, IDC_CUSTOM,  TRUE);
                        PostDlgItemEnableWindow(hParent, IDC_ADD_NEW, TRUE);
                    }

                    if( iAddItem != nGamingDevices-1 )
                        iAddItem--;

                    // Set the focus to the next available item
                    PostMessage(hWnd, LB_SETCURSEL, (WPARAM)(iAddItem == NO_ITEM) ? 0 : iAddItem, 0);
                }
            }
            break;
        } else return(-1);

//	case WM_NOTIFY:
///		return HANDLE_WM_NOTIFY(hDlg, wParam, lParam, OnNotify);

    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam, lParam);
        return(1);
    }
    return(0);
} 

BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
{
    HICON hIcon = (HICON)LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CPANEL), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
    ASSERT (hIcon);

    if( hIcon )
        ::PostMessage(hDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);

    if( nFlags & ON_NT )
        DestroyWindow(GetDlgItem(hDlg, IDC_WDM));
    else
    {
        HKEY hKey;

        // remove the WDM flag unless otherwise specified!
        if( RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources\\joystick\\<FixedKey>"), &hKey) == ERROR_SUCCESS )
        {
            DWORD n;
            DWORD dwSize = sizeof (DWORD);

            if( RegQueryValueEx(hKey, TEXT("UseWDM"), 0, 0, (LPBYTE)&n, &dwSize) == ERROR_SUCCESS )
            {
                if( n )
                    DestroyWindow(GetDlgItem(hDlg, IDC_WDM));
            }
        }

        RegCloseKey(hKey);
    }


    // a simple debug test to verify that the template hasn't gotten DIALOGEX style again!
    HWND hCtrl = GetDlgItem(hDlg, IDC_DEVICE_LIST);
    ASSERT (hCtrl);

    // Fill up the Device List
    if( !UpdateListCtrl(hCtrl) )
    {
        TRACE(TEXT("JOY.CPL: ADD.CPP: Failed UpdateListCtrl!\n"));
        return(FALSE);
    }

    // If there is only one, don't confuse the user with the combo box
    if( nGameportBus > 1 )
    {
        // Allocate for AutoDetect Gameport!
        lpszAutoDetect = new (TCHAR[STR_LEN_32]);
        ASSERT (lpszAutoDetect);

        VERIFY(LoadString(ghInstance, IDS_AUTO_DETECT, lpszAutoDetect, STR_LEN_32));

        hCtrl = GetDlgItem(hDlg, IDC_GAMEPORTLIST);
        ASSERT (hCtrl);

        if( !PopulatePortList(hCtrl) )
        {
            TRACE(TEXT("JOY.CPL: ADD.CPP: Failed PopulatePortList!\n"));
            return(FALSE);
        }

        LPDIJOYTYPEINFO lpdiJoyInfo = new DIJOYTYPEINFO;
        ASSERT (lpdiJoyInfo);

        ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO));

        lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO);

        VERIFY(SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[0], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_FLAGS1)));

        // Search for AutoDetect in the list!
        char nIndex = (char)::SendMessage(hCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)(LPCTSTR)lpszAutoDetect);

        // If it's got the JOYTYPE_NOAUTODETECTGAMEPORT flag, remove AutoDetect from the ListCtrl
        if( lpdiJoyInfo->dwFlags1 & JOYTYPE_NOAUTODETECTGAMEPORT )
        {
            // it could fail because the entry is not available...
            if( nIndex != CB_ERR )
                ::SendMessage(hCtrl, CB_DELETESTRING, (WPARAM)nIndex, 0);

        }
        // Otherwise, verify that AutoDetect is present... if not, add it!
        else
        {
            // it could fail because the entry is not available...
            if( nIndex == CB_ERR )
                ::SendMessage(hCtrl, CB_SETITEMDATA, ::SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpszAutoDetect), AUTODETECT_PORT);
        }

        if( lpdiJoyInfo )
            delete (lpdiJoyInfo);

        SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        SetWindowPos( GetDlgItem(hDlg, IDC_GAMEPORT), NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);
    }

    // blj: Warning Message that you can't add any more devices!
    if( nGamingDevices == MAX_DEVICES-1 )
    {
        // Disable the Custom Button!
        PostDlgItemEnableWindow(hDlg, IDC_CUSTOM,  FALSE);
        PostDlgItemEnableWindow(hDlg, IDC_ADD_NEW, FALSE);

        // Give the user a error message!
        Error((short)IDS_MAX_DEVICES_TITLE, (short)IDS_MAX_DEVICES_MSG);
    }

    return(0);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
//
// PARAMETERS:	hDlg    - 
//             id      - 
//             hWndCtl -
//             code    -
//
// PURPOSE:		WM_COMMAND message handler
///////////////////////////////////////////////////////////////////////////////
void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
{
    switch( id )
    {
    case IDC_ADD_NEW:    
        if( SUCCEEDED(pDIJoyConfig->AddNewHardware(hDlg, GUID_MediaClass)) )
        {
            ClearArrays();

            if( FAILED(pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL)) )
            {
                TRACE(TEXT("JOY.CPL: ADD.CPP: Failed BuildEnumList!\n"));
                return;
            }

            // Warning Message that you can't add any more devices!
            if( nGamingDevices == MAX_DEVICES-1 )
            {
                // Disable the Custom Button!
                PostDlgItemEnableWindow(hDlg, IDC_CUSTOM,  FALSE);
                PostDlgItemEnableWindow(hDlg, IDC_ADD_NEW, FALSE);

                // Give the user a error message!
                Error((short)IDS_MAX_DEVICES_TITLE, (short)IDS_MAX_DEVICES_MSG);
            }

            if( !UpdateListCtrl(GetDlgItem(hDlg, IDC_DEVICE_LIST)) )
            {
                TRACE(TEXT("JOY.CPL: ADD.CPP: Failed to update the list control on the add page!\n"));
                return;
            }
        }
        break;

    case IDC_CUSTOM:
        // DialogBox returns either IDCANCEL or the index into the list of
        // defined types!
        if( IDOK == DialogBox(ghInstance, (PTSTR)IDD_CUSTOM, hDlg, (DLGPROC)CustomDialogProc) )
        {
            HWND hCtrl = GetDlgItem(hDlg, IDC_DEVICE_LIST);

            // blj: Warning Message that you can't add any more devices!
            if( nGamingDevices == MAX_DEVICES-1 )
            {
                // Disable the Custom Button!
                PostDlgItemEnableWindow(hDlg, IDC_CUSTOM, FALSE);

                // Give the user a error message!
                Error((short)IDS_MAX_DEVICES_TITLE, (short)IDS_MAX_DEVICES_MSG);
            }

            // Now, put the focus on the newly created item!
            LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
            ASSERT (lpdiJoyInfo);

            ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

            lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

            // Get nGamingDevices from pwszTypeArray
            // Subtract 1 from nGamingDevices because the list is 0 based!
            if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nGamingDevices-1], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_DISPLAYNAME | DITC_REGHWSETTINGS)) )
            {
#ifdef _UNICODE                                                               
                iAddItem = (short)SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpdiJoyInfo->wszDisplayName);
                SendMessage(hCtrl, LB_SETITEMDATA,  (WPARAM)iAddItem, (LPARAM)nGamingDevices-1);
                PostHScrollBar(hCtrl, lpdiJoyInfo->wszDisplayName, (BYTE)wcslen(lpdiJoyInfo->wszDisplayName));
#else
                USES_CONVERSION;
                iAddItem = (short)SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)W2A(lpdiJoyInfo->wszDisplayName));
                SendMessage(hCtrl, LB_SETITEMDATA, (WPARAM)iAddItem, (LPARAM)nGamingDevices-1);
                PostHScrollBar(hCtrl, W2A(lpdiJoyInfo->wszDisplayName), (BYTE)wcslen(lpdiJoyInfo->wszDisplayName));
#endif
                // SetFocus to that item!
                SendMessage(hCtrl, LB_SETCURSEL, (WPARAM)iAddItem, 0);

                OnCommand(hDlg, IDC_DEVICE_LIST, 0, LBN_SELCHANGE);
            }


            // clean-up!
            if( lpdiJoyInfo )
                delete (lpdiJoyInfo);
        }
        break;

    case IDC_DEVICE_LIST:
        if( code == LBN_SELCHANGE )
        {
            iAddItem = (short)SendMessage(hWndCtl, LB_GETCURSEL, 0, 0);

            BYTE nArrayID = (BYTE)SendMessage(hWndCtl, LB_GETITEMDATA, (WPARAM)iAddItem, 0);

            LPDIJOYTYPEINFO lpdiJoyInfo = new DIJOYTYPEINFO;
            ASSERT (lpdiJoyInfo);

            ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO));

            lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO);

            DWORD dwFlags = DITC_REGHWSETTINGS;

            if( nGameportBus > 1 )
                dwFlags |= DITC_FLAGS1;

            VERIFY(SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayID], (LPDIJOYTYPEINFO)lpdiJoyInfo, dwFlags)));
/*
                if (nGameportBus > 1)
                {
                   HWND hCtrl = GetDlgItem(hDlg, IDC_GAMEPORTLIST);

                    // Search for AutoDetect in the list!
                    char nIndex = (char)::SendMessage(hCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)(LPCTSTR)lpszAutoDetect);

                    // If it's got the JOYTYPE_NOAUTODETECTGAMEPORT flag, remove AutoDetect from the ListCtrl
                    if (lpdiJoyInfo->dwFlags1 & JOYTYPE_NOAUTODETECTGAMEPORT)
                    {
                        // it could fail because the entry is not available...
                        if (nIndex != CB_ERR)
                            ::SendMessage(hCtrl, CB_DELETESTRING, (WPARAM)nIndex, 0);	
                        
                    }
                    // Otherwise, verify that AutoDetect is present... if not, add it!
                    else
                    {
                        // it could fail because the entry is not available...
                        if (nIndex == CB_ERR)
                            ::SendMessage(hCtrl, CB_SETITEMDATA, ::SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpszAutoDetect), AUTODETECT_PORT);
                    }
        
                    ::PostMessage(hCtrl, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
                }
*/

            PostDlgItemEnableWindow(hDlg, IDC_JOY1HASRUDDER, (lpdiJoyInfo->hws.dwFlags & JOY_HWS_HASR) ? FALSE : TRUE);

            if( lpdiJoyInfo )
                delete (lpdiJoyInfo);

            break;
        }

        if( code != LBN_DBLCLK )
            break;

    case IDOK:
        iAddItem = (short)SendDlgItemMessage(hDlg, IDC_DEVICE_LIST, LB_GETCURSEL, 0, 0);

        if( iAddItem == NO_ITEM )
            break;

        // Check to see if they have a GamePortList
        {
            HWND hCtrl = GetDlgItem(hDlg, IDC_GAMEPORTLIST);
            ASSERT (hCtrl);

            if( IsWindowVisible(hCtrl) )
            {
                // Check to see if the user has a port selected!
                if( SendMessage(hCtrl, CB_GETCURSEL, 0, 0) == CB_ERR )
                {
                    // blj: TODO: Clear this message with UE
                    Error((short)IDS_NO_GAMEPORT_TITLE, (short)IDS_NO_GAMEPORT);
                    break;
                }
            }
        }

        iItem = 0;
        AddSelectedItem(hDlg);

    case IDCANCEL:
        EndDialog(hDlg, id);
        break;
    }
}

/// Custom Dialog procedure
BOOL WINAPI CustomDialogProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPWSTR lpwszVIDPID;

    switch( uMsg )
    {
    case WM_DESTROY:
        {
            HICON hIcon = (HICON)SendMessage(hDlg, WM_GETICON, (WPARAM)ICON_SMALL, 0);
            DestroyIcon(hIcon);
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(hDlg, WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam, lParam);
        return(TRUE);

    case WM_INITDIALOG:
        // Set up the Buttons and Axis combo boxs!
        {
            HICON hIcon = (HICON)LoadImage(ghInstance, MAKEINTRESOURCE(IDI_CPANEL), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
            ASSERT (hIcon);

            if( hIcon )
                ::PostMessage(hDlg, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)hIcon);

            // Return if no available VID/PIDs found!
            lpwszVIDPID = new (WCHAR[STR_LEN_32]);
            ASSERT (lpwszVIDPID);

            pDIJoyConfig->Acquire();

            if( !GetNextAvailableVIDPID(lpwszVIDPID) )
            {
                if( lpwszVIDPID )
                    delete[] (lpwszVIDPID);

                EndDialog(hDlg, IDCANCEL);

                // Let the user know that they need to remove some "Custom" devices!
                Error((short)IDS_NO_NAME_TITLE, (short)IDS_NOAVAILABLEVIDPID );

                return(FALSE);
            }

            // init id list
            BYTE nButtons = MAX_ANALOG_BUTTONS;
            TCHAR szTmp[3];

            HWND hCtrl = GetDlgItem(hDlg, IDC_COMBO_BUTTONS);

            // Fill the Buttons combo...
            do
            {
                itoa(nButtons, (LPTSTR)&szTmp);
                SendMessage(hCtrl, CB_ADDSTRING, (WPARAM)0, (LPARAM)(LPCTSTR)szTmp);
            } while( nButtons-- );

            // Set Default to four buttons 
            SendMessage(hCtrl, CB_SETCURSEL, MAX_ANALOG_BUTTONS, 0);

            // Use nButtons for Axis...
            nButtons = MAX_ANALOG_AXIS;

            hCtrl = GetDlgItem(hDlg, IDC_COMBO_AXIS);

            // Fill the Axis combo...
            do
            {
                itoa(nButtons--, (LPTSTR)&szTmp);
                SendMessage(hCtrl, CB_ADDSTRING, (WPARAM)0, (LPARAM)(LPCTSTR)szTmp);
            } while( nButtons > 1 );

            // Set Default to two Axis
            SendMessage(hCtrl, CB_SETCURSEL, 0, 0);
        }

        ::PostMessage(GetDlgItem(hDlg, IDC_SPECIAL_JOYSTICK), BM_SETCHECK, BST_CHECKED, 0);

        SendDlgItemMessage(hDlg, IDC_EDIT_NAME, EM_LIMITTEXT, (WPARAM)MAX_STR_LEN, 0);
        return(1);

    case WM_COMMAND:
        switch( LOWORD(wParam) )
        {
        case IDOK:
            {
                // defines for error states!
#define DUPLICATE_NAME  0x01
#define NO_NAME         0x02
#define INVALID_NAME    0x04

                BYTE nLen = (BYTE)SendDlgItemMessage(hDlg, IDC_EDIT_NAME, EM_LINELENGTH, 0, 0);

                LPTSTR pszTypeName = NULL;

                if( nLen )
                {
                    pszTypeName = new (TCHAR[nLen+1]);
                    ASSERT (pszTypeName);

                    // Get the Type/Display Name
                    GetDlgItemText(hDlg, IDC_EDIT_NAME, (LPTSTR)pszTypeName, nLen+1);

                    if( _tcschr(pszTypeName, TEXT('\\')) )
                        nLen = INVALID_NAME;
                    else
                    {
                        // Make sure it's not a duplicate!
                        // start of fix #9269
                        LPDIJOYTYPEINFO_DX5 lpdiGetJoyInfo = new DIJOYTYPEINFO_DX5;
                        ASSERT (lpdiGetJoyInfo);

                        ZeroMemory(lpdiGetJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

                        lpdiGetJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

                        // Clean-up nLen!
                        BYTE n = nLen = 0;

                        // Search for a Duplicate Display Name!!!
                        while( pwszTypeArray[n] )
                        {
                            if( FAILED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[n++], (LPDIJOYTYPEINFO)lpdiGetJoyInfo, DITC_DISPLAYNAME)) )
                            {
                                TRACE(TEXT("JOY.CPL: ADD.CPP: GetTypeInfo Failed!\n"));
                                continue;
                            }
#ifndef	_UNICODE
                            USES_CONVERSION;
#endif

                            if( _tcsncmp(pszTypeName, 
#ifdef _UNICODE
                                        lpdiGetJoyInfo->wszDisplayName, 
#else
                                        W2A(lpdiGetJoyInfo->wszDisplayName),
#endif
                                        wcslen(lpdiGetJoyInfo->wszDisplayName)+1) == 0 )
                            {
                                nLen = DUPLICATE_NAME;
                                break;
                            }
                        }

                        if( lpdiGetJoyInfo ) {
                            delete (lpdiGetJoyInfo);
                        }
                        // end of fix #9269
                        
                    }
                } else nLen = NO_NAME;

                // Check for an error!
                if( nLen )
                {
                    if( pszTypeName )
                        delete[] (pszTypeName);

                    // Give the user the appropriate error!
                    switch( nLen )
                    {
                    case DUPLICATE_NAME:
                        Error((SHORT)IDS_NO_NAME_TITLE, (SHORT)IDS_DUPLICATE_TYPE);
                        break;

                    case NO_NAME:
                        Error((short)IDS_NO_NAME_TITLE, (short)IDS_NO_NAME);
                        break;

                    case INVALID_NAME:
                        Error((short)IDS_NO_NAME_TITLE, (short)IDS_INVALID_NAME);
                        break;
                    }

                    // Set Focus to the Dialog
                    SetFocus(hDlg);

                    HWND hCtrl = GetDlgItem(hDlg, IDC_EDIT_NAME);
                    ASSERT (hCtrl);

                    // Set Focus to the Control
                    SetFocus(hCtrl);

                    // hilite the error
                    PostMessage(hCtrl, EM_SETSEL, (WPARAM)0, (LPARAM)-1);

                    return(FALSE);
                }

                // set the type information
                LPDIJOYTYPEINFO lpdiJoyInfo = new (DIJOYTYPEINFO);
                ASSERT (lpdiJoyInfo);

                ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO));

                lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO);

#ifndef _UNICODE
                USES_CONVERSION;
#endif

                // Set the Display Name
                wcsncpy(lpdiJoyInfo->wszDisplayName, 
#ifdef _UNICODE
                         pszTypeName, 
#else
                         A2W(pszTypeName),
#endif // _UNICODE
                         lstrlen(pszTypeName)+1);

                if( pszTypeName )
                    delete[] (pszTypeName);

                // Set the GUID - default to LegacyServer
                // Per Marcus, we don't want to do this anymore!
                //lpdiJoyInfo->clsidConfig = CLSID_LegacyServer;

                // Set the Hardware Settings
                lpdiJoyInfo->hws.dwNumButtons = (DWORD)SendDlgItemMessage(hDlg, IDC_COMBO_BUTTONS, CB_GETCURSEL, 0, 0);

                switch( SendDlgItemMessage(hDlg, IDC_COMBO_AXIS, CB_GETCURSEL, 0, 0) )
                {
                // R Axis
                case 1:
                    // Check to see which button got checked...
                    lpdiJoyInfo->hws.dwFlags |= ::SendMessage(GetDlgItem(hDlg, IDC_HASRUDDER), BM_GETCHECK, 0, 0) ? JOY_HWS_HASR : JOY_HWS_HASZ;
                    break;

                    // Z Axis
                case 2:
                    lpdiJoyInfo->hws.dwFlags |= JOY_HWS_HASR;
                    lpdiJoyInfo->hws.dwFlags |= JOY_HWS_HASZ;
                    break;

                    // X/Y are default!
                default:
                    lpdiJoyInfo->hws.dwFlags = 0;
                    break;
                }

                lpdiJoyInfo->hws.dwFlags |= ::SendMessage(GetDlgItem(hDlg, IDS_CUSTOM_HASPOV), BM_GETCHECK, 0, 0) ? JOY_HWS_HASPOV : 0;

                // Get Special char's status
                lpdiJoyInfo->hws.dwFlags |= ::SendMessage(GetDlgItem(hDlg, IDC_SPECIAL_JOYSTICK), BM_GETCHECK, 0, 0) ? 0
                                            :  ::SendMessage(GetDlgItem(hDlg, IDC_SPECIAL_PAD), BM_GETCHECK, 0, 0) ? JOY_HWS_ISGAMEPAD
                                            :  ::SendMessage(GetDlgItem(hDlg, IDC_SPECIAL_AUTO), BM_GETCHECK, 0, 0) ? JOY_HWS_ISCARCTRL
                                            :  JOY_HWS_ISYOKE; // default to Yoke!	

                // Set up wszHardwareId
                wcscpy(lpdiJoyInfo->wszHardwareId, L"GamePort\\");

                // This blocks the Huge DisplayName bug!
                // DINPUT change requires VID/PID at the end of the hardware ID... it was 
                //StrNCatW(lpdiJoyInfo->wszHardwareId, lpwszVIDPID, 245);
                // Win95 does not like StrNCatW, we will use wcsncat

                wcsncat(lpdiJoyInfo->wszHardwareId, lpwszVIDPID, 245);

                if( SUCCEEDED(pDIJoyConfig->Acquire()) )
                {
#ifdef _UNICODE
                    if( FAILED(pDIJoyConfig->SetTypeInfo(lpwszVIDPID, lpdiJoyInfo, DITC_DISPLAYNAME | DITC_CLSIDCONFIG | DITC_REGHWSETTINGS | DITC_HARDWAREID)) )
#else
                    if( FAILED(pDIJoyConfig->SetTypeInfo(lpwszVIDPID, lpdiJoyInfo, DITC_DISPLAYNAME | DITC_CLSIDCONFIG | DITC_REGHWSETTINGS ) ) )
#endif
                    {
#ifdef _DEBUG
                        OutputDebugString(TEXT("JOY.CPL: ADD.CPP: CustomDlgProc: SetTypeInfo Failed!\n"));
#endif                  
                    }

                    // Create the memory for the Custom device and stick it into the array!
                    pwszTypeArray[nGamingDevices++] = _wcsdup(lpwszVIDPID);

                    pDIJoyConfig->Unacquire();
                }

                if( lpdiJoyInfo )  delete   (lpdiJoyInfo);
            }

        case IDCANCEL:
            if( lpwszVIDPID )
                delete[] (lpwszVIDPID);

            EndDialog(hDlg, LOWORD(wParam));
            break;

        case IDC_SPECIAL_JOYSTICK:
        case IDC_SPECIAL_YOKE:
        case IDC_SPECIAL_PAD:
        case IDC_SPECIAL_AUTO:
            CheckRadioButton(hDlg, IDC_SPECIAL_JOYSTICK, IDC_SPECIAL_AUTO, IDC_SPECIAL_JOYSTICK);
            break;

        case IDC_COMBO_AXIS:
            // Show/Hide IDC_HASRUDDER based on Selection of 3 Axis
            if( HIWORD(wParam) == CBN_SELCHANGE )
            {
                const USHORT nCtrlArray[] = {IDC_HASRUDDER, IDC_HASZAXIS};
                BYTE nCtrls = sizeof(nCtrlArray)/sizeof(short);

                // the '1' in the comparison is because the CB is Zero based!
                BOOL bShow = (BOOL)(SendDlgItemMessage(hDlg, IDC_COMBO_AXIS, CB_GETCURSEL, 0, 0) == 1);

                do
                {
                    SetWindowPos( GetDlgItem(hDlg, nCtrlArray[--nCtrls]), NULL, NULL, NULL, NULL, NULL, 
                                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((bShow) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
                } while( nCtrls );

                if( bShow )
                    ::PostMessage(GetDlgItem(hDlg, IDC_HASZAXIS), BM_SETCHECK, BST_CHECKED, 0);
            }
            break;
        }
        return(1);

    case WM_CLOSE:
        EndDialog(hDlg, 0);
        return(1);
    }
    return(0);
}

char GetNextAvailableID( void )
{
    LPDIJOYCONFIG_DX5 pJoyConfig = new (DIJOYCONFIG_DX5);
    ASSERT (pJoyConfig);

    ZeroMemory(pJoyConfig, sizeof(DIJOYCONFIG_DX5));

    pJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);

    char i = 0;

    do
    {
        switch( pDIJoyConfig->GetConfig(i, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE) )
        {
        case S_FALSE:
        case DIERR_NOMOREITEMS:
        case DIERR_NOTFOUND:
        case E_FAIL:
            goto EXIT;


        default:
            i++;
            break;
        }
    } while( i < NUMJOYDEVS );

    i = -1;

    // And it's Error time!
    Error((short)IDS_NO_IDS_TITLE, (short)IDS_NO_IDS);

    EXIT:
    if( pJoyConfig )
        delete (pJoyConfig);

    return(i);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	AddSelectedItem(HWND hDlg)
//
// PARAMETERS:	hDlg    - Handle to page
//
// PURPOSE:		Adds selected item from List box.
///////////////////////////////////////////////////////////////////////////////
char AddSelectedItem( HWND hDlg )
{
    static BYTE n;
    DWORD dwFlags;
    HRESULT hr; 
    int   nID;
#ifdef SUPPORT_TWO_2A2B    
    BOOL  f2_2A2B = FALSE;
#endif

    nID = GetNextAvailableID();

    // GetNextAvailableID returns -1 if it fails!
    if( nID < 0 )
        return((char)nID);

    // Type info
    LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
    ASSERT (lpdiJoyInfo);

    ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

    lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

    BYTE nArrayID = (BYTE)SendDlgItemMessage(hDlg, IDC_DEVICE_LIST, LB_GETITEMDATA, (WPARAM)iAddItem, 0);

    VERIFY(SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nArrayID], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_REGHWSETTINGS | DITC_CALLOUT | DITC_DISPLAYNAME)));

#ifdef SUPPORT_TWO_2A2B    
#ifndef _UNICODE
    if( wcscmp( pwszTypeArray[nArrayID], L"#<" ) == 0 ) {
        f2_2A2B = TRUE;
        lpdiJoyInfo->hws.dwFlags = 0;
        pwszTypeArray[nArrayID][1] = L'2';
    } else {
        f2_2A2B = FALSE;
    }
#endif
#endif

    LPDIJOYCONFIG pTempJoyConfig = new DIJOYCONFIG;
    ASSERT (pTempJoyConfig);

    ZeroMemory(pTempJoyConfig, sizeof(DIJOYCONFIG));

    pTempJoyConfig->dwSize = sizeof (DIJOYCONFIG);

    pTempJoyConfig->hwc.hws = lpdiJoyInfo->hws;
    pTempJoyConfig->hwc.hws.dwFlags |= JOY_HWS_ISANALOGPORTDRIVER;

    // Do the Rudder Flags!
    if( ::SendMessage(GetDlgItem(hDlg, IDC_JOY1HASRUDDER), BM_GETCHECK, 0, 0) )
    {
        pTempJoyConfig->hwc.hws.dwFlags     |= JOY_HWS_HASR;
        pTempJoyConfig->hwc.dwUsageSettings |= JOY_US_HASRUDDER;
    }

    // set default to present
    pTempJoyConfig->hwc.dwUsageSettings |= JOY_US_PRESENT;

    pTempJoyConfig->hwc.dwType = nArrayID;

    wcsncpy(pTempJoyConfig->wszCallout, lpdiJoyInfo->wszCallout, wcslen(lpdiJoyInfo->wszCallout)+1);

    wcsncpy(pTempJoyConfig->wszType, pwszTypeArray[nArrayID], wcslen(pwszTypeArray[nArrayID])+1);

    LPWSTR lpszPortName = NULL;

    if( SUCCEEDED(pDIJoyConfig->Acquire()) )
    {
        // This stops Memphis and gameport-less systems!!!
        if( nGameportBus )
        {

            // no point asking the Combo box if there's really no choice!
            if( nGameportBus > 1 )
            {
                n = (BYTE)SendDlgItemMessage(hDlg, IDC_GAMEPORTLIST, CB_GETITEMDATA, 
                                             (WPARAM)SendDlgItemMessage(hDlg, IDC_GAMEPORTLIST, CB_GETCURSEL, 0, 0), 0);
            } else
            {
                n = 0;
            }


            if( n == AUTODETECT_PORT )
            {
#ifdef _DEBUG
                OutputDebugString(TEXT("JOY.CPL: ADD.CPP: Selected Port is AutoDetect!\n"));
#endif 
                pTempJoyConfig->guidGameport = GUID_GAMEENUM_BUS_ENUMERATOR;
            } else
            {
                // Zero the memory because the buffer still contains the old data!!!
                ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));
                lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

#ifdef _DEBUG
                TRACE(TEXT("JOY.CPL: ADD.CPP: Port List index is %d or %s!\n"), n, pwszGameportBus[n]);
#endif 																														   
                if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszGameportBus[n], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_CLSIDCONFIG | DITC_DISPLAYNAME)) )
                {
                    pTempJoyConfig->guidGameport = lpdiJoyInfo->clsidConfig;
                    lpszPortName = _wcsdup(lpdiJoyInfo->wszDisplayName);
                }
            }
        }


        // This is for Memphis and odd case NT systems!
        if( pTempJoyConfig->guidGameport == GUID_NULL )
        {
            pTempJoyConfig->guidGameport = GUID_GAMEENUM_BUS_ENUMERATOR;
#ifdef _DEBUG
            OutputDebugString(TEXT("JOY.CPL: ADD.CPP: Selected Port did not return a clsidConfig so AutoDetect is being used!\n"));
#endif 
        }

        // Set the hour glass
        SetCursor(LoadCursor(NULL, IDC_WAIT));

//  ISSUE-2001/03/29-timgill (MarcAnd) Why would we want to block updates when we're adding a device?
#if 1
        // Unblock the WM_DEVICECHANGE message handler!
        nFlags &= ~BLOCK_UPDATE;
        nFlags |= ON_PAGE;

        /*
         *  Set the nReEnum counter going so that for the next n WM_TIMER 
         *  messages (or until the device arrives) we can consider 
         *  doing a refresh.
         *  The value is somewhat arbitrary.
         */
        nReEnum = 43;
        /*
         *  Set a target for the number of devices so that the extra 
         *  reenumerations can be avoided if this target is reached.
         */
        nTargetAssigned = nAssigned+1;
#else
		nFlags |= BLOCK_UPDATE;
#endif

        dwFlags = DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT;
        dwFlags |= ::SendDlgItemMessage(hDlg, IDC_WDM, BM_GETCHECK, 0, 0) ? DIJC_WDMGAMEPORT : 0;

        if( FAILED(hr = pDIJoyConfig->SetConfig(nID, pTempJoyConfig, dwFlags)) )
        {
            // Let the user know what happend!
            if( hr == E_ACCESSDENIED )
            {
                // Let the use know that the port is already occupied and that they need to remove that device or 
                // re-assign the device to an unoccupied port.

                LPDIJOYCONFIG lpJoyCfg = new (DIJOYCONFIG);
                ASSERT (lpJoyCfg);

                ZeroMemory(lpJoyCfg, sizeof(DIJOYCONFIG));

                lpJoyCfg->dwSize = sizeof(DIJOYCONFIG);

                // Cycle threw pAssigned and find the device with the same port name!
                BYTE nIndex = nAssigned;

                do
                {
                    if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[--nIndex]->ID, lpJoyCfg, DIJC_WDMGAMEPORT)) )
                    {
                        if( lpJoyCfg->guidGameport == pTempJoyConfig->guidGameport )
                            break;
                    }
                } while( nIndex );

                if( lpJoyCfg )
                    delete (lpJoyCfg);

                DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
                ASSERT (pDIPropStr);

                ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

                pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
                pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
                pDIPropStr->diph.dwHow        = DIPH_DEVICE;

                // Ok now.. you found it... use the Device pointer to get it's Friendly name!
                if( SUCCEEDED(pAssigned[nIndex]->fnDeviceInterface->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph)) )
                {
                    // Put ellipse in text to avoid buffer over-flow.
                    // Limit displayed name to 50 chars... not completely arbitrary,
                    // we need to leave room in the Message string...
                    // who knows how long the string will get when translated!
                    if( wcslen(pDIPropStr->wsz) > 50 )
                    {
                        pDIPropStr->wsz[47] = pDIPropStr->wsz[48] = pDIPropStr->wsz[49] = L'.';
                        pDIPropStr->wsz[50] = L'\0';
                    }

                    LPTSTR lptszMsgFormat = new (TCHAR[MAX_STR_LEN]);
                    ASSERT (lptszMsgFormat);
                    VERIFY(LoadString(ghInstance, IDS_ADD_PORT_MSGFORMAT, lptszMsgFormat, MAX_STR_LEN));

                    LPTSTR lptszMsg = new (TCHAR[MAX_STR_LEN]);
                    ASSERT (lptszMsg);

                    // Format the message
                    wsprintf(lptszMsg, lptszMsgFormat, pDIPropStr->wsz, lpszPortName, pAssigned[nIndex]->ID+1);

                    VERIFY(LoadString(ghInstance, IDS_ADD_PORT_OCCUPIED, lptszMsgFormat, MAX_STR_LEN));

                    MessageBox(hDlg, lptszMsg, lptszMsgFormat, MB_ICONHAND | MB_OK | MB_APPLMODAL);

                    if( lptszMsgFormat )
                        delete[] (lptszMsgFormat);

                    if( lptszMsg )
                        delete[] (lptszMsg);
                }

                if( pDIPropStr )
                    delete (pDIPropStr);
            } else if( hr == DIERR_DEVICEFULL )
            {
                Error((short)IDS_GAMEPORT_OCCUPIED_TITLE, (short)IDS_GAMEPORT_OCCUPIED);
            } else
            {
                // Something Ugly happened!
                Error((short)IDS_NO_GAMENUM_TITLE, (short)IDS_NO_GAMENUM);
            }
        } else
        {
#ifdef _UNICODE
            // Fix #55524
            if( SUCCEEDED(pDIJoyConfig->GetConfig(nID, pTempJoyConfig, DIJC_REGHWCONFIGTYPE)) )
            {
                if( !(pTempJoyConfig->hwc.dwUsageSettings & JOY_US_PRESENT) )
                {
                    pTempJoyConfig->hwc.dwUsageSettings |= JOY_US_PRESENT;
                    pTempJoyConfig->hwc.hwv.dwCalFlags  |= 0x80000000;
                    pTempJoyConfig->hwc.hws.dwFlags     |= JOY_HWS_ISANALOGPORTDRIVER;

                    VERIFY(SUCCEEDED(pDIJoyConfig->SetConfig(nID, pTempJoyConfig, DIJC_REGHWCONFIGTYPE)));
                }
            }
            // end of Fix #55524
#endif

            // make sure VJOYD is notified
            if( !(nFlags & ON_NT) ) {
                pDIJoyConfig->SendNotify();
                Sleep(10);
                pDIJoyConfig->SendNotify();
            }

#ifndef _UNICODE
    #ifdef SUPPORT_TWO_2A2B    
            /*
             * Add the other part of Two_2Axis_2Button joystick.
             */
            if( f2_2A2B ) {
                nID = GetNextAvailableID();
                if( nID >= 0 ){
                    hr = pDIJoyConfig->SetConfig(nID, pTempJoyConfig, dwFlags);

                    if( SUCCEEDED(hr) ) {
                        if( !(nFlags & ON_NT) )
                        pDIJoyConfig->SendNotify();
                    }
                }
                 
            }
    #endif
#endif

        }

        if( lpszPortName )
            free(lpszPortName);

        // Set the standard pointer
        SetCursor(LoadCursor(NULL, IDC_ARROW));

        pDIJoyConfig->Unacquire();
    }

    if( lpdiJoyInfo )
        delete (lpdiJoyInfo);

    if( pTempJoyConfig )
        delete (pTempJoyConfig);

    return((char)nID);
}

BOOL UpdateListCtrl( HWND hCtrl )
{
    // Turn Redraw off here else it will flicker!
    ::SendMessage(hCtrl, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // delete all existing entries
    ::SendMessage(hCtrl, LB_RESETCONTENT, 0, 0);

    // Type info
    LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = new (DIJOYTYPEINFO_DX5);
    ASSERT (lpdiJoyInfo);

    ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

    lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

#ifndef _UNICODE
    USES_CONVERSION;
#endif

    BYTE nIndex = nGamingDevices-1;

    ::SendMessage(hCtrl, LB_SETCOUNT, (WPARAM)(int)nIndex, 0);

    LPWSTR lpStr = new WCHAR[MAX_STR_LEN];
    ASSERT (lpStr);

    BYTE nLargestStringLen = 0;

    do
    {
        if( SUCCEEDED(pDIJoyConfig->GetTypeInfo(pwszTypeArray[nIndex], (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_DISPLAYNAME)) )
        {
#ifdef _UNICODE
            ::SendMessage(hCtrl, LB_SETITEMDATA, 
                          (WPARAM)::SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpdiJoyInfo->wszDisplayName), (LPARAM)nIndex);
#else
            ::SendMessage(hCtrl, LB_SETITEMDATA, 
                          (WPARAM)::SendMessage(hCtrl, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)W2A(lpdiJoyInfo->wszDisplayName)), (LPARAM)nIndex);
#endif
            if( wcslen(lpdiJoyInfo->wszDisplayName) > nLargestStringLen )
            {
                nLargestStringLen = (BYTE)wcslen(lpdiJoyInfo->wszDisplayName);
                wcscpy(lpStr, lpdiJoyInfo->wszDisplayName);
            }
        }
    } while( nIndex-- );

    if( lpdiJoyInfo )
        delete (lpdiJoyInfo);

#ifdef _UNICODE
    PostHScrollBar(hCtrl, lpStr, nLargestStringLen);
#else
    PostHScrollBar(hCtrl, W2A(lpStr), nLargestStringLen);
#endif

    if( lpStr )
        delete[] (lpStr);

    // Select the default selection to the 0th device type
    iAddItem = 0;

    ::PostMessage(hCtrl, LB_SETCURSEL, (WPARAM)iAddItem, 0);

    // Turn the redraw flag back on!
    ::SendMessage (hCtrl, WM_SETREDRAW, (WPARAM)TRUE, 0);
    InvalidateRect(hCtrl, NULL, TRUE);
    return(TRUE);
}

// Please check to see if nGameportBus is > 0 before a call to this function!
// It will work, but What a waste!
BOOL PopulatePortList( HWND hCtrl )
{
    if( !::IsWindow(hCtrl) )
    {
        TRACE(TEXT("JOY.CPL: PopulatePortList: HWND passed to PopulatePortList is NOT a valid Window!\n"));
        return(FALSE);
    }

    SendMessage(hCtrl, CB_SETEXTENDEDUI, TRUE, 0);

    // temp so we don't damage the global!
    BYTE n = nGameportBus;

    LPDIJOYTYPEINFO lpDIJoyTypeInfo = new (DIJOYTYPEINFO);
    ASSERT(lpDIJoyTypeInfo);

#ifndef _UNICODE
    USES_CONVERSION;
#endif

    lpDIJoyTypeInfo->dwSize = sizeof(DIJOYTYPEINFO);

    // Populate the list as they were enumerated.
    do
    {
        if( FAILED(pDIJoyConfig->GetTypeInfo(pwszGameportBus[--n], lpDIJoyTypeInfo, DITC_DISPLAYNAME)) )
        {
            TRACE(TEXT("JOY.CPL: ADD.CPP: GetTypeInfo failed!\n"));
            continue;
        }

        // put the name in the list and place the index of the port array 
        // in it's item data...
        SendMessage(hCtrl, CB_SETITEMDATA, 
#ifdef _UNICODE
                    SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpDIJoyTypeInfo->wszDisplayName), n);
#else
                    SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCSTR)W2A(lpDIJoyTypeInfo->wszDisplayName)), n);
#endif

        // Just in case you're curious, we're going backwards so the default
        // port is the lowest available one.
    } while( n );

    // Don't forget Auto-Detect!
    // But only if there's more than one port!
    ::SendMessage(hCtrl, CB_SETITEMDATA, ::SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)lpszAutoDetect), AUTODETECT_PORT);

    // While you're at it, check to see if one is available... 
    // if so, put it as the default!
    ::PostMessage(hCtrl, CB_SETCURSEL, (WPARAM)0, (LPARAM)0);

    if( lpDIJoyTypeInfo )
        delete (lpDIJoyTypeInfo);

    return(TRUE);
}

static BOOL IsTypeActive( short *nArrayIndex )
{
    if( *nArrayIndex > nGamingDevices )
    {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: IsTypeActive: nArrayIndex > nGamingDevices!\n"));
#endif
        return(FALSE);
    }

    BOOL bRet = FALSE;

    BYTE nIndex  = nAssigned;
    BYTE nStrLen = (BYTE)wcslen(pwszTypeArray[*nArrayIndex])+1;

    LPDIJOYCONFIG_DX5 lpDIJoyConfig = new (DIJOYCONFIG_DX5);
    ASSERT (lpDIJoyConfig);

    ZeroMemory(lpDIJoyConfig, sizeof(DIJOYCONFIG_DX5));

    lpDIJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);

    // find the assigned ID's  
    while( nIndex-- )
    {
        if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[nIndex]->ID, (LPDIJOYCONFIG)lpDIJoyConfig, DIJC_REGHWCONFIGTYPE)) )
        {
            // if you find it... break out!
            if( wcsncmp(lpDIJoyConfig->wszType, pwszTypeArray[*nArrayIndex], nStrLen) == 0 )
            {
                bRet = TRUE;
                *nArrayIndex = nIndex;
                break;
            }
        }
    } 

    if( lpDIJoyConfig )
        delete (lpDIJoyConfig);

    return(bRet);
}

BOOL GetNextAvailableVIDPID(LPWSTR lpwszType )
{
    // Make the VID/PID to compare from the following formula
    // VID_045e&PID_100+JOY_HW_LASTENTRY to 100+JOY_HW_LASTENTRY+0xf

    HKEY hKey;
    BYTE n = JOY_HW_LASTENTRY;

    wcsncpy(lpwszType, L"VID_045E&PID_0100", 18);

    const WCHAR wszLookup[] = L"0123456789ABCDEF";

    do
    {
        if( n < 0x10 )
        {
            lpwszType[16] = wszLookup[n];
        } else
        {
            lpwszType[15] = wszLookup[1];
            lpwszType[16] = wszLookup[n%0x10];
        }

        n++;

        if( FAILED(pDIJoyConfig->OpenTypeKey(lpwszType, KEY_READ, &hKey)) )
            break;

        RegCloseKey(hKey);

    } while( n < (JOY_HW_LASTENTRY+0x11) );

    return(BOOL)(n < 0x1d);
}

//
// PostDlgItemEnableWindow(HWND hDlg, USHORT nItem, BOOL bEnabled)
//
void PostDlgItemEnableWindow(HWND hDlg, USHORT nItem, BOOL bEnabled)
{
    HWND hCtrl = GetDlgItem(hDlg, nItem);

    if( hCtrl )
        PostEnableWindow(hCtrl, bEnabled);
}

//
// PostEnableWindow(HWND hCtrl, BOOL bEnabled)
//
void PostEnableWindow(HWND hCtrl, BOOL bEnabled)
{
    DWORD dwStyle = GetWindowLong(hCtrl, GWL_STYLE);

    // No point Redrawing the Window if there's no change!
    if( bEnabled )
    {
        if( dwStyle & WS_DISABLED )
            dwStyle &= ~WS_DISABLED;
        else return;
    } else
    {
        if( !(dwStyle & WS_DISABLED) )
            dwStyle |=  WS_DISABLED;
        else return;
    }

    SetWindowLong(hCtrl, GWL_STYLE, dwStyle);

    RedrawWindow(hCtrl, NULL, NULL, RDW_INTERNALPAINT | RDW_INVALIDATE); 
}

/*
BOOL IsCustomType(BYTE nIndex)
{
   BOOL bRet = FALSE;

   // First verify VID is 045E
   WCHAR *pwStr = StrStrW(pwszTypeArray[nIndex],L"VID_");
   
   if (pwStr)
   {
      // Increment the pointer over the VID_ and test for 045E
      pwStr = &pwStr[4];

      if (_wcsnicmp(pwStr, L"045e", 4) == 0)
      {
         OutputDebugString(TEXT("Hit \n"));

         // Now, increment the pointer over 045e and &PID_ and test for the range!
         pwStr = &pwStr[9];

         // Second, verify PID is between 0x100 + JOY_HW_LASTENTRY and 
         // 0x100 + JOY_HW_LASTENTRY + 0xf


         bRet = TRUE;
      }
   }

   return bRet;
}
*/

void PostHScrollBar(HWND hCtrl, LPCTSTR lpStr, BYTE nStrLen)
{
    SIZE sz;
    HDC hDC = GetWindowDC(hCtrl);
    if( hDC != NULL ) /* PREFIX MANBUGS: 29336*/
    {
        GetTextExtentPoint32(hDC, lpStr, nStrLen, &sz);
        ReleaseDC(hCtrl, hDC);
        ::PostMessage(hCtrl, LB_SETHORIZONTALEXTENT, (WPARAM)sz.cx, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\creditst.cpp ===
// CreditStatic.cpp : implementation file
//

#include "stdafx.h"
#include "CreditSt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// defined in MAIN.CPP
extern HINSTANCE ghInstance;

#define  DISPLAY_TIMER_ID		150		// timer id
/////////////////////////////////////////////////////////////////////////////
// CCreditStatic

CCreditStatic::CCreditStatic()
{

	m_Colors[0] = RGB(0,0,255);     // Black
	m_Colors[1] = RGB(255,0,0);     // Red
	m_Colors[2] = RGB(0,128,0); 	  // John Deer Green
	m_Colors[3] = RGB(0,255,255);   // Turquoise
	m_Colors[4] = RGB(255,255,255); // White    

	m_TextHeights[0] = 36;
	m_TextHeights[1] = 34;
	m_TextHeights[2] = 34; 
	m_TextHeights[3] = 30;
	m_nCurrentFontHeight = m_TextHeights[NORMAL_TEXT_HEIGHT]; 


	m_Escapes[0] = '\t';
	m_Escapes[1] = '\n';
	m_Escapes[2] = '\r';
	m_Escapes[3] = '^';

	/*
	m_DisplaySpeed[0] = 75;
	m_DisplaySpeed[1] = 65;
	m_DisplaySpeed[2] = 15;
	*/

	m_CurrentSpeed = 15; //DISPLAY_FAST;
	m_ScrollAmount = -1;

	m_ArrIndex = NULL;
	m_nCounter = 31;
	m_nClip = 0;

	m_bFirstTurn   = TRUE;
	m_Gradient     = GRADIENT_RIGHT_DARK;
	n_MaxWidth     = 0;
	TimerOn        = 0;
	m_szWork			= NULL;
}

CCreditStatic::~CCreditStatic()
{
}


BEGIN_MESSAGE_MAP(CCreditStatic, CStatic)
	//{{AFX_MSG_MAP(CCreditStatic)
	ON_WM_ERASEBKGND()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreditStatic message handlers

BOOL CCreditStatic::StartScrolling()
{
	if(m_pArrCredit->IsEmpty())
		return FALSE;

	if (m_BmpMain) 
   {
		DeleteObject(m_BmpMain);
		m_BmpMain = NULL;
	}
	
	::GetClientRect(this->m_hWnd, &m_ScrollRect);

	TimerOn = (UINT)SetTimer(DISPLAY_TIMER_ID, m_CurrentSpeed, NULL);
   ASSERT(TimerOn != 0);

	m_ArrIndex = m_pArrCredit->GetHeadPosition();
//	m_nCounter = 1;
//	m_nClip = 0;

	return TRUE;
}

void CCreditStatic::EndScrolling()
{
	KillTimer(DISPLAY_TIMER_ID);
	TimerOn = 0;

	if (m_BmpMain) 
   {
		DeleteObject(m_BmpMain);
		m_BmpMain = NULL;
	}
}

void CCreditStatic::SetCredits(LPCTSTR credits,TCHAR delimiter)
{
	LPTSTR str,ptr1,ptr2;
    
	ASSERT(credits);

	if ((str = _tcsdup(credits)) == NULL)
		return;

	m_pArrCredit = new (CStringList);
	ASSERT (m_pArrCredit);

	m_pArrCredit->RemoveAll();

	ptr1 = str;
	while((ptr2 = _tcschr(ptr1,delimiter)) != NULL) 
   {
		*ptr2 = '\0';
		m_pArrCredit->AddTail(ptr1);
		ptr1 = ptr2+1;
	}
	m_pArrCredit->AddTail(ptr1);

	free(str);

	m_ArrIndex = m_pArrCredit->GetHeadPosition();
//	m_nCounter = 1;
//	m_nClip    = 0;
}

BOOL CCreditStatic::OnEraseBkgnd(CDC* pDC) 
{
	return TRUE;
	
//	return CStatic::OnEraseBkgnd(pDC);
}

//************************************************************************
//	 OnTimer
//
//	 	On each of the display timers, scroll the window 1 unit. Each 20
//      units, fetch the next array element and load into work string. Call
//      Invalidate and UpdateWindow to invoke the OnPaint which will paint 
//      the contents of the newly updated work string.
//************************************************************************
void CCreditStatic::OnTimer(UINT nIDEvent) 
{
	BOOL bCheck = FALSE;

	if (m_nCounter++ % m_nCurrentFontHeight == 0)	 // every x timer events, show new line
	{
		m_nCounter=1;
		m_szWork = (LPCTSTR)m_pArrCredit->GetNext(m_ArrIndex);

		if(m_bFirstTurn)
			bCheck = TRUE;

		if (m_ArrIndex == NULL) 
      {
			m_bFirstTurn = FALSE;
			m_ArrIndex = m_pArrCredit->GetHeadPosition();
		}
		m_nClip = 0;
	}
	
	HDC hMainDC = this->GetDC()->m_hDC;
	RECT rc = m_ScrollRect;

	rc.left	= ((rc.right-rc.left)-n_MaxWidth)/2;
	rc.right	= rc.left + n_MaxWidth;

	HDC hDC = ::CreateCompatibleDC(hMainDC);

	// Don't try to scroll credits you don't have!
	if (m_szWork)
		MoveCredit(&hMainDC, rc, bCheck);
	else
		FillGradient(&hMainDC, m_ScrollRect);

	::SelectObject(hDC, m_BmpMain);
	::BitBlt(hMainDC, 0, 0, m_ScrollRect.right-m_ScrollRect.left, m_ScrollRect.bottom-m_ScrollRect.top, hDC, 0, 0, SRCCOPY);
	
	::ReleaseDC(this->m_hWnd, hMainDC);
	::DeleteDC(hDC);

	CStatic::OnTimer(nIDEvent);
}

void CCreditStatic::FillGradient(HDC *pDC, RECT& FillRect)
{ 
	float fStep,fRStep,fGStep,fBStep;	    // How large is each band?

	WORD R = GetRValue(m_Colors[BACKGROUND_COLOR]);
	WORD G = GetGValue(m_Colors[BACKGROUND_COLOR]);
	WORD B = GetBValue(m_Colors[BACKGROUND_COLOR]);

	// Determine how large each band should be in order to cover the
	// client with 256 bands (one for every color intensity level)
	//if(m_Gradient % 2) 
   //{
		fRStep = (float)R / 255.0f;
		fGStep = (float)G / 255.0f;
		fBStep = (float)B / 255.0f;
	/*
	} 
   else 
   {
		fRStep = (float)(255-R) / 255.0f;
		fGStep = (float)(255-G) / 255.0f;
		fBStep = (float)(255-B) / 255.0f;
	}
	*/

	COLORREF OldCol = ::GetBkColor(*pDC);
	RECT rc;

	// Start filling bands
	fStep = (float)(m_ScrollRect.right-m_ScrollRect.left) / 256.0f;

	for (short iOnBand = (short)((256*FillRect.left)/(m_ScrollRect.right-m_ScrollRect.left)); 
		(int)(iOnBand*fStep) < FillRect.right && iOnBand < 256; iOnBand++) 
   {
		::SetRect(&rc, 
			(int)(iOnBand * fStep), 
			FillRect.top,
			(int)((iOnBand+1) * fStep), 
			FillRect.bottom+1);

		// If we want to enable gradient filling from any direction!
/*
		switch(m_Gradient) 
      {
		case GRADIENT_RIGHT_DARK:
			col = RGB((int)(R-iOnBand*fRStep),(int)(G-iOnBand*fGStep),(int)(B-iOnBand*fBStep));
			break;
		case GRADIENT_RIGHT_LIGHT:
			col = RGB((int)(R+iOnBand*fRStep),(int)(G+iOnBand*fGStep),(int)(B+iOnBand*fBStep));
			break;
		case GRADIENT_LEFT_DARK:
			col = RGB((int)(iOnBand*fRStep),(int)(iOnBand*fGStep),(int)(iOnBand*fBStep));
			break;
		case GRADIENT_LEFT_LIGHT:
			col = RGB(255-(int)(iOnBand*fRStep),255-(int)(iOnBand*fGStep),255-(int)(iOnBand*fBStep));
			break;
		default:
			return;
		}
*/
		::SetBkColor(*pDC, RGB((int)(R-iOnBand*fRStep),(int)(G-iOnBand*fGStep),(int)(B-iOnBand*fBStep)));
		::ExtTextOut(*pDC, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

	}
	::SetBkColor(*pDC, OldCol);
} 

void CCreditStatic::MoveCredit(HDC* pDC, RECT& ClientRect, BOOL bCheck)
{
	HDC hMemDC = ::CreateCompatibleDC(*pDC);

	HBITMAP *pOldMemDCBitmap = NULL;
	HFONT   *pOldFont 	    = NULL;
    
	RECT r1;

	if (m_BmpMain == NULL) 
   {
		m_BmpMain = ::CreateCompatibleBitmap(*pDC, m_ScrollRect.right-m_ScrollRect.left, m_ScrollRect.bottom-m_ScrollRect.top );

		pOldMemDCBitmap = (HBITMAP *)::SelectObject(hMemDC, m_BmpMain);

		FillGradient(&hMemDC, m_ScrollRect);
	} 	else pOldMemDCBitmap = (HBITMAP *)::SelectObject(hMemDC, m_BmpMain);


	if ((ClientRect.right-ClientRect.left) > 0) 
   {
	   ::ScrollDC(hMemDC, 0, m_ScrollAmount, &m_ScrollRect, &ClientRect, NULL, &r1);
   }
	else 
   {
		r1 = m_ScrollRect;
		r1.top = r1.bottom-abs(m_ScrollAmount);
	}

	m_nClip = m_nClip + abs(m_ScrollAmount);	
	

	//*********************************************************************
	//	FONT SELECTIlON
  	short rmcode = 1;

	if (lstrlen(m_szWork))
   {
		BYTE bUnderline, bItalic;
		bUnderline = bItalic = FALSE;

		COLORREF nTmpColour = m_Colors[TOP_LEVEL_GROUP_COLOR];

		TCHAR c = m_szWork[lstrlen(m_szWork)-1]; 

		if(c == m_Escapes[TOP_LEVEL_GROUP]) 
      {
			m_nCurrentFontHeight = m_TextHeights[TOP_LEVEL_GROUP_HEIGHT];
		}
		else if(c == m_Escapes[GROUP_TITLE]) 
      {
			m_nCurrentFontHeight = m_TextHeights[GROUP_TITLE_HEIGHT];
			nTmpColour = m_Colors[GROUP_TITLE_COLOR];
		}
		else if(c == m_Escapes[TOP_LEVEL_TITLE]) 
      {
			m_nCurrentFontHeight = m_TextHeights[TOP_LEVEL_TITLE_HEIGHT];
			nTmpColour = m_Colors[TOP_LEVEL_TITLE_COLOR];
		}

		// If this were application critical, I'd make an array of fonts a member 
		// and create all the fonts prior to starting the timer!
   	HFONT pfntArial = ::CreateFont(m_nCurrentFontHeight, 0, 0, 0, 
   				FW_BOLD, bItalic, bUnderline, 0, 
   				ANSI_CHARSET,
             	OUT_DEFAULT_PRECIS,
             	CLIP_DEFAULT_PRECIS,
             	PROOF_QUALITY,
             	VARIABLE_PITCH | 0x04 | FF_DONTCARE,
             	(LPCTSTR)"Arial");

		::SetTextColor(hMemDC, nTmpColour);

		if (pOldFont != NULL) 
			::SelectObject(hMemDC, pOldFont);

		pOldFont = (HFONT *)::SelectObject(hMemDC, pfntArial);
	}

	FillGradient(&hMemDC, r1);

  	::SetBkMode(hMemDC, TRANSPARENT);

	if(bCheck) 
   {
		SIZE size; 												  
		::GetTextExtentPoint(hMemDC, (LPCTSTR)m_szWork,lstrlen(m_szWork)-rmcode, &size);
		
		if (size.cx > n_MaxWidth) 
      {
			n_MaxWidth = (short)((size.cx > (m_ScrollRect.right-m_ScrollRect.left)) ? (m_ScrollRect.right-m_ScrollRect.left) : size.cx);
			ClientRect.left = ((m_ScrollRect.right-m_ScrollRect.left)-n_MaxWidth)/2;
			ClientRect.right = ClientRect.left + n_MaxWidth;
		}
			
	}

	RECT r = ClientRect;
	r.top = r.bottom-m_nClip;
												  
	DrawText(hMemDC, (LPCTSTR)m_szWork,lstrlen(m_szWork)-rmcode,&r,DT_TOP|DT_CENTER|DT_NOPREFIX | DT_SINGLELINE);	
	
	if (pOldFont != NULL)
		::SelectObject(hMemDC, pOldFont);

	::SelectObject(hMemDC, pOldMemDCBitmap);

	::DeleteDC(hMemDC);
}

void CCreditStatic::OnDestroy() 
{
	CStatic::OnDestroy();

	m_pArrCredit->RemoveAll();

	if (m_pArrCredit)
		delete (m_pArrCredit);

	if(TimerOn)
		EndScrolling();
}

/*  In the event we ever want a few library routines!
void CCreditStatic::SetCredits(UINT nID, TCHAR delimiter)
{
	LPTSTR lpCredits = new (TCHAR[255]);
	ASSERT (lpCredits);

	::LoadString(ghInstance, nID, lpCredits, 255);

	SetCredits((LPCTSTR)lpCredits, delimiter);

	if (lpCredits)
		delete[] (lpCredits);
}

void CCreditStatic::SetSpeed(UINT index, int speed)
{
	ASSERT(index <= DISPLAY_FAST);

	if(speed)
		m_DisplaySpeed[index] = speed;

	m_CurrentSpeed = index;
}

void CCreditStatic::SetColor(UINT index, COLORREF col)
{
	ASSERT(index <= NORMAL_TEXT_COLOR);

	m_Colors[index] = col;
}

void CCreditStatic::SetTextHeight(UINT index, int height)
{
	ASSERT(index <= NORMAL_TEXT_HEIGHT);

	m_TextHeights[index] = height;
}

void CCreditStatic::SetEscape(UINT index, char escape)
{
	ASSERT(index <= DISPLAY_BITMAP);

	m_Escapes[index] = escape;
}

void CCreditStatic::SetGradient(UINT value)
{
	ASSERT(value <= GRADIENT_LEFT_LIGHT);

	m_Gradient = value;
}

void CCreditStatic::SetTransparent(BOOL bTransparent)
{
	m_bTransparent = bTransparent;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\creditst.h ===
#if !defined(AFX_CREDITSTATIC_H__4ABD7701_49F5_11D1_9E3C_00A0245800CF__INCLUDED_)
#define AFX_CREDITSTATIC_H__4ABD7701_49F5_11D1_9E3C_00A0245800CF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CreditStatic.h : header file
//

#define DISPLAY_SLOW		        0
#define DISPLAY_MEDIUM		     1
#define DISPLAY_FAST		        2

#define BACKGROUND_COLOR        0
#define TOP_LEVEL_TITLE_COLOR	  1
#define TOP_LEVEL_GROUP_COLOR   2
#define GROUP_TITLE_COLOR       3
#define NORMAL_TEXT_COLOR		  4

#define TOP_LEVEL_TITLE_HEIGHT  0		
#define TOP_LEVEL_GROUP_HEIGHT  1     
#define GROUP_TITLE_HEIGHT      2     
#define NORMAL_TEXT_HEIGHT		  3

#define TOP_LEVEL_TITLE			  0   // '\t'
#define TOP_LEVEL_GROUP         1   // '\n'
#define GROUP_TITLE             2   // '\r'
#define DISPLAY_BITMAP			  3   // '^'

#define GRADIENT_NONE			  0
#define GRADIENT_RIGHT_DARK	  1
#define GRADIENT_RIGHT_LIGHT	  2
#define GRADIENT_LEFT_DARK		  3
#define GRADIENT_LEFT_LIGHT	  4

class CCreditStatic : public CStatic
{
protected:
	COLORREF    m_Colors[5];
	short       m_TextHeights[4];
 	TCHAR       m_Escapes[4];
//	short       m_DisplaySpeed[3],
	short 		m_CurrentSpeed;
 	RECT        m_ScrollRect;		   // rect of Static Text frame
	CStringList *m_pArrCredit;
//	CString		m_szWork;
	LPCTSTR 	m_szWork;
	short       m_nCounter;		   // work ints
	POSITION    m_ArrIndex;
	short       m_nClip,m_ScrollAmount;
	short       m_nCurrentFontHeight;

	HBITMAP	    m_BmpMain;

	BOOL		m_bFirstTurn;
	UINT        m_Gradient;
	short		n_MaxWidth;
	UINT        TimerOn;
// Construction
public:
	CCreditStatic();

// Attributes
public:

// Operations
public:
	BOOL StartScrolling();
	void EndScrolling();
	void SetCredits(LPCTSTR credits, TCHAR delimiter = TEXT('|'));
//	void SetCredits(UINT nID, TCHAR delimiter = TEXT('|'));
//	void SetSpeed(UINT index, int speed = 0);
//	void SetColor(UINT index, COLORREF col);
//	void SetTextHeight(UINT index, int height);
//	void SetEscape(UINT index, char escape);
//	void SetGradient(UINT value = GRADIENT_RIGHT_DARK);
//	BOOL SetBkImage(UINT nIDResource);
//	BOOL SetBkImage(LPCTSTR lpszResourceName);
//	void SetTransparent(BOOL bTransparent = TRUE);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreditStatic)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCreditStatic();

	// Generated message map functions
protected:		 
	void MoveCredit(HDC* pDC, RECT& ClientRect, BOOL bCheck);
	void FillGradient(HDC *pDC, RECT& m_FillRect);

	//{{AFX_MSG(CCreditStatic)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CREDITSTATIC_H__4ABD7701_49F5_11D1_9E3C_00A0245800CF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\appman.cpp ===
/*
File:		AppMan.cpp
Project:	
Author:	DDalal & ScottLe
Date:		10/22/99
Comments:
    AppMan Settings Tab in Game Control Panel.

Copyright (c) 1999, Microsoft Corporation
*/

// This is necessary LVS_EX_INFOTIP

#if (_WIN32_IE < 0x400)
#undef _WIN32_IE
#define  _WIN32_IE  0x400
	#if 0
	typedef struct tagNMITEMACTIVATE{
		NMHDR   hdr;
		int     iItem;
		int     iSubItem;
		UINT    uNewState;
		UINT    uOldState;
		UINT    uChanged;
		POINT   ptAction;
	    LPARAM  lParam;
	    UINT    uKeyFlags;
	} NMITEMACTIVATE, FAR *LPNMITEMACTIVATE;
	#endif
#endif

#include <afxcmn.h>
#include <windowsx.h>

#include <cpl.h>

#include <winuser.h>  // For RegisterDeviceNotification stuff!
#include <dbt.h>      // for DBT_ defines!!!
#include <commctrl.h>  // for listview
#include <tchar.h>    // for TCHAR
#include <malloc.h>	 // for _alloca

#include "hsvrguid.h"

#include "cpanel.h"
#include "resource.h"
#include "joyarray.h"

#ifdef MAX_DEVICES		// The control panel and the addman both define MAX_DEVICES, we'll use the AppMan supplied version
#undef MAX_DEVICES
#endif

#include <AppManAdmin.h>

#if _DEBUG
#define Assert(x) { if(!(x)) { DebugBreak(); }}
#else
#define Assert(x)
#endif

static HWND ghDlg;
HWND hAppManCheckBox;
extern const DWORD gaHelpIDs[];
extern HINSTANCE ghInstance;

// constants
const short NO_ITEM     = -1;                                    
static short iItem = NO_ITEM;   // index of selected item

static DWORD ct=0L;

// Forwards

//
// local forwards
//
static BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam);
static void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code);
static BOOL OnNotify(HWND hDlg, WPARAM idFrom, LPARAM lParam);

void OnScroll(HWND hDlg, WPARAM wParam);
void OnListCtrl_Select(HWND hDlg);
void OnListCtrl_DblClick(HWND hDlg);
void OnListCtrl_UpdateFromCheckBoxes( HWND hDlg );
void OnButtonPress( HWND hDlg );
void OnAdvancedModeCheckBox( HWND hCtl);
void OnMoreInfoButton( HWND hDlg );
INT_PTR CALLBACK MoreInfoProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

static void OnAdvHelp       (LPARAM);
static void OnContextMenu   (WPARAM wParam, LPARAM lParam);
static void OnListviewContextMenu (HWND hWnd, LPARAM lParam );


// util fcns
int  MyInsertItem( HWND hCtrl, LPTSTR lpszBuff, int iItem );  // replaced from cpanel.cpp
void SetScrollBarString(HWND hDlg, INT pos, int iDevIndex );
void SetScrollBarPosition( HWND hDlg, INT pos, int iDevIndex );
void PostDlgItemEnableWindow( HWND hDlg, USHORT nItem, BOOL bEnabled );
void EnableDiskManageControls( HWND hDlg, BOOL bEnable );
void EnableScrollBarAndText( HWND hDlg, BOOL bEnable );
void EnableAllControls( HWND hDlg, BOOL bEnable );
DWORD GetCurrentDeviceFromList( HWND hDlg, BYTE *nItem = NULL );

void ConfigureListControl( HWND hDlg );
void PopulateListControl( HWND hDlg, BYTE nItem );

void UpdateCurrentDeviceFromScrollBar( HWND hDlg, DWORD newPos );

void UpdateListItem( HWND hDlg, int iItem, BOOL bUpdateScrollBarPos = TRUE);
void UpdateListAndScrollBar( HWND hDlg, BOOL bJustScrollBar = FALSE );

// appman fcns
HRESULT AppManGetGameDiskUsage(DWORD devIndex, DWORD &percent);
HRESULT AppManSetGameDiskUsage(DWORD devIndex, DWORD percent);
HRESULT AppManGetAllocatedMeg(DWORD devIndex, DWORD percent, DWORD &dwMegaBytes);
HRESULT AppManShutdown();
HRESULT AppManInit();
HRESULT AppManIsDeviceExcluded(DWORD devIndex, BOOL &isExcluded);
HRESULT AppManExcludeDevice(DWORD devIndex, BOOL bDoExclude );
BOOL    AppManDoesDeviceExist(DWORD devIndex, GUID &sDevGuid);
BOOL    AppManInitialized();
HRESULT AppManSetAdvMode(BOOL bAdvMode);
HRESULT AppManGetAdvMode(BOOL &bAdvMode);



//
// from cpanel.cpp
//
extern void SetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpStr);
extern void InsertColumn(HWND hCtrl, BYTE nColumn, USHORT nStrID, USHORT nWidth);
extern BOOL SetItemData( HWND hCtrl, BYTE nItem, DWORD dwFlag );
extern DWORD GetItemData(HWND hCtrl, BYTE nItem );
extern void SetListCtrlItemFocus ( HWND hCtrl, BYTE nItem );

//
// GLOBALS
//
BOOL g_ListPopulated = FALSE;
int  g_nm_click = -1;
BOOL g_nm_click_state = FALSE;
BOOL g_DlgInitialized = FALSE;
BOOL g_ChkBoxUpdate = FALSE;

#define  APPMAN_LIST_EXCLUDE_CHECKBOX  0
#define  APPMAN_LIST_DRIVE             1
#define  APPMAN_LIST_EXCLUDED_PERCENT  2

struct {
BOOL isValid;
int  iItem;
BOOL isClicked;
int iNextItem;
BOOL bKeybrdChange;
} g_ItemChanged;

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	AppManProc(HWND hDlg,	ULONG uMsg,	WPARAM wParam,	LPARAM lParam)
//
// PARAMETERS:	hDlg    - 
//             uMsg    - 
//             wParam  -
//             lParam  -
//
// PURPOSE:		Main callback function for "Appman"  sheet
///////////////////////////////////////////////////////////////////////////////

BOOL WINAPI AppManProc(HWND hDlg, ULONG uMsg, WPARAM wParam,  LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_ACTIVATEAPP:
      if( wParam ) {
	    HWND hListCtrl = NULL;

		hListCtrl = GetDlgItem((HWND) wParam, IDC_APPMAN_DRIVE_LIST);

		SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);
      }
      break;

    case WM_DEVICECHANGE:
        switch( (UINT)wParam )
        {
        case DBT_DEVICEARRIVAL:
//         case DBT_DEVICEREMOVECOMPLETE:
            break;
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
      //PostMessage(GetParent(hDlg), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        if( !HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, OnInitDialog) )
        {
            // Fix #108983 NT, Remove Flash on Error condition.
            SetWindowPos(::GetParent(hDlg), HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
            DestroyWindow(hDlg);
        }
        return(TRUE);

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, OnCommand);
        return(TRUE);

    case WM_HSCROLL: 
      OnScroll(hDlg, wParam);
        return(TRUE);
	 
    case WM_DESTROY:
      //return(HANDLE_WM_DESTROY(hDlg, wParam, lParam, OnDestroy));
        return(TRUE);

    case WM_NOTIFY:
      return OnNotify(hDlg, wParam, lParam);

    case WM_HELP:
      OnAdvHelp(lParam);
        return(TRUE);

    case WM_CONTEXTMENU:
      OnContextMenu(wParam, lParam);
        return(TRUE);

    default:
        break;
    }
    return(0);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
//
// PARAMETERS:	hDlg    - 
//				   hWnd    - 
//				   lParam  -
//
// PURPOSE:		WM_INITDIALOG message handler
///////////////////////////////////////////////////////////////////////////////
BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
{
  HRESULT hr = S_OK;

  hr = AppManInit();

  //
  // init globals
  //
  ZeroMemory( &g_ItemChanged, sizeof(g_ItemChanged));
  g_DlgInitialized = FALSE;

  if( FAILED(hr) ) {
    //
    // Disable everything
    //

    EnableAllControls(hDlg, FALSE);

    // 
    // popup saying: hey you need appman installed ?
    //

  } else {

    ghDlg = hDlg;

    //
    // Set defaults
    //
    
    //
    // Configure the List control, and then fill it in
    //
    ConfigureListControl( hDlg );
    PopulateListControl( hDlg, 0 );

    //
    // TRACK BAR
    //
    {

      // Set range [0..100]
      SendDlgItemMessage(hDlg,
			 IDC_APPMAN_SCROLLBAR,
			 TBM_SETRANGE,
			 (WPARAM) TRUE,
			 (LPARAM) MAKELONG(0,100));

      // set tick freq
      SendDlgItemMessage(hDlg,
			 IDC_APPMAN_SCROLLBAR,
			 TBM_SETTICFREQ,
			 (WPARAM) 10,
			 (LPARAM) 0);

	  UpdateListAndScrollBar(hDlg, TRUE); // Update the scroll bar only
//      OnListCtrl_Select( hDlg );
    }

	// Set the Advanced user check box
	{
		BOOL bAdvMode;
		AppManGetAdvMode(bAdvMode);
		SendDlgItemMessage(hDlg,IDC_APPMAN_ADVUSER, BM_SETCHECK,(bAdvMode ? BST_CHECKED : BST_UNCHECKED),0L);
	}

    g_DlgInitialized = TRUE;

  }  // else

  return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
//
// PARAMETERS:  hDlg    - 
//              id      - 
//              hWndCtl -
//              code    -
//
// PURPOSE:		WM_COMMAND message handler
///////////////////////////////////////////////////////////////////////////////
void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
{
  HRESULT     hr = S_OK;


  switch( id )    
  {
    //
    // put the reset defaults button here
    //
    case IDC_APPMAN_RESTORE_DEFAULTS_BUTTON:
      OnButtonPress( hDlg );
      break;           

  	case IDC_APPMAN_ADVUSER:
	  	OnAdvancedModeCheckBox( hWndCtl);
		  break;

    case IDS_WHATSTHIS:
    {
      // point to help file
      LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
      ASSERT (pszHelpFileName);

      if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
        WinHelp((HWND)hDlg, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
      else
        OutputDebugString(TEXT("JOY.CPL: AppMan.cpp: OnCommand: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

      if( pszHelpFileName )
        delete[] (pszHelpFileName);
    }
      break;

    case IDC_APPMAN_MORE_INFO:
      OnMoreInfoButton( hDlg );
      break;           

/*
    case IDC_APPMAN_MANAGE_DISK:
    {
	    BOOL isChecked = (IsDlgButtonChecked(hDlg, id)) ? TRUE : FALSE;
	    EnableDiskManageControls( hDlg, !isChecked );
    }
      break;
*/

    default:
      break;
  }

}


////////////////////////////////////////////////////////////////////////////////
// 
// FUNCTION:	OnNotify(HWND hDlg, WPARAM idFrom, NMHDR* pnmhdr)
//
// PARAMETERS:	hDlg   - 
//             idFrom - ID of control sending WM_NOTIFY message
//             pnmhdr -
//
// PURPOSE:		WM_NOTIFY message handler
////////////////////////////////////////////////////////////////////////////////


BOOL OnNotify(HWND hDlg, WPARAM idFrom, LPARAM lParam)
{
  NMLISTVIEW *pnmv;
	  
   LPNMHDR pnmhdr = (LPNMHDR)lParam;
  switch( pnmhdr->code )
  {

  case LVN_ITEMCHANGED:

	pnmv = (LPNMLISTVIEW) lParam;

    if( idFrom == IDC_APPMAN_DRIVE_LIST ) 
	{
	// this is called if a new item has been selected
	// or if the user clicked on the checkbox, changing state

#ifdef _DEBUG
        {    
			TCHAR tstring[256];
			NMITEMACTIVATE *pitemact = (LPNMITEMACTIVATE)lParam;
			_stprintf(tstring, TEXT("JOY.CPL: AppMan.cpp: OnNotify: LVN_ITEMCHANGED, ct=%ld,idFrom=%lx, item=%lx uChanged=%lx uNewState=%lx uOldState=%lx lParam=%lx\n"),++ct,idFrom,pitemact->iItem,pitemact->uChanged,pitemact->uNewState,pitemact->uOldState,pitemact->lParam);
			OutputDebugString(tstring);
		}
#endif // _DEBUG

		if( AppManInitialized() && 
		    g_DlgInitialized && 
			(pnmv->uNewState & LVIS_SELECTED || 
			 pnmv->uNewState == 0x1000 || pnmv->uNewState == 0x2000) && 
			 // TODO: Find definitions for x1000 and x2000 (check box state change in a list view control)
//			g_ItemChanged.isClicked && 
			g_ChkBoxUpdate)
		{

			NMITEMACTIVATE *ll = (LPNMITEMACTIVATE)lParam;
			HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);
		  
			g_ItemChanged.isValid = TRUE;
			g_ItemChanged.iItem = ll->iItem;
			g_ItemChanged.isClicked = FALSE;
		  
			//
			// this flag is VERY important for consistent state changes 
			// and eliminating race conditions
			//
			g_ChkBoxUpdate = FALSE;
			OnListCtrl_UpdateFromCheckBoxes( hDlg );
			g_ChkBoxUpdate = TRUE;

			g_ItemChanged.isValid = FALSE;

			UpdateListItem(hDlg, g_ItemChanged.iItem);

			{
				HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);
				SetListCtrlItemFocus( hLC, (BYTE)g_ItemChanged.iItem );
			}

//			UpdateListAndScrollBar(hDlg, TRUE); // Update the scroll bar only
		}
    }
	
    return TRUE;
    break;

    } // switch

    return(0);
}


const INT bigInc = 5;
const INT smlInc = 1;

void OnScroll(HWND hDlg, WPARAM wParam)
{
  
  INT curPos = 0;
  INT newPos = 0;
  INT xInc = 0;

  curPos = (INT) SendDlgItemMessage(hDlg,
			      IDC_APPMAN_SCROLLBAR,
			      TBM_GETPOS,
			      (WPARAM) 0,
			      (LPARAM) 0);


  switch(LOWORD (wParam)) 
    { 
      // User clicked shaft left of the scroll box. 
 
    case SB_PAGEUP: 
      xInc = -bigInc;
      break; 
 
      // User clicked shaft right of the scroll box. 
 
    case SB_PAGEDOWN: 
      xInc = +bigInc;
      break; 
 
      // User clicked the left arrow. 
 
    case SB_LINEUP: 
      xInc = -smlInc;
      break; 
 
      // User clicked the right arrow. 
 
    case SB_LINEDOWN: 
      xInc = +smlInc;
      break; 
 
      // User dragged the scroll box. 
 
    case SB_THUMBTRACK: 
      xInc = HIWORD(wParam) - curPos; 
      break; 
 
    default: 
      xInc = 0;  
    } 

  newPos = curPos + xInc;

  // also sets scroll bar
  UpdateCurrentDeviceFromScrollBar( hDlg, newPos );
}

void  UpdateCurrentDeviceFromScrollBar( HWND hDlg, DWORD newPos )
{
  DWORD percent, devIndex;

  //
  // Update scroll bar & text to this drive
  //
  devIndex = GetCurrentDeviceFromList( hDlg );

  if( devIndex < 0 ) return;

  percent = newPos;
  
  // SET app man drive percentage
  HRESULT hr = AppManSetGameDiskUsage( devIndex, percent );
  
  UpdateListItem(hDlg, g_ItemChanged.iItem, FALSE);

//UpdateListAndScrollBar( hDlg);
}

#if 0
void OnListCtrl_DblClick(HWND hDlg)
{
  HRESULT hr;
  BOOL bIsExcluded = FALSE;
  BYTE nItem = 0;

  //
  // toggle drive exlusion
  //
  DWORD nDevIndex = GetCurrentDeviceFromList( hDlg, &nItem );

  if( nDevIndex < 0 ) return;

  hr = AppManIsDeviceExcluded( nDevIndex, bIsExcluded );

  //
  // Toggle exclusion
  //
  hr = AppManExcludeDevice( nDevIndex, !bIsExcluded );

  //
  // Update display: list & scroll bar!
  //
  UpdateListAndScrollBar( hDlg );
}
#endif
  
void OnListCtrl_UpdateFromCheckBoxes( HWND hDlg )
{
  HRESULT hr;
  BOOL bIsExcluded = FALSE;
  BYTE nItem = 0;

  //
  // go through each item, check the box & set exclusion
  //
  HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);
  if( !hLC ) return;

  int iItem = -1;
  if( g_ItemChanged.isValid )
    {
      
      //
      // very important: tell the system that this information is no longer
      // valid.  hence we won't recurse misteriously or unpredictably
      //
      g_ItemChanged.isValid = FALSE;

      iItem = g_ItemChanged.iItem;
      BOOL isIncluded = ListView_GetCheckState( hLC, iItem );
      DWORD dwDevIndex = GetItemData( hLC, (BYTE)iItem );
      hr = AppManExcludeDevice( dwDevIndex, isIncluded );
    }
      
  //
  // Update display: list & scroll bar!
  //

  //UpdateListAndScrollBar( hDlg );

  g_ChkBoxUpdate = TRUE;
}

#define APPMAN_DEFAULT_GAME_DISK_USAGE  0xFFFFFFFF // this code means, get default from registry

void OnButtonPress( HWND hDlg )
{
  if( !AppManInitialized() )  return;

  GUID sDevGuid;
  // reset defaults
  for(int i = 0; i<MAX_DEVICES; i++) {
    if( AppManDoesDeviceExist( i, sDevGuid ) ) {
      AppManExcludeDevice( i, TRUE );
      AppManSetGameDiskUsage( i, APPMAN_DEFAULT_GAME_DISK_USAGE);
    }
  }	

  // Force the advanced mode off
  if (SUCCEEDED(AppManSetAdvMode(FALSE)))
  {
		// Clear the advance mode check box
		HWND hCtl = GetDlgItem(hDlg,IDC_APPMAN_ADVUSER);
		::SendMessage(hCtl,BM_SETCHECK,BST_UNCHECKED,0L);
		InvalidateRect(hCtl, NULL, TRUE);
  }
	
  // update everything
  UpdateListAndScrollBar( hDlg );
  g_ItemChanged.iItem = 0;
  OnListCtrl_Select(hDlg);
}


void OnMoreInfoButton( HWND hDlg )
{
	DialogBox(ghInstance, MAKEINTRESOURCE(IDD_APPMAN_MORE_INFO), hDlg, MoreInfoProc);

  return;
}


INT_PTR CALLBACK  MoreInfoProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
#define INFO_STR_LEN  2048

	BOOL        fRet;
	HICON       hIcon;
  TCHAR       szMoreInfo[INFO_STR_LEN] = {0};


	fRet = FALSE;

	switch (message)
	{
	  case WM_INITDIALOG:
    {
		  if (hIcon = LoadIcon(NULL, IDI_INFORMATION))
		    SendDlgItemMessage(hDlg, IDC_INFO_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

	    if (LoadString(ghInstance, IDS_APPMAN_MORE_INFO_EDITBOX, szMoreInfo, INFO_STR_LEN))
				SetDlgItemText(hDlg, IDC_APPMAN_MORE_INFO_EDITBOX, szMoreInfo);

		  break;
		}

	  case WM_COMMAND:
		  switch (LOWORD(wParam))
		  {
		    case IDOK:
		    case IDCANCEL:
			    EndDialog(hDlg, LOWORD(wParam));
			    fRet = TRUE;
			    break;

		    default:
			    break;
		  }
  		  break;

	    default:
		    break;
	}
	

	return fRet;
}


void OnAdvancedModeCheckBox( HWND hCtl )
{
  if( !hCtl || !AppManInitialized() )  return;

  // Advanced mode check box has been selected.  Toggle the selection.
	BOOL bAdvMode;
	AppManGetAdvMode(bAdvMode);
	if (SUCCEEDED(AppManSetAdvMode(!bAdvMode)))
	{
		// Set the check box
		::SendMessage(hCtl,BM_SETCHECK,(!bAdvMode ? BST_CHECKED : BST_UNCHECKED),0L);
		InvalidateRect(hCtl, NULL, TRUE);

	}
}


void  UpdateListItem( HWND hDlg, int iItem, BOOL bUpdateScrollBarPos)
{
  HRESULT     hr;
  DWORD       percent, devIndex;
  BOOL        isExcluded = FALSE;
  GUID        sDeviceGuid;
  TCHAR       szTempText[MAX_STR_LEN] = {0};
  TCHAR       szItemText1[MAX_STR_LEN] = {0};
  TCHAR       szItemText2[MAX_STR_LEN] = {0};


  HWND  hLC = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);
  devIndex = GetItemData( hLC, (BYTE)iItem );

  if ( devIndex < 0 )
    return;


  if ( AppManDoesDeviceExist(devIndex, sDeviceGuid) ) 
  {
#if 0 // Don't need to update the drive letter...
	  // sets the text in the "Drive" column
	  LPTSTR lpszDriveText = new (TCHAR[MAX_STR_LEN]);

	  LoadString(ghInstance, IDS_APPMAN_DRIVE_TEXT, lpszDriveText, MAX_STR_LEN);
	  _stprintf(szItemText1, lpszDriveText, devIndex + 65);

	  delete lpszDriveText;

	  SetItemText(hLC, iItem, APPMAN_LIST_DRIVE, szItemText1);
#endif

	  // Set the included/excluded text
	  hr = AppManIsDeviceExcluded( devIndex, isExcluded );

	  if ( isExcluded ) 
	  {
	    LoadString(ghInstance, IDS_APPMAN_EXCLUDED, szTempText, MAX_STR_LEN);
	    _stprintf(szItemText1, szTempText);
	    LoadString(ghInstance, IDS_APPMAN_CHECKBOX_NO, szTempText, MAX_STR_LEN);
	    _stprintf(szItemText2, szTempText);
	  }
    else 
	  {
	    LoadString(ghInstance, IDS_APPMAN_GAME_USAGE, szTempText, MAX_STR_LEN);
	    hr = AppManGetGameDiskUsage(devIndex, percent);
	    _stprintf(szItemText1, szTempText, percent);
	    LoadString(ghInstance, IDS_APPMAN_CHECKBOX_YES, szTempText, MAX_STR_LEN);
	    _stprintf(szItemText2, szTempText);
	  }

	  //
	  // Set the checkbox (FALSE = Not Checked = Excluded in the UI only).
	  //
	  ListView_SetCheckState( hLC, iItem, !isExcluded );

	  // Set the excluded or percent (if not excluded) text
	  SetItemText(hLC, (BYTE)iItem, APPMAN_LIST_EXCLUDED_PERCENT, szItemText1);

    //  3/31/2000(RichGr): Set "Allow new games" column to "Yes" or "No".
	  SetItemText(hLC, (BYTE)iItem, APPMAN_LIST_EXCLUDE_CHECKBOX, szItemText2);

	  if (bUpdateScrollBarPos)
	  {
		  // Set the scroll bar position
		  // GET appman drive percentage
		  hr = AppManGetGameDiskUsage( devIndex, percent );
  
		  // set position on sb
		  SetScrollBarPosition( hDlg, percent, devIndex );

		  // En/disable scroll bar as needed
		  EnableScrollBarAndText( hDlg, !isExcluded );
	  }
	  else
    {
	    // At least change scroll bar text
		  SetScrollBarString( hDlg, percent, devIndex );
    }  
  }

  return;
}




void UpdateListAndScrollBar( HWND hDlg, BOOL bJustScrollBar )
{
  HRESULT hr;
  DWORD percent, devIndex;
  BYTE nItem = 0;
  BOOL bCurrentDeviceExcluded = FALSE;

  devIndex = GetCurrentDeviceFromList( hDlg, &nItem );

  if( devIndex < 0 ) return;

  if( !bJustScrollBar ) 
  {
	// populate list
	PopulateListControl( hDlg, nItem );
  }

  hr = AppManIsDeviceExcluded( devIndex, bCurrentDeviceExcluded );

  // GET appman drive percentage
  hr = AppManGetGameDiskUsage( devIndex, percent );
  
  // set position on sb
  SetScrollBarPosition( hDlg, percent, devIndex );

  // set special text "Device D: is excluded"
  // disable scroll bar
  EnableScrollBarAndText( hDlg, !bCurrentDeviceExcluded );
}


void OnListCtrl_Select(HWND hDlg)
{
//	UpdateListAndScrollBar( hDlg, TRUE );
	HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);
	SetListCtrlItemFocus( hLC, (BYTE)g_ItemChanged.iItem );
}

int MyInsertItem( HWND hCtrl, LPTSTR lpszBuff, int iItem )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    ZeroMemory( plvItem, sizeof( LVITEM ) );

    plvItem->mask         = LVIF_TEXT;
    plvItem->pszText      = lpszBuff;
    plvItem->cchTextMax = lstrlen(lpszBuff);
    plvItem->iItem       = iItem;

    return ListView_InsertItem(hCtrl, (const LPLVITEM)plvItem);
}

void SetScrollBarPosition( HWND hDlg, INT pos, int iDevIndex )
{
  SendDlgItemMessage(hDlg,
		     IDC_APPMAN_SCROLLBAR,
		     TBM_SETPOS,
		     (WPARAM) TRUE,
		     (LPARAM) pos);
  
  // change text
  SetScrollBarString( hDlg, pos, iDevIndex );
}


void  SetScrollBarString(HWND hDlg, INT pos, int iDevIndex)
{
  HRESULT     hr;
  DWORD       dwMegaBytes;
  TCHAR       szTempText[MAX_STR_LEN] = {0};
  TCHAR       szItemText1[MAX_STR_LEN] = {0};
  TCHAR       szItemText2[MAX_STR_LEN] = {0};


  LoadString(ghInstance, IDS_APPMAN_GRP_PERCENT_DISK_USED, szTempText, MAX_STR_LEN);
  _stprintf(szItemText1, szTempText, iDevIndex + 65);
  hr = AppManGetAllocatedMeg( iDevIndex, pos, dwMegaBytes );
  LoadString(ghInstance, IDS_APPMAN_GAME_SPACE_ON_DRIVE, szTempText, MAX_STR_LEN);
  _stprintf(szItemText2, szTempText, iDevIndex + 65, dwMegaBytes, pos);

  SendDlgItemMessage(hDlg, IDC_APPMAN_GRP_PERCENT_DISK_USED, WM_SETTEXT, 0, (LPARAM)szItemText1);
  SendDlgItemMessage(hDlg, IDC_APPMAN_TEXT_PERCENT_DISK_USED, WM_SETTEXT, 0, (LPARAM)szItemText2);


  return;
}


#define ISVALID(item) ( (item < MAX_DEVICES) && (item>=0) )

// Default device is the first one.
DWORD g_CurrentItem = 0;

DWORD GetCurrentDeviceFromList( HWND hDlg, BYTE *nItem )
{
  if( ! AppManInitialized() ) return -1;

  if( ! g_ListPopulated ) return -1;

  int item = -1;
  HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);

  if( g_ItemChanged.isValid ) {
    // use this info 'cause it was set by the itemchanged notification
    item = g_ItemChanged.iItem;

  } else {

    item = ListView_GetNextItem(hLC, -1, LVNI_SELECTED);
    if( ! ISVALID(item) ) {
      item = ListView_GetNextItem(hLC, -1, LVNI_FOCUSED);
    }
  }

  DWORD dwDev = -1;
  if( ISVALID(item) ) {
    dwDev = GetItemData( hLC, (BYTE)item );
    if( ISVALID(dwDev) ) {
      g_CurrentItem = item;
      if( nItem != NULL) { 
	*nItem = (BYTE)item; 
      }
    } else {
      dwDev = item = -1;
    }
  }

  return dwDev;
}


void  ConfigureListControl( HWND hDlg )
{
  HWND          hLC;
  LVCOLUMN      lvColumn = {0};
  RECT          rc;


  hLC = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);

  ::SendMessage(hLC , LVM_SETEXTENDEDLISTVIEWSTYLE, 0, 
            		LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES | LVS_EX_HEADERDRAGDROP
		            // LVS_EX_TWOCLICKACTIVATE    // LVN_ITEMACTIVATE (WM_NOTIFY) 
                );

  GetClientRect(hLC, &rc);

//  4/18/2000(RichGr): Bug 32634 - Reduce the size of the columns to just below 100% so we
//     can avoid a horizontal scrollbar showing up under some resolutions.
  DWORD w = ((rc.right - rc.left) * 95) / 100;
  DWORD w1 = w / 3;            // 33% of width
  w = w - w1; 
  DWORD w2 = w / 3;             // 1/3 of remaining width
  DWORD w3 = w - w2;            // remaining width

  InsertColumn(hLC, APPMAN_LIST_EXCLUDE_CHECKBOX, IDS_APPMAN_EXCLUDE_CHECKBOX, (USHORT)(w1));
  InsertColumn(hLC, APPMAN_LIST_DRIVE,            IDS_APPMAN_DRIVE,  (USHORT)(w2));
  InsertColumn(hLC, APPMAN_LIST_EXCLUDED_PERCENT, IDS_APPMAN_EXCLUDED_PERCENT, (USHORT)(w3));

  //  3/31/2000(RichGr): Center Yes/No text in checkbox column.
  lvColumn.mask = LVCF_FMT;
  lvColumn.fmt  = LVCFMT_CENTER;

  ListView_SetColumn( hLC, APPMAN_LIST_EXCLUDE_CHECKBOX, &lvColumn );

  #if 0
  // 
  // now move the 0'th column all the way to the right
  //
    // Allocate the structure
  LPLVCOLUMN plvColumn = (LPLVCOLUMN)_alloca(sizeof(LVCOLUMN));
  ASSERT (plvColumn);

  ZeroMemory(plvColumn, sizeof(LVCOLUMN));

  plvColumn->mask = LVCF_FMT | LVCF_ORDER;
  plvColumn->fmt  = LVCFMT_CENTER;
  plvColumn->iOrder = 2;
  ListView_SetColumn( hLC, APPMAN_LIST_EXCLUDE_CHECKBOX, plvColumn );
  #endif

  return;
}


// populates from appman state
void  PopulateListControl( HWND hDlg, BYTE nItem )
{
  HRESULT     hr = S_OK;
  GUID        sDeviceGuid;
  BOOL        isExcluded = FALSE;
  DWORD       percent = 70;
  UCHAR       listIndex = (UCHAR)0;
  TCHAR       szTempText[MAX_STR_LEN] = {0};
  TCHAR       szItemText1[MAX_STR_LEN] = {0};
  TCHAR       szItemText2[MAX_STR_LEN] = {0};


  g_ListPopulated = FALSE;
  g_ChkBoxUpdate = FALSE;

  Assert( AppManInitialized() );

  HWND hLC = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);

  // Turn Redraw off here else it will flicker!
  ::SendMessage(hLC, WM_SETREDRAW, (WPARAM)FALSE, 0);
  
  // Out with the old...
  ::SendMessage(hLC, LVM_DELETEALLITEMS, 0, 0);


  //
  // we use do/while construct because we can only insert at the front of the list.
  //
  for(DWORD nDevIndex = 0; nDevIndex < MAX_DEVICES; nDevIndex++)
  {
    if( AppManDoesDeviceExist(nDevIndex, sDeviceGuid) )
    {
  	  // 
	    // this array maps list entry indices to valid device indices.
	    // for example, list entry index 0 contains drive D, which is index 2
	    //
	    LoadString(ghInstance, IDS_APPMAN_DRIVE_TEXT, szTempText, MAX_STR_LEN);
	    _stprintf(szItemText1, szTempText, nDevIndex + 65);

	    //
	    // Insert the Drive name
	    //

	    // Creates an item with a checkbox.  
	    int actualListIndex = MyInsertItem( hLC, _T(""), listIndex );
	    SetItemData( hLC, (BYTE)actualListIndex, nDevIndex );

	    // sets the text in the "Drive" column
	    SetItemText(hLC, (BYTE)actualListIndex, APPMAN_LIST_DRIVE, szItemText1);
      
	    //
	    // Populate the columns with "excluded" or "percentage"
	    //

	    hr = AppManIsDeviceExcluded( nDevIndex, isExcluded );

	    if ( isExcluded )
      {
	      LoadString(ghInstance, IDS_APPMAN_EXCLUDED, szTempText, MAX_STR_LEN);
	      _stprintf(szItemText1, szTempText);
	      LoadString(ghInstance, IDS_APPMAN_CHECKBOX_NO, szTempText, MAX_STR_LEN);
	      _stprintf(szItemText2, szTempText);
	    }
      else
      {
	      LoadString(ghInstance, IDS_APPMAN_GAME_USAGE, szTempText, MAX_STR_LEN);
	      hr = AppManGetGameDiskUsage(nDevIndex, percent);
	      _stprintf(szItemText1, szTempText, percent);
	      LoadString(ghInstance, IDS_APPMAN_CHECKBOX_YES, szTempText, MAX_STR_LEN);
	      _stprintf(szItemText2, szTempText);
	    }

	    //
	    // sets the checkbox if it's excluded
	    //
	    ListView_SetCheckState( hLC, actualListIndex, !isExcluded );

	    SetItemText(hLC, (BYTE)actualListIndex, APPMAN_LIST_EXCLUDED_PERCENT, szItemText1);

      //  3/31/2000(RichGr): Set "Allow new games" column to "Yes" or "No".
	    SetItemText(hLC, (BYTE)actualListIndex, APPMAN_LIST_EXCLUDE_CHECKBOX, szItemText2);

	    listIndex++;
    } // if
  } // for

  //
  // set focus on that item
  //
  SetListCtrlItemFocus( hLC, nItem );

  //
  // Turn the redraw flag back on!
  // 
  ::SendMessage (hLC, WM_SETREDRAW, (WPARAM)TRUE, 0);

  g_ListPopulated = TRUE;
  g_ChkBoxUpdate = TRUE;

  return;
}


/*
BOOL ListView_SortItems(
    HWND hwnd, 		
    PFNLVCOMPARE pfnCompare, 		
    LPARAM lParamSort		
);

BOOL ListView_SortItemsEx(
    HWND hwnd, 
    PFNLVCOMPARE pfnCompare, 
    LPARAM lParamSort
);

This macro is similar to ListView_SortItems, 
except for the type of information passed to the comparison function. 
With ListView_SortItemsEx, the item's index is passed instead
 of its lparam value. 


int CALLBACK CompareFunc(
			 LPARAM lParam1, 
			 LPARAM lParam2, 
			 LPARAM lParamSort); 
 
*/

void EnableAllControls( HWND hDlg, BOOL bEnable )
{
//  HWND hwnd;

  // do manage disk cb
  //hwnd =  GetDlgItem(hDlg, IDC_APPMAN_MANAGE_DISK);
  //EnableWindow( hwnd, bEnable );

  EnableDiskManageControls( hDlg, bEnable );
}


void EnableDiskManageControls( HWND hDlg, BOOL bEnable )
{
  HWND hwnd;
  // LIST CONTROL
  hwnd = GetDlgItem(hDlg, IDC_APPMAN_DRIVE_LIST);
  
  EnableWindow( hwnd, bEnable );

  EnableScrollBarAndText( hDlg, bEnable );
}


void EnableScrollBarAndText( HWND hDlg, BOOL bEnable )
{
  HWND hwnd;

  // SCROLLBAR
  //PostDlgItemEnableWindow( hDlg, IDC_APPMAN_SCROLLBAR, enableManageDiskSpace );
  hwnd =  GetDlgItem(hDlg, IDC_APPMAN_SCROLLBAR);
  EnableWindow( hwnd, bEnable );

  // TEXT
  hwnd = GetDlgItem(hDlg, IDC_APPMAN_TEXT_PERCENT_DISK_USED);
  EnableWindow( hwnd, bEnable );
}

///////////////////////////////////////////////////////////////////
//  AppMan functions
///////////////////////////////////////////////////////////////////

#define RELEASE(p) { if((p)) { (p)->Release(); p = NULL; } }

IApplicationManagerAdmin *g_IAppManAdmin = NULL;

BOOL  AppManInitialized() { return (g_IAppManAdmin != NULL); }

HRESULT AppManInit()
{
  HRESULT hr = S_OK;

  // Important
  if( AppManInitialized() ) return hr;

  if (FAILED(CoInitialize(NULL)))
    {
      return E_FAIL;
    }
    
  hr = CoCreateInstance(CLSID_ApplicationManager, 
			NULL, 
			CLSCTX_INPROC_SERVER, 
			IID_ApplicationManagerAdmin, 
			(LPVOID *) &g_IAppManAdmin);

  if( FAILED(hr) ) return hr;

  return hr;
}


BOOL  AppManDoesDeviceExist(DWORD devIndex, GUID &sDevGuid)
{
  return (SUCCEEDED(g_IAppManAdmin->EnumerateDevices(devIndex, &sDevGuid))) ? TRUE : FALSE;
}

DWORD g_dwExclusionMask = APP_CATEGORY_ENTERTAINMENT;

HRESULT AppManShutdown()
{
  RELEASE( g_IAppManAdmin );
  return S_OK;
}


HRESULT AppManSetGameDiskUsage(DWORD devIndex, DWORD percent)
{
  HRESULT hr = S_OK;
  GUID sDeviceGuid;

  if( g_IAppManAdmin ) {
    
    if (SUCCEEDED(g_IAppManAdmin->EnumerateDevices(devIndex, &sDeviceGuid)))
      {
	hr = g_IAppManAdmin->SetDeviceProperty(DEVICE_PROPERTY_PERCENTCACHESIZE, 
					       &sDeviceGuid, 
					       &percent, 
					       sizeof(percent));
      }
  }

  return hr;
}

HRESULT AppManGetAdvMode(BOOL &bAdvMode)
{
  HRESULT hr = S_OK;

  if( g_IAppManAdmin )
	  hr = g_IAppManAdmin->GetAppManProperty(APPMAN_PROPERTY_ADVANCEDMODE, &bAdvMode, sizeof(DWORD));

  return hr;
}


HRESULT AppManSetAdvMode(BOOL bAdvMode)
{
  HRESULT hr = S_OK;

  if( g_IAppManAdmin )
	  hr = g_IAppManAdmin->SetAppManProperty(APPMAN_PROPERTY_ADVANCEDMODE, &bAdvMode, sizeof(DWORD));

  return hr;
}

HRESULT AppManGetGameDiskUsage(DWORD devIndex, DWORD &percent)
{
  HRESULT hr = S_OK;
  GUID sDeviceGuid;

  if( g_IAppManAdmin ) {
    if (SUCCEEDED(g_IAppManAdmin->EnumerateDevices(devIndex, &sDeviceGuid)))
      {
	hr = g_IAppManAdmin->GetDeviceProperty(DEVICE_PROPERTY_PERCENTCACHESIZE, 
					       &sDeviceGuid, 
					       &percent, 
					       sizeof(percent));
      }
  }

  return hr;
}

HRESULT  AppManExcludeDevice(DWORD devIndex, BOOL bDoInclude)
{
  HRESULT hr = S_OK;
  GUID sDeviceGuid;

  if( g_IAppManAdmin ) 
  {
    if (SUCCEEDED(g_IAppManAdmin->EnumerateDevices(devIndex, &sDeviceGuid)))
    {

		DWORD dwMask = g_dwExclusionMask;

	    // Get the prior mask.
	    hr = g_IAppManAdmin->GetDeviceProperty(DEVICE_PROPERTY_EXCLUSIONMASK, 
					       &sDeviceGuid, 
					       &dwMask, 
					       sizeof(g_dwExclusionMask));

		if (SUCCEEDED(hr))
		{
			if( !bDoInclude ) 
			{
				// Exclude the drive, set the APP_CATEGORY_ENTERTAINMENT bit
				dwMask |= APP_CATEGORY_ENTERTAINMENT;
			}
			else
			{
				// Include the drive, clear the APP_CATEGORY_ENTERTAINMENT bit
				dwMask &= ~APP_CATEGORY_ENTERTAINMENT;
			}

			hr = g_IAppManAdmin->SetDeviceProperty(DEVICE_PROPERTY_EXCLUSIONMASK, 
					       &sDeviceGuid, 
					       &dwMask, 
					       sizeof(g_dwExclusionMask));
		}
	}
  }
  return hr;
}


HRESULT  AppManIsDeviceExcluded(DWORD devIndex, BOOL &isExcluded)
{
  HRESULT hr = S_OK;
  GUID sDeviceGuid;
  DWORD dwExcMask;

  if( g_IAppManAdmin ) {
    if (SUCCEEDED(g_IAppManAdmin->EnumerateDevices(devIndex, &sDeviceGuid)))
      {
	hr = g_IAppManAdmin->GetDeviceProperty(DEVICE_PROPERTY_EXCLUSIONMASK, 
					       &sDeviceGuid, 
					       &dwExcMask,
					       sizeof(dwExcMask));

	if( SUCCEEDED(hr) ) {

	  // 
	  // XXX: make sure JUST the flags i'm interested in are on
	  //
	  if( dwExcMask & APP_CATEGORY_ENTERTAINMENT) // somthing is on
	    {
	      isExcluded = TRUE;
	    } else {
	      isExcluded = FALSE;
	    }
	} 
      }
  }
  return hr;  
}


HRESULT  AppManGetAllocatedMeg(DWORD devIndex, DWORD percent, DWORD &dwMegaBytes)
{
  HRESULT hr = S_OK;
  GUID sDeviceGuid;

  if( g_IAppManAdmin ) {
    if (SUCCEEDED(g_IAppManAdmin->EnumerateDevices(devIndex, &sDeviceGuid)))
      {
	hr = g_IAppManAdmin->GetDeviceProperty(DEVICE_PROPERTY_TOTALKILOBYTES, 
					       &sDeviceGuid, 
					       &dwMegaBytes,
					       sizeof(dwMegaBytes));
	if(SUCCEEDED(hr)) {
	  dwMegaBytes = DWORD(  float(dwMegaBytes) * (float(percent) / 100.0f) );
	  dwMegaBytes = dwMegaBytes >> 10;  // turn kilobytes into megabytes
	} else {
	  dwMegaBytes = -1;
	}
      }
  }

  return hr;
}
					       
////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnAdvHelp ( LPARAM lParam )
//
// PARAMETERS:  lParam - Pointer to HELPINFO struct
//
// PURPOSE:     WM_HELP message handler
////////////////////////////////////////////////////////////////////////////////////////
void OnAdvHelp(LPARAM lParam)
{
    ASSERT (lParam);

    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    ASSERT (pszHelpFileName);

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
    {
        if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: AppMan.cpp: OnAdvHelp: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnContextMenu ( WPARAM wParam )
//
// PARAMETERS:  wParam - HWND of window under the pointer
//
// PURPOSE:     Handle WM_RBUTTONDOWN over all client windows 
// (except the list control... that's OnListviewContextMenu() job)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam, LPARAM lParam)
{
//    HWND hListCtrl = NULL
    ASSERT (wParam);

#if 0
    hListCtrl = GetDlgItem((HWND) wParam, IDC_APPMAN_DRIVE_LIST);

    // If you are on the ListCtrl...
    if( (HWND)wParam == hListCtrl )
    {
        SetFocus(hListCtrl);

        // Don't attempt if nothing selected
        if( iItem != NO_ITEM )
            OnListviewContextMenu(hListCtrl,lParam);
    } else
#endif
    {
        // point to help file
        LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
        ASSERT (pszHelpFileName);

        if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
            WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
        else OutputDebugString(TEXT("JOY.CPL: appman.cpp: OnContextMenu: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

        if( pszHelpFileName )
            delete[] (pszHelpFileName);
    }
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    OnListviewContextMenu( void )
//
// PURPOSE:     Handle Context menu in Listview
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
static void OnListviewContextMenu( HWND hWnd, LPARAM lParam )
{
    HMENU hPopupMenu = CreatePopupMenu();
    HWND hListCtrl = NULL;

    hListCtrl = GetDlgItem(hWnd, IDC_APPMAN_DRIVE_LIST);
    ASSERT (hPopupMenu);

    // unlike life, bRet defaults to bliss
    BOOL bRet = TRUE;

    LPTSTR pszText = new TCHAR[STR_LEN_32];
    ASSERT (pszText);

    // Don't display Rename/Change if on (none) entry
    if( !(GetItemData(hListCtrl, (BYTE)iItem) & ID_NONE) )
    {
        if( TRUE ) // Borrowed code...
        {
            // add the "Change..." string
            ::SendDlgItemMessage(GetParent(hListCtrl), IDC_ADV_CHANGE, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)pszText);

            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_ADV_CHANGE, pszText); 
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

            // Add the Rename text
            VERIFY(LoadString(ghInstance, IDS_RENAME, pszText, STR_LEN_32));
            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_RENAME, pszText);
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

            // Add the SEPERATOR and "What's this?"
            bRet = AppendMenu(hPopupMenu, MF_SEPARATOR, 0, 0); 
#ifdef _DEBUG
            if( !bRet )
                TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert SEPERATOR!\n"));
#endif //_DEBUG
        }
    }

    VERIFY(LoadString(ghInstance, IDS_WHATSTHIS, pszText, STR_LEN_32));
    bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDS_WHATSTHIS, pszText); 
#ifdef _DEBUG
    if( !bRet )
        TRACE(TEXT("JOY.CPL: OnListviewCOntextMenu: AppendMenu Failed to insert %s\n"), pszText);
#endif //_DEBUG

    if( pszText ) delete[] (pszText);

    POINT pt;

    // lParam is -1 if we got here via Shift+F10
    if( lParam > 0 )
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    } else
    {
        // Center the popup on the selected item!

        // This get's a good X pos, but the y is the start of the control!
        ::SendMessage(hListCtrl, LVM_GETITEMPOSITION, iItem, (LPARAM)&pt);

        RECT rc;
        ::GetClientRect(hListCtrl, &rc);

        pt.x = rc.right>>1;

        ClientToScreen(hListCtrl, &pt);
    }

    bRet = TrackPopupMenu (hPopupMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, 0, ghDlg, NULL);
#ifdef _DEBUG
    if( !bRet )
        TRACE (TEXT("JOY.CPL: OnListviewContextMenu: TrackPopupMenu Failed!\n"));
#endif //_DEBUG

    DestroyMenu (hPopupMenu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\cpanel.h ===
/*
File:		cpanel.h
Project:	Universal Joystick Control Panel OLE Client
Author:	Brycej
Date:		02/08/95
Comments: 
         general header file

Copyright (c) 1995, Microsoft Corporation
*/


#define DIRECTINPUT_VERSION         0x05B2

#ifndef _CPANEL_H_
#define _CPANEL_H_

#include <commctrl.h>

#define _INC_MMSYSTEM
#define WINMMAPI    DECLSPEC_IMPORT
typedef UINT        MMRESULT;   /* error return code, 0 means no error */
                                /* call as if(err=xxxx(...)) Error(err); else */
// end of hack to avoid including mmsystem.h!!!

#ifndef _UNICODE
#include <malloc.h>		// for alloca
#include <afxconv.h>	   // for AfxW2AHelper
//USES_CONVERSION;
#endif

// DI includes
#include "dinput.h"
#include "dinputd.h"

#include "resource.h"
#include "sstructs.h"
#include "ifacesvr.h"  // also has HSrvGuid.h!!!

#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif

typedef HRESULT (STDAPICALLTYPE * LPFNDIRECTINPUTCREATE)(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUT *ppDI, LPUNKNOWN punkOuter);

#ifndef USES_CONVERSION
#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0;
#endif
#endif // USES_CONVERSION

#ifndef A2W
#define A2W(lpa) (((LPCSTR)lpa == NULL) ? NULL : (_convert = (lstrlenA(lpa)+1),	AfxA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))
#endif // A2W

#ifndef W2A
#define W2A(lpw) (((LPCWSTR)lpw == NULL) ? NULL : (_convert = (wcslen(lpw)+1)*2, AfxW2AHelper((LPTSTR) alloca(_convert), lpw, _convert)))
#endif // W2A

//#define IMAGE_NOTCONNECTED	0
const int IMAGE_DEFAULTJOY = 0;
const BYTE NUMJOYDEVS = 16;

#define ID_NONE 		0x10000	// This gets ID_NONE out of the low word of the extended info!

//#define SUPPORT_TWO_2A2B    1

#define MUTEX_NAME	TEXT("$$$MS_GameControllers_Cpl$$$")

// max string length for language strings
#define MAX_STR_LEN	255
#define STR_LEN_128	128
#define STR_LEN_64	 64
#define STR_LEN_32	 32

#define MAX_DEVICES	 75
#define MAX_BUSSES   10
#define MAX_GLOBAL_PORT_DRIVERS 10
#define MAX_ASSIGNED  32

// flags for bNeedUpdate!
#define UPDATE_FOR_ADV  0x01
#define UPDATE_FOR_GEN  0x02
#define UPDATE_ALL      UPDATE_FOR_ADV | UPDATE_FOR_GEN
#define UPDATE_INPROCESS 0x04
#define ON_PAGE			0x08
#define USER_MODE		0x10
#define BLOCK_UPDATE	0x20	// This Blocks WM_DEVICECHANGE messages from doing anything!!!
								// If you use this, remove it when you are done!
#define ON_NT			0x40

// DI define for Get and Set Config to support all currently support bit flags
#define DIJC_ALL DIJC_REGHWCONFIGTYPE |  DIJC_CALLOUT  | DIJC_WDMGAMEPORT | DIJC_GAIN | DIJC_GUIDINSTANCE
#define DITC_ALL DITC_CLSIDCONFIG  | DITC_REGHWSETTINGS   | DITC_DISPLAYNAME | DITC_CALLOUT | DITC_HARDWAREID 

// General Column IDs
#define DEVICE_COLUMN	0
#define STATUS_COLUMN	1

class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
	private:
		DWORD				m_cProperty_refcount;
		
	public:
		CDIGameCntrlPropSheet(void);
		~CDIGameCntrlPropSheet(void);
		
		// IUnknown methods
	    STDMETHODIMP            QueryInterface(REFIID, PPVOID);
	    STDMETHODIMP_(ULONG)    AddRef(void);
	    STDMETHODIMP_(ULONG)    Release(void);
		
		// CImpIServerProperty methods
		STDMETHODIMP			GetSheetInfo(LPDIGCSHEETINFO *lpSheetInfo);
		STDMETHODIMP			GetPageInfo (LPDIGCPAGEINFO  *lpPageInfo );
		STDMETHODIMP			SetID(USHORT nID);
	    STDMETHODIMP_(USHORT)   GetID(void);
};
typedef CDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;

struct JOY
{
	char ID;
	BYTE nStatus;
	BYTE nButtons;
	CLSID clsidPropSheet;
    BOOL fHasOemSheet;
	LPDIRECTINPUTDEVICE2 fnDeviceInterface;

	JOY();
	virtual ~JOY();
};

typedef JOY *PJOY;

int CALLBACK CompareListItems(LPARAM, LPARAM, LPARAM);
int CALLBACK CompareStatusItems(LPARAM, LPARAM, LPARAM);
LRESULT GetHelpFileName(LPTSTR lpszHelpFileName, short* nSize);
BOOL CreateJoyConfigInterface( void );
BOOL DeleteAssignedType( LPWSTR lpwszType );

void OnHelp(LPARAM);  //  for ? help - lives in Add.cpp!
BOOL PopulatePortList( HWND hCtrl ); // Lives in Add.cpp!
void Error (short nTitleID, short nMsgID); // Lives in Cpanel.cpp
void itoa(BYTE n, LPTSTR lpStr);
BOOL SortTextItems( CListCtrl *pCtrl, short nCol, BOOL bAscending, short low, short high );
BOOL DeleteSelectedItem( PBYTE nItem );

// DI Callback proc for enumerating the DI devices
BOOL CALLBACK DIEnumJoyTypeProc(LPCWSTR pwszTypeName, LPVOID pvRef );
BOOL CALLBACK DIEnumDevicesProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid);
HRESULT Enumerate( HWND hDlg );

#ifdef DX7
BOOL CALLBACK DIEnumMiceProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid);
BOOL CALLBACK DIEnumKeyboardsProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid);
#endif // DX7
//LPCDIGAMECNTRLPROPSHEET HasInterface( REFCLSID refCLSID, HINSTANCE hOleInst );
void ClearArrays			( void );
void PostDlgItemEnableWindow( HWND hDlg, USHORT nItem, BOOL bEnabled);
void PostEnableWindow		( HWND hCtrl, BOOL bEnabled );
void MoveOK	 				( HWND hParentWnd );
void LaunchExtention		( HWND hWnd );

// ListControl helper functions!!!
DWORD GetItemData			( HWND hCtrl, BYTE nItem );
BOOL SetItemData			( HWND hCtrl, BYTE nItem, DWORD dwFlag );
void InsertColumn 			( HWND hCtrl, BYTE nColumn, USHORT nStrID, USHORT nWidth );
void SetListCtrlItemFocus 	( HWND hCtrl, BYTE nItem );
void SetItemText			( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpStr);
BYTE GetItemText			( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpszBuff, BYTE nLen );
BYTE InsertItem				( HWND hCtrl, LPTSTR lpszBuff, BYTE nItem); 
void SwapIDs				( BYTE nSource, BYTE nTarget);


#ifdef _UNICODE
void RegisterForDevChange(HWND hDlg, PVOID *hNodifyDevNode);
#endif


#define SETTINGS_PAGE		0
#define TEST_PAGE			1
#define DIAGNOSTICS_PAGE	2
#define MENU_OFFSET			2800

// Dialog proc definitions
BOOL WINAPI CPanelProc		(HWND, ULONG, WPARAM, LPARAM);
BOOL WINAPI AdvancedProc	(HWND, ULONG, WPARAM, LPARAM);
BOOL WINAPI AppManProc  	(HWND, ULONG, WPARAM, LPARAM);
BOOL WINAPI AppManLockProc 	(HWND, ULONG, WPARAM, LPARAM);
BOOL WINAPI AddDialogProc	(HWND, ULONG, WPARAM, LPARAM);
BOOL WINAPI CustomDialogProc(HWND, ULONG, WPARAM, LPARAM);
BOOL WINAPI ChangeDialogProc(HWND, ULONG, WPARAM, LPARAM);

HRESULT Launch(HWND hWnd, PJOY pJoy, BYTE nStartPage);

// Local String function prototypes
#ifdef STRINGS_IN_LOCAL_RESOURCE
BOOL RCSetDlgItemText( HWND hDlg, USHORT nCtrlID, USHORT nStringID);
#endif // STRINGS_IN_LOCAL_RESOURCE

#ifndef LVM_SETEXTENDEDLISTVIEWSTYLE
#define LVM_SETEXTENDEDLISTVIEWSTYLE	(LVM_FIRST+54)
#endif 

#ifndef LVS_EX_FULLROWSELECT
#define LVS_EX_FULLROWSELECT			0x00000020
#endif 

#ifndef LVS_EX_TRACKSELECT
#define LVS_EX_TRACKSELECT				0x00000008
#endif

DEFINE_GUID(CLSID_NULL,	0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);


inline int atoiW(const WCHAR *sz)
{
    BYTE i = 0;

    while (*sz && *sz >= L'0' && *sz <= L'9')
    	i = i*10 + *sz++ - L'0';
    	
    return i;    	
}

inline int WINAPI atoiA(const CHAR *sz)
{
    BYTE i = 0;

    while (*sz && *sz >= '0' && *sz <= '9')
    	i = i*10 + *sz++ - '0';
    	
    return i;    	
}

#ifdef UNICODE
#define atoi    atoiW
#else
#define atoi    atoiA
#endif

// update.cpp
//  void Update(HWND hDlg, int nAccess, TCHAR *tszProxy);
//  INT_PTR CALLBACK CplUpdateProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif //_CPANEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\cpanel.cpp ===
/*
 * File:    Cpanel.cpp
 * Project: Universal Joystick Control Panel OLE Client
 * Author:  Brycej
 * Date:    02/08/95 - Started this maddness...
 *          04/15/97 - Updated to use DI interface
 * Comments:
 *          window proc for General page in cpanel
 *
 * Copyright (c) 1995, Microsoft Corporation
 */                                                      

/*
// This is necessary LVS_EX_INFOTIP
#if (_WIN32_IE < 0x0500)
#undef _WIN32_IE
#define  _WIN32_IE  0x0500
#endif
*/


#include <afxcmn.h>
#include <windowsx.h>

#ifndef _UNICODE
    #define INC_OLE2

    #include <objbase.h>    // For COM stuff!
#endif

#include <initguid.h>

#include <cpl.h>
#include <winuser.h>  // For RegisterDeviceNotification stuff!
#include <dbt.h>      // for DBT_ defines!!!
#include <hidclass.h>
#include <malloc.h>  // for _alloca
#include <regstr.h>		  // for REGSTR_PATH_JOYOEM reference!

#include "hsvrguid.h"
#include "cpanel.h"
#include "resource.h"
#include "joyarray.h"

// constants
const short ID_MYTIMER  = 1000;
const short POLLRATE        = 850;
const short NO_ITEM    = -1;

#define IDC_WHATSTHIS   400

// externs
extern const DWORD gaHelpIDs[];
extern HINSTANCE ghInstance;

// externs for arguements!
extern BYTE nID, nStartPageDef, nStartPageCPL;

// DI globals
IDirectInputJoyConfig* pDIJoyConfig = 0;
LPDIRECTINPUT lpDIInterface = 0;

// Array of all available devices
#ifndef _UNICODE
WCHAR *pwszGameportDriverArray[MAX_GLOBAL_PORT_DRIVERS]; // List of enumerated Gameport Drivers
BYTE nGameportDriver; // Global Port Driver Enumeration Counter
#endif

WCHAR *pwszTypeArray[MAX_DEVICES];    // List of enumerated devices
WCHAR *pwszGameportBus[MAX_BUSSES];   // List of enumerated gameport buses 
PJOY  pAssigned[MAX_ASSIGNED];        // List of assigned devices

BYTE nGamingDevices;     // Gaming Devices Enumeration Counter
BYTE nGameportBus;    // Gameport Bus Enumeration Counter
BYTE nAssigned;       // Number of elements in pAssigned array
BYTE nTargetAssigned;  // Number of elements expected in pAssigned array when pending adds complete
BYTE nReEnum;           // Counter used to decide when to reenumerate

GUID guidOccupied[MAX_BUSSES];  //Whether the gameport bus has been occupied.

short nFlags;         // Flags for Update, User Mode, and if the user is on this page!

// local (module-scope) variables
static HWND hListCtrl;
short  iItem = NO_ITEM; // index of selected item
extern short iAdvItem;

// Global to avoid creating in timer!
static LPDIJOYSTATE   lpDIJoyState;

static UINT JoyCfgChangedMsg;     // vjoyd JoyConfigChanged message
static BOOL WINAPI MsgSubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static WNDPROC fpMainWindowProc; 

#ifdef _UNICODE
static PVOID hNotifyDevNode;     
#endif

// local message handlers
static BOOL OnInitDialog             (HWND, HWND, LPARAM);
static void OnCommand                (HWND, int, HWND, UINT);
static BOOL OnNotify                    (HWND, WPARAM, NMHDR*);
static void OnDestroy                (HWND);
static void OnListViewContextMenu (HWND hDlg,     LPARAM lParam);

#ifndef _UNICODE
BOOL AddListCtrlItem(BYTE nItemID, LPDIJOYCONFIG pJoyConfig);
#endif


// Share these with Add.cpp
void OnContextMenu           (WPARAM wParam, LPARAM lParam);
void OnHelp                      (LPARAM);

#ifdef WINNT
// Share this one with Advanced.cpp
void RunWDMJOY               ( void );
#endif

// local utility fns
static BOOL DetectHotplug     ( HWND hDlg, BYTE nItemSelected );
static BOOL SetActive         ( HWND hDlg );
static void UpdateListCtrl      ( HWND hDlg );
static void UpdateButtonState ( HWND hDlg );
static void StatusChanged     ( HWND hDlg, BYTE i );

JOY::JOY()
{
    ID                  = nStatus = nButtons = -1; 
    clsidPropSheet  = CLSID_LegacyServer;
    fnDeviceInterface = 0;
}

JOY::~JOY()
{
    if( fnDeviceInterface )
    {
        fnDeviceInterface->Unacquire();
        fnDeviceInterface->Release();
        fnDeviceInterface = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
//CPanelProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam)
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CPanelProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
    case WM_ACTIVATEAPP:
        if( nFlags & ON_PAGE )
        {
            if( wParam )
            {
                if( nFlags & UPDATE_FOR_GEN )
                {
                    nFlags &= ~UPDATE_FOR_GEN;
                    UpdateListCtrl(hDlg);
                }

                // Set the focus!
                if( nAssigned )
                {
                    if( iItem == NO_ITEM )
                        iItem = 0;

                    if( pDIJoyConfig )
                        SetActive(hDlg);

                    // restore selection focus
                    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);
                } else {
                    UpdateButtonState(hDlg);
                }

                // the user is requesting that the CPL be shown
                // and an extention associated with nID be Launched.
                if( nID < NUMJOYDEVS )
                {

                    BYTE nCount = (BYTE)::SendMessage(hListCtrl, LVM_GETITEMCOUNT, 0, 0);

                    while( nCount-- )
                    {
                        if( pAssigned[GetItemData(hListCtrl, (BYTE)iItem)]->ID == nID )
                        {
                            KillTimer(hDlg, ID_MYTIMER);

                            OnCommand(hDlg, IDC_BTN_PROPERTIES, 0, 0);

                            SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
                            break;
                        }
                    }

                    // just to get nID > NUMJOYDEVS!
                    nID = (NUMJOYDEVS<<1);
                }
            } else
            {
                KillTimer(hDlg, ID_MYTIMER);
            }
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hDlg), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        if( !HANDLE_WM_INITDIALOG(hDlg, wParam, lParam, OnInitDialog) )
        {
            // Fix #108983 NT, Remove Flash on Error condition.
            SetWindowPos(::GetParent(hDlg), HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
            DestroyWindow(hDlg);
        }

        // if we want to set focus, get the control hWnd 
        // and set it as the wParam.
        return(TRUE);

    case WM_DESTROY:
        HANDLE_WM_DESTROY(hDlg, wParam, lParam, OnDestroy);
        return(1);

        // OnTimer
    case WM_TIMER:
        {
            BYTE i = nAssigned; 
            BYTE nButtons;
            BYTE nLoop;

            if( nReEnum )
            {
                if( !( --nReEnum & 3 ) )
                {
                    //  ISSUE-2001/03/29-timgill Much used code
                    //  (MarcAnd) I hope this code is generally appropriate
                    //  it appears in much the same form all over the place.
                    KillTimer(hDlg, ID_MYTIMER);
                    // Set the Update Flag!
                    nFlags |= UPDATE_ALL;
                    UpdateListCtrl(hDlg);
                    SetActive(hDlg);
                    SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
                }
            }

            while( i-- )
            {
                if( pAssigned[i]->fnDeviceInterface )
                {
                    int nPollFail;

                    pAssigned[i]->fnDeviceInterface->Acquire();

                    // LOOKOUT RE-USE of nButtons!
                    nButtons = pAssigned[i]->nStatus;

                    nLoop = 5; 
                    nPollFail = 0;

                    // Special work for the sidewinder folks...
                    // ACT LAB: You can't poll actrs.vxd (ACT LAB) too often, otherwise it fails.
                    //          See Manbug 41049.  - qzheng 8/1/2000
                    do
                    {
                        if( FAILED(pAssigned[i]->fnDeviceInterface->Poll()) ) {
                            nPollFail ++;
                        } else {
                            break;
                        }

                        Sleep(30);
                    } while( nLoop-- );

                    // Check to see if things have changed!
                    pAssigned[i]->nStatus = (nPollFail > 2) ? (BYTE)0 : (BYTE)JOY_US_PRESENT;

                    if( pAssigned[i]->nStatus != nButtons )
                    {
                        StatusChanged(hDlg, i);
                    }

                    // Check for button press and set focus to it!!!
                    if( pAssigned[i]->nStatus == JOY_US_PRESENT )
                    {
                        // Do the button press launch thing!
                        if( SUCCEEDED(pAssigned[i]->fnDeviceInterface->GetDeviceState(sizeof(DIJOYSTATE), lpDIJoyState)) )
                        {
                            nButtons = pAssigned[i]->nButtons;

                            // run up the list of buttons and check if there's one that's down!
                            while( nButtons-- )
                            {
                                if( lpDIJoyState->rgbButtons[nButtons] & 0x80 )
                                {
                                    // SetFocus on Selected Item
                                    SetListCtrlItemFocus(hListCtrl, i);
                                    break;
                                }
                            }
                        }
                    }
                
                }
            }

            if( nAssigned ) {
                /*
                 * If the selected device is "Not Connected", grey out the property button.
                 */
                int id = GetItemData(hListCtrl, (BYTE)iItem);
                PostDlgItemEnableWindow(hDlg, IDC_BTN_PROPERTIES, (BOOL)(pAssigned[id]->nStatus & JOY_US_PRESENT));
            }

        }
        break;

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hDlg, wParam, lParam, OnCommand);
        return(1);

    case WM_NOTIFY:
        return(HANDLE_WM_NOTIFY(hDlg, wParam, lParam, OnNotify));

    case WM_POWERBROADCAST:
        switch( wParam )
        {
        case PBT_APMSUSPEND:
            // Suspend operation!
            KillTimer(hDlg, ID_MYTIMER);
            break;

        case PBT_APMRESUMESUSPEND:
        case PBT_APMRESUMECRITICAL:
            // Resume operation!
            SetActive(hDlg);
            break;
        }
        break;

    case WM_DEVICECHANGE:
        switch( (UINT)wParam )
        {
        case DBT_DEVICEQUERYREMOVE:
            {
                KillTimer(hDlg, ID_MYTIMER);

                BYTE i = (BYTE)::SendMessage(hListCtrl, LVM_GETITEMCOUNT, 0, 0);

                // Acquire All Devices that are Attached!!!
                char nIndex;

                while( i-- )
                {
                    // get joystick config of item
                    nIndex = (char)GetItemData(hListCtrl, i);

                    if( pAssigned[nIndex]->nStatus & JOY_US_PRESENT )
                        pAssigned[nIndex]->fnDeviceInterface->Unacquire();
                }
            }
            break;

        case DBT_DEVICEARRIVAL:
        case DBT_DEVICEREMOVECOMPLETE:
            if( nFlags & ON_PAGE )
            {
                PostMessage(hDlg, WM_COMMAND, IDC_BTN_REFRESH, 0);            	

              #if 0
                if( !(nFlags & BLOCK_UPDATE) )
                {
                    KillTimer(hDlg, ID_MYTIMER);

                    // Set the Update Flag!
                    nFlags |= UPDATE_ALL;

                    UpdateListCtrl(hDlg);

                    SetActive(hDlg);

                    SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
                }
              #endif
            }
            break;
        }
        break;

    case WM_HELP:
        KillTimer(hDlg, ID_MYTIMER);
        OnHelp(lParam);
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case WM_CONTEXTMENU:
        nFlags &= ~ON_PAGE;
        KillTimer(hDlg, ID_MYTIMER);
        OnContextMenu(wParam, lParam);
        nFlags |= ON_PAGE;
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        return(1);
    }

    return(0);
}

///////////////////////////////////////////////////////////////////////////////
// StatusChanged( HWND hDlg, BYTE i )
///////////////////////////////////////////////////////////////////////////////
void StatusChanged( HWND hDlg, BYTE i )
{
    // Update the buttons and set focus to changed item!  
    PostDlgItemEnableWindow(hDlg, IDC_BTN_PROPERTIES, (BOOL)(pAssigned[i]->nStatus & JOY_US_PRESENT));

    if( pAssigned[0] )
    {
        PostDlgItemEnableWindow(hDlg, IDC_BTN_REMOVE, TRUE );
    }

    // Don't try to make this buffer any smaller... 
    // Remember... we also have "Not Connected"!
    TCHAR sz[20];

    // display result
    VERIFY(LoadString(ghInstance, (pAssigned[i]->nStatus & JOY_US_PRESENT) ? IDS_GEN_STATUS_OK : IDS_GEN_STATUS_NOTCONNECTED, (LPTSTR)&sz, 20));


    LVFINDINFO *lpFindInfo = new (LVFINDINFO);
    ASSERT (lpFindInfo);

    ZeroMemory(lpFindInfo, sizeof(LVFINDINFO));

    lpFindInfo->flags  = LVFI_PARAM;
    lpFindInfo->lParam = i;

    // Make sure you place i where it's suppose to be!
    i = (BYTE)::SendMessage(hListCtrl, LVM_FINDITEM, (WPARAM)(int)-1, (LPARAM)(const LVFINDINFO*)lpFindInfo);

    if( lpFindInfo )
        delete (lpFindInfo);

    SetItemText(hListCtrl, i, STATUS_COLUMN, sz);
    ::PostMessage(hListCtrl, LVM_UPDATE, (WPARAM)i, 0L);
    SetListCtrlItemFocus(hListCtrl, i);
}


///////////////////////////////////////////////////////////////////////////////
//OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
///////////////////////////////////////////////////////////////////////////////
BOOL OnInitDialog(HWND hDlg, HWND hWnd, LPARAM lParam)
{
    // initialize our list control
    hListCtrl = GetDlgItem(hDlg, IDC_LIST_DEVICE);
    ASSERT(hListCtrl);

    // LVS_EX_ONECLICKACTIVATE removed per PSierra                                           | LVS_EX_INFOTIP
    ::SendMessage(hListCtrl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    if( !lpDIInterface )
    {
        if( FAILED(DirectInputCreate(ghInstance, DIRECTINPUT_VERSION, &lpDIInterface, NULL)) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: DirectInputCreate() failed\n"));
#endif
            Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
            return(FALSE);
        }
    }

    // Dynamically size the columns!
    RECT rc;
    ::GetClientRect(hListCtrl, &rc);

    // cut the list control into 1/4ths
    rc.right >>= 2;

    // This one get's 3/4ths
    InsertColumn(hListCtrl, DEVICE_COLUMN, IDS_GEN_DEVICE_HEADING, (USHORT)(rc.right*3));   

    // Column heading for Status
    InsertColumn(hListCtrl, STATUS_COLUMN, IDS_GEN_STATUS_HEADING, (USHORT)(rc.right+3));   

    if( !pDIJoyConfig )
    {

        // just in case CoCreateInstanceFailed...
        if( FAILED(lpDIInterface->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID*)&pDIJoyConfig)) )
        {
#ifdef _DEBUG
            OutputDebugString (TEXT("JOY.CPL: CoCreateInstance Failed... Closing CPL!\n"));
#endif
            Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);

            return(FALSE);
        }

        VERIFY (SUCCEEDED(pDIJoyConfig->SetCooperativeLevel(hDlg, DISCL_EXCLUSIVE | DISCL_BACKGROUND)));
    }

    // Zero out the global counters!
#ifndef _UNICODE
    nGameportDriver = 0;
#endif
    nGamingDevices = nGameportBus = 0;

    // Try to Acquire, if you fail... Disable the Add and Remove buttons!
    if( pDIJoyConfig->Acquire() == DIERR_INSUFFICIENTPRIVS )
    {
        nFlags |=  USER_MODE;

        LONG style = ::GetWindowLong(hListCtrl, GWL_STYLE);
        style &= ~LVS_EDITLABELS;

        ::SetWindowLong(hListCtrl, GWL_STYLE, style);
    }
#ifdef WINNT
    else 
    {
        //Run the WDMJOY.INF file!!!
        RunWDMJOY();
        pDIJoyConfig->SendNotify();
    }        
#endif

    if( FAILED(pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL)) )
    {
#ifdef _DEBUG
        OutputDebugString( TEXT("JOY.CPL: Failed BuildEnumList!\n") );
#endif
        return(FALSE);
    }

    // Don't allow Add if there is nothing to add!
    // OR no port to add them to!
    if( ((!nGameportBus) && (!nGamingDevices)) 
#ifdef _UNICODE
        || GetSystemMetrics(SM_REMOTESESSION) 
#endif
    ) {
        PostDlgItemEnableWindow(hDlg, IDC_BTN_ADD, FALSE);
    }

    // register the JOY_CONFIGCHANGED_MSGSTRING defined in MMDDK.H if you're on Memphis
    JoyCfgChangedMsg = (nFlags & ON_NT) ? NULL : RegisterWindowMessage(TEXT("MSJSTICK_VJOYD_MSGSTR"));

    // blj: Warning Message that you can't add any more devices!
    if( nGamingDevices == MAX_DEVICES-1 )
        Error((short)IDS_MAX_DEVICES_TITLE, (short)IDS_MAX_DEVICES_MSG);

    // blj: beginning of fix for 5.0 to turn on all devices!
    LPDIJOYCONFIG_DX5 pJoyConfig = new (DIJOYCONFIG_DX5);
    ASSERT (pJoyConfig);

    ZeroMemory(pJoyConfig, sizeof(DIJOYCONFIG_DX5));

    pJoyConfig->dwSize = sizeof(DIJOYCONFIG_DX5);

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    BYTE nIndex = nAssigned;
    HRESULT hr;

    while( nIndex )
    {
        hr = pDIJoyConfig->GetConfig(pAssigned[--nIndex]->ID, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE);

        if( (hr == S_FALSE) || FAILED(hr) )
            continue;

        if( pJoyConfig->hwc.dwUsageSettings & JOY_US_PRESENT )
            continue;

        pJoyConfig->hwc.dwUsageSettings |= JOY_US_PRESENT;

        VERIFY(SUCCEEDED(pDIJoyConfig->SetConfig(pAssigned[nIndex]->ID, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE)));

        // Fix #55524
        VERIFY(SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[nIndex]->ID, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE)));

        if( !(pJoyConfig->hwc.dwUsageSettings & JOY_US_PRESENT) )
        {
            if( SUCCEEDED(pDIJoyConfig->Acquire()) )
            {
                pJoyConfig->hwc.dwUsageSettings |= JOY_US_PRESENT;
                pJoyConfig->hwc.hwv.dwCalFlags  |= 0x80000000;
                VERIFY(SUCCEEDED(pDIJoyConfig->SetConfig(pAssigned[nIndex]->ID, (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE)));
            }
        }
        // end of Fix #55524
    } 

    if( pJoyConfig ) delete (pJoyConfig);
    // blj: end of fix for 5.0 to turn on all devices!

    // Set the hour glass
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    HWND hParentWnd = GetParent(hDlg);

    GetWindowRect(hParentWnd, &rc);

    // Only center the dialog if this was the page that we started on!
    if( (nStartPageCPL == 0) || (nStartPageCPL == NUMJOYDEVS) )
    {
        // Centre the Dialog!
        SetWindowPos(hParentWnd, NULL, 
                     (GetSystemMetrics(SM_CXSCREEN) - (rc.right-rc.left))>>1, 
                     (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom-rc.top))>>1, 
                     NULL, NULL, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        if( nStartPageCPL == NUMJOYDEVS )
            PostMessage(hDlg, WM_COMMAND, IDC_BTN_ADD, 0);
    }

    // Do that move button thing!
    MoveOK(hParentWnd);

    // this is required because the CPL can be launched via RUNDLL32
    if( ::IsWindow(hParentWnd) )
        hParentWnd = GetParent(hParentWnd);

    // Since the JOY_CONFIGCHANGED_MSGSTRING msg only gets sent to top-level
    // windows, this calls for a subclass!
    if( JoyCfgChangedMsg )
        fpMainWindowProc = (WNDPROC)SetWindowLongPtr(hParentWnd, GWLP_WNDPROC, (LONG_PTR)MsgSubClassProc);

    // Set bOnPage so WM_ACTIVATEAPP will work!
    nFlags |= ON_PAGE;

    // Update the list ctrl!
    nFlags |= UPDATE_FOR_GEN;

    // to put the selection on the first item on startup...
    if( nAssigned )
        iItem = 0;

    lpDIJoyState = new (DIJOYSTATE);
    ASSERT (lpDIJoyState);

    ZeroMemory(lpDIJoyState, sizeof(DIJOYSTATE));

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
//OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
///////////////////////////////////////////////////////////////////////////////
void OnCommand(HWND hDlg, int id, HWND hWndCtl, UINT code)
{                                                
    switch( id )
    {
    case IDC_WHATSTHIS:
        {
            // point to help file
            LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
            ASSERT (pszHelpFileName);

            if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
                WinHelp((HWND)hListCtrl, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
            else 
                OutputDebugString(TEXT("JOY.CPL: OnCommand: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

            if( pszHelpFileName ) {
                delete[] (pszHelpFileName);
            }
        }
        return;

    case IDC_BTN_REMOVE:
        KillTimer(hDlg, ID_MYTIMER);
        nFlags &= ~ON_PAGE;

        // Block Update, otherwise we'll be forced to update and we don't need to!
        nFlags |= BLOCK_UPDATE;

        if( nFlags & USER_MODE )
            Error((short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
        else if( DeleteSelectedItem((PBYTE)&iItem) )
        {
            UpdateButtonState(hDlg);

            // Set the UpdateFlag!
            nFlags |= UPDATE_FOR_ADV;

            // Set the default push button to the Add button!
            ::PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)1, (LPARAM)LOWORD(FALSE));
        }

        // Unblock the WM_DEVICECHANGE message handler!
        nFlags &= ~BLOCK_UPDATE;

        nFlags |= ON_PAGE;
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case IDC_BTN_ADD:
        // Don't set ON_PAGE flag!
        // We need the WM_DEVICECHANGE message in the case a user plugs in a device!

        KillTimer(hDlg, ID_MYTIMER);

        ClearArrays();

        // Clear everything up before you call this...
        if( FAILED(pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL)) )
            break;

        nFlags &= ~ON_PAGE;

        if( nFlags & USER_MODE )
        {
            Error((short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
        }
        // call AddDevice dialog
        else if( DialogBox( ghInstance, (PTSTR)IDD_ADD, hDlg, (DLGPROC)AddDialogProc ) == IDOK )
        {
            SendMessage(hDlg, WM_COMMAND, IDC_BTN_REFRESH, 0);
        }

        SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);

        nFlags &= ~BLOCK_UPDATE;
        nFlags |= ON_PAGE;

        // Now, we set it back active!
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case IDC_BTN_REFRESH:
        KillTimer(hDlg, ID_MYTIMER);

        nFlags |= UPDATE_ALL;

        pDIJoyConfig->Acquire();
        pDIJoyConfig->SendNotify();

        UpdateListCtrl(hDlg);
        UpdateButtonState(hDlg);

        pDIJoyConfig->SendNotify();
        pDIJoyConfig->Unacquire();

        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case IDC_RENAME:
        // Don't allow editing of Mouse or Keyboard names!
        // Don't allow renaming if in USER mode!
        if( !(nFlags & USER_MODE) )
        {
            KillTimer(hDlg, ID_MYTIMER);

            ::PostMessage(hListCtrl, LVM_EDITLABEL, (WPARAM)(int)iItem, 0);
        }
        return;

        /* If we want this back...
        case IDC_SW_HACK:
            {
            // SideWinder Hack button!
            BYTE nID = pAssigned[GetItemData(hListCtrl, (BYTE)iItem)]->ID;
    
            if (nID == 0) 
            {
                ::PostMessage(GetDlgItem(hDlg, IDC_SW_HACK), BM_SETCHECK, BST_CHECKED, 0);
                //CheckDlgButton(hDlg, IDC_SW_HACK, BST_CHECKED);
                break;
            }
    
            // Get the Selected Item and force its ID to Zero!
            SwapIDs((BYTE)nID, (BYTE)0);
            }
        */
        // Missing break intentional!
        // Used to fall into IDC_BTN_REFRESH!

    case IDC_BTN_TSHOOT:
        {
            LPTSTR lpszCmd = new (TCHAR[STR_LEN_64]);
            ASSERT (lpszCmd);

            if( LoadString(ghInstance, IDS_TSHOOT_CMD, lpszCmd, STR_LEN_64) )
            {
                LPSTARTUPINFO pSi           = (LPSTARTUPINFO)_alloca(sizeof(STARTUPINFO));
                LPPROCESS_INFORMATION pPi  = (LPPROCESS_INFORMATION)_alloca(sizeof(PROCESS_INFORMATION));

                ZeroMemory(pSi, sizeof(STARTUPINFO));
                ZeroMemory(pPi, sizeof(PROCESS_INFORMATION));

                pSi->cb              = sizeof(STARTUPINFO);
                pSi->dwFlags     = STARTF_USESHOWWINDOW | STARTF_FORCEONFEEDBACK;
                pSi->wShowWindow = SW_NORMAL;

                if( CreateProcess(0, lpszCmd, 0, 0, 0, 0, 0, 0, pSi, pPi) )
                {
                    CloseHandle(pPi->hThread);
                    CloseHandle(pPi->hProcess);
                }
            }

            if( lpszCmd )
                delete[] (lpszCmd);
        }
        break;
 			
#if 0  //disable UPDATE button, see manbug 33666.
    case IDC_BTN_UPDATE:
        if (DialogBox(ghInstance, MAKEINTRESOURCE(IDD_UPDATE), hDlg, CplUpdateProc) == IDOK)
        {
            Update( hDlg, 1, NULL ); //NO Proxy
        }
        break;
#endif

    case IDC_BTN_PROPERTIES:

        // Because PSN_KILLACTIVE is not sent... we do it ourselves
        // kill status timer
        KillTimer(hDlg, ID_MYTIMER);
        nFlags &= ~ON_PAGE;

        {
            char nIndex = (char)GetItemData(hListCtrl, (BYTE)iItem);

            // default to the first page!
#ifdef _DEBUG
            HRESULT hr = 
#endif _DEBUG
            Launch(hDlg, pAssigned[nIndex], IsEqualIID(pAssigned[nIndex]->clsidPropSheet, CLSID_LegacyServer) ? 1 : 0);

#ifdef _DEBUG
            switch( hr )
            {
            case DIGCERR_NUMPAGESZERO:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NUMPAGESZERO!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NODLGPROC:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NODLGPROC!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NOPREPOSTPROC:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NOPREPOSTPROC!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NOTITLE:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NOTITLE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NOCAPTION:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NOCAPTION!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NOICON:            
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NOICON!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_STARTPAGETOOLARGE:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_STARTPAGETOOLARGE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_NUMPAGESTOOLARGE:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_NUMPAGESTOOLARGE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case DIGCERR_INVALIDDWSIZE: 
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error DIGCERR_INVALIDDWSIZE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case E_NOINTERFACE:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error E_NOINTERFACE!\n"), pAssigned[nIndex]->ID, id);
                break;

            case E_OUTOFMEMORY:
                TRACE (TEXT("JOY.CPL: Launch failed device ID #%d, Page #%d, with the error E_OUTOFMEMORY!\n"), pAssigned[nIndex]->ID, id);
                break;

                //case DIGCERR_NUMPAGESTOOLARGE:
                //case DIGCERR_STARTPAGETOOLARGE:

            default:
// Only display this return code if things are going Really weird.
                TRACE (TEXT("JOY.CPL: Launch return code is %x %s!\n"), hr, strerror(hr));
                break;
            }
#endif // _DEBUG

            nFlags |= ON_PAGE;

            //OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: returned from Property sheet!\n"));

            InvalidateRect(hDlg, NULL, TRUE);
            UpdateWindow(hDlg);

            // Now, we set it back active!
            // create timer
            SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        }
        break;
    }

    // Set the focus where we left off!
    if( iItem == NO_ITEM )
        iItem = 0;

    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);
}

////////////////////////////////////////////////////////////////////////////////
// OnNotify(HWND hDlg, WPARAM idFrom, NMHDR* pnmhdr)
// Purpose: WM_NOTIFY Handler
////////////////////////////////////////////////////////////////////////////////
BOOL OnNotify(HWND hDlg, WPARAM idFrom, NMHDR* pnmhdr)
{
    switch( pnmhdr->code )
    {
    case PSN_QUERYCANCEL:
        if( nFlags & UPDATE_INPROCESS )
            nFlags &= ~UPDATE_INPROCESS;
        break;

    case LVN_BEGINLABELEDIT:
        if( nFlags & USER_MODE )
            return(TRUE);

        KillTimer(hDlg, ID_MYTIMER);
        ::PostMessage((HWND)::SendMessage(hListCtrl, LVM_GETEDITCONTROL, 0, 0), EM_SETLIMITTEXT, MAX_STR_LEN, 0);

        // This lets us know if the edit field is up!
        nFlags |= UPDATE_INPROCESS;
        return(FALSE);   

/*
    case LVN_GETINFOTIP:
        {
        LPLVHITTESTINFO lpHit = new (LVHITTESTINFO);
        ASSERT (lpHit);

        BOOL bRet = FALSE;

        POINT pt;
        GetCursorPos(&pt);
        ScreenToClient(hListCtrl, &pt);

        lpHit->pt    = pt;
        lpHit->flags = lpHit->iItem = lpHit->iSubItem = 0;

        ::SendMessage(hListCtrl, LVM_SUBITEMHITTEST, 0, (LPARAM)(LPLVHITTESTINFO)lpHit);

        // We only want to support the device column!
        if (lpHit->iSubItem == 0)
        {
            if (lpHit->flags & LVHT_ONITEMLABEL)
            {
                // Determine the text length of the column text
                LPTSTR lpStr = new (TCHAR[MAX_STR_LEN+1]);
                ASSERT (lpStr);

                GetItemText(hListCtrl, lpHit->iItem, lpHit->iSubItem, lpStr, MAX_STR_LEN);

                // Determine if the latter will fit inside the former...
                SIZE size;
                HDC hDC = GetDC(hListCtrl);
               GetTextExtentPoint(hDC, lpStr, lstrlen(lpStr), &size);
                ReleaseDC(hListCtrl, hDC);

                // Determine how wide the column is!
                short nWidth = (short)::SendMessage(hListCtrl, LVM_GETCOLUMNWIDTH, lpHit->iSubItem, 0);

                bRet = (BOOL)(size.cx > nWidth);

                if (bRet)
                    // if not, copy the text into lpHit->pszText
                    _tcscpy(((LPNMLVGETINFOTIP)pnmhdr)->pszText, lpStr);

                if (lpStr)
                    delete[] (lpStr);
            }
        }

        if (lpHit)
            delete (lpHit);

        return bRet;
        }
*/

    case LVN_ENDLABELEDIT:
        if( nFlags & UPDATE_INPROCESS )
        {
            HWND hCtrl = (HWND)::SendMessage(hListCtrl, LVM_GETEDITCONTROL, 0, 0);
            ASSERT(::IsWindow(hCtrl));

            if( ::SendMessage(hCtrl, EM_GETMODIFY, 0, 0) )
            {
                BYTE nLen = (BYTE)lstrlen(((NMLVDISPINFO *)pnmhdr)->item.pszText);

                if( (nLen > MAX_STR_LEN) || (nLen == 0) )
                    MessageBeep(MB_ICONHAND);

                // Make sure the name is usable!
                else if( _tcschr(((NMLVDISPINFO *)pnmhdr)->item.pszText, TEXT('\\')) )
                {
                    Error((short)IDS_INVALID_NAME_TITLE, (short)IDS_INVALID_NAME);
                } else
                {
                    // Set the Update flag!
                    nFlags |= UPDATE_ALL;

                    LPDIPROPSTRING pDIPropString = new (DIPROPSTRING);
                    ASSERT (pDIPropString);

                    ZeroMemory(pDIPropString, sizeof(DIPROPSTRING));

                    pDIPropString->diph.dwSize       = sizeof(DIPROPSTRING);
                    pDIPropString->diph.dwHeaderSize = sizeof(DIPROPHEADER);
                    pDIPropString->diph.dwHow        = DIPH_DEVICE;

#ifdef _UNICODE
                    wcscpy(pDIPropString->wsz, ((NMLVDISPINFO *)pnmhdr)->item.pszText);
#else
                    USES_CONVERSION;
                    wcscpy(pDIPropString->wsz, A2W(((NMLVDISPINFO *)pnmhdr)->item.pszText));
#endif
                    if( SUCCEEDED(pAssigned[iItem]->fnDeviceInterface->SetProperty(DIPROP_INSTANCENAME, &pDIPropString->diph)) )
                    {
                        SetItemText(hListCtrl, (BYTE)iItem, 0, ((NMLVDISPINFO *)pnmhdr)->item.pszText);
                    } else
                    {
                        Error((short)IDS_NO_RENAME_TITLE, (short)IDS_NO_RENAME);
                    }

                    if( pDIPropString )
                        delete (pDIPropString);

                    // Trip the flag so the Advanced page knows it needs to update!
                    nFlags |= UPDATE_FOR_ADV;
                }
            }
            // Clear the InProcess flag!
            nFlags &= ~UPDATE_INPROCESS;

        }
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        break;

    case LVN_KEYDOWN:
        switch( ((LV_KEYDOWN*)pnmhdr)->wVKey )
        {
        case VK_DELETE:
            if( iItem != NO_ITEM )
                SendMessage(hDlg, WM_COMMAND, IDC_BTN_REMOVE, 0);
            break;

        case VK_F5:
            nFlags |= UPDATE_ALL;

            UpdateListCtrl(hDlg);

            if( GetKeyState(VK_SHIFT) & 0x80 )
            {
#ifdef WINNT
                RunWDMJOY();
#endif
                ClearArrays();

                pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL);
            }
            break;
        }
        break;

#if 0
    case LVN_COLUMNCLICK:
        {
            CListCtrl *pCtrl = new (CListCtrl);
            ASSERT(pCtrl);

            pCtrl->Attach(hListCtrl);

            if( ((NM_LISTVIEW*)pnmhdr)->iSubItem )
            {
                static bItemDirection = TRUE;

                SortTextItems(pCtrl, 0, bItemDirection =! bItemDirection, 0, -1);
            } else
            {
                static bLabelDirection = TRUE;

                SortTextItems(pCtrl, 0, bLabelDirection =! bLabelDirection, 0, -1);
            }

            pCtrl->Detach();

            if( pCtrl )
                delete (pCtrl);
        }
        break;
#endif

    case LVN_ITEMCHANGED:
        if( iItem != NO_ITEM )
        {
            // get index of selected item
            // no point if it's not changed!
            if( iItem != (short)((NM_LISTVIEW*)pnmhdr)->iItem )
            {
                int i = GetItemData(hListCtrl, (char)iItem);

                iItem = (short)((NM_LISTVIEW*)pnmhdr)->iItem;

                iAdvItem = pAssigned[i]->ID;

                UpdateButtonState(hDlg);
            }
        }
        break;

    case NM_DBLCLK:
        switch( idFrom )
        {
        case IDC_LIST_DEVICE:
            if( iItem == NO_ITEM )
            {
                if( !(nFlags & USER_MODE) && nGameportBus )
                    OnCommand(hDlg, IDC_BTN_ADD, 0, 0);
            } else if( IsWindowEnabled(GetDlgItem(hDlg, IDC_BTN_PROPERTIES)) )
            {
                // make sure the connected one has got an interface pointer...
                OnCommand(hDlg, IDC_BTN_PROPERTIES, 0, 0);
            }
            break;
        }
        break;

    case PSN_KILLACTIVE:
        KillTimer(hDlg, ID_MYTIMER);

        nFlags &= ~ON_PAGE;

        if( nFlags & UPDATE_INPROCESS )
            SetFocus(hListCtrl);

#ifdef _UNICODE
        if( hNotifyDevNode )
            UnregisterDeviceNotification(hNotifyDevNode);
#endif
        PostMessage(hDlg, WM_ACTIVATEAPP, FALSE, 0);
        break;

    case PSN_SETACTIVE:
        nFlags |= ON_PAGE;
        nFlags |= UPDATE_FOR_GEN;
        
#ifdef _UNICODE
        // Set up the Device Notification
        RegisterForDevChange(hDlg, &hNotifyDevNode);
#endif
        SendMessage(hDlg, WM_ACTIVATEAPP, TRUE, 0);
        break;
    }
    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////
//  OnDestroy(HWND hWnd)                                              
////////////////////////////////////////////////////////////////////////////////////////
void OnDestroy(HWND hWnd)
{
    SetWindowPos( GetParent(hWnd), NULL, NULL, NULL, NULL, NULL, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW);

    if( lpDIJoyState )
        delete (lpDIJoyState);

    // if you are looking for where the following variables are deleted, look
    // in DLL_PROCESS_DETACH in MAIN.CPP:
    // pwszTypeArray, pwszGameportDriverArray, pwszGameportBus
    // This is done because of the way several Microsoft games load the CPL and
    // Don't Unload it between loads.

    // Clear pAssigned 
    while( nAssigned )
    {
        if( pAssigned[--nAssigned] )
        {
            delete (pAssigned[nAssigned]);

            pAssigned[nAssigned] = 0;
        }
    }
    // delete all existing entries
    //::PostMessage(hListCtrl, LVM_DELETEALLITEMS, 0, 0);

    // release the DI JoyConfig interface pointer
    if( pDIJoyConfig )
    {
        pDIJoyConfig->Release();
        pDIJoyConfig = 0;
    }

    // release the DI Device interface pointer
    if( lpDIInterface )
    {
        lpDIInterface->Release();
        lpDIInterface = 0;
    }

    // Drop the subclass, else you'll crash!
    if( !(nFlags & ON_NT) )
        SetWindowLongPtr(GetParent(GetParent(hWnd)), GWLP_WNDPROC, (LONG_PTR)fpMainWindowProc);
}

////////////////////////////////////////////////////////////////////////////////////////
//  OnHelp(LPARAM lParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnHelp(LPARAM lParam)
{
    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    ASSERT (pszHelpFileName);

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
    {
        if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);

    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: OnHelp: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
//  OnContextMenu(WPARAM wParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    // this prevents double handling of this message
    if( (HWND)wParam == hListCtrl )
    {
        OnListViewContextMenu(GetParent((HWND)wParam), lParam);
        return;
    }

    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    ASSERT (pszHelpFileName);                      

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
        WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: OnContextMenu: LoadString Failed to find IDS_HELPFILENAME!\n")); 
#endif

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

/////////////////////////////////////////////////////////////////////////////////////////
// OnListViewContextMenu(HWND hDlg)
// Purpose: Query the plug-in for the selected device for it's characteristics
//          Then construct a menu to reflect your findings
/////////////////////////////////////////////////////////////////////////////////////////
void OnListViewContextMenu(HWND hDlg, LPARAM lParam)
{
    BOOL bRet = TRUE;

    HMENU hPopupMenu = CreatePopupMenu();
    ASSERT (hPopupMenu);

    LPTSTR psz = new TCHAR[STR_LEN_32];
    ASSERT (psz);

    // Add the Refresh text
    VERIFY(LoadString(ghInstance, IDS_REFRESH, psz, STR_LEN_32));
    bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_BTN_REFRESH, psz);

    // Add the Add text

    HWND hCtrl;

    // Only Display Add menu option if we've found a GameportBus!!!
    if( nGameportBus 
#ifdef _UNICODE
        && !GetSystemMetrics(SM_REMOTESESSION) 
#endif
    )
    {
        hCtrl = GetDlgItem(hDlg, IDC_BTN_ADD);
        ASSERT(hCtrl);

        if( IsWindowEnabled(hCtrl) )
        {
            ::SendMessage(hCtrl, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)psz);

            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_BTN_ADD, psz);
            if( !bRet )
                TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert %s\n"), psz);
        }
    }

    // Add the Remove text
    hCtrl = GetDlgItem(hDlg, IDC_BTN_REMOVE);
    ASSERT(hCtrl);

    // Only Show it if it's available
    if( IsWindowEnabled(hCtrl) && (iItem != NO_ITEM) )
    {
        ::SendMessage(hCtrl, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)psz);

        bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_BTN_REMOVE, psz);
        if( !bRet )
            TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert %s\n"), psz);
    }

    // Add the Properties text
    hCtrl = GetDlgItem(hDlg, IDC_BTN_PROPERTIES);
    ASSERT (hCtrl);

    if( IsWindowEnabled(hCtrl) )
    {
        ::SendMessage(hCtrl, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)(LPCTSTR)psz);

        bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_BTN_PROPERTIES, psz);
        if( !bRet )
            TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert %s\n"), psz);
    }

    // Add the Rename text if not a USER!
    if( !(nFlags & USER_MODE) )
    {
        if( nAssigned && (iItem != NO_ITEM) )
        {
            VERIFY(LoadString(ghInstance, IDS_RENAME, psz, STR_LEN_32));
            bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_RENAME, psz);
        }
    }

    bRet = AppendMenu(hPopupMenu, MF_SEPARATOR, 0, 0); 
    if( !bRet )
        TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert the separator!\n"), psz);

    VERIFY(LoadString(ghInstance, IDS_WHATSTHIS, psz, STR_LEN_32));
    bRet = AppendMenu(hPopupMenu, MF_ENABLED, IDC_WHATSTHIS, psz); 
    if( !bRet )
        TRACE(TEXT("JOY.CPL: AppendMenu Failed to insert %s\n"), psz);

    if( psz ) delete[] (psz);

    POINT pt;

    // lParam is -1 if we got here via Shift+F10
    if( lParam > 0 )
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    } else
    {
        // Centre the popup on the selected item!

        // This get's a good X pos, but the y is the start of the control!
        ::SendMessage(hListCtrl, LVM_GETITEMPOSITION, iItem, (LPARAM)&pt);

        RECT rc;
        ::GetClientRect(hListCtrl, &rc);

        pt.x = rc.right>>1;

        ClientToScreen(hListCtrl, &pt);
    }

    // restore selection focus
    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);

    bRet = TrackPopupMenu (hPopupMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON, pt.x, pt.y, 0, hDlg, NULL);
    if( !bRet )
        TRACE (TEXT("JOY.CPL: TrackPopupMenu Failed!\n"));

    if(hPopupMenu) DestroyMenu (hPopupMenu);   // PREFIX 45088

    // Set the focus back to the item it came from!
    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);
}


int CALLBACK CompareStatusItems(LPARAM item1, LPARAM item2, LPARAM uDirection)
{
    if( (((PJOY)item1)->nStatus & JOY_US_PRESENT) == (((PJOY)item2)->nStatus & JOY_US_PRESENT) )
        return(0);

    return(uDirection) ? -1 : 1;
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    DeleteSelectedItem ( BYTE nItem )
//
// PARAMETERS:  nItem - ID of item to remove
//
// PURPOSE:     Prompt the user, delete the selected device from the listview, and update the registry
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL DeleteSelectedItem( PBYTE pnItem )
{
    BYTE nItem = *pnItem;
    
    // don't process if nothing is selected.
    if( *pnItem == NO_ITEM )
        return(FALSE);

    LV_ITEM lvItem;
    lvItem.mask       = LVIF_PARAM;
    lvItem.iSubItem = 0;
    lvItem.iItem    = *pnItem;

    if( !ListView_GetItem(hListCtrl, &lvItem) )
        return(FALSE);

    ::PostMessage(hListCtrl, LVM_ENSUREVISIBLE, *pnItem, FALSE );

    LPTSTR pszTitle = new TCHAR[STR_LEN_64];
    ASSERT (pszTitle);

    // Query user if they are sure!
    VERIFY(LoadString(ghInstance, IDS_GEN_AREYOUSURE, pszTitle, STR_LEN_64));   

    // Get the name of the device for the message box!

    //PREFIX #WI226554. Won't fix. Obsolete code, from Whistler on replaced with new version.
    LPTSTR lptszTmp = new TCHAR[STR_LEN_64];

    // Make sure the name isn't so long as to over-write the buffer!
    if( GetItemText(hListCtrl, (BYTE)*pnItem, DEVICE_COLUMN, lptszTmp, STR_LEN_64) > 60 )
    {
        lptszTmp[60] = lptszTmp[61] = lptszTmp[62] = TEXT('.');
        lptszTmp[63] = TEXT('\0');
    }

    LPTSTR pszMsg    = new TCHAR[MAX_STR_LEN];
    ASSERT (pszMsg);           

    wsprintf( pszMsg, pszTitle, lptszTmp);

    if( lptszTmp )
        delete[] (lptszTmp);

    VERIFY(LoadString(ghInstance, IDS_GEN_AREYOUSURE_TITLE, pszTitle, STR_LEN_64));

    BOOL bRet = (BOOL)(IDYES == MessageBox(GetFocus(), pszMsg, pszTitle, MB_ICONQUESTION | MB_YESNO | MB_APPLMODAL));

    if( pszMsg )      delete[] (pszMsg);
    if( pszTitle )   delete[] (pszTitle);

    if( bRet )
    {
        HRESULT hr;

        // Check for privileges!
        if( SUCCEEDED(hr = pDIJoyConfig->Acquire()) )
        {
            char nIndex = (char)GetItemData(hListCtrl, (BYTE)*pnItem);

            // Set the hour glass
            SetCursor(LoadCursor(NULL, IDC_WAIT));

            // Verify that you can delete the Config before you release the interface pointers!
            if( SUCCEEDED(hr = pDIJoyConfig->DeleteConfig(pAssigned[nIndex]->ID)) )
            {
                // make sure VJOYD is initialized
                if( !(nFlags & ON_NT) )
                    VERIFY (SUCCEEDED(pDIJoyConfig->SendNotify()));

                ::SendMessage(hListCtrl, LVM_DELETEITEM, (WPARAM)(int)*pnItem, 0);

                // Move the last assigned to the hole... if there is one!
                if( nIndex != (nAssigned-1) )
                {
                    // Before you move the tail to the hole, 
                    // Release() the interfaces at the hole!
                    pAssigned[nIndex]->fnDeviceInterface->Unacquire();
                    pAssigned[nIndex]->fnDeviceInterface->Release();

                    // Move the tail to the hole.
                    CopyMemory(pAssigned[nIndex], pAssigned[nAssigned-1], sizeof (JOY));

                    pAssigned[nAssigned-1]->fnDeviceInterface = 0;

                    // Don't forget to set the index in the item data!
                    SetItemData(hListCtrl, nItem, nIndex);

                    // Assign the tail to the hole so it gets deleted!
                    nIndex = nAssigned-1;

                    // Don't forget to set the index in the item data!
                    // QZheng: This line is very wrong!!!
                    //SetItemData(hListCtrl, (BYTE)*pnItem, nIndex);

                }

                // delete the memory...
                if( pAssigned[nIndex] )
                {
                    delete (pAssigned[nIndex]);
                    pAssigned[nIndex] = 0;
                }

                // Set the focus before you corrupt iItem
                SetListCtrlItemFocus(hListCtrl, nIndex);

                pDIJoyConfig->SendNotify();  //do more to make sure

                pDIJoyConfig->Unacquire();


                // dec nAssigned
                nAssigned--;

                // if there's no items, tell iItem about it!
                if( nAssigned == 0 )
                    *pnItem = NO_ITEM;
            } else if( hr == DIERR_UNSUPPORTED )
            {
                Error((short)IDS_GEN_AREYOUSURE_TITLE, (short)IDS_GEN_NO_REMOVE_USB);
            }

            // Set the hour glass
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
    }
    return(bRet);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    DIEnumJoyTypeProc( LPCWSTR pwszTypeName, LPVOID pvRef )
//
// PARAMETERS:  LPCWSTR pwszTypeName - Type name of the device enumerated
//                  LPVOID pvRef            - 
//
// PURPOSE:     To Enumerate the types of devices associated with this system
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK DIEnumJoyTypeProc( LPCWSTR pwszTypeName, LPVOID pvRef )
{
    // Type info
    LPDIJOYTYPEINFO_DX5 lpdiJoyInfo = (LPDIJOYTYPEINFO_DX5)_alloca(sizeof(DIJOYTYPEINFO_DX5));
    ASSERT (lpdiJoyInfo);

    ZeroMemory(lpdiJoyInfo, sizeof(DIJOYTYPEINFO_DX5));

    lpdiJoyInfo->dwSize = sizeof(DIJOYTYPEINFO_DX5);

    // populate the Type Info                                         
    switch( pDIJoyConfig->GetTypeInfo(pwszTypeName, (LPDIJOYTYPEINFO)lpdiJoyInfo, DITC_REGHWSETTINGS) )
    {
    // errors to continue with...
    case DIERR_NOTFOUND:
        TRACE(TEXT("JOY.CPL: GetTypeInfo returned DIERR_NOTFOUND for type %s!\n"), pwszTypeName);
        return(DIENUM_CONTINUE);

        // errors to stop with...
    case DIERR_INVALIDPARAM:
        TRACE(TEXT("JOY.CPL: GetTypeInfo returned DIERR_INVALIDPARAM!\n"));
    case DIERR_NOMOREITEMS:
        return(DIENUM_STOP);
    }


    // a quick check to make sure we don't have the infamous array out of bounds problem!
#ifndef _UNICODE
    if( nGameportDriver > MAX_GLOBAL_PORT_DRIVERS-1 )
    {
    #ifdef DEBUG
        OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumJoyTypeProc: Global Gameport Drivers have exceeded MAX_GLOBAL_PORT_DRIVERS!\n"));
    #endif
        return(DIENUM_STOP);
    }
#endif

    if( nGameportBus > MAX_BUSSES-1 )
    {
#ifdef DEBUG
        OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumJoyTypeProc: Enumerated Gameport busses have exceeded MAX_BUSSES!\n"));
#endif // _DEBUG
        return(DIENUM_STOP);
    }

    if( nGamingDevices > MAX_DEVICES-1 )
    {
#ifdef DEBUG
        OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumJoyTypeProc: Enumerated Gameport busses have exceeded MAX_DEVICES!\n"));
#endif // _DEBUG
        return(DIENUM_STOP);
    }

    // check to see if it's a global port driver
#ifndef _UNICODE
    if( lpdiJoyInfo->hws.dwFlags & JOY_HWS_ISGAMEPORTDRIVER )
    {
        if( pwszGameportDriverArray[nGameportDriver] )
            wcsncpy(pwszGameportDriverArray[nGameportDriver], pwszTypeName, wcslen(pwszTypeName)+1);
        else
            pwszGameportDriverArray[nGameportDriver] = _wcsdup(pwszTypeName);
        nGameportDriver++;
    } else
#endif // _UNICODE
        if( lpdiJoyInfo->hws.dwFlags & JOY_HWS_ISGAMEPORTBUS )
    {
        if( pwszGameportBus[nGameportBus] )
            wcscpy(pwszGameportBus[nGameportBus], pwszTypeName);
        else
            pwszGameportBus[nGameportBus] = _wcsdup(pwszTypeName);
        nGameportBus++;
    } else
    {
        if( !(lpdiJoyInfo->hws.dwFlags & JOY_HWS_AUTOLOAD) )
        {
            // it's a standard gaming device
            if( pwszTypeArray[nGamingDevices] )
                wcsncpy(pwszTypeArray[nGamingDevices], pwszTypeName, wcslen(pwszTypeName)+1);
            else
                pwszTypeArray[nGamingDevices] = _wcsdup(pwszTypeName);
            nGamingDevices++;
        }
    }
    return(DIENUM_CONTINUE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    DIEnumDevicesProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid)
//
// PARAMETERS:  LPDIDEVICEINSTANCE lpDeviceInst     - Device Instance
//                  LPVOID lpVoid                           -
//
// PURPOSE:     To Enumerate the devices associated with this system
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK DIEnumDevicesProc(LPDIDEVICEINSTANCE lpDeviceInst, LPVOID lpVoid)
{
    LPDIRECTINPUTDEVICE  pdiDevTemp;

    pDIJoyConfig->Acquire();

    // First Create the device
    if( SUCCEEDED(lpDIInterface->CreateDevice(lpDeviceInst->guidInstance, &pdiDevTemp, 0)) )
    {
        PJOY pNewJoy = new JOY;
        ASSERT (pNewJoy);

        // Query for a device2 object
        if( FAILED(pdiDevTemp->QueryInterface(IID_IDirectInputDevice2, (LPVOID*)&pNewJoy->fnDeviceInterface)) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: QueryInterface failed!\n"));
#endif
            // release the temporary object
            pdiDevTemp->Release();
            return(FALSE);
        }

        DIPROPDWORD *pDIPropDW = new (DIPROPDWORD);
        ASSERT (pDIPropDW);

        ZeroMemory(pDIPropDW, sizeof(DIPROPDWORD));

        pDIPropDW->diph.dwSize       = sizeof(DIPROPDWORD);
        pDIPropDW->diph.dwHeaderSize = sizeof(DIPROPHEADER);
        pDIPropDW->diph.dwHow        = DIPH_DEVICE;

        // Get the device ID
        VERIFY (SUCCEEDED(pdiDevTemp->GetProperty(DIPROP_JOYSTICKID, &pDIPropDW->diph)));

        // release the temporary object
        pdiDevTemp->Release();

        pNewJoy->ID = (char)pDIPropDW->dwData;

        if( pDIPropDW )
            delete (pDIPropDW);

        // Get the Type name
        LPDIJOYCONFIG_DX5 lpDIJoyCfg = new (DIJOYCONFIG_DX5);
        ASSERT (lpDIJoyCfg);

        ZeroMemory(lpDIJoyCfg, sizeof(DIJOYCONFIG_DX5));

        lpDIJoyCfg->dwSize = sizeof(DIJOYCONFIG_DX5);

        VERIFY (SUCCEEDED(pDIJoyConfig->GetConfig(pNewJoy->ID, (LPDIJOYCONFIG)lpDIJoyCfg, DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT)));

        // Get the clsidConfig
        LPDIJOYTYPEINFO lpDIJoyType = new (DIJOYTYPEINFO);
        ASSERT(lpDIJoyType);

        ZeroMemory(lpDIJoyType, sizeof(DIJOYTYPEINFO));

        lpDIJoyType->dwSize = sizeof(DIJOYTYPEINFO);

        VERIFY (SUCCEEDED(pDIJoyConfig->GetTypeInfo(lpDIJoyCfg->wszType, (LPDIJOYTYPEINFO)lpDIJoyType, DITC_CLSIDCONFIG | DITC_REGHWSETTINGS | DITC_FLAGS1 ))); 

        if( lpDIJoyCfg )
            delete (lpDIJoyCfg);

        // if NULL, Leave as default.
        if( !IsEqualIID(lpDIJoyType->clsidConfig, GUID_NULL) ) {
            pNewJoy->fHasOemSheet = TRUE;
            if( !(lpDIJoyType->dwFlags1 & JOYTYPE_DEFAULTPROPSHEET) ) {
                pNewJoy->clsidPropSheet = lpDIJoyType->clsidConfig;
            }
        } else {
            pNewJoy->fHasOemSheet = FALSE;
        }

        // Assign the number of buttons!
        pNewJoy->nButtons = (BYTE)(lpDIJoyType->hws.dwNumButtons);

        if( lpDIJoyType )
            delete (lpDIJoyType);

        // Set it's format!!!
        if( SUCCEEDED(pNewJoy->fnDeviceInterface->SetDataFormat(&c_dfDIJoystick)) )
        {
            // Set it's Cooperative Level!
            if( FAILED(pNewJoy->fnDeviceInterface->SetCooperativeLevel(GetParent((HWND)GetParent(hListCtrl)), DISCL_NONEXCLUSIVE | DISCL_BACKGROUND)) )
            {
#ifdef _DEBUG
                OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: SetCooperativeLevel Failed!\n"));
#endif
            }
        }

        // Add the item to the tree!
        pAssigned[nAssigned] = pNewJoy;

        // If you're on the General page!
        if( nFlags & ON_PAGE )
        {
            // add to tree                                              
            LVITEM lvItem = {LVIF_TEXT | LVIF_PARAM, nAssigned, 0, 0, 0, lpDeviceInst->tszInstanceName, lstrlen(lpDeviceInst->tszInstanceName), 0, (LPARAM)nAssigned, 0};
            ::SendMessage(hListCtrl, LVM_INSERTITEM, 0, (LPARAM) (const LPLVITEM)&lvItem);
            //InsertItem(hListCtrl, lpDeviceInst->tszInstanceName, nAssigned);

            TCHAR sz[STR_LEN_32];
            VERIFY(LoadString(ghInstance, IDS_GEN_STATUS_UNKNOWN, (LPTSTR)&sz, STR_LEN_32));

            SetItemText(hListCtrl, nAssigned, STATUS_COLUMN, sz);
        }

        // Increment the array counter!
        nAssigned++;
        if( nAssigned == nTargetAssigned )
        {
            /*
             *  A new device arrived so assume there's no 
             *  longer any point in checking on the timer.
             */
            nTargetAssigned = (BYTE)-1;
            nReEnum = 0;
        }

    }
    return(DIENUM_CONTINUE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    ClearArrays ( void )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void ClearArrays( void )
{
#ifndef _UNICODE
    while( nGameportDriver )
    {
        free(pwszGameportDriverArray[--nGameportDriver]);
        pwszGameportDriverArray[nGameportDriver] = L'\0';
    }    

#endif // _UNICODE
    while( nGamingDevices )
    {
        free(pwszTypeArray[--nGamingDevices]);
        pwszTypeArray[nGamingDevices] = L'\0';
    }  

    while( nGameportBus )
    {
        free(pwszGameportBus[--nGameportBus]);
        pwszGameportBus[nGameportBus] = L'\0';
        memset( &guidOccupied[nGameportBus], 0, sizeof(GUID) );
    }   
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    UpdateListCtrl( HWND hDlg )
//
//  PARAMETERS: HWND hDlg - Handle to window to update
//
// PURPOSE:     Refreshes enumerated device list
//
// RETURN:      TRUE if successfull, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
static void UpdateListCtrl( HWND hDlg )
{
    if( !(nFlags & ON_PAGE) )
        return;

    // Turn Redraw off here else it will flicker!
    ::SendMessage(hListCtrl, WM_SETREDRAW, (WPARAM)FALSE, 0);

    // delete all existing entries
    ::SendMessage(hListCtrl, LVM_DELETEALLITEMS, 0, 0);

    Enumerate( hDlg );

    // turn the flag off!
    if( nFlags & UPDATE_FOR_GEN )
        nFlags &= ~UPDATE_FOR_GEN;

    // Turn the redraw flag back on!
    ::SendMessage (hListCtrl, WM_SETREDRAW, (WPARAM)TRUE, 0);
    InvalidateRect(hListCtrl, NULL, TRUE);
}

//#ifdef _UNICODE
HRESULT Enumerate( HWND hDlg )
{
    nFlags |= UPDATE_ALL;

    // Clear pAssigned 
    while( nAssigned )
    {
        if( pAssigned[--nAssigned] )
        {
            delete (pAssigned[nAssigned]);

            pAssigned[nAssigned] = 0;
        }
    }

    // Enumerate the Joysticks and put them in the list...  | DIEDFL_INCLUDEPHANTOMS
#ifdef _UNICODE
    return(lpDIInterface->EnumDevices(DIDEVTYPE_JOYSTICK, (LPDIENUMDEVICESCALLBACK)DIEnumDevicesProc, (LPVOID)hDlg, 
                                      DIEDFL_ALLDEVICES ));
#else
    return(lpDIInterface->EnumDevices(DIDEVTYPE_JOYSTICK, (LPDIENUMDEVICESCALLBACK)DIEnumDevicesProc, (LPVOID)hDlg, 
                                      DIEDFL_ALLDEVICES | DIEDFL_INCLUDEPHANTOMS));
#endif                                      
}
/*
#else
HRESULT Enumerate( HWND hDlg )
{
   // Clear pAssigned 
    while (nAssigned)
    {
    if (pAssigned[--nAssigned])
        {
        delete (pAssigned[nAssigned]);

            pAssigned[nAssigned] = 0;
        }
    }

    DIJOYCONFIG *pJoyConfig = new DIJOYCONFIG;
    ASSERT (pJoyConfig);

    pJoyConfig->dwSize = sizeof (DIJOYCONFIG);

    LPDIJOYTYPEINFO pdiJoyTypeInfo = new DIJOYTYPEINFO;
    ASSERT (pdiJoyTypeInfo);

    pdiJoyTypeInfo->dwSize = sizeof (DIJOYTYPEINFO);

    HRESULT hr;

    // find and assign ID's  
    for (BYTE n = 0; n < NUMJOYDEVS; n++)
    {
        hr = pDIJoyConfig->GetConfig(n, pJoyConfig, DIJC_REGHWCONFIGTYPE | DIJC_GUIDINSTANCE);

      if (hr == S_OK)
         AddListCtrlItem(n, pJoyConfig);
    }

    // clean up, clean up... everybody do your share!
    if (pJoyConfig)   delete   (pJoyConfig);
    if (pdiJoyTypeInfo) delete    (pdiJoyTypeInfo);

    return hr;
}

BOOL AddListCtrlItem(BYTE nItemID, LPDIJOYCONFIG pJoyConfig)
{
   LPDIRECTINPUTDEVICE  pdiDevTemp;

   pDIJoyConfig->Acquire();

   // First Create the device
   if (SUCCEEDED(lpDIInterface->CreateDevice(pJoyConfig->guidInstance, &pdiDevTemp, 0)))
   {
       PJOY pNewJoy = new JOY;
    ASSERT (pNewJoy);

      // Query for a device2 object
      if (FAILED(pdiDevTemp->QueryInterface(IID_IDirectInputDevice2, (LPVOID*)&pNewJoy->fnDeviceInterface)))
      {
#ifdef _DEBUG
         OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: QueryInterface failed!\n"));
#endif
         // release the temporary object
         pdiDevTemp->Release();
         return FALSE;
      }

      DIPROPDWORD *pDIPropDW = new (DIPROPDWORD);
      ASSERT (pDIPropDW);

      ZeroMemory(pDIPropDW, sizeof(DIPROPDWORD));

    pDIPropDW->diph.dwSize       = sizeof(DIPROPDWORD);
       pDIPropDW->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropDW->diph.dwHow        = DIPH_DEVICE;

      // Get the device ID
      VERIFY (SUCCEEDED(pdiDevTemp->GetProperty(DIPROP_JOYSTICKID, &pDIPropDW->diph)));

      // release the temporary object
      pdiDevTemp->Release();

      pNewJoy->ID = (char)pDIPropDW->dwData;

      if (pDIPropDW)
         delete (pDIPropDW);

      // Get the Type name
      LPDIJOYCONFIG_DX5 lpDIJoyCfg = new (DIJOYCONFIG_DX5);
      ASSERT (lpDIJoyCfg);

      ZeroMemory(lpDIJoyCfg, sizeof(DIJOYCONFIG_DX5));

      lpDIJoyCfg->dwSize = sizeof(DIJOYCONFIG_DX5);

      VERIFY (SUCCEEDED(pDIJoyConfig->GetConfig(pNewJoy->ID, (LPDIJOYCONFIG)lpDIJoyCfg, DIJC_REGHWCONFIGTYPE)));
      
      // Get the clsidConfig
      LPDIJOYTYPEINFO_DX5 lpDIJoyType = new (DIJOYTYPEINFO_DX5);
      ASSERT(lpDIJoyType);

      ZeroMemory(lpDIJoyType, sizeof(DIJOYTYPEINFO_DX5));

      lpDIJoyType->dwSize = sizeof(DIJOYTYPEINFO_DX5);

      VERIFY (SUCCEEDED(pDIJoyConfig->GetTypeInfo(lpDIJoyCfg->wszType, (LPDIJOYTYPEINFO)lpDIJoyType, DITC_CLSIDCONFIG))); 
      
    // if NULL, Leave as default.
       if (!IsEqualIID(lpDIJoyType->clsidConfig, GUID_NULL))
           pNewJoy->clsidPropSheet = lpDIJoyType->clsidConfig;

      if (lpDIJoyType)
         delete (lpDIJoyType);

      // Set it's format!!!
      if (FAILED(pNewJoy->fnDeviceInterface->SetDataFormat(&c_dfDIJoystick)))
        {
#ifdef _DEBUG
         OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: SetDataFormat() Failed!\n"));
#endif
        }

      // Set it's Cooperative Level!
      if (FAILED(pNewJoy->fnDeviceInterface->SetCooperativeLevel(GetParent((HWND)GetParent(hListCtrl)), DISCL_NONEXCLUSIVE | DISCL_BACKGROUND)))
        {
#ifdef _DEBUG
         OutputDebugString(TEXT("JOY.CPL: Cpanel.cpp: DIEnumDevicesProc: SetCooperativeLevel Failed!\n"));
#endif
        }

      // Add the item to the tree!
      pAssigned[nAssigned] = pNewJoy;

        // Get the number of buttons!
        LPDIDEVCAPS_DX3 lpDIDevCaps = new (DIDEVCAPS_DX3);
        ASSERT (lpDIDevCaps);

        ZeroMemory(lpDIDevCaps, sizeof(DIDEVCAPS_DX3));
       lpDIDevCaps->dwSize = sizeof(DIDEVCAPS_DX3);

        pAssigned[nAssigned]->fnDeviceInterface->Acquire();

      if (SUCCEEDED(pAssigned[nAssigned]->fnDeviceInterface->GetCapabilities((LPDIDEVCAPS)lpDIDevCaps)))
            pAssigned[nAssigned]->nButtons = (BYTE)lpDIDevCaps->dwButtons;

        if (lpDIDevCaps)
            delete (lpDIDevCaps);

        // If you're on the General page!
        if (nFlags & ON_PAGE)
        {
        DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
           ASSERT (pDIPropStr);
        
           ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

        pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
           pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
          pDIPropStr->diph.dwHow        = DIPH_DEVICE;
            
            pAssigned[nAssigned]->fnDeviceInterface->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph);

            USES_CONVERSION;

        // add to tree                                              
            LVITEM lvItem = {LVIF_TEXT | LVIF_PARAM, nAssigned, 0, 0, 0, W2A(pDIPropStr->wsz), lstrlen(W2A(pDIPropStr->wsz)), 0, (LPARAM)nAssigned, 0};
            ::SendMessage(hListCtrl, LVM_INSERTITEM, 0, (LPARAM) (const LPLVITEM)&lvItem);

            TCHAR sz[STR_LEN_32];
           VERIFY(LoadString(ghInstance, IDS_GEN_STATUS_UNKNOWN, (LPTSTR)&sz, STR_LEN_32));

        SetItemText(hListCtrl, nAssigned, STATUS_COLUMN, sz);

            if (pDIPropStr)
                delete (pDIPropStr);
        }

      // Increment the array counter!
      nAssigned++;
   }

   return TRUE;
}

#endif
*/

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:  SetActive ( HWND hDlg )   
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
BOOL SetActive(HWND hDlg)
{
    // restore selection focus to nItemSelected
    SetListCtrlItemFocus(hListCtrl, (BYTE)iItem);

    BYTE i = (BYTE)::SendMessage(hListCtrl, LVM_GETITEMCOUNT, 0, 0);

    // Acquire All Devices that are Attached!!!
    char nIndex;

    while( i-- )
    {
        // get joystick config of item
        nIndex = (char)GetItemData(hListCtrl, i);

        if( pAssigned[nIndex]->nStatus & JOY_US_PRESENT )
            pAssigned[nIndex]->fnDeviceInterface->Acquire();
    }

    // create timer
    SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);

    UpdateButtonState( hDlg );

    return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    MsgSubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// PARAMETERS:  HWND   hWnd
//             UINT   uMsg
//             WPARAM wParam
//             LPARAM lParam
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI MsgSubClassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Only do this if you are ON THIS PAGE!
    if( nFlags & ON_PAGE )
    {
        if( uMsg == JoyCfgChangedMsg )
        {
            if( !(nFlags & BLOCK_UPDATE) )
            {
                // kill status timer
                KillTimer(hWnd, ID_MYTIMER);
                nFlags |= UPDATE_ALL;
                ClearArrays();
                pDIJoyConfig->EnumTypes((LPDIJOYTYPECALLBACK)DIEnumJoyTypeProc, NULL);
                UpdateListCtrl(hWnd);
                SetActive(hWnd);
            }
        }
    }

    return(BOOL)CallWindowProc(fpMainWindowProc, hWnd, uMsg, wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    Error ( short nTitleID, short nMsgID )
//
// PARAMETERS:  nTitleID    - Resource ID for Message Title
//                  nMsgID  - Resource ID for Message
//
// PURPOSE:     Prompt user when error occurs
//
// RETURN:      TRUE
///////////////////////////////////////////////////////////////////////////////
void Error(short nTitleID, short nMsgID)
{
    LPTSTR lptTitle = new TCHAR[STR_LEN_64];
    ASSERT (lptTitle);

    if( LoadString(ghInstance, nTitleID, lptTitle, STR_LEN_64) )
    {
        LPTSTR lptMsg = new TCHAR[MAX_STR_LEN];
        ASSERT (lptMsg);

        if( LoadString(ghInstance, nMsgID, lptMsg, MAX_STR_LEN) )
            MessageBox(NULL, lptMsg, lptTitle, MB_ICONHAND | MB_OK | MB_APPLMODAL);

        if( lptMsg )
            delete[] (lptMsg);
    }

    if( lptTitle )
        delete[] (lptTitle);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    MoveOK ( HWND  hParentWnd )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void MoveOK(HWND hParentWnd)
{
    // Hide the Cancel and move the OK...
    HWND hCtrl = GetDlgItem(hParentWnd, IDCANCEL);

    // if there is no IDCANCEL, we've been here before!
    if( hCtrl )
    {
        RECT rc;
        GetWindowRect(hCtrl, &rc);

        DestroyWindow(hCtrl);

        //POINT pt = {rc.left, rc.top};

        //ScreenToClient(hParentWnd, &pt);

        // This should take care of Mirroring and work for normal windows
        MapWindowPoints(NULL, hParentWnd, (LPPOINT)&rc, 2);

        hCtrl = GetDlgItem(hParentWnd, IDOK);
        ASSERT(hCtrl);

        //SetWindowPos(hCtrl, NULL, pt.x, pt.y, NULL, NULL, SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(hCtrl, NULL, rc.left, rc.top, NULL, NULL, SWP_NOSIZE | SWP_NOZORDER);

        LPTSTR lpszDone = new TCHAR[12];
        ASSERT (lpszDone);

        // Used to be IDS_DONE, but we changed it from DONE to OK
        VERIFY(LoadString(ghInstance, IDS_GEN_STATUS_OK, lpszDone, 12));
        ::SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)lpszDone);

        if( lpszDone )
            delete[] (lpszDone);
    }
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    UpdateButtonState ( HWND hDlg )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void UpdateButtonState( HWND hDlg )
{
    PostDlgItemEnableWindow(hDlg, IDC_BTN_REMOVE,      (BOOL)nAssigned);
    PostDlgItemEnableWindow(hDlg, IDC_BTN_PROPERTIES, (BOOL)nAssigned);
}

#ifdef WINNT
///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    RunWDMJoy ( void )
//
// PURPOSE:     Run wdmjoy.inf to install 
//                       
///////////////////////////////////////////////////////////////////////////////
void RunWDMJOY( void )
{
    //Check if we have already placed the first value
    //HKLM,SYSTEM\CurrentControlSet\Control\MediaProperties\PrivateProperties\Joystick\OEM\VID_045E&PID_01F0
    HKEY hKey;

    long lTest = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REGSTR_PATH_JOYOEM TEXT("\\VID_045E&PID_01F0"),
                    0,
                    KEY_READ,
                    &hKey);
    if (lTest == ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return;
    }


    LPTSTR lpszWDMJoy = new (TCHAR[STR_LEN_64]);
    ASSERT (lpszWDMJoy);

    // Check to see if the file is present
    WIN32_FIND_DATA findData;
    
    BYTE nLen = (BYTE)GetWindowsDirectory(lpszWDMJoy, STR_LEN_64);
    VERIFY(LoadString(ghInstance, IDS_WDMJOY_INF, &lpszWDMJoy[nLen], STR_LEN_64-nLen));

    HANDLE hFind = FindFirstFile(lpszWDMJoy, &findData);

    // If you've found one... run it!
    if( hFind != INVALID_HANDLE_VALUE )
    {
        LPTSTR lpStr = new (TCHAR[MAX_STR_LEN]);
        ASSERT (lpStr);

        // Copy the Windows directory to the buffer!
        _tcsncpy(lpStr, lpszWDMJoy, nLen+1);

        if( LoadString(ghInstance, IDS_WDMJOY, &lpStr[nLen], MAX_STR_LEN-nLen) )
        {
            // Put IDS_WDMJOY_INF on the end of the string!
            _tcscpy(&lpStr[lstrlen(lpStr)], lpszWDMJoy);

            LPSTARTUPINFO psi = new (STARTUPINFO);
            ASSERT (psi);

            ZeroMemory(psi, sizeof(STARTUPINFO));

            psi->cb = sizeof(STARTUPINFO);

            LPPROCESS_INFORMATION ppi = new (PROCESS_INFORMATION);
            ASSERT (ppi);

            ZeroMemory(ppi, sizeof(PROCESS_INFORMATION));

            if( CreateProcess(0, lpStr, 0, 0, 0, 0, 0, 0, psi, ppi) )
            {
                CloseHandle(ppi->hThread);
                CloseHandle(ppi->hProcess);
            }
#ifdef _DEBUG
            else OutputDebugString(TEXT("JOY.CPL: CPANEL.CPP: RunWDMJoy: CreateProcess Failed!\n"));
#endif

            if( ppi )
                delete (ppi);

            if( psi )
                delete (psi);
        }

        if( lpStr )
            delete[] (lpStr);
    }

    FindClose(hFind);

    if( lpszWDMJoy )
        delete[] (lpszWDMJoy);
}
#endif

#ifdef _UNICODE
///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    RegisterForDevChange ( HWND hDlg, PVOID *hNoditfyDevNode )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void RegisterForDevChange(HWND hDlg, PVOID *hNotifyDevNode)
{
    DEV_BROADCAST_DEVICEINTERFACE *pFilterData = new (DEV_BROADCAST_DEVICEINTERFACE);
    ASSERT (pFilterData);

    ZeroMemory(pFilterData, sizeof(DEV_BROADCAST_DEVICEINTERFACE));

    pFilterData->dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    pFilterData->dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    pFilterData->dbcc_classguid  = GUID_CLASS_INPUT; 

    *hNotifyDevNode = RegisterDeviceNotification(hDlg, pFilterData, DEVICE_NOTIFY_WINDOW_HANDLE);

    if( pFilterData )
        delete (pFilterData);
}
#endif


// BEGINNING OF LIST CONTROL FUNCTIONS!

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SetListCtrlItemFocus ( HWND hCtrl, BYTE nItem )
//
// PARAMETERS:  HWND hCtrl - Handle of ListControl to recieve the message
//                  BYTE nItem - Item to set focus to
//
// PURPOSE:     Set focus to item in list control
//
// RETURN:      NONE
///////////////////////////////////////////////////////////////////////////////
void SetListCtrlItemFocus ( HWND hCtrl, BYTE nItem )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    plvItem->lParam       = plvItem->iSubItem = plvItem->iImage = 
                            plvItem->cchTextMax = plvItem->iIndent  = 0;

    plvItem->mask         = LVIF_STATE;
    plvItem->iItem    = nItem;
    plvItem->state    = 
    plvItem->stateMask  = LVIS_FOCUSED | LVIS_SELECTED;
    plvItem->pszText      = NULL;

    ::SendMessage(hCtrl, LVM_SETITEM, 0, (LPARAM)(const LPLVITEM)plvItem);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    GetItemData(HWND hCtrl, BYTE nItem )
//
// PARAMETERS:  HWND hCtrl - Handle of ListControl to recieve the message
//                  
//                  BYTE nItem - Item to retrieve data from
// PURPOSE:     Retrieve the lower char of the item's data
//
// RETURN:      Item's data cast to a char
///////////////////////////////////////////////////////////////////////////////
DWORD GetItemData(HWND hCtrl, BYTE nItem )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    ZeroMemory(plvItem, sizeof(LVITEM));

    plvItem->mask  = LVIF_PARAM;
    plvItem->iItem = nItem;

    VERIFY(::SendMessage(hCtrl, LVM_GETITEM, 0, (LPARAM)(LPLVITEM)plvItem));

    return(DWORD)plvItem->lParam;
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SetItemData(HWND hCtrl, BYTE nItem, DWORD dwFlag )
//
// PARAMETERS:  HWND hCtrl   - Handle of ListControl to recieve the message
//                  BYTE nItem   - Item to send data to
//                  DWORD dwFlag - DWORD to send to nItem
// PURPOSE:     Set the extra memory associated with nItem to dwFlag
//
// RETURN:      TRUE if Successful, FALSE otherwise
///////////////////////////////////////////////////////////////////////////////
BOOL  SetItemData(HWND hCtrl, BYTE nItem, DWORD dwFlag )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    ZeroMemory(plvItem, sizeof(LVITEM));

    plvItem->mask   = LVIF_PARAM;
    plvItem->iItem  = nItem;
    plvItem->lParam = dwFlag;

    return(BOOL)::SendMessage(hCtrl, LVM_SETITEM, 0, (LPARAM)(const LPLVITEM)plvItem);
}



///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    InsertColumn (HWND hCtrl, BYTE nColumn, short nStrID, short nWidth)
//
// PARAMETERS:  HWND hCtrl   - Handle of ListControl to recieve the message
//                  BYTE nColumn - Column to place string
//                  short nStrID -  Resource ID for string 
//                  short nWidth - Width of column
//
// PURPOSE:     Insert a column in a list control
//
// RETURN:      NONE
///////////////////////////////////////////////////////////////////////////////
void InsertColumn (HWND hCtrl, BYTE nColumn, USHORT nStrID, USHORT nWidth)
{
    // Allocate the structure
    LPLVCOLUMN plvColumn = (LPLVCOLUMN)_alloca(sizeof(LVCOLUMN));
    ASSERT (plvColumn);

    ZeroMemory(plvColumn, sizeof(LVCOLUMN));

    plvColumn->mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    plvColumn->fmt  = LVCFMT_CENTER;
    plvColumn->cx    = nWidth;

    plvColumn->pszText = (LPTSTR)_alloca(sizeof(TCHAR[STR_LEN_32]));
    ASSERT (plvColumn->pszText);

    plvColumn->cchTextMax = LoadString(ghInstance, nStrID, plvColumn->pszText, STR_LEN_32);

    ::SendMessage(hCtrl, LVM_INSERTCOLUMN, (WPARAM)(int)nColumn, (LPARAM)(const LPLVCOLUMN)plvColumn);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    SetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpStr)
//
// PARAMETERS:  HWND hCtrl    - Handle of ListControl to recieve the message
//                  BYTE nItem    - Item to set
//                  BYTE nSubItem - SubItem to set
//                  LPTSTR lpStr  - String to set
//
// PURPOSE:     Set list control item text
//
// RETURN:      NONE
///////////////////////////////////////////////////////////////////////////////
void SetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpStr)
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    plvItem->lParam = plvItem->stateMask = plvItem->iImage  = 
                      plvItem->state  = plvItem->iIndent   = 0;

    plvItem->mask         = LVIF_TEXT;
    plvItem->iItem    = nItem;
    plvItem->iSubItem   = nSubItem;
    plvItem->cchTextMax = lstrlen(lpStr);
    plvItem->pszText      = lpStr;

    ::SendMessage(hCtrl, LVM_SETITEM, 0, (LPARAM)(const LPLVITEM)plvItem);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    GetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpszBuff, BYTE nLen )
//
// PARAMETERS:  HWND hCtrl       - Handle of ListControl to recieve the message
//                  BYTE nItem       - Item to retrive text
//                  BYTE nSubItem    - SubItem to retrieve text
//                  LPTSTR lpszBuff - Buffer for retrieved text
//                  BYTE nLen        - Size of buffer
//
// PURPOSE:     Retrieve text from a list control
//
// RETURN:      length of retrieved string!
///////////////////////////////////////////////////////////////////////////////
BYTE GetItemText( HWND hCtrl, BYTE nItem, BYTE nSubItem, LPTSTR lpszBuff, BYTE nLen )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    plvItem->lParam =   plvItem->stateMask = plvItem->iImage  =  
                        plvItem->state  = plvItem->iIndent   = 0;

    plvItem->mask         = LVIF_TEXT;
    plvItem->iItem    = nItem;
    plvItem->iSubItem   = nSubItem;
    plvItem->pszText      = lpszBuff;
    plvItem->cchTextMax = nLen;

    return(BYTE)::SendMessage(hCtrl, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)(const LPLVITEM)plvItem);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    InsertItem(HWND hCtrl, LPTSTR lpszBuff )
//
// PARAMETERS:  HWND hCtrl       - Handle of ListControl to recieve the message
//                  BYTE nItem       - Item to retrive text
//                  LPTSTR lpszBuff - Text to be inserted
//
// PURPOSE:     Retrieve text from a list control
//
// RETURN:      NONE              BYTE nItem,
///////////////////////////////////////////////////////////////////////////////
BYTE InsertItem( HWND hCtrl, LPTSTR lpszBuff, BYTE nItem )
{
    LPLVITEM plvItem = (LPLVITEM)_alloca(sizeof(LVITEM));
    ASSERT (plvItem);

    plvItem->state = plvItem->stateMask = plvItem->iImage   = 
                     plvItem->iItem = plvItem->iIndent   = plvItem->iSubItem = 0;

    plvItem->mask         = LVIF_TEXT | LVIF_PARAM;
    plvItem->pszText      = lpszBuff;
    plvItem->cchTextMax = lstrlen(lpszBuff);
    plvItem->lParam       = ID_NONE | nItem;

    return(BYTE)::SendMessage(hCtrl, LVM_INSERTITEM, (WPARAM)0, (LPARAM)(const LPLVITEM)plvItem);
}


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    Launch(HWND hWnd, BYTE nJoy, BYTE startpage)
//
// PARAMETERS:  HWND hWnd - Handle to Dialog
//                  BYTE nJoy - Index into pAssigned global array of assigned devices
//                  BYTE nStartPage - Page to show first
//
// PURPOSE:     
//           
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
HRESULT Launch(HWND hWnd, PJOY pJoy, BYTE nStartPage)
{
    HRESULT hresRet;
    
    ASSERT (::IsWindow(hWnd));

    if( nStartPage > MAX_PAGES )
        return(DIGCERR_STARTPAGETOOLARGE);

    LPCDIGAMECNTRLPROPSHEET fnInterface;    

/*  
#ifdef _UNICODE
    LPTSTR lpszWin32 = new (TCHAR[STR_LEN_64]);
    ASSERT (lpszWin32);

    _tcscpy(&lpszWin32[GetSystemDirectory(lpszWin32, STR_LEN_64)], TEXT("\\OLE32.DLL"));
                                                //TEXT("OLE32.DLL")
    HINSTANCE hOleInst = LoadLibrary(lpszWin32);

    if (lpszWin32)
        delete[] (lpszWin32);

    if (!hOleInst)
    {
        return E_NOINTERFACE;
    }
#endif
*/

    // Get the interface pointer if there is one!
    // This reduces the memory footprint of the CPL but takes a bit more time to 
    // launch the property sheet pages!
/*
#ifdef _UNICODE
    fnInterface = HasInterface(pJoy->clsidPropSheet, hOleInst);

    if (!fnInterface)
    {
        // If the propsheet is not mine, try mine!
        if (!IsEqualIID(pJoy->clsidPropSheet, CLSID_LegacyServer))
            fnInterface = HasInterface(CLSID_LegacyServer, hOleInst);
    }
    
    FreeLibrary(hOleInst);
#else
*/
    HRESULT hr;

    //if( SUCCEEDED(hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED| COINIT_SPEED_OVER_MEMORY)) )
    // OLE32 on Win95 does not have CoInitializeEx. 
    if( SUCCEEDED(hr = CoInitialize(NULL)) )
    {
        IClassFactory* ppv_classfactory;

        if( SUCCEEDED(hr = CoGetClassObject(pJoy->clsidPropSheet, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&ppv_classfactory)) )
        {
            VERIFY(SUCCEEDED(ppv_classfactory->CreateInstance(NULL, IID_IDIGameCntrlPropSheet, (LPVOID *)&fnInterface)));

            ppv_classfactory->Release();
        } else {
            fnInterface = 0;
        }
    } else {
        fnInterface = 0;
    }

//#endif

    // By this point, you've tried twice (possibly)...
    // if you don't have an interface by this point... 
    // QUIT!
    if( !fnInterface )
    {
        Error((short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
        return(E_NOINTERFACE);
    }

    // here's where we are sending the property sheet an ID describing the location of the installed device!
    fnInterface->SetID(pJoy->ID);

    LPDIGCSHEETINFO pServerSheet;

    // Get the property sheet info from the server
    if( FAILED(fnInterface->GetSheetInfo(&pServerSheet)) )
    {
        TRACE(TEXT("JOY.CPL: CPANEL.CPP: Launch: GetSheetInfo Failed!\n"));
        return(E_FAIL);
    }

    // test to make sure the number of pages is reasonable
    if( pServerSheet->nNumPages == 0 )
        return(DIGCERR_NUMPAGESZERO);
    else if( (pServerSheet->nNumPages > MAX_PAGES) ||   (pServerSheet->nNumPages < nStartPage) )
        return(DIGCERR_NUMPAGESTOOLARGE);

    LPDIGCPAGEINFO   pServerPage;

    // step 2 : get the information for all the pages from the server
    if( FAILED(fnInterface->GetPageInfo(&pServerPage)) )
    {
        TRACE(TEXT("JOY.CPL: CPANEL.CPP: Launch: GetPageInfo Failed!\n"));
        return(E_FAIL);
    }


    // Allocate Memory for the pages!
    HPROPSHEETPAGE *pPages = new (HPROPSHEETPAGE[pServerSheet->nNumPages]);
    ASSERT (pPages);

    ZeroMemory(pPages, sizeof(HPROPSHEETPAGE)*pServerSheet->nNumPages);

    if( !pPages ) return(E_OUTOFMEMORY);

    // Allocate Memory for the header!
    LPPROPSHEETHEADER   ppsh = new (PROPSHEETHEADER);
    ASSERT (ppsh);

    ZeroMemory(ppsh, sizeof(PROPSHEETHEADER));

    ppsh->dwSize        = sizeof(PROPSHEETHEADER);
    ppsh->hwndParent    = hWnd;
    ppsh->hInstance = pServerPage[0].hInstance;

    if( pServerSheet->fSheetIconFlag )
    {
        if( pServerSheet->lpwszSheetIcon )
        {
            // check to see if you are an INT or a WSTR
            if( HIWORD((INT_PTR)pServerSheet->lpwszSheetIcon) )
            {
                // You are a string!
#ifdef _UNICODE        
                ppsh->pszIcon   = pServerSheet->lpwszSheetIcon;
#else
                USES_CONVERSION;
                ppsh->pszIcon   = W2A(pServerSheet->lpwszSheetIcon);
#endif
            } else ppsh->pszIcon = (LPCTSTR)(pServerSheet->lpwszSheetIcon);

            ppsh->dwFlags =    PSH_USEICONID;
        } else return(DIGCERR_NOICON);
    }

    // do we have a sheet caption ?
    if( pServerSheet->lpwszSheetCaption )
    {
#ifdef _UNICODE
        ppsh->pszCaption    = pServerSheet->lpwszSheetCaption;
#else
        USES_CONVERSION;
        ppsh->pszCaption    = W2A(pServerSheet->lpwszSheetCaption);
#endif
        ppsh->dwFlags |= PSH_PROPTITLE;
    }

    ppsh->nPages        = pServerSheet->nNumPages;  
    ppsh->nStartPage    = nStartPage;

    // set the property pages inofrmation into the header
    ppsh->phpage = pPages;


    // OK, sheet stuff is done... now, time to do the pages!

#ifndef _UNICODE
    USES_CONVERSION;
#endif

    LPPROPSHEETPAGE lpPropPage = new (PROPSHEETPAGE);
    ASSERT(lpPropPage);

    ZeroMemory(lpPropPage, sizeof(PROPSHEETPAGE));

    lpPropPage->dwSize    = sizeof(PROPSHEETPAGE);

    //   3.2 Now proceed to fill up each page
    BYTE nIndex = 0;
    do
    {
        // Assign the things that there are not questionable
        lpPropPage->lParam   = pServerPage[nIndex].lParam;
        lpPropPage->hInstance = pServerPage[nIndex].hInstance;

        // Add the title...
        if( pServerPage[nIndex].lpwszPageTitle )
        {
            lpPropPage->dwFlags = PSP_USETITLE; 

            // Check to see if you are a String!!!
            if( HIWORD((INT_PTR)pServerPage[nIndex].lpwszPageTitle) )
            {
#ifdef _UNICODE
                lpPropPage->pszTitle = pServerPage[nIndex].lpwszPageTitle;
#else
                lpPropPage->pszTitle = W2A(pServerPage[nIndex].lpwszPageTitle);
#endif
            } else lpPropPage->pszTitle = (LPTSTR)pServerPage[nIndex].lpwszPageTitle;
        } else lpPropPage->pszTitle = NULL;

        // if icon is required go ahead and add it.
        if( pServerPage[nIndex].fIconFlag )
        {
            lpPropPage->dwFlags |= PSP_USEICONID;

            // Check to see if you are an INT or a String!
            if( HIWORD((INT_PTR)pServerPage[nIndex].lpwszPageIcon) )
            {
                // You're a string!!!
#ifdef _UNICODE
                lpPropPage->pszIcon = pServerPage[nIndex].lpwszPageIcon;
#else
                lpPropPage->pszIcon = W2A(pServerPage[nIndex].lpwszPageIcon);
#endif
            } else lpPropPage->pszIcon = (LPCTSTR)(pServerPage[nIndex].lpwszPageIcon);

        }

        // if a pre - post processing call back proc is required go ahead and add it
        if( pServerPage[nIndex].fProcFlag )
        {
            if( pServerPage[nIndex].fpPrePostProc )
            {
                lpPropPage->dwFlags |= PSP_USECALLBACK;
                lpPropPage->pfnCallback = (LPFNPSPCALLBACK) pServerPage[nIndex].fpPrePostProc;
            } else return(DIGCERR_NOPREPOSTPROC);
        }

        // and the essential "dialog" proc
        if( pServerPage[nIndex].fpPageProc )
            lpPropPage->pfnDlgProc = pServerPage[nIndex].fpPageProc;
        else return(DIGCERR_NODLGPROC);


        // Assign the Dialog Template!
        if( HIWORD((INT_PTR)pServerPage[nIndex].lpwszTemplate) )
        {
#ifdef _UNICODE
            lpPropPage->pszTemplate = pServerPage[nIndex].lpwszTemplate;
#else
            lpPropPage->pszTemplate = W2A(pServerPage[nIndex].lpwszTemplate);
#endif
        } else lpPropPage->pszTemplate = (LPTSTR)pServerPage[nIndex].lpwszTemplate;

        pPages[nIndex++] = CreatePropertySheetPage(lpPropPage);
    }   while( nIndex < pServerSheet->nNumPages );

    if( lpPropPage )
        delete (lpPropPage);

    // step 5 : launch modal property sheet dialog
    hresRet = (HRESULT)PropertySheet(ppsh);

    if( pPages )
        delete[] (pPages);

    if( ppsh )
        delete (ppsh);

    if( fnInterface )
        fnInterface->Release();

    CoFreeUnusedLibraries();  //to free gcdef.dll now

//#ifndef _UNICODE
    // Let COM go... on Memphis!
    CoUninitialize();

    
    if( hresRet )
    {
        switch( hresRet )
        {
        // In the event that the user wants to reboot...
        case ID_PSREBOOTSYSTEM:
        case ID_PSRESTARTWINDOWS:
#ifdef _DEBUG
            TRACE(TEXT("JOY.CPL: PropertySheet returned a REBOOT request!\n"));
#endif
            ExitWindowsEx(EWX_REBOOT, NULL);
            break;
        }
    } else {
    	::PostMessage(hWnd, WM_COMMAND, (WPARAM)IDC_BTN_REFRESH, 0);
    }

//#endif

    // step 7 : return success / failure code back to the caller
    return(hresRet);
}

/*
#ifdef _UNICODE
//////////////////////////////////////////////////////////////////////
// LPCDIGAMECNTRLPROPSHEET HasInterface(REFCLSID refCLSID, HINSTANCE hOleInst)
// Purpose: Tests for existance of rrid in refCLSID
LPCDIGAMECNTRLPROPSHEET HasInterface(REFCLSID refCLSID, HINSTANCE hOleInst)
{
    typedef HRESULT (STDAPICALLTYPE * LPFNCOGETCLASSOBJECT)(REFCLSID, DWORD, COSERVERINFO *, REFIID, LPVOID *);

    LPFNCOGETCLASSOBJECT fpCoGetClassObject = (LPFNCOGETCLASSOBJECT)GetProcAddress(hOleInst, "CoGetClassObject");

    IClassFactory* ppv_classfactory;
    LPCDIGAMECNTRLPROPSHEET fnInterface = 0;

    if(SUCCEEDED(fpCoGetClassObject( refCLSID, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&ppv_classfactory)))
    {
        if(SUCCEEDED(ppv_classfactory->CreateInstance(NULL, IID_IDIGameCntrlPropSheet, (LPVOID *)&fnInterface)))
        {
            ppv_classfactory->Release();
        }
        else
        {
#ifdef _DEBUG
        OutputDebugString(TEXT("CPANEL.cpp: CreateInstance Failed!\n"));
#endif 
            // make sure the pointer is nulled
            fnInterface = 0;

            ppv_classfactory->Release();
        }
    }
    else 
#ifdef _DEBUG
   else OutputDebugString(TEXT("CPANEL.cpp: LoadServerInterface Failed!\n"));
#endif
    return fnInterface; 
}
#endif // _UNICODE
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\creg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.h
 *  Content:	definition of the CRegistry class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/18/99		rodtoll	Added Register/UnRegister that can be used to 
 *						allow COM objects to register themselves.
 * 08/25/99		rodtoll	Updated to provide read/write of binary (blob) data
 * 10/07/99		rodtoll	Updated to work in Unicode
 * 10/27/99		pnewson	added Open() call that takes a GUID
 *
 ***************************************************************************/

#ifndef __CREGISTRY_H
#define __CREGISTRY_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

// Useful definition
#define MAX_REGISTRY_STRING_SIZE		_MAX_PATH+1

// CRegistry
//
// This class handles reading/writing to the windows registry.  Each instance
// of the CRegistry class is attached to a single registry handle, which is
// an open handle to a point in the registry tree.
//
class CRegistry 
{

public:

	CRegistry();
	CRegistry( const CRegistry &registry );
	CRegistry( const HKEY branch, LPWSTR pathName, BOOL create = TRUE );

	~CRegistry();

    BOOL        EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );

	BOOL		Open( const HKEY branch, const LPCWSTR pathName, BOOL create = TRUE );
	BOOL		Open( const HKEY branch, const GUID* lpguid, BOOL create = TRUE );
	BOOL		Close();

	BOOL		IsOpen()	{ return m_isOpen;	};

	BOOL		DeleteSubKey( LPCWSTR keyName );

    BOOL        ReadGUID( LPCWSTR keyName, GUID &guid );
    BOOL        WriteGUID( LPCWSTR keyName, const GUID &guid );

	BOOL		WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue );
	BOOL		ReadString( LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength );

	BOOL		WriteDWORD( LPCWSTR keyName, DWORD value );
	BOOL		ReadDWORD( LPCWSTR keyName, DWORD &result );

	BOOL		WriteBOOL( LPCWSTR keyName, BOOL value );
	BOOL		ReadBOOL( LPCWSTR keyName, BOOL &result );

	BOOL		ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize );
	BOOL		WriteBlob( LPCWSTR keyName, LPBYTE lpbBuffer, DWORD dwSize );

	static BOOL	Register( LPCWSTR lpszProgID, LPCWSTR lpszDesc, LPCWSTR lpszProgName, GUID guidCLSID, LPCWSTR lpszVerIndProgID );
	static BOOL UnRegister( GUID guidCLSID );

	// Data access functions
	operator	HKEY() const		{ return m_regHandle; };
	HKEY		GetBaseHandle() const { return m_baseHandle; };
	HKEY		GetHandle() const { return m_regHandle; };

protected:

	BOOL	m_isOpen;		// BOOL indicating if the object is open
	HKEY	m_regHandle;	// Handle to the registry which is represented by this object
	HKEY	m_baseHandle;	// Handle to the root of the part of the registry
							// this object is in.  E.g. HKEY_LOCAL_MACHINE
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\creg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.cpp
 *  Content:	
 *			This module contains the implementation of the CRegistry class.
 *			For a class description, see creg.h
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/18/99		rodtoll	Added Register/UnRegister that can be used to 
 *						allow COM objects to register themselves. 
 * 08/25/99		rodtoll	Updated to provide read/write of binary (blob) data 
 * 10/05/99		rodtoll	Added DPF_MODNAMEs     
 * 10/07/99		rodtoll	Updated to work in Unicode 
 * 10/08/99		rodtoll	Fixes to DeleteKey / Reg/UnReg for Win9X
 * 10/15/99		rodtoll	Plugged some memory leaks
 * 10/27/99		pnewson	added Open() call that takes a GUID
 * 03/07/2001           rodtoll WINBUG #228288 - PREFIX bug
 ***************************************************************************/

#include "stdafx.h"
#include "creg.h"
#include "dndbg.h"
//#include "OSInd.h"
#include "dvosal.h"
#include "guidutil.h"

#define MODULE_ID   CREGISTRY

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Constructor
//
// This is the default constructor for the registry class.  It 
// is used to construct a registry object which has not yet
// opened a handle to the registry.  Open must be called before
// this object can be used.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::CRegistry( ): m_isOpen(FALSE)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Copy Constructor
//
// This is the copy constructor for the class which attempts to
// open a new registry handle at the same point in the registry
// as the registry parameter.  You must check the IsOpen function
// to see if the object was succesfully initialized.
//
// Parameters:
// const CRegistry &registry - The registry object to set this
//                             object to
//
// Returns:
// N/A
//
/*
CRegistry::CRegistry( const CRegistry &registry ): m_isOpen(FALSE) 
{
	Open( registry.GetBaseHandle(), FALSE );
}
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Constructor
//
// This constructor attempts to open a registry connection using
// the given parameters.  This is equivalent to calling the default
// constructor and then Open with the equivalent parameters.
//
// After using this constructor you should call IsOpen to see if
// the open succeeded.
//
// Parameters:
// HKEY branch - Identifies the branch of the registry to open
//               a connect to.  E.g. HKEY_LOCAL_MACHINE
//               This can also be an HKEY which points to another
//               open portion of the registry
// const TCHAR *pathName - A string specifiying the registry path
//                        to open within the key.  NO leading
//                        slash is required and path is relative
//                        from the patch represented by the branch
//                        parameter.
// BOOL create - Set to TRUE to create the given path if it doesn't
//               exist, FALSE otherwise.
//
// Returns:
// N/A
//
CRegistry::CRegistry( HKEY branch, LPWSTR pathName, BOOL create ): m_isOpen(FALSE) {

	Open( branch, pathName, create );
}

// CRegistry Destructor
//
// This is the destructor for the class, and will close the connection
// to the registry if this object has one open.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::~CRegistry() {

	if( m_isOpen ) {
		Close();
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteSubKey"
// DeleteSubKey
//
// This function causes the key specified by the keyname parameter
// to be deleted from the point in the registry this object is rooted
// at, if the key exists.  If the object does not have an open connection
// to the registry, or the keyName is not specified
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const LPCWSTR keyName ) {

	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG	retValue;
	
	if( OSAL_IsUnicodePlatform() )
	{
		retValue = RegDeleteKeyW( m_regHandle, keyName );
	}
	else
	{
		LPSTR lpstrKeyName;

		if( FAILED( OSAL_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
		{
			return FALSE;
		}
		else
		{
			retValue = RegDeleteKeyA( m_regHandle, lpstrKeyName );

			delete [] lpstrKeyName;
		}
	}

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const TCHAR *path - The path relative to the root specified by 
//                    branch where the registry connection will
//                    be opened.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const LPCWSTR pathName, BOOL create ) {

	DWORD	dwResult;	// Temp used in call to RegXXXX
	LONG	result;		// used to store results

	DNASSERT( pathName != NULL );
    
    // Prefix found this. Ref Manbugs 29337
    // There are some code paths where the pathName can legitimately be NULL,
    // returning FALSE indicates a failure to open the registry key.
    if( pathName == NULL )
    {
        return FALSE;
    }

	// If there is an open connection, close it.
	if( m_isOpen ) {
		Close();
	}

	if( OSAL_IsUnicodePlatform() )
	{
		// Create or open the key based on create parameter
		if( create ) {
			result = RegCreateKeyExW( branch, pathName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
				                     NULL, &m_regHandle, &dwResult );
		} else {
			result = RegOpenKeyExW( branch, pathName, 0, KEY_ALL_ACCESS, &m_regHandle );
		}
	}
	else
	{
		LPSTR lpszKeyName;

		if( OSAL_AllocAndConvertToANSI( &lpszKeyName, pathName ) == S_OK )
		{
			if( create ) {
				result = RegCreateKeyExA( branch, lpszKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
					                     NULL, &m_regHandle, &dwResult );
			} else {
				result = RegOpenKeyExA( branch, lpszKeyName, 0, KEY_ALL_ACCESS, &m_regHandle );
			}

			delete [] lpszKeyName;
		}
		else
		{
			return FALSE;
		}
	}

	// If succesful, initialize object, otherwise set it to 
	// not open state.
	if( result == ERROR_SUCCESS ) {
		m_isOpen	 = TRUE;
		m_baseHandle = branch;
		return TRUE;

	} else {
		m_isOpen = FALSE;
		return FALSE;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// In this version of the function, the path is specified as
// a guid instead of a string. The function will attempt to open
// a key with a name in the form "{CB4961DB-D2FA-43f3-942A-991D9294DDBB}"
// that corresponds to the guid as you would expect.
// 
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const LPGUID lpguid - The path relative to the root specified by 
//                    branch where the registry connection will
//                    be opened. See comment above.
// BOOL create - Settings this parameter controls how this function
//               handles opens on paths which don't exist.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const GUID* lpguid, BOOL create )
{
	WCHAR       wszGuidString[GUID_STRING_LEN];
	HRESULT     hr;
	
	DNASSERT( lpguid != NULL );

	// If there is an open connection, close it.
	if( m_isOpen ) {
		Close();
	}

	// convert the guid to a string
	hr = DVStringFromGUID(lpguid, wszGuidString, GUID_STRING_LEN);
	if (FAILED(hr))
	{
		DPF(DVF_ERRORLEVEL, "DVStringFromGUID failed");
		return FALSE;
	}

	return Open(branch, wszGuidString, create);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Close"
// Close
//
// This function will close an open connection to the registry
// if this object has one.  Otherwise it does nothing.
//
// Parameters:
// N/A
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.  If the object
//        is not open it will return TRUE.
//
BOOL CRegistry::Close() {

	LONG retValue;

	if( m_isOpen ) {
		retValue = RegCloseKey( m_regHandle );
        if( retValue == ERROR_SUCCESS )
        {
            m_isOpen = FALSE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
	} else {
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumKeys"
// EnumKeys
//
// This function can be used to enumerate the keys at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the keys you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// BFC_STRING &name - The current key in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or 
//                 ended at which case this parameter won't be touched.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
	if( OSAL_IsUnicodePlatform() )
	{
	    wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	    DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	    FILETIME tmpTime;

	    if( RegEnumKeyExW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	    {
	        return FALSE;
	    }
	    else
	    {
	    	if( bufferSize+1 > *lpdwStringLen  )
	    	{
	    		*lpdwStringLen = bufferSize+1;
	    		return FALSE;
	    	}

	    	lstrcpyW( lpwStrName, buffer );

			*lpdwStringLen = bufferSize+1;
	    	
	        return TRUE;
	    }	
	}
	else
	{
	    char buffer[MAX_REGISTRY_STRING_SIZE];
	    DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	    FILETIME tmpTime;

	    if( RegEnumKeyExA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	    {
	        return FALSE;
	    }
	    else
	    {
	    	if( bufferSize+1 > *lpdwStringLen )
	    	{
	    		*lpdwStringLen = bufferSize+1;
	    		return FALSE;
	    	}

	    	if( OSAL_AnsiToWide( lpwStrName, buffer, *lpdwStringLen ) == 0 )
	    	{
	    		return FALSE;
	    	}
	    	else
	    	{
				*lpdwStringLen = bufferSize+1;
	    	    return TRUE;
	    	}
	    }	
		

    }
}


// This comment documents ALL of the Read<Data Type> functions which
// follow.
//
// CRegistry Read<Data Type> Functions
//
// The set of ReadXXXXX functions for the CRegistry class are 
// responsible for reading <data type> type data from the registry.
// The object must have an open connection to the registry before 
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.  
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to read
// <datatype> & - A reference to the specific data type where
//				  the data will be placed on a succesful read.
//                This parameter will be unaffected if the read
//                fails.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//


// This comment documents ALL of the Write<Data Type> functions which
// follow.
//
// CRegistry Write<Data Type> Functions
//
// The set of Write<Data Type> functions for the CRegistry class are 
// responsible for writing <data type> type data to the registry.
// The object must have an open connection to the registry before 
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.  
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to write
// <datatype> & - A reference to the specific data type which
//                contains the data to be written to the registry.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteString"
// WriteString
//
// Writes Strings's to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue ) 
{

	LONG		retValue;
	
	// Found by PREFIX: Millen Bug #129154, ManBugs:29338
    // lpwstrValue could conceivably be NULL and the  
    if( keyName == NULL || !IsOpen() || lpwstrValue == NULL ) return FALSE;

	if( OSAL_IsUnicodePlatform() )
	{
		retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) lpwstrValue, (lstrlenW( lpwstrValue )+1)*sizeof(wchar_t) );	
	}
	else
	{
		LPSTR lpstrKeyName;
		LPSTR lpstrValue;
		
		if( FAILED( OSAL_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
		{
			return FALSE;
		}

		if( FAILED( OSAL_AllocAndConvertToANSI( &lpstrValue, lpwstrValue ) ) )
		{
			delete [] lpstrKeyName;
			return FALSE;
		}
		
		retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrValue, lstrlenA( lpstrValue )+1 );

		delete [] lpstrKeyName;
		delete [] lpstrValue;
	}

	return (retValue == ERROR_SUCCESS);

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadString"
// ReadString
//
// Reads CString's from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadString( const LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength )
{
	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpSize;;
	DWORD		tmpType;	

	if( OSAL_IsUnicodePlatform() )
	{
		wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
		tmpSize = MAX_REGISTRY_STRING_SIZE*sizeof(wchar_t);
		
		retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );

		if( retValue != ERROR_SUCCESS )
        {
            return FALSE;
        }

		if( (tmpSize/2) > *lpdwLength )
		{
			*lpdwLength = (tmpSize/2);
			return FALSE;
		}

		lstrcpyW( lpwstrValue, buffer );

		*lpdwLength = (tmpSize/2);

		return TRUE;
	}
	else
	{
		LPSTR lpstrKeyName;
		char buffer[MAX_REGISTRY_STRING_SIZE];
		tmpSize = MAX_REGISTRY_STRING_SIZE;

		if( FAILED( OSAL_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
			return FALSE;
			
		retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );

		delete [] lpstrKeyName;

		if( retValue != ERROR_SUCCESS )
        {
                        return FALSE;
        }

		if( tmpSize > *lpdwLength )
		{
			*lpdwLength = tmpSize;
			return FALSE;
		}

		if( OSAL_AnsiToWide( lpwstrValue, buffer, *lpdwLength ) == 0 )
			return FALSE;

		*lpdwLength = tmpSize;	
	}

	if( retValue == ERROR_SUCCESS && tmpType == REG_SZ ) {
		return TRUE;
	} else {
		return FALSE;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteGUID"
// WriteGUID
//
// Writes GUID's to the registry, see block comment above
// for details.  The GUID is written in the format it is usually
// displayed.  (But without the '{''s).
//
BOOL CRegistry::WriteGUID( LPCWSTR keyName, const GUID &guid ) 
{
	LONG retValue;
	WCHAR wszGuidString[GUID_STRING_LEN];
	HRESULT hr;

	hr = DVStringFromGUID(&guid, wszGuidString, GUID_STRING_LEN);
	if (FAILED(hr))
	{
		DPF(DVF_ERRORLEVEL, "DVStringFromGUID failed, code: %i", hr);
		return FALSE;
	}

	if( OSAL_IsUnicodePlatform() )
	{
	    retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) wszGuidString, (lstrlenW( wszGuidString )+1)*sizeof(wchar_t) );
	}
	else
	{
		LPSTR lpstrKeyName;
		LPSTR lpstrKeyValue;

		hr = OSAL_AllocAndConvertToANSI( &lpstrKeyName, keyName );
		if (FAILED(hr))
		{
			DPF(DVF_ERRORLEVEL, "DVStringFromGUID failed, code: %i", hr);
			return FALSE;
		}
		
		hr = OSAL_AllocAndConvertToANSI( &lpstrKeyValue, wszGuidString );
		if (FAILED(hr))
		{
			DPF(DVF_ERRORLEVEL, "DVStringFromGUID failed, code: %i", hr);
		    delete [] lpstrKeyName;
			return FALSE;
		}

	    retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrKeyValue, lstrlenA( lpstrKeyValue )+1);

	    delete [] lpstrKeyName;
	    delete [] lpstrKeyValue;
	}

	if( retValue == ERROR_SUCCESS )
		return TRUE;
	else
		return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadGUID"
// ReadGUID
//
// Reads GUID's from the registry, see block comment above
// for details.  The GUID must be stored in the format written by
// the WriteGUID function or it will not be read correctly.
//
BOOL CRegistry::ReadGUID( LPCWSTR keyName, GUID &guid )
{
	wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD		dwLength = MAX_REGISTRY_STRING_SIZE;
    HRESULT hr;

    if( !ReadString( keyName, buffer, &dwLength ) )
    {
        return FALSE;
    }
    else
    {
    	hr = DVGUIDFromString(buffer, &guid);
    	if (FAILED(hr))
    	{
    		DPF(DVF_ERRORLEVEL, "DVGUIDFromString failed, code: %i", hr);
    		return FALSE;
    	}
    	return TRUE;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteDWORD"
// WriteDWORD
//
// Writes DWORDS to the registry, see block comment above
// for details.  
//
BOOL CRegistry::WriteDWORD( LPCWSTR keyName, DWORD value ) {

	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) return FALSE;

	if( OSAL_IsUnicodePlatform() )
	{
		retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );		
	}
	else
	{
		LPSTR lpszKeyName;

		if( FAILED( OSAL_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
			return FALSE;

		retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );

		delete [] lpszKeyName;
	}

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Cregistry::ReadBOOL"
BOOL CRegistry::ReadBOOL( LPCWSTR keyName, BOOL &result )
{
	DWORD tmpResult;

	if( ReadDWORD( keyName, tmpResult ) )
	{
		result = (BOOL) tmpResult;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteBOOL" 
BOOL CRegistry::WriteBOOL( LPCWSTR keyName, BOOL value )
{
	DWORD tmpValue = (DWORD) value;

	return WriteDWORD( keyName, tmpValue );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadDWORD"
// ReadDWORD
//
// Reads DWORDS from the registry, see block comment above
// for details.  
//
BOOL CRegistry::ReadDWORD( LPCWSTR keyName, DWORD &result ) {

	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpValue;
	DWORD		tmpType;
	DWORD		tmpSize;

	tmpSize = sizeof( DWORD );

	if( OSAL_IsUnicodePlatform() )
	{
		retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
	}
	else
	{
		LPSTR lpszKeyName;

		if( FAILED( OSAL_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
			return FALSE;

		retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
		
		delete [] lpszKeyName;
	}

	if( retValue == ERROR_SUCCESS && tmpType == REG_DWORD ) {
		result = tmpValue;
		return TRUE;
	} else {
		return FALSE;
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Register"
BOOL CRegistry::Register( LPCWSTR lpszProgID, const LPCWSTR lpszDesc, const LPCWSTR lpszProgName, GUID guidCLSID, LPCWSTR lpszVerIndProgID )
{
	CRegistry core;

	DNASSERT( lpszDesc != NULL );
	DNASSERT( lpszProgID != NULL );

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[MAX_REGISTRY_STRING_SIZE];
    wchar_t lpszKeyName[_MAX_PATH];

    swprintf( lpszGUID, L"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", guidCLSID.Data1, guidCLSID.Data2, guidCLSID.Data3, 
               guidCLSID.Data4[0], guidCLSID.Data4[1], guidCLSID.Data4[2], guidCLSID.Data4[3],
               guidCLSID.Data4[4], guidCLSID.Data4[5], guidCLSID.Data4[6], guidCLSID.Data4[7] );	

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
    {
    	DPF( DVF_ERRORLEVEL, "Unable to open/create registry key %s", lpszKeyName );
    	return FALSE;
    }

    core.WriteString( L"", lpszDesc );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\InProcServer32 section
    swprintf( lpszKeyName, L"CLSID\\%s\\InProcServer32", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
    {
    	DPF( DVF_ERRORLEVEL, "Unable to open/create registry key %s", lpszKeyName );
    	return FALSE;
    }
    core.WriteString( L"", lpszProgName );
    core.WriteString( L"ThreadingModel", L"Both" );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\VersionIndependentProgID section
    if( lpszVerIndProgID != NULL )
    {
	    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
	    {
	    	DPF( DVF_ERRORLEVEL, "Unable to open/create verind registry key %s", lpszKeyName );
	    	return FALSE;
	    }
    
	    core.WriteString( L"", lpszVerIndProgID );
	    core.Close();
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\ProgID section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
    {
    	DPF( DVF_ERRORLEVEL, "Unable to open/create verind registry key %s", lpszKeyName );
    	return FALSE;
    }

    core.WriteString( L"", lpszProgID );
    core.Close();

	// Write The VersionIND ProgID
	
	if( lpszVerIndProgID != NULL )
	{
		if( !core.Open( HKEY_CLASSES_ROOT, lpszVerIndProgID ) )
		{
			DPF( DVF_ERRORLEVEL, "Unable to open/create reg key %s", lpszVerIndProgID );
		}
		else
		{
			core.WriteString( L"", lpszDesc );
			core.Close();			
		}

		swprintf( lpszKeyName, L"%s\\CLSID", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
		{
			DPF( DVF_ERRORLEVEL, "Unable to open/create reg key %s", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszGUID );
			core.Close();
		}

		swprintf( lpszKeyName, L"%s\\CurVer", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
		{
			DPF( DVF_ERRORLEVEL, "Unable to open/create reg key %s", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszProgID );
			core.Close();
		}		
	}

	if( !core.Open( HKEY_CLASSES_ROOT, lpszProgID ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to open/create reg key %s", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszDesc );
		core.Close();
	}
	
	swprintf( lpszKeyName, L"%s\\CLSID", lpszProgID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to open/create reg key %s", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszGUID );
		core.Close();
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::UnRegister"
BOOL CRegistry::UnRegister( GUID guidCLSID )
{
	CRegistry core, cregClasses, cregSub;

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[MAX_REGISTRY_STRING_SIZE];
    wchar_t lpszKeyName[_MAX_PATH];
    wchar_t szProgID[MAX_REGISTRY_STRING_SIZE];
    wchar_t szVerIndProgID[MAX_REGISTRY_STRING_SIZE];
    DWORD dwSize = MAX_REGISTRY_STRING_SIZE;

    swprintf( lpszGUID, L"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", guidCLSID.Data1, guidCLSID.Data2, guidCLSID.Data3, 
               guidCLSID.Data4[0], guidCLSID.Data4[1], guidCLSID.Data4[2], guidCLSID.Data4[3],
               guidCLSID.Data4[4], guidCLSID.Data4[5], guidCLSID.Data4[6], guidCLSID.Data4[7] );	

	if( !cregClasses.Open( HKEY_CLASSES_ROOT, L"" ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to open HKEY_CLASSES_ROOT" );
		return FALSE;
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to open %s", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;	

    if( core.ReadString( L"", szProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szProgID );
    	
    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPF( DVF_ERRORLEVEL, "Unable to delete %s", lpszKeyName );
    		return FALSE;
    	}
    	
    	if( !cregClasses.DeleteSubKey( szProgID ) )
    	{
    		DPF( DVF_ERRORLEVEL, "Unable to delete HKEY_CLASSES_ROOT/ProgID" );

    		return FALSE;
    	}
    }

	core.Close();

    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to open %s", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;
	
    if( core.ReadString( L"", szVerIndProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPF( DVF_ERRORLEVEL, "Unable to delete %s", lpszKeyName );
    		return FALSE;
    	}

    	swprintf( lpszKeyName, L"%s\\CurVer", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPF( DVF_ERRORLEVEL, "Unable to delete %s", lpszKeyName );
    		return FALSE;
    	}
    	
    	
    	if( !cregClasses.DeleteSubKey( szVerIndProgID ) )
    	{
    		DPF( DVF_ERRORLEVEL, "Unable to delete HKEY_CLASSES_ROOT/%s", szVerIndProgID);

    		return FALSE;
    	}
    }

    core.Close();

	swprintf( lpszKeyName, L"CLSID\\%s\\InprocServer32", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to delete %s", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to delete %s", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to delete %s", lpszKeyName );
		return FALSE;	
	}	

	swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPF( DVF_ERRORLEVEL, "Unable to delete %s", lpszKeyName );
		return FALSE;	
	}

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadBlob"
BOOL CRegistry::ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize )
{
	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpType;

	if( OSAL_IsUnicodePlatform() )
	{
		retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, lpbBuffer, lpdwSize );	
	}
	else
	{
		LPSTR lpszKeyName;
		
		if( FAILED( OSAL_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
			return FALSE;

		retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, lpbBuffer, lpdwSize );

		delete [] lpszKeyName;
	}
	
	if( retValue == ERROR_SUCCESS && tmpType == REG_BINARY ) {
		return TRUE;
	} else {
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteBlob"
BOOL CRegistry::WriteBlob( LPCWSTR keyName, LPBYTE lpbBuffer, DWORD dwSize )
{
	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) return FALSE;

	if( OSAL_IsUnicodePlatform() )
	{
		retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_BINARY, lpbBuffer, dwSize );
	}
	else
	{
		LPSTR lpszKeyName;
		
		if( FAILED( OSAL_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
			return FALSE;

		retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_BINARY, lpbBuffer, dwSize );
		
		delete [] lpszKeyName;	
	}

	return (retValue == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\dbginfo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dbginfo.h
 *  Content:	Include for setting debugging information, 1 copy of
 *              this file should be in each directory for debugging.
 *              It requires the include path to start with the local
 *              directory so other copies don't take precedence.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/14/99		aarono	Created
 * 07/16/99		johnkan	Fixed problem with macro redefinition if DPF_MODNAME was already defined in .Cxx file
 *
 ***************************************************************************/

#ifndef _DBGINFO_H_
#define _DBGINFO_H_

/*
 *  Sets the section in Win.ini that the debug code looks at to get the settings
 */

#undef PROF_SECT
#define PROF_SECT "DirectPlayVoice"

/*
 *  This is the per function name that should be set so that it is easier to
 *  track down the section of the code that is generating a DPF
 */
#ifndef	DPF_MODNAME
#define DPF_MODNAME "UNKNOWN_MODULE"
#endif	// DPF_MODNAME

/*
 *  Sets the module name print in the debug string.  DPF_MODNAME overrides this
 *  string when present in a file.  This name is also used as the key to override
 *  the standard debug value for this module.
 */
#undef DPF_MODULE_NAME
#define DPF_MODULE_NAME "UNKNOWN_MODULE"


/*
 * Use this identifier to define which line in WIN.INI [DirectNet] denotes the
 * debug control string.  This string is typically the default debug value, it
 * is used if there is no overriding string of the from "DPF_MODULE_NAME" =
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DNetDebug"


/*
 * Define this identifier to a DWORD variable in your component if you want to
 * be able to turn debugging of components off and on in your component during
 * a debug session.  This is the variable that holds the mask of the component
 * bits that are ON and you want debug spew for.  You then use DPFSC instead
 * of DPF and have specified DPS_SUBCOMP_BIT then only if that bit is
 * set in the DPF_SUMCOMP_MASK variable will the debug spew be logged or
 * displayed.
 */
//#define DPF_SUBCOMP_MASK

#endif // _DBGINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\guids.cpp ===
// Defines guids  --ddalal 10/13/99

#include <initguid.h>
//#include <AppManAdmin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\dndbg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.h
 *  Content:	debug support functions for DirectNet
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99  aarono    Created
 *	07-16-99  johnkan	Added DEBUG_ONLY, DBG_CASSERT, fixed DPFERR to take an argument
 *  08/31/99  rodtoll	Added DVF_ defines for error levels
 *  09/01/99  rodtoll	Added functions to check valid read/write pointers
 *  11/12/99  pnewson	Added DVF_TRACELEVEL, DPF_ENTER(), DPF_EXIT(), DPFI()
 ***************************************************************************/

#ifndef _DNDBG_H_

#define DVF_ERRORLEVEL		0
#define DVF_WARNINGLEVEL	1
#define DVF_ENTRYLEVEL		2
#define DVF_APIPARAM		3
#define DVF_LOCKS			4
#define DVF_INFOLEVEL		5
#define DVF_STRUCTUREDUMP	6
#define DVF_TRACELEVEL		9

// The Windows NT build process currently defines DBG when it is
// performing a debug build. Key off this to define DEBUG
#if defined(DBG) && !defined(DEBUG)
	#define DEBUG 1
#endif

// each component should have a private dbginfo.h in its source directory
// and should ensure that its source directory is first on the include
// path.
#include "dbginfo.h"

#ifdef __cplusplus
	extern "C" {
#endif	

// DEBUG_BREAK()
#if defined(DEBUG) || defined(DBG)
	#if defined( _WIN32 ) && !defined(WINNT)
		#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
	#else
		#define DEBUG_BREAK()       DebugBreak()
	#endif
#endif
//
// macros used generate compile time messages
//
// you need to use these with #pragma, example
//
//      #pragma TODO(ToddLa, "Fix this later!")
//

// to turn this off, set cl = /DTODO_OFF in your environment variables
#define __TODO(e,m,n)   message(__FILE__ "(" #n ") : TODO: " #e ": " m)
#define _TODO(e,m,n)    __TODO(e,m,n)

#ifdef TODO_OFF
#define TODO(e,m)
#else
#define TODO(e,m)		_TODO(e,m,__LINE__)
#endif

//========================
// Debug Logging support
//========================

/*=============================================================================
 Usage:

 In code, you can use DPF to print to the log or the debug windows of the
 running application.  The format of DPF (debug printf) is as follows:

 DPF(level, string *fmt, arg1, arg2, ...);

 level specifies how important this debug printf is.  The standard convention
 for debug levels is as follows.  This is no way strictly enforced for
 personal use, but by the time the code is checked in, it should be as close
 to this as possible...

  0: Error useful for application developers.
  1: Warning useful for application developers.
  2: API Entered
  3: API parameters, API return values
  4: Driver conversation
  5: Deeper program flow notifications
  6: Dump structures
  9: Detailed program trace

 Note: please use the DVF_... macros defined above instead of raw numbers!

 When printing a critical error, you can use

 DPERR( "String" );

 which will print a string at debug level zero.

 In order to cause the code to stop and break in.  You can use ASSERT() or
 DEBUG_BREAK().  In order for ASSERT to break in, you must have
 BreakOnAssert set in the win.ini file section (see osindep.cpp).

=============================================================================*/

#ifdef DEBUG

extern BOOL IsValidWritePtr( LPVOID lpBuffer, DWORD dwSize );
extern BOOL IsValidReadPtr( LPVOID lpBuffer, DWORD dwSize );
extern void DebugSetLineInfo(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
extern void DebugPrintf(volatile DWORD dwDetail, ...);
extern void DebugPrintfNoLock(volatile DWORD dwDetail, ...);
extern void DebugPrintfInit(void);
extern void DebugPrintfFini(void);
extern void _DNAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
extern void LogPrintf(volatile DWORD dwDetail, ...);
#define DNVALID_WRITEPTR(a,b)	IsValidWritePtr(a,b)
#define DNVALID_READPTR(a,b)	IsValidReadPtr(a,b)
#define DPF			DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
#define DPFERR( a ) DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
#define DPFINIT()	DebugPrintfInit();
#define DPFFINI()   DebugPrintfFini();
#define DNASSERT(condition) if (!(condition)) _DNAssert(__FILE__, __LINE__, #condition)
#if !defined DEBUG_ONLY
#define	DEBUG_ONLY( arg )	arg
#endif
#define DBG_CASSERT( exp )	switch (0) case 0: case exp:

#if defined(INTERNAL_DPF_ENABLED)
#define DPFI DPF
#define DPF_ENTER() DPF(DVF_TRACELEVEL, "Enter");
#define DPF_EXIT() DPF(DVF_TRACELEVEL, "Exit");
#else
#define DPFI()
#define DPF_ENTER()
#define DPF_EXIT()
#endif


#define dprintf(a,b) DebugPrintfNoLock(a,b);

#ifdef DPF_SUBCOMP_MASK
	#define DPFSC if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME),if(DPF_SUBCOMP_MASK & DPF_SUBCOMP_BIT)DebugPrintf
#else
	#define DPFSC DPF
#endif

#define	LOGPF		LogPrintf

#else /* NOT DEBUG */

	#pragma warning(disable:4002)
	#define DPF()
	#define DPFERR()
	#define DPFINIT()
	#define DPFFINI()
	#define DPFSC()
	#define DNASSERT()
	#if !defined DEBUG_ONLY
	#define	DEBUG_ONLY()
	#endif
	#define	DBG_CASSERT()
	#define dprintf()
	#define	LOGPF()
	#define DNVALID_WRITEPTR(a,b)		TRUE
	#define DNVALID_READPTR(a,b)		TRUE
	#define DPF_ENTER()
	#define DPF_EXIT()
	#define DPFI()
	
#endif /* DEBUG */

#define WVSPRINTF wvsprintfA
#define STRLEN   lstrlenA

#define PROF_SECT "DirectPlayVoice"

//========================================
// Memory Allocation Support and Tracking
//========================================

#ifdef __cplusplus
	}	//extern "C"
#endif

#endif /* _DNDBG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\guidutil.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       guidutil.cpp
 *  Content:    Some GUID related utility functions
 *
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#include "guidutil.h"
#include "stdio.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DVStringFromGUID"
HRESULT DVStringFromGUID(const GUID* lpguid, WCHAR* swzBuf, DWORD dwNumChars)
{
	if (dwNumChars < GUID_STRING_LEN)
	{
		return E_FAIL;
	}
	
    swprintf( 
    	swzBuf, 
    	L"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", 
    	lpguid->Data1, 
    	lpguid->Data2, 
    	lpguid->Data3, 
        lpguid->Data4[0], 
        lpguid->Data4[1], 
        lpguid->Data4[2], 
        lpguid->Data4[3],
        lpguid->Data4[4], 
        lpguid->Data4[5], 
        lpguid->Data4[6], 
        lpguid->Data4[7] );
        
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVGUIDFromString"
HRESULT DVGUIDFromString(const WCHAR* wszBuf, GUID* lpguid)
{
    UINT aiTmp[10];

    if( swscanf( wszBuf, L"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}",
                    &lpguid->Data1, 
                    &aiTmp[0], &aiTmp[1], 
                    &aiTmp[2], &aiTmp[3],
                    &aiTmp[4], &aiTmp[5],
                    &aiTmp[6], &aiTmp[7],
                    &aiTmp[8], &aiTmp[9] ) != 11 )
    {
    	ZeroMemory(lpguid, sizeof(GUID));
        return FALSE;
    }
    else
    {
        lpguid->Data2       = (USHORT) aiTmp[0];
        lpguid->Data3       = (USHORT) aiTmp[1];
        lpguid->Data4[0]    = (BYTE) aiTmp[2];
        lpguid->Data4[1]    = (BYTE) aiTmp[3];
        lpguid->Data4[2]    = (BYTE) aiTmp[4];
        lpguid->Data4[3]    = (BYTE) aiTmp[5];
        lpguid->Data4[4]    = (BYTE) aiTmp[6];
        lpguid->Data4[5]    = (BYTE) aiTmp[7];
        lpguid->Data4[6]    = (BYTE) aiTmp[8];
        lpguid->Data4[7]    = (BYTE) aiTmp[9];
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\dvosal.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvosal.h
 *  Content:	
 *			This module the DirectPlayVoice O/S abstraction layer.
 *  		Allows the DLL to run with all strings as Unicode, regardless 
 *			of the platform.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99		rodtoll	Created
 *
 ***************************************************************************/
#ifndef __DVOSAL_H
#define __DVOSAL_H

#include <windows.h>

HRESULT OSAL_Initialize();
HRESULT OSAL_DeInitialize();
BOOL OSAL_IsUnicodePlatform();
BOOL OSAL_CheckIsUnicodePlatform();
HRESULT OSAL_AllocAndConvertToANSI( LPSTR *lpstrAnsiString, LPCWSTR lpwstrUnicodeString );
int OSAL_WideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr);
int OSAL_AnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr);
int OSAL_WideToTChar(LPTSTR lpTStr,LPCWSTR lpWStr,int cchTStr);
int OSAL_TCharToWide(LPWSTR lpWStr,LPCTSTR lpTStr,int cchWStr);

/*
void OSAL_CreateEvent( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName );
void OSAL_CreateSemaphore( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName );
#define OSAL_ReleaseSemaphore( x, y, z ) ReleaseSemaphore( x, y, z )
#define OSAL_CloseHandle( x ) CloseHandle( x )
#define OSAL_SetEvent( x ) SetEvent( x )
void OSAL_sprintf( LPWSTR lpOut, LPWSTR lpFmt, ... );
void OSAL_strcpy( 
void OSAL_lstrcpy( LPWSTR lpString1, LPWSTR lpString2 );
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\guidutil.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       guidutil.h
 *  Content:    Some GUID related utility functions
 *
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#ifndef _GUIDUTIL_H_
#define _GUIDUTIL_H_

#include <windows.h>

#define GUID_STRING_LEN 39

HRESULT DVStringFromGUID(const GUID* lpguid, WCHAR* wszBuf, DWORD dwNumChars);
HRESULT DVGUIDFromString(const WCHAR* wszBuf, GUID* lpguid);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\dndbg.c ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.c
 *  Content:	debug support for DirectNet
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *  07-16-99	johnkan	Fixed include of OSInd.h, defined WSPRINTF macro
 *  07-19-99	vanceo	Explicitly declared OutStr as returning void for NT
 *						Build environment.
 *	07-22-99	a-evsch	Check for multiple Inits,  and release CritSec when DebugPrintf
 *						returns early.
 *	08-02-99	a-evsch	Added LOGPF support. LW entries only go into shared-file log
 *	08-31-99	johnkan	Removed include of <OSIND.H>
 *  09/01/99    rodtoll	Added functions to check valid read/write pointers 
 *  01-10-00	pnewson Added support for logging to disk
 *
 *  Notes:
 *	
 *  Use /Oi compiler option for strlen()
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#include <windows.h>
#include "memlog.h"
#include "dndbg.h"

//===============
// Debug  support
//===============

/*******************************************************************************
	Debug Logging to VXD.  In order to get this logging, DNET.VXD must be
	installed on the system.  This service is only available in the Win9x code
	base and can be installed by added the following to the system.ini file
	in the 386Enh section

	[386Enh]
	device=dnet.vxd

	This will enable a set of command under the debugger for dumping the
	log when broken into the debugger.  The commands can be initiated by
	typing .dnet at the ## prompt in the debugger.
==============================================================================*/
/*
BOOL DeviceIoControl(
HANDLE hDevice, 			// handle to device of interest
DWORD dwIoControlCode, 		// control code of operation to perform
LPVOID lpInBuffer, 			// pointer to buffer to supply input data
DWORD nInBufferSize, 		// size of input buffer
LPVOID lpOutBuffer, 		// pointer to buffer to receive output data
DWORD nOutBufferSize, 		// size of output buffer
LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count
LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
);
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)
#define WRITE_STATS     (FIRST_DEBUG_PROC+2)
#define WSPRINTF		wsprintfA

typedef struct _LOGENTRY {
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;


HANDLE hLoggingVxd=0;
HANDLE hLogMutex=0;
HANDLE hLogFile=0;
PSHARED_LOG_FILE pLogFile=0;
char szDiskFileName[MAX_PATH+1];
HANDLE hDiskFile=0;
HANDLE hDiskMutex=0;
#define DISK_LOG_MUTEX_NAME "DPLAYLOGMUTEX-1"

/*===========================================================================

	Debug Support.

	Logging:
	========

	Debug Logging and playback is designed to operate on both Win9x and
	Windows NT (Windows 2000).  On Win9x, a support VXD is used to extend
	the kernel debugger.  The VXD (DNET.VXD) is used for both logging and
	playback of debug buffers.  In addition to the debug VXD there is also
	logging to a shared file.  The shared file logging is played back with
	the DNLOG.EXE utility and can be played back on either Windows2000 or
	Win9x.

	Debug support for dumping structures on Win9x is supported only in the
	DNET.VXD component.  Dumping of structures internal to DPLAY can only
	be done from the context of a DPLAY thread.  This is because the
	addresses are only valid in that context.  Under NT there is (will be)
	a debug extension for dumping internal structures.

	Debug Logging is controlled by settings in the win.ini file.  Under
	the section heading [DirectNet].  There are 2 settings:

	Debug=9

	controls the debug level.  All messages, at or below that debug level
	are printed.

	The second setting (logging).  If not specified, all debugs are spewed
	through the standard DebugPrint and will appear on in DEVSTUDIO if
	it is up, or on the kernel debugger if it is running.

	This is a bit mask.
	bit 1 - spew to console
	bit 2 - spew to memory and vxd log
	bit 3 - spew to a disk file

	therefore:
	
	log = 0 {no debug output}
	log = 1	{spew to console only}
	log = 2 {spew to log only}
	log = 3 {spew to console and log}
	log = 4 {spew to disk}
	log = 5 {spew to console and disk}
	log = 6 {spew to log and disk}
	log = 7 {spew to console, log and disk}

	example win.ini...

	Use the "FileName" key to set the disk file that disk spew
	is written to. Data will be appended to this file. You must
	delete it yourself to keep it from growing without bound.
	This is so that if multiple concurrent processes call DPF_INIT()
	they will not delete the log written to that point.

	[DirectNet]
	Debug=7		; lots of spew
	log=6		; don't spew to debug window, but to log and disk
	FileName=c:\dplog.txt ; spew to the disk file c:\dplog.txt

	[DirectNet]
	Debug=0		; only fatal errors spewed to debug window

	Asserts:
	========
	Asserts are used to validate assumptions in the code.  For example
	if you know that the variable jojo should be > 700 and are depending
	on it in subsequent code, you SHOULD put an assert before the code
	that acts on that assumption.  The assert would look like:

	ASSERT(jojo>700);

	Asserts generally will produce 3 lines of debug spew to highlight the
	breaking of the assumption.  For testing, you might want to set the
	system to break in on asserts.  This is done in the [DirectNet] section
	of win.ini by setting BreakOnAssert=TRUE

	e.g.

	[DirectNet]
	Debug=0
	BreakOnAssert=TRUE
	Verbose=1

	Debug Breaks:
	=============
	When something really severe happens and you want the system to break in
	so that you can debug it later, you should put a debug break in the code
	path.  Some people use the philosophy that all code paths must be
	verified by hand tracing each one in the debugger.  If you abide by this
	you should place a DEBUG_BREAK() in every code path and remove them
	from the source as you trace each.  When you have good coverage but
	some unhit paths (error conditions) you should force those paths in
	the debugger.


===========================================================================*/

BOOL bInited=FALSE;
static CRITICAL_SECTION  csDPF;

DWORD lDebugLevel = 0;	

DWORD dwLogging   = 1;	// 0 => No debug spew
						// 1 => Spew to console only (default)
						// 2 => Spew to log only
						// 3 => Spew to console and log

DWORD bBreakOnAssert=FALSE; // if TRUE, causes DEBUG_BREAK on false asserts.

// if TRUE, all file/line/module information is printed and logged.
DWORD nVerboseLevel = 0;	// 1 => very verbose
							// 2 => Newson verbose
							
BOOL  bLiveLogging = FALSE;

// if TRUE messages printed with the LOGPF will be logged, if FALSE they're ignored
DWORD  lOutputLog = 0;

// Informational variables set for DebugPrintf before actual call
// to do printing/logging.  These variables are locked by csDPF
// when set.  csDPF is dropped when the data is finally printed
// which means there must be a call to DebugSetLineInfo followed
// immediately by a call to DebugPrintf.  This is hidden by the
// DPF macro.
static DWORD g_dwLine;  			    // line number of current DPF
static char  g_szFile	 [ MAX_PATH ];	// file name of current DPF
static char  g_szModName [ MAX_PATH ];	// module name of current DPF

// mystrncpy -
// our own strncpy to avoid linking CLIB.  This is debug only and hence
// not time critical, so this simple routine is fine.
// note: strlen also in this module is a Generic Intrinsic fn, so this
//       module should be compiled /Oi.
void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

// open up a channel to the DirectNet VXD (DNET.VXD) that will allows
// the log to be written to the VxD through DeviceIoControl calls.  The
// log in this case is accessible in the Win9x kernel debugger through
// the .dnet debugger extensions.
void InitDirectNetVxd(void)
{
	IN_LOGINIT In;
	OUT_LOGINIT Out;
	UINT cbRet;

	// note we rely on the system automatically closing this
	// handle for us when the user mode application exits.
	hLoggingVxd = CreateFileA("\\\\.\\DNET",0,0,0,0,0,0);

	if(hLoggingVxd != INVALID_HANDLE_VALUE){

		In.nCharsPerLine=MAX_STRING;
		In.nLogEntries=5000;
		DeviceIoControl(hLoggingVxd,
						OPEN_DEBUGLOG,
						&In,sizeof(In),
						&Out, sizeof(Out),
						&cbRet, NULL);
	} else {
		hLoggingVxd=0;
	}
}

// Write a string to the log in the debug support VxD.  This only
// operates on Win9x, when the DNET.VXD is installed.
static void VxdLogString( LPSTR str )
{
	char logstring[MAX_STRING+sizeof(LOGENTRY)];
	int  i=0;
	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
	UINT rc;
	UINT cbRet;
	int maxlen = MAX_STRING+sizeof(LOGENTRY);

	if(hLoggingVxd && str){
		while(str[i] && i < maxlen)
			i++;
		pLogEntry->debuglevel=0;
		memcpy(pLogEntry->str,str,i+1);
		DeviceIoControl(hLoggingVxd,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
	}
}

// Create a shared file for logging information on the fly
// This support allows the current log to be dumped from the
// user mode DPLOG.EXE application.  This is useful when debugging
// in MSSTUDIO or in NTSD.  When the DPLOG.EXE is invoke, note that
// the application will get halted until the log is completely dumped
// so it is best to dump the log to a file.
static BOOL InitMemLogString(VOID)
{
	static BOOL inited = FALSE;

	if(!inited){
		hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
		hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
		pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);

		if(!hLogFile || !hLogMutex || !pLogFile){
			if(hLogFile){
				CloseHandle(hLogFile);
				hLogFile=0;
			}
			if(hLogMutex){
				CloseHandle(hLogMutex);
				hLogMutex=0;
			}
			if(pLogFile){
				UnmapViewOfFile(pLogFile);
				pLogFile=NULL;
			}
			return FALSE;
		} else {
			inited = TRUE;
			pLogFile->nEntries = DPLOG_NUMENTRIES;
			pLogFile->cbLine   = DPLOG_ENTRYSIZE;
			pLogFile->iWrite   = 0;
			pLogFile->cInUse   = 0;
		}
	}
	return TRUE;
}

// open a disk file to receive spew
static BOOL InitDiskLogString(VOID)
{
	static BOOL inited = FALSE;

	if(!inited){

		// we're relying on the system to clean up these
		// handles when the process exits
		hDiskFile = CreateFileA(szDiskFileName, 
			GENERIC_WRITE, 
			FILE_SHARE_READ|FILE_SHARE_WRITE, 
			NULL,
			OPEN_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL);
			
		hDiskMutex=CreateMutexA(NULL,FALSE,DISK_LOG_MUTEX_NAME);

		if(!hDiskFile || !hDiskMutex){
			if(hDiskFile){
				CloseHandle(hDiskFile);
				hDiskFile=0;
			}
			if(hDiskMutex){
				CloseHandle(hDiskMutex);
				hDiskMutex=0;
			}
			return FALSE;
		} else {
			inited = TRUE;
		}
	}
	return TRUE;
}


// Log a string to a shared file.  This file can be dumped using the
// DPLOG.EXE utility.
static void MemLogString(LPSTR str)
{
	PLOG_ENTRY pEntry;
	DWORD cbCopy;

	if(!hLogFile){
		if(!InitMemLogString()){
			return;
		}
	}

	WaitForSingleObject(hLogMutex,INFINITE);

	pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
	pEntry->hThread=GetCurrentThreadId();
	pEntry->tLogged=timeGetTime();
	pEntry->DebugLevel=0;

	cbCopy=strlen(str)+1;
	if(cbCopy > DPLOG_ENTRYSIZE){
		str[DPLOG_ENTRYSIZE]=0;
		cbCopy=DPLOG_ENTRYSIZE;
	}
	memcpy(pEntry->str, str, cbCopy);

	if(pLogFile->iWrite+1 > pLogFile->cInUse){
		pLogFile->cInUse=pLogFile->iWrite+1;
	}

	pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
	ReleaseMutex(hLogMutex);

}

// Log the string to an ordinary disk file
static void DiskLogString(LPSTR str)
{
	DWORD dwBytesWritten;
	
	if(!hDiskFile){
		if(!InitDiskLogString()){
			return;
		}
	}

	WaitForSingleObject(hDiskMutex,INFINITE);

	if (SetFilePointer(hDiskFile, 0, NULL, FILE_END) != INVALID_SET_FILE_POINTER)
	{
		WriteFile(hDiskFile, str, strlen(str), &dwBytesWritten, NULL);
		WriteFile(hDiskFile, "\r\n", strlen("\r\n"), &dwBytesWritten, NULL);
		FlushFileBuffers(hDiskFile);
	}

	ReleaseMutex(hDiskMutex);
}


// DebugPrintfInit() - initialize DPF support.
void DebugPrintfInit()
{
	DWORD lSpecificLevel;

	if(bInited == TRUE){			// DPF deadlocks if it gets inited twice.
		return;
	}

    lDebugLevel = (signed int) GetProfileIntA( PROF_SECT, "debug", 0 );
    lSpecificLevel = (signed int) GetProfileIntA( PROF_SECT, DPF_MODULE_NAME, -1);
    if(lSpecificLevel != -1){
    	lDebugLevel = lSpecificLevel;
    }
    dwLogging   = (signed int) GetProfileIntA( PROF_SECT, "log" , 0);
    bBreakOnAssert = (signed int) GetProfileIntA( PROF_SECT, "BreakOnAssert", 0);
    nVerboseLevel = (signed int) GetProfileIntA( PROF_SECT, "Verbose", 0);

    lOutputLog = (signed int) GetProfileIntA( PROF_SECT, "OutputLog", 0);

	ZeroMemory(szDiskFileName, MAX_PATH+1);
    GetProfileStringA(PROF_SECT, "FileName", "C:\\dplog.txt", szDiskFileName, MAX_PATH+1);

	if (dwLogging & 0x0001)
	{
		bLiveLogging=TRUE;
	}
	else
	{
		bLiveLogging=FALSE;
	}

	/*
	switch(dwLogging){
		case 0:
			bLiveLogging=FALSE;
			break;
		case 1:
			bLiveLogging=TRUE;
			break;
		case 2:
			bLiveLogging=FALSE;
			break;
		case 3:
			bLiveLogging=TRUE;
			break;
		default:
			break;
	}
	*/
	
	if((dwLogging & 0x0002)||(lOutputLog > 0)){
		// Doing log based logging, so try to find the VXD and open
		// the shared logging file.
		InitDirectNetVxd();

		// Do logging also based on shared memory file.
		InitMemLogString();	
	}

	if (dwLogging & 0x0004)
	{
		// We're also logging to a file, open it
		InitDiskLogString();
	}

    InitializeCriticalSection(&csDPF);
    bInited=TRUE;
}

// DebugPrintfFini() - release resources used by DPF support.
void DebugPrintfFini()
{
	if(hLogFile){
		CloseHandle(hLogFile);
	}
	if(hLoggingVxd){
		CloseHandle(hLoggingVxd);
	}	
	DeleteCriticalSection(&csDPF);

	bInited = FALSE;
}

// DebugSetLineInfo - store information about where the DPF is from.
//
// Called before a call to DebugPrintf in order to specify the file
// line and function from which the DPF is being called.  This allows
// logging of these values.  In order to support this though, the
// values are stored in globals over the duration of the call, so a
// lock is acquired in this call and released in the DebugPrintf call.
// This means these functions MUST be called one after the other.
void DebugSetLineInfo(LPSTR szFile, DWORD dwLine, LPSTR szModName)
{
	if(!bInited){
		// NOTE: your module should call DPFINIT() if possible.
		DebugPrintfInit();
	}
	EnterCriticalSection(&csDPF);

    mystrncpy (g_szFile,szFile,sizeof(g_szFile));
    mystrncpy (g_szModName,szModName,sizeof(g_szModName));
    g_dwLine = dwLine;
}

// Actually ouput the string to the various output methods as requested
// in the win.ini section.
void OutStr( DWORD dwDetail, LPSTR str )
{
	INT i=0;

	if(dwDetail <= lDebugLevel){

		if(str)while(str[i++]);	// string warming

		if(bLiveLogging)
		{
			// log to debugger output
			OutputDebugStringA(str);
			OutputDebugStringA("\n");
		}

		if(hLoggingVxd){
			// log to vxd
			VxdLogString( str );
		}

		if(dwLogging & 0x0002){
			// log to shared file
			MemLogString( str );
		}

		if(dwLogging & 0x0004){
			// log to shared file
			DiskLogString( str );
		}
	}	
}

void DebugPrintfNoLock(volatile DWORD dwDetail, ...){
	CHAR  cMsg[1000];
	LPSTR szFormat;

	va_list argptr;

	if(!bInited){
		// NOTE: your module should call DPFINIT() if possible.
		DebugPrintfInit();
	}

	if(lDebugLevel < dwDetail)
		return;

	va_start(argptr, dwDetail);
	szFormat = (LPSTR)(DWORD_PTR)va_arg(argptr, DWORD);

	cMsg[0]=0;

	// Prints out / logs as:
	// 1. Verbose
	// dwDetail:ThreadId:File:Fn:Line:DebugString
	// e.g.
	// 2:8007eaf:DPLAYX.DLL:DPOS.C(L213):
	//
	// 2. Regular
	// ThreadId:DebugString

	WSPRINTF(cMsg,"%1d:",dwDetail);
	WSPRINTF(cMsg+strlen(cMsg),"%08x:",GetCurrentThreadId());

	if(nVerboseLevel==1){
		WSPRINTF(cMsg+strlen(cMsg),"(%12s)",g_szFile);
		WSPRINTF(cMsg+strlen(cMsg),"%s",g_szModName);
		WSPRINTF(cMsg+strlen(cMsg),"(L%d)",g_dwLine);
	} else if (nVerboseLevel==2){
		WSPRINTF(cMsg+strlen(cMsg),"%s",g_szModName);
		WSPRINTF(cMsg+strlen(cMsg),"(L%d)",g_dwLine);
	}

	WSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);

	OutStr( dwDetail, cMsg );

	va_end(argptr);
}

// DebugPrintf - print a debug string
//
// You must call DebugSetLineInfo before making this call.
//
void DebugPrintf(volatile DWORD dwDetail, ...)
{
	CHAR  cMsg[1000];
	LPSTR szFormat;

	va_list argptr;

	if(!bInited){
		// NOTE: your module should call DPFINIT() if possible.
		DebugPrintfInit();
	}

	if(lDebugLevel < dwDetail){
		LeaveCriticalSection(&csDPF);
		return;
	}

	va_start(argptr, dwDetail);
	szFormat = (LPSTR)(DWORD_PTR)va_arg(argptr, DWORD);

	cMsg[0]=0;

	// Prints out / logs as:
	// 1. Verbose
	// dwDetail:ThreadId:File:Fn:Line:DebugString
	// e.g.
	// 2:8007eaf:DPLAYX.DLL:DPOS.C(L213):
	//
	// 2. Regular
	// ThreadId:DebugString

	WSPRINTF(cMsg,"%1d:",dwDetail);
	WSPRINTF(cMsg+strlen(cMsg),"%08x:",GetCurrentThreadId());

	if(nVerboseLevel==1){
		WSPRINTF(cMsg+strlen(cMsg),"(%12s)",g_szFile);
		WSPRINTF(cMsg+strlen(cMsg),"%s",g_szModName);
		WSPRINTF(cMsg+strlen(cMsg),"(L%d)",g_dwLine);
	} else if (nVerboseLevel==2){
		WSPRINTF(cMsg+strlen(cMsg),"%s",g_szModName);
		WSPRINTF(cMsg+strlen(cMsg),"(L%d)",g_dwLine);
	}

	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);

	OutStr( dwDetail, cMsg );

	LeaveCriticalSection(&csDPF);

	va_end(argptr);
}

/*
**	LogPrintf copies a quick Log Entry to the
**
*/

void LogPrintf(volatile DWORD dwDetail, ...)
{
	CHAR  cMsg[1000];
	LPSTR szFormat;

	va_list argptr;

	if(lOutputLog < dwDetail){
		return;
	}

	EnterCriticalSection(&csDPF);

	va_start(argptr, dwDetail);
	szFormat = (LPSTR)(DWORD_PTR)va_arg(argptr, DWORD);

	cMsg[0]=0;

	WSPRINTF(cMsg,"%s: ",g_szModName);

	WVSPRINTF(cMsg+lstrlenA( cMsg ), szFormat, argptr);

	MemLogString( (LPSTR) cMsg );

	LeaveCriticalSection(&csDPF);

	va_end(argptr);
}

//
// NOTE: I don't want to get into error checking for buffer overflows when
// trying to issue an assertion failure message. So instead I just allocate
// a buffer that is "bug enough" (I know, I know...)
//
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DNAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAssert || GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}

// IsValidWritePtr
//
// Checks to ensure memory pointed to by the buffer is valid for 
// writing dwSize bytes.  Contents of the memory are restored 
// after this call.  
//
BOOL IsValidWritePtr( LPVOID lpBuffer, DWORD dwSize )
{
	DWORD dwIndex;
	BYTE bTempValue;
	LPBYTE lpBufferPtr = (LPBYTE) lpBuffer;

	if( lpBuffer == NULL )
		return FALSE;
	
	_try
    {
    	for( dwIndex = 0; dwIndex < dwSize; dwIndex++ )
    	{
    		bTempValue = lpBufferPtr[dwIndex];
    		lpBufferPtr[dwIndex] = 0xcc;
    		lpBufferPtr[dwIndex] = bTempValue;
    	}
    }
    _except( EXCEPTION_EXECUTE_HANDLER )
    {
        return FALSE;
    }

    return TRUE;
}

// IsValidReadPtr
//
// Checks to see if the memory pointed to by lpBuffer is valid for
// reading of dwSize bytes.  
//
BOOL IsValidReadPtr( LPVOID lpBuffer, DWORD dwSize )
{
	DWORD dwIndex;
	BYTE bTempValue;
	LPBYTE lpBufferPtr = (LPBYTE) lpBuffer;
	DWORD dwTotal = 0;

	if( lpBuffer == NULL )
		return FALSE;

	_try
	{
    	for( dwIndex = 0; dwIndex < dwSize; dwIndex++ )
    	{
    		bTempValue = lpBufferPtr[dwIndex];
    		dwTotal += bTempValue;
    	}
    }
    _except( EXCEPTION_EXECUTE_HANDLER )
    {
        return FALSE;
    }

    return TRUE;
}


#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\guid.h ===
// guid.h
#ifndef GUID_H
#define GUID_H

// Flash
// {9A9A1380-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_FlashExtension,
	0x9a9a1380, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// Legacy
// {9A9A1381-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_LegacyExtension,
	0x9a9a1381, 
	0x0d4f,
	0x11cf,
	0xaf, 0x06,
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	IID_IJoyPropSheetExt, 
	0x9a9a1382, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// Midas
// {9A9A1383-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_JoystickExtension,
	0x9a9a1383, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// BEGINNING OF NOT RELIABLE GUIDS!!!
// Jolt
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_JoltExtension, 
	0x9a9a1384, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);


// Juno
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_JunoExtension, 
	0x9a9a1385, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// Shazam
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_Shazam, 
	0x9a9a1386, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// IServerChar
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	IID_IServerChars, 
	0x9a9a1387, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// CServerChar
// {9A9A1382-0D4F-11cf-AF06-00AA004BB9BE}
DEFINE_GUID(
	CLSID_CServerChars, 
	0x9a9a1388, 
	0x0d4f, 
	0x11cf, 
	0xaf, 0x06, 
	0x00, 0xaa, 0x00, 0x4b, 0xb9, 0xbe);

// END OF NOT RELIABLE GUIDS!!!

#endif // GUID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\dvosal.cpp ===
#include "dvosal.h"
//#include "osind.h"
#include "dndbg.h"

#define DVOSAL_DEFAULT_CHAR "-"

volatile BOOL g_fUnicode;

#undef DPF_MODNAME
#define DPF_MODNAME "OSAL_Initialize"
HRESULT OSAL_Initialize()
{
	g_fUnicode = OSAL_CheckIsUnicodePlatform();

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "OSAL_DeInitialize"
HRESULT OSAL_DeInitialize()
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "OSAL_IsUnicodePlatform"
BOOL OSAL_IsUnicodePlatform()
{
	return g_fUnicode;
}


#undef DPF_MODNAME
#define DPF_MODNAME "OSAL_CheckIsUnicodePlatform"
BOOL OSAL_CheckIsUnicodePlatform()
{
	OSVERSIONINFOA	ver;
	BOOL			bReturn = FALSE;


	// Clear our structure since it's on the stack
	memset(&ver, 0, sizeof(OSVERSIONINFOA));
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	// Just always call the ANSI function
	if(!GetVersionExA(&ver))
	{
		DPF( DVF_ERRORLEVEL, "Unable to determinte platform -- setting flag to ANSI");
		bReturn = FALSE;
	}
	else
	{
		switch(ver.dwPlatformId)
		{
			case VER_PLATFORM_WIN32_WINDOWS:
				DPF(DVF_ERRORLEVEL, "Platform detected as non-NT -- setting flag to ANSI");
				bReturn = FALSE;
				break;

			case VER_PLATFORM_WIN32_NT:
				DPF(DVF_ERRORLEVEL, "Platform detected as NT -- setting flag to Unicode");
				bReturn = TRUE;
				break;

			default:
				DPF(DVF_ERRORLEVEL, "Unable to determine platform -- setting flag to ANSI");
				bReturn = FALSE;
				break;
		}
	}

	// Keep the compiler happy
	return bReturn;

}  // OS_IsUnicodePlatform

#undef DPF_MODNAME
#define DPF_MODNAME "OSAL_AllocAndConvertToANSI"
/*
 ** GetAnsiString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszAnsi - pointer to string
 *				lpszWide - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and converts lpszWide to ansi
 *
 *  RETURNS: string length
 *
 */
HRESULT OSAL_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
{
	int iStrLen;
	
	DNASSERT(ppszAnsi);

	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return S_OK;
	}

	// call wide to ansi to find out how big +1 for terminating NULL
	iStrLen = OSAL_WideToAnsi(NULL,lpszWide,0) + 1;
	DNASSERT(iStrLen > 0);

	*ppszAnsi = new char[iStrLen];
	if (!*ppszAnsi)	
	{
		DPF(DVF_ERRORLEVEL, "could not get ansi string -- out of memory");
		return E_OUTOFMEMORY;
	}
	OSAL_WideToAnsi(*ppszAnsi,lpszWide,iStrLen);

	return S_OK;
} // GetAnsiString

#undef DPF_MODNAME
#define DPF_MODNAME "OSAL_WideToAnsi"
/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int OSAL_WideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr)
{
	int rval;
	//PREFIX: using uninitialized memory 'bDefault', Mill Bug#129165
    // bDefault is passed by reference to WideCharToMultiByte, but we will keep prefix happy	
    BOOL bDefault = 0x0;

	if (!lpWStr && cchStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DNASSERT(FALSE);
		return 0;
	}
	
	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
			DVOSAL_DEFAULT_CHAR,&bDefault);

	if (bDefault)
	{
		DPF(DVF_WARNINGLEVEL,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
		DPF(DVF_WARNINGLEVEL,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
	}
	
	return rval;

} // WideToAnsi

#undef DPF_MODNAME
#define DPF_MODNAME "OSAL_AnsiToWide"
/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int OSAL_AnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr)
{
	int rval;

	if (!lpStr && cchWStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DNASSERT(FALSE);
		return 0;
	}

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);

	return rval;
}  // AnsiToWide

/*
 ** WideToTChar
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpTStr - destination string
 *				lpWStr - string to convert
 *				cchTStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to TCHAR lpTStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchTStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int OSAL_WideToTChar(LPTSTR lpTStr,LPCWSTR lpWStr,int cchTStr)
{
#if defined(UNICODE)
	// no conversion required, just copy the string over
	if (!lpWStr && cchTStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DNASSERT(FALSE);
		return 0;
	}

	if (cchTStr == 0)
	{
		return (wcslen(lpWStr)+1)*sizeof(TCHAR);
	}

	wcsncpy(lpTStr, lpWStr, cchTStr/sizeof(TCHAR));

	return (wcslen(lpTStr)+1)*sizeof(TCHAR);
	
#else
	// call the conversion function
	return OSAL_WideToAnsi(lpTStr, lpWStr, cchTStr);
	
#endif
} // WideToTChar

/*
 ** TCharToWide
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpWStr - destination string
 *				lpTStr - string to convert
 *				cchWStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts TCHAR lpTStr to unicode lpWStr.
 *				
 *
 *  RETURNS:  if cchWStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int OSAL_TCharToWide(LPWSTR lpWStr,LPCTSTR lpTStr,int cchWStr)
{
#if defined(UNICODE)
	// no conversion required, just copy the string over
	if (!lpTStr && cchWStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DNASSERT(FALSE);
		return 0;
	}

	if (cchWStr == 0)
	{
		return (wcslen(lpTStr)+1)*sizeof(WCHAR);
	}

	wcsncpy(lpWStr, lpTStr, cchWStr/sizeof(WCHAR));

	return (wcslen(lpWStr)+1)*sizeof(WCHAR);
	
#else
	// call the conversion function
	return OSAL_AnsiToWide(lpWStr, lpTStr, cchWStr);
	
#endif
} // TCharToWide
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\memlog.h ===
#include <windows.h>
#include <mmsystem.h>

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define BASE_LOG_FILENAME  "DPLAYLOG-0"
#define BASE_LOG_MUTEXNAME "DPLAYLOGMUTEX-0"

#define DPLOG_NUMENTRIES	5000
#define DPLOG_ENTRYSIZE		120
#define DPLOG_SIZE (sizeof(SHARED_LOG_FILE)+((sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)*DPLOG_NUMENTRIES))

//
// Globals for shared memory based logging
//
typedef struct _SHARED_LOG_FILE{
	CHAR	szAppName[16];
	DWORD   nEntries;
	DWORD	cbLine;
	DWORD 	iWrite;
	DWORD	cInUse;
	// followed by an array of LOGENTRIES.
}SHARED_LOG_FILE, *PSHARED_LOG_FILE;

typedef struct _LOG_ENTRY {
	DWORD	hThread;
	DWORD	tLogged;
	DWORD	DebugLevel;
	CHAR	str[0];
} LOG_ENTRY, *PLOG_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\inplace.cpp ===
// InPlaceEdit.cpp : implementation file
//

#include "stdafx.h"
#include "InPlace.h"
#include "cpanel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_STR_LEN 255

extern HWND hAdvListCtrl;

/////////////////////////////////////////////////////////////////////////////
// CInPlaceEdit

CInPlaceEdit::CInPlaceEdit(BYTE iItem, BYTE iSubItem):m_iItem(iItem),m_iSubItem(iSubItem)
//,m_bESC(FALSE),m_sInitText(sInitText)
{
	m_iItem 	  	= iItem;
	m_iSubItem 	= iSubItem;
	m_bESC 	  	= FALSE;

//	_tcscpy(m_sInitText, sInitText);
}

CInPlaceEdit::~CInPlaceEdit()
{
}


BEGIN_MESSAGE_MAP(CInPlaceEdit, CEdit)
	//{{AFX_MSG_MAP(CInPlaceEdit)
	ON_WM_KILLFOCUS()
	ON_WM_CHAR()
	ON_WM_CREATE()
	ON_WM_MOUSEWHEEL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInPlaceEdit message handlers
/*
BOOL CInPlaceEdit::PreTranslateMessage(MSG* pMsg) 
{
	if( pMsg->message == WM_KEYDOWN )
	{
		if(pMsg->wParam == VK_RETURN
				|| pMsg->wParam == VK_DELETE
				|| pMsg->wParam == VK_ESCAPE
				|| GetKeyState( VK_CONTROL)
				)
		{
			::TranslateMessage(pMsg);
			::DispatchMessage(pMsg);
			return TRUE;		    	// DO NOT process further
		}
	}
	return CEdit::PreTranslateMessage(pMsg);
}
*/

BOOL CInPlaceEdit::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
{
	OnKillFocus(this);
	return TRUE;
}

void CInPlaceEdit::OnKillFocus(CWnd* pNewWnd) 
{
	CEdit::OnKillFocus(pNewWnd);

	if (LineLength())
	{
		::GetWindowText(this->GetSafeHwnd(), m_sInitText, MAX_STR_LEN);

	   // No point sending the message if the text hasn't changed!
	   // OR if there's nothing to add!
	   // Send Notification to parent of ListView ctrl
		LV_DISPINFO *lpDispinfo = new (LV_DISPINFO);
	   ASSERT (lpDispinfo);

	   lpDispinfo->hdr.hwndFrom    = GetParent()->m_hWnd;
		lpDispinfo->hdr.idFrom      = GetDlgCtrlID();
	   lpDispinfo->hdr.code        = LVN_ENDLABELEDIT;

		lpDispinfo->item.mask       = LVIF_TEXT;
		lpDispinfo->item.iItem      = m_iItem;
	   lpDispinfo->item.iSubItem   = m_iSubItem;
	   lpDispinfo->item.pszText    = m_bESC ? NULL : m_sInitText;
		lpDispinfo->item.cchTextMax = MAX_STR_LEN;

	   GetParent()->GetParent()->SendMessage( WM_NOTIFY, GetParent()->GetDlgCtrlID(), 
						(LPARAM)lpDispinfo );

	   if (lpDispinfo)
	      delete (lpDispinfo);
   }

	if (m_sInitText)
		delete[] (m_sInitText);

	PostMessage(WM_CLOSE);
}

void CInPlaceEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	CEdit::OnChar(nChar, nRepCnt, nFlags);

	// Get text extent
	BYTE nLen = (BYTE)SendMessage(LB_GETTEXTLEN, (WPARAM)0, 0);

	if (nLen == 255)
		return;

   LPTSTR lpStr = new (TCHAR[nLen+1]);
	ASSERT (lpStr);

   SendMessage(LB_GETTEXT, (WPARAM)0, (LPARAM)(LPCTSTR)lpStr);

	// Resize edit control if needed
	HDC hDC = this->GetDC()->m_hDC;
	SIZE size;
	::GetTextExtentPoint(hDC, lpStr, nLen+1, &size);
	::ReleaseDC(this->m_hWnd, hDC);

	if (lpStr)
		delete[] (lpStr);

	size.cx += 5;			   	// add some extra buffer

	// Get client rect
	RECT rect, parentrect;
	GetClientRect( &rect );
	GetParent()->GetClientRect( &parentrect );

	// Transform rect to parent coordinates
	ClientToScreen( &rect );
	GetParent()->ScreenToClient( &rect );

	// Check whether control needs to be resized
	// and whether there is space to grow
	if( size.cx > (rect.right-rect.left) )
	{
		rect.right = ( size.cx + rect.left < parentrect.right ) ? rect.left + size.cx : parentrect.right;
		MoveWindow( &rect );
	}
}


int CInPlaceEdit::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CEdit::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Allocate the string buffer
	m_sInitText = new (TCHAR[MAX_STR_LEN+1]);
	ASSERT (m_sInitText);

	GetItemText(hAdvListCtrl, m_iItem, m_iSubItem, m_sInitText, MAX_STR_LEN);

	// Set the proper font
	// If you don't, the font is a bold version of the dialog font!
	::SendMessage(this->m_hWnd, WM_SETFONT, ::SendMessage(::GetParent(this->m_hWnd), WM_GETFONT, 0, 0), 0);

	SendMessage(WM_SETTEXT, 0, (LPARAM)(LPCTSTR)m_sInitText);
	SetFocus();
   SendMessage(EM_SETSEL, (WPARAM)0, (LPARAM)-1);
	SendMessage(EM_LIMITTEXT, (WPARAM)MAX_STR_LEN, 0);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\retrocfg.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       retrocfg.h
 *  Content:    Prototypes the RetroConfigProcess function
 *  History:
 *	Date   By  Reason
 *	============
 *	10/13/99	pnewson		created
 ***************************************************************************/

#ifndef _RETROCFG_H_
#define _RETROCFG_H_

HRESULT RetroConfigProcess(HINSTANCE hResDLLInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\inplace.h ===
#if !defined(AFX_INPLACEEDIT_H__8424B1E4_BF4A_11D1_82D7_0000F87A3912__INCLUDED_)
#define AFX_INPLACEEDIT_H__8424B1E4_BF4A_11D1_82D7_0000F87A3912__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InPlaceEdit.h : header file
//

#define IDC_IPEDIT 7896

/////////////////////////////////////////////////////////////////////////////
// CInPlaceEdit window

class CInPlaceEdit : public CEdit
{
// Construction
public:
	CInPlaceEdit(BYTE iItem, BYTE iSubItem);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInPlaceEdit)
//	public:
// 	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CInPlaceEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CInPlaceEdit)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	//}}AFX_MSG										    

	DECLARE_MESSAGE_MAP()

private:
	BYTE m_iItem;
	BYTE m_iSubItem;
	LPTSTR m_sInitText;
	BOOL    m_bESC;	 	// To indicate whether ESC key was pressed
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INPLACEEDIT_H__8424B1E4_BF4A_11D1_82D7_0000F87A3912__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\main.cpp ===
/*
File:		main.cpp
Project:	Universal Joystick Control Panel OLE Client
Author:	Brycej
Date:		02/28/95
Comments:

Copyright (c) 1995, Microsoft Corporation
*/

//#pragma pack (8)

#include <afxcmn.h>
#include <cpl.h>

#include "cpanel.h"
#include "resource.h"
#include "creditst.h" // for the Credit Dialog!

#define JOYSTICK_CPL	0
#define MAX_CPL_PAGES 6

HINSTANCE ghInstance;

extern WCHAR *pwszTypeArray[MAX_DEVICES];
extern WCHAR *pwszGameportDriverArray[MAX_GLOBAL_PORT_DRIVERS];
extern WCHAR *pwszGameportBus[MAX_BUSSES];  // List of enumerated gameport buses 

extern BYTE nGamingDevices;  // Gaming Devices Enumeration Counter
extern BYTE nGameportDriver; // Global Port Driver Enumeration Counter
extern BYTE nGameportBus;    // Gameport Bus Enumeration Counter
extern short nFlags;              // State Flags the CPL defined in CPANEL.H

static void AddPage(LPPROPSHEETHEADER ppsh, short nTemplateID, int nTabID, DLGPROC pfn);

static void DoProperties(HWND hWnd, UINT nStartPage);
void WINAPI ShowJoyCPL(HWND);
void ParseArgs(HWND hDlg, LPTSTR lpArgList);
BOOL WINAPI SplashDialogProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam);

// From AppMan.cpp
//extern HRESULT AppManInit();

// From Retrocfg.cpp
extern HRESULT  DVoiceCPLInit();
extern INT_PTR CALLBACK  RetrofitProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
extern INT_PTR RetrofitDestroyHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


BYTE nID, nStartPageDef, nStartPageCPL;


BOOL WINAPI DllMain(HANDLE  hModule, ULONG  uReason, LPVOID pv)
{
    switch( uReason )
    {
    case DLL_PROCESS_ATTACH:
        ghInstance = (HINSTANCE)hModule;

        // needed because CEdit will Assert without this line!!!
        afxCurrentInstanceHandle = ghInstance;
        afxCurrentResourceHandle = ghInstance;
        break;

//	case DLL_PROCESS_DETACH:
//		ClearArrays();

    case DLL_THREAD_ATTACH:
        DisableThreadLibraryCalls((HMODULE)hModule);
    case DLL_THREAD_DETACH:
        break;
    }
    return(TRUE);
}

/*
function:	CPlApplet()
comments:
    Entry point for control panel applets.
*/
LONG WINAPI CPlApplet(HWND  hWnd, UINT  uMsg, LPARAM  lParam1, LPARAM   lParam2)
{
    switch( uMsg )
    {
    case CPL_INIT:
        return(1);

    case CPL_GETCOUNT:
        return(1);

    case CPL_INQUIRE:
        ((LPCPLINFO)lParam2)->idIcon = IDI_CPANEL; 
        ((LPCPLINFO)lParam2)->idName = IDS_GEN_CPANEL_TITLE; 
        ((LPCPLINFO)lParam2)->idInfo = IDS_GEN_CPANEL_INFO; 
        ((LPCPLINFO)lParam2)->lData  = 0;
        return(1);

    case CPL_DBLCLK:
        nID = (NUMJOYDEVS<<1);

        // Applet icon double clicked -- invoke property sheet with
        // The first property sheet page on top.
        DoProperties(hWnd, 0);
        break;

        /*
         * This function requires Windows 2000. Not available on Win9x.
         */
    case CPL_STARTWPARMS:
        // Same as CPL_DBLCLK, but lParam2 is a long pointer to
        // a string of extra directions that are to be supplied to
        // the property sheet that is to be initiated.
        // The arguments are as follows:
        // @nCPLDialog Index, nStartPageCPL, nStartPageDef

        // Don't do anything if there are no arguments!
        if( *(LPTSTR)lParam2 )
            ParseArgs(hWnd, (LPTSTR)lParam2);
        return(TRUE);  // return non-zero to indicate message handled

    case CPL_EXIT:
    case CPL_STOP:
        break;
    }

    return(0);
}

/*
   Function: DoProperties(HWND hWnd, UINT nStartPage)
   Arguements: hWnd       - Handle to Main Window
               nStartPage - Page number to start
*/
static void DoProperties(HWND hWnd, UINT nStartPage)
{
    static HWND hPrevHwnd;
    static HANDLE hMutex = CreateMutex(NULL, TRUE, MUTEX_NAME);

    if( GetLastError() == ERROR_ALREADY_EXISTS )
    {
        SetForegroundWindow(hPrevHwnd); 
    } else
    {
        hPrevHwnd = hWnd;

        nFlags = (GetVersion() < 0x80000000) ? ON_NT : 0;

        HPROPSHEETPAGE  *pPages = new (HPROPSHEETPAGE[MAX_CPL_PAGES]);
        ASSERT (pPages);

        LPPROPSHEETHEADER ppsh = new (PROPSHEETHEADER);
        ASSERT(ppsh);

        ZeroMemory(ppsh, sizeof(PROPSHEETHEADER));

        ppsh->dwSize     = sizeof(PROPSHEETHEADER);
        ppsh->dwFlags    = PSH_NOAPPLYNOW | PSH_USEICONID;
        ppsh->hwndParent = hWnd;
        ppsh->hInstance  = ghInstance;
        ppsh->pszCaption = MAKEINTRESOURCE(IDS_GEN_CPANEL_TITLE);
        ppsh->pszIcon     = MAKEINTRESOURCE(IDI_CPANEL);
        ppsh->nStartPage = nStartPage;
        ppsh->phpage     = pPages;

        AddPage(ppsh, IDD_CPANEL,   IDS_GENERAL_TAB,  (DLGPROC)CPanelProc);
        AddPage(ppsh, IDD_ADVANCED, IDS_ADVANCED_TAB, (DLGPROC)AdvancedProc);

		if( SUCCEEDED ( DVoiceCPLInit() )) {
		  AddPage(ppsh, IDD_PROP_RETROFIT, IDS_DVOICE_TAB, (DLGPROC) RetrofitProc);
		}

//		if( SUCCEEDED ( AppManInit() ) ) {
//			AddPage(ppsh, IDD_APPMAN,   IDS_APPMAN_TAB, (DLGPROC)AppManProc);
//			AddPage(ppsh, IDD_APPMAN_LOCKING, IDS_APPMANLOCK_TAB, (DLGPROC) AppManLockProc);
//		}

#ifdef SYMANTIC_MAPPER
        AddPage(ppsh, IDD_SMAPPER, ID_SMAPPER_TAB, (DLGPROC)SMapperProc);
#endif // SYMANTIC_MAPPER

        // trap for return...
        VERIFY(PropertySheet(ppsh) != -1);

        if( pPages )
            delete[] (pPages);

        if( ppsh )
            delete (ppsh);

        ReleaseMutex(hMutex);
        CloseHandle(hMutex);

        // Ensure voice is always cleaned up
        RetrofitDestroyHandler( NULL, 0, 0, 0 );

        ClearArrays();
    }
}

static void AddPage(LPPROPSHEETHEADER ppsh, short nTemplateID, int nTabID, DLGPROC pfn)
{
    if( ppsh->nPages < MAX_CPL_PAGES )
    {
        LPPROPSHEETPAGE ppsp = new (PROPSHEETPAGE);
        ASSERT(ppsp);

        ZeroMemory(ppsp, sizeof(PROPSHEETPAGE));

        ppsp->dwSize      = sizeof(PROPSHEETPAGE);
        ppsp->pszTitle    = MAKEINTRESOURCE(nTabID);
        ppsp->hInstance   = ghInstance;
        ppsp->pfnDlgProc  = pfn;
        ppsp->pszTemplate = MAKEINTRESOURCE(nTemplateID);

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(ppsp);

        if( ppsp )
            delete (ppsp);

        if( ppsh->phpage[ppsh->nPages] )
            ppsh->nPages++;
    }
}  // AddPage


// DO NOT REMOVE THIS!!!
// This is here because the games group loads the CPL from the exported function
// If you remove this Hellbender, Monster Truck Maddness, CART, etc will fail to
// load the Joystick CPL!!!
// DO NOT REMOVE THIS!!!
void WINAPI ShowJoyCPL(HWND hWnd)
{
    nID = (NUMJOYDEVS<<1);

    DoProperties(hWnd, 0);
}

void LaunchExtention(HWND hWnd)
{
    // These are defined in CPANEL.CPP
    extern LPDIRECTINPUT lpDIInterface;
    extern IDirectInputJoyConfig* pDIJoyConfig;

    HRESULT hr =  DirectInputCreate(ghInstance, DIRECTINPUT_VERSION, &lpDIInterface, NULL);

    if( FAILED(hr) ) return;

    // Call CreateJoyConfigInterface!
    if( SUCCEEDED(lpDIInterface->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID*)&pDIJoyConfig)) )
    {
        // Create a pJoy and populate it's GUID from GetTypeInfo
        PJOY pJoy = new (JOY);
        ASSERT (pJoy);

        pJoy->ID = nID;

        DIJOYCONFIG_DX5 JoyConfig;

        JoyConfig.dwSize = sizeof (DIJOYCONFIG_DX5);

        if( SUCCEEDED(pDIJoyConfig->GetConfig(nID, (LPDIJOYCONFIG)&JoyConfig, DIJC_REGHWCONFIGTYPE)) )
        {
            LPDIJOYTYPEINFO_DX5 pdiJoyTypeInfo = new (DIJOYTYPEINFO_DX5);
            ASSERT (pdiJoyTypeInfo);

            pdiJoyTypeInfo->dwSize = sizeof (DIJOYTYPEINFO_DX5);

            hr = pDIJoyConfig->GetTypeInfo(JoyConfig.wszType, (LPDIJOYTYPEINFO)pdiJoyTypeInfo, DITC_CLSIDCONFIG);

            if( !IsEqualIID(pdiJoyTypeInfo->clsidConfig, GUID_NULL) )
                pJoy->clsidPropSheet = pdiJoyTypeInfo->clsidConfig;

            if( pdiJoyTypeInfo )
                delete (pdiJoyTypeInfo);

        }

        if( SUCCEEDED(hr) )
            Launch(hWnd, pJoy, nStartPageDef);

        if( pJoy )
            delete (pJoy);

        // release the DI JoyConfig interface pointer
        if( pDIJoyConfig )
        {
            pDIJoyConfig->Release();
            pDIJoyConfig = 0;
        }
    }

    // release the DI Device interface pointer
    if( lpDIInterface )
    {
        lpDIInterface->Release();
        lpDIInterface = 0;
    }
}

void ParseArgs(HWND hDlg, LPTSTR lpArgList)
{
    BOOL bShowCPL = TRUE;

    // Check for '-', as they may not want to show the CPL!
    if( *lpArgList == '-' )
    {
        bShowCPL = FALSE;
        *lpArgList++;
    }

    nStartPageCPL = nStartPageCPL = nStartPageDef = 0;

    // parse command line for nStartPageCPL!
    while( *lpArgList && (*lpArgList != ',') )
    {
        nStartPageCPL *= 10;
        nStartPageCPL += *lpArgList++ - '0';
    }

    // check to make sure nStartPageCPL is within range!
    if( bShowCPL ) {
        if( nStartPageCPL > MAX_CPL_PAGES )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("JOY.CPL: Command line requested an invalid start page, reset to default!\n"));
#endif      
            // NUMJOYDEVS is used to send the user to the Add dialog on start-up!
            if( nStartPageCPL != NUMJOYDEVS )
                nStartPageCPL = 0;
        }
    }

        // Only continue if you have something further to parse!
    if( *lpArgList == ',' )
    {
        *lpArgList++;

        nID = 0;

        // Parse for ID's
        while( *lpArgList && (*lpArgList != ',') )
        {
            nID *= 10;
            nID += *lpArgList++ - '0';
        }

        // Check for error cases!
        if( (nID < 1) || (nID > NUMJOYDEVS) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("JOY.CPL: Command line Device ID out of range!\n"));
#endif
            nID = (NUMJOYDEVS<<1);

            return;
        }

        // Decrement to internal zero based ID
        nID--;

        // Don't parse what you don't have!
        if( *lpArgList == ',' )
        {
            *lpArgList++;

            // Lastly, parse for nStartPageDef!
            while( *lpArgList && (*lpArgList != ',') )
            {
                nStartPageDef *= 10;
                nStartPageDef += *lpArgList++ - '0';
            }
        }
    } else {
        nID = (NUMJOYDEVS<<1);
    }

    // Done with the parsing...
    // Time to get to work!

    // if we're not showing the CPL...
    if( !bShowCPL )
    {
        // check to make sure the next value is a 1
        // we may want to have further negative arguments :)
        switch( nStartPageCPL )
        {
        case 1:
            // Invalid ID...
            if( nID > NUMJOYDEVS ) return;
            LaunchExtention(hDlg);
            break;

#ifdef WE_CAN_HAVE_CREDITS
        case 60:
            // If they ask for the splash, they don't get the CPL!
            DialogBox( ghInstance, (PTSTR)IDD_SPLASH, hDlg, (DLGPROC)SplashDialogProc );
            break;
#endif
            
        }

    } else {
        DoProperties(NULL, nStartPageCPL); 
    }
}


#ifdef WE_CAN_HAVE_CREDITS
BOOL WINAPI SplashDialogProc(HWND hDlg, ULONG uMsg, WPARAM wParam, LPARAM lParam)
{
    static CCreditStatic *pStatic;

    switch( uMsg )
    {
    case WM_INITDIALOG:
        {
            pStatic = new (CCreditStatic);
            ASSERT (pStatic);

            CWnd *pCWnd = new (CWnd);
            ASSERT (pCWnd);

            pCWnd->Attach(hDlg);

            pStatic->SubclassDlgItem(IDC_MYSTATIC, pCWnd);

            if( pCWnd )
            {
                pCWnd->Detach();
                delete (pCWnd);
                pCWnd = 0;
            }

            LPTSTR lpStr = new (TCHAR[MAX_STR_LEN]);
            ASSERT (lpStr);

            // The Credits come in two lines!
            BYTE nStrLen = (BYTE)LoadString(ghInstance, IDS_SPLASH, lpStr, MAX_STR_LEN);
            LoadString(ghInstance, IDS_SPLASH1, &lpStr[nStrLen], MAX_STR_LEN-nStrLen);

            pStatic->SetCredits(lpStr);

            if( lpStr )
            {
                delete[] (lpStr);
                lpStr = 0;
            }

            pStatic->StartScrolling();
        }
        return(TRUE);  // return TRUE unless you set the focus to a control
        // EXCEPTION: OCX Property Pages should return FALSE}

    case WM_COMMAND:
        switch( LOWORD(wParam) )
        {
        case IDOK:
            EndDialog(hDlg, LOWORD(wParam));
            break;
        }
        break;

//		case WM_TIMER:
        //SendDlgItemMessage(hDlg, IDC_STATIC, WM_TIMER, 0, 0);
//			pStatic->OnTimer(150); //DISPLAY_TIMER_ID
//			break;

    case WM_DESTROY:
        if( pStatic )
        {
            delete (pStatic);
            pStatic = 0;
        }
        break;
    }     

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\joyarray.h ===
#include "joyhelp.h"
#include "resource.h"

const DWORD gaHelpIDs[]=
{
    IDC_BTN_PROPERTIES,     IDH_101_1002,   // Game Controllers: "&Properties..." (Button)
    IDC_BTN_TSHOOT,         IDH_101_1036,   // Trouble Shoot Button
    IDC_LIST_DEVICE,        IDH_101_1058,   // Game Controllers: "List1" (SysListView32)
    IDC_LIST_HEADING,       IDH_101_1058,   // Game Controllers: "&Game Controllers" (Static)
    IDC_BTN_REMOVE,         IDH_101_1028,   // Game Controllers: "&Remove..." (Button)
    IDC_BTN_ADD,            IDH_101_1010,   // Game Controllers: "A&dd..." (Button)
    IDC_BTN_REFRESH,        IDH_101_1022,   // Game Controllers: "Refresh" (Button)
    IDC_POLLFLAGS,          IDH_117_1100,   // -: "P&oll with interrupts enabled" (Button)
    IDC_COMBO1,             IDH_117_1101,   // -: "" (ComboBox)
    IDC_TEXT_PORTDRIVER,    IDH_117_1101,   // -: "&Port Driver:" (Static)
    IDC_GAMEPORT,           IDH_117_1101,   // 
    IDC_GAMEPORTLIST,       IDH_117_1101,   // 
    IDC_ADV_LIST_DEVICE,    IDH_117_8197,   // -: "" (ListBox)
    IDC_ADV_CHANGE,         IDH_117_8198,   // -: "Cha&nge..." (Button)
    IDC_ADV_USEOEMPAGE,     IDH_117_8199,   // Advanced: OEM property sheet check box
    IDC_ADD_NEW,            IDH_119_1039,   // Add Game Controller: "&Add Other..." (Button)
    IDC_CUSTOM,             IDH_119_1049,   // Add's Custom button!
    IDC_DEVICE_LIST_TAG,    IDH_119_1059,   // Add Game Controller: "&Controllers:" (Static)
    IDC_DEVICE_LIST,        IDH_119_1059,   // Add Game Controller: "List1" (SysListView32)
    IDC_COMBO_AXIS,         IDH_4099_1043,  // Custom Game Controller: "" (ComboBox)
    IDC_HASRUDDER,          IDH_4099_1044,  // Rudder checkbox from Custom Page
    IDC_COMBO_BUTTONS,      IDH_4099_1045,  // Custom Game Controller: "" (ComboBox)
    IDC_HASZAXIS,           IDH_4099_1046,  // Z Axis checkbox from Custom Page
    IDC_SPECIAL_YOKE,       IDH_4099_1051,  // Custom Game Controller: "Is a flight yoke/stick" (Button)
    IDC_SPECIAL_PAD,        IDH_4099_1052,  // Custom Game Controller: "Is a game pad" (Button)
    IDC_SPECIAL_AUTO,       IDH_4099_1053,  // Custom Game Controller: "Is a race car controller" (Button)
    IDS_CUSTOM_HASPOV,      IDH_4099_1054,  // Custom Game Controller: "Has a &point of view control" (Button)
    IDC_CUSTOM_NAME,        IDH_4099_1056,  // Custom Game Controller: "" (Edit)
    IDC_EDIT_NAME,          IDH_4099_1056,  // Custom Game Controller: "" (Edit)
    IDC_SPECIAL_JOYSTICK,   IDH_4099_1058,  // Custom Game Controller: "Is a Joystick" (Button)
    IDC_JOY1HASRUDDER,      IDH_4201_1019,  // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
    IDC_SPIN,               IDH_8188_8189,  // Spin button in Advanced page Change dialog!
    IDC_SPINBUDDY,          IDH_8188_8189,  // Spin button in Advanced page Change dialog!
    IDC_SELECTEDID,         IDH_8188_8191,  // Change Controller Assignment: "Selected ID" (ListBox)
    IDC_CHANGE_LIST,        IDH_8188_8194,  // Change Controller Assignment: "" (ListBox)
    IDC_LISTTXT,            IDH_8188_8194,
    IDC_ADV_GRP,            (DWORD)-1,
    IDC_ADV_GRP2,           (DWORD)-1,
    IDC_TEXT_DRIVER,        (DWORD)-1,
    IDC_ADD_STR1,           (DWORD)-1,
    IDC_ADD_STR2,           (DWORD)-1,
    IDC_GEN_ICON,           (DWORD)-1,
    IDC_GEN_INTRO,          (DWORD)-1,
    IDC_ASSIGNTXT,          (DWORD)-1,
    IDC_TEXT_TITLE,         (DWORD)-1,
    IDC_SEPERATOR,          (DWORD)-1,
    IDC_AXES_GROUP,         (DWORD)-1,  // Custom Game Controller: "&Axes" (Button)
    IDC_BUTTONS_GROUP,      (DWORD)-1,  // Custom Game Controller: "" (ComboBox)
    IDC_SPECIAL_GROUP,      (DWORD)-1,  // Custom Game Controller: "&Special Characteristics" (Button)

    IDC_VOICECHATGROUP,	    (DWORD)-1,
    IDC_VOICECHATTEXT,      (DWORD)-1,
    IDC_GAMESLISTHOTKEY,    (DWORD)-1,

    IDC_LIST_GAMES,         IDH_VOICE_LIST_GAMES,
    IDC_DETAILS,            IDH_VOICE_DETAILS,
	
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\joyhelp.h ===
#define IDH_101_1002    65667173    // Game Controllers: "&Properties..." (Button)
#define IDH_101_1022    65667180    // Game Controllers: "Refresh" (Button)
#define IDH_101_1010    66191461    // Game Controllers: "A&dd..." (Button)
#define IDH_101_1028    67371109    // Game Controllers: "&Remove..." (Button)
#define IDH_101_1036    67548653    // Game Controllers: "Troubleshoot..." (Button)
#define IDH_101_1058    69337189    // Game Controllers: "&Game Controllers" (Static)

#define IDH_117_1100    72089717    // -: "P&oll with interrupts enabled" (Button)
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_117_8195    537067637   // -: "&Controller ID's:" (Static)
#define IDH_117_8196    537133173   // -: "Game Controllers:" (Static)
#define IDH_117_8197    537198709   // -: "" (ListBox)
#define IDH_117_8198    537264245   // -: "Cha&nge..." (Button)
#define IDH_117_8199    537385268   // Advanced: OEM property sheet check box

#define IDH_119_1039    68092023    // Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049    68092025    // Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059    69402743    // Add Game Controller: "&Controllers:" (Static)

#define IDH_4099_1043   68358147    // Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1044   68358149    // Custom Game Controller: Rudder/Pedals (Button)
#define IDH_4099_1046   68358151    // Custom Game Controller: Z Axis (Button)
#define IDH_4099_1045   68685827    // Custom Game Controller: "" (ComboBox)
#define IDH_4099_1051   68882435    // Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052   68947971    // Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053   69013507    // Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1054   69079043    // Custom Game Controller: "Has a &point of view control" (Button)
#define IDH_4099_1056   69210115    // Custom Game Controller: "" (Edit)
#define IDH_4099_1058   69410157    // Custom Game Controller: "Is a Joystick" (Button)

#define IDH_4201_1019   66785385    // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)

#define IDH_8188_8189   536682492   // Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191   537010170   // Change Controller Assignment: "Selected ID" (ListBox) (Label?)
#define IDH_8188_8194   537010172   // Change Controller Assignment: "" (ListBox)

#define IDH_APPMAN_EXCLUDEDRIVE_INSTRUCTIONS		    2768L
#define IDH_APPMAN_RESTOREDEFAULTS_INSTRUCTIONS		  2767L
#define IDH_APPMAN_DISKUSAGE_SETTING_INSTRUCTIONS   2766L
#define IDH_VOICE_LIST_GAMES						            2765L
#define IDH_VOICE_DETAILS							              2764L

/*
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_101_1002    65667173    // Game Controllers: "&Properties..." (Button)
#define IDH_101_1022    65667180    // Game Controllers: "Refresh" (Button)
#define IDH_101_1010    66191461    // Game Controllers: "A&dd..." (Button)
#define IDH_101_1028    67371109    // Game Controllers: "&Remove..." (Button)
#define IDH_101_1058    69337189    // Game Controllers: "&Game Controllers" (Static)
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_117_8195    537067637   // -: "&Controller ID's:" (Static)
#define IDH_117_8196    537133173   // -: "Game Controllers:" (Static)
#define IDH_117_8197    537198709   // -: "" (ListBox)
#define IDH_117_8198    537264245   // -: "Cha&nge..." (Button)
#define IDH_119_1039    68092023    // Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049    68092025    // Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059    69402743    // Add Game Controller: "&Controllers:" (Static)
#define IDH_4099_1043   68358147    // Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1048   68685827    // Custom Game Controller: "" (ComboBox)
#define IDH_4099_1050   68816899    // Custom Game Controller: "&Special Characteristics" (Button)
#define IDH_4099_1051   68882435    // Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052   68947971    // Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053   69013507    // Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1054   69079043    // Custom Game Controller: "Has a &point of view control" (Button)
#define IDH_4099_1056   69210115    // Custom Game Controller: "" (Edit)
#define IDH_4101_12293  805638149   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12308  806621189   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12309  806686725   // Joystick Calibration: "f" (Static)
#define IDH_4101_12328  807931909   // Joystick Calibration: "Capture &POV" (Button)
#define IDH_4101_12329  807997445   // Joystick Calibration: "< &Back" (Button)
#define IDH_4101_12330  808062981   // Joystick Calibration: "&Next >" (Button)
#define IDH_4101_12331  808062983   // Joystick Calibration: "&Finish" (Button)
#define IDH_4101_12334  808325125   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12347  809177093   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12349  809308165   // Joystick Calibration: "" (ListBox)
#define IDH_4201_1019   66785385    // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12291  805507177   // Settings: "&Calibrate..." (Button)
#define IDH_4202_12293  805638250   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_12308  806621290   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_12328  807932010   // Game Controller Calibration: "Set &POV" (Button)
#define IDH_4202_12334  808325226   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_8199   537333866   // Game Controller Calibration: "Calibration Information" (Button)
#define IDH_4203_1023   67047531    // -: "Buttons" (Button)
#define IDH_4203_12293  805638251   // -: "" (ListBox)
#define IDH_4203_12308  806621291   // -: "" (ListBox)
#define IDH_4203_12309  806686827   // -: "" (POVHAT)
#define IDH_4203_12334  808325227   // -: "" (ListBox)
#define IDH_4203_12347  809177195   // -: "" (ListBox)
#define IDH_4203_12349  809308267   // -: "" (ListBox)
#define IDH_4203_12350  809308265   // -: "" (Listbox--Slider 1)
#define IDH_4203_12351  809308269   // -: "" (Listbox--Slider 2)
#define IDH_8188_8189   536682492   // Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191   537010170   // Change Controller Assignment: "Selected ID" (ListBox)
#define IDH_8188_8194   537010172   // Change Controller Assignment: "" (ListBox)
#define IDH_4099_1046   68358149    // 
#define IDH_4099_1044   68358151    //
#define IDH_101_1036    67548653    //
#define IDH_4099_1058   69410157    //
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\retrocfg.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       retrocfg.cpp
 *  Content:    Implement the RetroConfigProcess function, and supporting functions
 *  History:
 *	Date   By  Reason
 *	============
 *	10/13/99	pnewson		created
 *  10/27/99    pnewson     Fix: Bug #113692 & #113943 - support for new dplay app flags
 *  11/04/99	pnewson 	Bug #115279 - added HWND to check audio setup calls
 *										- call audio setup automatically when retrofit enabled
 *  12/03/99	scottle		Merged into joy.cpl, and handed to pnewson to bug fix.
 *  01/25/2000	pnewson 	Removed "unlisted games" checkbox
 *  02/15/2000	pnewson 	Assorted bug fixes:
 *							millen 131837
 *							millen 131794
 *							millen 131889
 *  03/23/2000  rodtoll		Changed include dsound.x --> dsprv.h
 *  04/05/2000  pnewson		Changed format of "More Information" dialog box.
 *  04/10/2000  pnewson		changes to make 64bit builds work.
 *  06/21/2000	rodtoll		Bug #36213 - DX8 options panel should only appear on Millenium
 *							Panel will not load on any other OS.
 *				rodtoll		Bug #30776 - Game options control panel gives Unexpected error if no device is present
 *  09/28/2000	rodtoll		Bug #46003 - DPVOICE: Memory leak when joy.cpl closed without clicking voice tab
 *
 ***************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <initguid.h>
#include <mmsystem.h>
#include <dsound.h>
#include <dsprv.h> // need for GUID instances
#include "dvoice.h"
#include "resource.h"
#include "retrocfg.h"
#include "dndbg.h"
#include "creg.h"
#include "dvosal.h"
#include <commctrl.h>
#include <shellapi.h>
#include <windowsx.h>
#include "joyarray.h"

#include "..\\..\\..\\dplay\\dplobby\\dplobby\\dplobby.h"


INT_PTR CALLBACK RetrofitProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR RetrofitInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR RetrofitSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR RetrofitApplyHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR RetrofitResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR RetrofitDetailsHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR RetrofitDestroyHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK WizardCancelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WizardLaunchProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ConfirmHalfDuplexProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SoundInitFailureProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WizardErrorProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK VoiceEnabledProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DetailsProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PrevHalfDuplexProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK ListViewSubclassProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR ListViewLButtonDownHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR ListViewLButtonDblClkHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR ListViewKeydownHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

void ClearAllCheckboxes(HWND hDlg, HWND hwndListView, LONG lNumItems);
void MySetCheckState(HWND hwnd, int iItem, BOOL bChecked);
BOOL MyGetCheckState(HWND hwnd, int iItem);
BOOL MyToggleCheckState(HWND hwnd, int iItem);

static void RetrofitOnAdvHelp       (LPARAM);
static void RetrofitOnContextMenu   (WPARAM wParam, LPARAM lParam);

// These defines have been repeated here instead of inclucing dplobpr.h
// because it causes build problems.
#define DPLAY_REGISTRY_APPS 	L"Software\\Microsoft\\DirectPlay\\Applications"
#define REGSTR_VAL_FLAGS		L"dwFlags"
#define REGSTR_VAL_FILE 		L"File"
#define REGSTR_VAL_PATH 		L"Path"

#define MAX_ICONS 2048


// Gasp! globals!
HIMAGELIST g_himagelist = NULL;
int g_iCheckboxEmptyIndex;
int g_iCheckboxFullIndex;
HINSTANCE g_hResDLLInstance;
LPDIRECTPLAYVOICETEST g_IDirectPlayVoiceSetup = NULL;
#define COLUMN_HEADER_SIZE 32
TCHAR g_tstrColumnHeader1[COLUMN_HEADER_SIZE];
TCHAR g_tstrColumnHeader2[COLUMN_HEADER_SIZE];
WNDPROC g_ListViewProc;
#define MESSAGE_BOX_SCRATCH_SIZE 128

// From Main.cpp
extern HINSTANCE ghInstance;

// externals for context help
extern const DWORD gaHelpIDs[];

typedef HRESULT (* PFGETDEVICEID)(LPCGUID, LPGUID);

#undef DPF_MODNAME
#define DPF_MODNAME "DPVoiceCheckForDefaultDevices"
// DPVoiceCheckForDefaultDevices
//
// This function returns DV_OK if this system has at least a single playback 
// and recording device.
//
HRESULT DPVoiceCheckForDefaultDevices() 
{
	HRESULT hr = DV_OK;
	HMODULE hModule = NULL;
	PFGETDEVICEID pfGetDeviceID = NULL;

	GUID guidTmp;

	hModule = LoadLibraryA("dsound.dll");

	if (!hModule)
	{
		hr = GetLastError();
		DPF(DVF_ERRORLEVEL, "Error loading dsound.dll - 0x%x", hr);
		goto CHECKDEVICE_ERROR;
	}

	// attempt to get a pointer to the GetDeviceId function
	pfGetDeviceID = (PFGETDEVICEID)GetProcAddress(hModule, "GetDeviceID");

	if( !pfGetDeviceID )
	{
		hr = GetLastError();
		DPF(DVF_ERRORLEVEL, "Error getting default devices - 0x%x", hr );
		hr = DVERR_GENERIC;
		goto CHECKDEVICE_ERROR;
	}

	hr = (*pfGetDeviceID)( &DSDEVID_DefaultPlayback, &guidTmp );

	if( FAILED( hr ) )
	{
		DPF( DVF_ERRORLEVEL, "Error getting default playback device hr=0x%x", hr );
		goto CHECKDEVICE_ERROR;
	}

	hr = (*pfGetDeviceID)( &DSDEVID_DefaultCapture, &guidTmp );

	if( FAILED( hr ) )
	{
		DPF( DVF_ERRORLEVEL, "Error getting default capture device hr=0x%x", hr );
		goto CHECKDEVICE_ERROR;
	}

CHECKDEVICE_ERROR:

	if( hModule )
		FreeLibrary( hModule );

	DPF_EXIT();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DPVoiceCheckOS"
// DPVoiceCheckOS
//
// This function returns DV_OK if this is a platform the retrofit runs on.
//
// This function will return DVERR_GENERIC if this is a platform the retrofit does not
// run on.
//
HRESULT DPVoiceCheckOS()
{
	OSVERSIONINFO osVerInfo;
	LONG lLastError;

	osVerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

	if( GetVersionEx( &osVerInfo ) )
	{
		// Win2K
		if( osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
		{
			// NOTE: If we enable Whistler support we have to ensure that this returns an error
			// 		 if we're booting in safe-mode!
			/*
			// Whistler -- Major Version = 5 & Build # > 2195
			if( osVerInfo.dwMajorVersion == 5 && osVerInfo.dwBuildNumber > 2195 )
			{
				return DV_OK;
			}*/

			return DVERR_GENERIC;
		}
		// Win9X
		else
		{
			// Millenium Major = 4, Minor = 90
			if( (HIBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 90) )
			{
				return DV_OK;
			}

			return DVERR_GENERIC;
		}
	}
	else
	{
		lLastError = GetLastError();

		DPF( 0, "Error getting version info: 0x%x", lLastError );
		return DVERR_GENERIC;
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DVoiceCPLInit"
HRESULT DVoiceCPLInit(void)
{
	DPF_ENTER();
	HRESULT hr = S_OK;

	GUID guidTmp;

	g_hResDLLInstance = ghInstance;

	// Check to ensure we're on Millenium or Whistler.  If we aren't we want to hide this
	// control panel.
	//
	hr = DPVoiceCheckOS();

	if( FAILED( hr ) )
	{
		DPF( DVF_ERRORLEVEL, "Error checking OS.  Not a supported OS hr=0x%x", hr );
		return hr;
	}

	// Check to ensure there is at least a default playback and default capture device in the 
	// system.  If there is not we want to hide the control panel.
	//
	hr = DPVoiceCheckForDefaultDevices();

	if( FAILED( hr ) )
	{
		DPF( DVF_ERRORLEVEL, "Error checking for play/cap device hr=0x%x", hr );
		return hr;
	}	

	if (FAILED(CoInitialize(NULL)))
    {
	  	DPF_EXIT();
      	return E_FAIL;
    }

	hr = CoCreateInstance(CLSID_DirectPlayVoiceTest, 
				NULL, 
				CLSCTX_INPROC_SERVER, 
				IID_IDirectPlayVoiceTest, 
				(LPVOID *) &g_IDirectPlayVoiceSetup);

	if( FAILED( hr ) )
	{
		DPF( DVF_ERRORLEVEL, "Failed to create test interface hr=0x%x", hr );
		DPF_EXIT();
		return hr;
	}

	DPF_EXIT();
	return hr;
} // End DVoiceCPLInit();


#undef DPF_MODNAME
#define DPF_MODNAME "RetrofitProc"
INT_PTR CALLBACK RetrofitProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	INT_PTR fRet;

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		fRet = RetrofitInitDialogHandler(hDlg, message, wParam, lParam); 
		break;

	case WM_NOTIFY :
		{
		LPNMHDR lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
			{
			case PSN_SETACTIVE : 
				fRet = RetrofitSetActiveHandler(hDlg, message, wParam, lParam);
				break;

			case PSN_APPLY :
				fRet = RetrofitApplyHandler(hDlg, message, wParam, lParam);
				break;

			case PSN_RESET :
				fRet = RetrofitResetHandler(hDlg, message, wParam, lParam);
				break;

			case LVN_ITEMCHANGED :
				PropSheet_Changed(GetParent(hDlg), hDlg);
				fRet = TRUE;
				break;

			default :
				break;
			}
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_DETAILS:
			fRet = RetrofitDetailsHandler(hDlg, message, wParam, lParam);
			break;
		}
		break;

	case WM_DESTROY:
		fRet = RetrofitDestroyHandler(hDlg, message, wParam, lParam);
		break;

    case WM_HELP:
        RetrofitOnAdvHelp(lParam);
        return(TRUE);

    case WM_CONTEXTMENU:
        RetrofitOnContextMenu(wParam, lParam);
        return(TRUE);

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "RetrofitInitDialogHandler"
INT_PTR RetrofitInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	CRegistry cregApps;
	CRegistry cregApp;
	DWORD dwIndex;
	DWORD dwListViewIndex;
    WCHAR swzBuffer[MAX_REGISTRY_STRING_SIZE];
    TCHAR tszBuffer[MAX_REGISTRY_STRING_SIZE];
    WCHAR swzFilename[MAX_REGISTRY_STRING_SIZE];
    WCHAR swzPath[MAX_REGISTRY_STRING_SIZE];
    TCHAR tszFilename[MAX_REGISTRY_STRING_SIZE];
    TCHAR tszPathAndFile[MAX_REGISTRY_STRING_SIZE * 2 + 1];
    DWORD dwStrLen;
    HKEY hkApps;
    LONG lRet;
    HRESULT hr;
    LVITEM lvitem;
    LVCOLUMN lvcolumn;
    RECT rect;
    HWND hwndListView;
    HICON hiLarge;
    HICON hiSmall;
    int iIconXSize;
    int iIconYSize;
    int iIconIndex;
    int iScrollWidth;
    DWORD dwGlobalFlags;
    HICON hiconDefault;
    HDC hdc;
    TEXTMETRIC tm;
    int iChars;

	// create the image list for the icons
	iIconXSize = GetSystemMetrics(SM_CXSMICON);
	if (iIconXSize == 0)
	{
		lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "GetSystemMetrics failed, code: %i", lRet);
		goto error_level_0;
	}

	iIconYSize = GetSystemMetrics(SM_CYSMICON);
	if (iIconYSize == 0)
	{
		lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "GetSystemMetrics failed, code: %i", lRet);
		goto error_level_0;
	}

	g_himagelist = ImageList_Create(iIconXSize, iIconYSize, ILC_MASK, 0,  MAX_ICONS);
	if (g_himagelist == NULL)
	{
		lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "ImageList_Create failed, code: %i", lRet);
		goto error_level_0;
	}

	// Load the default icon for the image list
	hiconDefault = LoadIcon(g_hResDLLInstance, MAKEINTRESOURCE(IDI_LIST_DEFAULT));
	if (hiconDefault == NULL)
	{
		lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "LoadIcon failed, code: %i", lRet);
		goto error_level_0;
	}

	// get a handle to the list view control
	hwndListView = GetDlgItem(hDlg, IDC_LIST_GAMES);
	if (hwndListView == NULL)
	{
		lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		goto error_level_0;
	}

	// subclass the list view
	g_ListViewProc = (WNDPROC)SetWindowLongPtr(hwndListView, GWLP_WNDPROC, (INT_PTR)ListViewSubclassProc);
	if (g_ListViewProc == NULL)
	{
		lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "SetWindowLong failed, code: %i", lRet);
		goto error_level_0;
	}

	// add the enable column to the list view control
	hdc = GetDC(hDlg);
	if (hdc == NULL)
	{
		DPF(DVF_ERRORLEVEL, "GetDC failed");
		goto error_level_0;
	}
	if (GetTextMetrics(hdc, &tm) == 0)
	{
		DPF(DVF_ERRORLEVEL, "GetTextMetrics failed");
		goto error_level_0;
	}
	
	ZeroMemory(&lvcolumn, sizeof(lvcolumn));
	lvcolumn.mask = LVCF_ORDER|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM;
	lvcolumn.iOrder = 1;
	lvcolumn.iSubItem = 1;
	ZeroMemory(g_tstrColumnHeader2, COLUMN_HEADER_SIZE*sizeof(TCHAR));
	iChars = LoadString(g_hResDLLInstance, 
		IDS_ENABLED_COLUMN_HEADER, 
		g_tstrColumnHeader2, 
		COLUMN_HEADER_SIZE);
	if (iChars == 0)
	{
		DPF(DVF_ERRORLEVEL, "LoadString failed");
		goto error_level_0;
	}
	
	lvcolumn.pszText = g_tstrColumnHeader2;
	lvcolumn.cx = tm.tmAveCharWidth * iChars;
	
	if (ListView_InsertColumn(hwndListView, 1, &lvcolumn) == -1)
	{
		DPF(DVF_ERRORLEVEL, "ListView_InsertColumn failed");
		goto error_level_0;
	}

	// add the game column to the list view control
	ZeroMemory(&lvcolumn, sizeof(lvcolumn));
	lvcolumn.mask = LVCF_ORDER|LVCF_WIDTH|LVCF_TEXT;
	lvcolumn.iOrder = 0;

	if (!GetClientRect(hwndListView, &rect))
	{
		lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "GetClientRect failed, code: %i", lRet);
		goto error_level_0;
	}
	iScrollWidth = GetSystemMetrics(SM_CXVSCROLL);
	if (iScrollWidth == 0)
	{
		DPF(DVF_ERRORLEVEL, "GetSystemMetrics failed");
		goto error_level_0;
	}
	lvcolumn.cx = rect.right - rect.left - iScrollWidth - (iChars * tm.tmAveCharWidth);	
	
	ZeroMemory(g_tstrColumnHeader1, COLUMN_HEADER_SIZE*sizeof(TCHAR));
	iChars = LoadString(g_hResDLLInstance, 
		IDS_GAMES_COLUMN_HEADER, 
		g_tstrColumnHeader1, 
		COLUMN_HEADER_SIZE);
	if (iChars == 0)
	{
		DPF(DVF_ERRORLEVEL, "LoadString failed");
		goto error_level_0;
	}
	lvcolumn.pszText = g_tstrColumnHeader1;
	
	if (ListView_InsertColumn(hwndListView, 0, &lvcolumn) == -1)
	{
		DPF(DVF_ERRORLEVEL, "ListView_InsertColumn failed");
		goto error_level_0;
	}

	// put checkboxes into the list view control
	//ListView_SetExtendedListViewStyle(hwndListView, LVS_EX_CHECKBOXES);	
	ListView_SetExtendedListViewStyle(hwndListView, LVS_EX_SUBITEMIMAGES);

	// add the small image list to the list view control
	ListView_SetImageList(hwndListView, g_himagelist, LVSIL_SMALL);

	// add icons to the image list for selected and cleared checkboxes
	hiSmall = (HICON)LoadImage(
		g_hResDLLInstance, 
		MAKEINTRESOURCE(IDI_CHECKBOX_EMPTY), 
		IMAGE_ICON,
		iIconXSize,
		iIconYSize,
		LR_SHARED);
	if (hiSmall == NULL)
	{
		DPF(DVF_ERRORLEVEL, "Unable to load empty checkbox icon resource");
		goto error_level_0;
	}
	g_iCheckboxEmptyIndex = ImageList_AddIcon(g_himagelist, hiSmall);
	if (g_iCheckboxEmptyIndex == -1)
	{
		DPF(DVF_ERRORLEVEL, "Unable to add empty checkbox icon to image list");
		goto error_level_0;
	}
	hiSmall = (HICON)LoadImage(
		g_hResDLLInstance, 
		MAKEINTRESOURCE(IDI_CHECKBOX_FULL), 
		IMAGE_ICON,
		iIconXSize,
		iIconYSize,
		LR_SHARED);
	if (hiSmall == NULL)
	{
		DPF(DVF_ERRORLEVEL, "Unable to load full checkbox icon resource");
		goto error_level_0;
	}
	g_iCheckboxFullIndex = ImageList_AddIcon(g_himagelist, hiSmall);
	if (g_iCheckboxFullIndex == -1)
	{
		DPF(DVF_ERRORLEVEL, "Unable to add full checkbox icon to image list");
		goto error_level_0;
	}
	
	// open the applications area of the registry
	if (!cregApps.Open(HKEY_LOCAL_MACHINE, DPLAY_REGISTRY_APPS, FALSE))
	{
		DPF(DVF_ERRORLEVEL, "Unable to open DirectPlay applications registry key");
		goto error_level_0;
	}
	hkApps = cregApps.GetHandle();

	// default the global checkbox to off
	/*
	if (!CheckDlgButton(hDlg, IDC_UNLISTEDCHECK, FALSE))
	{
		DPF(DVF_ERRORLEVEL, "Unable to clear unlisted games enable checkbox");
		// don't bail, continue
	}
	*/
	
	// get the dwFlags value from the root of the applications area
	if (cregApps.ReadDWORD(REGSTR_VAL_FLAGS, dwGlobalFlags))
	{
		// set the checkbox if indicated
		/*
		if (dwGlobalFlags & DPLAPP_AUTOVOICE)
		{
			if (!CheckDlgButton(hDlg, IDC_UNLISTEDCHECK, TRUE))
			{
				DPF(DVF_ERRORLEVEL, "Unable to clear unlisted games enable checkbox");
				// don't bail, continue
			}
		}
		*/
	}
	else
	{
		DPF(DVF_ERRORLEVEL, "Unable to read flags DirectPlay applications registry key");
		// don't bail, continue
	}

	// enum the apps and add them to the list box
	dwIndex = 0;
	dwListViewIndex = 0;
	while(1)
	{
		dwStrLen = MAX_REGISTRY_STRING_SIZE;
		if (!cregApps.EnumKeys(swzBuffer, &dwStrLen, dwIndex))
		{
			// that's all, we're done.
			break;
		}

		if (!cregApp.Open(hkApps, swzBuffer, FALSE))
		{
			DPF(DVF_ERRORLEVEL, "Unable to open application registry key");
			continue;
		}

		// get the app flags so we know if we want
		// to add this item to the list.
		DWORD dwFlags;
		if (!cregApp.ReadDWORD(REGSTR_VAL_FLAGS, dwFlags))
		{
			DPF(DVF_ERRORLEVEL, "CRegistry::ReadDWORD failed");
			// forgive this error, since apps registered with
			// older versions of DirectPlay will not have 
			// flags entries, set dwFlags to zero.
			dwFlags = 0;
		}

		if (dwFlags & DPLAPP_NOENUM || dwFlags & DPLAPP_SELFVOICE)
		{
			// This app is either hidden, or implements it's own
			// voice comms. We don't want to add it to the list,
			// so continuue with the next iteration.
			++dwIndex;
			cregApp.Close();
			continue;
		}

		// get the name of the key in a TCHAR
		if (!OSAL_WideToTChar(tszBuffer, swzBuffer, MAX_REGISTRY_STRING_SIZE))
		{
			DPF(DVF_ERRORLEVEL, "OSAL_WideToAnsi failed");
			++dwIndex;
			cregApp.Close();
			continue;
		}

		// get the application's icon
		dwStrLen = MAX_REGISTRY_STRING_SIZE;
		if (!cregApp.ReadString(REGSTR_VAL_FILE, swzFilename, &dwStrLen))
		{
			DPF(DVF_ERRORLEVEL, "CRegistry::ReadString failed");
			++dwIndex;
			cregApp.Close();
			continue;
		}

		hr = OSAL_WideToTChar(tszFilename, swzFilename, dwStrLen);
		if (FAILED(hr))
		{
			DPF(DVF_ERRORLEVEL, "OSAL_WidToAnsi failed, code: %i", hr);
			++dwIndex;
			cregApp.Close();
			continue;
		}

		dwStrLen = MAX_REGISTRY_STRING_SIZE;
		if (!cregApp.ReadString(REGSTR_VAL_PATH, swzPath, &dwStrLen))
		{
			DPF(DVF_ERRORLEVEL, "CRegistry::ReadString failed");
			++dwIndex;
			cregApp.Close();
			continue;
		}

		if (!cregApp.Close())
		{
			DPF(DVF_ERRORLEVEL, "CRegistry::Close failed");
			++dwIndex;
			continue;
		}

		hr = OSAL_WideToTChar(tszPathAndFile, swzPath, MAX_REGISTRY_STRING_SIZE);
		if (FAILED(hr))
		{
			DPF(DVF_ERRORLEVEL, "OSAL_AllocAndConvertToANSI failed, code: %i", hr);
			++dwIndex;
			continue;
		}

		if (tszPathAndFile[_tcslen(tszPathAndFile)-1] != '\\')
		{
			// since there isn't one there, tack on the trailing backslash
			_tcscat(tszPathAndFile, _T("\\"));
		}
		_tcscat(tszPathAndFile, tszFilename);
		ExtractIconEx(tszPathAndFile, 0, &hiLarge, &hiSmall, 1);

		// don't need the large icon.
		if (hiLarge != NULL)
		{
			DestroyIcon(hiLarge);
		}

		// add the small icon to the image list if it is valid
		if (hiSmall != NULL)
		{
			iIconIndex = ImageList_AddIcon(g_himagelist, hiSmall);
		}
		else
		{
			iIconIndex = ImageList_AddIcon(g_himagelist, hiconDefault);
		}
		
		if (iIconIndex == -1)
		{
			lRet = GetLastError();
			DPF(DVF_ERRORLEVEL, "ImageList_AddIcon failed, code: %i", lRet);
			++dwIndex;
			continue;
		}

		lvitem.mask = LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
		lvitem.iImage = iIconIndex;

		if (hiSmall != NULL)
		{
			DestroyIcon(hiSmall);
		}
		
		lvitem.iItem = dwListViewIndex;
		lvitem.iSubItem = 0;
		lvitem.state = 0;
		lvitem.stateMask = 0;
		lvitem.pszText = tszBuffer;
		lvitem.cchTextMax = 0;
		lvitem.lParam = dwFlags;
		lvitem.iIndent = 0;
		if (ListView_InsertItem(hwndListView, &lvitem) == -1)
		{
			DPF(DVF_ERRORLEVEL, "ListView_InsertItem failed");
			++dwIndex;
			continue;
		}

		lvitem.mask = LVIF_IMAGE;
		lvitem.iItem = dwListViewIndex;
		lvitem.iSubItem = 1;
		// check the flags to see if this item should be initially selected
		if (dwFlags & DPLAPP_AUTOVOICE)
		{
			// select this item in the list
			lvitem.iImage = g_iCheckboxFullIndex;
		}
		else
		{
			lvitem.iImage = g_iCheckboxEmptyIndex;
		}
		if (ListView_SetItem(hwndListView, &lvitem) == -1)
		{
			DPF(DVF_ERRORLEVEL, "ListView_SetItem failed");
			ListView_DeleteItem(hwndListView, dwListViewIndex);
			++dwIndex;
			continue;
		}

		++dwIndex;
		++dwListViewIndex;
	}

	if (!cregApps.Close())
	{
		DPF(DVF_ERRORLEVEL, "Unable to close DirectPlay applications registry key");
	}

	// If there is at least one item in the list, set the focus to the first item
	// in the list so it will be marked when the user first comes to this tab.
	if (dwListViewIndex > 0)
	{
		ListView_SetItemState(hwndListView, 0, LVIS_FOCUSED, LVIS_FOCUSED);
	}

	DPF_EXIT();
	return TRUE;

error_level_0:
	DPF_EXIT();
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "RetrofitSetActiveHandler"
INT_PTR RetrofitSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "RetrofitApplyHandler"
INT_PTR RetrofitApplyHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	LONG        lRet;
	LONG        lNumItems;
	LONG        lIndex;
	TCHAR       tszItemText[MAX_REGISTRY_STRING_SIZE];
	WCHAR       swzItemText[MAX_REGISTRY_STRING_SIZE];
	CRegistry   cregApps;
	CRegistry   cregApp;
	HKEY        hkApps;
	HWND        hwndListView;
	LVITEM      lvitem;
	DWORD       dwFlags;
	HRESULT     hr1;
	HRESULT     hr2;
	BOOL        fItemsSelected;
	INT_PTR     intptr;
	BOOL        fTestRun = FALSE;

	
	// Get a handle to the list view
	hwndListView = GetDlgItem(hDlg, IDC_LIST_GAMES);
	if (hwndListView == NULL)
	{
		lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		goto error_level_0;
	}

	// Get the number of items in the list view
	lNumItems = ListView_GetItemCount(hwndListView);

	// Prescan the list to see if any items have been
	// checked off.
	fItemsSelected = FALSE;
	lvitem.mask = LVIF_IMAGE;
	lvitem.iSubItem = 1;
	for (lIndex = 0; lIndex < lNumItems; ++lIndex)
	{
		lvitem.iItem = lIndex;
		if (!ListView_GetItem(hwndListView, &lvitem))
		{
			DPF(DVF_ERRORLEVEL, "ListView_GetItem failed");
			goto error_level_0;			
		}
		
		if (lvitem.iImage == g_iCheckboxFullIndex)
		{
			fItemsSelected = TRUE;
		}
	}

	// look at the checkbox for unlisted games as well
	/*
	if (IsDlgButtonChecked(hDlg, IDC_UNLISTEDCHECK) == BST_CHECKED)
	{
		fItemsSelected = TRUE;
	}
	*/

	if (fItemsSelected)
	{
		// Before we allow the user to enable the retrofit, we are going
		// to make sure that setup has been run on the default
		// devices, and run it forcibly if required.
		hr1 = g_IDirectPlayVoiceSetup->CheckAudioSetup(&DSDEVID_DefaultVoicePlayback, &DSDEVID_DefaultVoiceCapture, NULL, DVFLAGS_QUERYONLY);
		switch (hr1)
		{
		case DV_FULLDUPLEX:
			// The sound hardware is fine, do nothing special.
			break;

		case DV_HALFDUPLEX:
			// The wizard has been run before, but the result was half duplex.
			// Give the user the option to run the wizard again, or continue
			// with the half duplex limitation.
			intptr = DialogBox(g_hResDLLInstance, MAKEINTRESOURCE(IDD_PREV_HALFDUPLEX),
				hDlg, PrevHalfDuplexProc);
			switch (intptr)
			{
			case IDOK:
				// the user has accepted half duplex mode, exit the control panel
				break;
			
			case IDCANCEL:
				// the use hit the X or esc. Escape back to the control panel, and
				// do not exit it
				goto error_level_1;

			case IDC_RUNTEST:
			default:
				// default should not occur, but treat as a run test
				fTestRun = TRUE;
				hr2 = g_IDirectPlayVoiceSetup->CheckAudioSetup(&DSDEVID_DefaultVoicePlayback, &DSDEVID_DefaultVoiceCapture, hDlg, 0);
				break;				
			}
			break;
			
		default:
			// With any other result, either the wizard hasn't been run, or it failed
			// really badly. Run it again, but warn the user we're about to run the wizard, 
			// and give them the chance to bail.
			if (DialogBox(g_hResDLLInstance, MAKEINTRESOURCE(IDD_WIZARD_LAUNCH),
				hDlg, WizardLaunchProc) != IDOK)
			{
				// treat this as if they bailed out of the wizard itself.
				fTestRun = TRUE;
				hr2 = DVERR_USERCANCEL;
			}
			else
			{
				fTestRun = TRUE;
				hr2 = g_IDirectPlayVoiceSetup->CheckAudioSetup(&DSDEVID_DefaultVoicePlayback, &DSDEVID_DefaultVoiceCapture, hDlg, 0);
			}
			break;
		}

		// if the test was run, deal with the results
		if (fTestRun)
		{
			switch (hr2)
			{
			case DV_FULLDUPLEX:
				// The user just exited from the wizard, so we don't want to 
				// kick them completely out of the control panel. They should
				// have to hit OK again in the control panel.
				goto error_level_1;
				break;

			case DV_HALFDUPLEX:
				// the user is only getting half duplex, confirm that they want
				// to use voice chat anyway. If they don't, clear all checkboxes
				// and don't exit the control panel.
				if (DialogBox(g_hResDLLInstance, MAKEINTRESOURCE(IDD_CONFIRM_HALFDUPLEX),
					hDlg, ConfirmHalfDuplexProc) != IDOK)
				{
					ClearAllCheckboxes(hDlg, hwndListView, lNumItems);
				}

				// The user just exited from the wizard, so we don't want to 
				// kick them completely out of the control panel. They should
				// have to hit OK again in the control panel.
				goto error_level_1;

			case DVERR_SOUNDINITFAILURE:
				// The sound test failed miserably. Let the user know they cannot use
				// voice chat, clear all the checkboxes and exit the control panel
				ClearAllCheckboxes(hDlg, hwndListView, lNumItems);
				DialogBox(g_hResDLLInstance, MAKEINTRESOURCE(IDD_CONFIRM_SOUNDINITFAILURE),
					hDlg, SoundInitFailureProc);
				goto error_level_1;
				
			case DVERR_USERCANCEL:
				// The user canceled the wizard, inform them they cannot use
				// voice chat and clear all the checkboxes. Don't exit the property sheet.
				ClearAllCheckboxes(hDlg, hwndListView, lNumItems);
				DialogBox(g_hResDLLInstance, MAKEINTRESOURCE(IDD_WIZARD_CANCELED),
					hDlg, WizardCancelProc);
				goto error_level_1;

			default:
				// Anything else is unexpect and should be treated as an error.
				// Display an error message, clear the checkboxes, and DO exit the propery sheet
				ClearAllCheckboxes(hDlg, hwndListView, lNumItems);
				DialogBox(g_hResDLLInstance, MAKEINTRESOURCE(IDD_WIZARD_ERROR),
					hDlg, WizardErrorProc);
				goto error_level_1;
			}
		}
	}

	// If we get here, the test was already run on the default 
	// devices, and it returned either halfduplex or fullduplex,
	// so we can set the bits as we please.
	
	// Open the applications registry key
	if (!cregApps.Open(HKEY_LOCAL_MACHINE, DPLAY_REGISTRY_APPS, FALSE))
	{
		DPF(DVF_ERRORLEVEL, "CRegistry::Open failed");
		goto error_level_1;
	}
	hkApps = cregApps.GetHandle();

	// set the autovoice bit - maintaint the state of the rest of the bits
	// in case we add more global flags later
	/*
	if (!cregApps.ReadDWORD(REGSTR_VAL_FLAGS, dwGlobalFlags))
	{
		DPF(DVF_ERRORLEVEL, "Error reading default flags from applications key");
		dwGlobalFlags = 0;
		// continue anyway
	}
	if (IsDlgButtonChecked(hDlg, IDC_UNLISTEDCHECK) == BST_CHECKED)
	{
		dwGlobalFlags |= DPLAPP_AUTOVOICE;
	}
	else
	{
		dwGlobalFlags &= ~DPLAPP_AUTOVOICE;
	}
	if (cregApps.WriteDWORD(REGSTR_VAL_FLAGS, dwGlobalFlags))
	{
		DPF(DVF_ERRORLEVEL, "Error writing default flags to application key");
		// continue anyway
	}
	*/

	// loop through the items and set the app's flags according to
	// the selected state of the list view
	for (lIndex = 0; lIndex < lNumItems; ++lIndex)
	{
		// get the item info
		lvitem.mask = LVIF_TEXT|LVIF_PARAM;
		lvitem.iItem = lIndex;
		lvitem.iSubItem = 0;
		lvitem.state = 0;
		lvitem.stateMask = 0;
		lvitem.pszText = tszItemText;
		lvitem.cchTextMax = MAX_REGISTRY_STRING_SIZE;
		lvitem.iImage = 0;
		lvitem.lParam = 0;
		lvitem.iIndent = 0;
		if (!ListView_GetItem(hwndListView, &lvitem))
		{
			DPF(DVF_ERRORLEVEL, "ListView_GetItem failed");
			goto error_level_1;			
		}

		dwFlags = (DWORD)lvitem.lParam;

		if (!OSAL_TCharToWide(swzItemText, tszItemText, MAX_REGISTRY_STRING_SIZE))
		{
			DPF(DVF_ERRORLEVEL, "OSAL_AnsiToWide failed");
			goto error_level_1;
		}

		lvitem.mask = LVIF_IMAGE;
		lvitem.iItem = lIndex;
		lvitem.iSubItem = 1;
		if (!ListView_GetItem(hwndListView, &lvitem))
		{
			DPF(DVF_ERRORLEVEL, "ListView_GetItem failed");
			goto error_level_1;			
		}

		if (lvitem.iImage == g_iCheckboxFullIndex)
		{
			dwFlags |= DPLAPP_AUTOVOICE;
		}
		else
		{
			dwFlags &= ~DPLAPP_AUTOVOICE;
		}
		
		if (!cregApp.Open(hkApps, swzItemText, FALSE))
		{
			DPF(DVF_ERRORLEVEL, "CRegistry::Open failed");
			goto error_level_1;
		}

		if (!cregApp.WriteDWORD(REGSTR_VAL_FLAGS, dwFlags))
		{
			DPF(DVF_ERRORLEVEL, "CRegistry::WriteDWORD failed");
			goto error_level_1;
		}

		if (!cregApp.Close())
		{
			DPF(DVF_ERRORLEVEL, "CRegistry::Close failed");
			goto error_level_1;
		}
	}

	if (!cregApps.Close())
	{
		DPF(DVF_ERRORLEVEL, "CRegistry::Close failed");
		goto error_level_1;
	}

	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
	DPF_EXIT();
	return TRUE;

error_level_1:
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
	
error_level_0:
	DPF_EXIT();
	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "RetrofitResetHandler"
INT_PTR RetrofitResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "RetrofitDetailsHandler"
INT_PTR RetrofitDetailsHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();

	DialogBox(g_hResDLLInstance, MAKEINTRESOURCE(IDD_MOREINFO),
		hDlg, DetailsProc);
	
	DPF_EXIT();
	return FALSE;
}



#undef DPF_MODNAME
#define DPF_MODNAME "RetrofitDestroyHandler"
INT_PTR RetrofitDestroyHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();

	if( g_himagelist )
	{
    	// clean up the image list
    	ImageList_Destroy(g_himagelist);
        g_himagelist = NULL;
	}

	if( g_IDirectPlayVoiceSetup )
	{
    	// release the IDirectPlayVoiceSetup interface
    	g_IDirectPlayVoiceSetup->Release();
    	g_IDirectPlayVoiceSetup = NULL;
	}
	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WizardCancelProc"
INT_PTR CALLBACK WizardCancelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;
	HICON hIcon;

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG:
		hIcon = LoadIcon(NULL, IDI_WARNING);
		SendDlgItemMessage(hDlg, IDC_ICON_NOTCOMPLETE, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;
	
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			fRet = TRUE;
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WizardLaunchProc"
INT_PTR CALLBACK WizardLaunchProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;
	HICON hIcon;

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG:
		hIcon = LoadIcon(NULL, IDI_INFORMATION);
		SendDlgItemMessage(hDlg, IDC_ICON_INFORMATION, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;
		
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			fRet = TRUE;
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "PrevHalfDuplexProc"
INT_PTR CALLBACK PrevHalfDuplexProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;
	HICON hIcon;

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG:
		hIcon = LoadIcon(NULL, IDI_WARNING);
		SendDlgItemMessage(hDlg, IDC_WARNING_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;
		
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
		case IDC_RUNTEST:
			EndDialog(hDlg, LOWORD(wParam));
			fRet = TRUE;
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}


#undef DPF_MODNAME
#define DPF_MODNAME "ConfirmHalfDuplexProc"
INT_PTR CALLBACK ConfirmHalfDuplexProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;
	HICON hIcon;

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG:
		hIcon = LoadIcon(NULL, IDI_WARNING);
		SendDlgItemMessage(hDlg, IDC_ICON_WARNING, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;
	
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			fRet = TRUE;
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SoundInitFailureProc"
INT_PTR CALLBACK SoundInitFailureProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;
	HICON hIcon;

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG:
		hIcon = LoadIcon(NULL, IDI_ERROR);
		SendDlgItemMessage(hDlg, IDC_ICON_ERROR, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;
	
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			fRet = TRUE;
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WizardErrorProc"
INT_PTR CALLBACK WizardErrorProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;
	HICON hIcon;

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG:
		hIcon = LoadIcon(NULL, IDI_ERROR);
		SendDlgItemMessage(hDlg, IDC_ICON_ERROR, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;
	
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			fRet = TRUE;
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VoiceEnabledProc"
INT_PTR CALLBACK VoiceEnabledProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;
	HICON hIcon;

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG:
		hIcon = LoadIcon(NULL, IDI_INFORMATION);
		SendDlgItemMessage(hDlg, IDC_INFO_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;
		
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			fRet = TRUE;
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DetailsProc"
INT_PTR CALLBACK DetailsProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL              fRet;
	static TCHAR     *szMoreInfo = NULL;
	static const int  c_iMoreInfoStrLen = 2048;


	fRet = FALSE;

	switch (message)
	{
	case WM_INITDIALOG:
		/*
		hIcon = LoadIcon(NULL, IDI_INFORMATION);
		SendDlgItemMessage(hDlg, IDC_INFO_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		hIcon = LoadIcon(NULL, IDI_WARNING);
		SendDlgItemMessage(hDlg, IDC_WARNING_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		*/
		szMoreInfo = (TCHAR*)malloc((c_iMoreInfoStrLen-1)*sizeof(TCHAR));
		if (szMoreInfo != NULL)
		{
			if (LoadString(g_hResDLLInstance, IDS_VOICEMOREINFO, szMoreInfo, c_iMoreInfoStrLen) != 0)
			{
				SetDlgItemText(hDlg, IDC_MOREINFO, szMoreInfo);
			}
		}
		break;
		
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			fRet = TRUE;
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ClearAllCheckboxes"
void ClearAllCheckboxes(HWND hDlg, HWND hwndListView, LONG lNumItems)
{
	LONG lIndex;
	
	// get a handle to the list view control
	HWND hwnd = GetDlgItem(hDlg, IDC_LIST_GAMES);
	if (hwnd == NULL)
	{
		LONG lRet = GetLastError();
		DPF(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		return;
	}
	
	for (lIndex = 0; lIndex < lNumItems; ++lIndex)
	{
		MySetCheckState(hwnd, lIndex, FALSE);
	}

	/*
	if (!CheckDlgButton(hDlg, IDC_UNLISTEDCHECK, FALSE))
	{
		DPF(DVF_ERRORLEVEL, "Unable to clear unlisted games enable checkbox");
	}
	*/

	InvalidateRect(hwnd, NULL, TRUE);
	UpdateWindow(hwnd);

	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ListViewSubclassProc"
INT_PTR CALLBACK ListViewSubclassProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();

	LRESULT lResult;

	switch (message)
	{
	case WM_LBUTTONDOWN:
		ListViewLButtonDownHandler(hwnd, message, wParam, lParam);
		break;

	case WM_LBUTTONDBLCLK:
		ListViewLButtonDblClkHandler(hwnd, message, wParam, lParam);
		break;

	case WM_KEYDOWN:
		ListViewKeydownHandler(hwnd, message, wParam, lParam);
		break;

	default:
		break;
	}

	lResult = CallWindowProc(g_ListViewProc, hwnd, message, wParam, lParam);
	
	DPF_EXIT();
	return lResult;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ListViewLButtonDownHandler"
INT_PTR ListViewLButtonDownHandler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	LVHITTESTINFO lvHitTestInfo;
	lvHitTestInfo.pt.x = GET_X_LPARAM(lParam);
	lvHitTestInfo.pt.y = GET_Y_LPARAM(lParam);

	ListView_SubItemHitTest(hwnd, &lvHitTestInfo);

	if (lvHitTestInfo.flags & LVHT_ONITEMICON && lvHitTestInfo.iSubItem == 1)
	{
		MyToggleCheckState(hwnd, lvHitTestInfo.iItem);
	}
		
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ListViewLButtonDblClkHandler"
INT_PTR ListViewLButtonDblClkHandler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	LVHITTESTINFO lvHitTestInfo;
	lvHitTestInfo.pt.x = GET_X_LPARAM(lParam);
	lvHitTestInfo.pt.y = GET_Y_LPARAM(lParam);

	ListView_HitTest(hwnd, &lvHitTestInfo);

	if (lvHitTestInfo.flags & LVHT_ONITEMICON|LVHT_ONITEMLABEL)
	{
		LVITEM lvitem;
		lvitem.mask = LVIF_IMAGE;
		lvitem.iItem = lvHitTestInfo.iItem;
		lvitem.iSubItem = 1;
		
		if (ListView_GetItem(hwnd, &lvitem))
		{
			// we got the image, toggle the state
			if (lvitem.iImage == g_iCheckboxEmptyIndex)
			{
				lvitem.iImage = g_iCheckboxFullIndex;
			}
			else
			{
				lvitem.iImage = g_iCheckboxEmptyIndex;
			}

			ListView_SetItem(hwnd, &lvitem);

			InvalidateRect(hwnd, NULL, TRUE);
			UpdateWindow(hwnd);
		}
	}
		
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ListViewKeydownHandler"
INT_PTR ListViewKeydownHandler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();

	int iItem;
	switch (wParam)
	{
	case VK_SPACE:
		// The space bar was hit. Figure out if one of the 
		// list view items has focus and if so, toggle the
		// checkbox state
		iItem = ListView_GetNextItem(hwnd, -1, LVNI_FOCUSED|LVNI_SELECTED);
		if (iItem != -1)
		{
			MyToggleCheckState(hwnd, iItem);			
		}
		break;
		
	default:
		break;
	}
	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MySetCheckState"
void MySetCheckState(HWND hwnd, int iItem, BOOL bChecked)
{
	LVITEM lvitem;
	lvitem.mask = LVIF_IMAGE;
	lvitem.iItem = iItem;
	lvitem.iSubItem = 1;
	
	if (ListView_GetItem(hwnd, &lvitem))
	{
		// we got the image, set the check state
		if (bChecked)
		{
			lvitem.iImage = g_iCheckboxFullIndex;
		}
		else
		{
			lvitem.iImage = g_iCheckboxEmptyIndex;
		}

		ListView_SetItem(hwnd, &lvitem);

		InvalidateRect(hwnd, NULL, TRUE);
		UpdateWindow(hwnd);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "MyGetCheckState"
BOOL MyGetCheckState(HWND hwnd, int iItem)
{
	LVITEM lvitem;
	lvitem.mask = LVIF_IMAGE;
	lvitem.iItem = iItem;
	lvitem.iSubItem = 1;
	
	if (ListView_GetItem(hwnd, &lvitem))
	{
		// we got the image, return the state
		if (lvitem.iImage == g_iCheckboxEmptyIndex)
		{
			return FALSE;
		}
		else
		{
			return TRUE;
		}
	}
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MyToggleCheckState"
BOOL MyToggleCheckState(HWND hwnd, int iItem)
{
	LVITEM lvitem;
	lvitem.mask = LVIF_IMAGE;
	lvitem.iItem = iItem;
	lvitem.iSubItem = 1;
	BOOL fRet = FALSE;
	
	if (ListView_GetItem(hwnd, &lvitem))
	{
		// we got the image, toggle the state
		if (lvitem.iImage == g_iCheckboxEmptyIndex)
		{
			lvitem.iImage = g_iCheckboxFullIndex;
			fRet = FALSE;
		}
		else
		{
			lvitem.iImage = g_iCheckboxEmptyIndex;
			fRet = TRUE;
		}

		ListView_SetItem(hwnd, &lvitem);

		InvalidateRect(hwnd, NULL, TRUE);
		UpdateWindow(hwnd);
	}
	return fRet;
}

////////////////////////////////////
// copied verbatim from appman.cpp
////////////////////////////////////
#define STR_LEN_32 32 // used by these functions...
static void RetrofitOnAdvHelp(LPARAM lParam)
{
    DNASSERT (lParam);

    // point to help file
    LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
    DNASSERT (pszHelpFileName);

    if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
    {
        if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("JOY.CPL: AppMan.cpp: OnAdvHelp: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

    if( pszHelpFileName )
        delete[] (pszHelpFileName);
}

////////////////////////////////////
// copied verbatim from appman.cpp
////////////////////////////////////
static void RetrofitOnContextMenu(WPARAM wParam, LPARAM lParam)
{
//    HWND hListCtrl = NULL
    DNASSERT (wParam);

#if 0
    hListCtrl = GetDlgItem((HWND) wParam, IDC_APPMAN_DRIVE_LIST);

    // If you are on the ListCtrl...
    if( (HWND)wParam == hListCtrl )
    {
        SetFocus(hListCtrl);

        // Don't attempt if nothing selected
        if( iItem != NO_ITEM )
            OnListviewContextMenu(hListCtrl,lParam);
    } else
#endif
    {
        // point to help file
        LPTSTR pszHelpFileName = new TCHAR[STR_LEN_32];
        DNASSERT (pszHelpFileName);

        if( LoadString(ghInstance, IDS_HELPFILENAME, pszHelpFileName, STR_LEN_32) )
            WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
#ifdef _DEBUG
        else OutputDebugString(TEXT("JOY.CPL: appman.cpp: OnContextMenu: LoadString Failed to find IDS_HELPFILENAME!\n"));
#endif // _DEBUG

        if( pszHelpFileName )
            delete[] (pszHelpFileName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gcmain.rc
//
#define IDD_CPANEL                      101
#define IDI_CPANEL                      102
#define IDD_PROPSHEET                   103
#define IDD_ASSIGN                      104
#define IDI_NOTCONNECTED                108
#define IDI_JOYSTICK                    110
#define IDR_MENU1                       116
#define IDD_ADVANCED                    117
#define IDD_ADD                         119
#define IDD_SMAPPER                     122
#define IDB_JOYSTICK                    126
#define IDD_MOREINFO                    127
#define IDI_CHECKBOX_EMPTY              131
#define IDD_DVOICE                      131
#define IDI_CHECKBOX_FULL               132
#define IDD_PROP_RETROFIT               133
#define IDS_DVOICE_TAB                  134
#define IDD_WIZARD_CANCELED             135
#define IDD_WIZARD_LAUNCH               136
#define IDD_VOICE_ENABLED               137
#define IDI_LIST_DEFAULT                138
#define IDD_CONFIRM_HALFDUPLEX          139
#define IDD_CONFIRM_SOUNDINITFAILURE    140
#define IDD_WIZARD_ERROR                141
#define IDD_DETAILS                     143
#define IDD_PREV_HALFDUPLEX             144
#define IDD_APPMAN_MORE_INFO            145
#define IDD_UPDATE                      146
#define IDC_COMBO1                      1000
#define IDC_TEXT_HELP                   1001
#define IDC_BTN_PROPERTIES              1002
#define IDC_BTN_SETTINGS                1003
#define IDC_BTN_TEST                    1004
#define IDC_TAB                         1005
#define IDC_BTN_APPLY                   1006
#define IDC_BTN_TSHOOT                  1007
#define IDC_TEXT_DEVICE                 1008
#define IDC_BTN_REFRESH                 1009
#define IDC_BTN_ASSIGN                  1010
#define IDC_BTN_ADD                     1011
#define IDC_COMBO_JOYSTICKID            1012
#define IDS_TSHOOT_CMD                  1013
#define IDC_BTN_UPDATE                  1014
#define IDC_LIST_DEVICE                 1020
#define IDC_TEXT_DEVICELIST             1025
#define IDC_TEXT_IDLIST                 1026
#define IDC_BTN_REMOVE                  1028
#define IDC_COMBO_AXIS                  1030
#define IDC_TEXT_TITLE                  1031
#define IDC_TEXT_DRIVER                 1032
#define IDC_TEXT_LBTAG                  1033
#define IDC_ADD_STR1                    1037
#define IDC_ADD_STR2                    1038
#define IDC_ADD_NEW                     1039
#define IDS_ADV_TITLE                   1039
#define IDS_ADV_GLOBAL_DESC             1040
#define IDS_ADV_GLOBAL_TAG              1041
#define IDS_ADV_DEVICE_HEADING          1042
#define IDC_AXES_GROUP                  1043
#define IDC_AXES2                       1044
#define IDC_AXES3                       1045
#define IDC_AXES4                       1046
#define IDC_BUTTONS_GROUP               1047
#define IDC_COMBO_BUTTONS               1048
#define IDC_SPECIAL_GROUP               1049
#define IDC_SPECIAL_CHECK               1050
#define IDC_SPECIAL_YOKE                1051
#define IDC_SPECIAL_PAD                 1052
#define IDC_SPECIAL_AUTO                1053
#define IDC_SPECIAL_JOYSTICK            1054
#define IDC_CUSTOM_NAME                 1055
#define IDC_EDIT_NAME                   1056
#define IDC_DEVICE_LIST                 1057
#define IDC_LIST_HEADING                1058
#define IDS_ADD_DESC                    1059
#define IDS_ADD_NEW_DESC                1060
#define IDS_ADD_NEW                     1061
#define IDS_CUSTOM_TITLE                1062
#define IDS_CUSTOM_AXES_GROUP           1063
#define IDS_CUSTOM_2AXES                1064
#define IDS_CUSTOM_3AXES                1065
#define IDS_CUSTOM_4AXES                1066
#define IDS_CUSTOM_BUTTONS_GROUP        1067
#define IDS_CUSTOM_SPECIAL              1068
#define IDS_CUSTOM_ISFLIGHTYOKE         1069
#define IDS_CUSTOM_ISGAMEPAD            1070
#define IDS_CUSTOM_ISRACECAR            1071
#define IDS_CUSTOM_HASPOV               1072
#define IDS_CUSTOM_NAME                 1073
#define IDS_CUSTOM_BUTTONS              1074
#define IDS_GEN_CPANEL_TITLE            1076
#define IDS_GENERAL_TAB                 1077
#define IDC_ADV_USEOEMPAGE              1078
#define IDS_ADVANCED_TAB                1079
#define IDS_NONE                        1080
#define IDC_SCROLLBAR1                  1081
#define IDC_SPIN1                       1083
#define IDS_ADV_DEVICE_FRIENDLY         1084
#define IDC_DATETIMEPICKER1             1085
#define IDC_SW_HACK                     1086
#define IDS_ADD_DEVICE_LIST_TAG         1091
#define IDS_OK                          1092
#define IDS_CANCEL                      1093
#define IDS_ADD_TITLE                   1094
#define IDS_NO_IDS                      1095
#define IDS_NO_IDS_TITLE                1096
#define IDS_NO_NAME                     1097
#define IDS_NO_NAME_TITLE               1098
#define IDS_GEN_CPANEL_INFO             1099
#define IDC_POLLFLAGS                   1100
#define IDC_TEXT_PORTDRIVER             1101
#define IDS_NO_GAMEPORT                 1102
#define IDS_NO_GAMEPORT_TITLE           1103
#define IDS_ADV_STATUS_HEADING          1143
#define IDS_ADV_STD_GAMEPORT            1144
#define IDS_WHATSTHIS                   1145
#define IDS_GEN_PROPERTIES              1146
#define IDS_GEN_REMOVE                  1147
#define IDS_GEN_ADD                     1148
#define IDS_GEN_LIST_HEADING            1149
#define IDS_GEN_TEXT_HELP               1150
#define IDS_GEN_DEVICE_HEADING          1151
#define IDS_GEN_STATUS_HEADING          1152
#define IDS_GEN_AREYOUSURE              1153
#define IDC_VIEW_CTRL                   1154
#define IDS_GEN_STATUS_OK               1155
#define IDS_GEN_STATUS_NOTCONNECTED     1157
#define IDS_GEN_STATUS_NOFORCES         1158
#define IDC_DEVICE_LIST_TAG             1159
#define IDC_ADV_GRP                     1161
#define IDC_ADV_GRP2                    1162
#define IDC_GEN_INTRO                   1164
#define IDC_GEN_ICON                    1166
#define IDC_GAMEPORT                    1167
#define IDC_GAMEPORTLIST                1168
#define IDC_CUSTOM                      1169
#define IDS_ADV_GAME_CONTROLLERS        1170
#define IDC_HASRUDDER                   1172
#define IDC_HASZAXIS                    1174
#define IDC_ADV_OEMSHEET                1175
#define IDC_WDM                         1176
#define IDS_ADV_DEVICE_PORT             1177
#define IDS_NOAVAILABLEVIDPID           1178
#define IDS_GAMES_COLUMN_HEADER         1188
#define IDS_ENABLED_COLUMN_HEADER       1189
#define IDS_GEN_AREYOUSURE_TITLE        1254
#define IDC_MOREINFO                    1280
#define IDC_INFO_ICON                   1300
#define IDC_ICON_NOTCOMPLETE            1301
#define IDC_ICON_INFORMATION            1302
#define IDC_ICON_WARNING                1303
#define IDC_ICON_ERROR                  1304
#define IDC_DETAILS                     1305
#define IDC_WARNING_ICON                1306
#define IDC_RUNTEST                     1307
#define IDC_VOICECHATTEXT               1308
#define IDC_GAMESLISTHOTKEY             1309
#define IDC_VOICECHATGROUP              1310
#define IDD_CUSTOM                      4099
#define IDD_ADV_CHANGE                  8188
#define IDC_CHANGE_BOARDER              8189
#define IDD_APPMAN_ADV                  8189
#define IDD_APPMAN_LOCKING              8189
#define IDC_SELECTEDID                  8190
#define IDD_APPMAN_ADVUSER              8191
#define IDC_CHANGEID                    8192
#define IDC_ASSIGNTXT                   8193
#define IDC_LISTTXT                     8194
#define IDC_CHANGE_LIST                 8195
#define IDS_DEVICEID                    8196
#define IDS_CONTROLLERS                 8197
#define IDC_ADV_LIST_DEVICE             8198
#define IDC_ADV_CHANGE                  8199
#define IDC_GROUPBOX                    8300
#define IDS_CONTROLLERID                8301
#define IDC_GROUPBOX_2                  8302
#define IDC_GROUPBOX_3                  8303
#define IDS_ADV_CHANGE                  8304
#define IDS_CUSTOM_STRING               8305
#define IDC_JOYHASPOV                   12322
#define IDC_JOYISYOKE                   12323
#define IDC_JOYISGAMEPAD                12324
#define IDC_JOYISCARCTRL                12325
#define IDC_JOY2BUTTON                  12326
#define IDC_JOY4BUTTON                  12327
#define IDC_JOYUSESPECIAL               12332
#define IDC_JOY2AXIS                    12336
#define IDC_JOY3AXIS                    12337
#define IDC_JOY4AXIS                    12338
#define IDC_BTN_DIAG                    40001
#define IDS_HELPFILENAME                40002
#define IDS_DUPLICATE_TYPE              40003
#define IDS_DUPLICATE_TYPE_TITLE        40004
#define IDS_INVALID_NAME                40005
#define IDS_INVALID_NAME_TITLE          40006
#define IDS_INTERNAL_ERROR              40007
#define IDS_NO_DIJOYCONFIG              40008
#define IDS_NO_GAMENUM                  40009
#define IDS_NO_GAMENUM_TITLE            40010
#define IDC_SEPERATOR                   40011
#define IDS_MAX_DEVICES_TITLE           40012
#define IDS_MAX_DEVICES_MSG             40013
#define IDS_NO_REMOVE                   40014
#define IDS_RENAME                      40016
#define IDC_RENAME                      40017
#define IDS_DONE                        40018
#define IDS_REFRESH                     40019
#define IDC_JOY1HASRUDDER               40022
#define IDC_SPIN                        40023
#define IDC_SPINBUDDY                   40024
#define IDS_ADD_PORT_MSGFORMAT          40025
#define IDS_ADD_PORT_OCCUPIED           40026
#define IDS_GEN_STATUS_UNKNOWN          40027
#define IDS_GEN_NO_REMOVE_USB           40028
#define IDS_WDMJOY                      40029
#define IDS_AUTO_DETECT                 40030
#define IDS_USER_MODE                   40031
#define IDS_USER_MODE_TITLE             40032
#define IDS_WDMJOY_INF                  40033
#define IDC_MYSTATIC                    40034
#define IDS_NO_RENAME                   40035
#define IDS_NO_RENAME_TITLE             40036
#define IDS_GAMEPORT_OCCUPIED           40037
#define IDS_GAMEPORT_OCCUPIED_TITLE     40038
#define IDS_DEST_ID_OCCUPIED            40039
#define IDS_DEST_ID_OCCUPIED_TITLE      40040
#define IDS_VOICEMOREINFO               40046
#define IDC_PEAKMETER                   41008
#define IDC_P1                          41013
#define IDC_P2                          41014
#define IDC_P3                          41015
#define IDC_WELCOME_IMAGE               41016
#define IDC_COMPLETE_IMAGE              41021
#define IDC_TITLE                       41022
#define IDC_PROGRESSBAR                 41023
#define IDC_RADIO_EXTERNAL              41024
#define IDC_RADIO_HEADSET               41025
#define IDC_COMPLETE_FAILED_GRAPHIC     41026
#define IDC_P4                          41027
#define IDC_DIVIDER                     41028
#define IDC_P5                          41029
#define IDC_LIST_GAMES                  41034
#define IDC_TEST_DEVICES                41042
#define IDC_VOICE_DEVICES               41043
#define IDC_GROUP1                      41044
#define IDC_GROUP2                      41045
#define IDS_UPDATE_SITEDIR              41046
#define IDS_UPDATE_INI                  41047
#define IDS_UPDATE_LASTUPDATED          41048
#define IDS_UPDATE_NOTCONNECTED_TITLE   41049
#define IDS_UPDATE_NOTCONNECTED         41050
#define IDS_UPDATE_FTP_ERROR            41051
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        147
#define _APS_NEXT_COMMAND_VALUE         41052
#define _APS_NEXT_CONTROL_VALUE         1311
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>       
#include <afxext.h>       
#include <afxcmn.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\sources.inc ===
!IFNDEF DXROOT
DXROOT = $(BASEDIR)\MultiMedia\DirectX
!ENDIF

!INCLUDE $(DXROOT)\Project.mk

#
#   Use an empty binplace file to dump this version in the Windows build
#
!IFNDEF TARGET_WIN95
!IFNDEF DIRECTX_REDIST
BINPLACE_PLACEFILE=..\..\noplace.txt
!ENDIF
!ENDIF

LINKER_STACKSIZE=-STACK:4096,1024

MAJORCOMP=shell
MINORCOMP=accessory

TARGETNAME=joy
TARGETEXT=cpl
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows

DLLENTRY=DllMain


# Need to define IE_VERSION as 0x300, otherwise, joy.cpl won't launch in Win95 gold.
!IFDEF TARGET_WIN95
WIN32_IE_VERSION=0x0300
!ENDIF


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\uuid.lib     \
           $(SDK_LIB_PATH)\dinput.lib   \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib   \
           $(SDK_LIB_PATH)\gdi32.lib    \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SDK_LIB_PATH)\winmm.lib \
           $(SDK_LIB_PATH)\shell32.lib \
           $(SDK_LIB_PATH)\setupapi.lib \
           $(SDK_LIB_PATH)\wininet.lib 
           

INCLUDES=$(INCLUDES);                       \
     ..;                                    \
     ..\..\handler;                         \
     ..\..\default;                         \
     $(DXROOT)\inc;                         \
     $(DXROOT)\dplay\dvoice\inc;  \
     $(SDK_INC_PATH)\MFC42;  


SOURCES=\
    ..\gcmain.rc    \
    ..\add.cpp      \
    ..\advanced.cpp \
    ..\cpanel.cpp   \
    ..\main.cpp     \
    ..\inplace.cpp  \
	..\guids.cpp \
	..\retrocfg.cpp \
	..\dvosal.cpp \
	..\creg.cpp \
	..\guidutil.cpp \
	..\dndbg.c

DLLDEF=..\joy.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mfccpl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\update.cpp ===
/*
 * update.cpp -- Windows Update for DirectInput Device Configurations and Images
 *
 * History:
 *    4-22-00  qzheng  First version
 *
 */
 
#include <afxcmn.h>
#include <windows.h>
#include <windowsx.h>
#include <direct.h>
#include <wininet.h>
#include <setupapi.h>
#include <tchar.h>
#include "cpanel.h"

extern HINSTANCE ghInstance;
extern PJOY pAssigned[MAX_ASSIGNED];  // List of assigned devices
extern short iItem;
extern IDirectInputJoyConfig *pDIJoyConfig;

static TCHAR tszFtpAgent[] = TEXT("Game Control Panel");
static TCHAR tszUpdateSite[] = TEXT("ftp.microsoft.com");  //????
static TCHAR tszUpdateSiteUser[] = TEXT("anonymous");
static TCHAR tszUpdateSitePass[] = TEXT("anonymous@microsoft.com");
static TCHAR tszFormatRundll9x[] = TEXT("rundll.exe setupx.dll,InstallHinfSection DefaultInstall 4 ");
static TCHAR tszFormatRundllNT[] = TEXT("\\system32\\rundll32.exe syssetup.dll,SetupInfObjectInstallAction DefaultInstall 4 ");
static TCHAR tszUpdateInf[] = TEXT("dimapins.inf");

// Global variable holding destination directory.
static HINTERNET hOpen, hConnect;
static DWORD dwType = FTP_TRANSFER_TYPE_BINARY;
static TCHAR tszTargetPath[MAX_PATH];

static BOOL Open(TCHAR *tszHost, TCHAR *tszUser, TCHAR *tszPass);
static BOOL Close(HINTERNET hConnect);
static BOOL ErrorOut( DWORD dError, TCHAR *szCallFunc);
static BOOL lcd(TCHAR *tszDir);
static BOOL rcd(TCHAR *tszDir);
static void GetCurDeviceType(HWND hDlg, TCHAR *tszDeviceType);
static void ExtractCabinet(PTSTR pszCabFile);
static void ApplyUpdateInf( void );


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    Update
//
// PURPOSE:     Update device configuration files and image if there are new
//              ones on Windows Update Server.
//                       
///////////////////////////////////////////////////////////////////////////////

void Update(HWND hDlg, int nAccess, TCHAR *tszProxy)
{
    TCHAR tszWinDir[STR_LEN_64];
    TCHAR tszLocalIni[MAX_PATH];
    TCHAR tszTempDir[MAX_PATH];
    TCHAR tszRemoteIni[MAX_PATH];
    TCHAR tszDeviceType[MAX_PATH];
    TCHAR tszDeviceCabFile[MAX_PATH];
    TCHAR tszBuf[MAX_PATH];
    OFSTRUCT ofs;
    HANDLE hIniFile;
    FILETIME ftLocalTime, ftRemoteTime, ftCT, ftLAT;
    TCHAR tszUpdateSiteDir[STR_LEN_32];
    TCHAR tszUpdateIniFile[STR_LEN_32];
    TCHAR tszLastUpdate[STR_LEN_32];
    BOOL  fLocalIniExist;

    // nAccess: 1 - don't use proxy, default
    //          2 - use proxy
    switch (nAccess)
    {
    case 1:
        // No proxy specified.  Open WININET.DLL w/ local access
        if ( !(hOpen = InternetOpen( tszFtpAgent,  LOCAL_INTERNET_ACCESS , NULL, 0, 0) ) )
        {
            ErrorOut( GetLastError(), TEXT("InternetOpen"));
            return ;
        }
        break;
        
    case 2:
        // Specified proxy, Open WININET.DLL w/ Proxy
        if ( !(hOpen = InternetOpen( tszFtpAgent, CERN_PROXY_INTERNET_ACCESS, tszProxy, NULL, 0) ) )
        {
           ErrorOut( GetLastError(), TEXT("InternetOpen"));
           return ;
        }
        break;
        
    default:
        return;
    }

    if ( !Open(tszUpdateSite, tszUpdateSiteUser, tszUpdateSitePass) ){
        Error((short)IDS_UPDATE_NOTCONNECTED_TITLE, (short)IDS_UPDATE_NOTCONNECTED);
        return;
    }

    LoadString(ghInstance, IDS_UPDATE_SITEDIR, tszUpdateSiteDir, sizeof(tszUpdateSiteDir) );
    LoadString(ghInstance, IDS_UPDATE_INI, tszUpdateIniFile, sizeof(tszUpdateIniFile) );
    LoadString(ghInstance, IDS_UPDATE_LASTUPDATED, tszLastUpdate, sizeof(tszLastUpdate) );

    GetCurDeviceType( hDlg, tszDeviceType );

    // The following codes are to get last modified time of the local Ini file ($windir\dinputup.ini).
    GetWindowsDirectory( tszWinDir, sizeof(tszWinDir) );
    lstrcpy( tszLocalIni, tszWinDir );
    lstrcat( tszLocalIni, TEXT("\\") );
    lstrcat( tszLocalIni, tszUpdateIniFile );

    hIniFile = CreateFile(tszLocalIni,
                      GENERIC_READ,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

    if( hIniFile != INVALID_HANDLE_VALUE ) {
        GetFileTime( hIniFile, &ftCT, &ftLAT, &ftLocalTime );
        CloseHandle(hIniFile);
        fLocalIniExist = TRUE;
    } else {
    	//the local dinputup.ini doesn't exist.
    	fLocalIniExist = FALSE;
    	ErrorOut(GetLastError(), TEXT("CreateFile(dinputup.ini) fails or file doesn't exist"));
    }
    
//  wsprintf( tszBuf, TEXT("%lx,%lx"), ftLWT.dwHighDateTime, ftLWT.dwLowDateTime );
//  lstrcpy( tszDeviceType, TEXT("VID_046D&PID_C207"));
//  WritePrivateProfileString( tszDeviceType, tszLastUpdate, tszBuf, tszUpdateIniFile); 

    // The following codes are to get last modified time of the remote Ini file
    // on Windows Update server.
    GetTempPath( sizeof(tszTempDir), tszTempDir );
    lcd( tszTempDir );
    
    lstrcpy( tszRemoteIni, tszTempDir );
    lstrcat( tszRemoteIni, TEXT("\\") );
    lstrcat( tszRemoteIni, tszUpdateIniFile );
    
    rcd( tszUpdateSiteDir );  // change to proper directory on Windows Update Server.
    
    if ( !FtpGetFile(hConnect, tszUpdateIniFile, tszUpdateIniFile, FALSE, 0, INTERNET_FLAG_RELOAD | dwType, 0) ) {
        ErrorOut(GetLastError(), TEXT("FtpGetFile"));
        Error((short)IDS_UPDATE_NOTCONNECTED_TITLE, (short)IDS_UPDATE_FTP_ERROR);
        goto _CLOSE;
    }

    hIniFile = CreateFile(tszRemoteIni,
                      GENERIC_READ,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

    if( hIniFile != INVALID_HANDLE_VALUE ) {
        GetFileTime( hIniFile, &ftCT, &ftLAT, &ftRemoteTime );
        CloseHandle(hIniFile);
    } else {
    	ErrorOut(GetLastError(), TEXT("CreateFile on Remote Ini file"));
        goto _CLOSE;
    }

    if( !fLocalIniExist || (CompareFileTime(&ftLocalTime, &ftRemoteTime) < 0) ) {
        // remote one is newer, overwrite local one.
        CopyFile( tszRemoteIni, tszLocalIni, FALSE );
    }
    
    lstrcpy( tszDeviceCabFile, tszDeviceType );
    lstrcat( tszDeviceCabFile, TEXT(".cab") );
    if (!FtpGetFile(hConnect, tszDeviceCabFile, tszDeviceCabFile, FALSE, 0, INTERNET_FLAG_RELOAD | dwType, 0 ) ) {
        ErrorOut(GetLastError(), TEXT("FtpGetFile"));
        Error((short)IDS_UPDATE_NOTCONNECTED_TITLE, (short)IDS_UPDATE_FTP_ERROR);
        goto _CLOSE;
    }

    lstrcpy( tszTargetPath, tszTempDir );
    lstrcat( tszTargetPath, TEXT("\\") );
    lstrcpy( tszBuf, tszTempDir );
    lstrcat( tszBuf, TEXT("\\"));
    lstrcat( tszBuf, tszDeviceCabFile );

    // extract cab file
    ExtractCabinet( tszBuf );
    
    // apply update inf file
    ApplyUpdateInf();

_CLOSE:
    Close(hConnect);

    return;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    lcd
//
// PURPOSE:     Change to new directory on local
//                       
///////////////////////////////////////////////////////////////////////////////

BOOL lcd(TCHAR *tszDir)
{
    if ((*tszDir != 0) && (_tchdir(tszDir) == -1)) {
#ifdef _DEBUG
        OutputDebugString(TEXT("?Invalid Local Directory"));
#endif
        return FALSE;       
    }
    
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    rcd
//
// PURPOSE:     Change to new directory on remote side
//                       
///////////////////////////////////////////////////////////////////////////////

BOOL rcd(TCHAR *tszDir)
{
    BOOL fRtn = FALSE;
    
    if (*tszDir != 0)
    {
        if (!FtpSetCurrentDirectory(hConnect, tszDir))
        {
            ErrorOut(GetLastError(), TEXT("FtpSetCurrentDirectory"));
            fRtn = FALSE;
        }
        
        fRtn = TRUE;
    }
    
    return fRtn;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    Open
//
// PURPOSE:     Open an Internect connection to a host.
//                       
///////////////////////////////////////////////////////////////////////////////

BOOL Open(TCHAR *tszHost, TCHAR *tszUser, TCHAR *tszPass)
{
    if ( !(hConnect = InternetConnect( hOpen, tszHost , INTERNET_INVALID_PORT_NUMBER, tszUser, tszPass, INTERNET_SERVICE_FTP, INTERNET_FLAG_PASSIVE , 0) ) )
    {
        ErrorOut(GetLastError(), TEXT("InternetConnect"));
        return FALSE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    Close
//
// PURPOSE:     Close the opened connection (hConnect)
//                       
///////////////////////////////////////////////////////////////////////////////

BOOL Close(HINTERNET hConnect)
{
    if (!InternetCloseHandle (hConnect) )
    {
        ErrorOut(GetLastError(), TEXT("InternetCloseHandle"));
        return FALSE;
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: ErrorOut
//
// PURPOSE:  This function is used to get extended Internet error.
//
// COMMENTS: Function returns TRUE on success and FALSE on failure.
//
///////////////////////////////////////////////////////////////////////////////

BOOL ErrorOut( DWORD dError, TCHAR *szCallFunc)
{
#ifdef _DEBUG

    TCHAR szTemp[100] = "", *szBuffer=NULL, *szBufferFinal = NULL;
    DWORD  dwIntError , dwLength = 0; 
    wsprintf (szTemp,  "%s error %d\n ", szCallFunc, dError );

    if (dError == ERROR_INTERNET_EXTENDED_ERROR)
    {
        InternetGetLastResponseInfo (&dwIntError, NULL, &dwLength);
        if (dwLength)
        {
            if ( !(szBuffer = (TCHAR *) LocalAlloc ( LPTR,  dwLength) ) )
            {
                lstrcat (szTemp, TEXT ( "Unable to allocate memory to display Internet error code. Error code: ") );
                lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) );
                lstrcat (szTemp, TEXT ("\n") );
                OutputDebugString(szTemp);
                return FALSE;
            }
            if (!InternetGetLastResponseInfo(&dwIntError, (LPTSTR) szBuffer, &dwLength))
            {
                lstrcat (szTemp, TEXT ( "Unable to get Internet error. Error code: ") );
                lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) );
                lstrcat (szTemp, TEXT ("\n") );
                OutputDebugString(szTemp);
                return FALSE;
            }
            if ( !(szBufferFinal = (TCHAR *) LocalAlloc( LPTR,  (strlen (szBuffer) +strlen (szTemp) + 1)  ) )  )
            {
                lstrcat (szTemp, TEXT ( "Unable to allocate memory. Error code: ") );
                lstrcat (szTemp, TEXT (_itoa (GetLastError(), szBuffer, 10)  ) );
                lstrcat (szTemp, TEXT ("\n") );
                OutputDebugString(szTemp0;
                return FALSE;
            }
            lstrcpy (szBufferFinal, szTemp);
            lstrcat (szBufferFinal, szBuffer);
            LocalFree (szBuffer);
            OutputDebugString(szBufferFinal);
            LocalFree (szBufferFinal);
        }
    }
    else {
        OutputDebugString(szTemp);
    }

#endif // _DEBUG

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    CabinetCallback
//
// PURPOSE:     Callback used in ExtractCabinet
//                       
///////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI
CabinetCallback ( IN PVOID pMyInstallData,
                  IN UINT Notification,
                  IN UINT Param1,
                  IN UINT Param2 )
{
   LRESULT lRetVal = NO_ERROR;
   TCHAR szTarget[MAX_PATH];
   FILE_IN_CABINET_INFO *pInfo = NULL;
   FILEPATHS *pFilePaths = NULL;

   lstrcpy(szTarget,tszTargetPath);

   switch(Notification)
   {
      case SPFILENOTIFY_FILEINCABINET:
         pInfo = (FILE_IN_CABINET_INFO *)Param1;
         lstrcat(szTarget, pInfo->NameInCabinet);
         lstrcpy(pInfo->FullTargetName, szTarget);
         lRetVal = FILEOP_DOIT;  // Extract the file.
         break;

      case SPFILENOTIFY_FILEEXTRACTED:
         pFilePaths = (FILEPATHS *)Param1;
         lRetVal = NO_ERROR;
         break;

      case SPFILENOTIFY_NEEDNEWCABINET: // Unexpected.
         lRetVal = NO_ERROR;
         break;
   }

   return lRetVal;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    ExtractCabinet
//
// PURPOSE:     Extract all files stored in the cab file.
//                       
///////////////////////////////////////////////////////////////////////////////

void ExtractCabinet(PTSTR pszCabFile)
{
   if( !SetupIterateCabinet(pszCabFile, 0, (PSP_FILE_CALLBACK)CabinetCallback, 0) )
    {
        ErrorOut( GetLastError(), TEXT("Extract Cab File") );
    }
} 

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    ApplyUpdateInf
//
// PURPOSE:     Run dimapins.inf to install configuration files and images
//                       
///////////////////////////////////////////////////////////////////////////////
void ApplyUpdateInf( void )
{
    TCHAR tszRundll[1024];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    GetWindowsDirectory(tszRundll, sizeof(tszRundll));
#ifdef _UNICODE
    lstrcat(tszRundll, tszFormatRundllNT);
#else
    lstrcat(tszRundll, tszFormatRundll9x);
#endif

	lstrcat(tszRundll, tszTargetPath);
	lstrcat(tszRundll, tszUpdateInf);

    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

    if( CreateProcess(0, tszRundll, 0, 0, 0, 0, 0, 0, &si, &pi) )
    {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }
#ifdef _DEBUG
    else {
    	OutputDebugString(TEXT("JOY.CPL: ApplyUpdateInf: CreateProcess Failed!\n"));
    }
#endif
}

INT_PTR CALLBACK CplUpdateProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
//  HICON hIcon;

    switch (message)
    {
    case WM_INITDIALOG:
//      hIcon = LoadIcon(NULL, IDI_INFORMATION);
//      SendDlgItemMessage(hDlg, IDC_ICON_INFORMATION, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            fRet = TRUE;
            break;

        default:
            break;
        }
        break;

    default:
        break;
    }
    
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:    GetCurDeviceType
//
// PURPOSE:     Get device type of the current selected device
//                       
///////////////////////////////////////////////////////////////////////////////
void GetCurDeviceType(HWND hDlg, TCHAR *tszDeviceType)
{
    DIJOYCONFIG_DX5 diJoyConfig;
    HWND hListCtrl;
    int  id;

    hListCtrl = GetDlgItem(hDlg, IDC_LIST_DEVICE);
    id = GetItemData(hListCtrl, (BYTE)iItem);

    ZeroMemory(&diJoyConfig, sizeof(DIJOYCONFIG_DX5));
    diJoyConfig.dwSize = sizeof(DIJOYCONFIG_DX5);

    // find the assigned ID's  
    if( SUCCEEDED(pDIJoyConfig->GetConfig(pAssigned[id]->ID, (LPDIJOYCONFIG)&diJoyConfig, DIJC_REGHWCONFIGTYPE)) )
    {
#ifdef _UNICODE
        lstrcpy(tszDeviceType, diJoyConfig.wszType );
#else
        USES_CONVERSION;
        lstrcpy(tszDeviceType, W2A(diJoyConfig.wszType) );
#endif
    } 

#if 0
    // change '&' to '_'
    while( tszDeviceType ) {
        if( *tszDeviceType == TEXT('&') ) {
            *tszDeviceType = TEXT('_');
        }
        
        tszDeviceType++;
    }
#endif
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\client\res\dijoy.h ===
#define IDH_101_1002	65667173	// Game Controllers: "&Properties..." (Button)
#define IDH_101_1022	65667180	// Game Controllers: "Refresh" (Button)
#define IDH_101_1010	66191461	// Game Controllers: "A&dd..." (Button)
#define IDH_101_1028	67371109	// Game Controllers: "&Remove..." (Button)
#define IDH_101_1036	67548653	// Game Controllers: "Troubleshoot..." (Button)
#define IDH_101_1058	69337189	// Game Controllers: "&Game Controllers" (Static)
#define IDH_117_1101	72155253	// -: "&Port Driver:" (Static)
#define IDH_117_8197	537198709	// -: "" (ListBox)
#define IDH_117_8198	537264245	// -: "Cha&nge..." (Button)
#define IDH_117_8199	537385268	// Advanced: OEM property sheet check box
#define IDH_119_1039	68092023	// Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049	68092025	// Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059	69402743	// Add Game Controller: "&Controllers:" (Static)
#define IDH_4099_1043	68358147	// Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1044	68358149	// Custom Game Controller: Rudder/Pedals (Button)
#define IDH_4099_1046	68358151	// Custom Game Controller: Z Axis (Button)
#define IDH_4099_1045	68685827	// Custom Game Controller: "" (ComboBox)
#define IDH_4099_1051	68882435	// Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052	68947971	// Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053	69013507	// Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1056	69210115	// Custom Game Controller: "" (Edit)
#define IDH_4099_1058	69410157	// Custom Game Controller: "Is a Joy stick" (Button)
#define IDH_4201_1019	66785385	// Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12290	805507175	// Settings: "Reset to &default" (Button)
#define IDH_4201_12291	805507177	// Settings: "&Calibrate..." (Button)
#define IDH_4203_1023	67047531	// -: "Buttons" (Button)
#define IDH_4203_12293	805638251	// -: "" (ListBox) (X/Y test box)
#define IDH_4203_12308	806621291	// -: "" (ListBox) (all other test boxes)
#define IDH_4203_12309	806686827	// -: "" (POVHAT)
#define IDH_8188_8189	536682492	// Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191	537010170	// Change Controller Assignment: "Selected ID" (ListBox) (Label?)
#define IDH_8188_8194	537010172	// Change Controller Assignment: "" (ListBox)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\clientnt\core.cpp ===
/****************************************************************************
 *
 *  Copyright (C) 2000, 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Tomislav Markoc, (tmarkoc), SDE
 *
 ****************************************************************************/

#include <windows.h>
#include <commctrl.h>//UI only
#include <shfusion.h>//UI only
#define _INC_MMSYSTEM
#define WINMMAPI    DECLSPEC_IMPORT
typedef UINT        MMRESULT;   /* error return code, 0 means no error */
                                /* call as if(err=xxxx(...)) Error(err); else */
// end of hack to avoid including mmsystem.h!!!
#include <gameport.h>
#include <dinput.h>
#include <dinputd.h>
#include <list>
#include <exception>
#include <string>
#include <algorithm>
#include <tchar.h>
#include <windowsx.h>
#include <new.h>
#include "resource.h"
#include "ifacesvr.h"
#include "joyarray.h"

using namespace std;

#define NUMJOYDEVS 16
#define MAX_DEVICES 75
#define IDC_WHATSTHIS 400

#ifdef UNICODE
#define String  wstring
#else
#define String  string
#endif // !UNICODE

#ifdef _CHECKED
#define JOY_EXCEPTION(A) JoyException(_T(__FILE__),__LINE__,A)
#else
#define JOY_EXCEPTION(A) JoyException(A)
#endif

class JoyException:public exception
{
    HRESULT m_hRes;
#ifdef _CHECKED
    String m_SourceFile;
    DWORD m_dwLine;
#endif
public:
    HRESULT GetResult(){return m_hRes;};
    JoyException(
#ifdef _CHECKED
        LPCTSTR lpSourceFile,DWORD dwLine,
#endif
        HRESULT hRes);
};

JoyException::JoyException(
#ifdef _CHECKED
    LPCTSTR lpSourceFile,DWORD dwLine,
#endif
    HRESULT hRes)
{
    m_hRes=hRes;
#ifdef _CHECKED
    m_SourceFile=lpSourceFile;
    m_dwLine=dwLine;
#endif
}

int __cdecl my_new_handler(size_t) {
throw JOY_EXCEPTION(E_OUTOFMEMORY);
return 0;
}

template <class p> class AutoRelease
{
    p m_p;
public:
    AutoRelease(){m_p=NULL;};
    ~AutoRelease(){Clear();};
    void Clear(){
        ULONG nRef=-1;
        if(m_p)
        {
            nRef=m_p->Release();//If last ptr, nRef falls to 0.
        };
        m_p=NULL;};

    AutoRelease(const AutoRelease<p> &R)
        {m_p=R.m_p;m_p->AddRef();};
    AutoRelease<p> &operator=(const AutoRelease<p> &R)
        {m_p=R.m_p;m_p->AddRef();return *this;};
	AutoRelease<p> &operator=(p ptr)
		{m_p=ptr;if(m_p)m_p->AddRef();return *this;};
    p operator->(){return m_p;};
    operator p&(){return m_p;};
    operator p*(){return &m_p;};
};
typedef AutoRelease<LPDIRECTINPUT8> LPDIRECTINPUT_AR;
typedef AutoRelease<LPDIRECTINPUTDEVICE8> LPDIRECTINPUTDEVICE_AR;
typedef AutoRelease<LPDIRECTINPUTJOYCONFIG8> LPDIRECTINPUTJOYCONFIG_AR;

template <class p> class AutoDeleteArray
{
    p m_p;
public:
    AutoDeleteArray(){m_p=NULL;};
    AutoDeleteArray(const p P){m_p=P;};
    ~AutoDeleteArray(){delete[] m_p;};
    p operator=(const p P){m_p=P;return m_p;};
    p operator->(){return m_p;};
    operator p&(){return m_p;};
    operator p*(){return &m_p;};
};

enum EStatus{EConnected,ENotConnected,EUnknown};

//ISSUE-2001/03/29-timgill Should use predefined NULLGUID
const GUID NULLGUID;

class CCore;
class CDIDev
{
friend BOOL CALLBACK DIEnumDevicesProc(
    const DIDEVICEINSTANCE * lpddi,LPVOID pvRef);

    LPDIRECTINPUTDEVICE_AR m_pDID;
    DIDEVICEINSTANCE m_DIDevInst;
    DIDEVCAPS_DX3 m_DIDevCaps;
    DIJOYCONFIG m_DIJoyCfg;
    DWORD m_dwId;

    bool m_bInitialized;
    CCore *m_pCore;
public:
    CDIDev(){m_bInitialized=false;};
    DWORD Id(){return m_dwId;};
    const GUID &InstGUID(){return m_DIDevInst.guidInstance;};
    const GUID &PortGUID(){return m_DIJoyCfg.guidGameport;};
    LPCTSTR InstName(){return m_DIDevInst.tszInstanceName;};
    EStatus Status(){if(m_DIDevCaps.dwFlags&DIDC_ATTACHED)return EConnected;return ENotConnected;};
    void Update(LPDIRECTINPUTJOYCONFIG8 pJoyCfg);
    HRESULT Rename(LPCTSTR pName);
    bool operator==(const GUID &G){if(InstGUID()==G)return true;return false;};
};

class CGprtDev
{
friend BOOL CALLBACK DIEnumJoyTypePr(LPCWSTR pwszTypeName,LPVOID pvRef);
friend class CCore;
    String m_Name;
    DIJOYTYPEINFO m_Info;
public:
    LPCTSTR TypeName(){return m_Name.data();};
    LPCTSTR Name(){return m_Info.wszDisplayName;};
    bool operator==(LPCTSTR pTypeName){if(m_Name==pTypeName)return true;return false;};
    bool Rudder(){if(m_Info.hws.dwFlags&JOY_HWS_HASR)return true;return false;};
};

typedef list<CDIDev> LISTDIDEV;
typedef list<String> LISTSTRING;
typedef list<CGprtDev> LISTGPRTDEV;

class CCore
{
friend HRESULT Properties(HMODULE hMod,HWND hWnd,CCore *pCore,DWORD dwId);
friend BOOL CALLBACK DIEnumJoyTypePr(LPCWSTR pwszTypeName,LPVOID pvRef);
friend class CDIDev;
friend BOOL CALLBACK DIEnumDevicesProc(const DIDEVICEINSTANCE *lpddi,LPVOID pvRef);

    bool m_bAccess;
    bool m_bInitialized;

    virtual void UIUpdate(){};
    LPDIRECTINPUT_AR m_pDI;
    LPDIRECTINPUTJOYCONFIG_AR m_pDIJoyCfg;

    int GetNextAvailableId();
public:
    LISTDIDEV m_ListDIDev;
    LISTSTRING m_GprtDrv;
    LISTGPRTDEV m_GprtBus;
    LISTGPRTDEV m_GprtDev;

    CCore();
    void Initialize(HWND hWnd);
    void Update();
    void UpdateType();
    bool Access(){return m_bAccess;};
    CDIDev *FindDIDev(GUID &G);
    HRESULT Remove(GUID &G);
    void Preferred(GUID &G);
    HRESULT AddDevice
            (LPCTSTR pTypeName,bool bRudder,LPCTSTR pGprtId,GUID &GOccupied);
    bool IsAutoDetectGprt();
    bool IsAvailableVIDPID(String &VIDPIDName);
    bool DuplicateDeviceName(LPCTSTR pName);
    void AddCustomDevice(bool bJoy,bool bPad,bool bYoke,bool bCar,
             int nAxes,bool bZAxis,int nButtons,bool bHasPov,LPCTSTR pName,
             LPCTSTR pVIDPIDName);
    bool IsCustomDevice(LPCTSTR pTypeName);
    bool IsDeviceActive(LPCTSTR pTypeName);
    void DeleteType(LPCTSTR pTypeName);
    CGprtDev *FindGprtDev(LPCTSTR pTypeName);
};

struct SEnumDev
{
    LPDIRECTINPUT8 m_pDI;
    CCore *m_pCore;
    SEnumDev(LISTDIDEV &ListDIDev,LPDIRECTINPUT8 pDI,CCore *pCore)
        {m_pDI=pDI;m_pCore=pCore;};
};

/******************************************************************************
End of header
******************************************************************************/


/******************************************************************************
CDIDev
******************************************************************************/

HRESULT CDIDev::Rename(LPCTSTR pName)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    if(!m_pCore->Access())return DIERR_INSUFFICIENTPRIVS;

    DIPROPSTRING DIPropString;
    ZeroMemory(&DIPropString,sizeof(DIPROPSTRING));
    DIPropString.diph.dwSize=sizeof(DIPROPSTRING);
    DIPropString.diph.dwHeaderSize=sizeof(DIPROPHEADER);
    DIPropString.diph.dwHow=DIPH_DEVICE;
    wcsncpy(DIPropString.wsz,pName,MAX_PATH-1);
    DIPropString.wsz[MAX_PATH-1]=0;
    HRESULT hRes=m_pDID->SetProperty(DIPROP_INSTANCENAME,&DIPropString.diph);
    Update(m_pCore->m_pDIJoyCfg);
    return hRes;
}

void CDIDev::Update(LPDIRECTINPUTJOYCONFIG8 pJoyCfg)
{
    HRESULT hRes=S_OK;

    ZeroMemory(&m_DIDevInst,sizeof(m_DIDevInst));
    m_DIDevInst.dwSize=sizeof(m_DIDevInst);
    hRes=m_pDID->GetDeviceInfo(&m_DIDevInst);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }

    ZeroMemory(&m_DIDevCaps,sizeof(m_DIDevCaps));
    m_DIDevCaps.dwSize=sizeof(m_DIDevCaps);
    hRes=m_pDID->GetCapabilities((LPDIDEVCAPS)&m_DIDevCaps);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }

    //Get Id.
    m_dwId=-1;
    DIPROPDWORD DIPropDW;
    ZeroMemory(&DIPropDW,sizeof(DIPropDW));
    DIPropDW.diph.dwSize=sizeof(DIPROPDWORD);
    DIPropDW.diph.dwHeaderSize=sizeof(DIPROPHEADER);
    DIPropDW.diph.dwHow=DIPH_DEVICE;
    hRes=m_pDID->GetProperty(DIPROP_JOYSTICKID,&DIPropDW.diph);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }
    m_dwId=DIPropDW.dwData;

    //Get gameport.
    ZeroMemory(&m_DIJoyCfg,sizeof(m_DIJoyCfg));
    m_DIJoyCfg.dwSize=sizeof(m_DIJoyCfg);
    hRes=pJoyCfg->GetConfig(m_dwId,&m_DIJoyCfg,DIJC_WDMGAMEPORT);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }
}

/******************************************************************************
CCore
******************************************************************************/

BOOL CALLBACK DIEnumDevicesProc(
    const DIDEVICEINSTANCE *lpddi,LPVOID pvRef)
{
    try
    {
        SEnumDev &ED=*(SEnumDev*)pvRef;

        CDIDev Dev;
        Dev.m_pCore=ED.m_pCore;
        HRESULT hRes=ED.m_pDI->CreateDevice(lpddi->guidInstance,Dev.m_pDID,NULL);
        if(FAILED(hRes))
        {
            throw JOY_EXCEPTION(hRes);
        }
        Dev.Update(ED.m_pCore->m_pDIJoyCfg);
        Dev.m_bInitialized=true;
        ED.m_pCore->m_ListDIDev.push_back(Dev);
    }
    catch(JoyException E)
    {
    }
    catch(exception)
    {
    }
        return DIENUM_CONTINUE;
}

BOOL CALLBACK DIEnumJoyTypePr(LPCWSTR pwszTypeName,LPVOID pvRef)
{
    try
    {
        HRESULT hRes=S_OK;
        
        String TN=pwszTypeName;
        
        SEnumDev &ED=*(SEnumDev*)pvRef;

        DIJOYTYPEINFO JoyInfo;
        ZeroMemory(&JoyInfo,sizeof(JoyInfo));
        JoyInfo.dwSize=sizeof(JoyInfo);

        switch(ED.m_pCore->m_pDIJoyCfg->GetTypeInfo(pwszTypeName,&JoyInfo,DITC_REGHWSETTINGS))
        {
        //Errors to continue with.
        case DIERR_NOTFOUND:
            return DIENUM_CONTINUE;
        //Errors to stop with.
        case DIERR_INVALIDPARAM:
        case DIERR_NOMOREITEMS:
            return DIENUM_STOP;
        }

        if(JoyInfo.hws.dwFlags&JOY_HWS_ISGAMEPORTBUS)
        {
            CGprtDev D;
            D.m_Name=TN;

            ZeroMemory(&D.m_Info,sizeof(D.m_Info));
            D.m_Info.dwSize=sizeof(D.m_Info);
            DWORD dwFlags=DITC_CLSIDCONFIG|DITC_DISPLAYNAME;
            if(FAILED(ED.m_pCore->m_pDIJoyCfg->GetTypeInfo(D.m_Name.data(),&D.m_Info,dwFlags)))
            {
                throw JOY_EXCEPTION(hRes);
            }
            ED.m_pCore->m_GprtBus.push_back(D);
        }
        else if(!(JoyInfo.hws.dwFlags&JOY_HWS_AUTOLOAD))
        {
            CGprtDev D;
            D.m_Name=TN;

            ZeroMemory(&D.m_Info,sizeof(D.m_Info));
            D.m_Info.dwSize=sizeof(D.m_Info);
            DWORD dwFlags=DITC_REGHWSETTINGS|DITC_FLAGS1|DITC_HARDWAREID|DITC_CALLOUT|DITC_DISPLAYNAME;
            if(FAILED(ED.m_pCore->m_pDIJoyCfg->GetTypeInfo(D.m_Name.data(),&D.m_Info,dwFlags)))
            {
                throw JOY_EXCEPTION(hRes);
            }
            ED.m_pCore->m_GprtDev.push_back(D);
        }
    }
    catch(JoyException E)
    {
    }
    catch(exception)
    {
    }
        return DIENUM_CONTINUE;
}

CCore::CCore()
{
    m_bAccess=false;
    m_bInitialized=false;
}

bool CCore::IsAutoDetectGprt()
{
    if(!m_GprtDev.size())return false;
    if(m_GprtDev.front().m_Info.dwFlags1&
        JOYTYPE_NOAUTODETECTGAMEPORT)return false;
    return true;
}

int CCore::GetNextAvailableId()
{
    if(!m_bInitialized)return -1;
    DIJOYCONFIG JoyCfg;
    ZeroMemory(&JoyCfg,sizeof(JoyCfg));
    JoyCfg.dwSize=sizeof(JoyCfg);

    for(int i=0;i<NUMJOYDEVS;i++)
    {
        switch(m_pDIJoyCfg->GetConfig(i,&JoyCfg,DIJC_REGHWCONFIGTYPE))
        {
        case S_FALSE:
        case DIERR_NOMOREITEMS:
        case DIERR_NOTFOUND:
        case E_FAIL:
            return i;
        }
    }
    return -1;
}

HRESULT CCore::AddDevice(LPCTSTR pTypeName,bool bRudder,LPCTSTR pGprtId,GUID &GOccupied)
{
    HRESULT hRes=S_OK;
    GOccupied=NULLGUID;

    if(!m_bInitialized)return E_FAIL;

    if(m_GprtDev.size()>=MAX_DEVICES)return E_FAIL;
    
    LISTGPRTDEV::iterator It;
    It=find(m_GprtDev.begin(),m_GprtDev.end(),pTypeName);
    if(It==m_GprtDev.end())return E_FAIL;
    CGprtDev *pGprtDev=&*It;

    int nId=GetNextAvailableId();
    if(nId==-1)return DIERR_NOTFOUND;

    DIJOYCONFIG JoyCfg;
    ZeroMemory(&JoyCfg,sizeof(JoyCfg));
    JoyCfg.dwSize=sizeof(JoyCfg);
    JoyCfg.hwc.hws=pGprtDev->m_Info.hws;
    JoyCfg.hwc.hws.dwFlags|=JOY_HWS_ISANALOGPORTDRIVER;
    if(bRudder)
    {
        JoyCfg.hwc.hws.dwFlags|=JOY_HWS_HASR;
        JoyCfg.hwc.dwUsageSettings|=JOY_US_HASRUDDER;
    }
    JoyCfg.hwc.dwUsageSettings|=JOY_US_PRESENT;
    //JoyCfg.hwc.dwType=nArrayID;WHY is this beeing set to index?????????????????????????????????????????????????????????????????????????????????
    wcsncpy(JoyCfg.wszCallout,pGprtDev->m_Info.wszCallout,sizeof(JoyCfg.wszCallout)/sizeof(JoyCfg.wszCallout[0])-1);
    wcsncpy(JoyCfg.wszType,pGprtDev->m_Name.data(),sizeof(JoyCfg.wszType)/sizeof(JoyCfg.wszType[0])-1);

    if(SUCCEEDED(hRes=m_pDIJoyCfg->Acquire()))
    {
        if(m_GprtBus.size())
        {
            if(m_GprtBus.size()>1)
            {
                if(pGprtId)
                {
                    String GId=pGprtId;
                    LISTGPRTDEV::iterator It;
                    It=find(m_GprtBus.begin(),m_GprtBus.end(),GId.data());
                    if(It!=m_GprtDev.end())
                    {
                        JoyCfg.guidGameport=It->m_Info.clsidConfig;
                    }
                }
            }
            else
            {
                JoyCfg.guidGameport=m_GprtBus.front().m_Info.clsidConfig;
            }
        }

        if(FAILED(hRes=m_pDIJoyCfg->SetConfig(nId,&JoyCfg,DIJC_REGHWCONFIGTYPE|DIJC_CALLOUT)))
        {
            m_pDIJoyCfg->Unacquire();
            if(hRes==E_ACCESSDENIED)
                GOccupied=JoyCfg.guidGameport;
            return hRes;
        }
        else
        {
            //Fix #55524.
            if(SUCCEEDED(m_pDIJoyCfg->GetConfig(nId,&JoyCfg,DIJC_REGHWCONFIGTYPE)))
            {
                if(!(JoyCfg.hwc.dwUsageSettings&JOY_US_PRESENT))
                {
                    JoyCfg.hwc.dwUsageSettings|=JOY_US_PRESENT;
                    JoyCfg.hwc.hwv.dwCalFlags|=0x80000000;
                    JoyCfg.hwc.hws.dwFlags|=JOY_HWS_ISANALOGPORTDRIVER;
                    m_pDIJoyCfg->SetConfig(nId,&JoyCfg,DIJC_REGHWCONFIGTYPE);
                }
            }
            //End of fix #55524.
        }
        m_pDIJoyCfg->Unacquire();
    }
    Update();
    UpdateType();
    return hRes;
}

void CCore::Initialize(HWND hWnd)
{
    if((LPDIRECTINPUTJOYCONFIG8)m_pDIJoyCfg)
        m_pDIJoyCfg->Release();
    m_pDIJoyCfg=NULL;
    
    if((LPDIRECTINPUT8)m_pDI)
        m_pDI->Release();
    m_pDI=NULL;

    HMODULE hM=GetModuleHandle(NULL);
    if(!hM)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    HRESULT hRes=DirectInput8Create(hM,DIRECTINPUT_VERSION,
        IID_IDirectInput8,(LPVOID*)&m_pDI,NULL);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }
    hRes=m_pDI->QueryInterface(IID_IDirectInputJoyConfig8,(LPVOID*)&m_pDIJoyCfg);
    if(hRes!=DI_OK)
    {
        throw JOY_EXCEPTION(hRes);
    }
    hRes=m_pDIJoyCfg->SetCooperativeLevel(hWnd,DISCL_EXCLUSIVE|DISCL_BACKGROUND);
    if(hRes!=DI_OK)
    {
        throw JOY_EXCEPTION(hRes);
    }
    m_bInitialized=true;
}

void CCore::Update()
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }

    m_bAccess=false;
    m_ListDIDev.clear();

    HRESULT hRes=m_pDIJoyCfg->Acquire();
    if(SUCCEEDED(hRes))
    {
    	m_bAccess=true;
    }

    SEnumDev ED(m_ListDIDev,m_pDI,this);
    hRes=m_pDI->EnumDevices(DI8DEVCLASS_GAMECTRL,DIEnumDevicesProc,&ED,DIEDFL_ALLDEVICES);
    if(FAILED(hRes))
    {
    	//EnumDevices goes wrong
        ; //throw JOY_EXCEPTION(hRes);
    }

    m_pDIJoyCfg->Unacquire();

    UIUpdate();
}

void CCore::UpdateType()
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }

    m_GprtDrv.clear();
    m_GprtBus.clear();
    m_GprtDev.clear();

    HRESULT hRes=S_OK;/*=m_pDIJoyCfg->Acquire();
    if(hRes!=DIERR_INSUFFICIENTPRIVS)
    {
        if(hRes!=DI_OK)
        {
            throw JOY_EXCEPTION(hRes);
        }
        else
            m_bAccess=true;
    }
*/
    SEnumDev ED(m_ListDIDev,m_pDI,this);
    hRes=m_pDIJoyCfg->EnumTypes(DIEnumJoyTypePr,&ED);
    if(FAILED(hRes))
    {
        throw JOY_EXCEPTION(hRes);
    }

//    if(SUCCEEDED(hRes))
//        hRes=m_pDIJoyCfg->Unacquire();

    UIUpdate();
}

CDIDev *CCore::FindDIDev(GUID &Guid)
{
    LISTDIDEV::iterator It;
    It=find(m_ListDIDev.begin(),m_ListDIDev.end(),Guid);
    if(It==m_ListDIDev.end())return NULL;
    return &*It;
}

HRESULT CCore::Remove(GUID &Guid)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    
    CDIDev *pDev=FindDIDev(Guid);
    if(!pDev)return E_FAIL;
    
    HRESULT hRes;
    
    if(FAILED(hRes=m_pDIJoyCfg->Acquire()))return hRes;
    if(FAILED(hRes=m_pDIJoyCfg->DeleteConfig(pDev->Id())))
    {    
        m_pDIJoyCfg->Unacquire();
        return hRes;
    }
    m_pDIJoyCfg->SendNotify();
    m_pDIJoyCfg->Unacquire();
    return S_OK;
}

#define DIJC_ALL DIJC_REGHWCONFIGTYPE|DIJC_CALLOUT|DIJC_WDMGAMEPORT|DIJC_GAIN|DIJC_GUIDINSTANCE

void CCore::Preferred(GUID &G)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
//Set Id of preferred device to 0.
    
    //Find Id of device to be set to 0.
    CDIDev *pDev=FindDIDev(G);
    if(!pDev)return;
    int nId=pDev->Id();
    if(nId==0)//Already preferred.
        return;
    
    if(SUCCEEDED(m_pDIJoyCfg->Acquire()))
    {
//We could call SetConfig only once and DInput on NT or Whistler should
//swap Id-s of two devices. However, it will not work if gameport device
//is unplugged, so we still must swap by salling SetConfig twice.

        DIJOYCONFIG OldId0;
        ZeroMemory(&OldId0,sizeof(OldId0));
        OldId0.dwSize=sizeof(OldId0);
        bool bOldId0=true;
        HRESULT hRes=m_pDIJoyCfg->GetConfig(0,&OldId0,DIJC_ALL);
        if(hRes==DIERR_NOTFOUND||hRes==S_FALSE)
            bOldId0=false;

        DIJOYCONFIG NewId0;
        ZeroMemory(&NewId0,sizeof(NewId0));
        NewId0.dwSize=sizeof(NewId0);
        bool bNewId0=true;
        hRes=m_pDIJoyCfg->GetConfig(nId,&NewId0,DIJC_ALL);
        if(hRes==DIERR_NOTFOUND||hRes==S_FALSE)
            bNewId0=false;

        if(bOldId0)
            m_pDIJoyCfg->SetConfig(nId,&OldId0,DIJC_ALL);
        else 
            //We must still delete because GetConfig could fail for other
            //reasons than device with Id 0 not present.
            m_pDIJoyCfg->DeleteConfig(0);

        if(bNewId0)
            m_pDIJoyCfg->SetConfig(0,&NewId0,DIJC_ALL);

        m_pDIJoyCfg->SendNotify();
        m_pDIJoyCfg->Unacquire();
    }
    Update();
}

//Partialy copied from old joy.cpl.
//I strongly suspect this is not documented anywhere.
bool CCore::IsAvailableVIDPID(String &VIDPIDName)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }

    HRESULT hRes=m_pDIJoyCfg->Acquire();
    if(FAILED(hRes))throw JOY_EXCEPTION(hRes);
    
    //Make the VID/PID to compare from the following formula:
    //VID_045e&PID_100+JOY_HW_LASTENTRY to 100+JOY_HW_LASTENTRY+0xf

    TCHAR Type[18];
    _tcsncpy(Type,_T("VID_045E&PID_0100"),18);
    Type[17] = 0;

    const WCHAR Lookup[]=_T("0123456789ABCDEF");

    int i=JOY_HW_LASTENTRY;
    do
    {
        if(i<0x10)
        {
            Type[16]=Lookup[i];
        }
        else
        {
            Type[15]=Lookup[1];
            Type[16]=Lookup[i%0x10];
        }
        i++;

        HKEY hKey;
        if(FAILED(m_pDIJoyCfg->OpenTypeKey(Type,KEY_READ,&hKey)))
            break;
        RegCloseKey(hKey);
    }
    while(i<(JOY_HW_LASTENTRY+0x11));

    m_pDIJoyCfg->Unacquire();
    if(i<0x1d)
    {
        VIDPIDName=Type;
        return true;
    }
    return false;
}

CGprtDev *CCore::FindGprtDev(LPCTSTR pTypeName)
{
    if(!pTypeName)return NULL;
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    for(LISTGPRTDEV::iterator It=m_GprtDev.begin();
            It!=m_GprtDev.end();It++)
    {
        if(It->m_Name==pTypeName)
            return &(*It);
    }
    return NULL;
}

bool CCore::IsCustomDevice(LPCTSTR pTypeName)
{
    if(!pTypeName)return false;
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    if(pTypeName[0]==_T('#'))return false;//Standard type.
    CGprtDev *pDevType=FindGprtDev(pTypeName);
    if(!pDevType)
        //This should never happend, but just in case.
        throw JOY_EXCEPTION(E_FAIL);
    if(!pDevType->m_Info.wszHardwareId[0])
    {
        if(!pDevType->m_Info.wszCallout[0])
            return true;
    }
    else
    {
        TCHAR AnalogRoot[]=_T("gameport\\vid_045e&pid_01");
        //Test if it is predefined custom. Do not delete.
        TCHAR C=pDevType->m_Info.wszHardwareId[(sizeof(AnalogRoot)/
                sizeof(AnalogRoot[0]))-1];
        if((C==_T('f'))||(C==_T('F')))
            return false;
        //Now test if it is custom.
        if(!_tcsnicmp(pDevType->m_Info.wszHardwareId,AnalogRoot,
                (sizeof(AnalogRoot)/sizeof(AnalogRoot[0]))-1))
            return true;
    }
    return false;
}

void CCore::DeleteType(LPCTSTR pTypeName)
{
    if(!pTypeName)return;
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    HRESULT hRes=m_pDIJoyCfg->Acquire();
    if(FAILED(hRes))throw JOY_EXCEPTION(hRes);
    m_pDIJoyCfg->DeleteType(pTypeName);
    m_pDIJoyCfg->Unacquire();
    UpdateType();
}

bool CCore::IsDeviceActive(LPCTSTR pTypeName)
{
    if(!pTypeName)return false;
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    for(LISTDIDEV::iterator It=m_ListDIDev.begin();
            It!=m_ListDIDev.end();It++)
    {
        DIJOYCONFIG JoyCfg;
        ZeroMemory(&JoyCfg,sizeof(JoyCfg));
        JoyCfg.dwSize=sizeof(JoyCfg);
        if(SUCCEEDED(m_pDIJoyCfg->GetConfig(It->Id(),&JoyCfg,
            DIJC_REGHWCONFIGTYPE)))
        {
            if(!_tcscmp(JoyCfg.wszType,pTypeName))
                return true;
        }
    }
    return false;
}

bool CCore::DuplicateDeviceName(LPCTSTR pName)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }

    for(LISTGPRTDEV::iterator It=m_GprtDev.begin();
            It!=m_GprtDev.end();It++)
    {
        if(!_tcsncmp(pName,It->Name(),
                (sizeof(It->m_Info.wszDisplayName)/
                sizeof(It->m_Info.wszDisplayName[0]))-1))
            return true;
    }
    return false;
}

void CCore::AddCustomDevice(bool bJoy,bool bPad,bool bYoke,bool bCar,
             int nAxes,bool bZAxis,int nButtons,bool bHasPov,LPCTSTR pName,
             LPCTSTR pVIDPIDName)
{
    if(!m_bInitialized)
    {
        throw JOY_EXCEPTION(E_FAIL);
    }
    
    String VIDPIDName=_T("GamePort\\");
    VIDPIDName+=pVIDPIDName;

    HRESULT hRes=m_pDIJoyCfg->Acquire();
    if(FAILED(hRes))throw JOY_EXCEPTION(hRes);

    DIJOYTYPEINFO JTI;
    ZeroMemory(&JTI,sizeof(JTI));
    JTI.dwSize=sizeof(JTI);
    int nCh=sizeof(JTI.wszDisplayName)/
            sizeof(JTI.wszDisplayName[0]);
    _tcsncpy(JTI.wszDisplayName,pName,nCh);
    JTI.wszDisplayName[nCh-1]=0;
    JTI.hws.dwNumButtons=nButtons;
    if(nAxes==3)
    {
        if(bZAxis)
            JTI.hws.dwFlags|=JOY_HWS_HASZ;
        else
            JTI.hws.dwFlags|=JOY_HWS_HASR;
    }
    else if(nAxes==4)
    {
        JTI.hws.dwFlags|=JOY_HWS_HASR|JOY_HWS_HASZ;
    }
    if(bHasPov)
        JTI.hws.dwFlags|=JOY_HWS_HASPOV|JOY_HWS_POVISBUTTONCOMBOS;
    if(!bJoy)
    {
        if(bPad)
        {
            JTI.hws.dwFlags|=JOY_HWS_ISGAMEPAD;
        }
        else if(bCar)
        {
            JTI.hws.dwFlags|=JOY_HWS_ISCARCTRL;
        }
        else
        {
            JTI.hws.dwFlags|=JOY_HWS_ISYOKE;
        }
    }
    nCh=sizeof(JTI.wszHardwareId)/
            sizeof(JTI.wszHardwareId[0]);
    _tcsncpy(JTI.wszHardwareId,VIDPIDName.data(),nCh);
    JTI.wszDisplayName[nCh-1]=0;

    hRes=m_pDIJoyCfg->SetTypeInfo(pVIDPIDName,&JTI,
            DITC_DISPLAYNAME|DITC_CLSIDCONFIG|
            DITC_REGHWSETTINGS|DITC_HARDWAREID,NULL);
    m_pDIJoyCfg->Unacquire();
    if(FAILED(hRes))throw JOY_EXCEPTION(hRes);
    
    UpdateType();
}

/******************************************************************************
UI
******************************************************************************/

/******************************************************************************
UI header
******************************************************************************/

class CDlgProcHandler//this is not in CDlg because we want to reuse for property sheets...
{
protected:
    HWND m_hWnd;
    HMODULE  m_hModule;

    static INT_PTR CALLBACK DialogProc
            (HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
    virtual INT_PTR DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam);
    virtual BOOL InitDialog(HWND hFocus,LPARAM lParam){return TRUE;};
    virtual BOOL Timer(WPARAM wTimerID){return FALSE;};
    virtual INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
    virtual INT_PTR Notify(int idCtrl,LPNMHDR pnmh){return 0;};
    HWND HDlgItem(int nIDDlgItem){return GetDlgItem(m_hWnd,nIDDlgItem);}; 
public:
    CDlgProcHandler(){m_hWnd=NULL;m_hModule=NULL;};
};

class CDlg:public CDlgProcHandler
{
protected:
    virtual INT_PTR DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam);
    virtual INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
public:
    int Dlg(WORD wID,HMODULE  hModule,HWND hParent);
};

int CDlg::Dlg(WORD wID,HMODULE  hModule,HWND hParent)
{
    m_hModule=hModule;
    return DialogBoxParam(hModule,MAKEINTRESOURCE(wID),hParent,
        CDlgProcHandler::DialogProc,(LPARAM)this);
}

typedef list<GUID> LISTGUID;
class CMainDlg;
class CPreferredDlg:public CDlg
{
    LISTGUID m_ListCtrl;    
    bool m_bBlockUpdate;
    CCore *m_pCore;
    CMainDlg *m_pMainDlg;

    virtual BOOL InitDialog(HWND hFocus,LPARAM lParam);
    virtual INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
    void Preferred();
    INT_PTR Notify(int idCtrl,LPNMHDR pnmh);
public:
    CPreferredDlg(CMainDlg *pMainDlg,CCore *pCore)
        {m_pMainDlg=pMainDlg;m_pCore=pCore;m_bBlockUpdate=false;};
    void Update();
};

class CAddDlg:public CDlg
{
    CCore *m_pCore;
//    CMainDlg *m_pMainDlg;
    LISTSTRING m_ListCtrl;
    LISTSTRING m_GprtListCtrl;
    bool m_bBlockUpdate;

    BOOL InitDialog(HWND hFocus,LPARAM lParam);
    INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
    void AddDev();
    INT_PTR DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam);
public:
    CAddDlg(/*CMainDlg *pMainDlg,*/CCore *pCore)
        {/*m_pMainDlg=pMainDlg;*/m_pCore=pCore;m_bBlockUpdate=false;};
    void Update();
};

class CCustomDlg:public CDlg
{
    CCore *m_pCore;
    String m_VIDPIDName;
    BOOL InitDialog(HWND hFocus,LPARAM lParam);
    INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
public:
    CCustomDlg(CCore *pCore){m_pCore=pCore;};
    LPCTSTR GetVIDPIDName(){return m_VIDPIDName.data();};
};

class CMainDlg:public CDlg
{
    LISTGUID m_ListCtrl;    
    bool m_bBlockUpdate;
    CCore *m_pCore;
    CPreferredDlg *m_pPrefDlg;
    CAddDlg *m_pAddDlg;
    bool m_bEditingName;

    virtual BOOL InitDialog(HWND hFocus,LPARAM lParam);
    virtual BOOL Timer(WPARAM wTimerID);
    virtual INT_PTR Command(WORD wNotifyCode,WORD wID,HWND hwndCtl);
    INT_PTR DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam);
    INT_PTR Notify(int idCtrl,LPNMHDR pnmh);
    void Remove();
    void Prop();
protected:
    CMainDlg(){m_pCore=NULL;m_bBlockUpdate=false;m_pPrefDlg=NULL;m_pAddDlg=NULL;m_bEditingName=false;};
    void ConnectUI(CCore *pCore){m_pCore=pCore;};
    void Update();
    void CoreUpdate();
};

class CUpdate
{
    bool *m_pbBlockUpdate;
public:
    CUpdate(bool *pbBlockUpdate)
        {m_pbBlockUpdate=pbBlockUpdate;*m_pbBlockUpdate=true;};
    ~CUpdate(){*m_pbBlockUpdate=false;};
};

/******************************************************************************
End of UI header
******************************************************************************/

#define DEVICE_COLUMN 0
#define STATUS_COLUMN 1

String LoadString(HINSTANCE hInstance,UINT uID)
{
//ISSUE-2001/03/29-timgill  Should find size of resource string and write directly into allocated String object
    TCHAR Str[256];
    LoadString(hInstance,uID,Str,256);
    String S=Str;
    return Str;
}

String Insert1String(LPCTSTR pS,LPCTSTR pI)
{
    LPTSTR pR=new TCHAR[_tcslen(pS)+_tcslen(pI)+1];
    wsprintf(pR,pS,pI);
    String R=pR;
    delete[] pR;
    return R;
}

String Insert2Strings(LPCTSTR pS,LPCTSTR pI1,LPCTSTR pI2)
{
    LPTSTR pR=new TCHAR[_tcslen(pS)+_tcslen(pI1)+_tcslen(pI2)+1];
    wsprintf(pR,pS,pI1,pI2);
    String R=pR;
    delete[] pR;
    return R;
}

void MessageBox(HWND hWnd,HINSTANCE hInstance,UINT uTitleID,UINT uMsgID)
{
    String Title=LoadString(hInstance,uTitleID);
    String Msg=LoadString(hInstance,uMsgID);
    UINT uRTL = (GetWindowLongPtr(hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? MB_RTLREADING : 0;
    MessageBox(hWnd,Msg.data(),Title.data(),MB_ICONHAND|MB_OK|MB_APPLMODAL|uRTL);
}

void LVSetItem(HWND hCtrl,int nItem,int nSubItem, LPCTSTR lpStr)
{
    LVITEM Item;
    ZeroMemory(&Item,sizeof(Item));
    Item.mask=LVIF_TEXT;
    Item.iItem=nItem;
    Item.iSubItem=nSubItem;
    Item.cchTextMax=lstrlen(lpStr);
    Item.pszText=(LPTSTR)lpStr;

    SendMessage(hCtrl,LVM_SETITEM,0,(LPARAM)(const LPLVITEM)&Item);
}

void LVInsertItem(HWND hCtrl,int nItem,int nSubItem,LPCTSTR lpStr,LPARAM lData)
{
    LVITEM Item;
    ZeroMemory(&Item,sizeof(Item));
    Item.mask=LVIF_TEXT|LVIF_PARAM;
    Item.iItem=nItem;
    Item.cchTextMax=lstrlen(lpStr);
    Item.pszText=(LPTSTR)lpStr;
    Item.lParam=lData;

    SendMessage(hCtrl,LVM_INSERTITEM,0,(LPARAM)(const LPLVITEM)&Item);
}

void *LVGetItemDataPtr(HWND hCtrl,int nItem)
{
    LVITEM Item;
    ZeroMemory(&Item,sizeof(LVITEM));
    Item.mask=LVIF_PARAM;
    Item.iItem=nItem;
    if(SendMessage(hCtrl,LVM_GETITEM,0,(LPARAM)(LPLVITEM)&Item))
        return(void*)Item.lParam;
    return NULL;
}

const GUID &LVGetItemGUID(HWND hCtrl,int nItem)
{
    if(nItem<0)return NULLGUID;
    GUID *pG=(GUID*)LVGetItemDataPtr(hCtrl,nItem);
    if(pG)return *pG;
    return NULLGUID;
}

int LVFindGUIDIndex(HWND hCtrl,GUID &G)
{
    int nCnt=ListView_GetItemCount(hCtrl);
    for(int i=0;i<nCnt;i++)
        if(G==LVGetItemGUID(hCtrl,i))return i;
    return -1;
}

int LVGetSel(HWND hCtrl)
{
    return ListView_GetNextItem(hCtrl,-1,LVNI_SELECTED);
}

void LVSetSel(HWND hCtrl,int nItem,bool bSel=true)
{
    if(bSel)
        ListView_SetItemState(hCtrl,nItem,
                            LVIS_FOCUSED|LVIS_SELECTED,0x000F)
    else
        ListView_SetItemState(hCtrl,nItem,
                            0,0x000F);
}

void LVInsertColumn (HWND hCtrl,int nColumn,UINT uID,int nWidth,HINSTANCE hInstance)
{
    LVCOLUMN Col;
    ZeroMemory(&Col,sizeof(Col));
    Col.mask=LVCF_FMT|LVCF_TEXT|LVCF_WIDTH;
    Col.fmt=LVCFMT_CENTER;
    Col.cx=nWidth;
    String S=LoadString(hInstance,uID);
    Col.pszText=(LPTSTR )S.data();//const cast
    SendMessage(hCtrl,LVM_INSERTCOLUMN,(WPARAM)(int)nColumn,(LPARAM)(const LPLVCOLUMN)&Col);
}

INT_PTR CDlgProcHandler::DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        return InitDialog((HWND)wParam,lParam);
    case WM_TIMER:
        return Timer(wParam);
    case WM_COMMAND:
        return Command(HIWORD(wParam),LOWORD(wParam),(HWND)lParam);
    case WM_NOTIFY:
        return Notify((int)wParam,(LPNMHDR)lParam);
    case WM_CONTEXTMENU:
        {
            String HelpFileName=LoadString(m_hModule,IDS_HELPFILENAME);
            WinHelp((HWND)wParam,HelpFileName.data(),HELP_CONTEXTMENU,(ULONG_PTR)gaHelpIDs);
        }
        //Undocumented in msdn but otherwise
        //problem rightclicking title to close.
        return TRUE;
    default:
        return FALSE;
    }
    return FALSE;
}

INT_PTR CDlgProcHandler::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDC_WHATSTHIS:
        {
            String HelpFileName=LoadString(m_hModule,IDS_HELPFILENAME);
            WinHelp(hwndCtl,HelpFileName.data(),HELP_WM_HELP,(ULONG_PTR)gaHelpIDs);
        }
        return 0;
    }
    return 0;
};

INT_PTR CALLBACK CDlgProcHandler::DialogProc
            (HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    CDlgProcHandler* pH=NULL;

    try
    {
        if(uMsg==WM_INITDIALOG)
        {
            SetLastError(0);
            LONG lRet=SetWindowLongPtr(hwndDlg,GWLP_USERDATA,lParam);
            if(GetLastError()&&!lRet) {
                EndDialog(hwndDlg,E_FAIL);
            }
        }
        
        pH=(CDlgProcHandler*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
        if(pH && !IsBadReadPtr(pH, sizeof(CDlgProcHandler)))
        {
            if(uMsg==WM_INITDIALOG) {
                pH->m_hWnd=hwndDlg;
            } 
            
            if( pH->m_hWnd == hwndDlg ) {
                return pH->DialogProc(uMsg,wParam,lParam);
            }
        }
        return FALSE;
    }
    
    catch(JoyException E)
    {
        if(pH)
        {
            if(uMsg==WM_INITDIALOG) {
                EndDialog(pH->m_hWnd,IDCANCEL);
            }
        }
    }

    catch(...)
    {
        if(pH && !IsBadReadPtr(pH, sizeof(CDlgProcHandler))) {
            EndDialog(pH->m_hWnd, IDCANCEL);
        }
        //should report error here, and keep going.
    }

    if(uMsg==WM_INITDIALOG) {
        return TRUE;
    }

    return FALSE;
}

/******************************************************************************
CDlg
******************************************************************************/

INT_PTR CDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDOK:
        if(!(wNotifyCode&~1))
            EndDialog(m_hWnd,IDOK);
        return 0;
    case IDCANCEL:
        if(!(wNotifyCode&~1))
            EndDialog(m_hWnd,IDCANCEL);
        return 0;
    }
    return CDlgProcHandler::Command(wNotifyCode,wID,hwndCtl);
};

INT_PTR CDlg::DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_CLOSE:
        EndDialog(m_hWnd,0);
        return 0;
    }
    return CDlgProcHandler::DialogProc(uMsg,wParam,lParam);
}

/******************************************************************************
Main dialog CMainDlg
******************************************************************************/

void CMainDlg::Remove()
{
    {
        if(!m_pCore->Access())
        {
            MessageBox(m_hWnd,m_hModule,IDS_USER_MODE_TITLE,IDS_USER_MODE);
            return;
        }
        HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
        if(hListCtrl)
        {
            int nSelDev=LVGetSel(hListCtrl);
            if(nSelDev<0)return;
            GUID G=LVGetItemGUID(hListCtrl,nSelDev);
            CDIDev *pDev=m_pCore->FindDIDev(G);
            //ISSUE-2001/03/29-timgill  internal error;SHOULD ASSERT HERE
            if(!pDev)return;
            String AreSure=LoadString(m_hModule,IDS_GEN_AREYOUSURE);
            AreSure=Insert1String(AreSure.data(),pDev->InstName());
            String Title=LoadString(m_hModule,IDS_GEN_AREYOUSURE_TITLE);

            UINT uRTL = (GetWindowLongPtr(m_hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? MB_RTLREADING : 0;
            if(IDYES!=MessageBox(m_hWnd,AreSure.data(),Title.data(),MB_ICONQUESTION|MB_YESNO|MB_APPLMODAL|uRTL))
                return;
            if(m_pCore->Remove(G)==DIERR_UNSUPPORTED)
                MessageBox(m_hWnd,m_hModule,IDS_GEN_AREYOUSURE_TITLE,IDS_GEN_NO_REMOVE_USB);

        }   
    }
    CoreUpdate();
}

void OnHelp(LPHELPINFO pHelpInfo,HINSTANCE hInstance)
{
    String FileName=LoadString(hInstance,IDS_HELPFILENAME);
    if(pHelpInfo->iContextType==HELPINFO_WINDOW)
        WinHelp((HWND)pHelpInfo->hItemHandle,FileName.data(),HELP_WM_HELP,(ULONG_PTR)gaHelpIDs);
}

INT_PTR CMainDlg::DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_ACTIVATEAPP:
        CoreUpdate();
        return 0;
/*    case WM_POWERBROADCAST:
        switch( wParam )
        {
        return 0;
        case PBT_APMSUSPEND:
            // Suspend operation!
            KillTimer(hDlg, ID_MYTIMER);
            break;

        case PBT_APMRESUMESUSPEND:
        case PBT_APMRESUMECRITICAL:
            // Resume operation!
            SetActive(hDlg);
            break;
        }
        break;return 0;*/
    case WM_DEVICECHANGE:
        CoreUpdate();        
        return 0;
    case WM_HELP:
        OnHelp((LPHELPINFO)lParam,m_hModule);
        return 0;
/*        nFlags &= ~ON_PAGE;
        KillTimer(hDlg, ID_MYTIMER);
        OnContextMenu(wParam, lParam);
        nFlags |= ON_PAGE;
        SetTimer(hDlg, ID_MYTIMER, POLLRATE, 0);
        return(1);        return 0;???
*/
    case WM_SYSCOLORCHANGE:
        {
            HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
            if(hListCtrl)
            {
                SendMessage(hListCtrl,WM_SYSCOLORCHANGE,0,0);
            }
        }
        return 0;
    }
    return CDlg::DialogProc(uMsg,wParam,lParam);
}

void CMainDlg::Prop()
{
    HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
    if(hListCtrl)
    {
        int nSelDev=LVGetSel(hListCtrl);
        if(nSelDev<0)return;
        GUID G=LVGetItemGUID(hListCtrl,nSelDev);
        CDIDev *pDev=m_pCore->FindDIDev(G);
        //ISSUE-2001/03/29-timgill  internal error;SHOULD ASSERT HERE
        if(!pDev)return;
                //need to kill the timer before launching property sheet - see Whistler bug 260145 for details
                KillTimer(m_hWnd,1);
        switch(Properties(m_hModule,m_hWnd,m_pCore,pDev->Id()))
        {
        case E_NOINTERFACE:
            MessageBox(m_hWnd,m_hModule,IDS_INTERNAL_ERROR,IDS_NO_DIJOYCONFIG);
            break;
        default://Not handled for now or ever?
            break;
        };
                //now update and re-set the timer
                m_pCore->Update();
                SetTimer(m_hWnd,1,5000,NULL);
    }
}

INT_PTR CMainDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDC_BTN_ADV:
        if(!m_pPrefDlg)
        {
            CPreferredDlg PrefDlg(this,m_pCore);
            m_pPrefDlg=&PrefDlg;
            PrefDlg.Dlg(IDD_ADV_CHANGE,m_hModule,m_hWnd);
            m_pPrefDlg=NULL;
        }
        return 0;
    case IDC_BTN_REMOVE:
        Remove();
        return 0;
    case IDC_BTN_ADD:
        if(!m_pAddDlg)
        {
            CAddDlg AddDlg(m_pCore);
            m_pAddDlg=&AddDlg;
            AddDlg.Dlg(IDD_ADD,m_hModule,m_hWnd);
            m_pAddDlg=NULL;
        }
        return 0;
    case IDC_BTN_TSHOOT:
        {
            TCHAR ExeBuff[MAX_PATH];

            if( GetWindowsDirectory(ExeBuff,MAX_PATH) ) {
                String Cmd=LoadString(m_hModule,IDS_TSHOOT_CMD);
                STARTUPINFO Si;
                PROCESS_INFORMATION Pi;
                ZeroMemory(&Si,sizeof(Si));
                ZeroMemory(&Pi,sizeof(Pi));
                Si.cb=sizeof(Si);
// ISSUE-2000/12/20-MarcAnd Quick Fix to use HSS
// In other places where HSS is used, STARTF_FORCEONFEEDBACK is not set 
// Changed IDS_TSHOOT_CMD from: "hh.exe joy.chm" 
// to "explorer.exe hcp://help/tshoot/tsInputDev.htm"
// Need to make this OS specific to allow backprop to Win2k (or further)
                Si.dwFlags=STARTF_USESHOWWINDOW|STARTF_FORCEONFEEDBACK;
                Si.wShowWindow=SW_NORMAL;

                ExeBuff[MAX_PATH-1]=0;
                String Exe=ExeBuff;
                if(Exe[Exe.size()-1]!=_T('\\'))
                {
                    Exe+=_T('\\');
                }
                Exe+=_T("explorer.exe");
                Cmd=_T("\"")+Exe+_T("\"")+_T(" ")+Cmd;

                if(CreateProcess(Exe.data(),(LPTSTR)Cmd.data(),0,0,0,0,0,0,&Si,&Pi))
                {
                    CloseHandle(Pi.hThread);
                    CloseHandle(Pi.hProcess);
                }
            } else {
            	// something is wrong when calling GetWindowsDirectory
            	;
            }
        }
        return 0;
    case IDC_BTN_PROPERTIES:
        Prop();
        return 0;
    }
    return CDlg::Command(wNotifyCode,wID,hwndCtl);
};

INT_PTR CMainDlg::Notify(int idCtrl,LPNMHDR pnmh)
{
    switch(pnmh->code )
    {
/*  Keeping this just in case someone changes his/her mind soon.  
    case LVN_BEGINLABELEDIT:
    {
        HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
        if(!hListCtrl)return TRUE;
        if(!m_pCore->Access())return TRUE;
        PostMessage((HWND)::SendMessage(hListCtrl,LVM_GETEDITCONTROL,0,0),EM_SETLIMITTEXT,MAX_PATH-1,0);
        m_bEditingName=true;
        return(FALSE);   
    }
    case LVN_ENDLABELEDIT:
    {
        m_bEditingName=false;
        HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
        if(!hListCtrl)
        {
            CoreUpdate();
            return FALSE;
        }

        HWND hCtrl=(HWND)SendMessage(hListCtrl,LVM_GETEDITCONTROL,0,0);
        if(hCtrl)
        {
            if(SendMessage(hCtrl,EM_GETMODIFY,0,0))
            {
                int nLen=lstrlen(((NMLVDISPINFO*)pnmh)->item.pszText);
                if((nLen>(MAX_PATH-1))||(nLen==0))
                    MessageBeep(MB_ICONHAND);
                //Make sure the name is usable.
                else if(_tcschr(((NMLVDISPINFO*)pnmh)->item.pszText,TEXT('\\')))
                    MessageBox(m_hWnd,m_hModule,IDS_INVALID_NAME_TITLE,IDS_INVALID_NAME);
                else
                {
                    int nSelDev=LVGetSel(hListCtrl);
                    GUID SelGUID=LVGetItemGUID(hListCtrl,nSelDev);
                    CDIDev *pSelDev=m_pCore->FindDIDev(SelGUID);

                    if(SUCCEEDED(pSelDev->Rename(((NMLVDISPINFO *)pnmh)->item.pszText)))
                    {
                        CoreUpdate();
                        return TRUE;
                    } 
                    else
                    {
                        MessageBox(m_hWnd,m_hModule,IDS_NO_RENAME_TITLE,IDS_NO_RENAME);
                    }
                }
            }
        }
        CoreUpdate();
        return FALSE;
    }*/
    case LVN_KEYDOWN:
        switch(((LV_KEYDOWN*)pnmh)->wVKey)
        {
        case VK_DELETE:
            Remove();
            return 0;

        case VK_F5:
            CoreUpdate();
            return 0;
        }
        return 0;
    case LVN_ITEMCHANGED:
        if(!(((LPNMLISTVIEW)pnmh)->uOldState&LVIS_SELECTED)&&
            (((LPNMLISTVIEW)pnmh)->uNewState&LVIS_SELECTED)&&
            (((LPNMLISTVIEW)pnmh)->uChanged&LVIF_STATE))
                Update();
        return 0;
    case NM_DBLCLK:
        switch(idCtrl)
        {
        case IDC_LIST_DEVICE:
            Prop();
            return 0;
        }
        return 0;
    }
    return 0;
}

void CMainDlg::CoreUpdate()
{
    m_pCore->Update();
    //KillTimer so if UI is updated for some other reason than WM_TIMER timer will be reset.
    //make sure nothing can fail between KillTimer and SetTimer.
    KillTimer(m_hWnd,1);
    SetTimer(m_hWnd,1,5000,NULL);
}

BOOL CMainDlg::InitDialog(HWND hFocus,LPARAM lParam)
{
    SetTimer(m_hWnd,1,5000,NULL);
    m_pCore->Initialize(m_hWnd);
//#wi315410. we need to decide...
//    m_pCore->UpdateType();
    
    HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
    if(hListCtrl)
    {
        SendMessage(hListCtrl,LVM_SETEXTENDEDLISTVIEWSTYLE,0,LVS_EX_FULLROWSELECT);
        RECT R;
        GetClientRect(hListCtrl,&R);
        int nWidth=(R.right>>2)*3;
        LVInsertColumn(hListCtrl,DEVICE_COLUMN,IDS_GEN_DEVICE_HEADING,nWidth,m_hModule);
        LVInsertColumn(hListCtrl,STATUS_COLUMN,IDS_GEN_STATUS_HEADING,R.right-nWidth,m_hModule);
    }
    CoreUpdate();
    return TRUE;
}

BOOL CMainDlg::Timer(WPARAM wTimerID)
{
    CoreUpdate();
    return FALSE;
}

void CMainDlg::Update()
{
    if(m_pPrefDlg)m_pPrefDlg->Update();

    if(m_bEditingName)return;//Do not update this dialog when editing name.
    if(m_bBlockUpdate)return;//Some actions may send notify messages which then Update and overflow stack.
    CUpdate U(&m_bBlockUpdate);

    int nSelDev=-1;
    GUID SelGUID=NULLGUID;
    
    HWND hListCtrl=HDlgItem(IDC_LIST_DEVICE);
    if(hListCtrl)
    {
        nSelDev=LVGetSel(hListCtrl);
        SelGUID=LVGetItemGUID(hListCtrl,nSelDev);

        SendMessage(hListCtrl,WM_SETREDRAW,(WPARAM)FALSE,0);
        SendMessage(hListCtrl,LVM_DELETEALLITEMS,0,0);
        m_ListCtrl.clear();//Must be behind LVM_DELETEALLITEMS
        int nIndex=0;
        for(LISTDIDEV::iterator It=m_pCore->m_ListDIDev.begin();
                It!=m_pCore->m_ListDIDev.end();It++)
        {
            GUID G=It->InstGUID();
            m_ListCtrl.push_back(G);
            LVInsertItem(hListCtrl,nIndex,DEVICE_COLUMN,
                It->InstName(),(LPARAM)&m_ListCtrl.back());

            String Status;
            if(It->Status()==ENotConnected)
                Status=LoadString(m_hModule,IDS_GEN_STATUS_NOTCONNECTED);
            else if(It->Status()==EConnected)
                Status=LoadString(m_hModule,IDS_GEN_STATUS_OK);
            else
                Status=LoadString(m_hModule,IDS_GEN_STATUS_UNKNOWN);
            LVSetItem(hListCtrl,nIndex,STATUS_COLUMN,Status.data());
            nIndex++;
        }

        nSelDev=LVFindGUIDIndex(hListCtrl,SelGUID);
        if(nSelDev>=0)
        {
            LVSetSel(hListCtrl,nSelDev);
        }
        else
            LVSetSel(hListCtrl,0);
        nSelDev=LVGetSel(hListCtrl);
        
        SendMessage(hListCtrl,WM_SETREDRAW,(WPARAM)TRUE,0);
        InvalidateRect(hListCtrl,NULL,TRUE);
        SelGUID=LVGetItemGUID(hListCtrl,nSelDev);
    }
    CDIDev *pSelDev=m_pCore->FindDIDev(SelGUID);
   
//#wi315410. we need to decide...
//    HWND hAddBtn=HDlgItem(IDC_BTN_ADD);
//    if(hAddBtn)
//    {
//        BOOL bE=(m_pCore->m_GprtBus.size()>0)?TRUE:FALSE;
//        EnableWindow(hAddBtn,bE);
//    }
    HWND hRemBtn=HDlgItem(IDC_BTN_REMOVE);
    if(hRemBtn)
    {
        BOOL bE=(nSelDev>=0)?TRUE:FALSE;
        EnableWindow(hRemBtn,bE);
    }
    HWND hPropBtn=HDlgItem(IDC_BTN_PROPERTIES);
    if(hPropBtn)
    {
        BOOL bE=FALSE;
        if((nSelDev>=0)&&pSelDev)
                if(pSelDev->Status()==EConnected)
                    bE=TRUE;
        EnableWindow(hPropBtn,bE);
    }
}

/******************************************************************************
Add dialog
******************************************************************************/

int CBGetCurSel(HWND hCtrl)
{
    int i=ComboBox_GetCurSel(hCtrl);
    if(i==CB_ERR)
        i=-1;
    return i;    
}

int CBGetCnt(HWND hCtrl)
{
    int i=ComboBox_GetCount(hCtrl);
    if(i==CB_ERR)
        i=0;
    return i;    
}

const GUID &CBGetItemGUID(HWND hCtrl,int iIndex)
{
    LRESULT p=ComboBox_GetItemData(hCtrl,iIndex);
    if(p==CB_ERR)return NULLGUID;
    if(p)
        return *(GUID*)p;
    return NULLGUID;
}

int CBFindGUIDIndex(HWND hCtrl,const GUID &G)
{
    int nCnt=ComboBox_GetCount(hCtrl);
    if(nCnt==CB_ERR)return -1;
    for(int i=0;i<nCnt;i++)
    {
        if(CBGetItemGUID(hCtrl,i)==G)
            return i;
    }
    return -1;
}

LPCTSTR CBGetItemTypeName(HWND hCtrl,int iIndex)
{
    LRESULT p=ComboBox_GetItemData(hCtrl,iIndex);
    if(p==CB_ERR)return NULL;
    if(p)
        return ((String*)p)->data();
    return NULL;
}

int CBFindTypeNameIndex(HWND hCtrl,LPCTSTR pTypeName)
{
    int nCnt=ComboBox_GetCount(hCtrl);
    if(nCnt==CB_ERR)return -1;
    String TN;
    if(pTypeName)
        TN=pTypeName;
    for(int i=0;i<nCnt;i++)
    {
        if(CBGetItemTypeName(hCtrl,i)==TN)
            return i;
    }
    return -1;
}

int LBGetCurSel(HWND hCtrl)
{
    int i=ListBox_GetCurSel(hCtrl);
    if(i==LB_ERR)return -1;
    return i;
}

LPCTSTR LBGetItemTypeName(HWND hCtrl,int iIndex)
{
    LRESULT p=ListBox_GetItemData(hCtrl,iIndex);
    if(p==LB_ERR)return NULL;
    if(p)
        return ((String*)p)->data();
    return NULL;
}

int LBFindTypeNameIndex(HWND hCtrl,LPCTSTR pTypeName)
{
    int nCnt=ListBox_GetCount(hCtrl);
    if(nCnt==LB_ERR)return -1;
    String TN;
    if(pTypeName)
        TN=pTypeName;
    for(int i=0;i<nCnt;i++)
    {
        if(LBGetItemTypeName(hCtrl,i)==TN)
            return i;
    }
    return -1;
}

BOOL CAddDlg::InitDialog(HWND hFocus,LPARAM lParam)
{
    m_pCore->UpdateType();
    Update();
    return TRUE;
}

void CAddDlg::Update()
{
    if(m_bBlockUpdate)return;//Some actions may send notify messages which then Update and overflow stack.
    CUpdate U(&m_bBlockUpdate);

    if(!m_hWnd)return;
//Update device list.    
    int nSelDev=-1;
    String TypeName;
    
    HWND hListCtrl=HDlgItem(IDC_DEVICE_LIST);
    if(hListCtrl)
    {
        int nTopIndex=ListBox_GetTopIndex(hListCtrl);
        nSelDev=LBGetCurSel(hListCtrl);
        LPCTSTR pTypeName=LBGetItemTypeName(hListCtrl,nSelDev);
        if(pTypeName)TypeName=pTypeName;

        SetWindowRedraw(hListCtrl,FALSE);
        ListBox_ResetContent(hListCtrl);
        m_ListCtrl.clear();//Must be behind ListBox_ResetContent
        for(LISTGPRTDEV::iterator It=m_pCore->m_GprtDev.begin();
                It!=m_pCore->m_GprtDev.end();It++)
        {
            String S=It->TypeName();
            m_ListCtrl.push_back(S);
            int nIndex=ListBox_AddString(hListCtrl,It->Name());
            ListBox_SetItemData(hListCtrl,nIndex,&m_ListCtrl.back());
        }

        nSelDev=LBFindTypeNameIndex(hListCtrl,TypeName.data());
        if(nSelDev>=0)
            ListBox_SetCurSel(hListCtrl,nSelDev);
        else
            ListBox_SetCurSel(hListCtrl,0);
        
        ListBox_SetTopIndex(hListCtrl,nTopIndex);
        SetWindowRedraw(hListCtrl,TRUE);
        InvalidateRect(hListCtrl,NULL,TRUE);

        nSelDev=LBGetCurSel(hListCtrl);
    }

    HWND hRudder=HDlgItem(IDC_JOY1HASRUDDER);
    if(hRudder)
    {
        BOOL bE=FALSE;
        if(nSelDev>=0)
        {
            LPCTSTR pTypeName=LBGetItemTypeName(hListCtrl,nSelDev);
            if(pTypeName)
            {
                LISTGPRTDEV::iterator It;
                It=find(m_pCore->m_GprtDev.begin(),m_pCore->m_GprtDev.end(),pTypeName);
                if(It!=m_pCore->m_GprtDev.end())
                    bE=It->Rudder()?FALSE:TRUE;
            }
        }
        EnableWindow(hRudder,bE);
    }    

//Update gameport list.
    nSelDev=-1;
    TypeName;
    
    HWND hListCtrlTitle=HDlgItem(IDC_GAMEPORT);
    hListCtrl=HDlgItem(IDC_GAMEPORTLIST);
    if(hListCtrl&&hListCtrlTitle)
    {
        SetWindowRedraw(hListCtrl,FALSE);
        SetWindowPos(hListCtrl,NULL,NULL,NULL,NULL,NULL,
            SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_HIDEWINDOW);

        //How many gameports. Gameport list only if more than 1.
        if(m_pCore->m_GprtBus.size()>1)
        {
            ShowWindow(hListCtrlTitle,SW_SHOWNA);

            nSelDev=CBGetCurSel(hListCtrl);
            LPCTSTR pTypeName=CBGetItemTypeName(hListCtrl,nSelDev);
            if(pTypeName)TypeName=pTypeName;

            ComboBox_ResetContent(hListCtrl);
            m_GprtListCtrl.clear();//Must be behind ComboBox_ResetContent
            for(LISTGPRTDEV::iterator It=m_pCore->m_GprtBus.begin();
                    It!=m_pCore->m_GprtBus.end();It++)
            {
                String S=It->TypeName();
                m_GprtListCtrl.push_back(S);
                int nIndex=ComboBox_AddString(hListCtrl,It->Name());
                ComboBox_SetItemData(hListCtrl,nIndex,&m_GprtListCtrl.back());
            }

            nSelDev=CBFindTypeNameIndex(hListCtrl,TypeName.data());
            if(nSelDev>=0)
                ComboBox_SetCurSel(hListCtrl,nSelDev);
            else
                ComboBox_SetCurSel(hListCtrl,0);
            SetWindowPos(hListCtrl,NULL,NULL,NULL,NULL,NULL,
                SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);
        }
        else
        {
            ShowWindow(hListCtrlTitle,SW_HIDE);
        }
        SetWindowRedraw(hListCtrl,TRUE);
        InvalidateRect(hListCtrl,NULL,TRUE);
    }

    HWND hCustomBtn=HDlgItem(IDC_CUSTOM);
    if(hCustomBtn)
    {
        BOOL bE=(m_pCore->m_GprtDev.size()<MAX_DEVICES)?TRUE:FALSE;
        EnableWindow(hCustomBtn,bE);
    }
}

void CAddDlg::AddDev()
{
    HWND hListCtrl=HDlgItem(IDC_DEVICE_LIST);
    HWND hRudder=HDlgItem(IDC_JOY1HASRUDDER);
    if(hListCtrl&&hRudder)
    {
        int nSelDev=LBGetCurSel(hListCtrl);
        LPCTSTR pTypeName=LBGetItemTypeName(hListCtrl,nSelDev);

        HWND hListCtrlGprt=HDlgItem(IDC_GAMEPORTLIST);
        nSelDev=CBGetCurSel(hListCtrlGprt);
        LPCTSTR pGprtTypeName=CBGetItemTypeName(hListCtrlGprt,nSelDev);
        if(!pGprtTypeName)
        {
            pGprtTypeName=m_pCore->m_GprtBus.front().TypeName();
        }
        if(pTypeName&&pGprtTypeName)
        {
            GUID GOccupied=NULLGUID;
            HRESULT hRes=m_pCore->AddDevice(pTypeName,Button_GetCheck(hRudder)?true:false,pGprtTypeName,GOccupied);
            if(!SUCCEEDED(hRes))
            switch(hRes)
            {
            case E_FAIL:
                break;
            case E_ACCESSDENIED:
                if(GOccupied!=NULLGUID)
                {
                //Find device which occupies the port.
                    for(LISTDIDEV::iterator It=m_pCore->m_ListDIDev.begin();It!=m_pCore->m_ListDIDev.end();It++)
                    {
                        if(It->PortGUID()==GOccupied)
                        {
                            String Title=LoadString(m_hModule,IDS_ADD_PORT_OCCUPIED);
                            String Msg=LoadString(m_hModule,IDS_ADD_PORT_MSGFORMAT);
                            //Get gameport name.
                            LPCTSTR pBus=_T(" ");
                            LISTGPRTDEV::iterator It;
                            It=find(m_pCore->m_GprtBus.begin(),m_pCore->m_GprtBus.end(),pGprtTypeName);
                            if(It!=m_pCore->m_GprtBus.end())
                                pBus=It->Name();
                            //Get device name.
                            LPCTSTR pDev=_T(" ");
                            LISTDIDEV::iterator ItDN;
                            for(ItDN=m_pCore->m_ListDIDev.begin();ItDN!=m_pCore->m_ListDIDev.end();ItDN++)
                                if(ItDN->PortGUID()==GOccupied)break;
                            if(ItDN!=m_pCore->m_ListDIDev.end())
                                pDev=ItDN->InstName();

                            Msg=Insert2Strings(Msg.data(),pDev,pBus);
                            UINT uRTL = (GetWindowLongPtr(m_hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? MB_RTLREADING : 0;
                            MessageBox(m_hWnd,Msg.data(),Title.data(),MB_ICONHAND|MB_OK|MB_APPLMODAL|uRTL);
                            break;
                        }
                    }
                }
                break;
            case DIERR_DEVICEFULL:
                MessageBox(m_hWnd,m_hModule,IDS_GAMEPORT_OCCUPIED_TITLE,IDS_GAMEPORT_OCCUPIED);
                break;
            case DIERR_NOTFOUND:
                MessageBox(m_hWnd,m_hModule,IDS_NO_IDS_TITLE,IDS_NO_IDS);
                break;
            case DIERR_DEVICENOTREG:
                MessageBox(m_hWnd,m_hModule,IDS_NO_GAMENUM_TITLE,IDS_NO_GAMENUM);
                break;
            }
        }
    }
    EndDialog(m_hWnd,IDOK);
}

INT_PTR CAddDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDOK:
        AddDev();
        return 0;
    case IDC_CUSTOM:
        {
            CCustomDlg CustomDlg(m_pCore);
            if(CustomDlg.Dlg(IDD_CUSTOM,m_hModule,m_hWnd)==IDOK)
            {
                Update();
                //Now select new custom device in this dialog box.
                HWND hListCtrl=HDlgItem(IDC_DEVICE_LIST);
                if(hListCtrl)
                {
                    int nSelDev=LBFindTypeNameIndex(hListCtrl,CustomDlg.GetVIDPIDName());
                    if(nSelDev>=0)
                    {
                        ListBox_SetCurSel(hListCtrl,nSelDev);
                    }
                }
            }
        }
        return 0;
    case IDC_DEVICE_LIST:
        switch(wNotifyCode)
        {
        case LBN_DBLCLK:
            AddDev();
            return 0;
        case LBN_SELCHANGE:
            Update();
            return 0;
        }
        return 0;
    }
    return CDlg::Command(wNotifyCode,wID,hwndCtl);
}

INT_PTR CAddDlg::DialogProc(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_VKEYTOITEM:
        if(LOWORD(wParam)==VK_DELETE)
        {
            HWND hListCtrl=HDlgItem(IDC_DEVICE_LIST);
            if(hListCtrl)
            {
                int nSelDev=LBGetCurSel(hListCtrl);
                LPCTSTR pTypeName=LBGetItemTypeName(hListCtrl,nSelDev);
                if(pTypeName)
                {
                    if(m_pCore->IsCustomDevice(pTypeName))
                    {
                        if(!m_pCore->IsDeviceActive(pTypeName))
                        {
                            CGprtDev *pDev=m_pCore->FindGprtDev(pTypeName);
                            if(!pDev)
                                //This should never happend, but just in case.
                                throw JOY_EXCEPTION(E_FAIL);
                            String S=LoadString
                                (m_hModule,IDS_GEN_AREYOUSURE);
                            S=Insert1String(S.data(),pDev->Name());
                            String Title=LoadString(
                                m_hModule,IDS_GEN_AREYOUSURE_TITLE);
                            UINT uRTL = (GetWindowLongPtr(m_hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ? MB_RTLREADING : 0;
                            if(MessageBox(m_hWnd,S.data(),Title.data(),
                                MB_ICONQUESTION|MB_YESNO|MB_APPLMODAL|uRTL)==
                                IDYES)
                            {
                                m_pCore->DeleteType(pTypeName);
                            }
                        }
                        else
                        {
                            MessageBox(m_hWnd,m_hModule,
                                IDS_GEN_AREYOUSURE_TITLE,IDS_NO_REMOVE);
                        }
                    }
                }
            }
        }
        else return -1;
        return 0;
    }
    return CDlg::DialogProc(uMsg,wParam,lParam);
}

/******************************************************************************
Custom dialog
******************************************************************************/

#define MAX_ANALOG_BUTTONS 4
#define MIN_ANALOG_AXIS    2
#define MAX_ANALOG_AXIS    4
#define MAX_STR_LEN	255

BOOL CCustomDlg::InitDialog(HWND hFocus,LPARAM lParam)
{
    if(!m_pCore->IsAvailableVIDPID(m_VIDPIDName))
    {
        MessageBox(m_hWnd,m_hModule,IDS_NO_NAME_TITLE,IDS_NOAVAILABLEVIDPID);
        EndDialog(m_hWnd,IDCANCEL);
        return TRUE;
    }
    HWND hButtons=HDlgItem(IDC_COMBO_BUTTONS);
    if(hButtons)
    {
        for(int i=0;i<=MAX_ANALOG_BUTTONS;i++)
        {
            TCHAR Str[32];
            _sntprintf(Str,32,_T("%d"),i);
            Str[31]=0;
            ComboBox_InsertString(hButtons,i,Str);
        }
        ComboBox_SetCurSel(hButtons,MAX_ANALOG_BUTTONS);
    }
    HWND hAxis=HDlgItem(IDC_COMBO_AXIS);
    if(hAxis)
    {
        for(int i=MIN_ANALOG_AXIS;i<=MAX_ANALOG_AXIS;i++)
        {
            TCHAR Str[32];
            _sntprintf(Str,32,_T("%d"),i);
            Str[31]=0;
            ComboBox_InsertString(hAxis,i-MIN_ANALOG_AXIS,Str);
        }
        ComboBox_SetCurSel(hAxis,0);
    }
    HWND hSpecJoy=HDlgItem(IDC_SPECIAL_JOYSTICK);
    if(hSpecJoy)
        Button_SetCheck(hSpecJoy,BST_CHECKED);
    HWND hEdit=HDlgItem(IDC_EDIT_NAME);
    if(hEdit)
        Edit_LimitText(hEdit,MAX_STR_LEN);
    HWND hHasZAxis=HDlgItem(IDC_HASZAXIS);
    if(hHasZAxis)
        Button_SetCheck(hHasZAxis,BST_CHECKED);

    return TRUE;
}

INT_PTR CCustomDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDOK:
        {
            HWND hJoy=HDlgItem(IDC_SPECIAL_JOYSTICK);
            HWND hYoke=HDlgItem(IDC_SPECIAL_YOKE);
            HWND hPad=HDlgItem(IDC_SPECIAL_PAD);
            HWND hCar=HDlgItem(IDC_SPECIAL_AUTO);
            HWND hAxis=HDlgItem(IDC_COMBO_AXIS);
            HWND hRudder=HDlgItem(IDC_HASRUDDER);
            HWND hZAxis=HDlgItem(IDC_HASZAXIS);
            HWND hButtons=HDlgItem(IDC_COMBO_BUTTONS);
            HWND hPov=HDlgItem(IDS_CUSTOM_HASPOV);
            HWND hEdit=HDlgItem(IDC_EDIT_NAME);
            if(hJoy&&
                hYoke&&
                hPad&&
                hCar&&
                hAxis&&
                hRudder&&
                hZAxis&&
                hButtons&&
                hPov&&
                hEdit)//Possible internal error.
            {
                TCHAR *pStr=NULL;
                bool bErr=false;

                int nLen=Edit_LineLength(hEdit,0);//Possible internal error.
                if(!nLen)
                {
                    bErr=true;
                    MessageBox(m_hWnd,m_hModule,IDS_NO_NAME_TITLE,IDS_NO_NAME);
                }
                else
                {
                    pStr=new TCHAR[nLen+1];
                    if(GetDlgItemText(m_hWnd,IDC_EDIT_NAME,pStr,nLen+1)!=nLen)
                        return 0;//Internal error.
                    if(_tcschr(pStr,_T('\\')))
                    {
                        bErr=true;
                        MessageBox(m_hWnd,m_hModule,IDS_NO_NAME_TITLE,IDS_INVALID_NAME);
                    }
                    else
                    {
                        if(m_pCore->DuplicateDeviceName(pStr))
                        {
                            bErr=true;
                            MessageBox(m_hWnd,m_hModule,IDS_NO_NAME_TITLE,IDS_DUPLICATE_TYPE);
                        }
                    }
                }
                
                if(bErr)//User entered invalid text for name.
                {
                    SetFocus(m_hWnd);
                    SetFocus(hEdit);
                    Edit_SetSel(hEdit,0,-1);
                    return 0;
                }

                m_pCore->AddCustomDevice(
                    (Button_GetCheck(hJoy)==BST_CHECKED)?true:false,
                    (Button_GetCheck(hPad)==BST_CHECKED)?true:false,
                    (Button_GetCheck(hYoke)==BST_CHECKED)?true:false,
                    (Button_GetCheck(hCar)==BST_CHECKED)?true:false,
                    ComboBox_GetCurSel(hAxis)+MIN_ANALOG_AXIS,
                    (Button_GetCheck(hZAxis)==BST_CHECKED)?true:false,
                    ComboBox_GetCurSel(hButtons),
                    (Button_GetCheck(hPov)==BST_CHECKED)?true:false,
                    pStr,
                    m_VIDPIDName.data());

                if( pStr ) {
                    delete[] pStr;
                }
            }
        }
        EndDialog(m_hWnd,IDOK);
        return 0;
    case IDC_COMBO_AXIS:
        if(wNotifyCode==CBN_SELCHANGE)
        {
            HWND hAxis=HDlgItem(IDC_COMBO_AXIS);
            if(hAxis)
            {
                UINT uShow=SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER;
                if((ComboBox_GetCurSel(hAxis)+MIN_ANALOG_AXIS)==3)//If 3 axis selected.
                    uShow|=SWP_SHOWWINDOW;
                else
                    uShow|=SWP_HIDEWINDOW;
                
                HWND hHasZAxis=HDlgItem(IDC_HASZAXIS);
                if(hHasZAxis)
                {
                    SetWindowPos(hHasZAxis,NULL,NULL,NULL,NULL,NULL,uShow);
                }
                HWND hHasRudder=HDlgItem(IDC_HASRUDDER);
                if(hHasRudder)
                {
                    SetWindowPos(hHasRudder,NULL,NULL,NULL,NULL,NULL,uShow);
                }
            }
        }
        return 0;
    }
    return CDlg::Command(wNotifyCode,wID,hwndCtl);
}

/******************************************************************************
Preferred dialog
******************************************************************************/

void CPreferredDlg::Preferred()
{
    HWND hListCtrl=HDlgItem(IDC_CHANGE_LIST);
    if(hListCtrl)
    {
        int nSelDev=CBGetCurSel(hListCtrl);
        GUID SelGUID=CBGetItemGUID(hListCtrl,nSelDev);
        if(SelGUID!=NULLGUID)
            m_pCore->Preferred(SelGUID);
    }
    EndDialog(m_hWnd,IDOK);
}

INT_PTR CPreferredDlg::Command(WORD wNotifyCode,WORD wID,HWND hwndCtl)
{
    switch(wID)
    {
    case IDOK:
        Preferred();
        return 0;
    }
    if(wNotifyCode==CBN_CLOSEUP)
    {
        Update();
        return 0;
    }
    return CDlg::Command(wNotifyCode,wID,hwndCtl);
}

BOOL CPreferredDlg::InitDialog(HWND hFocus,LPARAM lParam)
{
    Update();
    HWND hListCtrl=HDlgItem(IDC_CHANGE_LIST);
    if(hListCtrl)
    {
        for(LISTDIDEV::iterator It=m_pCore->m_ListDIDev.begin();
                It!=m_pCore->m_ListDIDev.end();It++)
        {
            if(It->Id()==0)
            {
                int nSelDev=CBFindGUIDIndex(hListCtrl,It->InstGUID());
                if(nSelDev>=0)
                    ComboBox_SetCurSel(hListCtrl,nSelDev);
                break;
            }
        }
    }
    return TRUE;
}

void CPreferredDlg::Update()
{
    if(m_bBlockUpdate)return;//Some actions may send notify messages which then Update and overflow stack.
    CUpdate U(&m_bBlockUpdate);

    if(!m_hWnd)return;
    
    int nSelDev=-1;
    GUID SelGUID=NULLGUID;
    
    HWND hListCtrl=HDlgItem(IDC_CHANGE_LIST);
    if(hListCtrl)
    {
        if(ComboBox_GetDroppedState(hListCtrl))return;//No update when selecting preferred.

        int nCount=CBGetCnt(hListCtrl);
        nSelDev=CBGetCurSel(hListCtrl);
        SelGUID=CBGetItemGUID(hListCtrl,nSelDev);

        SetWindowRedraw(hListCtrl,FALSE);
        ComboBox_ResetContent(hListCtrl);
        m_ListCtrl.clear();//Must be behind ComboBox_ResetContent.
        int nId0Index=-1;//Index of preferred device.
        for(LISTDIDEV::iterator It=m_pCore->m_ListDIDev.begin();
                It!=m_pCore->m_ListDIDev.end();It++)
        {
            GUID G=It->InstGUID();
            m_ListCtrl.push_back(G);
            int nIndex=ComboBox_AddString(hListCtrl,It->InstName());
            ComboBox_SetItemData(hListCtrl,nIndex,&m_ListCtrl.back());
            if(It->Id()==0)
                nId0Index=nIndex;                
        }
        
        int nNoneIndex=-1;
        if(nId0Index<0)//Only if there is no preferred device.
        {
            String None=LoadString(m_hModule,IDS_NONE);
            nNoneIndex=ComboBox_AddString(hListCtrl,None.data());
        }

        if((!nCount)||//First update during init.
            (SelGUID==NULLGUID))//Or none is selected.
        {
            if(nId0Index>=0)//Preferred device was added.
                ComboBox_SetCurSel(hListCtrl,nId0Index);
            else//There is no preferred device.
                ComboBox_SetCurSel(hListCtrl,nNoneIndex);
        }
        else//List was not empty before update. Select same thing.
        {
            nSelDev=CBFindGUIDIndex(hListCtrl,SelGUID);
            if(nSelDev>=0)
                ComboBox_SetCurSel(hListCtrl,nSelDev);
            else//Selected device removed.
            {
                if(nId0Index>=0)//Then select original preferred device.
                    ComboBox_SetCurSel(hListCtrl,nId0Index);
                else//Select none.
                    ComboBox_SetCurSel(hListCtrl,nNoneIndex);
            }
        }
        
        SetWindowRedraw(hListCtrl,TRUE);
        InvalidateRect(hListCtrl,NULL,TRUE);
    }
}

INT_PTR CPreferredDlg::Notify(int idCtrl,LPNMHDR pnmh)
{
//    switch(pnmh->code)
//    {
    /*case LVN_KEYDOWN:
        switch(((LV_KEYDOWN*)pnmh)->wVKey)
        {
        case VK_F5:
            CoreUpdate();
            return 0;
        }
        return 0;
    case LVN_ITEMCHANGED:
        Update();
        return 0;*/
/*    case NM_DBLCLK:
        switch(pnmh->idFrom)
        {
        case IDC_CHANGE_LIST:
            Preferred();
            return 0;
        }
        return 0;*/
//    }
    return 0;
}

/******************************************************************************
Connect UI and core
******************************************************************************/

class CCP:public CCore,public CMainDlg
{
    virtual void UIUpdate(){CMainDlg::Update();};
public:
    CCP(){ConnectUI((CCore*)this);};
};

/******************************************************************************
Entry point.
******************************************************************************/

#define MUTEX_NAME	_T("$$$MS_GameControllers_Cpl$$$")

void Core(HANDLE  hModule,HWND hWnd)
{
    static HWND hPrevHwnd=NULL;
    static HANDLE hMutex=CreateMutex(NULL,TRUE,MUTEX_NAME);

    if(GetLastError()==ERROR_ALREADY_EXISTS)
    {
        SetForegroundWindow(hPrevHwnd); 
    }
    else
    {
        hPrevHwnd=hWnd;
    
        _PNH _old_handler;
        _old_handler = _set_new_handler(my_new_handler);
        SHFusionInitializeFromModuleID((HMODULE)hModule,124);
        try
        {
            CCP CP;
            CP.Dlg(IDD_CPANEL,(HMODULE)hModule,hWnd);
        }
        catch(JoyException E)
        {
        }
        catch(exception)
        {
        }
        SHFusionUninitialize();
        _set_new_handler(_old_handler);

        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }
}

/******************************************************************************
Propertiy
******************************************************************************/

class CoInit
{
    HRESULT m_hRes;
public:
    ~CoInit()
    {
        if(SUCCEEDED(m_hRes))
        {
            CoFreeUnusedLibraries();//Free gcdef.dll.
            CoUninitialize();
        }
    };
    CoInit(){m_hRes=CoInitialize(NULL);};
    operator HRESULT(){return m_hRes;};
};
typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;
typedef AutoDeleteArray<LPHPROPSHEETPAGE> LPHPROPSHEETPAGE_ADAR;

//FUN! FUN! FUN! FUN!
//This is certain funny code written by some other, quite funny people,
//so I will put it in the funny code section at the end of the otherwise
//serious file.

//tmarkoc cleaned it up. No more memory/interface/freelib leaks, alloc failures handled, no unneccessary allocations.

/*
#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif
//WHAT IS THIS FOR????????????????????????????????????????????????????????
class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
        private:
                DWORD                           m_cProperty_refcount;
                
        public:
                CDIGameCntrlPropSheet(void);
                ~CDIGameCntrlPropSheet(void);
                
                // IUnknown methods
            STDMETHODIMP            QueryInterface(REFIID, PPVOID);
            STDMETHODIMP_(ULONG)    AddRef(void);
            STDMETHODIMP_(ULONG)    Release(void);
                
                // CImpIServerProperty methods
                STDMETHODIMP                    GetSheetInfo(LPDIGCSHEETINFO *lpSheetInfo);
                STDMETHODIMP                    GetPageInfo (LPDIGCPAGEINFO  *lpPageInfo );
                STDMETHODIMP                    SetID(USHORT nID);
            STDMETHODIMP_(USHORT)   GetID(void);
};*/
//typedef CDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;
typedef IDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;

typedef AutoRelease<LPCDIGAMECNTRLPROPSHEET> LPCDIGAMECNTRLPROPSHEET_AR;

HRESULT Properties(HMODULE hMod,HWND hWnd,CCore *pCore,DWORD dwId)
{
//    ASSERT(IsWindow(hWnd));

    CLSID clsidPropSheet=CLSID_LegacyServer;
    
    //Get type name.
    DIJOYCONFIG DIJoyCfg;
    ZeroMemory(&DIJoyCfg,sizeof(DIJoyCfg));
    DIJoyCfg.dwSize=sizeof(DIJoyCfg);
    if(SUCCEEDED(pCore->m_pDIJoyCfg->GetConfig(dwId,&DIJoyCfg,DIJC_REGHWCONFIGTYPE|DIJC_CALLOUT)))
    {
        //Get the clsidConfig.
        DIJOYTYPEINFO DIJoyType;
        ZeroMemory(&DIJoyType,sizeof(DIJoyType));
        DIJoyType.dwSize=sizeof(DIJoyType);
        if(SUCCEEDED(pCore->m_pDIJoyCfg->GetTypeInfo(DIJoyCfg.wszType,&DIJoyType,DITC_CLSIDCONFIG|DITC_REGHWSETTINGS|DITC_FLAGS1)))
        {
            if((DIJoyType.clsidConfig!=GUID_NULL)&&
                !(DIJoyType.dwFlags1&JOYTYPE_DEFAULTPROPSHEET))
                    clsidPropSheet=DIJoyType.clsidConfig;
        }
    }
    int nStartPage=(clsidPropSheet==CLSID_LegacyServer)?1:0;

    if(nStartPage>MAX_PAGES)
        return(DIGCERR_STARTPAGETOOLARGE);

    CoInit CI;//CoInitialize(NULL); Auto CoFreeUnusedLibraries();CoUninitialize();.
    LPCDIGAMECNTRLPROPSHEET_AR fnInterface;
    if(SUCCEEDED(CI))
    {
        IClassFactory* pCF;
        if(SUCCEEDED(CoGetClassObject(clsidPropSheet,CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory,(LPVOID*)&pCF)))
        {
            pCF->CreateInstance(NULL,IID_IDIGameCntrlPropSheet,(LPVOID*)&fnInterface);
            pCF->Release();
        }
        else
        { 
            //reset to legacy server
            clsidPropSheet=CLSID_LegacyServer;
            nStartPage=1;
            if(SUCCEEDED(CoGetClassObject(clsidPropSheet,CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory,(LPVOID*)&pCF)))
            {
                pCF->CreateInstance(NULL,IID_IDIGameCntrlPropSheet,(LPVOID*)&fnInterface);
                pCF->Release();
            }
        }
    }
    if(*((PVOID *)&fnInterface) == NULL)
    {
        return(E_NOINTERFACE);
    }
    //Send device Id to the property sheet.
    fnInterface->SetID(dwId);

    LPDIGCSHEETINFO pServerSheet=NULL;
    //Get the property sheet info from the server.
    if(FAILED(fnInterface->GetSheetInfo(&pServerSheet)))
    {
        return(E_FAIL);
    }
    //Verify data from server.
    if(pServerSheet->nNumPages==0)
        return(DIGCERR_NUMPAGESZERO);
    else if((pServerSheet->nNumPages>MAX_PAGES)||(pServerSheet->nNumPages<nStartPage))
        return(DIGCERR_NUMPAGESTOOLARGE);

    LPDIGCPAGEINFO pServerPage=NULL;
    //Get the information for all the pages from the server.
    if(FAILED(fnInterface->GetPageInfo(&pServerPage)))
    {
        return(E_FAIL);
    }

    // Allocate memory for the pages.
    LPHPROPSHEETPAGE_ADAR pPages=new HPROPSHEETPAGE[pServerSheet->nNumPages];
    if(*((PVOID *)&pPages) == NULL) return(E_OUTOFMEMORY);
    ZeroMemory((LPHPROPSHEETPAGE)pPages,sizeof(HPROPSHEETPAGE)*pServerSheet->nNumPages);

    // Allocate memory for the header!
    PROPSHEETHEADER SH;
    ZeroMemory(&SH,sizeof(SH));
    SH.dwSize=sizeof(SH);
    SH.hwndParent= hWnd;
    SH.hInstance=pServerPage[0].hInstance;
    if(pServerSheet->fSheetIconFlag)
    {
        if(pServerSheet->lpwszSheetIcon)
        {
            //Check to see if you are an INT or a WSTR.
            if(HIWORD((INT_PTR)pServerSheet->lpwszSheetIcon))
            {
                //You are a string.
                SH.pszIcon=pServerSheet->lpwszSheetIcon;
            }
            else
                SH.pszIcon=(LPCTSTR)(pServerSheet->lpwszSheetIcon);
            SH.dwFlags=PSH_USEICONID;
        }
        else return(DIGCERR_NOICON);
    }

    //Do we have a sheet caption?
    if(pServerSheet->lpwszSheetCaption)
    {
        SH.pszCaption=pServerSheet->lpwszSheetCaption;
        SH.dwFlags|=PSH_PROPTITLE;
    }

    SH.nPages=pServerSheet->nNumPages;  
    SH.nStartPage=nStartPage;

    //Set the property pages inofrmation into the header.
    SH.phpage=(LPHPROPSHEETPAGE)pPages;


    //Sheet stuff is done.Now do the pages.
    PROPSHEETPAGE PropPage;
    ZeroMemory(&PropPage,sizeof(PropPage));
    PropPage.dwSize=sizeof(PropPage);

    //Fill up each page.
    int nIndex=0;
    do
    {
        //Assign the things that there are not questionable.
        PropPage.lParam=pServerPage[nIndex].lParam;
        PropPage.hInstance=pServerPage[nIndex].hInstance;

        // Add the title.
        if(pServerPage[nIndex].lpwszPageTitle)
        {
            PropPage.dwFlags=PSP_USETITLE; 
            //Check to see if you are a string.
            if(HIWORD((INT_PTR)pServerPage[nIndex].lpwszPageTitle))
            {
                PropPage.pszTitle=pServerPage[nIndex].lpwszPageTitle;
            }
            else
                PropPage.pszTitle=(LPTSTR)pServerPage[nIndex].lpwszPageTitle;
        }
        else PropPage.pszTitle=NULL;

        //If icon is required go ahead and add it.
        if(pServerPage[nIndex].fIconFlag)
        {
            PropPage.dwFlags|=PSP_USEICONID;
            //Check to see if you are an INT or a String.
            if(HIWORD((INT_PTR)pServerPage[nIndex].lpwszPageIcon))
            {
                //You're a string.
                PropPage.pszIcon=pServerPage[nIndex].lpwszPageIcon;
            }
            else
                PropPage.pszIcon=(LPCTSTR)(pServerPage[nIndex].lpwszPageIcon);
        }

        //If a pre - post processing call back proc is required go ahead and add it.
        if(pServerPage[nIndex].fProcFlag)
        {
            if(pServerPage[nIndex].fpPrePostProc)
            {
                PropPage.dwFlags|=PSP_USECALLBACK;
                PropPage.pfnCallback=(LPFNPSPCALLBACK)pServerPage[nIndex].fpPrePostProc;
            }
            else 
                return(DIGCERR_NOPREPOSTPROC);
        }

        //And the essential "dialog" proc.
        if(pServerPage[nIndex].fpPageProc)
            PropPage.pfnDlgProc=pServerPage[nIndex].fpPageProc;
        else
            return(DIGCERR_NODLGPROC);

        //Assign the dialog template.
        if(HIWORD((INT_PTR)pServerPage[nIndex].lpwszTemplate))
        {
            PropPage.pszTemplate=pServerPage[nIndex].lpwszTemplate;
        }
        else
            PropPage.pszTemplate=(LPTSTR)pServerPage[nIndex].lpwszTemplate;

        if(clsidPropSheet!=CLSID_LegacyServer)//If third party software do not enforce theme.
            ((LPHPROPSHEETPAGE)pPages)[nIndex++]=SHNoFusionCreatePropertySheetPageW(&PropPage);
        else
            ((LPHPROPSHEETPAGE)pPages)[nIndex++]=CreatePropertySheetPage(&PropPage);
    }   
    while(nIndex<pServerSheet->nNumPages);

    //Launch modal property sheet dialog.
    int iRet=(HRESULT)PropertySheet(&SH);

    if(iRet)
    {
        switch(iRet)
        {
        //User want's to reboot.
        case ID_PSREBOOTSYSTEM:
        case ID_PSRESTARTWINDOWS:
            ExitWindowsEx(EWX_REBOOT,NULL);
            break;
        }
    } 
    else 
        pCore->Update();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\clientnt\guids.c ===
/*****************************************************************************
 *
 *  guids.c
 *
 *  Copyright (c) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *****************************************************************************/

#include <windows.h>
#include <initguid.h>
#include <gameport.h>
#include <dinput.h>
#include <dinputd.h>
#include "ifacesvr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\clientnt\res\dijoy.h ===
#define IDH_101_1002	65667173	// Game Controllers: "&Properties..." (Button)
#define IDH_101_1022	65667180	// Game Controllers: "Refresh" (Button)
#define IDH_101_1010	66191461	// Game Controllers: "A&dd..." (Button)
#define IDH_101_1028	67371109	// Game Controllers: "&Remove..." (Button)
#define IDH_101_1036	67548653	// Game Controllers: "Troubleshoot..." (Button)
#define IDH_101_1058	69337189	// Game Controllers: "&Game Controllers" (Static)
#define IDH_117_1101	72155253	// -: "&Port Driver:" (Static)
#define IDH_117_8197	537198709	// -: "" (ListBox)
#define IDH_117_8198	537264245	// -: "Cha&nge..." (Button)
#define IDH_117_8199	537385268	// Advanced: OEM property sheet check box
#define IDH_119_1039	68092023	// Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049	68092025	// Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059	69402743	// Add Game Controller: "&Controllers:" (Static)
#define IDH_4099_1043	68358147	// Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1044	68358149	// Custom Game Controller: Rudder/Pedals (Button)
#define IDH_4099_1046	68358151	// Custom Game Controller: Z Axis (Button)
#define IDH_4099_1045	68685827	// Custom Game Controller: "" (ComboBox)
#define IDH_4099_1051	68882435	// Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052	68947971	// Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053	69013507	// Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1056	69210115	// Custom Game Controller: "" (Edit)
#define IDH_4099_1058	69410157	// Custom Game Controller: "Is a Joy stick" (Button)
#define IDH_4201_1019	66785385	// Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12290	805507175	// Settings: "Reset to &default" (Button)
#define IDH_4201_12291	805507177	// Settings: "&Calibrate..." (Button)
#define IDH_4203_1023	67047531	// -: "Buttons" (Button)
#define IDH_4203_12293	805638251	// -: "" (ListBox) (X/Y test box)
#define IDH_4203_12308	806621291	// -: "" (ListBox) (all other test boxes)
#define IDH_4203_12309	806686827	// -: "" (POVHAT)
#define IDH_8188_8189	536682492	// Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191	537010170	// Change Controller Assignment: "Selected ID" (ListBox) (Label?)
#define IDH_8188_8194	537010172	// Change Controller Assignment: "" (ListBox)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\clientnt\joyarray.h ===
#include "joyhelp.h"
#include "resource.h"

const DWORD gaHelpIDs[]=
{
    IDC_BTN_PROPERTIES,     IDH_101_1002,   // Game Controllers: "&Properties..." (Button)
    IDC_BTN_TSHOOT,         IDH_101_1036,   // Trouble Shoot Button
    IDC_LIST_DEVICE,        IDH_101_1058,   // Game Controllers: "List1" (SysListView32)
    IDC_LIST_HEADING,       IDH_101_1058,   // Game Controllers: "&Game Controllers" (Static)
    IDC_BTN_REMOVE,         IDH_101_1028,   // Game Controllers: "&Remove..." (Button)
    IDC_BTN_ADD,            IDH_101_1010,   // Game Controllers: "A&dd..." (Button)
    IDC_BTN_REFRESH,        IDH_101_1022,   // Game Controllers: "Refresh" (Button)
    IDC_BTN_ADV,            IDH_101_1311,   // Game Controllers: "A&dvanced" (Button)
    IDC_POLLFLAGS,          IDH_117_1100,   // -: "P&oll with interrupts enabled" (Button)
    IDC_COMBO1,             IDH_117_1101,   // -: "" (ComboBox)
    IDC_TEXT_PORTDRIVER,    IDH_117_1101,   // -: "&Port Driver:" (Static)
    IDC_GAMEPORT,           IDH_117_1101,   // 
    IDC_GAMEPORTLIST,       IDH_117_1101,   // 
    IDC_ADV_LIST_DEVICE,    IDH_117_8197,   // -: "" (ListBox)
    IDC_ADV_CHANGE,         IDH_117_8198,   // -: "Cha&nge..." (Button)
    IDC_ADV_USEOEMPAGE,     IDH_117_8199,   // Advanced: OEM property sheet check box
    IDC_ADD_NEW,            IDH_119_1039,   // Add Game Controller: "&Add Other..." (Button)
    IDC_CUSTOM,             IDH_119_1049,   // Add's Custom button!
    IDC_DEVICE_LIST_TAG,    IDH_119_1059,   // Add Game Controller: "&Controllers:" (Static)
    IDC_DEVICE_LIST,        IDH_119_1059,   // Add Game Controller: "List1" (SysListView32)
    IDC_COMBO_AXIS,         IDH_4099_1043,  // Custom Game Controller: "" (ComboBox)
    IDC_HASRUDDER,          IDH_4099_1044,  // Rudder checkbox from Custom Page
    IDC_COMBO_BUTTONS,      IDH_4099_1045,  // Custom Game Controller: "" (ComboBox)
    IDC_HASZAXIS,           IDH_4099_1046,  // Z Axis checkbox from Custom Page
    IDC_SPECIAL_YOKE,       IDH_4099_1051,  // Custom Game Controller: "Is a flight yoke/stick" (Button)
    IDC_SPECIAL_PAD,        IDH_4099_1052,  // Custom Game Controller: "Is a game pad" (Button)
    IDC_SPECIAL_AUTO,       IDH_4099_1053,  // Custom Game Controller: "Is a race car controller" (Button)
    IDS_CUSTOM_HASPOV,      IDH_4099_1054,  // Custom Game Controller: "Has a &point of view control" (Button)
    IDC_CUSTOM_NAME,        IDH_4099_1056,  // Custom Game Controller: "" (Edit)
    IDC_EDIT_NAME,          IDH_4099_1056,  // Custom Game Controller: "" (Edit)
    IDC_SPECIAL_JOYSTICK,   IDH_4099_1058,  // Custom Game Controller: "Is a Joystick" (Button)
    IDC_JOY1HASRUDDER,      IDH_4201_1019,  // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
    IDC_SPIN,               IDH_8188_8189,  // Spin button in Advanced page Change dialog!
    IDC_SPINBUDDY,          IDH_8188_8189,  // Spin button in Advanced page Change dialog!
    IDC_SELECTEDID,         IDH_8188_8191,  // Change Controller Assignment: "Selected ID" (ListBox)
    IDC_CHANGE_LIST,        IDH_8188_8194,  // Change Controller Assignment: "" (ListBox)
    IDC_LISTTXT,            IDH_8188_8194,
    IDC_ADV_GRP,            (DWORD)-1,
    IDC_ADV_GRP2,           (DWORD)-1,
    IDC_TEXT_DRIVER,        (DWORD)-1,
    IDC_ADD_STR1,           (DWORD)-1,
    IDC_ADD_STR2,           (DWORD)-1,
    IDC_GEN_ICON,           (DWORD)-1,
    IDC_GEN_INTRO,          (DWORD)-1,
    IDC_ASSIGNTXT,          (DWORD)-1,
    IDC_TEXT_TITLE,         (DWORD)-1,
    IDC_SEPERATOR,          (DWORD)-1,
    IDC_AXES_GROUP,         (DWORD)-1,  // Custom Game Controller: "&Axes" (Button)
    IDC_BUTTONS_GROUP,      (DWORD)-1,  // Custom Game Controller: "" (ComboBox)
    IDC_SPECIAL_GROUP,      (DWORD)-1,  // Custom Game Controller: "&Special Characteristics" (Button)

    IDC_VOICECHATGROUP,	    (DWORD)-1,
    IDC_VOICECHATTEXT,      (DWORD)-1,
    IDC_GAMESLISTHOTKEY,    (DWORD)-1,

    IDC_LIST_GAMES,         IDH_VOICE_LIST_GAMES,
    IDC_DETAILS,            IDH_VOICE_DETAILS,
	
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\clientnt\sources.inc ===
!IFNDEF DXROOT
DXROOT = $(BASEDIR)\MultiMedia\DirectX
!ENDIF

!INCLUDE $(DXROOT)\Project.mk

#
#   Use an empty binplace file to dump this version in the DirectX build
#
!IFDEF DIRECTX_REDIST
BINPLACE_PLACEFILE=..\..\noplace.txt
!ENDIF

MAJORCOMP=shell
MINORCOMP=accessory

TARGETNAME=joy
TARGETEXT=cpl
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows

USE_MSVCRT=0
USE_STL=1
USE_MAPSYM=1

DLLENTRY=DllMain

USER_C_FLAGS=$(USER_C_FLAGS) /EHsc
LINKER_FLAGS=$(LINKER_FLAGS) -ignore:4049,4217 

TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\uuid.lib \
           $(SDK_LIB_PATH)\dinput8.lib \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\shlwapi.lib \
           $(SHELL_LIB_PATH)\shfusion.lib \
           
# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.OptionallyYourGroupName.YourAppName
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=Joy.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
SXS_MANIFEST_RESOURCE_ID=124

INCLUDES=$(INCLUDES); \
     ..; \
     ..\..\handler; \
     $(DXROOT)\inc; \
     $(SHELL_INC_PATH); \

SOURCES= \
    ..\gcmain.rc \
    ..\guids.c \
    ..\main.cpp \
    ..\core.cpp \

DLLDEF=..\joy.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\clientnt\joyhelp.h ===
#define IDH_101_1002    65667173    // Game Controllers: "&Properties..." (Button)
#define IDH_101_1022    65667180    // Game Controllers: "Refresh" (Button)
#define IDH_101_1010    66191461    // Game Controllers: "&Add..." (Button)
#define IDH_101_1028    67371109    // Game Controllers: "&Remove..." (Button)
#define IDH_101_1036    67548653    // Game Controllers: "Troubleshoot..." (Button)
#define IDH_101_1058    69337189    // Game Controllers: "&Game Controllers" (Static)
#define IDH_101_1311    65667174    // Game Controllers: "A&dvanced" (Button)

#define IDH_117_1100    72089717    // -: "P&oll with interrupts enabled" (Button)
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_117_8195    537067637   // -: "&Controller ID's:" (Static)
#define IDH_117_8196    537133173   // -: "Game Controllers:" (Static)
#define IDH_117_8197    537198709   // -: "" (ListBox)
#define IDH_117_8198    537264245   // -: "Cha&nge..." (Button)
#define IDH_117_8199    537385268   // Advanced: OEM property sheet check box

#define IDH_119_1039    68092023    // Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049    68092025    // Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059    69402743    // Add Game Controller: "&Controllers:" (Static)

#define IDH_4099_1043   68358147    // Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1044   68358149    // Custom Game Controller: Rudder/Pedals (Button)
#define IDH_4099_1046   68358151    // Custom Game Controller: Z Axis (Button)
#define IDH_4099_1045   68685827    // Custom Game Controller: "" (ComboBox)
#define IDH_4099_1051   68882435    // Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052   68947971    // Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053   69013507    // Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1054   69079043    // Custom Game Controller: "Has a &point of view control" (Button)
#define IDH_4099_1056   69210115    // Custom Game Controller: "" (Edit)
#define IDH_4099_1058   69410157    // Custom Game Controller: "Is a Joystick" (Button)

#define IDH_4201_1019   66785385    // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)

#define IDH_8188_8189   536682492   // Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191   537010170   // Change Controller Assignment: "Selected ID" (ListBox) (Label?)
#define IDH_8188_8194   537010172   // Change Controller Assignment: "" (ListBox)

#define IDH_APPMAN_EXCLUDEDRIVE_INSTRUCTIONS		    2768L
#define IDH_APPMAN_RESTOREDEFAULTS_INSTRUCTIONS		  2767L
#define IDH_APPMAN_DISKUSAGE_SETTING_INSTRUCTIONS   2766L
#define IDH_VOICE_LIST_GAMES						            2765L
#define IDH_VOICE_DETAILS							              2764L

/*
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_101_1002    65667173    // Game Controllers: "&Properties..." (Button)
#define IDH_101_1022    65667180    // Game Controllers: "Refresh" (Button)
#define IDH_101_1010    66191461    // Game Controllers: "A&dd..." (Button)
#define IDH_101_1028    67371109    // Game Controllers: "&Remove..." (Button)
#define IDH_101_1058    69337189    // Game Controllers: "&Game Controllers" (Static)
#define IDH_117_1101    72155253    // -: "&Port Driver:" (Static)
#define IDH_117_8195    537067637   // -: "&Controller ID's:" (Static)
#define IDH_117_8196    537133173   // -: "Game Controllers:" (Static)
#define IDH_117_8197    537198709   // -: "" (ListBox)
#define IDH_117_8198    537264245   // -: "Cha&nge..." (Button)
#define IDH_119_1039    68092023    // Add Game Controller: "&Add Other..." (Button)
#define IDH_119_1049    68092025    // Add Game Controller: "&Custom..." (Button)
#define IDH_119_1059    69402743    // Add Game Controller: "&Controllers:" (Static)
#define IDH_4099_1043   68358147    // Custom Game Controller: "&Axes" (Button)
#define IDH_4099_1048   68685827    // Custom Game Controller: "" (ComboBox)
#define IDH_4099_1050   68816899    // Custom Game Controller: "&Special Characteristics" (Button)
#define IDH_4099_1051   68882435    // Custom Game Controller: "Is a flight yoke/stick" (Button)
#define IDH_4099_1052   68947971    // Custom Game Controller: "Is a game pad" (Button)
#define IDH_4099_1053   69013507    // Custom Game Controller: "Is a race car controller" (Button)
#define IDH_4099_1054   69079043    // Custom Game Controller: "Has a &point of view control" (Button)
#define IDH_4099_1056   69210115    // Custom Game Controller: "" (Edit)
#define IDH_4101_12293  805638149   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12308  806621189   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12309  806686725   // Joystick Calibration: "f" (Static)
#define IDH_4101_12328  807931909   // Joystick Calibration: "Capture &POV" (Button)
#define IDH_4101_12329  807997445   // Joystick Calibration: "< &Back" (Button)
#define IDH_4101_12330  808062981   // Joystick Calibration: "&Next >" (Button)
#define IDH_4101_12331  808062983   // Joystick Calibration: "&Finish" (Button)
#define IDH_4101_12334  808325125   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12347  809177093   // Joystick Calibration: "" (ListBox)
#define IDH_4101_12349  809308165   // Joystick Calibration: "" (ListBox)
#define IDH_4201_1019   66785385    // Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12291  805507177   // Settings: "&Calibrate..." (Button)
#define IDH_4202_12293  805638250   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_12308  806621290   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_12328  807932010   // Game Controller Calibration: "Set &POV" (Button)
#define IDH_4202_12334  808325226   // Game Controller Calibration: "" (ListBox)
#define IDH_4202_8199   537333866   // Game Controller Calibration: "Calibration Information" (Button)
#define IDH_4203_1023   67047531    // -: "Buttons" (Button)
#define IDH_4203_12293  805638251   // -: "" (ListBox)
#define IDH_4203_12308  806621291   // -: "" (ListBox)
#define IDH_4203_12309  806686827   // -: "" (POVHAT)
#define IDH_4203_12334  808325227   // -: "" (ListBox)
#define IDH_4203_12347  809177195   // -: "" (ListBox)
#define IDH_4203_12349  809308267   // -: "" (ListBox)
#define IDH_4203_12350  809308265   // -: "" (Listbox--Slider 1)
#define IDH_4203_12351  809308269   // -: "" (Listbox--Slider 2)
#define IDH_8188_8189   536682492   // Change Controller Assignment: "Controller Assignment" (Button)
#define IDH_8188_8191   537010170   // Change Controller Assignment: "Selected ID" (ListBox)
#define IDH_8188_8194   537010172   // Change Controller Assignment: "" (ListBox)
#define IDH_4099_1046   68358149    // 
#define IDH_4099_1044   68358151    //
#define IDH_101_1036    67548653    //
#define IDH_4099_1058   69410157    //
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\clientnt\main.cpp ===
/****************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 ****************************************************************************/

#include <windows.h>
#include <cpl.h>
#include "resource.h"

void Core(HANDLE hModule,HWND hWnd);

HINSTANCE ghInstance;

BOOL WINAPI DllMain(HANDLE hModule,ULONG uReason,LPVOID pv)
{
    switch(uReason)
    {
    case DLL_PROCESS_ATTACH:
        ghInstance=(HINSTANCE)hModule;
        break;
	case DLL_PROCESS_DETACH:
		break;
    case DLL_THREAD_ATTACH:
        DisableThreadLibraryCalls((HMODULE)hModule);
        break;
    case DLL_THREAD_DETACH:
        break;
    }
    return(TRUE);
}

LONG WINAPI CPlApplet(HWND hWnd,UINT uMsg,LPARAM lParam1,LPARAM lParam2)
{
    switch(uMsg)
    {
    case CPL_INIT:
        return 1;
    case CPL_GETCOUNT:
        return 1;
    case CPL_INQUIRE:
        ((LPCPLINFO)lParam2)->idIcon=IDI_CPANEL; 
        ((LPCPLINFO)lParam2)->idName=IDS_GEN_CPANEL_TITLE; 
        ((LPCPLINFO)lParam2)->idInfo=IDS_GEN_CPANEL_INFO; 
        ((LPCPLINFO)lParam2)->lData=0;
        //return 0;MSDN doc says this should be returned.
        return 1;
    case CPL_DBLCLK:
        Core(ghInstance,hWnd);
        return 0;
    }
    return 0;
}

// DO NOT REMOVE THIS!!!
// This is here because the games group loads the CPL from the exported function
// If you remove this Hellbender, Monster Truck Maddness, CART, etc will fail to
// load the Joystick CPL!!!
// DO NOT REMOVE THIS!!!
void WINAPI ShowJoyCPL(HWND hWnd)
{
    Core(ghInstance,hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\button.cpp ===
/*~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
**
**    FILE:       BUTTON.CPP
**    DATE:       5/12/98
**    PROJ:       NT5
**    PROG:       BLJ
**    COMMENTS:   
**
**    DESCRIPTION: Window class custom buttons
**                    
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    5/12/98     a-brycej     Wrote it.
**    
**
** Copyright (C) Microsoft 1998.  All Rights Reserved.
**
**~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=*/

#include <malloc.h>     // for _alloca
#include "resrc1.h"

#include "cplsvr1.h"
extern HINSTANCE ghInst;
extern CDIGameCntrlPropSheet_X *pdiCpl;

// Colour of text for buttons!
#define TEXT_COLOUR  RGB(202,202,202)

HICON hIconArray[2];

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  ButtonWndProc
//    REMARKS  :  The callback function for the CustomButton Window.
//                    
//    PARAMS   :  The usual callback funcs for message handling
//
//    RETURNS  :  LRESULT - Depends on the message
//    CALLS    :  
//    NOTES    :
//                

LRESULT CALLBACK ButtonWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch( iMsg )
    {
        case WM_PAINT:
            {
                PAINTSTRUCT *pps = new (PAINTSTRUCT);
                assert (pps);

                HDC hDC = BeginPaint(hWnd, pps);

                // Draw the appropriate icon                                                                                       
                DrawIconEx(hDC, 0, 0, hIconArray[GetWindowLong(hWnd, GWLP_USERDATA)], 0, 0, 0, NULL, DI_NORMAL);

                // Prepare the DC for the text
                SetBkMode   (hDC, TRANSPARENT);
                SetTextColor(hDC, TEXT_COLOUR);

                // Enforce the proper size!
                pps->rcPaint.top    = pps->rcPaint.left   = 0;
                pps->rcPaint.bottom = 33;
                pps->rcPaint.right  = 30;

                TCHAR tsz[3];

                // Draw the Number                        
                DrawText (hDC, (LPCTSTR)tsz, GetWindowText(hWnd, tsz, sizeof(tsz)/sizeof(TCHAR)), &pps->rcPaint, DT_VCENTER|DT_CENTER|DT_NOPREFIX|DT_SINGLELINE|DT_NOCLIP);
                SetBkMode(hDC, OPAQUE);
                EndPaint (hWnd, pps);

                if( pps )
                    delete (pps);
            }
            return(FALSE);

        default:
            return(DefWindowProc(hWnd, iMsg,wParam, lParam));
    }
    return(FALSE);
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  RegisterCustomButtonClass
//    REMARKS  :  Registers the Custom Button control window.
//                    
//    PARAMS   :  hInstance - Used for the call to RegisterClassEx
//
//    RETURNS  :  TRUE - if successfully registered
//                FALSE - failed to register
//    CALLS    :  RegisterClassEx
//    NOTES    :
//

extern ATOM RegisterCustomButtonClass()
{
    LPWNDCLASSEX pCustCtrlClass   = (LPWNDCLASSEX)_alloca(sizeof(WNDCLASSEX));
    assert (pCustCtrlClass);

    ZeroMemory(pCustCtrlClass, sizeof(WNDCLASSEX));

    pCustCtrlClass->cbSize        = sizeof(WNDCLASSEX);
    pCustCtrlClass->style         = CS_CLASSDC; 
    pCustCtrlClass->lpfnWndProc   = ButtonWndProc;
    pCustCtrlClass->hInstance     = ghInst;
    pCustCtrlClass->lpszClassName = TEXT("TESTBUTTON");

    return(RegisterClassEx( pCustCtrlClass ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\clientnt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by gcmain.rc
//
#define IDD_CPANEL                      101
#define IDI_CPANEL                      102
#define IDD_PROPSHEET                   103
#define IDD_ASSIGN                      104
#define IDI_NOTCONNECTED                108
#define IDI_JOYSTICK                    110
#define IDR_MENU1                       116
#define IDD_ADVANCED                    117
#define IDD_ADD                         119
#define IDD_SMAPPER                     122
#define IDB_JOYSTICK                    126
#define IDD_MOREINFO                    127
#define IDI_DIRECTX                     129
#define IDI_CHECKBOX_EMPTY              131
#define IDD_DVOICE                      131
#define IDI_CHECKBOX_FULL               132
#define IDD_PROP_RETROFIT               133
#define IDS_DVOICE_TAB                  134
#define IDD_WIZARD_CANCELED             135
#define IDD_WIZARD_LAUNCH               136
#define IDD_VOICE_ENABLED               137
#define IDI_LIST_DEFAULT                138
#define IDD_CONFIRM_HALFDUPLEX          139
#define IDD_CONFIRM_SOUNDINITFAILURE    140
#define IDD_WIZARD_ERROR                141
#define IDD_DETAILS                     143
#define IDD_PREV_HALFDUPLEX             144
#define IDD_APPMAN_MORE_INFO            145
#define IDD_UPDATE                      146
#define IDC_COMBO1                      1000
#define IDC_TEXT_HELP                   1001
#define IDC_BTN_PROPERTIES              1002
#define IDC_BTN_SETTINGS                1003
#define IDC_BTN_TEST                    1004
#define IDC_TAB                         1005
#define IDC_BTN_APPLY                   1006
#define IDC_BTN_TSHOOT                  1007
#define IDC_TEXT_DEVICE                 1008
#define IDC_BTN_REFRESH                 1009
#define IDC_BTN_ASSIGN                  1010
#define IDC_BTN_ADD                     1011
#define IDC_COMBO_JOYSTICKID            1012
#define IDS_TSHOOT_CMD                  1013
#define IDC_BTN_UPDATE                  1014
#define IDC_LIST_DEVICE                 1020
#define IDC_TEXT_DEVICELIST             1025
#define IDC_TEXT_IDLIST                 1026
#define IDC_BTN_REMOVE                  1028
#define IDC_COMBO_AXIS                  1030
#define IDC_TEXT_TITLE                  1031
#define IDC_TEXT_DRIVER                 1032
#define IDC_TEXT_LBTAG                  1033
#define IDC_ADD_STR1                    1037
#define IDC_ADD_STR2                    1038
#define IDC_ADD_NEW                     1039
#define IDS_ADV_TITLE                   1039
#define IDS_ADV_GLOBAL_DESC             1040
#define IDS_ADV_GLOBAL_TAG              1041
#define IDS_ADV_DEVICE_HEADING          1042
#define IDC_AXES_GROUP                  1043
#define IDC_AXES2                       1044
#define IDC_AXES3                       1045
#define IDC_AXES4                       1046
#define IDC_BUTTONS_GROUP               1047
#define IDC_COMBO_BUTTONS               1048
#define IDC_SPECIAL_GROUP               1049
#define IDC_SPECIAL_CHECK               1050
#define IDC_SPECIAL_YOKE                1051
#define IDC_SPECIAL_PAD                 1052
#define IDC_SPECIAL_AUTO                1053
#define IDC_SPECIAL_JOYSTICK            1054
#define IDC_CUSTOM_NAME                 1055
#define IDC_EDIT_NAME                   1056
#define IDC_DEVICE_LIST                 1057
#define IDC_LIST_HEADING                1058
#define IDS_ADD_DESC                    1059
#define IDS_ADD_NEW_DESC                1060
#define IDS_ADD_NEW                     1061
#define IDS_CUSTOM_TITLE                1062
#define IDS_CUSTOM_AXES_GROUP           1063
#define IDS_CUSTOM_2AXES                1064
#define IDS_CUSTOM_3AXES                1065
#define IDS_CUSTOM_4AXES                1066
#define IDS_CUSTOM_BUTTONS_GROUP        1067
#define IDS_CUSTOM_SPECIAL              1068
#define IDS_CUSTOM_ISFLIGHTYOKE         1069
#define IDS_CUSTOM_ISGAMEPAD            1070
#define IDS_CUSTOM_ISRACECAR            1071
#define IDS_CUSTOM_HASPOV               1072
#define IDS_CUSTOM_NAME                 1073
#define IDS_CUSTOM_BUTTONS              1074
#define IDS_GEN_CPANEL_TITLE            1076
#define IDS_GENERAL_TAB                 1077
#define IDC_ADV_USEOEMPAGE              1078
#define IDS_ADVANCED_TAB                1079
#define IDS_NONE                        1080
#define IDC_SCROLLBAR1                  1081
#define IDC_SPIN1                       1083
#define IDS_ADV_DEVICE_FRIENDLY         1084
#define IDC_DATETIMEPICKER1             1085
#define IDC_SW_HACK                     1086
#define IDS_ADD_DEVICE_LIST_TAG         1091
#define IDS_OK                          1092
#define IDS_CANCEL                      1093
#define IDS_ADD_TITLE                   1094
#define IDS_NO_IDS                      1095
#define IDS_NO_IDS_TITLE                1096
#define IDS_NO_NAME                     1097
#define IDS_NO_NAME_TITLE               1098
#define IDS_GEN_CPANEL_INFO             1099
#define IDC_POLLFLAGS                   1100
#define IDC_TEXT_PORTDRIVER             1101
#define IDS_NO_GAMEPORT                 1102
#define IDS_NO_GAMEPORT_TITLE           1103
#define IDS_ADV_STATUS_HEADING          1143
#define IDS_ADV_STD_GAMEPORT            1144
#define IDS_WHATSTHIS                   1145
#define IDS_GEN_PROPERTIES              1146
#define IDS_GEN_REMOVE                  1147
#define IDS_GEN_ADD                     1148
#define IDS_GEN_LIST_HEADING            1149
#define IDS_GEN_TEXT_HELP               1150
#define IDS_GEN_DEVICE_HEADING          1151
#define IDS_GEN_STATUS_HEADING          1152
#define IDS_GEN_AREYOUSURE              1153
#define IDC_VIEW_CTRL                   1154
#define IDS_GEN_STATUS_OK               1155
#define IDS_GEN_STATUS_NOTCONNECTED     1157
#define IDS_GEN_STATUS_NOFORCES         1158
#define IDC_DEVICE_LIST_TAG             1159
#define IDC_ADV_GRP                     1161
#define IDC_ADV_GRP2                    1162
#define IDC_GEN_INTRO                   1164
#define IDC_GEN_ICON                    1166
#define IDC_GAMEPORT                    1167
#define IDC_GAMEPORTLIST                1168
#define IDC_CUSTOM                      1169
#define IDS_ADV_GAME_CONTROLLERS        1170
#define IDC_HASRUDDER                   1172
#define IDC_HASZAXIS                    1174
#define IDC_ADV_OEMSHEET                1175
#define IDC_WDM                         1176
#define IDS_ADV_DEVICE_PORT             1177
#define IDS_NOAVAILABLEVIDPID           1178
#define IDS_GAMES_COLUMN_HEADER         1188
#define IDS_ENABLED_COLUMN_HEADER       1189
#define IDS_GEN_AREYOUSURE_TITLE        1254
#define IDC_MOREINFO                    1280
#define IDC_INFO_ICON                   1300
#define IDC_ICON_NOTCOMPLETE            1301
#define IDC_ICON_INFORMATION            1302
#define IDC_ICON_WARNING                1303
#define IDC_ICON_ERROR                  1304
#define IDC_DETAILS                     1305
#define IDC_WARNING_ICON                1306
#define IDC_RUNTEST                     1307
#define IDC_VOICECHATTEXT               1308
#define IDC_GAMESLISTHOTKEY             1309
#define IDC_VOICECHATGROUP              1310
#define IDC_BTN_ADV                     1311
#define IDD_CUSTOM                      4099
#define IDD_ADV_CHANGE                  8188
#define IDC_CHANGE_BOARDER              8189
#define IDD_APPMAN_ADV                  8189
#define IDD_APPMAN_LOCKING              8189
#define IDC_SELECTEDID                  8190
#define IDD_APPMAN_ADVUSER              8191
#define IDC_CHANGEID                    8192
#define IDC_ASSIGNTXT                   8193
#define IDC_LISTTXT                     8194
#define IDC_CHANGE_LIST                 8195
#define IDS_DEVICEID                    8196
#define IDS_CONTROLLERS                 8197
#define IDC_ADV_LIST_DEVICE             8198
#define IDC_ADV_CHANGE                  8199
#define IDC_GROUPBOX                    8300
#define IDS_CONTROLLERID                8301
#define IDC_GROUPBOX_2                  8302
#define IDC_GROUPBOX_3                  8303
#define IDS_ADV_CHANGE                  8304
#define IDS_CUSTOM_STRING               8305
#define IDC_JOYHASPOV                   12322
#define IDC_JOYISYOKE                   12323
#define IDC_JOYISGAMEPAD                12324
#define IDC_JOYISCARCTRL                12325
#define IDC_JOY2BUTTON                  12326
#define IDC_JOY4BUTTON                  12327
#define IDC_JOYUSESPECIAL               12332
#define IDC_JOY2AXIS                    12336
#define IDC_JOY3AXIS                    12337
#define IDC_JOY4AXIS                    12338
#define IDC_BTN_DIAG                    40001
#define IDS_HELPFILENAME                40002
#define IDS_DUPLICATE_TYPE              40003
#define IDS_DUPLICATE_TYPE_TITLE        40004
#define IDS_INVALID_NAME                40005
#define IDS_INVALID_NAME_TITLE          40006
#define IDS_INTERNAL_ERROR              40007
#define IDS_NO_DIJOYCONFIG              40008
#define IDS_NO_GAMENUM                  40009
#define IDS_NO_GAMENUM_TITLE            40010
#define IDC_SEPERATOR                   40011
#define IDS_MAX_DEVICES_TITLE           40012
#define IDS_MAX_DEVICES_MSG             40013
#define IDS_NO_REMOVE                   40014
#define IDS_RENAME                      40016
#define IDC_RENAME                      40017
#define IDS_DONE                        40018
#define IDS_REFRESH                     40019
#define IDC_JOY1HASRUDDER               40022
#define IDC_SPIN                        40023
#define IDC_SPINBUDDY                   40024
#define IDS_ADD_PORT_MSGFORMAT          40025
#define IDS_ADD_PORT_OCCUPIED           40026
#define IDS_GEN_STATUS_UNKNOWN          40027
#define IDS_GEN_NO_REMOVE_USB           40028
#define IDS_WDMJOY                      40029
#define IDS_AUTO_DETECT                 40030
#define IDS_USER_MODE                   40031
#define IDS_USER_MODE_TITLE             40032
#define IDS_WDMJOY_INF                  40033
#define IDC_MYSTATIC                    40034
#define IDS_NO_RENAME                   40035
#define IDS_NO_RENAME_TITLE             40036
#define IDS_GAMEPORT_OCCUPIED           40037
#define IDS_GAMEPORT_OCCUPIED_TITLE     40038
#define IDS_DEST_ID_OCCUPIED            40039
#define IDS_DEST_ID_OCCUPIED_TITLE      40040
#define IDS_VOICEMOREINFO               40046
#define IDC_PEAKMETER                   41008
#define IDC_P1                          41013
#define IDC_P2                          41014
#define IDC_P3                          41015
#define IDC_WELCOME_IMAGE               41016
#define IDC_COMPLETE_IMAGE              41021
#define IDC_TITLE                       41022
#define IDC_PROGRESSBAR                 41023
#define IDC_RADIO_EXTERNAL              41024
#define IDC_RADIO_HEADSET               41025
#define IDC_COMPLETE_FAILED_GRAPHIC     41026
#define IDC_P4                          41027
#define IDC_DIVIDER                     41028
#define IDC_P5                          41029
#define IDC_LIST_GAMES                  41034
#define IDC_TEST_DEVICES                41042
#define IDC_VOICE_DEVICES               41043
#define IDC_GROUP1                      41044
#define IDC_GROUP2                      41045
#define IDS_UPDATE_SITEDIR              41046
#define IDS_UPDATE_INI                  41047
#define IDS_UPDATE_LASTUPDATED          41048
#define IDS_UPDATE_NOTCONNECTED_TITLE   41049
#define IDS_UPDATE_NOTCONNECTED         41050
#define IDS_UPDATE_FTP_ERROR            41051
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        147
#define _APS_NEXT_COMMAND_VALUE         41052
#define _APS_NEXT_CONTROL_VALUE         1312
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\cal.cpp ===
//===========================================================================
// CAL.CPP... Would be CALIBRATE.CPP, but that's not 8.3 compliant :(
//
// Functions:
//
//    CalInitProc  
//    CalXYProc  	
//    CalSliderProc
//    CalPovProc
//    CalStateChange
//    CollectCalInfo
//    EnableXYWindows
//    GetOEMCtrlString
//
//===========================================================================

// This is necessary or PSH_WIZARD_LITE will not be defined!
#if (_WIN32_IE < 0x0500)
    #undef _WIN32_IE
    #define  _WIN32_IE  0x0500
#endif

// This is necessary for UnregisterDeviceNotification!
#if (WINVER < 0x0500)
    #undef WINVER
    #define WINVER 0x0500
#endif

// Uncomment if we decide to calibrate the POV!
#define WE_SUPPORT_CALIBRATING_POVS	1

#include "cplsvr1.h"
//#include <windowsx.h>

#include <mmsystem.h>
#include <malloc.h>


#include "cplsvr1.h"

#ifdef _UNICODE
    #include <winuser.h>  // For RegisterDeviceNotification stuff!
    #include <dbt.h>      // for DBT_ defines!!!
#endif // _UNICODE

// remove to remove support for calibration of deadzones!
//#define DEADZONE 1

#include "resource.h"
#include "cal.h"			// Data to be shared with other modules
#include "calocal.h"		// Local Data to this module
#include "dicputil.h"	// for OnContextMenu and OnHelp
#include "pov.h"			// for SetDegrees()

#include <prsht.h>      // includes the property sheet functionality

#include <shlwapi.h>    // for the Str... functions!

#include <regstr.h>		// for pre-defined Registry string names
#include "Gradient.h" 	// for Gradient Fill Slider!

// Local function prototypes!
static void UpdateXYLabel           (const HWND hDlg);
static BOOL UpdateProgressLabel (const HWND hDlg);
// myitoa prototype is in cplsvr1.h
static void reverse                 (LPTSTR string);
static void RawDataSelected     (const HWND hWnd, BOOL bEnable);
static void WizFinish               (const HWND hWnd);

// Calibration procedures!
LRESULT CALLBACK CalInitProc    (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK CalXYProc          (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK CalSliderProc  (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef WE_SUPPORT_CALIBRATING_POVS
LRESULT CALLBACK CalPovProc   (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif //WE_SUPPORT_CALIBRATING_POVS

VOID CALLBACK TimerProc             (const HWND hWnd, UINT uMsg, UINT  idEvent, DWORD  dwTime);


//static void EnableSliderWindows	(const HWND hWnd, BOOL bEnable);


HWND ProgWndCal;                 // Handle to Progress Control Window
//DWORD dwUsage;  				 // Usage flags for the device being calibrated!
char nCalState;                  // Flag state variable!
char nPrevCalState;
LPMYJOYRANGE pRanges;        // Ranges recieved by the Calibration!
BOOL bShowRawData;
LPWSTR lpwszTypeName;        // Set in WM_INIT, Used in GetOEMCtrlString
LPDIJOYCONFIG_DX5 pJoyConfig; // DIJC_REGHWCONFIGTYPE information about the device!


// 
extern LPMYJOYRANGE lpCurrentRanges;
extern LPDIJOYSTATE lpDIJoyState;       // Defined in TEST.CPP
extern CDIGameCntrlPropSheet_X *pdiCpl;
extern HINSTANCE  ghInst;

HFONT hTitleFont;

static LPDIRECTINPUTDEVICE2 pdiDevice2; 
static CGradientProgressCtrl *pGradient;
static BOOL bGradient;

//****************************************************************************
//
//   FUNCTION: CreateWizard(HWND hwndOwner, LPARAM lParam)
//
//   PURPOSE: Create the Wizard control. 
//
//   COMMENTS:
//	
//      This function creates the wizard property sheet.
//****************************************************************************
short CreateWizard(const HWND hwndOwner, LPARAM lParam)
{
#ifdef WE_SUPPORT_CALIBRATING_POVS
    const BYTE nTempArray[]  = {IDD_INITIAL,                IDD_XY,                     IDD_SLIDER,   IDD_POV };
    const DLGPROC pDlgProc[] = {(DLGPROC)CalInitProc,  (DLGPROC)CalXYProc,  (DLGPROC)CalSliderProc,   (DLGPROC)CalPovProc };
#else
    const BYTE nTempArray[]  = {IDD_INITIAL,                IDD_XY,                     IDD_SLIDER };
    const DLGPROC pDlgProc[] = {(DLGPROC)CalInitProc,  (DLGPROC)CalXYProc,  (DLGPROC)CalSliderProc };
#endif

    HPROPSHEETPAGE  *pPages = new (HPROPSHEETPAGE[sizeof(nTempArray)/sizeof(BYTE)]);
    if( !pPages ) {
        return 0;
    }

    // Allocate and Zero the Page header memory
    PROPSHEETHEADER *ppsh = new (PROPSHEETHEADER);
    if( !ppsh ) {
        delete[] (pPages);
        return 0;
    }

    ZeroMemory(ppsh, sizeof(PROPSHEETHEADER));

    ppsh->dwSize     = sizeof(PROPSHEETHEADER);
    ppsh->dwFlags    = PSH_WIZARD_LITE | PSH_NOAPPLYNOW | PSH_USEICONID; 
    ppsh->hwndParent = hwndOwner;
    ppsh->pszIcon     = MAKEINTRESOURCE(IDI_GCICON);
    ppsh->hInstance  = ghInst;
    ppsh->phpage      = pPages;

    ppsh->pszbmWatermark = MAKEINTRESOURCE(IDB_CALHD);

    PROPSHEETPAGE *ppsp = new (PROPSHEETPAGE);
    if( !ppsp ) {
        delete[] (pPages);
        delete (ppsh);

        return 0;
    }

    ZeroMemory(ppsp, sizeof(PROPSHEETPAGE));

    ppsp->dwSize      = sizeof(PROPSHEETPAGE);
// ppsp->pszTitle    = MAKEINTRESOURCE(nTabID);
    ppsp->hInstance   = ghInst;
    ppsp->lParam        = lParam;

    while( ppsh->nPages < (sizeof(nTempArray)/sizeof(BYTE)) ) {
        ppsp->pfnDlgProc  = pDlgProc[ppsh->nPages];
        ppsp->pszTemplate = MAKEINTRESOURCE(nTempArray[ppsh->nPages]);

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(ppsp);

        ppsh->nPages++;
    }

    if( ppsp )
        delete (ppsp);

    short nRet = (short)PropertySheet(ppsh);

    if( pPages )
        delete[] (pPages);

    // Clean up!
    if( ppsh )
        delete (ppsh);

    return(nRet);
}

//*******************************************************************************
//
//   FUNCTION: CalInitProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//   PURPOSE: 	Procedure for Start-up screen
//
//   COMMENTS:	This function is responsible for display of text and bitmap.
//					Since it is also the only page that is Guarenteed to be hit,
//					it is also responsible for creating, deleteing, and storing 
//					everything for the calibration wizard.
//	
//*******************************************************************************
LRESULT CALLBACK CalInitProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HFONT hBoldFont;
    static PVOID hNotifyDevNode;     

    switch( uMsg ) {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

#ifdef _UNICODE
    case WM_DEVICECHANGE:  
        if( (UINT)wParam == DBT_DEVICEREMOVECOMPLETE )
            ::PostMessage(GetParent(hWnd), WM_COMMAND, IDCANCEL, 0);
        break;
#endif
        // OnInit
    case WM_INITDIALOG:
        // Init to FALSE to turn off Gradient fill!
        bGradient = FALSE;

        // According to knowlege base artical Q138505, this is the prescribed method of removing 
        // the context sensitive help '?' from the title bar.
        {
            LONG style = ::GetWindowLong(GetParent(hWnd), GWL_EXSTYLE);
            style &= ~WS_EX_CONTEXTHELP;

            HWND hParent = GetParent(hWnd);

            ::SetWindowLong(hParent, GWL_EXSTYLE, style);


            // Set up the Device Notification
#ifdef _UNICODE
            RegisterForDevChange(hWnd, &hNotifyDevNode);
#endif
            HDC myDC = GetDC(hWnd);
            if( myDC ) {     // Prefix Whistler 45095
                hTitleFont = CreateFont(-MulDiv(8, GetDeviceCaps(myDC, LOGPIXELSY), 72), 0, 0, 
                                        0, FW_SEMIBOLD, FALSE, 
                                        FALSE, FALSE, DEFAULT_CHARSET, 
                                        OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, 
                                        DEFAULT_PITCH | FF_DONTCARE, TEXT("MS Shell Dlg"));

                // Do the Create font thing...
                hBoldFont = CreateFont(-MulDiv(15, GetDeviceCaps(myDC, LOGPIXELSY), 72), 0, 0, 
                                       0, FW_SEMIBOLD, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS, 
                                       PROOF_QUALITY, DEFAULT_PITCH | FF_ROMAN, TEXT("MS Shell Dlg")); 

                ReleaseDC(hWnd, myDC);
            }
            
            if( hBoldFont )
                ::SendDlgItemMessage(hWnd, IDC_INIT_TITLE, WM_SETFONT, (WPARAM)hBoldFont, TRUE);

            CenterDialog(hWnd);

            ::PostMessage(hParent, PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT);

            bShowRawData = FALSE;

            // Allocate the memory for the ranges!
            pRanges = new MYJOYRANGE;
            assert(pRanges);

            // Set Everything to
            ZeroMemory(pRanges, sizeof(MYJOYRANGE));

            // Get the "best guess" ranges...
            CopyMemory(pRanges, lpCurrentRanges, sizeof(MYJOYRANGE));

            pdiCpl->GetDevice(&pdiDevice2);

            // Attempt to Set them... die if you can't!
            SetMyRanges(pdiDevice2, pRanges, pdiCpl->GetStateFlags()->nAxis);

            if( FAILED(GetLastError()) ) {
                Error(hWnd, (short)IDS_USER_MODE_TITLE, (short)IDS_USER_MODE);
                PostMessage(GetParent(hWnd), WM_SYSCOMMAND, SC_CLOSE, 0L);
            }

            pJoyConfig = new(DIJOYCONFIG_DX5);
            assert (pJoyConfig);

            pJoyConfig->dwSize = sizeof (DIJOYCONFIG_DX5);

            LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
            pdiCpl->GetJoyConfig(&pdiJoyConfig);

            HRESULT hres;

            // Retrieve and store Hardware Configuration about the device!
            hres = pdiJoyConfig->GetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE | DIJC_GUIDINSTANCE);

            if( SUCCEEDED(hres) ) {
                bPolledPOV = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_HASPOV) && (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL);
                CalibratePolledPOV( &pJoyConfig->hwc );
            }

        }
        break;

        // Change the background of all Static text fields to WHITE
    case WM_CTLCOLORSTATIC:
        return(LRESULT)GetStockObject(WHITE_BRUSH);

    case WM_DESTROY:
        if( pJoyConfig )
            delete (pJoyConfig);

        if( lpwszTypeName )
            LocalFree(lpwszTypeName);

        pdiDevice2->Unacquire();
        SetCalibrationMode( FALSE );

        if( hTitleFont )
            DeleteObject((HGDIOBJ)hTitleFont);

        if( hBoldFont )
            DeleteObject((HGDIOBJ)hBoldFont);

// if you call this function you will hang up the system for 30 seconds or more!!!
#ifdef _UNICODE
        if( hNotifyDevNode )
            UnregisterDeviceNotification(hNotifyDevNode);
#endif // _UNICODE
        break;
    }               
    return(DefWindowProc(hWnd, uMsg, wParam, lParam));
}

//*******************************************************************************
//
//   FUNCTION: CalXYProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//   PURPOSE: 	Procedure for first three stages of calibration
//
//   COMMENTS:	This function is responsible for capture of X/Y and Center values!
//	
//*******************************************************************************
LRESULT CALLBACK CalXYProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg ) {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

        // OnInit
    case WM_INITDIALOG:
        {
            // set up the local globals
            nCalState = JCS_XY_CENTER1;
            nPrevCalState = JCS_INIT;

            // Get the JoyConfig Interface Pointer!
            LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
            pdiCpl->GetJoyConfig(&pdiJoyConfig);

            if( SUCCEEDED(pdiJoyConfig->SetCooperativeLevel(hWnd, DISCL_EXCLUSIVE | DISCL_BACKGROUND)) ) {
                // Set the font for the 
                ::SendDlgItemMessage(hWnd, IDC_WIZARD_MSG_HDR, WM_SETFONT, (WPARAM)hTitleFont, TRUE);

                lpwszTypeName = StrDupW(pJoyConfig->wszType);

                // This sets up the Windows and the global ProgWndCal!
                UpdateXYLabel(hWnd);

                // Set up for first round
                CalStateChange( hWnd, (BYTE)pJoyConfig->hwc.hws.dwFlags );

                VERIFY(SUCCEEDED(SetCalibrationMode(TRUE)));
                VERIFY(FAILED(pdiDevice2->Acquire()));
            }
        }
        break;

        // Change the background of all Static text fields to WHITE
    case WM_CTLCOLORSTATIC:
        // We only want to paint the background for the items in the top white rectangle!
        switch( GetDlgCtrlID((HWND)lParam) ) {
        case IDC_WIZARD_MSG:
        case IDC_HEADERFRAME:
        case IDC_WIZARD_MSG_HDR:
            return(LRESULT)GetStockObject(WHITE_BRUSH);
        }
        return(FALSE);

        // OnNotify
    case WM_NOTIFY:
        switch( ((NMHDR FAR *) lParam)->code ) {
        case PSN_KILLACTIVE:
            KillTimer(hWnd, ID_CAL_TIMER);
            break;

        case PSN_RESET:
            // reset to the original values
            KillTimer(hWnd, ID_CAL_TIMER);
            break;

        case PSN_SETACTIVE:
            SetTimer( hWnd, ID_CAL_TIMER, CALIBRATION_INTERVAL, (TIMERPROC)TimerProc);

            // Sorry, you can't go back to the first page... 
            if( nCalState > JCS_XY_CENTER1 )
                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT | PSWIZB_BACK);
            else
                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT);
            break;

        case PSN_WIZBACK:
            // Determine what the next calibration stage is!
            // Look out... we're backing up!
            if( nCalState == nPrevCalState )
                nPrevCalState--;

            nCalState = nPrevCalState;

            CalStateChange(hWnd, (BYTE)pJoyConfig->hwc.hws.dwFlags);

            // No more backing up!
            if( nCalState == JCS_XY_CENTER1 )
                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT);

            SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, (nCalState < JCS_XY_CENTER1) ? IDD_INITIAL : -1);
            return(nCalState < JCS_XY_CENTER1) ?  IDD_INITIAL : -1;


        case PSN_WIZNEXT:
            nPrevCalState = nCalState;

            ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT | PSWIZB_BACK);

#if 0
            // Determine what the next calibration stage is!
    #ifndef DEADZONE
            //while ((!(pdiCpl->GetStateFlags()->nAxis & 1<<nCalState++)) && (nCalState < JCS_FINI));
            nCalState++;
    #else
            nCalState++;
    #endif // DEADZONE
#endif

            while( (!(pdiCpl->GetStateFlags()->nAxis & (1<<nCalState++) )) && (nCalState < JCS_FINI) );

            if( nCalState > JCS_FINI )
                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_FINISH | PSWIZB_BACK);
            else if( nCalState < JCS_Z_MOVE )
                CalStateChange( hWnd, (BYTE)pJoyConfig->hwc.hws.dwFlags );


            SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, (nCalState < JCS_Z_MOVE) ? -1 : IDD_SLIDER );
            return(nCalState < JCS_Z_MOVE) ?  -1 : IDD_SLIDER;


        default:
            return(FALSE);
        }
        break;

        // OnCommand
    case WM_COMMAND:
        switch( LOWORD(wParam) ) {
        case IDC_RAWDATA:
            RawDataSelected(hWnd, bShowRawData = !bShowRawData);
            break;
        }
        break;

        // OnDestroy
    case WM_DESTROY:
        if( pRanges ) {
            delete (pRanges);
            pRanges = NULL;
        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);   
}


//****************************************************************************
//
//   FUNCTION: CalSliderProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//   PURPOSE: 	Procedure 
//
//   COMMENTS:
//	
//      This function creates the wizard property sheet.
//****************************************************************************
LRESULT CALLBACK CalSliderProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg ) {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

    case WM_INITDIALOG:
        // Set the Control font!
        ::SendDlgItemMessage(hWnd,IDC_WIZARD_MSG_HDR, WM_SETFONT, (WPARAM)hTitleFont, TRUE);

#ifdef DEADZONE
        ::SendDlgItemMessage(hWnd, IDC_DEADZONE_TITLE,   WM_SETFONT, (WPARAM)hTitleFont, TRUE);
        ::SendDlgItemMessage(hWnd, IDC_SATURATION_TITLE, WM_SETFONT, (WPARAM)hTitleFont, TRUE);
#endif //DEADZONE

        // Setup the Progress bar!
        ProgWndCal = GetDlgItem(hWnd, IDC_SLIDER);

        // do the Gradient fill maddness!
        {
            HDC hDC = ::GetWindowDC(hWnd);
            if( hDC ) {
                bGradient = (BOOL)(GetDeviceCaps(hDC, NUMCOLORS) < 0);

                if( bGradient ) {
                    pGradient = new (CGradientProgressCtrl);
                    pGradient->SubclassWindow(GetDlgItem(hWnd, IDC_SLIDER)); 
                    pGradient->SetDirection(HORIZONTAL);
                    //pGradient->ShowPercent();
                    pGradient->SetStartColor(COLORREF(RGB(0,0,255)));
                    pGradient->SetEndColor(COLORREF(RGB(0,0,0)));
                    pGradient->SetBkColor(COLORREF(RGB(180,180,180)));
                }
                ::ReleaseDC(hWnd, hDC);
            }
        }

        if( nCalState < JCS_FINI ) {
            // UpdateProgressLabel MUST be called Before CalStateChange!!!
            UpdateProgressLabel(hWnd);

            // If we're not using the gradient control, set the bar
            // colour PBM_SETBARCOLOR is WM_USER+9... YES, it's undocumented...
            if( !bGradient ) {
                ::PostMessage(ProgWndCal, WM_USER+9, 0, (LPARAM)ACTIVE_COLOR);
            }
        } else {
           ::PostMessage(GetParent(hWnd), PSM_PRESSBUTTON, (WPARAM)(int)PSBTN_NEXT, 0);
        }
        break;

    case WM_DESTROY:
        if( bGradient )
            if( pGradient )
                delete (pGradient);
        break;

        // OnCommand
    case WM_COMMAND:
        switch( LOWORD(wParam) ) {
        case IDC_RAWDATA:
            RawDataSelected(hWnd, bShowRawData = !bShowRawData);

            if( bGradient )
                pGradient->ShowPercent(bShowRawData);
            break;
        }
        break;

        // Change the background of all Static text fields to WHITE
    case WM_CTLCOLORSTATIC:
        // We only want to paint the background for the items in the top white rectangle!
        switch( GetDlgCtrlID((HWND)lParam) ) {
        case IDC_WIZARD_MSG:
        case IDC_HEADERFRAME:
        case IDC_WIZARD_MSG_HDR:
            return(LRESULT)GetStockObject(WHITE_BRUSH);
        }
        return(FALSE);

    case WM_NOTIFY:
        switch( ((NMHDR FAR *) lParam)->code ) {
        case PSN_KILLACTIVE:
            KillTimer(hWnd, ID_CAL_TIMER);
            break;

        case PSN_SETACTIVE:
            // Set up for first round
            CalStateChange( hWnd, (BYTE)NULL );
            SetTimer( hWnd, ID_CAL_TIMER, CALIBRATION_INTERVAL, (TIMERPROC)TimerProc);
            ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_NEXT | PSWIZB_BACK);
            break;

        case PSN_WIZBACK:
            // Determine what the previous calibration stage is!
            if( nCalState == nPrevCalState ) {
                DWORD dwAxis = pdiCpl->GetStateFlags()->nAxis;
                nPrevCalState --;

                while( ( !(dwAxis & (1<<(--nPrevCalState)) ) ) && (nPrevCalState > JCS_XY_CENTER2) ){
                    ;
                }
                
                nPrevCalState ++;
            }

            nCalState = nPrevCalState;

            if( nCalState > JCS_XY_CENTER2 ) {
                // UpdateProgressLabel MUST be called Before CalStateChange!!!
                UpdateProgressLabel(hWnd);

                CalStateChange( hWnd, (BYTE)NULL );
            }

            SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, (nCalState < JCS_Z_MOVE) ? IDD_XY : -1);
            return(nCalState < JCS_Z_MOVE) ?  IDD_XY : -1;

        case PSN_WIZNEXT:
            nPrevCalState = nCalState;

            // Determine what the next calibration stage is!
            while( (!(pdiCpl->GetStateFlags()->nAxis & 1<<nCalState++)) && (nCalState < JCS_FINI) );

            if( nCalState <=  JCS_S1_MOVE ) {
                UpdateProgressLabel(hWnd);
                
#ifdef WE_SUPPORT_CALIBRATING_POVS
            } else if( bPolledPOV ) {
                nCalState = JCS_S1_MOVE + 1;
                
                SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, IDD_POV );

                return(IDD_POV);
#endif
            } else {
                // Remove the dialog items you no longer need...
                //EnableSliderWindows(hWnd, FALSE);
                const short nCtrlArray[] = {IDC_SLIDER, IDC_RAWDATA, IDC_RAWX, IDC_RAWXOUTPUT, IDC_JOYLIST2_LABEL};
                BYTE nSize = sizeof(nCtrlArray)/sizeof(short);

                do {
                    SetWindowPos( GetDlgItem(hWnd, nCtrlArray[--nSize]), NULL, NULL, NULL, NULL, NULL, 
                                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW );
                } while( nSize );

                ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_FINISH);
            }

            CalStateChange( hWnd, (BYTE)NULL );

            // we have no further pages, so don't allow them to go any further!
            SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, -1);
            
            return(-1);


        case PSN_WIZFINISH:
            WizFinish(hWnd);
            break;

        default:
            return(FALSE);

        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);   
}

//*******************************************************************************
//
//   FUNCTION: EnableSliderWindows(HWND hWnd, BOOL bEnable)
//
//   PURPOSE: 	Procedure to Show/Hide dialog controls during CalSliderProc's life
//
//   COMMENTS:	
//	
//*******************************************************************************
/*
void EnableSliderWindows(const HWND hWnd, BOOL bEnable)
{
    const short nCtrlArray[] = {IDC_SLIDER, IDC_RAWDATA, IDC_RAWX, IDC_RAWXOUTPUT, IDC_JOYLIST2_LABEL};
    BYTE nSize = sizeof(nCtrlArray)/sizeof(short);

    do
    {
       SetWindowPos( GetDlgItem(hWnd, nCtrlArray[--nSize]), NULL, NULL, NULL, NULL, NULL, 
           SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | (bEnable ? SWP_SHOWWINDOW : SWP_HIDEWINDOW ));
    } while (nSize);
}
*/
#ifdef WE_SUPPORT_CALIBRATING_POVS 
//****************************************************************************
//
//   FUNCTION: CalPovProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//   PURPOSE: 	Procedure 
//
//   COMMENTS:
//	
//      This function creates the wizard property sheet.
//****************************************************************************
LRESULT CALLBACK CalPovProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg ) {
    case WM_ACTIVATEAPP:
        if( lpDIJoyState )
            DoTestPOV(FORCE_POV_REFRESH, lpDIJoyState->rgdwPOV, hWnd);
        break;

    case WM_INITDIALOG:
    {
        // Set the POV position to the Up position and Set the Text!
        nCalState = JCS_POV_MOVEUP;

        HWND hwndPOV = GetDlgItem(hWnd, IDC_JOYPOV);
        // Disable RTL flag
        SetWindowLongPtr(hwndPOV, GWL_EXSTYLE, GetWindowLongPtr(hwndPOV,GWL_EXSTYLE)&~WS_EX_LAYOUTRTL);

        // Set the Control font!
        ::SendDlgItemMessage(hWnd,IDC_WIZARD_MSG_HDR, WM_SETFONT, (WPARAM)hTitleFont, TRUE);
        break;
    }
    
    case WM_DESTROY:
        break;

    case WM_COMMAND:
        switch( LOWORD(wParam) ) {
        case IDC_RAWDATA:
            RawDataSelected(hWnd, bShowRawData = !bShowRawData);
            break;

        case IDC_SETPOV:

            //if( joyGetPosEx(pdiCpl->GetID(), lpJoyInfo) == JOYERR_NOERROR ) {
            if( SUCCEEDED(DIUtilPollJoystick(pdiDevice2, lpDIJoyState)) ) {
                CollectCalInfo(hWnd, lpDIJoyState);
                // Insert the POV information!
                switch( nCalState ) {
                case JCS_POV_MOVEUP:
                    // Store what we got!
                    pRanges->dwPOV[JOY_POVVAL_FORWARD] = pJoyConfig->hwc.hwv.dwPOVValues[JOY_POVVAL_FORWARD] = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL) ? lpDIJoyState->rgdwPOV[0] : 0;
                    
                    // Once you're here... disable the buttons... no going back and forth...
                    ::SendMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_DISABLEDFINISH);
                    break;

                case JCS_POV_MOVERIGHT:
                    // Store what we got!
                    pRanges->dwPOV[JOY_POVVAL_RIGHT] = pJoyConfig->hwc.hwv.dwPOVValues[JOY_POVVAL_RIGHT] = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL) ? lpDIJoyState->rgdwPOV[0] : 0;
                    break;

                case JCS_POV_MOVEDOWN:
                    // Store what we got!
                    pRanges->dwPOV[JOY_POVVAL_BACKWARD] = pJoyConfig->hwc.hwv.dwPOVValues[JOY_POVVAL_BACKWARD] = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL) ? lpDIJoyState->rgdwPOV[0] : 0;
                    break;

                case JCS_POV_MOVELEFT:
                    // Store what we got!
                    pRanges->dwPOV[JOY_POVVAL_LEFT] = pJoyConfig->hwc.hwv.dwPOVValues[JOY_POVVAL_LEFT] = (pJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL) ? lpDIJoyState->rgdwPOV[0] : 0;
                    ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_FINISH);

                    // Take away the controls... it's all over!
                    DestroyWindow(GetDlgItem(hWnd, IDC_JOYPOV));
                    DestroyWindow(GetDlgItem(hWnd, IDC_SETPOV));
                    break;
                }
            }

            nCalState++;
            CalStateChange(hWnd, NULL);

            // Set the focus back to IDC_SETPOV button!
            SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hWnd, IDC_SETPOV), (LPARAM)TRUE);
            break;
        }
        break;

        // Change the background of all Static text fields to WHITE
    case WM_CTLCOLORSTATIC:
        // We only want to paint the background for the items in the top white rectangle!
        switch( GetDlgCtrlID((HWND)lParam) ) {
        case IDC_WIZARD_MSG:
        case IDC_HEADERFRAME:
        case IDC_WIZARD_MSG_HDR:
            return(LRESULT)GetStockObject(WHITE_BRUSH);
        }
        return(FALSE);


    case WM_NOTIFY:
        switch( ((NMHDR FAR *) lParam)->code ) {
        
        case PSN_KILLACTIVE:
            KillTimer(hWnd, ID_CAL_TIMER);
            return(TRUE);

        case PSN_RESET:
            break;

        case PSN_SETACTIVE:
            if( nCalState == JCS_POV_MOVEUP ) {
                DoTestPOV(FORCE_POV_REFRESH, lpDIJoyState->rgdwPOV, hWnd);
            }
            CalStateChange(hWnd, NULL);
            break;

        case PSN_WIZFINISH:
            WizFinish(hWnd);
            break;

        case PSN_WIZBACK:
            // Determine what the next calibration stage is!
            if( nCalState == nPrevCalState ) {
                DWORD dwAxis = pdiCpl->GetStateFlags()->nAxis;
                nPrevCalState --;

                while( ( !(dwAxis & (1<<(--nPrevCalState)) ) ) && (nPrevCalState > JCS_XY_CENTER2) ){
                    ;
                }
                
                nPrevCalState ++;
            }

            nCalState = nPrevCalState;

            if( nCalState > JCS_XY_CENTER2 ) {
                if( nCalState <=  JCS_S1_MOVE ) {
                    UpdateProgressLabel(hWnd);
                    
                    CalStateChange( hWnd, (BYTE)NULL );
                } else if( bPolledPOV ) {
                    SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, IDD_POV );

                    return(IDD_POV);
                }
            } else {
                SetWindowLongPtr(hWnd,  DWLP_MSGRESULT, (nCalState < JCS_Z_MOVE) ? IDD_XY : -1);
                return(nCalState < JCS_Z_MOVE) ?  IDD_XY : -1;
            }

            break;

        case PSN_WIZNEXT:
            // Take away the controls... it's all over!
            DestroyWindow(GetDlgItem(hWnd, IDC_JOYPOV));
            DestroyWindow(GetDlgItem(hWnd, IDC_SETPOV));

            // Go on to Finish!
            nCalState = JCS_FINI;
            CalStateChange(hWnd, NULL);

            // Get rid of Back and bring on Finish!
            ::PostMessage(GetParent(hWnd), PSM_SETWIZBUTTONS, 0, (LPARAM)(DWORD)PSWIZB_FINISH);

            break;

        default:
            return(FALSE);

        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);   
}
#endif // WE_SUPPORT_CALIBRATING_POVS 

//*******************************************************************************
//
//   FUNCTION: CalStateChange( HWND hDlg, BYTE nDeviceFlags )
//
//   PURPOSE: 	Procedure to set up the dialog for its' Next stage
//
//   COMMENTS:	
//	
//*******************************************************************************
void CalStateChange( HWND hDlg, BYTE nDeviceFlags )
{
    short nMsgID   = IDS_JOYCAL_MOVE;
    short nTitleID = IDS_AXIS_CALIBRATION;

#define MAX_CAL_VAL 0xfffffff

    switch( nCalState ) {
    case JCS_XY_CENTER1:
    case JCS_XY_CENTER2:
        // Set up the string ID
        if( nDeviceFlags & JOY_HWS_ISYOKE )
            nMsgID = IDS_JOYCALXY_CENTERYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL )
            nMsgID = IDS_JOYCALXY_CENTERCAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD )
            nMsgID = IDS_JOYCALXY_CENTERGAMEPAD;
        else nMsgID = IDS_JOYCALXY_CENTER;

        // Setup the Header TextID
        nTitleID    = (nCalState == JCS_XY_CENTER1) ? IDS_CENTER_HDR : IDS_VERIFY_CENTER_HDR;

        EnableXYWindows( hDlg ); 
        break;

    case JCS_XY_MOVE:

        // Set up the string ID
        if( nDeviceFlags & JOY_HWS_ISYOKE )
            nMsgID = IDS_JOYCALXY_MOVEYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL )
            nMsgID = IDS_JOYCALXY_MOVECAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD )
            nMsgID = IDS_JOYCALXY_MOVEGAMEPAD;
        else nMsgID = IDS_JOYCALXY_MOVE;

        // Blast the data so we are sure to get the correct data!
        pRanges->jpMin.dwX =  MAX_CAL_VAL;
        pRanges->jpMax.dwX = -MAX_CAL_VAL;

        pRanges->jpMin.dwY =  MAX_CAL_VAL;
        pRanges->jpMax.dwY = -MAX_CAL_VAL;

        EnableXYWindows( hDlg ); 
        break;

/*
    case JCS_XY_CENTER1:
      // Set up the string ID
      if ( nDeviceFlags & JOY_HWS_ISYOKE ) 
           nMsgID = IDS_JOYCALXY_CENTERYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL ) 
            nMsgID = IDS_JOYCALXY_CENTERCAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD ) 
            nMsgID = IDS_JOYCALXY_CENTERGAMEPAD;
        else nMsgID = IDS_JOYCALXY_CENTER;

        // Setup the Header TextID
        nTitleID	= IDS_CENTER_HDR;

      EnableXYWindows( hDlg ); 
        break;

   case JCS_XY_MOVE:

      // Set up the string ID
       if( nDeviceFlags & JOY_HWS_ISYOKE ) 
           nMsgID = IDS_JOYCALXY_MOVEYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL ) 
            nMsgID = IDS_JOYCALXY_MOVECAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD ) 
            nMsgID = IDS_JOYCALXY_MOVEGAMEPAD;
        else nMsgID = IDS_JOYCALXY_MOVE;

      // Blast the data so we are sure to get the correct data!
      pRanges->jpMin.dwX =  MAX_CAL_VAL;
      pRanges->jpMax.dwX = -MAX_CAL_VAL;

      pRanges->jpMin.dwY =  MAX_CAL_VAL;
      pRanges->jpMax.dwY = -MAX_CAL_VAL;

      EnableXYWindows( hDlg ); 
       break;

    case JCS_XY_CENTER2:

      // Set up the string ID
        if( nDeviceFlags & JOY_HWS_ISYOKE ) 
            nMsgID = IDS_JOYCALXY_CENTERYOKE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL ) 
            nMsgID = IDS_JOYCALXY_CENTERCAR;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD ) 
            nMsgID = IDS_JOYCALXY_CENTERGAMEPAD;
        else nMsgID = IDS_JOYCALXY_CENTER;

        // Setup the Header TextID
        nTitleID	= IDS_VERIFY_CENTER_HDR;

        EnableXYWindows( hDlg );
       break;
*/
#ifdef DEADZONE
    case JCS_DEADZONE:
        // Set up the message string.
        if( nDeviceFlags & JOY_HWS_ISYOKE )
            nMsgID = IDS_YOKE_DEADZONE;
        else if( nDeviceFlags & JOY_HWS_ISCARCTRL )
            nMsgID = IDS_CAR_DEADZONE;
        else if( nDeviceFlags & JOY_HWS_ISGAMEPAD )
            nMsgID = IDS_GAMEPAD_DEADZONE;
        else nMsgID = IDS_JOYSTICK_DEADZONE;

        // Set up the title string!
        nTitleID = IDS_DEADZONE_TITLE;

        // Setup the controls!
        EnableXYWindows( hDlg );

        // Text Labels are sent in during UpdateXYLabel!
        // Text fonts are set on INIT!

        // Setup the Spin positions!
        {
            LPDIPROPDWORD pDIPropDW =  (LPDIPROPDWORD)_alloca(DIPROPDWORD);
            ASSERT (pDIPropDW);

            ZeroMemory(pDIPropDW, sizeof(DIPROPDWORD));

            pDIPropDW->diph.dwSize          = sizeof(DIPROPDWORD);
            pDIPropDW->diph.dwHeaderSize    = sizeof(DIPROPHEADER);
            pDIPropDW->diph.dwObj           = DIJOFS_X;
            pDIPropDW->diph.dwHow           = DIPH_BYOFFSET;

            HWND hSpinCtrl;

            // Deadzone first...
            if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_DEADZONE, &pDIPropDW->diph)) ) {
                // First the Deadzone...
                hSpinCtrl = GetDlgItem(hDlg, IDC_X_DEADZONE_SPIN);

                ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(1000, 1));
                ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
                ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(pDIPropDW->dwData, 0));
            }

            // Setup the DIPROPDWORD struct!
            pDIPropDW->diph.dwObj           = DIJOFS_Y;

            if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_DEADZONE, &pDIPropDW->diph)) ) {
                // First the Deadzone...
                hSpinCtrl = GetDlgItem(hDlg, IDC_Y_DEADZONE_SPIN);

                ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(1000, 1));
                ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
                ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(pDIPropDW->dwData, 0));
            }

            // Now, the Saturation!
            if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_SATURATION, &pDIPropDW->diph)) ) {
                hSpinCtrl = GetDlgItem(hDlg, IDC_Y_SATURATION_SPIN);

                ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(1000, 1));
                ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
                ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(pDIPropDW->dwData, 0));
            }

            // Setup the DIPROPDWORD struct!
            pDIPropDW->diph.dwObj           = DIJOFS_X;


            if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_SATURATION, &pDIPropDW->diph)) ) {
                hSpinCtrl = GetDlgItem(hDlg, IDC_X_SATURATION_SPIN);

                ::PostMessage(hSpinCtrl, UDM_SETRANGE,  0, MAKELPARAM(1000, 1));
                ::PostMessage(hSpinCtrl, UDM_SETBASE,  10, 0L);
                ::PostMessage(hSpinCtrl, UDM_SETPOS,     0, MAKELPARAM(pDIPropDW->dwData, 0));
            }
        }

        // Draw the rectangle!

        break;
#endif //DEADZONE

    case JCS_Z_MOVE:
        {
            static long nMin = pRanges->jpMin.dwZ;
            static long nMax = pRanges->jpMax.dwZ;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwZ =  MAX_CAL_VAL;
            pRanges->jpMax.dwZ = -MAX_CAL_VAL;
        }
        break;

    case JCS_R_MOVE:
        {
            static long nMin = pRanges->jpMin.dwRx;
            static long nMax    = pRanges->jpMax.dwRx;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwRx =  MAX_CAL_VAL;
            pRanges->jpMax.dwRx = -MAX_CAL_VAL;
        }
        break;

    case JCS_U_MOVE:
        {
            static long nMin = pRanges->jpMin.dwRy;
            static long nMax = pRanges->jpMax.dwRy;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwRy =  MAX_CAL_VAL;
            pRanges->jpMax.dwRy = -MAX_CAL_VAL;
        }
        break;

    case JCS_V_MOVE:
        {
            static long nMin = pRanges->jpMin.dwRz;
            static long nMax = pRanges->jpMax.dwRz;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwRz =  MAX_CAL_VAL;
            pRanges->jpMax.dwRz = -MAX_CAL_VAL;
        }
        break;

    case JCS_S0_MOVE:
        {
            static long nMin = pRanges->jpMin.dwS0;
            static long nMax    = pRanges->jpMax.dwS0;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwS0 =  MAX_CAL_VAL;
            pRanges->jpMax.dwS0 = -MAX_CAL_VAL;
        }
        break;

    case JCS_S1_MOVE:
        {
            static long nMin = pRanges->jpMin.dwS1;
            static long nMax    = pRanges->jpMax.dwS1;

            // Set the Range
            if( bGradient )
                pGradient->SetRange(nMin, nMax);

            ::PostMessage(ProgWndCal, PBM_SETRANGE32, (WPARAM)nMin, (LPARAM)nMax);

            // Blast the data so we are sure to get the correct data!
            pRanges->jpMin.dwS1 =  MAX_CAL_VAL;
            pRanges->jpMax.dwS1 = -MAX_CAL_VAL;
        }
        break;

#ifdef WE_SUPPORT_CALIBRATING_POVS
    case JCS_POV_MOVEUP:
        lpDIJoyState->rgdwPOV[0] = JOY_POVFORWARD;
        DoTestPOV(HAS_POV1 | HAS_CALIBRATED, lpDIJoyState->rgdwPOV, hDlg);

        nMsgID   = IDS_JOYCALPOV_MOVE;
        nTitleID = IDS_POV_CALIBRATION;
        break;

    case JCS_POV_MOVERIGHT:
        lpDIJoyState->rgdwPOV[0] = JOY_POVRIGHT;
        DoTestPOV(HAS_POV1 | HAS_CALIBRATED, lpDIJoyState->rgdwPOV, hDlg);

        nMsgID   = IDS_JOYCALPOV_MOVE;
        nTitleID = IDS_POV_CALIBRATION;
        break;

    case JCS_POV_MOVEDOWN:
        lpDIJoyState->rgdwPOV[0] = JOY_POVBACKWARD;
        DoTestPOV(HAS_POV1 | HAS_CALIBRATED, lpDIJoyState->rgdwPOV, hDlg);

        nMsgID   = IDS_JOYCALPOV_MOVE;
        nTitleID = IDS_POV_CALIBRATION;
        break;

    case JCS_POV_MOVELEFT:
        lpDIJoyState->rgdwPOV[0] = JOY_POVLEFT;
        DoTestPOV(HAS_POV1 | HAS_CALIBRATED, lpDIJoyState->rgdwPOV, hDlg);

        nMsgID   = IDS_JOYCALPOV_MOVE;
        nTitleID = IDS_POV_CALIBRATION;
        break;
#endif //WE_SUPPORT_CALIBRATING_POVS

    case JCS_FINI:
        nMsgID   = IDS_JOYCAL_DONE;
        nTitleID = IDS_CALIBRATION_FINI;
        break;

    default:
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF.DLL: CAL.CPP: CalStateChange: nCalState doesn't match any known Calibration States!\n"));
#endif
        return;

    }  // END OF SWITCH

    // load and set the text
    LPTSTR lptszMsg = new TCHAR[MAX_STR_LEN];

    DWORD nStrLen = MAX_STR_LEN - 1;

    // see if there is any OEM text specified
    if( pJoyConfig->hwc.dwUsageSettings & JOY_US_ISOEM ) {
        GetOEMCtrlString(lptszMsg, &nStrLen);
    } else {
    	nStrLen = 0;
    }

    // nStrLen will be non-zero if GetOEMCtrlString is successfull!
    if( nStrLen == 0 ) {
        VERIFY(LoadString(ghInst, nMsgID, lptszMsg, MAX_STR_LEN));

        switch( nMsgID ) {
        case IDS_JOYCAL_MOVE:
            {
                LPTSTR lptszBuff = new TCHAR[STR_LEN_32];
                LPTSTR lpDup = StrDup(lptszMsg);

                if( lptszBuff && lpDup ) {
                    ::SendDlgItemMessage(hDlg, IDC_JOYLIST2_LABEL, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)lptszBuff);
                    wsprintf(lptszMsg, lpDup, lptszBuff);
                    LocalFree(lpDup);
                    delete []lptszBuff;
                }
            }
            break;
        }
    }

    // Send the smaller message
    ::SendDlgItemMessage(hDlg, IDC_WIZARD_MSG, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)lptszMsg);

    VERIFY(LoadString(ghInst, nTitleID, lptszMsg, MAX_STR_LEN));

    // Send the Bold Header message
    ::SendDlgItemMessage(hDlg, IDC_WIZARD_MSG_HDR, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)lptszMsg);

    if( lptszMsg ) {
        delete[] (lptszMsg);
    }

    // Take care of the RawData dialog items!
    switch( nCalState ) {
    // Don't do the raw data thing if you don't have the checkbox!
    case JCS_XY_CENTER1:
    case JCS_XY_CENTER2:
    case JCS_FINI:
        break;

        // Do the percent for the pages that need it!
    case JCS_Z_MOVE:
    case JCS_R_MOVE:
    case JCS_U_MOVE:
    case JCS_V_MOVE:
    case JCS_S0_MOVE:
    case JCS_S1_MOVE:
        if( bGradient ) {
            if( pGradient ) {
                pGradient->ShowPercent(bShowRawData);
            }
        }
        // Missing break intentional!!!

    default:
        RawDataSelected(hDlg, bShowRawData);
        ::SendDlgItemMessage(hDlg, IDC_RAWDATA, BM_SETCHECK, (bShowRawData) ? BST_CHECKED : BST_UNCHECKED, 0);
        break;
    }


} // *** end of CalStateChange 



//*******************************************************************************
//
//   FUNCTION: CollectCalInfo( HWND hDlg, LPDIJOYSTATE pdiJoyState )
//
//   PURPOSE: 	Procedure to Collect Calibration Data
//
//   COMMENTS:	
//	
//*******************************************************************************
BOOL CollectCalInfo( HWND hDlg, LPDIJOYSTATE pdiJoyState )
{
    TCHAR tsz[16];

    switch( nCalState ) {
    // remember XY center
    case JCS_XY_CENTER1:
        // store the initial centres!
        pRanges->jpCenter.dwY = pdiJoyState->lY;
        pRanges->jpCenter.dwX = pdiJoyState->lX;

        // We Have an X/Y, so let's check for our Pens!
        CreatePens();
        break;

        // remember max/min XY values
    case JCS_XY_MOVE:
        if( pdiJoyState->lX > pRanges->jpMax.dwX )
            pRanges->jpMax.dwX = pdiJoyState->lX;
        else if( pdiJoyState->lX < pRanges->jpMin.dwX )
            pRanges->jpMin.dwX = pdiJoyState->lX;

        if( pdiJoyState->lY > pRanges->jpMax.dwY )
            pRanges->jpMax.dwY = pdiJoyState->lY;
        else if( pdiJoyState->lY < pRanges->jpMin.dwY )
            pRanges->jpMin.dwY = pdiJoyState->lY;

        // if IDC_RAWXOUTPUT is visible, then so is IDC_RAWYOUTPUT...
        // no bother to even ask.
        if( bShowRawData ) {
            static POINT ptOld = {DELTA,DELTA};

            if( (ptOld.x != pdiJoyState->lX) || (ptOld.y != pdiJoyState->lY) ) {
                myitoa(pdiJoyState->lX, &tsz[0]);
                ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);

                myitoa(pdiJoyState->lY, &tsz[0]);
                ::SendDlgItemMessage(hDlg, IDC_RAWYOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);

                ptOld.x = pdiJoyState->lX;
                ptOld.y = pdiJoyState->lY;
            }
        }

        // Scale before send it to DoJoyMove!
        {
            RECT rc;
            GetClientRect(GetDlgItem(hDlg, IDC_JOYLIST1), &rc);

            // Casting to the UINT will change the sign!
            UINT nRange = (UINT)(pRanges->jpMax.dwX - pRanges->jpMin.dwX);

            float nScaledRange = (float)(rc.right-DELTA);

            if( nRange )
                nScaledRange /= (float)nRange;

            // Scale X
            pdiJoyState->lX = (long)((pdiJoyState->lX - pRanges->jpMin.dwX) * nScaledRange);

            // Scale Y
            if( nRange ) nScaledRange = (float)rc.bottom / (float)nRange;
            pdiJoyState->lY = (long)((pdiJoyState->lY - pRanges->jpMin.dwY) * nScaledRange);
        }
        DoJoyMove( hDlg, (BYTE)HAS_X|HAS_Y );
        break;

    case JCS_XY_CENTER2:
        // Average the Y
        pRanges->jpCenter.dwY = (pRanges->jpCenter.dwY += pdiJoyState->lY)>>1;

        //Average the X
        pRanges->jpCenter.dwX = (pRanges->jpCenter.dwX += pdiJoyState->lX)>>1;
        break;

        // remember max/min Z value
    case JCS_Z_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->lZ  > pRanges->jpMax.dwZ ) {
            pRanges->jpMax.dwZ    = pdiJoyState->lZ; 
            pRanges->jpCenter.dwZ = (pRanges->jpMax.dwZ+pRanges->jpMin.dwZ)>>1;
        } else if( pdiJoyState->lZ  < pRanges->jpMin.dwZ ) {
            pRanges->jpMin.dwZ    = pdiJoyState->lZ; 
            pRanges->jpCenter.dwZ = (pRanges->jpMax.dwZ+pRanges->jpMin.dwZ)>>1;
        }

        // Do the position status
        // Update the text
        if( bShowRawData ) {
            myitoa(pdiJoyState->lZ, &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->lZ);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->lZ, 0L);
        break;

        // remember max/min Rx value
    case JCS_R_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->lRx  > pRanges->jpMax.dwRx ) {
            pRanges->jpMax.dwRx    = pdiJoyState->lRx; 
            pRanges->jpCenter.dwRx = (pRanges->jpMax.dwRx+pRanges->jpMin.dwRx)>>1;
        } else if( pdiJoyState->lRx  < pRanges->jpMin.dwRx ) {
            pRanges->jpMin.dwRx    = pdiJoyState->lRx; 
            pRanges->jpCenter.dwRx = (pRanges->jpMax.dwRx+pRanges->jpMin.dwRx)>>1;
        }

        // Do the position status
        // Update the text
        if( bShowRawData ) {
            myitoa(pdiJoyState->lRx, &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->lRx);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->lRx, 0L);
        break;

        // remember max/min Ry value
    case JCS_U_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->lRy > pRanges->jpMax.dwRy ) {
            pRanges->jpMax.dwRy    = pdiJoyState->lRy; 
            pRanges->jpCenter.dwRy = (pRanges->jpMax.dwRy+pRanges->jpMin.dwRy)>>1;
        } else if( pdiJoyState->lRy < pRanges->jpMin.dwRy ) {
            pRanges->jpMin.dwRy    = pdiJoyState->lRy; 
            pRanges->jpCenter.dwRy = (pRanges->jpMax.dwRy+pRanges->jpMin.dwRy)>>1;
        }

        // Do the position status
        if( bShowRawData ) {
            myitoa(pdiJoyState->lRy, &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->lRy);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->lRy, 0L);
        break;

        // remember max/min Rz value
    case JCS_V_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->lRz > pRanges->jpMax.dwRz ) {
            pRanges->jpMax.dwRz    = pdiJoyState->lRz; 
            pRanges->jpCenter.dwRz = (pRanges->jpMax.dwRz+pRanges->jpMin.dwRz)>>1;
        } else if( pdiJoyState->lRz < pRanges->jpMin.dwRz ) {
            pRanges->jpMin.dwRz    = pdiJoyState->lRz; 
            pRanges->jpCenter.dwRz = (pRanges->jpMax.dwRz+pRanges->jpMin.dwRz)>>1;
        }

        // Do the position status
        if( bShowRawData ) {
            myitoa(pdiJoyState->lRz, &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->lRz);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->lRz, 0L);
        break;

        // remember max/min S0 value
    case JCS_S0_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->rglSlider[0] > pRanges->jpMax.dwS0 ) {
            pRanges->jpMax.dwS0    = pdiJoyState->rglSlider[0]; 
            pRanges->jpCenter.dwS0 = (pRanges->jpMax.dwS0+pRanges->jpMin.dwS0)>>1;
        } else if( pdiJoyState->rglSlider[0] < pRanges->jpMin.dwS0 ) {
            pRanges->jpMin.dwS0    = pdiJoyState->rglSlider[0]; 
            pRanges->jpCenter.dwS0 = (pRanges->jpMax.dwS0+pRanges->jpMin.dwS0)>>1;
        }

        // Do the position status
        if( bShowRawData ) {
            myitoa(pdiJoyState->rglSlider[0], &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->rglSlider[0]);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->rglSlider[0], 0L);
        break;

        // remember max/min S1 value
    case JCS_S1_MOVE:
        // Set new Min's and Max's...
        // Set a new Center whenever either is hit!
        if( pdiJoyState->rglSlider[1] > pRanges->jpMax.dwS1 ) {
            pRanges->jpMax.dwS1    = pdiJoyState->rglSlider[1]; 
            pRanges->jpCenter.dwS1 = (pRanges->jpMax.dwS1+pRanges->jpMin.dwS1)>>1;
        } else if( pdiJoyState->rglSlider[1] < pRanges->jpMin.dwS1 ) {
            pRanges->jpMin.dwS1    = pdiJoyState->rglSlider[1]; 
            pRanges->jpCenter.dwS1 = (pRanges->jpMax.dwS1+pRanges->jpMin.dwS1)>>1;
        }

        // Do the position status
        if( bShowRawData ) {
            myitoa(pdiJoyState->rglSlider[1], &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }

        if( bGradient )
            pGradient->SetPos(pdiJoyState->rglSlider[1]);

        ::PostMessage(ProgWndCal, PBM_SETPOS, (WPARAM)pdiJoyState->rglSlider[1], 0L);
        break;

    case JCS_POV_MOVEUP:
    case JCS_POV_MOVERIGHT:
    case JCS_POV_MOVEDOWN:
    case JCS_POV_MOVELEFT:
        // Do the position status
        /*
        if( bShowRawData ) {
            myitoa(pdiJoyState->rgdwPOV[0], &tsz[0]);
            ::SendDlgItemMessage(hDlg, IDC_RAWXOUTPUT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tsz);
        }
        */
        break;
    }

    return(TRUE);
} // CollectCalInfo


//*******************************************************************************
//
//   FUNCTION: EnableXYWindows( HWND hDlg)
//
//   PURPOSE: 	Enables X/Y Windows
//
//   COMMENTS:	
//	
//*******************************************************************************
void EnableXYWindows( HWND hDlg )
{
    ////// set up the XY window controls ///////		  	 
    USHORT nCtrls[] = {IDC_RAWX, IDC_RAWY, IDC_RAWXOUTPUT, IDC_RAWYOUTPUT};
    BYTE nNumCtrls = sizeof(nCtrls)/sizeof(short);                                                    

    do {
        SetWindowPos( GetDlgItem( hDlg,  nCtrls[--nNumCtrls]), NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW);
    } while( nNumCtrls );

#ifdef DEADZONE
    {
        USHORT nDZCtrls[] = {IDC_X_DEADZONE_SPIN,   IDC_Y_DEADZONE_SPIN, IDC_X_SATURATION_SPIN,
            IDC_Y_SATURATION_SPIN, IDC_DEADZONE_TITLE,  IDC_X_DEADZONE,
            IDC_Y_DEADZONE,           IDC_X_AXIS_LABEL,    IDC_X_AXIS_LABEL,
            IDC_Y_AXIS_LABEL,     IDC_SATURATION_TITLE,IDC_X_SATURATION,
            IDC_Y_SATURATION,      IDC_X_AXIS_LABEL_SATURATION, IDC_Y_AXIS_LABEL_SATURATION};
        nNumCtrls = sizeof(nCtrls)/sizeof(short);                                                    

        do {
            // Use SetWindowPos here because internally, ShowWindow calls it!
            SetWindowPos( GetDlgItem( hDlg,  nCtrls[nNumCtrls]), NULL, NULL, NULL, NULL, NULL, 
                          SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((nCalState == JCS_DEADZONE) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
        } while( nNumCtrls-- );
    }
#endif // DEADZONE	

    nCtrls[0] = IDC_JOYLIST1;
    nCtrls[1] = IDC_JOYLIST1_LABEL;
    nCtrls[2] = IDC_RAWDATA;
    nNumCtrls = 2;

    do {
        // Use SetWindowPos here because internally, ShowWindow calls it!
        SetWindowPos( GetDlgItem( hDlg,  nCtrls[nNumCtrls]), NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | (((nCalState == JCS_XY_MOVE) 
#ifdef DEADZONE
                                                                 || (nCalState == JCS_DEADZONE)
#endif
                                                                ) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
    } while( nNumCtrls-- );
    
    HWND hwndXY = GetDlgItem(hDlg, IDC_JOYLIST1);
    // Disable RTL flag
    SetWindowLongPtr( hwndXY, GWL_EXSTYLE, GetWindowLongPtr(hwndXY,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL );
    
}

//*******************************************************************************
//
//   FUNCTION: GetOEMCtrlString(LPTSTR lptStr, BYTE *nStrLen)
//
//   PURPOSE: 	Gets string and string length for OEM controls
//
//   COMMENTS:	
//	
//*******************************************************************************
BOOL GetOEMCtrlString(LPTSTR lptStr, LPDWORD nStrLen)
{
    // there's no REGSTR_VAL_JOYOEM for the sliders so return false and take the defaults
    switch( nCalState ) {
        case JCS_S0_MOVE:
        case JCS_S1_MOVE:
            *nStrLen = 0;
            return(FALSE);
    }

    // Get the DIJOYCONFIG interface pointer!
    LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
    pdiCpl->GetJoyConfig(&pdiJoyConfig);

    BOOL bRet = FALSE;

    if( SUCCEEDED(pdiJoyConfig->Acquire()) ) {
        HKEY hKey;

        // Open the TypeKey
        if( SUCCEEDED(pdiJoyConfig->OpenTypeKey( lpwszTypeName, KEY_ALL_ACCESS, &hKey)) ) {
            // registry strings for calibration messages
            static LPCTSTR pszOEMCalRegStrs[] = { 
                REGSTR_VAL_JOYOEMCAL1, REGSTR_VAL_JOYOEMCAL2,
                REGSTR_VAL_JOYOEMCAL3, REGSTR_VAL_JOYOEMCAL4,
                REGSTR_VAL_JOYOEMCAL5, REGSTR_VAL_JOYOEMCAL6,
                REGSTR_VAL_JOYOEMCAL7, 

#ifdef WE_SUPPORT_CALIBRATING_POVS
                REGSTR_VAL_JOYOEMCAL8, REGSTR_VAL_JOYOEMCAL9, 
                REGSTR_VAL_JOYOEMCAL10,REGSTR_VAL_JOYOEMCAL11, 
#endif  // WE_SUPPORT_CALIBRATING_POVS
                REGSTR_VAL_JOYOEMCAL12
            };

            if( nCalState < (sizeof(pszOEMCalRegStrs)/sizeof(pszOEMCalRegStrs[0])) )
            {
                DWORD dwType = REG_SZ;
                // the -2 is because of JCS_S0_MOVE and JCS_S1_MOVE!
                if( RegQueryValueEx( hKey, pszOEMCalRegStrs[(nCalState == JCS_FINI) ? nCalState-2 : nCalState], NULL, &dwType, (CONST LPBYTE)lptStr, nStrLen ) == ERROR_SUCCESS )
                    bRet = TRUE;
                else
                    *nStrLen = 0;
            }
            else
            {
                *nStrLen = 0;
            }
            RegCloseKey(hKey);
        } else
        {
            *nStrLen = 0;
#ifdef _DEBUG
            OutputDebugString(TEXT("Test.cpp: GetOEMCtrlString: OpenTypeKey FAILED!\n"));
#endif
        }

        pdiJoyConfig->Unacquire();
    }

    return(bRet);
} // *** end of GetOEMCtrlString


#ifdef WE_SUPPORT_CALIBRATING_POVS
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	SetDefaultButton( HWND hwdb )
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
void SetDefaultButton( HWND hDlg, HWND hCtrl )
{
    // make the specified button the default
    DWORD style = GetWindowLong( hCtrl, GWL_STYLE );
    style &= ~(BS_PUSHBUTTON|BS_DEFPUSHBUTTON);
    style |= BS_DEFPUSHBUTTON;
    SetWindowLong( hCtrl, GWL_STYLE, style );

} // SetDefaultButton
#endif //WE_SUPPORT_CALIBRATING_POVS

//===========================================================================
// SetCalibrationMode ( BOOL bSet )
// 
// Sets DirectInput Calibration mode (RAW/COOKED)
//
// Parameters:
//  BOOL					bSet			-		TRUE for RAW, FALSE for COOKED
//
// Returns:				return value from SetProperty (standard COM stuff)
//
//===========================================================================
HRESULT SetCalibrationMode( BOOL bSet)
{
    LPDIPROPDWORD pDIPropDword = (LPDIPROPDWORD)_alloca(sizeof(DIPROPDWORD));
    assert (pDIPropDword);

    pDIPropDword->diph.dwSize = sizeof(DIPROPDWORD);
    pDIPropDword->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropDword->diph.dwObj  = 0x0;
    pDIPropDword->diph.dwHow  = DIPH_DEVICE;
    pDIPropDword->dwData = bSet ? DIPROPCALIBRATIONMODE_RAW : DIPROPCALIBRATIONMODE_COOKED;

    // Set the mode to Raw Data during Calibration!
    HRESULT hr = pdiDevice2->SetProperty(DIPROP_CALIBRATIONMODE, &pDIPropDword->diph);
#ifdef _DEBUG
    if( FAILED(hr) ) {
        OutputDebugString(TEXT("GCDEF.DLL: CAL.CPP: SetCalibrationMode: SetProperty Failed with a return of "));


        switch( hr ) {
        case DI_PROPNOEFFECT:
            OutputDebugString(TEXT("DI_PROPNOEFFECT\n"));
            break;

        case DIERR_INVALIDPARAM:
            OutputDebugString(TEXT("DIERR_INVALIDPARAM\n"));
            break;

        case DIERR_OBJECTNOTFOUND:
            OutputDebugString(TEXT("DIERR_OBJECTNOTFOUND\n"));
            break;

        case DIERR_UNSUPPORTED:
            OutputDebugString(TEXT("DIERR_UNSUPPORTED\n"));
            break;

        default:
            {
                TCHAR szTmp[32];
                wsprintf(szTmp, TEXT("%x"), hr);
                OutputDebugString(szTmp);
            }
        }
    }
#endif
    return(hr);
}


//===========================================================================
// UpdateXYLabel(HWND hWnd)
//
// Displays the number and names of the device Axis in the provided dialog.
// This	EXPECTS that the controls are not visible by default!
//
// Parameters:
//  HWND             hDlg       - Dialog handle
//
// Returns:
//
//===========================================================================
void UpdateXYLabel(const HWND hDlg)
{
    BYTE nAxisFlags = pdiCpl->GetStateFlags()->nAxis;

    // X and Y use the same control so they are isolated!
    if( (nAxisFlags & HAS_X) || (nAxisFlags & HAS_Y) ) {
        LPDIDEVICEOBJECTINSTANCE_DX3 pDevObjInst = new (DIDEVICEOBJECTINSTANCE_DX3);
        assert (pDevObjInst);

        ZeroMemory(pDevObjInst, sizeof(DIDEVICEOBJECTINSTANCE_DX3));

        pDevObjInst->dwSize = sizeof(DIDEVICEOBJECTINSTANCE_DX3);

        LPTSTR ptszBuff = (LPTSTR) _alloca(sizeof(TCHAR[STR_LEN_32]));
        assert (ptszBuff);

        ZeroMemory(ptszBuff, sizeof(TCHAR[STR_LEN_32]));

        // Set it's text
        if( nAxisFlags & HAS_X ) {
            if( FAILED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_X, DIPH_BYOFFSET)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF.DLL: DisplayAvailableAxis: GetObjectInfo Failed to find DIJOFS_X!\n"));
#endif
            }

            int nLen=lstrlen(pDevObjInst->tszName)+1;
            if(nLen>STR_LEN_32)
                nLen=STR_LEN_32;
            StrCpyN(ptszBuff, pDevObjInst->tszName, nLen);

            // Set the Output Label!
            ::SendDlgItemMessage(hDlg, IDC_RAWX, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);

#ifdef DEADZONE
            // Set text labels!
            ::SendDlgItemMessage(hDlg, IDC_X_AXIS_LABEL_DEADZONE,   WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
            ::SendDlgItemMessage(hDlg, IDC_X_AXIS_LABEL_SATURATION, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
#endif //DEADZONE

            // Remove the HAS_X flag
            nAxisFlags &= ~HAS_X;
        }

        if( nAxisFlags & HAS_Y ) {
            if( FAILED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_Y, DIPH_BYOFFSET)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF.DLL: DisplayAvailableAxis: GetObjectInfo Failed to find DIJOFS_Y!\n"));
#endif
            }

#ifdef DEADZONE
            // Set text labels!
            ::SendDlgItemMessage(hDlg, IDC_Y_AXIS_LABEL_DEADZONE,   WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
            ::SendDlgItemMessage(hDlg, IDC_Y_AXIS_LABEL_SATURATION, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
#endif //DEADZONE

            // just in case it has Y but not X
            if( ptszBuff && lstrlen(ptszBuff) ) {   // Whisltler PREFIX 45092
                int nLen=STR_LEN_32-lstrlen(ptszBuff);
                StrNCat(ptszBuff, TEXT(" / "), nLen);
            }

            int nLen=STR_LEN_32-lstrlen(ptszBuff);
            StrNCat(ptszBuff, pDevObjInst->tszName, nLen);

            // Set the Output Label!
            ::SendDlgItemMessage(hDlg, IDC_RAWY, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);

            // Remove the HAS_Y flag
            nAxisFlags &= ~HAS_Y;
        }

        if( pDevObjInst )
            delete (pDevObjInst);

        ::SendDlgItemMessage(hDlg, IDC_JOYLIST1_LABEL, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)ptszBuff);

//		if (ptszBuff)
//			delete[] (ptszBuff);
    }
} //*** end of UpdateXYLabel

//*******************************************************************************
//
//   FUNCTION: UpdateProgressLabel(HWND hDlg)
//
//   PURPOSE: 	Updates Axis specific labels based on the current Calibration stage.
//
//   COMMENTS:	
//	
//*******************************************************************************
BOOL UpdateProgressLabel(const HWND hDlg)
{
    // Array of supported axis!
    const DWORD dwOffsetArray[] = {DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};
    BOOL bRet = FALSE; 

    LPDIDEVICEOBJECTINSTANCE_DX3 pDevObjInst = (LPDIDEVICEOBJECTINSTANCE_DX3)_alloca(sizeof(DIDEVICEOBJECTINSTANCE_DX3));
    assert (pDevObjInst);

    ZeroMemory(pDevObjInst, sizeof(DIDEVICEOBJECTINSTANCE_DX3));

    pDevObjInst->dwSize = sizeof(DIDEVICEOBJECTINSTANCE_DX3);

    // Get it's text
    if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, dwOffsetArray[nCalState-3], DIPH_BYOFFSET)) ) {
        // Set it's text
        ::SendDlgItemMessage(hDlg, IDC_JOYLIST2_LABEL, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
        ::SendDlgItemMessage(hDlg, IDC_RAWX,              WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pDevObjInst->tszName);
        bRet = TRUE;
    }

    return(bRet);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:	myitoa(long n, LPTSTR lpStr)
//
// PARAMETERS:	BYTE   n     - Number to be translated
//             LPTSTR lpStr - Buffer to recieve translated value
//
// PURPOSE:	Convert BYTE values < 20 to strings.
///////////////////////////////////////////////////////////////////////////////
void myitoa(long n, LPTSTR lpStr)
{
    long sign = n;

    if( n < 0 )
        n = - n;

    LPTSTR pchStart = lpStr;

    do {
        *lpStr++ = (TCHAR)(n % 10 + '0');
    } while( (n /= 10) > 0 );

    if( sign < 0 )
        *lpStr++ = '-';
    *lpStr = '\0';
    reverse(pchStart);
}

void reverse(LPTSTR string)
{
    TCHAR c;
    short i, j;

    for( i = 0, j = lstrlen(string) - 1; i < j; i++, j-- ) {
        c = string[j];
        string[j] = string[i];
        string[i] = c;
    }
}

//*******************************************************************************
//
//   FUNCTION: RawDataSelected( HWND hWnd, BOOL bEnable )
//
//   PURPOSE: 	Shows/Hides Raw data associated windows.
//
//   COMMENTS:	
//	
//*******************************************************************************
void RawDataSelected( const HWND hWnd, BOOL bEnable )
{
    const USHORT nCtrlArray[] = {IDC_RAWX, IDC_RAWY, IDC_RAWXOUTPUT, IDC_RAWYOUTPUT};
    BYTE nCtrls = sizeof(nCtrlArray)/sizeof(short);

    do {
        SetWindowPos( GetDlgItem( hWnd,  nCtrlArray[--nCtrls]), NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((bEnable) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
    } while( nCtrls );
}

//*******************************************************************************
//
//   FUNCTION: TimerProc(HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
//
//   PURPOSE: 	TimerProc for the Calibration Wizard.
//					Searches for button presses, then moves to next stage/finish.
//
//   COMMENTS:	
//	
//*******************************************************************************
VOID CALLBACK TimerProc(const HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    if( SUCCEEDED(DIUtilPollJoystick(pdiDevice2, lpDIJoyState)) ) {
        CollectCalInfo(hWnd, lpDIJoyState);

        // Don't bother checking for key presses if the user is in the POV stage!
        if( nCalState <= JCS_S1_MOVE ) {
            // Catch button presses...
            static BYTE nDownButton = 0xff;
            BYTE i = 0;

            int nButtons = pdiCpl->GetStateFlags()->nButtons;

            // only attempt to check buttons we KNOW we have!!!
            while( nButtons ) {
                // check for a button press
                if( lpDIJoyState->rgbButtons[i] & 0x80 ) {
                    if( nDownButton != 0xff )
                        break;

                    // Let the Next button handle the processing
                    ::PostMessage(GetParent(hWnd), PSM_PRESSBUTTON, (WPARAM)(int)(nCalState > JCS_S1_MOVE) ? PSBTN_FINISH : PSBTN_NEXT, 0);

                    // Store the button that went down!
                    nDownButton = i;

                    // mission accomplished!
                    return;
                }
                // reset the nDownButton flag
                else if( i == nDownButton )
                    nDownButton = 0xff;

                nButtons &= ~(HAS_BUTTON1<<i++);
            } 
            // end of catch for button presses!
        }
    }
}

// This is because PSN_WIZFINISH is Documented to be sent to every page dlg proc on exit... but it doesn't!
static void WizFinish(const HWND hWnd)
{
    HRESULT hres;

    KillTimer(hWnd, ID_CAL_TIMER);

    // assign the new ranges
    SetMyRanges(pdiDevice2, pRanges, pdiCpl->GetStateFlags()->nAxis);

    LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
    pdiCpl->GetJoyConfig(&pdiJoyConfig);

    if( pdiCpl->GetStateFlags()->nPOVs ) {
        pdiDevice2->Unacquire();
        SetCalibrationMode( FALSE );
        pdiJoyConfig->Acquire();

        CopyRange( &pJoyConfig->hwc.hwv.jrvHardware, pRanges );
        memcpy( pJoyConfig->hwc.hwv.dwPOVValues, pRanges->dwPOV, sizeof(DWORD)*4 );

        hres = pdiJoyConfig->SetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)pJoyConfig, DIJC_REGHWCONFIGTYPE);
      #ifdef WE_SUPPORT_CALIBRATING_POVS
        if( SUCCEEDED(hres) ) {
            CalibratePolledPOV( &pJoyConfig->hwc );

            // set POV positions!
            if( bPolledPOV ) {
                SetMyPOVRanges(pdiDevice2);
            }
        }
      #endif
    }

    pdiJoyConfig->SendNotify();
    pdiDevice2->Unacquire();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\cal.h ===
//===========================================================================
// CALIBRATE.H
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#ifndef _CALIBRATE_H
#define _CALIBRATE_H



/***************************************************************************
//
//					FUNCTION DEFINITIONS FOLLOW
//
 ***************************************************************************/

BOOL CALLBACK Calibrate_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

typedef struct sliderranges_tag
{
	DWORD dwSlider0Max;
	DWORD dwSlider0Min;
	DWORD dwSlider0Centre;
	DWORD dwSlider1Max;
	DWORD dwSlider1Min;
	DWORD dwSlider1Centre;
}SLIDERRANGES, FAR *LPSLIDERRANGES;
#endif // *** _CALIBRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\cplsvr1.h ===
//===========================================================================
// CPLSVR1.H
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

//---------------------------------------------------------------------------

// Comment out to remove FORCE_FEEDBACK PAGE!
//#define FORCE_FEEDBACK

#ifndef _CPLSVR1_H
#define _CPLSVR1_H

//---------------------------------------------------------------------------
#define INC_OLE2
#define DIRECTINPUT_VERSION      0x05B2

#ifndef PPVOID
#define PPVOID  LPVOID*
#endif

// included headers
#define STRICT
#include <afxcmn.h>
#include <windows.h>
#include <objbase.h>

#ifndef _UNICODE
#include <malloc.h>     // needed for _alloca
#include <afxconv.h>
#endif

#include <dinput.h>
#include <dinputd.h>

#include "dicpl.h"
#include "resource.h"
#include "resrc1.h"
#include <assert.h>
#include "joyarray.h"
#include <mmsystem.h>

// symbolic constants
#define ID_POLLTIMER    50

#ifdef FORCE_FEEDBACK
#define NUMPAGES		3
#else
#define NUMPAGES        2
#endif // FORCE_FEEDBACK

// defines for calibration proc
#define MAX_STR_LEN		256
#define STR_LEN_128		128
#define STR_LEN_64		 64
#define STR_LEN_32		 32

// defines for the progress controls
#define NUM_WNDS  MAX_AXIS - 2
#define Z_INDEX  0
#define RX_INDEX 1
#define RY_INDEX 2
#define RZ_INDEX 3
#define S0_INDEX 4
#define S1_INDEX 5

// Defines for DrawCross()
#define JOYMOVE_DRAWXY	0x00000001
#define JOYMOVE_DRAWR	0x00000002
#define JOYMOVE_DRAWZ	0x00000004
#define JOYMOVE_DRAWU	0x00000008
#define JOYMOVE_DRAWV	0x00000010
#define JOYMOVE_DRAWALL	JOYMOVE_DRAWXY | JOYMOVE_DRAWR | JOYMOVE_DRAWZ | JOYMOVE_DRAWU | JOYMOVE_DRAWV

#define CAL_HIT     0x0001
#define RUDDER_HIT  0x0002
#define CALIBRATING 0x0004

#define POV_MIN    0
#define POV_MAX    1

#define HAS_CALIBRATED    0x40
#define FORCE_POV_REFRESH 254
void DoTestPOV ( BYTE nPov, PDWORD pdwPOV, HWND hDlg ); //in test.cpp
void CalibratePolledPOV( LPJOYREGHWCONFIG pHWCfg );     //in test.cpp

extern BOOL bPolledPOV;                                 //in cplsvr1.h
extern DWORD   myPOV[2][JOY_POV_NUMDIRS+1];             //in cplsvr1.h


typedef struct _CPLPAGEINFO
{
    //LPTSTR  lpwszDlgTemplate;
	USHORT lpwszDlgTemplate;
    DLGPROC fpPageProc;
} CPLPAGEINFO;

// Pop the structure packing 
//#include <poppack.h>

typedef struct _STATEFLAGS
{
	int  nButtons;
	BYTE nAxis;
	BYTE nPOVs;
} STATEFLAGS;


// prototypes
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv);
STDAPI DllCanUnloadNow(void);

// dialog callback functions
BOOL CALLBACK Settings_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK Test_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef FORCE_FEEDBACK
BOOL CALLBACK ForceFeedback_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif // FORCE_FEEDBACK

extern ATOM RegisterCustomButtonClass();
void myitoa(long n, LPTSTR lpStr); // held in cal.cpp
void CreatePens( void );

#ifdef _UNICODE
void RegisterForDevChange(HWND hDlg, PVOID *hNotifyDevNode);
#endif

// As the names imply, I had to create my own stucts because
// the DI ones doesn't support sliders!
typedef struct myjoypos_tag {
   long  dwX;
   long  dwY;
   long  dwZ;
   long  dwRx;
   long  dwRy;
   long  dwRz;
   long  dwS0;
   long  dwS1;
} MYJOYPOS, FAR *LPMYJOYPOS;

typedef struct myjoyrange_tag {
    MYJOYPOS      jpMin;
    MYJOYPOS      jpMax;
    MYJOYPOS      jpCenter;
#ifdef WE_SUPPORT_CALIBRATING_POVS
    DWORD         dwPOV[4];   // Currently only supports 1 POV w/4 possitions!
#endif    
} MYJOYRANGE,FAR *LPMYJOYRANGE;


// utility services
void DrawCross	( const HWND hwnd, LPPOINTS pPoint, short nFlag);
void DoJoyMove	( const HWND hDlg, BYTE nDrawFlags );
void SetOEMWindowText( const HWND hDlg, const short *nControlIDs, LPCTSTR *pszLabels, LPCWSTR wszType, LPDIRECTINPUTJOYCONFIG pdiJoyConfig, BYTE nCount );

// Wizard Services!
short CreateWizard(const HWND hwndOwner, LPARAM lParam);

//* NULL_GUID {00000000-0000-0000-0000-000000000000}
const GUID NULL_GUID = 
{ 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } };

// derive a new class from CDIGameCntrlPropSheet
//
// we want to store some additional data here
class CDIGameCntrlPropSheet_X : public IDIGameCntrlPropSheet
{
   private:
   BYTE 				m_cProperty_refcount;
   BYTE 			    m_nID;
   BOOL               	m_bUser;

   public:
   CDIGameCntrlPropSheet_X(void);
   ~CDIGameCntrlPropSheet_X(void);
   // IUnknown methods
   virtual STDMETHODIMP            	QueryInterface(REFIID, PPVOID);
   virtual STDMETHODIMP_(ULONG)    	AddRef(void);
   virtual STDMETHODIMP_(ULONG)    	Release(void);
   // IDIGameCntrlPropSheet methods		
   virtual STDMETHODIMP				GetSheetInfo(LPDIGCSHEETINFO *ppSheetInfo);
   virtual STDMETHODIMP				GetPageInfo (LPDIGCPAGEINFO  *ppPageInfo );
   virtual STDMETHODIMP				SetID(USHORT nID);
   virtual STDMETHODIMP_(USHORT)   	GetID(void)			{return m_nID;}
   virtual STDMETHODIMP       		Initialize(void);
   virtual STDMETHODIMP       		SetDevice(LPDIRECTINPUTDEVICE2 pdiDevice2);
   virtual STDMETHODIMP       		GetDevice(LPDIRECTINPUTDEVICE2 *ppdiDevice2);
   virtual STDMETHODIMP       		SetJoyConfig(LPDIRECTINPUTJOYCONFIG pdiJoyCfg);
   virtual STDMETHODIMP       		GetJoyConfig(LPDIRECTINPUTJOYCONFIG *ppdiJoyCfg);
   virtual STDMETHODIMP_(STATEFLAGS *)	GetStateFlags(void) {return m_pStateFlags;}
   virtual STDMETHODIMP_(BOOL) 		GetUser()  {return m_bUser;}
   virtual STDMETHODIMP       		SetUser(BOOL bUser) { m_bUser = bUser; return S_OK;}

   protected:
   DIGCSHEETINFO           *m_pdigcSheetInfo;
   DIGCPAGEINFO            *m_pdigcPageInfo;
   LPDIRECTINPUTDEVICE2    m_pdiDevice2;
   LPDIRECTINPUTJOYCONFIG  m_pdiJoyCfg;
   STATEFLAGS			   *m_pStateFlags;

   ATOM					   m_aPovClass, m_aButtonClass;
};

//---------------------------------------------------------------------------
#endif // _CPLSVR1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\calocal.h ===
//===========================================================================
// CALOCAL.H
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#ifndef _CALOCAL_H
#define _CALOCAL_H

#include <regstr.h>

#define STR_MAX_LEN		255
#define	STR_LEN_128		128
#define STR_LEN_64		 64
#define	STR_LEN_32		 32

#define DELTA			  5
#define RANGE_MIN		  0
#define RANGE_MAX	  65535


#define ID_CAL_TIMER	 		18
#define CALIBRATION_INTERVAL 	85 

#define ACTIVE_COLOR	RGB( 255, 0, 0 )
#define INACTIVE_COLOR	RGB( 128, 0, 0 )

typedef enum {
    JCS_INIT=-1,
    JCS_XY_CENTER1,
    JCS_XY_MOVE,
    JCS_XY_CENTER2,
#ifdef DEADZONE
	JCS_DEADZONE,
#endif
    JCS_Z_MOVE,
    JCS_R_MOVE,
    JCS_U_MOVE,
    JCS_V_MOVE,
    JCS_S0_MOVE,
    JCS_S1_MOVE,
#ifdef WE_SUPPORT_CALIBRATING_POVS
    JCS_POV_MOVEUP,
    JCS_POV_MOVERIGHT,
    JCS_POV_MOVEDOWN,
    JCS_POV_MOVELEFT,
#endif // WE_SUPPORT_CALIBRATING_POVS
    JCS_FINI
} cal_states;



/***************************************************************************
 
			  CALIBRATION SPECIFIC FUNCTION DEFINITIONS
 
 ***************************************************************************/

static void		CalStateChange	  ( HWND hDlg, BYTE nDeviceFlags );
static void     EnableXYWindows   ( HWND hDlg );
static BOOL		GetOEMCtrlString  ( LPTSTR lptStr, DWORD *nStrLen);
static BOOL		CollectCalInfo	  ( HWND hDlg, LPDIJOYSTATE pdiJoyState );
static HRESULT	SetCalibrationMode( BOOL bSet );

#ifdef WE_SUPPORT_CALIBRATING_POVS
//static void		ChangeIcon		( HWND hDlg, short idi );
//static void		SetDefaultButton( HWND hDlg, HWND hCtrl );
#endif //WE_SUPPORT_CALIBRATING_POVS

#endif //_CALOCAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\cplsvr1.cpp ===
//===========================================================================
// CPLSVR1.CPP
//
// Simple sample "Game Controllers" control panel extension server.
//
// Functions:
//  DLLMain()
//  DllGetClassObject()
//  DllCanUnloadNow()
//  CServerClassFactory::CServerClassFactory()
//  CServerClassFactory::~CServerClassFactory()
//  CServerClassFactory::QueryInterface()
//  CServerClassFactory::AddRef()
//  CServerClassFactory::Release()
//  CServerClassFactory::CreateInstance()
//  CServerClassFactory::LockServer()
//  CDIGameCntrlPropSheet_X::CDIGameCntrlPropSheet_X()
//  CDIGameCntrlPropSheet_X::~CDIGameCntrlPropSheet_X()
//  CDIGameCntrlPropSheet_X::QueryInterface()
//  CDIGameCntrlPropSheet_X::AddRef()
//  CDIGameCntrlPropSheet_X::Release()
//  CDIGameCntrlPropSheet_X::GetSheetInfo()								 
//  CDIGameCntrlPropSheet_X::GetPageInfo()
//  CDIGameCntrlPropSheet_X::SetID()
//  CDIGameCntrlPropSheet_X::Initialize()
//  CDIGameCntrlPropSheet_X::SetDevice()
//  CDIGameCntrlPropSheet_X::GetDevice()
//  CDIGameCntrlPropSheet_X::SetJoyConfig()
//  CDIGameCntrlPropSheet_X::GetJoyConfig()
//  
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#define INITGUID
#define STRICT

#include "cplsvr1.h"
#include "pov.h"
#include "assert.h"

//---------------------------------------------------------------------------

// file global variables
static  BYTE  glDLLRefCount  = 0;     // DLL reference count
static  LONG  glServerLocks  = 0;     // Count of locks
CDIGameCntrlPropSheet_X *pdiCpl;
HINSTANCE            ghInst;
CRITICAL_SECTION     gcritsect;

DWORD   myPOV[2][JOY_POV_NUMDIRS+1];
BOOL    bPolledPOV;

//---------------------------------------------------------------------------


// LegacyServer GUID!!!
// {92187326-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_LegacyServer, 
	0x92187326, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);


//---------------------------------------------------------------------------

//===========================================================================
// DLLMain
//
// DLL entry point.
//
// Parameters:
//  HINSTANCE   hInst       - the DLL's instance handle 
//  DWORD       dwReason    - reason why DLLMain was called
//  LPVOID      lpvReserved - 
//
// Returns:
//  BOOL - TRUE if succeeded
//
//===========================================================================
int APIENTRY DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpvReserved)
{   
	switch (dwReason)
   {
   	case DLL_PROCESS_ATTACH:
      	ghInst = hInst;
         InitializeCriticalSection(&gcritsect);
         break;

      case DLL_PROCESS_DETACH:
         DeleteCriticalSection(&gcritsect);
         break;

 		case DLL_THREAD_ATTACH:
			DisableThreadLibraryCalls((HMODULE)hInst);
   	case DLL_THREAD_DETACH:
			break;
   } //** end switch(dwReason)
   return TRUE;
} //*** end DLLMain()


//===========================================================================
// DllGetClassObject
//
// Gets an IClassFactory object.
//
// Parameters:
//  REFCLSID    rclsid  - CLSID value (by reference)
//  REFIID      riid    - IID value (by reference)
//  PPVOID      ppv     - ptr to store interface ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    // did the caller pass in our CLSID?
    if(!IsEqualCLSID(rclsid, CLSID_LegacyServer))
    {
        // no, return class not available error
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // did the caller request our class factory?
    if(!IsEqualIID(riid, IID_IClassFactory))
    {
        // no, return no interface error
        return E_NOINTERFACE;
    }

    // instantiate class factory object
    CServerClassFactory *pClsFactory = new CServerClassFactory();
    if (NULL == pClsFactory)
    {
        // could not create the object
        //
        // chances are we were out of memory
        return E_OUTOFMEMORY;

    }

    // query for interface riid, and return it via ppv
    HRESULT hRes = pClsFactory->QueryInterface(riid, ppv);   

    // we're finished with our local object
    pClsFactory->Release();

    // return the result code from QueryInterface
    return hRes;

} //*** end DllGetClassObject()


//===========================================================================
// DllCanUnloadNow
//
// Reports whether or not the DLL can be unloaded.
//
// Parameters: none
//
// Returns
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDAPI DllCanUnloadNow(void)
{
    // unloading should be safe if the global dll refcount is zero and server lock ref is 0
	 return (glDLLRefCount == 0 && glServerLocks == 0) ? S_OK : S_FALSE;
} //*** end DllCanUnloadNow()


//===========================================================================
// CServerClassFactory::CServerClassFactory
//
// Class constructor.
//
// Parameters: none
//
// Returns:
//  CServerClassFactory* (implicit)
//
//===========================================================================
CServerClassFactory::CServerClassFactory(void)
{
    // initialize and increment the object refcount
    m_ServerCFactory_refcount = 0;
    AddRef();

    // increment the dll refcount
    InterlockedIncrement((LPLONG)&glDLLRefCount);

} //*** end CServerClassFactory::CServerClassFactory()


//===========================================================================
// CServerClassFactory::CServerClassFactory
//
// Class constructor.
//
// Parameters: none
//
// Returns:
//  CServerClassFactory* (implicit)
//
//===========================================================================
CServerClassFactory::~CServerClassFactory(void)
{
	// decrement the dll refcount
   InterlockedDecrement((LPLONG)&glDLLRefCount);
} //*** end CServerClassFactory::~CServerClassFactory()


//===========================================================================
// CServerClassFactory::QueryInterface
//
// Implementation of the QueryInterface() method.
//
// Parameters:
//  REFIID  riid    - the interface that is being looked for
//  PPVOID  ppv     - pointer to target interface pointer
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDMETHODIMP CServerClassFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
	// make sure that if anything fails, we return something reasonable
   *ppv = NULL;

   // we support IUnknown...
   if (IsEqualIID(riid, IID_IUnknown))
   {
   	// return our object as an IUnknown
		*ppv = (LPUNKNOWN)(LPCLASSFACTORY)this;
	}
	else
	{
   	// ... and our interface
    	if (IsEqualIID(riid, IID_IClassFactory))
      	// return our object as a class factory
			*ppv = (LPCLASSFACTORY)this;
    	else
      	// we do not support any other interfaces
        	return E_NOINTERFACE;
	}
   
	// we got this far, so we've succeeded
	// increment our refcount and return
	AddRef();
	return S_OK;
} //*** end CServerClassFactory::QueryInterface()


//===========================================================================
// CServerClassFactory::AddRef
//
// Implementation of the AddRef() method.
//
// Parameters: none
//
// Returns:
//  ULONG   -   updated reference count. 
//              NOTE: apps should NOT rely on this value!
//
//===========================================================================
STDMETHODIMP_(ULONG) CServerClassFactory::AddRef(void)
{
	// update and return our object's reference count   
   InterlockedIncrement((LPLONG)&m_ServerCFactory_refcount);
   return m_ServerCFactory_refcount;
} //*** end CServerClassFactory::AddRef()


//===========================================================================
// CServerClassFactory::Release
//
// Implementation of the Release() method.
//
// Parameters: none
//
// Returns:
//  ULONG   -   updated reference count. 
//              NOTE: apps should NOT rely on this value!
//
//===========================================================================
STDMETHODIMP_(ULONG) CServerClassFactory::Release(void)
{
	// update and return our object's reference count   
	InterlockedDecrement((LPLONG)&m_ServerCFactory_refcount);
	if (0 == m_ServerCFactory_refcount)
	{
   	// it's now safe to call the destructor
      delete this;
      return 0;
   }
   else return m_ServerCFactory_refcount;
} //*** end CServerClassFactory::Release()
    

//===========================================================================
// CServerClassFactory::CreateInstance
//
// Implementation of the CreateInstance() method.
//
// Parameters: none
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDMETHODIMP CServerClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, PPVOID ppvObj)
{
	CDIGameCntrlPropSheet_X *pdiGCPropSheet = NULL;
   HRESULT                 hRes            = E_NOTIMPL;

   // make sure that if anything fails, we return something reasonable
   *ppvObj = NULL;

   // we want pUnkOuter to be NULL
   //
   // we do not support aggregation
   if (pUnkOuter != NULL)
   {
   	// tell the caller that we do not support this feature
      return CLASS_E_NOAGGREGATION;
   }

   // Create a new instance of the game controller property sheet object
   pdiGCPropSheet = new CDIGameCntrlPropSheet_X();
   if (NULL == pdiGCPropSheet)
   {
      // we could not create our object
      // chances are, we have run out of memory
      return E_OUTOFMEMORY;
   }
    
    // initialize the object (memory allocations, etc)
    if (SUCCEEDED(pdiGCPropSheet->Initialize()))
	    // query for interface riid, and return it via ppvObj
   	 hRes = pdiGCPropSheet->QueryInterface(riid, ppvObj);   

    // release the local object
    pdiGCPropSheet->Release();

    // all done, return result from QueryInterface
    return hRes;
} //*** end CServerClassFactory::CreateInstance()


//===========================================================================
// CServerClassFactory::LockServer
//
// Implementation of the LockServer() method.
//
// Parameters: none
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDMETHODIMP CServerClassFactory::LockServer(BOOL fLock)
{
	//HRESULT hRes = E_NOTIMPL;

   // increment/decrement based on fLock
	if (fLock) 
   	InterlockedIncrement((LPLONG)&glDLLRefCount); 
	else
   	InterlockedDecrement((LPLONG)&glDLLRefCount);

   // all done
   return S_OK;
} //*** end CServerClassFactory::LockServer()

//===========================================================================
// CDIGameCntrlPropSheet_X::CDIGameCntrlPropSheet_X
//
// Class constructor.
//
// Parameters: none
//		
// Returns: nothing
//
//===========================================================================
CDIGameCntrlPropSheet_X::CDIGameCntrlPropSheet_X(void)
{

   // initialize and increment the object refcount
   m_cProperty_refcount = 0;
   AddRef();

   // initialize our device id to -1 just to be safe
   m_nID = (BYTE)-1;

   // init 
   m_bUser = FALSE;

   // initialize all of our pointers
   m_pdigcPageInfo = NULL;
   m_pdiDevice2    = NULL;
   m_pdiJoyCfg     = NULL;
   
   pdiCpl          = NULL;

   // increment the dll refcount
   InterlockedIncrement((LPLONG)&glDLLRefCount);

	// Register the POV hat class
	m_aPovClass = RegisterPOVClass();

   // Register the custom Button class
   m_aButtonClass = RegisterCustomButtonClass();

} //*** end CDIGameCntrlPropSheet_X::CDIGameCntrlPropSheet_X()


//===========================================================================
// CDIGameCntrlPropSheet_X::~CDIGameCntrlPropSheet_X
//
// Class destructor.
//
// Parameters: none
//
// Returns: nothing
//
//===========================================================================
CDIGameCntrlPropSheet_X::~CDIGameCntrlPropSheet_X(void)
{
    // free the DIGCPAGEINFO memory
    if (m_pdigcPageInfo)
       LocalFree(m_pdigcPageInfo);

	// free the DIGCSHEETINFO memory
	if (m_pdigcSheetInfo)
		LocalFree(m_pdigcSheetInfo);

	// free up the StateFlags memory!
	if (m_pStateFlags)
		delete (m_pStateFlags);

    // cleanup directinput objects
    // m_pdiDevice2
    if (m_pdiDevice2)
    {
        m_pdiDevice2->Unacquire();
        m_pdiDevice2->Release();
        m_pdiDevice2 = NULL;
    }
    // m_pdiJoyCfg
    if (m_pdiJoyCfg)
    {
        m_pdiJoyCfg->Unacquire();
        m_pdiJoyCfg->Release();
        m_pdiJoyCfg = NULL;
    }

	// Unregister the classes!!!
	if (m_aPovClass)
		UnregisterClass((LPCTSTR)m_aPovClass, ghInst);

	if (m_aButtonClass)
		UnregisterClass((LPCTSTR)m_aButtonClass, ghInst);

    // decrement the dll refcount
    InterlockedDecrement((LPLONG)&glDLLRefCount);

} //*** end CDIGameCntrlPropSheet_X::~CDIGameCntrlPropSheet_X()


//===========================================================================
// CDIGameCntrlPropSheet_X::QueryInterface
//
// Implementation of the QueryInterface() method.
//
// Parameters:
//  REFIID  riid    - the interface that is being looked for
//  PPVOID  ppv     - pointer to target interface pointer
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::QueryInterface(REFIID riid, PPVOID ppv)
{
    // make sure that if anything fails, we return something reasonable
    *ppv = NULL;

    // we support IUnknown...
    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPUNKNOWN)(LPCDIGAMECNTRLPROPSHEET)this;
    }
    else
    {
        // ... and IID_IDIGameCntrlPropSheet
        if(IsEqualIID(riid, IID_IDIGameCntrlPropSheet))
            *ppv = (LPCDIGAMECNTRLPROPSHEET)this;
        else
            // we do not support any other interfaces
            return E_NOINTERFACE;
    }

    // we got this far, so we've succeeded
    // increment our refcount and return
    AddRef();
    return S_OK;
} //*** end CDIGameCntrlPropSheet_X::QueryInterface()


//===========================================================================
// CDIGameCntrlPropSheet_X::AddRef
//
// Implementation of the AddRef() method.
//
// Parameters: none
//
// Returns:
//  ULONG   -   updated reference count. 
//              NOTE: apps should NOT rely on this value!
//===========================================================================
STDMETHODIMP_(ULONG) CDIGameCntrlPropSheet_X::AddRef(void)
{   
    // update and return our object's reference count
    InterlockedIncrement((LPLONG)&m_cProperty_refcount);
    return m_cProperty_refcount;
} //*** end CDIGameCntrlPropSheet_X::AddRef()


//===========================================================================
// CDIGameCntrlPropSheet_X::Release
//
// Implementation of the Release() method.
//
// Parameters: none
//
// Returns:
//  ULONG   -   updated reference count. 
//              NOTE: apps should NOT rely on this value!
//===========================================================================
STDMETHODIMP_(ULONG) CDIGameCntrlPropSheet_X::Release(void)
{
	// update and return our object's reference count
   InterlockedDecrement((LPLONG)&m_cProperty_refcount);
   if (m_cProperty_refcount)
    	return m_cProperty_refcount;

	// it's now safe to call the destructor
   delete this;
   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::Release()


//===========================================================================
// CDIGameCntrlPropSheet_X::GetSheetInfo
//
// Implementation of the GetSheetInfo() method.
//
// Parameters:
//  LPDIGCSHEETINFO  *ppSheetInfo  - ptr to DIGCSHEETINFO struct ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::GetSheetInfo(LPDIGCSHEETINFO *ppSheetInfo)
{
	// pass back the our sheet information
   *ppSheetInfo = m_pdigcSheetInfo;

   // all done here
   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::GetSheetInfo()


//===========================================================================
// CDIGameCntrlPropSheet_X::GetPageInfo
//
// Implementation of the GetPageInfo() method.
//
// NOTE: This returns the information for ALL pages.  There is no mechanism
//  in place to request only page n's DIGCPAGEINFO.
//
// Parameters:
//  LPDIGCPAGEINFO  *ppPageInfo  - ptr to DIGCPAGEINFO struct ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::GetPageInfo(LPDIGCPAGEINFO  *ppPageInfo)
{
	// pass back the our page information
   *ppPageInfo = m_pdigcPageInfo;
    
   // all done here
   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::GetPageInfo()


//===========================================================================
// CDIGameCntrlPropSheet_X::SetID
//
// Implementation of the SetID() method.
//
// Parameters:
//  USHORT  nID - identifier to set
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::SetID(USHORT nID)
{
	// store the device id
   m_nID = (BYTE)nID;

   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::SetID()


//===========================================================================
// CDIGameCntrlPropSheet::Initialize
//
// Implementation of the Initialize() method.
//
// Parameters: none
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
HRESULT CDIGameCntrlPropSheet_X::Initialize(void)
{
// provide the following information for each device page
//  { dialog template, callback function pointer }
	CPLPAGEINFO     grgcpInfo[NUMPAGES] = {
		IDD_SETTINGS,
	   (DLGPROC)Settings_DlgProc,           
		IDD_TEST,
	   (DLGPROC)Test_DlgProc
#ifdef FORCE_FEEDBACK
	   ,                // Template DlgProc
		IDD_FORCEFEEDBACK, 
		(DLGPROC)ForceFeedback_DlgProc
	#endif // FORCE_FEEDBACK
      };

   // allocate memory for the DIGCPAGEINFO structures
   m_pdigcPageInfo = (DIGCPAGEINFO *)LocalAlloc(LPTR, NUMPAGES * sizeof(DIGCPAGEINFO));

   if (!m_pdigcPageInfo){
       return E_OUTOFMEMORY;
   }

	m_pdigcSheetInfo = (DIGCSHEETINFO *)LocalAlloc(LPTR, sizeof(DIGCSHEETINFO));
    if (!m_pdigcSheetInfo) {
        LocalFree(m_pdigcPageInfo);

        return E_OUTOFMEMORY;
    }

   // populate the DIGCPAGEINFO structure for each sheet
	BYTE i = 0;
	do
   {
       m_pdigcPageInfo[i].dwSize        = sizeof(DIGCPAGEINFO);
       m_pdigcPageInfo[i].fIconFlag     = FALSE;
		 // This is done to test JOY.CPL...
		 // It's also better for Win9x, as it will not be required to convert it!
//       m_pdigcPageInfo[i].lpwszPageIcon = (LPWSTR)IDI_GCICON; //MAKEINTRESOURCE(IDI_GCICON);
       m_pdigcPageInfo[i].hInstance     = ghInst;
       m_pdigcPageInfo[i].lParam        = (LPARAM)this;

       // the following data is unique to each page
       m_pdigcPageInfo[i].fpPageProc    = grgcpInfo[i].fpPageProc;
       m_pdigcPageInfo[i].lpwszTemplate = (LPWSTR)grgcpInfo[i++].lpwszDlgTemplate;
   } while (i < NUMPAGES);

   // populate the DIGCSHEETINFO structure
   m_pdigcSheetInfo->dwSize               = sizeof(DIGCSHEETINFO);
   m_pdigcSheetInfo->nNumPages            = NUMPAGES;
   m_pdigcSheetInfo->fSheetIconFlag       = TRUE;
   m_pdigcSheetInfo->lpwszSheetIcon       = (LPWSTR)IDI_GCICON; //MAKEINTRESOURCEW(IDI_GCICON);

	// Do that device object enumeration thing!
	m_pStateFlags = new (STATEFLAGS);

	if (!m_pStateFlags) {
        LocalFree(m_pdigcPageInfo);
        LocalFree(m_pdigcSheetInfo);

		return E_OUTOFMEMORY;
    }

	ZeroMemory(m_pStateFlags, sizeof(STATEFLAGS));

   // all done
   return S_OK;
} //*** end CDIGameCntrlPropSheet::Initialize()


//===========================================================================
// CDIGameCntrlPropSheet_X::SetDevice
//
// Implementation of the SetDevice() method.
//
// Parameters:
//  LPDIRECTINPUTDEVICE2 pdiDevice2 - device object ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::SetDevice(LPDIRECTINPUTDEVICE2 pdiDevice2)
{
	// store the device object ptr
   m_pdiDevice2 = pdiDevice2;

   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::SetDevice()


//===========================================================================
// CDIGameCntrlPropSheet_X::GetDevice
//
// Implementation of the GetDevice() method.
//
// Parameters:
//  LPDIRECTINPUTDEVICE2 *ppdiDevice2   - ptr to device object ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::GetDevice(LPDIRECTINPUTDEVICE2 *ppdiDevice2)
{
	// retrieve the device object ptr
	*ppdiDevice2 = m_pdiDevice2;

	return S_OK;
} //*** end CDIGameCntrlPropSheet_X::GetDevice()


//===========================================================================
// CDIGameCntrlPropSheet_X::SetJoyConfig
//
// Implementation of the SetJoyConfig() method.
//
// Parameters:
//  LPDIRECTINPUTJOYCONFIG  pdiJoyCfg - joyconfig object ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::SetJoyConfig(LPDIRECTINPUTJOYCONFIG pdiJoyCfg)
{
	// store the joyconfig object ptr
   m_pdiJoyCfg = pdiJoyCfg;

   return S_OK;
} //*** end CDIGameCntrlPropSheet_X::SetJoyConfig()


//===========================================================================
// CDIGameCntrlPropSheet_X::SetJoyConfig
//
// Implementation of the SetJoyConfig() method.
//
// Parameters:
//  LPDIRECTINPUTJOYCONFIG  *ppdiJoyCfg - ptr to joyconfig object ptr
//
// Returns:
//  HRESULT - OLE type success/failure code (S_OK if succeeded)
//===========================================================================
STDMETHODIMP CDIGameCntrlPropSheet_X::GetJoyConfig(LPDIRECTINPUTJOYCONFIG *ppdiJoyCfg)
{
	// retrieve the joyconfig object ptr
	*ppdiJoyCfg = m_pdiJoyCfg;

	return S_OK;
} //*** end CDIGameCntrlPropSheet_X::GetJoyConfig()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\dicpl.h ===
//
//                                                                       
//    This is a part of the Microsoft Direct Input SDK.                  
//    Copyright (C) 1992-1997 Microsoft Corporation                      
//    All rights reserved.                                               
//                                                                       
//    This source code is only intended as a supplement to the           
//    Microsoft Direct Input SDK References and related                  
//    electronic documentation provided with the SDK.                    
//    See these sources for detailed information regarding the           
//    Microsoft Direct Input API.                                        
//                                                                       
//

#ifndef _DX_CPL_
#define _DX_CPL_

// maximum pages allowed on a server
#define MAX_PAGES 26

// Interface ID
// {7854FB22-8EE3-11d0-A1AC-0000F8026977}
DEFINE_GUID(IID_IDIGameCntrlPropSheet, 
0x7854fb22, 0x8ee3, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);


//
//                                                                       
//                           STRUCTURES                                  
//                                                                       
//

// This pragma may not be supported by all compilers.
// Please consult your compiler documentation.
#include <pshpack8.h>

typedef struct 
{
	DWORD		      dwSize;           // Should be set to sizeof(DIGCPAGEINFO)
	LPWSTR  	      lpwszPageTitle;   // Text to be displayed on tab
	DLGPROC	      fpPageProc;       // Dialog Procedure for page
	BOOL		      fProcFlag;        // TRUE if you are using fpPrePostProc member
	DLGPROC	  	   fpPrePostProc;    // Pointer to Callback function that is Only called on Init!
	BOOL		      fIconFlag;        // TRUE if you are using lpwszPageIcon member
	LPWSTR		   lpwszPageIcon;    // Resource ID or name of icon
	LPWSTR         lpwszTemplate;    // Dialog template
	LPARAM		   lParam;           // Application defined data
	HINSTANCE	   hInstance;        // Handle of Instance to load Icon/Cursor
} DIGCPAGEINFO, *LPDIGCPAGEINFO;

typedef struct 
{
	DWORD		      dwSize;           // Should but set to sizeof(DIGCSHEETINFO)
	USHORT	      nNumPages;        // Number of pages on this sheet
	LPWSTR	      lpwszSheetCaption;// Text to be used in Sheet Window Title
	BOOL		      fSheetIconFlag;   // TRUE if you are using the lpwszSheetIcon member
	LPWSTR		   lpwszSheetIcon;   // Resource ID or name of icon
} DIGCSHEETINFO, *LPDIGCSHEETINFO;

#include <poppack.h>

//
//                                                                       
//         Interface as Exposed by the InProcServer Property Sheet       
//                                                                       
//
DECLARE_INTERFACE_( IDIGameCntrlPropSheet, IUnknown)
{
	// IUnknown Members
	STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// IServerProperty Members
	STDMETHOD(GetSheetInfo)		(THIS_ LPDIGCSHEETINFO *) PURE; 	
	STDMETHOD(GetPageInfo)		(THIS_ LPDIGCPAGEINFO *) PURE; 	
	STDMETHOD(SetID)			(THIS_ USHORT nID) PURE;
	STDMETHOD_(USHORT,GetID)(THIS) PURE;
};
typedef IDIGameCntrlPropSheet *LPIDIGAMECNTRLPROPSHEET;

//
//                                                                       
//                CLASS DEFINITION for CServerClassFactory				     
//                                                                       
//
class CServerClassFactory : public IClassFactory
{
	protected:
		ULONG   			m_ServerCFactory_refcount;
    
	public:
		// constructor
		CServerClassFactory(void);
		// destructor
		~CServerClassFactory(void);
        
		// IUnknown methods
		STDMETHODIMP            QueryInterface(REFIID, PPVOID);
		STDMETHODIMP_(ULONG)    AddRef(void);
		STDMETHODIMP_(ULONG)    Release(void);
    
		// IClassFactory methods
		STDMETHODIMP    		CreateInstance(LPUNKNOWN, REFIID, PPVOID);
		STDMETHODIMP    		LockServer(BOOL);
};

//
//                                                                       
//				  CLASS DEFINITION for CDIGameCntrlPropSheet			        
//                                                                       
//
class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
	friend					      CServerClassFactory;

	private:
		DWORD				         m_cProperty_refcount;
		
	public:
		CDIGameCntrlPropSheet(void);
		~CDIGameCntrlPropSheet(void);
		
		// IUnknown methods
	   STDMETHODIMP            QueryInterface(REFIID, PPVOID);
	   STDMETHODIMP_(ULONG)    AddRef(void);
	   STDMETHODIMP_(ULONG)    Release(void);
		
		STDMETHODIMP			   GetSheetInfo(LPDIGCSHEETINFO *lpSheetInfo);
		STDMETHODIMP			   GetPageInfo (LPDIGCPAGEINFO  *lpPageInfo );
		STDMETHODIMP			   SetID(USHORT nID);
      STDMETHODIMP_(USHORT)   GetID();
};
typedef CDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;


//
//                                                                       
//                             ERRORS                                    
//                                                                       
//
#define DIGCERR_ERRORSTART			   0x80097000
#define DIGCERR_NUMPAGESZERO	   	0x80097001
#define DIGCERR_NODLGPROC		   	0x80097002
#define DIGCERR_NOPREPOSTPROC		   0x80097003
#define DIGCERR_NOTITLE				   0x80097004
#define DIGCERR_NOCAPTION		   	0x80097005
#define DIGCERR_NOICON				   0x80097006
#define DIGCERR_STARTPAGETOOLARGE	0x80097007
#define DIGCERR_NUMPAGESTOOLARGE	   0x80097008
#define DIGCERR_INVALIDDWSIZE		   0x80097009
#define DIGCERR_ERROREND			   0x80097100

#endif // _DX_CPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\dicputil.h ===
//===========================================================================
// DICPUTIL.H
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#ifndef _DICPUTIL_H
#define _DICPUTIL_H

// Max supported defines!
#define MAX_BUTTONS	32
#define MAX_AXIS		8
#define MAX_POVS		4

// State flag defines!!!
// State flags for axis
#define HAS_X			0x0001
#define HAS_Y			0x0002
#define HAS_Z			0x0004
#define HAS_RX			0x0008
#define HAS_RY			0x0010
#define HAS_RZ			0x0020
#define HAS_SLIDER0	0x0040
#define HAS_SLIDER1	0x0080

// State flags for buttons
#define HAS_BUTTON1	0x00000001
#define HAS_BUTTON2	0x00000002
#define HAS_BUTTON3	0x00000004
#define HAS_BUTTON4	0x00000008
#define HAS_BUTTON5	0x00000010
#define HAS_BUTTON6	0x00000020
#define HAS_BUTTON7	0x00000040
#define HAS_BUTTON8	0x00000080
#define HAS_BUTTON9	0x00000100
#define HAS_BUTTON10	0x00000200
#define HAS_BUTTON11	0x00000400
#define HAS_BUTTON12	0x00000800
#define HAS_BUTTON13	0x00001000
#define HAS_BUTTON14	0x00002000
#define HAS_BUTTON15	0x00004000
#define HAS_BUTTON16	0x00008000
#define HAS_BUTTON17	0x00010000
#define HAS_BUTTON18	0x00020000
#define HAS_BUTTON19	0x00040000
#define HAS_BUTTON20	0x00080000
#define HAS_BUTTON21	0x00100000
#define HAS_BUTTON22	0x00200000
#define HAS_BUTTON23	0x00400000
#define HAS_BUTTON24	0x00800000
#define HAS_BUTTON25	0x01000000
#define HAS_BUTTON26	0x02000000
#define HAS_BUTTON27	0x04000000
#define HAS_BUTTON28	0x08000000
#define HAS_BUTTON29	0x10000000
#define HAS_BUTTON30	0x20000000
#define HAS_BUTTON31	0x40000000
#define HAS_BUTTON32	0x80000000

// State flags for POVs
#define HAS_POV1		0x0001
#define HAS_POV2		0x0002
#define HAS_POV3		0x0004
#define	HAS_POV4		0x0008


//---------------------------------------------------------------------------

// prototypes
HRESULT DIUtilPollJoystick(LPDIRECTINPUTDEVICE2 pdiDevice2, LPDIJOYSTATE pdijs);


// helper functions
void GetMyRanges(LPDIRECTINPUTDEVICE2 lpdiDevice2, LPMYJOYRANGE lpMyRanges, BYTE nAxis);
void SetMyRanges(LPDIRECTINPUTDEVICE2 lpdiDevice2, LPMYJOYRANGE lpMyRanges, BYTE nAxis);
void SetMyPOVRanges(LPDIRECTINPUTDEVICE2 pdiDevice2);

//BOOL GetDeviceRanges( LPMYJOYRANGE lpMyRanges, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis);

void OnHelp(LPARAM lParam);
void OnContextMenu(WPARAM wParam);
BOOL GetHelpFileName(LPTSTR lpszHelpFileName, short* nSize);
//BOOL CALLBACK DIEnumDeviceObjectsProc( LPCDIDEVICEOBJECTINSTANCE_DX3 lpddoi, LPVOID pvStateFlags );
HRESULT InitDInput(HWND hWnd, CDIGameCntrlPropSheet_X *pdiCpl);
void EnumDeviceObjects(LPDIRECTINPUTDEVICE2 lpdiDevice2, STATEFLAGS *pStateFlags);
void SetTitle( HWND hDlg );
BOOL Error(HWND hWnd, short nTitleID, short nMsgID);
void CenterDialog(HWND hWnd);
void PostDlgItemEnableWindow(HWND hDlg, USHORT nItem, BOOL bEnabled);
void PostEnableWindow(HWND hCtrl, BOOL bEnabled);

void CopyRange( LPJOYRANGE lpjr, LPMYJOYRANGE lpmyjr );

//---------------------------------------------------------------------------
#endif _DICPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\dicputil.cpp ===
//===========================================================================
// DICPUTIL.CPP
//
// DirectInput CPL helper functions.
//
// Functions:
//  DIUtilGetJoystickTypeName()
//  DIUtilPollJoystick()
//
//===========================================================================

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#include "cplsvr1.h"
#include "dicputil.h"
#include <shlwapi.h>  // for Str... functions!
#include <malloc.h>	 // for _alloca

extern HWND ghDlg;
extern CDIGameCntrlPropSheet_X *pdiCpl;
extern HINSTANCE  ghInst;
extern CRITICAL_SECTION gcritsect;


//===========================================================================
// DIUtilPollJoystick
//
// Polls the joystick device and returns the device state.
//
// Parameters:
//  LPDIRECTINPUTDEVICE2    pdiDevice2  - ptr to device object
//  DIJOYSTATE              *pdijs      - ptr to store joystick state
//
// Returns: HRESULT
//
//===========================================================================
HRESULT DIUtilPollJoystick(LPDIRECTINPUTDEVICE2 pdiDevice2, LPDIJOYSTATE pdijs)
{
    // clear the pdijs memory
    // this way, if we fail, we return no data
    pdijs->lX = pdijs->lY = pdijs->lZ = pdijs->lRx = pdijs->lRy = pdijs->lRz = pdijs->rglSlider[0] = pdijs->rglSlider[1] = 0;

    // poll the joystick
    HRESULT hRes; 

    if( SUCCEEDED(hRes = pdiDevice2->Poll()) )
    {
        static BOOL bFirstPoll = TRUE;

        // This is to disreguard the first poll!
        // DINPUT sends garbage the first poll.
        if( bFirstPoll )
        {
            pdiDevice2->GetDeviceState(sizeof(DIJOYSTATE), pdijs);
            bFirstPoll = FALSE;
        }

        // query the device state
        if( FAILED(hRes = pdiDevice2->GetDeviceState(sizeof(DIJOYSTATE), pdijs)) )
        {
            if( hRes == DIERR_INPUTLOST )
            {
                if( SUCCEEDED(hRes = pdiDevice2->Acquire()) )
                    hRes = pdiDevice2->GetDeviceState(sizeof(DIJOYSTATE), pdijs);
            }
        }
    }

    // done
    return(hRes);
} // *** end DIUtilPollJoystick()

//===========================================================================
// InitDInput
//
// Initializes DirectInput objects
//
// Parameters:
//  HWND                    hWnd    - handle of caller's window
//  CDIGameCntrlPropSheet_X *pdiCpl - pointer to Game Controllers property
//                                      sheet object
//
// Returns: HRESULT
//
//===========================================================================
HRESULT InitDInput(HWND hWnd, CDIGameCntrlPropSheet_X *pdiCpl)
{
    HRESULT                 hRes = S_OK;
    LPDIRECTINPUTDEVICE2    pdiDevice2;
    LPDIRECTINPUTJOYCONFIG  pdiJoyCfg;
    LPDIRECTINPUT           pdi = 0;

    // protect ourselves from multithreading problems
    EnterCriticalSection(&gcritsect);

    // validate pdiCpl
    if( (IsBadReadPtr((void*)pdiCpl, sizeof(CDIGameCntrlPropSheet_X))) ||
        (IsBadWritePtr((void*)pdiCpl, sizeof(CDIGameCntrlPropSheet_X))) )
    {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF.DLL: InitDInput() - bogus pointer\n"));
#endif
        hRes = E_POINTER;
        goto exitinit;
    }

    // retrieve the current device object
    pdiCpl->GetDevice(&pdiDevice2);   

    // retrieve the current joyconfig object
    pdiCpl->GetJoyConfig(&pdiJoyCfg);   

    // have we already initialized DirectInput?
    if( (NULL == pdiDevice2) || (NULL == pdiJoyCfg) )
    {
        // no, create a base DirectInput object
        if( FAILED(hRes = DirectInputCreate(ghInst, DIRECTINPUT_VERSION, &pdi, NULL)) )
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: DirectInputCreate() failed\n"));
#endif
            goto exitinit;
        }

        // have we already created a joyconfig object?
        if( NULL == pdiJoyCfg )
        {
            // no, create a joyconfig object
            if( SUCCEEDED(pdi->QueryInterface(IID_IDirectInputJoyConfig, (LPVOID*)&pdiJoyCfg)) )
            {
                if( SUCCEEDED(pdiJoyCfg->SetCooperativeLevel(hWnd, DISCL_EXCLUSIVE | DISCL_BACKGROUND)) )
                    pdiCpl->SetJoyConfig(pdiJoyCfg);
            } else
            {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF.DLL: Unable to create joyconfig\n"));
#endif
                goto exitinit;
            }
        }

        // have we already created a device object?
        if( NULL == pdiDevice2 )
        {
            // no, create a device object
            if( NULL != pdiJoyCfg )
            {
                LPDIRECTINPUTDEVICE  pdiDevTemp;
                LPDIJOYCONFIG_DX5    lpDIJoyConfig = (LPDIJOYCONFIG_DX5)_alloca(sizeof(DIJOYCONFIG_DX5));
                ASSERT (lpDIJoyConfig);

                // get the type name
                ZeroMemory(lpDIJoyConfig, sizeof(DIJOYCONFIG_DX5));

                // GetConfig will provide this information
                lpDIJoyConfig->dwSize = sizeof(DIJOYCONFIG_DX5);

                // Get the instance necessarey for CreateDevice
                if( SUCCEEDED(hRes = pdiJoyCfg->GetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)lpDIJoyConfig, DIJC_GUIDINSTANCE)) )
                {
                    // Create the device
                    if( SUCCEEDED(hRes = pdi->CreateDevice(lpDIJoyConfig->guidInstance, &pdiDevTemp, NULL)) )
                    {
                        // Query the device for the Device2 interface!
                        if( SUCCEEDED(hRes = pdiDevTemp->QueryInterface(IID_IDirectInputDevice2, (LPVOID*)&pdiDevice2)) )
                        {
                            // release the temporary object
                            pdiDevTemp->Release();

                            // Set the DataFormat and CooperativeLevel!
                            if( SUCCEEDED(hRes = pdiDevice2->SetDataFormat(&c_dfDIJoystick)) )
                                hRes = pdiDevice2->SetCooperativeLevel(hWnd, DISCL_EXCLUSIVE | DISCL_BACKGROUND);
                        }
                    }
                }

                if( SUCCEEDED(hRes) )
                {
                    // store the device object
                    pdiCpl->SetDevice(pdiDevice2);
                } else
                {
                    goto exitinit;
                }
            } else goto exitinit;
        }
    } else {
    	goto exitinit;
    }

    // if everything is Zero, either you've never enumerated or the enumeration is suspectable
    if( (pdiCpl->GetStateFlags()->nButtons == 0) &&
        (pdiCpl->GetStateFlags()->nAxis    == 0) &&
        (pdiCpl->GetStateFlags()->nPOVs    == 0) )
    {
        EnumDeviceObjects(pdiDevice2, pdiCpl->GetStateFlags());

        /*
        if (FAILED(pdiDevice2->EnumObjects((LPDIENUMDEVICEOBJECTSCALLBACK)DIEnumDeviceObjectsProc, (LPVOID *)pdiCpl->GetStateFlags(), DIDFT_ALL)))
        {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: TEST.CPP: WM_INIT: EnumObjects FAILED!\n"));
#endif
        }
        */
    }

exitinit:
    // release the base DirectInput object
    if( pdi ) {
        pdi->Release();
    }

    // we're done
    LeaveCriticalSection(&gcritsect);
    return(hRes);

} //*** end InitDInput()



void OnHelp(LPARAM lParam)
{                  
    assert ( lParam );

    short nSize = STR_LEN_32;

    // point to help file
    LPTSTR pszHelpFileName = (LPTSTR) _alloca(sizeof(TCHAR[STR_LEN_32]));
    assert (pszHelpFileName);

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    if( ((LPHELPINFO)lParam)->iContextType == HELPINFO_WINDOW )
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, pszHelpFileName, (UINT)HELP_WM_HELP, (ULONG_PTR)gaHelpIDs);
}

BOOL GetHelpFileName(TCHAR *lpszHelpFileName, short* nSize)
{
    if( LoadString(ghInst, IDS_HELPFILENAME, lpszHelpFileName, *nSize) )
        return(S_OK);
    else
        return(E_FAIL);
}

////////////////////////////////////////////////////////////////////////////////////////
//	OnContextMenu(WPARAM wParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam)
{
    short nSize = STR_LEN_32;

    // point to help file
    LPTSTR pszHelpFileName = (LPTSTR) _alloca(sizeof(TCHAR[STR_LEN_32]));
    assert (pszHelpFileName);                      

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)gaHelpIDs);
}

// Instead of enumerating via EnumObjects
void EnumDeviceObjects(LPDIRECTINPUTDEVICE2 pdiDevice2, STATEFLAGS *pStateFlags)
{
    LPDIDEVICEOBJECTINSTANCE_DX3 pDevObjInst = (LPDIDEVICEOBJECTINSTANCE_DX3) _alloca(sizeof(DIDEVICEOBJECTINSTANCE_DX3));
    assert (pDevObjInst);

    pDevObjInst->dwSize = sizeof(DIDEVICEOBJECTINSTANCE_DX3);

    const DWORD dwOffsetArray[] = {DIJOFS_X, DIJOFS_Y, DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};

    // -1 is for 0 based dwOffsetArray!
    BYTE n = MAX_AXIS;

    do
    {
        if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, dwOffsetArray[--n], DIPH_BYOFFSET)) )
            pStateFlags->nAxis |= (HAS_X<<n);
    } while( n );


    n = MAX_BUTTONS;

    do
    {
        if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_BUTTON(--n), DIPH_BYOFFSET)) )
            pStateFlags->nButtons |= (HAS_BUTTON1<<n);
    } while( n );


    n = MAX_POVS;

    do
    {
        if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_POV(--n), DIPH_BYOFFSET)) )
            pStateFlags->nPOVs |= (HAS_POV1<<n);
    } while( n );
}

#define GETRANGE( n ) \
		pDIPropCal->lMin	  = lpMyRanges->jpMin.dw##n##;		\
		pDIPropCal->lCenter = lpMyRanges->jpCenter.dw##n##;	\
		pDIPropCal->lMax	  = lpMyRanges->jpMax.dw##n##;		\


void SetMyRanges(LPDIRECTINPUTDEVICE2 lpdiDevice2, LPMYJOYRANGE lpMyRanges, BYTE nAxis)
{
    LPDIPROPCAL pDIPropCal = (LPDIPROPCAL)_alloca(sizeof(DIPROPCAL));
    assert (pDIPropCal);

    pDIPropCal->diph.dwSize         = sizeof(DIPROPCAL);
    pDIPropCal->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropCal->diph.dwHow          = DIPH_BYOFFSET;

    const DWORD dwOffsetArray[] = {DIJOFS_X, DIJOFS_Y, DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};
    BYTE n = 0;

    // You have to start with a "while" here because Reset to Default may not have Any Axis!!!
    while( nAxis )
    {
        if( nAxis & HAS_X )
        {
            GETRANGE(X);
        } else if( nAxis & HAS_Y )
        {
            GETRANGE(Y);
            n = 1;
        } else if( nAxis & HAS_Z )
        {
            GETRANGE(Z)
            n = 2;
        } else if( nAxis & HAS_RX )
        {
            GETRANGE(Rx);
            n = 3;
        } else if( nAxis & HAS_RY )
        {
            GETRANGE(Ry);
            n = 4;
        } else if( nAxis & HAS_RZ )
        {
            GETRANGE(Rz);
            n = 5;
        } else if( nAxis & HAS_SLIDER0 )
        {
            GETRANGE(S0);
            n = 6;
        } else if( nAxis & HAS_SLIDER1 )
        {
            GETRANGE(S1); 
            n = 7;
        }

        pDIPropCal->diph.dwObj = dwOffsetArray[n];

        VERIFY(SUCCEEDED(lpdiDevice2->SetProperty(DIPROP_CALIBRATION, &pDIPropCal->diph)));

        nAxis &= ~HAS_X<<n;
    }
}

// Removed 'till we calibrate POVs again!
void SetMyPOVRanges(LPDIRECTINPUTDEVICE2 pdiDevice2)
{
    DIPROPCALPOV *pDIPropCal = new (DIPROPCALPOV);
    assert (pDIPropCal);

    ZeroMemory(pDIPropCal, sizeof(*pDIPropCal));

    pDIPropCal->diph.dwSize = sizeof(*pDIPropCal);
    pDIPropCal->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropCal->diph.dwHow = DIPH_BYID; 
    pDIPropCal->diph.dwObj = DIDFT_POV; 

    memcpy( pDIPropCal->lMin, myPOV[POV_MIN], sizeof(pDIPropCal->lMin) );
    memcpy( pDIPropCal->lMax, myPOV[POV_MAX], sizeof(pDIPropCal->lMax) );
    
    if( FAILED(pdiDevice2->SetProperty(DIPROP_CALIBRATION, &pDIPropCal->diph)) )
    {
#if (defined(_DEBUG) || defined(DEBUG))
        OutputDebugString(TEXT("GCDEF.DLL: SetMyRanges: SetProperty failed to set POV!\n"));
#endif
    }

    if( pDIPropCal ) {
        delete (pDIPropCal);
    }
}


void SetTitle( HWND hDlg )
{
    // Set the title bar!
    LPDIRECTINPUTDEVICE2 pdiDevice2;
    pdiCpl->GetDevice(&pdiDevice2);

    DIPROPSTRING *pDIPropStr = new (DIPROPSTRING);
    ASSERT (pDIPropStr);

    ZeroMemory(pDIPropStr, sizeof(DIPROPSTRING));

    pDIPropStr->diph.dwSize       = sizeof(DIPROPSTRING);
    pDIPropStr->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropStr->diph.dwHow        = DIPH_DEVICE;

    if( SUCCEEDED(pdiDevice2->GetProperty(DIPROP_INSTANCENAME, &pDIPropStr->diph)) )
    {
        TCHAR  tszFormat[STR_LEN_64];
#ifndef _UNICODE
        CHAR   szOut[STR_LEN_128];
#endif

        LPWSTR lpwszTitle = new (WCHAR[STR_LEN_128]);
        ASSERT (lpwszTitle);

        // Shorten length, provide elipse, 
        if( wcslen(pDIPropStr->wsz) > 32 )
        {
            pDIPropStr->wsz[30] = pDIPropStr->wsz[31] = pDIPropStr->wsz[32] = L'.';
            pDIPropStr->wsz[33] = L'\0';
        }

        LoadString(ghInst, IDS_SHEETCAPTION, tszFormat, sizeof(tszFormat)/sizeof(tszFormat[0]));

#ifdef _UNICODE
        wsprintfW(lpwszTitle, tszFormat, pDIPropStr->wsz);
#else
        USES_CONVERSION;

        wsprintfA(szOut, tszFormat, W2A(pDIPropStr->wsz));
        StrCpyW(lpwszTitle, A2W(szOut));
#endif

        //SetWindowText(GetParent(hDlg), 
        ::SendMessage(GetParent(hDlg), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)
#ifdef _UNICODE
                      lpwszTitle);
#else
                      W2A(lpwszTitle));
#endif 

        if( lpwszTitle )
            delete[] (lpwszTitle);
    }
#ifdef _DEBUG
    else OutputDebugString(TEXT("GCDEF.DLL: DICPUTIL.CPP: SetTitle: GetProperty Failed!\n"));
#endif

    if( pDIPropStr )
        delete (pDIPropStr);
}

BOOL Error(HWND hWnd, short nTitleID, short nMsgID)
{
    LPTSTR lptTitle = new TCHAR[STR_LEN_64];
    ASSERT (lptTitle);

    BOOL bRet = FALSE;

    if( LoadString(ghInst, nTitleID, lptTitle, STR_LEN_64) )
    {
        LPTSTR lptMsg = (LPTSTR)_alloca(sizeof(TCHAR[STR_LEN_128]));
        ASSERT (lptMsg);

        if( LoadString(ghInst, nMsgID, lptMsg, STR_LEN_128) )
        {
            MessageBox(hWnd, lptMsg, lptTitle, MB_ICONHAND | MB_OK);
            bRet = TRUE;
        }
    }

    if( lptTitle )
        delete[] (lptTitle);

    return(bRet);
}

void CenterDialog(HWND hWnd)
{
    RECT rc;
    HWND hParentWnd = GetParent(hWnd);

    GetWindowRect(hParentWnd, &rc);

    // Centre the Dialog!
    SetWindowPos(hParentWnd, NULL, 
                 (GetSystemMetrics(SM_CXSCREEN) - (rc.right-rc.left))>>1, 
                 (GetSystemMetrics(SM_CYSCREEN) - (rc.bottom-rc.top))>>1, 
                 NULL, NULL, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);
}


#define SETRANGE( n ) \
      lpMyRanges->jpMin.dw##n##    = pDIPropRange->lMin;		\
      lpMyRanges->jpCenter.dw##n## = pDIPropRange->lCenter;	\
      lpMyRanges->jpMax.dw##n##    = pDIPropRange->lMax;		\

//===========================================================================
// BOOL GetMyRanges( LPMYJOYRANGE lpMyRanges, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis)
//
// Parameters:
//    LPMYJOYRANGE         lpMyRanges - Structure to fill with ranges
//    LPDIRECTINPUTDEVICE2 pdiDevice2 - Device in which axis ranges are requested
//    BYTE                 nAxis      - Bit mask of axis ranges to retrieve
//
// Returns: FALSE if failed
//
//===========================================================================
void GetMyRanges(LPDIRECTINPUTDEVICE2 lpdiDevice2, LPMYJOYRANGE lpMyRanges, BYTE nAxis)
{
    // Use DIPROPCAL to retrieve Range Information
    // Don't use DIPROPRANGE, as it doesn't have Center!
    LPDIPROPCAL pDIPropRange = (LPDIPROPCAL)_alloca(sizeof(DIPROPCAL));
    assert(pDIPropRange);

    pDIPropRange->diph.dwSize       = sizeof(DIPROPCAL);
    pDIPropRange->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropRange->diph.dwHow        = DIPH_BYOFFSET;

    const DWORD dwOffsetArray[] = {DIJOFS_X, DIJOFS_Y, DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};
    BYTE nIndex = 0;

    // Zero out the buffer members and the index!
    pDIPropRange->lMin = pDIPropRange->lCenter = pDIPropRange->lMax = 0;

    // You don't have to start with "while" here because Reset to Default does not call this function!!1
    do
    {
        if( nAxis & HAS_X )
        {
            pDIPropRange->diph.dwObj = dwOffsetArray[nIndex = 0];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &pDIPropRange->diph)) )
            {
                SETRANGE(X);
            }
        } else if( nAxis & HAS_Y )
        {
            pDIPropRange->diph.dwObj = dwOffsetArray[nIndex = 1];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &pDIPropRange->diph)) )
            {
                SETRANGE(Y);
            }
        } else if( nAxis & HAS_Z )
        {
            pDIPropRange->diph.dwObj = dwOffsetArray[nIndex = 2];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &pDIPropRange->diph)) )
            {
                SETRANGE(Z);
            }
        } else if( nAxis & HAS_RX )
        {
            pDIPropRange->diph.dwObj = dwOffsetArray[nIndex = 3];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &pDIPropRange->diph)) )
            {
                SETRANGE(Rx);
            }
        } else if( nAxis & HAS_RY )
        {
            pDIPropRange->diph.dwObj = dwOffsetArray[nIndex = 4];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &pDIPropRange->diph)) )
            {
                SETRANGE(Ry);
            }
        } else if( nAxis & HAS_RZ )
        {
            pDIPropRange->diph.dwObj = dwOffsetArray[nIndex = 5];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &pDIPropRange->diph)) )
            {
                SETRANGE(Rz);
            }
        } else if( nAxis & HAS_SLIDER0 )
        {
            pDIPropRange->diph.dwObj = dwOffsetArray[nIndex = 6];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &pDIPropRange->diph)) )
            {
                SETRANGE(S0);
            }
        } else if( nAxis & HAS_SLIDER1 )
        {
            pDIPropRange->diph.dwObj = dwOffsetArray[nIndex = 7];

            if( SUCCEEDED(lpdiDevice2->GetProperty(DIPROP_CALIBRATION, &pDIPropRange->diph)) )
            {
                SETRANGE(S1); 
            }
        } else {
            break;
        }
    } while( nAxis &= ~HAS_X<<nIndex );
}

void PostDlgItemEnableWindow(HWND hDlg, USHORT nItem, BOOL bEnabled)
{
    HWND hCtrl = GetDlgItem(hDlg, nItem);

    if( hCtrl )
        PostEnableWindow(hCtrl, bEnabled);
}

void PostEnableWindow(HWND hCtrl, BOOL bEnabled)
{
    DWORD dwStyle = GetWindowLong(hCtrl, GWL_STYLE);

    // No point Redrawing the Window if there's no change!
    if( bEnabled )
    {
        if( dwStyle & WS_DISABLED )
            dwStyle &= ~WS_DISABLED;
        else return;
    } else
    {
        if( !(dwStyle & WS_DISABLED) )
            dwStyle |=  WS_DISABLED;
        else return;
    }

    SetWindowLongPtr(hCtrl, GWL_STYLE, (LONG_PTR)dwStyle);

    RedrawWindow(hCtrl, NULL, NULL, RDW_INTERNALPAINT | RDW_INVALIDATE); 
}

void CopyRange( LPJOYRANGE lpjr, LPMYJOYRANGE lpmyjr )
{
    memcpy( &lpjr->jpMin,    &lpmyjr->jpMin, sizeof(JOYPOS) );
    memcpy( &lpjr->jpCenter, &lpmyjr->jpCenter, sizeof(JOYPOS) );
    memcpy( &lpjr->jpMax,    &lpmyjr->jpMax, sizeof(JOYPOS) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\joyhelp.h ===
#define IDH_4101_12293	805638149	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12308	806621189	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12309	806686725	// Joystick Calibration: "f" (Static)
#define IDH_4101_12328	807931909	// Joystick Calibration: "Capture &POV" (Button)
#define IDH_4101_12329	807997445	// Joystick Calibration: "< &Back" (Button)
#define IDH_4101_12330	808062981	// Joystick Calibration: "&Next >" (Button)
#define IDH_4101_12334	808325125	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12347	809177093	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12349	809308165	// Joystick Calibration: "" (ListBox)
#define IDH_4201_1019	66785385	// Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12291	805507177	// Settings: "&Calibrate..." (Button)
#define IDH_4202_8199	537333866	// Game Controller Calibration: "Calibration Information" (Button)
#define IDH_4202_12293	805638250	// Game Controller Calibration: "" (ListBox)
#define IDH_4202_12308	806621290	// Game Controller Calibration: "" (ListBox)
#define IDH_4202_12328	807932010	// Game Controller Calibration: "Set &POV" (Button)
#define IDH_4202_12329	807997546	// Game Controller Calibration: "<&Back" (Button)
#define IDH_4202_12330	808063082	// Game Controller Calibration: "&Next>" (Button)
#define IDH_4202_12334	808325226	// Game Controller Calibration: "" (ListBox)
#define IDH_4203_1023	67047531	// -: "Buttons" (Button)
#define IDH_4203_12293	805638251	// -: "" (ListBox)
#define IDH_4203_12308	806621291	// -: "" (ListBox)
#define IDH_4203_12309	806686827	// -: "" (POVHAT)
#define IDH_4203_12334	808325227	// -: "" (ListBox)
#define IDH_4203_12347	809177195	// -: "" (ListBox)
#define IDH_4203_12349	809308267	// -: "" (ListBox)
#define IDH_4201_12290	805507175	// Settings: "Reset to &default" (Button)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\gradient.cpp ===
//
// GradientProgressCtrl.cpp : implementation file
//

#include "afxcmn.h"
#include "Gradient.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGradientProgressCtrl

CGradientProgressCtrl::CGradientProgressCtrl()
{
	// Defaults assigned by CProgressCtrl()
	m_nLower = 0;
	m_nUpper = 100;
	m_nCurrentPosition = 0;
	m_nStep = 10;	
	
	// Default is vertical, because the only clients are the Test page and
	// the calibration wizard, and hitting the test page is Far more common.
	m_nDirection = VERTICAL;  
	
	// Initial colors
//	m_clrStart	  = COLORREF(RGB(255, 0,0));
//	m_clrEnd	  = COLORREF(RGB(255,128,192));
	m_clrStart	  = COLORREF(RGB(255,0,0));	 
	m_clrEnd 	  = COLORREF(RGB(0,0,255)); 
	m_clrBkGround = GetSysColor(COLOR_WINDOW);
    m_clrText     = COLORREF(RGB(255,255,255));

	// Initial show percent
    m_bShowPercent = FALSE;
}

CGradientProgressCtrl::~CGradientProgressCtrl()
{
}


BEGIN_MESSAGE_MAP(CGradientProgressCtrl, CProgressCtrl)
	//{{AFX_MSG_MAP(CGradientProgressCtrl)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGradientProgressCtrl message handlers

void CGradientProgressCtrl::OnPaint() 
{
	PAINTSTRUCT ps;
	::BeginPaint(this->m_hWnd, &ps);
	
	CDC *pDC=GetDC();
    HDC hDC = pDC->m_hDC;

	if ((m_nLower < 0) || (m_nUpper < 0))
		m_nCurrentPosition -= m_nLower;

	// Figure out what part should be visible so we can stop the gradient when needed
	RECT rectClient;
	::GetClientRect(this->m_hWnd, &rectClient);

	float nTmp = ((float)m_nCurrentPosition/(float)abs(m_nLower - m_nUpper));

	// Draw the gradient
	DrawGradient(hDC, rectClient, (short)(nTmp * ((m_nDirection == VERTICAL) ? rectClient.bottom : rectClient.right)));

	// Show percent indicator if needed
   if (m_bShowPercent)
   {
		TCHAR tszBuff[5];
		wsprintf(tszBuff, TEXT("%d%%"), (short)(100*nTmp));

		::SetTextColor(hDC, m_clrText);
		::SetBkMode(hDC, TRANSPARENT);
		::DrawText(hDC, tszBuff, lstrlen(tszBuff), &rectClient, DT_VCENTER |  DT_CENTER | DT_SINGLELINE);
   }

   	ReleaseDC(pDC);

	::EndPaint(this->m_hWnd, &ps);
	// Do not call CProgressCtrl::OnPaint() for painting messages
}


/*************************************************************************/
// Need to keep track of where the indicator thinks it is.
/*************************************************************************/
void CGradientProgressCtrl:: SetRange(long nLower, long nUpper)
{
	m_nCurrentPosition = m_nLower = nLower;
	m_nUpper = nUpper;
}

/*************************************************************************/
// Where most of the actual work is done.  The general version would fill the entire rectangle with
// a gradient, but we want to truncate the drawing to reflect the actual progress control position.
/*************************************************************************/
void CGradientProgressCtrl::DrawGradient(const HDC hDC, const RECT &rectClient, const short &nMaxWidth)
{
	// First find out the largest color distance between the start and end colors.  This distance
	// will determine how many steps we use to carve up the client region and the size of each
	// gradient rect.

	// Get the color differences
	short r = (GetRValue(m_clrEnd) - GetRValue(m_clrStart));
	short g = (GetGValue(m_clrEnd) - GetGValue(m_clrStart));
	short b = (GetBValue(m_clrEnd) - GetBValue(m_clrStart));


	// Make the number of steps equal to the greatest distance
	short nSteps = max(abs(r), max(abs(g), abs(b)));

	// Determine how large each band should be in order to cover the
	// client with nSteps bands (one for every color intensity level)
	float fStep = ((m_nDirection == VERTICAL) ? (float)rectClient.bottom : (float)rectClient.right) / (float)nSteps;

	// Calculate the step size for each color
	float rStep = r/(float)nSteps;
	float gStep = g/(float)nSteps;
	float bStep = b/(float)nSteps;

	// Reset the colors to the starting position
	r = GetRValue(m_clrStart);
	g = GetGValue(m_clrStart);
	b = GetBValue(m_clrStart);

	RECT rectFill;			   // Rectangle for filling band

	// Start filling bands
	for (short iOnBand = 0; iOnBand < nSteps; iOnBand++) 
	{
		
		if (m_nDirection == VERTICAL)
		{
			// This provides the "velvet" look...
			::SetRect(&rectFill,
					(int)(iOnBand * fStep),       // Upper left X
					 0,									// Upper left Y
					(int)((iOnBand+1) * fStep),   // Lower right X
					rectClient.bottom+1);				// Lower right Y

			/* Use this if we want the gradient to go up/down
			::SetRect(&rectFill,
					 0,									// Upper left Y
					(int)(iOnBand * fStep),       // Upper left X
					rectClient.bottom+1,			// Lower right Y
					(int)((iOnBand+1) * fStep));  // Lower right X
			*/
		}
		else
		{
			// Use this if we want the gradient to go left/right
			::SetRect(&rectFill,
					(int)(iOnBand * fStep),       // Upper left X
					 0,								   // Upper left Y
					(int)((iOnBand+1) * fStep),   // Lower right X
					rectClient.bottom+1);			// Lower right Y
		}

        // Home-brew'd FillSolidRect... Much more effecient!
		::SetBkColor(hDC, RGB(r+rStep*iOnBand, g + gStep*iOnBand, b + bStep *iOnBand));
		::ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rectFill, NULL, 0, NULL);
		
		if (m_nDirection == VERTICAL)
		{
		  	// Grey Rect
			::SetRect(&rectFill, 0, 0, rectClient.right, nMaxWidth);
			::SetBkColor(hDC, m_clrBkGround);
			::ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rectFill, NULL, 0, NULL);
		}
		else
		{
			// If we are past the maximum for the current position we need to get out of the loop.
			// Before we leave, we repaint the remainder of the client area with the background color.
			if (rectFill.right > nMaxWidth)
			{
				::SetRect(&rectFill, rectFill.right, 0, rectClient.right, rectClient.bottom);
				::SetBkColor(hDC, m_clrBkGround);
				::ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rectFill, NULL, 0, NULL);

				return;
			}
		}
	}
}

/*************************************************************************/
// All drawing is done in the OnPaint function
/*************************************************************************/
BOOL CGradientProgressCtrl::OnEraseBkgnd(CDC *pDC) 
{
	// TODO: Add your message handler code here and/or call default
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\gradient.h ===
#if !defined(AFX_ENHPROGRESSCTRL_H__12909D73_C393_11D1_9FAE_8192554015AD__INCLUDED_)
#define AFX_ENHPROGRESSCTRL_H__12909D73_C393_11D1_9FAE_8192554015AD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EnhProgressCtrl.h : header file
//


//
// GradientProgressCtrl.h : header file
//

#define HORIZONTAL	0x10
#define VERTICAL	0x20

/////////////////////////////////////////////////////////////////////////////
// CGradientProgressCtrl window

class CGradientProgressCtrl : public CProgressCtrl
{
// Construction
public:
	CGradientProgressCtrl();

// Attributes
public:
// Attributes
	
	void SetRange(long nLower, long nUpper);
	int StepIt(void);

// Operations
public:
	
	// Set Functions
	void SetBkColor(COLORREF color)		{m_clrBkGround = color;}
	void SetStartColor(COLORREF color)	{m_clrStart = color;}
	void SetEndColor(COLORREF color)	{m_clrEnd = color;}
	void SetDirection(BYTE nDirection)	{m_nDirection = nDirection;}
	void SetPos(long nPos)				{m_nCurrentPosition = nPos;}

	// Show the percent caption
	void ShowPercent(BOOL bShowPercent = TRUE)	{m_bShowPercent = bShowPercent;}
	
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGradientProgressCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGradientProgressCtrl();

	// Generated message map functions
protected:
	void DrawGradient(const HDC hDC, const RECT &rectClient, const short &nMaxWidth);	
    BYTE      m_nStep;
	long      m_nLower, m_nUpper, m_nCurrentPosition;
	BYTE	  m_nDirection;
	COLORREF  m_clrStart, m_clrEnd, m_clrBkGround, m_clrText;
	BOOL      m_bShowPercent; 

	//{{AFX_MSG(CGradientProgressCtrl)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENHPROGRESSCTRL_H__12909D73_C393_11D1_9FAE_8192554015AD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\joyarray.h ===
#include "joyhelp.h"

const DWORD gaHelpIDs[]=
{
   	IDC_TEXT_CALHELP,       (DWORD)-1,
   	IDC_SETTINGSGRP,        (DWORD)-1,
   	IDC_TEXT_AXESHELP,      (DWORD)-1,
   	IDC_AXISGRP,            (DWORD)-1,
   	IDC_GROUP_POV,          (DWORD)-1, 
   	IDC_GROUP_BUTTONS,	   	(DWORD)-1,
   	IDC_RESETCALIBRATION,   IDH_4201_12290,   // Settings: "Reset to &default" (Button)
	IDC_JOYCALIBRATE,	    IDH_4201_12291,	// Settings: "&Calibrate..." (Button)

	IDC_JOYLIST1,	       	IDH_4203_12293,	// -: "" (ListBox)
	IDC_JOYLIST2,	       	IDH_4203_12308,	// -: "" (ListBox)
	IDC_JOYLIST3,	       	IDH_4203_12308,	// -: "" (ListBox)
	IDC_JOYLIST4,	       	IDH_4203_12308,	// -: "" (ListBox)
	IDC_JOYLIST5,	       	IDH_4203_12308,	// -: "" (ListBox)
    IDC_JOYLIST6,          	IDH_4203_12308, 
    IDC_JOYLIST7,          	IDH_4203_12308, 
    IDC_JOYLIST1_LABEL,    	IDH_4203_12293,     
    IDC_JOYLIST2_LABEL,    	IDH_4203_12308,
    IDC_JOYLIST3_LABEL,    	IDH_4203_12308,
    IDC_JOYLIST4_LABEL,    	IDH_4203_12308,     
    IDC_JOYLIST5_LABEL,    	IDH_4203_12308,
    IDC_JOYLIST6_LABEL,    	IDH_4203_12308, 
    IDC_JOYLIST7_LABEL,    	IDH_4203_12308, 
    IDC_JOYPOV,	           	IDH_4203_12309,	// -: "" (POVHAT)
	IDC_TESTJOYBTNICON1,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON2,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON3,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON4,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON5,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON6,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON7,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON8,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON9,   	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON10,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON11,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON12,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON13,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON14,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON15,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON16,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON17,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON18,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON19,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON20,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON21,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON22,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON23,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON24,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON25,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON26,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON27,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON28,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON29,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON30,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON31,  	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON32,  	IDH_4203_1023,	// -: "x" (Static)
	0, 0
};

// Had to split into two arrays because the test and calibrate pages use the same
// IDs for their controls!  -tmc
/*
const DWORD gaHelpIDs_Cal[]=
{
   IDC_JOYLIST1,	IDH_4101_12293,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST2,	IDH_4101_12308,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST3,	IDH_4101_12334,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST4,	IDH_4101_12347,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST5,	IDH_4101_12349,	// Joystick Calibration: "" (ListBox)
	IDC_JOYPOV,	   IDH_4101_12309,	// Joystick Calibration: "f" (Static)
   IDC_JOYPICKPOV,IDH_4101_12328,	// Joystick Calibration: "Capture &POV" (Button)
   IDC_JOYCALBACK,IDH_4101_12329,	// Joystick Calibration: "< &Back" (Button)
   IDC_JOYCALNEXT,IDH_4101_12330,	// Joystick Calibration: "&Next >" (Button)
   IDC_JOYLIST1,	IDH_4202_12293,	// Game Controller Calibration: "" (ListBox)
	IDC_JOYLIST2,	IDH_4202_12308,	// Game Controller Calibration: "" (ListBox)
   IDC_JOYPICKPOV,IDH_4202_12328,	// Joystick Calibration: "Capture &POV" (Button)
   IDC_JOYCALBACK,IDH_4202_12329,	// Joystick Calibration: "< &Back" (Button)
   IDC_JOYCALNEXT,IDH_4202_12330,	// Joystick Calibration: "&Next >" (Button)
	IDC_JOYLIST3,	IDH_4202_12334,	// Game Controller Calibration: "" (ListBox)
	IDC_GROUPBOX,	IDH_4202_8199,	   // Game Controller Calibration: "Calibration Information" (Button)
	0, 0
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\pinfo.h ===
//----------- Packet Info structure -------------
typedef struct _PACKETINFO
{
   DWORD iMode;			      // Interface mode. (see below defs)
   DWORD port;                // game port.
	DWORD Flags;			      // acquistion flags.
	DWORD nPackets;		      // number of packets
	DWORD TimeStamp;		      // last valid acquisition time stamp
	DWORD nClocksSampled;      // number of clocks sampled.
	DWORD nB4Transitions;      // number of B4 line transitions (std mode only).
	DWORD StartTimeout;        // Start timeout period (in samples).
	DWORD HighLowTimeout;      // Clock High to Low timeout period (in samples).
	DWORD LowHighTimeout;      // Clock Low to High timeout period (in samples).
	DWORD InterruptDelay;      // Delay between INTXA interrupts.
	DWORD nFailures;		      // Number of Packet Failures.
	DWORD nAttempts;		      // Number of Packet Attempts.
   DWORD nBufSize;            // size of Raw data buffer.
	DWORD *pData;      	      // pointer to Raw data (DWORD aligned).
} PACKETINFO, *PPACKETINFO;

//--------- Interface MODES ---------------------
#define IMODE_DIGITAL_STD     0        // Standard Digital Mode.
#define IMODE_DIGITAL_ENH     4        // Enhanced Digital Mode.
#define IMODE_ANALOG          8        // Analog Mode.
#define IMODE_NONE            -1       // Joystick Disconnected.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\ff.cpp ===
//===========================================================================
// FF.CPP
//
// Functions:
// ForceFeedback_DlgProc()
//
//===========================================================================
#include "cplsvr1.h"
#include "dicputil.h"

//===========================================================================
// (C) Copyright 1997 Microsoft Corp.  All rights reserved.
//
// You have a royalty-free right to use, modify, reproduce and
// distribute the Sample Files (and/or any modified version) in
// any way you find useful, provided that you agree that
// Microsoft has no warranty obligations or liability for any
// Sample Application Files which are modified.
//===========================================================================

#define ID_SLIDERTIMER	2800
#define TIMER_FREQ		850

//===========================================================================
// ForceFeedback_DlgProc
//
// Parameters:
//  HWND    hWnd    - handle to dialog window
//  UINT    uMsg    - dialog message
//  WPARAM  wParam  - message specific data
//  LPARAM  lParam  - message specific data
//
// Returns: BOOL
//
//===========================================================================
BOOL CALLBACK ForceFeedback_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDIGameCntrlPropSheet_X *pdiCpl; // = (CDIGameCntrlPropSheet_X*)GetWindowLong(hWnd, DWL_USER);

	static LPDIRECTINPUTDEVICE2 pdiDevice2  = NULL;
	static CSliderCtrl CReturnSlider, CForceSlider;

    switch(uMsg)
    {
		// OnInit
        case WM_INITDIALOG:
             {
				// get ptr to our object
				pdiCpl = (CDIGameCntrlPropSheet_X*)((LPPROPSHEETPAGE)lParam)->lParam;

	            // Save our pointer so we can access it later
		        SetWindowLong(hWnd, DWL_USER, (LPARAM)pdiCpl);

			    // initialize DirectInput
				if(FAILED(InitDInput(GetParent(hWnd), pdiCpl)))
	            {
		            OutputDebugString(TEXT("TEST.CPP: WM_INIT: InitDInput FAILED!\n"));
			    }
                
				// Get the device2 interface pointer
				pdiCpl->GetDevice(&pdiDevice2);

				// Setup the Sliders
				HWND hCtrl = GetDlgItem(hWnd, IDC_SLIDER1);
				ASSERT (hCtrl);
				CReturnSlider.Attach(hCtrl);

				hCtrl = GetDlgItem(hWnd, IDC_SLIDER2);
				ASSERT (hCtrl);
				CForceSlider.Attach(hCtrl);


				// BLJ: TODO!!!
				// Setup the granularity of the sliders based on the device!

				// Set up timer to monitor button presses on the device!!!
				// SetTimer(hWnd, ID_SLIDERTIMER, TIMER_FREQ, 0);	
			 }
             break; // end of WM_INITDIALOG

		// OnTimer
		case WM_TIMER:
			
			 break;

		// OnDestroy
		case WM_DESTROY:
			// KillTimer(hWnd, ID_SLIDERTIMER);

			CForceSlider.Detach();
			CReturnSlider.Detach();

		 	// Get the device2 interface pointer
		 	pdiDevice2->Unacquire();
			break;  // end of WM_DESTROY
			

		// OnNotify
        case WM_NOTIFY:
			switch(((NMHDR *)lParam)->code)
			{
				case PSN_SETACTIVE:
					// Do that Acquire thing...
				    if(FAILED(pdiDevice2->Acquire()))
					{
				        OutputDebugString(TEXT("FF.CPP: PSN_SETACTIVE: Acquire() FAILED!\n"));
					}
					break;

				case PSN_KILLACTIVE:
					// Do that Unacquire thing...
				    pdiDevice2->Unacquire();
					break;
			}
            break;  // end of WM_NOTIFY
    }
      
    return FALSE;

} //*** end Test_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\pov.cpp ===
/*~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
**
**    FILE:       POV.CPP
**    DATE:       3/31/97
**    PROJ:       ATLAS
**    PROG:       JKH
**    COMMENTS:   
**
**    DESCRIPTION: Window class for a 360 degree Point Of View control
**                    
**                    
**
**    NOTE:       There are some issues with using extern "C" in this file.
**                If you don't understand why they are there, you're not
**                alone.  For now, and probably for a while they will be
**                here though, because I can't get this file and others
**                that use these services to compile without them.
**                Unfortunately the dynamics of this project don't really
**                afford me the time at present to figure this out.
**                TODO: figure this out
**
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    3/31/97     a-kirkh        Wrote it.
**    
**
**
**
** Copyright (C) Microsoft 1997.  All Rights Reserved.
**
**~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=*/
#include "cplsvr1.h"       // for ghInst
#include "dicputil.h"   // for MAX_POVS
#include "POV.H"           //This module's stuff. 
#include <malloc.h>  // for _alloca

#include "resrc1.h"

//static HWND hPOVWnd = NULL;
#define NUM_ARROW_POINTS    8
//static VERTICEINFO *paptVInfo;  
static const VERTICEINFO VInfo[] = {XARROWPOINT, YARROWPOINT, XARROWRIGHTOUT, YARROWRIGHTOUT, XARROWRIGHTIN, YARROWRIGHTIN,
    XARROWRIGHTBOTTOM, YARROWRIGHTBOTTOM, XARROWLEFTBOTTOM, YARROWLEFTBOTTOM, XARROWLEFTIN,
    YARROWLEFTIN, XARROWLEFTOUT, YARROWLEFTOUT, XARROWPOINT, YARROWPOINT};
static LPRECT prcOldRegionBox[MAX_POVS];
static LPRECT prcNewRegionBox[MAX_POVS];

#define  DEF_POV_POS -1

static double  degrees[MAX_POVS] = {DEF_POV_POS, DEF_POV_POS, DEF_POV_POS, DEF_POV_POS};

static BYTE   nPOV = MAX_POVS;
static HBRUSH hBrush[MAX_POVS];
static HRGN hRegion[MAX_POVS];

extern HINSTANCE ghInst;

void SetDegrees(BYTE nPov, short *nDegrees, HWND hPOVWnd)
{
    nPOV = nPov -= 1;

    LPPOINT paptPoints = (LPPOINT)_alloca(sizeof(POINT[NUM_ARROW_POINTS]));
    assert (paptPoints);

    // Create the proper brush for the axis!
    do {
        degrees[nPov] = (double)nDegrees[nPov] / DI_DEGREES; // if angle == 180, degrees comes in as 18000

        paptPoints[0].x = GETXCOORD(VInfo[0].y, VInfo[0].x, degrees[nPov]);
        paptPoints[0].y = GETYCOORD(VInfo[0].y, VInfo[0].x, degrees[nPov]);                    
        paptPoints[1].x = GETXCOORD(VInfo[1].y, VInfo[1].x, degrees[nPov]);
        paptPoints[1].y = GETYCOORD(VInfo[1].y, VInfo[1].x, degrees[nPov]);
        paptPoints[2].x = GETXCOORD(VInfo[2].y, VInfo[2].x, degrees[nPov]);
        paptPoints[2].y = GETYCOORD(VInfo[2].y, VInfo[2].x, degrees[nPov]);                    
        paptPoints[3].x = GETXCOORD(VInfo[3].y, VInfo[3].x, degrees[nPov]);
        paptPoints[3].y = GETYCOORD(VInfo[3].y, VInfo[3].x, degrees[nPov]);                    
        paptPoints[4].x = GETXCOORD(VInfo[4].y, VInfo[4].x, degrees[nPov]);
        paptPoints[4].y = GETYCOORD(VInfo[4].y, VInfo[4].x, degrees[nPov]);                    
        paptPoints[5].x = GETXCOORD(VInfo[5].y, VInfo[5].x, degrees[nPov]);
        paptPoints[5].y = GETYCOORD(VInfo[5].y, VInfo[5].x, degrees[nPov]);                    
        paptPoints[6].x = GETXCOORD(VInfo[6].y, VInfo[6].x, degrees[nPov]);
        paptPoints[6].y = GETYCOORD(VInfo[6].y, VInfo[6].x, degrees[nPov]);                    
        paptPoints[7].x = GETXCOORD(VInfo[7].y, VInfo[7].x, degrees[nPov]);
        paptPoints[7].y = GETYCOORD(VInfo[7].y, VInfo[7].x, degrees[nPov]);                    

        if(hRegion[nPov])
        {
            DeleteObject(hRegion[nPov]);
            hRegion[nPov]=NULL;
        }
        hRegion[nPov] = CreatePolygonRgn(paptPoints, NUM_ARROW_POINTS, WINDING);

        //hBrush[nPov] = CreateSolidBrush((nPov < 1) ? POV1_COLOUR : 
        //                                (nPov < 2) ? POV2_COLOUR : 
        //                                (nPov < 3) ? POV3_COLOUR : POV4_COLOUR); */

        //if (hRegion[nPov] && hBrush[nPov])
        //{
        //    GetRgnBox(hRegion[nPov], prcNewRegionBox[nPov]);
        //
        //    //RedrawWindow(hPOVWnd, NULL, NULL, RDW_INTERNALPAINT | RDW_INVALIDATE | RDW_ERASE); 
        //    InvalidateRect(hPOVWnd, prcOldRegionBox[nPov], TRUE);
        //    InvalidateRect(hPOVWnd, prcNewRegionBox[nPov], TRUE);
        //}
        RECT R;
        GetClientRect(hPOVWnd,&R);

        POINT Pnt[2];
        Pnt[0].x=R.left;
        Pnt[0].y=R.top;
        Pnt[1].x=R.right;
        Pnt[1].y=R.bottom;
        MapWindowPoints(hPOVWnd,GetParent(hPOVWnd),Pnt,2);
        R.left=Pnt[0].x;
        R.top=Pnt[0].y;
        R.right=Pnt[1].x;
        R.bottom=Pnt[1].y;
        InvalidateRect(GetParent(hPOVWnd), &R, TRUE);
    
    } while( nPov-- );

}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  POVWndProc
//    REMARKS  :  The callback function for the POVHat Window.
//                    
//    PARAMS   :  The usual callback funcs for message handling
//
//    RETURNS  :  LRESULT - Depends on the message
//    CALLS    :  
//    NOTES    :
//                WM_PAINT - Just calls DrawControl
//
//                PM_MYJOYPOSCHANGED - This is a private (WM_USER) message that is
//                called whenever a change in the POV hat occurs.
//                
LRESULT CALLBACK POVWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch( iMsg ) {

//      case WM_CREATE:
//          hPOVWnd = hWnd;
//          return FALSE;

//      case WM_DESTROY:
//         return FALSE;
    
    case WM_DESTROY:
        {
            BYTE nPov=nPOV;
            do
            {
                if(hRegion[nPov])
                {
                    DeleteObject(hRegion[nPov]);
                    hRegion[nPov]=NULL;
                }
            }while(nPov--);
        }
        return 0;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hDC = BeginPaint(hWnd, &ps);

            // 1) Get client size information
            SetMapMode(hDC, MM_TEXT);                              
            RECT rClient;
            GetClientRect(hWnd, &rClient);
            BYTE nSizeX = (BYTE)rClient.right>>1;
            BYTE nSizeY = (BYTE)rClient.bottom>>1;

            // 2) Load the hub bitmap and display it
            //PREFIX #WI226648. False positive. There is no leak. DeleteObject frees.
            HBITMAP hPOVHubBitmap = (HBITMAP)LoadImage(ghInst, MAKEINTRESOURCE(IDB_POVHUB), IMAGE_BITMAP, 0, 0, NULL);
            assert(hPOVHubBitmap);
            DrawBitmap(hDC, hPOVHubBitmap, nSizeX-8, nSizeY-8);
            DeleteObject(hPOVHubBitmap);

            // 3) Setup the window to use symmetrical units on a 1000 X 1000 cartesian grid
            SetMapMode(hDC, MM_ISOTROPIC);
            SetWindowExtEx  (hDC, 1000, 1000, NULL);
            SetViewportExtEx(hDC, nSizeX, -nSizeY, NULL); 
            SetViewportOrgEx(hDC, nSizeX,  nSizeY, NULL);

            // 4) Draw the circle upon which the arrow seems to rotate
            SelectObject(hDC, (HBRUSH)GetStockObject(NULL_BRUSH));

            HPEN hPenOld = (HPEN)SelectObject(hDC, (HGDIOBJ)GetStockObject(DC_PEN)); 
            SetDCPenColor( hDC, GetSysColor(COLOR_WINDOWTEXT) );

            Ellipse(hDC, -CIRCLERADIUS, CIRCLERADIUS, CIRCLERADIUS, -CIRCLERADIUS);
            SelectObject(hDC, hPenOld);

            // 5) Paint the Arrow at the correct angle if POV active
            BYTE nPov = nPOV;
            HBRUSH hBrushOld;

            do {
                if( degrees[nPov] >= 0 ) {
                    hBrush[nPov] = CreateSolidBrush((nPov < 1) ? POV1_COLOUR : 
                                                    (nPov < 2) ? POV2_COLOUR : 
                                                    (nPov < 3) ? POV3_COLOUR : POV4_COLOUR);                

                    hBrushOld = (HBRUSH)SelectObject(hDC, (HGDIOBJ)hBrush[nPov]); 



                    assert(hBrushOld);

                    PaintRgn(hDC, hRegion[nPov]);

                    // GetRgnBox returns zero if it fails...
                    GetRgnBox(hRegion[nPov], prcOldRegionBox[nPov]);
                    SelectObject(hDC, hBrushOld); 

                    if(hRegion[nPov])
                    {
                        DeleteObject(hRegion[nPov]);
                        hRegion[nPov]=NULL;
                    }
                    DeleteObject(hBrush[nPov] ); 
                }
            }   while( nPov-- );

            EndPaint(hWnd, &ps);
        }
        //PREFIX #WI226648. False positive. See above.
        return(0);

    default:
        return(DefWindowProc(hWnd, iMsg,wParam, lParam));
    }
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  RegisterPOVClass
//    REMARKS  :  Registers the POV Hat window.
//                    
//    PARAMS   :  hInstance - Used for the call to RegisterClassEx
//
//    RETURNS  :  TRUE - if successfully registered
//                FALSE - failed to register
//    CALLS    :  RegisterClassEx
//    NOTES    :
//

extern ATOM RegisterPOVClass()
{
    LPWNDCLASSEX pPOVWndClass    = (LPWNDCLASSEX)_alloca(sizeof(WNDCLASSEX));
    assert (pPOVWndClass);

    ZeroMemory(pPOVWndClass, sizeof(WNDCLASSEX));

    pPOVWndClass->cbSize        = sizeof(WNDCLASSEX);
    pPOVWndClass->style         = CS_HREDRAW; // | CS_VREDRAW;
    pPOVWndClass->lpfnWndProc   = POVWndProc;
    pPOVWndClass->hInstance     = ghInst;
    pPOVWndClass->hbrBackground = NULL;
    pPOVWndClass->lpszClassName = TEXT("POVHAT");

    return(RegisterClassEx( pPOVWndClass ));
}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  DrawBitmap
//    REMARKS  :  Copied verbatim from Petzold (WIN95 pg 190)
//    PARAMS   :  HDC - dc for drawing
//                HBITMAP - bitmap to draw
//                int xstart, ystart - where to place the bitmap
//
//    RETURNS  :  void
//    CALLS    :  
//    NOTES    :
//
void DrawBitmap(HDC hDC, HBITMAP hBitmap, BYTE xStart, BYTE yStart)
{
    HDC hdcMem = CreateCompatibleDC(hDC);

    // Found by prefix: Millen Bug129155. manbugs 29339
    // If CreateCompatibleDC fails, we should'nt proceed.
    if( hdcMem == NULL ) return;

    SelectObject(hdcMem, hBitmap);
    SetMapMode(hdcMem,GetMapMode(hDC));

    // Be aware!  This is the size of the current BITMAP...
    // IF IT CHANGES THIS WILL FAIL!!!
    POINT ptSize = {16, 16};
    DPtoLP(hDC, &ptSize, 1);

    POINT ptOrg = {0,0};
    DPtoLP(hdcMem, &ptOrg, 1);

    BitBlt(hDC, xStart, yStart, ptSize.x, ptSize.y, hdcMem, ptOrg.x, ptOrg.y, SRCAND);

    DeleteDC(hdcMem);
}

//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=EOF=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\settings.cpp ===
//===========================================================================
// SETTINGS.CPP
//
// Functions:
//  Settings_DlgProc()
//  DisplayJoystickState()
//
//===========================================================================

// Uncomment if we decide to calibrate the POV!
#define WE_SUPPORT_CALIBRATING_POVS	1

#include <malloc.h>     // for _alloca
#include "cplsvr1.h"
#include "dicputil.h"
#include "resource.h"
#include "assert.h"
#include "cal.h"

// Flag to stop centering of DLG if it's already happend!
// This is needed because of the args that allow any page to be the first!
BOOL bDlgCentered = FALSE;

// This is global because Test.cpp needs it to determine
// if the ranges need to be updated!
BYTE nStatic;

LPMYJOYRANGE lpCurrentRanges = NULL;

extern CDIGameCntrlPropSheet_X *pdiCpl;

//===========================================================================
// Settings_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
// Callback proceedure for Settings Page
//
// Parameters:
//  HWND    hWnd    - handle to dialog window
//  UINT    uMsg    - dialog message
//  WPARAM  wParam  - message specific data
//  LPARAM  lParam  - message specific data
//
// Returns: BOOL
//
//===========================================================================
BOOL CALLBACK Settings_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
//   static LPDIJOYCONFIG_DX5 pDIJoyConfig;

    switch( uMsg ) {
    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

        // OnHelp
    case WM_HELP:
        OnHelp(lParam);
        return(TRUE);

        // OnContextMenu
    case WM_CONTEXTMENU:
        OnContextMenu(wParam);
        return(TRUE);

        // OnDestroy
    case WM_DESTROY:
        bDlgCentered = FALSE;

//          if (pDIJoyConfig)
//              delete (pDIJoyConfig);
        break;

        // OnInitDialog
    case WM_INITDIALOG:
        // get ptr to our object
        if( !pdiCpl )
            pdiCpl = (CDIGameCntrlPropSheet_X*)((LPPROPSHEETPAGE)lParam)->lParam;

        // initialize DirectInput
        if( FAILED(InitDInput(GetParent(hWnd), pdiCpl)) ) {
#ifdef _DEBUG
            OutputDebugString(TEXT("GCDEF.DLL: Settings.cpp: WM_INITDIALOG: InitDInput FAILED!\n"));
#endif
            Error(hWnd, (short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
            PostMessage(GetParent(hWnd), WM_SYSCOMMAND, SC_CLOSE, 0);

            return(FALSE);
        }

        {
            // Enable/Disable the calibrate buttons if the device is present
            LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
            pdiCpl->GetJoyConfig(&pdiJoyConfig);

            // Acquire and check for USER mode!

            // If you're not logged in as a user, you can't use calibrate either!
            if( pdiJoyConfig->Acquire() == DIERR_INSUFFICIENTPRIVS ) {
                const USHORT nIDs[] = { IDC_SETTINGSGRP, 
                    IDC_RESETCALIBRATION,
                    IDC_JOYCALIBRATE,
                    IDC_TEXT_CALHELP};

                BYTE  nSize = sizeof(nIDs)/sizeof(USHORT);

                while( nSize-- )
                    PostDlgItemEnableWindow(hWnd, nIDs[nSize], FALSE);

                pdiCpl->SetUser(TRUE);
            }

            // Center the Dialog!
            // If it's not been centered!
            if( !bDlgCentered ) {
                // Set the title bar!
                SetTitle(hWnd);

                CenterDialog(hWnd);
                bDlgCentered = TRUE;
            }

            // Disable the Calibration button if they don't have any axis!!!
            // Leave the Reset to default...
            if( pdiCpl->GetStateFlags()->nAxis == 0 )
                PostDlgItemEnableWindow(hWnd, IDC_JOYCALIBRATE, FALSE);
        }
        break;

        // OnNotify
    case WM_NOTIFY:
        // perform any WM_NOTIFY processing, but there is none...
        // return TRUE if you handled the notification (and have set
        // the result code in SetWindowLong(hWnd, DWL_MSGRESULT, lResult)
        // if you want to return a nonzero notify result)
        // or FALSE if you want default processing of the notification.
        switch( ((NMHDR*)lParam)->code ) {
        case PSN_APPLY:
            // Kill the memory allocated for the Ranges struct
            Sleep(100);
            if( lpCurrentRanges ) {
                delete (lpCurrentRanges);
                lpCurrentRanges = NULL;
            }
/* We've removed the rudder stuff... but just in case it comes back...
                    if (nStatic & RUDDER_HIT)
                    {
                        LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
                        pdiCpl->GetJoyConfig(&pdiJoyConfig);

                        // get the status of the Rudder checkbox and assign it!
                  // THEN Add the rudder to the Axis mask!
                        if (pDIJoyConfig->hwc.dwUsageSettings & JOY_US_HASRUDDER)
                  {
                            pDIJoyConfig->hwc.dwUsageSettings &= ~JOY_US_HASRUDDER;
                     pdiCpl->GetStateFlags()->nAxis    &= ~HAS_RX;
                  }
                        else
                  {
                            pDIJoyConfig->hwc.dwUsageSettings |= JOY_US_HASRUDDER;
                     pdiCpl->GetStateFlags()->nAxis    |= HAS_RX;
                  }

                        if (FAILED(pdiJoyConfig->Acquire()))
                        {
#ifdef _DEBUG
                            OutputDebugString(TEXT("GCDEF.DLL: Settings.cpp: Settings_DlgProc: PSN_APPLY: Acquire FAILED!\n"));
#endif
                            break;
                        }

                  // Set the GUID to NULL to ask DINPUT to recreate!
                  pDIJoyConfig->guidInstance = NULL_GUID;

                        if (FAILED(pdiJoyConfig->SetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)pDIJoyConfig, DIJC_REGHWCONFIGTYPE)))
                        {
#ifdef _DEBUG
                            OutputDebugString(TEXT("GCDEF.DLL: Settings.cpp: Settings_DlgProc: PSN_APPLY: SetConfig FAILED!\n"));
#endif
                            break;
                        }

                  // Remove the mask from nStatic
                  nStatic &= ~RUDDER_HIT;

                        if (FAILED(pdiJoyConfig->SendNotify()))
                        {
#ifdef _DEBUG
                            OutputDebugString(TEXT("GCDEF.DLL: Settings.cpp: Settings_DlgProc: PSN_APPLY: SendNotify FAILED!\n"));
#endif
                        }
                        pdiJoyConfig->Unacquire();
                    }
*/
            break;

        case PSN_RESET:
            // if the user has changed the calibration... Set it back!
            if( lpCurrentRanges ) {
                LPDIRECTINPUTDEVICE2 pdiDevice2;
                pdiCpl->GetDevice(&pdiDevice2);

                SetMyRanges(pdiDevice2, lpCurrentRanges, pdiCpl->GetStateFlags()->nAxis);

                // Set POV possitions!
                //if (pdiCpl->GetStateFlags()->nPOVs)
                //   SetMyPOVRanges(pdiDevice2, lpCurrentRanges->dwPOV);

                LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
                pdiCpl->GetJoyConfig(&pdiJoyConfig);

                pdiJoyConfig->Acquire();
                pdiJoyConfig->SendNotify();

                delete (lpCurrentRanges);
                lpCurrentRanges = NULL;
            }
            break;

        default:
            break;
        }

        return(FALSE);

        // OnCommand
    case WM_COMMAND:
        switch( LOWORD(wParam) ) {
        /*
       case IDC_JOY1HASRUDDER:
       if (nStatic & RUDDER_HIT)
          nStatic &= ~RUDDER_HIT;
       else
          nStatic |=  RUDDER_HIT;

       // Update the ApplyNow button!
       PostMessage(GetParent(hWnd), (nStatic & RUDDER_HIT) ? PSM_CHANGED : PSM_UNCHANGED, 
          (WPARAM)hWnd, 0);
            break;
        */

        // Set to Default button!!!
        case IDC_RESETCALIBRATION:
            {
                LPMYJOYRANGE lpResetRanges = (LPMYJOYRANGE)_alloca(sizeof(MYJOYRANGE));
                ASSERT (lpResetRanges);

                ZeroMemory(lpResetRanges, sizeof(MYJOYRANGE));

                LPDIRECTINPUTDEVICE2 pdiDevice2;
                pdiCpl->GetDevice(&pdiDevice2);

                SetMyRanges(pdiDevice2, lpResetRanges, pdiCpl->GetStateFlags()->nAxis);

                //if (pdiCpl->GetStateFlags()->nPOVs)
                //   SetMyPOVRanges(pdiDevice2, lpResetRanges->dwPOV);

                LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
                pdiCpl->GetJoyConfig(&pdiJoyConfig);

                pdiJoyConfig->Acquire();
                pdiJoyConfig->SendNotify();
            }
            break;

        case IDC_JOYCALIBRATE:
            nStatic |= CALIBRATING;

            if( !lpCurrentRanges ) {
                lpCurrentRanges = new (MYJOYRANGE);
                assert (lpCurrentRanges);

                ZeroMemory (lpCurrentRanges, sizeof(MYJOYRANGE));

                LPDIRECTINPUTDEVICE2 pdiDevice2;
                pdiCpl->GetDevice(&pdiDevice2);

                // Get Current Ranges!
                GetMyRanges(pdiDevice2, lpCurrentRanges, pdiCpl->GetStateFlags()->nAxis);
            }

            if( CreateWizard(hWnd, (LPARAM)pdiCpl) ) {

                // Set the flags
                nStatic |= CAL_HIT;

                HWND hSheet = GetParent(hWnd);

                // take care of the Apply Now Button...
                ::SendMessage(hSheet, PSM_CHANGED, (WPARAM)hWnd, 0L);

                // Bug #179010 NT - Move to Test sheet after calibration!
                ::PostMessage(hSheet, PSM_SETCURSELID, 0, (LPARAM)IDD_TEST);
            } else {
                // if you canceled and it's your first time Kill the struct...
                // then Reset the flag
                if( !(nStatic & CAL_HIT) ) {
                    // Kill the memory allocated for the Ranges struct
                    if( lpCurrentRanges ) {
                        delete (lpCurrentRanges);
                        lpCurrentRanges = NULL;
                    }
                }
            }

            nStatic &= ~CALIBRATING;
            break;
        }
    }

    return(FALSE);

} //*** end Settings_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cplsvr1.rc
//
#define IDS_SHEETCAPTION                1
#define IDS_ERROR                       2
#define IDS_NOFORCEFEEDBACK             3
#define IDS_ACQUIRED                    4
#define IDS_UNACQUIRED                  5
#define IDS_DEFAULT                     6

#define IDD_INITIAL                     10
#define IDD_XY							11
#define IDD_SLIDER                      12
#define IDD_POV                         13
//#define IDC_POVLABEL					14

#define IDI_WINFLAG                     105
#define IDI_CONFIG                      108
#define IDC_STOP                        1001
#define IDC_XDATA                       1002
#define IDC_YDATA                       1003
#define IDC_ZDATA                       1004
#define IDC_RXDATA                      1005
#define IDC_RYDATA                      1006
#define IDC_RZDATA                      1007
#define IDC_S0DATA                      1008
#define IDC_S1DATA                      1009
#define IDC_POV0DATA                    1010
#define IDC_POV1DATA                    1011
#define IDC_POV2DATA                    1012
#define IDC_POV3DATA                    1013
#define IDC_BUTTONSDOWN                 1014
#define IDC_EFFECTLIST                  1018
#define IDC_NUMAXES                     1019
#define IDC_NUMBUTTONS                  1020
#define IDC_NUMPOVS                     1021
#define IDC_AXISLIST                    1022
#define IDC_BUTTONLIST                  1023
#define IDC_POVLIST                     1024
#define IDC_DISPNAME                    1025
#define IDC_TYPENAME                    1026
#define IDC_CLSID                       1027
#define IDC_CALLOUT                     1028
#define IDC_DEVSTATUS                   1029


// blj: Calibration ID's 
#define IDD_CALIBRATE                   1032
#define IDD_CALIBRATE1                  1033
#define IDC_CALIBRATE                   1034
#define IDC_GROUPBOX					       1035

#define IDC_JOYLIST1					       1036
#define IDC_JOYLIST1_LABEL			   	 	   1037

// THESE ID's MUST REMAIN UNDESTURBED!
#define IDC_JOYLIST2					       1038
#define IDC_JOYLIST3					       IDC_JOYLIST2+1
#define IDC_JOYLIST4					       IDC_JOYLIST2+2
#define IDC_JOYLIST5					       IDC_JOYLIST2+3
#define IDC_JOYLIST6                    	   IDC_JOYLIST2+4
#define IDC_JOYLIST7                    	   IDC_JOYLIST2+5

//******************************************************
#define IDC_JOYLIST2_LABEL				       1071
#define IDC_JOYLIST3_LABEL				       IDC_JOYLIST2_LABEL+1
#define IDC_JOYLIST4_LABEL				       IDC_JOYLIST2_LABEL+2
#define IDC_JOYLIST5_LABEL			       	   IDC_JOYLIST2_LABEL+3
#define IDC_JOYLIST6_LABEL				       IDC_JOYLIST2_LABEL+4
#define IDC_JOYLIST7_LABEL			       	   IDC_JOYLIST2_LABEL+5

#define IDC_JOYPOV_LABEL				       IDC_JOYLIST2_LABEL+7

// ID's related to items on the IDD_CALIBRATE page
#define IDC_JOYPICKPOV                  1101
#define IDC_JOYCALBACK                  1102
#define IDC_JOYCALNEXT                  1103
#define IDC_JOYCALDONE                  1104
#define IDC_JOYCALMSG                   1105
#define IDC_JOYPOV                      1106

// IDS's related to items on the IDD_CALIBRATE page
#define IDS_JOYCALCAPN					1200
#define IDS_JOYCALBACK					1201
#define IDS_JOYCALNEXT					1202
#define IDS_JOYCALDONE					1203

#define IDS_JOYCALXY_CENTERYOKE         1205
#define IDS_JOYCALXY_CENTERCAR          1206
#define IDS_JOYCALXY_CENTERGAMEPAD      1207
#define IDS_JOYCALXY_CENTER             1208
#define IDS_JOYCALXY_MOVEYOKE           1209
#define IDS_JOYCALXY_MOVECAR            1210
#define IDS_JOYCALXY_MOVEGAMEPAD        1211
#define IDS_JOYCALXY_MOVE               1212
#define IDS_JOYCALXY_CENTERYOKE2        1213
#define IDS_JOYCALXY_CENTERCAR2         1214
#define IDS_JOYCALXY_CENTERGAMEPAD2     1215
#define IDS_JOYCALXY_CENTER2            1216

#ifdef DEADZONE
// String defines!
#define IDS_DEADZONE_TITLE				2000
#define IDS_JOYSTICK_DEADZONE			2001
#define IDS_GAMEPAD_DEADZONE			2002
#define IDS_CAR_DEADZONE				2003
#define IDS_YOKE_DEADZONE				2004

// Spin Control defines!
#define IDC_X_DEADZONE_SPIN				2005
#define IDC_Y_DEADZONE_SPIN				2006
#define IDC_X_SATURATION_SPIN			2007
#define IDC_Y_SATURATION_SPIN			2008

// Edit Controls associated with the
// Spin controls above!
#define IDC_X_DEADZONE					2010
#define IDC_Y_DEADZONE					2011
#define	IDC_X_SATURATION				2015
#define	IDC_Y_SATURATION				2016

// Static text field defines!
#define IDC_DEADZONE_TITLE				2009
#define IDC_SATURATION_TITLE			2014
#define IDC_X_AXIS_LABEL_DEADZONE		2012
#define IDC_Y_AXIS_LABEL_DEADZONE		2013
#define IDC_X_AXIS_LABEL_SATURATION		2017
#define	IDC_Y_AXIS_LABEL_SATURATION		2018
#endif // DEADZONE
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1030
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\baseids.h ===
#define IDBASE				5000
#define INCREMENT			10

#define IDS_GENERAL_TAB		IDBASE + INCREMENT
#define IDS_DEVICE_DESC		IDS_GENERAL_TAB		+ INCREMENT
#define IDS_ASSIGN			IDS_DEVICE_DESC		+ INCREMENT
#define IDS_PROPERTIES		IDS_ASSIGN          + INCREMENT
#define IDS_TEST			IDS_PROPERTIES      + INCREMENT
#define IDS_OK				IDS_TEST            + INCREMENT
#define IDS_CANCEL			IDS_OK              + INCREMENT
#define IDS_APPLY			IDS_CANCEL          + INCREMENT
#define IDS_TEST_TAB		IDS_APPLY           + INCREMENT
#define IDS_MULTIPAD_DESC	IDS_TEST_TAB        + INCREMENT
#define IDS_SINGPAD_DESC	IDS_MULTIPAD_DESC   + INCREMENT
#define IDS_TEST_DESC		IDS_SINGPAD_DESC    + INCREMENT
#define IDS_POSITION_LBL	IDS_TEST_DESC       + INCREMENT
#define IDS_JOYTEST_DESC	IDS_POSITION_LBL    + INCREMENT
#define IDS_JOYSTICK_LBL	IDS_JOYTEST_DESC    + INCREMENT
#define IDS_THROTTLE_LBL	IDS_JOYSTICK_LBL    + INCREMENT
#define IDS_RUDDER_LBL		IDS_THROTTLE_LBL    + INCREMENT
#define IDS_POVHAT_LBL		IDS_RUDDER_LBL      + INCREMENT
#define IDS_BUTTONS_LBL		IDS_POVHAT_LBL		+ INCREMENT
#define IDS_JOYTESTBUTT_DESC	IDS_BUTTONS_LBL	+ INCREMENT
#define IDS_BUTTON1_LBL		IDS_JOYTESTBUTT_DESC+ INCREMENT
#define IDS_BUTTON2_LBL		IDS_BUTTON1_LBL		+ INCREMENT
#define IDS_BUTTON3_LBL		IDS_BUTTON2_LBL		+ INCREMENT
#define IDS_BUTTON4_LBL		IDS_BUTTON3_LBL		+ INCREMENT
#define IDS_BUTTON5_LBL		IDS_BUTTON4_LBL		+ INCREMENT
#define IDS_BUTTON6_LBL		IDS_BUTTON5_LBL		+ INCREMENT
#define IDS_BUTTON7_LBL		IDS_BUTTON6_LBL		+ INCREMENT
#define IDS_BUTTON8_LBL		IDS_BUTTON7_LBL		+ INCREMENT
#define IDS_PROP_TBAR		IDS_BUTTON8_LBL		+ INCREMENT
#define IDS_PROP_TAB		IDS_PROP_TBAR       + INCREMENT
#define IDS_RUDDERS_DESC	IDS_PROP_TAB        + INCREMENT
#define IDS_PADPROP_TBAR	IDS_RUDDERS_DESC    + INCREMENT
#define IDS_RUDDER_CBOX		IDS_PADPROP_TBAR    + INCREMENT
#define IDS_LEGPROP_TBAR	IDS_RUDDER_CBOX     + INCREMENT
#define IDS_CALIBRATE		IDS_LEGPROP_TBAR    + INCREMENT
#define IDS_ASSIGN_TBAR		IDS_CALIBRATE       + INCREMENT
#define IDS_DEVSEL_COBOX	IDS_ASSIGN_TBAR     + INCREMENT
#define IDS_ASSIGN_COBOX	IDS_DEVSEL_COBOX    + INCREMENT
#define IDS_CHANGEID_DESC	IDS_ASSIGN_COBOX    + INCREMENT
#define ID_MAINCP_TBAR		IDS_CHANGEID_DESC   + INCREMENT
#define IDS_CALIBRATE_DESC	ID_MAINCP_TBAR      + INCREMENT
#define IDS_SETTING_PRODUCT_NAME	IDS_CALIBRATE_DESC  + INCREMENT
#define IDS_VERSION			IDS_SETTING_PRODUCT_NAME	+ INCREMENT
#define IDS_COPYRIGHT		IDS_VERSION         + INCREMENT
#define IDS_PID				IDS_COPYRIGHT       + INCREMENT
#define IDS_NUM_DEVICES		IDS_PID             + INCREMENT
#define IDS_DIAGNOSTICS		IDS_NUM_DEVICES     + INCREMENT
#define IDS_TEST_GAMEPAD1	IDS_DIAGNOSTICS     + INCREMENT
#define IDS_TEST_GAMEPAD2	IDS_TEST_GAMEPAD1   + INCREMENT
#define IDS_TEST_GAMEPAD3	IDS_TEST_GAMEPAD2   + INCREMENT
#define IDS_TEST_GAMEPAD4	IDS_TEST_GAMEPAD3   + INCREMENT
#define IDS_ERROR          IDS_TEST_GAMEPAD4   + INCREMENT

#define IDBASE2 5700

#define	IDS_LVHEADING_DEVICE	  IDBASE2
#define	IDS_LVHEADING_STATUS	  IDS_LVHEADING_DEVICE      + INCREMENT
#define	IDS_LVHEADING_ASSIGN	  IDS_LVHEADING_STATUS     	+ INCREMENT
#define	IDS_STATUS_OK			  IDS_LVHEADING_ASSIGN     	+ INCREMENT
#define	IDS_STATUS_NOTCONNECTED	  IDS_STATUS_OK            	+ INCREMENT
#define	IDS_STATUS_ERROR		  IDS_STATUS_NOTCONNECTED  	+ INCREMENT
#define IDS_CPANEL_TITLE		  IDS_STATUS_ERROR			+ INCREMENT
								   						
#define IDLEGACYBASE 6000

#define IDS_JOYINFO             		IDLEGACYBASE
#define IDS_JOY                 		IDS_JOYINFO             	  + INCREMENT
#define IDS_JOY2                		IDS_JOY                 	  + INCREMENT
#define IDS_JOY2S               		IDS_JOY2                	  + INCREMENT
#define IDS_JOYCALXY_CENTER     		IDS_JOY2S               	  + INCREMENT
#define IDS_JOYCALXY_MOVE       		IDS_JOYCALXY_CENTER     	  + INCREMENT
#define IDS_JOYCALZ_MOVE        		IDS_JOYCALXY_MOVE       	  + INCREMENT
#define IDS_JOYCALPOV_MOVE      		IDS_JOYCALZ_MOVE        	  + INCREMENT
#define IDS_JOYCAL_UP           		IDS_JOYCALPOV_MOVE      	  + INCREMENT
#define IDS_JOYCAL_DOWN         		IDS_JOYCAL_UP           	  + INCREMENT
#define IDS_JOYCAL_LEFT         		IDS_JOYCAL_DOWN         	  + INCREMENT
#define IDS_JOYCAL_RIGHT        		IDS_JOYCAL_LEFT         	  + INCREMENT
#define IDS_JOYTESTCAPN         		IDS_JOYCAL_RIGHT        	  + INCREMENT
#define IDS_JOYBUTTON1          		IDS_JOYTESTCAPN         	  + INCREMENT
#define IDS_JOYBUTTON2          		IDS_JOYBUTTON1          	  + INCREMENT
#define IDS_JOYCALCAPN          		IDS_JOYBUTTON2          	  + INCREMENT
#define IDS_JOYUNPLUGGED        		IDS_JOYCALCAPN          	  + INCREMENT
#define IDS_JOYCALXY_MOVEYOKE   		IDS_JOYUNPLUGGED        	  + INCREMENT
#define IDS_JOYCAL_DONE         		IDS_JOYCALXY_MOVEYOKE   	  + INCREMENT
#define IDS_JOYCALXY_MOVEGAMEPAD		IDS_JOYCAL_DONE         	  + INCREMENT
#define IDS_JOYCALXY_CENTERGAMEPAD 		IDS_JOYCALXY_MOVEGAMEPAD	  + INCREMENT
#define IDS_JOYCALXY_CENTERYOKE 		IDS_JOYCALXY_CENTERGAMEPAD 	  + INCREMENT
#define IDS_JOYREADERROR        		IDS_JOYCALXY_CENTERYOKE 	  + INCREMENT
#define IDS_JOYCALRUDDER_MOVE   		IDS_JOYREADERROR        	  + INCREMENT
#define IDS_JOYCALXY_MOVECAR    		IDS_JOYCALRUDDER_MOVE   	  + INCREMENT
#define IDS_JOYCALXY_CENTERCAR  		IDS_JOYCALXY_MOVECAR    	  + INCREMENT
#define IDS_JOYCALXY_CENTER2    		IDS_JOYCALXY_CENTERCAR  	  + INCREMENT
#define IDS_JOYCAL_YOKE         		IDS_JOYCALXY_CENTER2    	  + INCREMENT
#define IDS_JOYCAL_CAR          		IDS_JOYCAL_YOKE         	  + INCREMENT
#define IDS_JOYCAL_GAMEPAD      		IDS_JOYCAL_CAR          	  + INCREMENT
#define IDS_JOYNOTPRESENT       		IDS_JOYCAL_GAMEPAD      	  + INCREMENT
#define IDS_JOYCAL_NOTDONE      		IDS_JOYNOTPRESENT       	  + INCREMENT
#define IDS_JOYCALU_MOVE        		IDS_JOYCAL_NOTDONE      	  + INCREMENT
#define IDS_JOYCALV_MOVE        		IDS_JOYCALU_MOVE        	  + INCREMENT
#define IDS_JOYRESTARTMSG1      		IDS_JOYCALV_MOVE        	  + INCREMENT
#define IDS_JOYRESTARTMSG2      		IDS_JOYRESTARTMSG1      	  + INCREMENT
#define IDS_JOYCALXY_CENTERGAMEPAD2		IDS_JOYRESTARTMSG2     		  + INCREMENT
#define IDS_JOYCALXY_CENTERYOKE2		IDS_JOYCALXY_CENTERGAMEPAD2	  + INCREMENT
#define IDS_JOYCALXY_CENTERCAR2 		IDS_JOYCALXY_CENTERYOKE2	  + INCREMENT
#define IDS_JOYCAL_YOKES        		IDS_JOYCALXY_CENTERCAR2 	  + INCREMENT
#define IDS_JOYCAL_CARS					IDS_JOYCAL_YOKES			  + INCREMENT
#define IDS_JOYCAL_GAMEPADS     		IDS_JOYCAL_CARS	        	  + INCREMENT
#define IDS_JOYCALINDICATOR     		IDS_JOYCAL_GAMEPADS     	  + INCREMENT
#define IDS_VAXIS_LABEL         		IDS_JOYCALINDICATOR     	  + INCREMENT
#define IDS_UAXIS_LABEL         		IDS_VAXIS_LABEL         	  + INCREMENT
#define IDS_POVAXIS_LABEL       		IDS_UAXIS_LABEL         	  + INCREMENT
#define IDS_ZAXIS_LABEL         		IDS_POVAXIS_LABEL       	  + INCREMENT
#define IDS_XYAXIS_LABEL        		IDS_ZAXIS_LABEL         	  + INCREMENT
#define IDS_RAXIS_LABEL         		IDS_XYAXIS_LABEL        	  + INCREMENT
#define	IDS_JOYPICKPOV					IDS_RAXIS_LABEL  			  + INCREMENT
#define	IDS_JOYCALBACK					IDS_JOYPICKPOV				  + INCREMENT
#define IDS_JOYCALNEXT					IDS_JOYCALBACK				  + INCREMENT
#define IDS_JOYCALDONE					IDS_JOYCALNEXT				  + INCREMENT
#define IDS_JOYCALGROUP					IDS_JOYCALDONE				  + INCREMENT
										
#define	IDS_JOYHWLAST					IDS_JOYCALGROUP				  + INCREMENT

#define IDLEGACYDESCBASE	7000

#define IDS_JOYHW0              		IDLEGACYDESCBASE
#define IDS_JOYHW1              		IDS_JOYHW0              	  + INCREMENT
#define IDS_JOYHW2              		IDS_JOYHW1              	  + INCREMENT
#define IDS_JOYHW3              		IDS_JOYHW2              	  + INCREMENT
#define IDS_JOYHW4              		IDS_JOYHW3              	  + INCREMENT
#define IDS_JOYHW5              		IDS_JOYHW4              	  + INCREMENT
#define IDS_JOYHW6              		IDS_JOYHW5              	  + INCREMENT
#define IDS_JOYHW7              		IDS_JOYHW6              	  + INCREMENT
#define IDS_JOYHW8              		IDS_JOYHW7              	  + INCREMENT
#define IDS_JOYHW9              		IDS_JOYHW8              	  + INCREMENT
#define IDS_JOYHW10             		IDS_JOYHW9              	  + INCREMENT
#define IDS_JOYHW11             		IDS_JOYHW10             	  + INCREMENT

#define IDS_NONE                	  IDS_JOYHW0
#define IDS_CUSTOM              	  IDS_JOYHW1
#define IDS_2A_2B_GENERIC       	  IDS_JOYHW2
#define IDS_2A_4B_GENERIC       	  IDS_JOYHW3
#define IDS_2B_GAMEPAD          	  IDS_JOYHW4
#define IDS_2B_FLIGHTYOKE       	  IDS_JOYHW5
#define IDS_2B_FLIGHTYOKETHROTTLE	  IDS_JOYHW6
#define IDS_3A_2B_GENERIC       	  IDS_JOYHW7
#define IDS_3A_4B_GENERIC       	  IDS_JOYHW8
#define IDS_4B_GAMEPAD          	  IDS_JOYHW9
#define IDS_4B_FLIGHTYOKE       	  IDS_JOYHW10
#define IDS_4B_FLIGHTYOKETHROTTLE 	  IDS_JOYHW11

#define IDCUSTOMBASE 8000

#define IDS_CUSTOM_TBAR				  IDCUSTOMBASE				+ INCREMENT
#define	IDS_CUSTOM_AXES				  IDS_CUSTOM_TBAR			+ INCREMENT
#define	IDS_CUSTOM_2AXES			  IDS_CUSTOM_AXES		    + INCREMENT
#define	IDS_CUSTOM_3AXES			  IDS_CUSTOM_2AXES	     	+ INCREMENT
#define	IDS_CUSTOM_4AXES			  IDS_CUSTOM_3AXES	     	+ INCREMENT
#define	IDS_CUSTOM_BUTTON			  IDS_CUSTOM_4AXES	     	+ INCREMENT
#define	IDS_CUSTOM_2BUTTONS			  IDS_CUSTOM_BUTTON	     	+ INCREMENT
#define	IDS_CUSTOM_4BUTTONS			  IDS_CUSTOM_2BUTTONS	    + INCREMENT
#define	IDS_CUSTOM_SPECIAL			  IDS_CUSTOM_4BUTTONS	    + INCREMENT
#define	IDS_CUSTOM_ISFLIGHTYOKE		  IDS_CUSTOM_SPECIAL	    + INCREMENT
#define	IDS_CUSTOM_ISRACECAR		  IDS_CUSTOM_ISFLIGHTYOKE	+ INCREMENT
#define	IDS_CUSTOM_ISGAMEPAD		  IDS_CUSTOM_ISRACECAR	 	+ INCREMENT
#define	IDS_CUSTOM_HASPOV			  IDS_CUSTOM_ISGAMEPAD	 	+ INCREMENT

#define IDS_HELPFILENAME			  850

#define IDS_GENERALERRMSG  10000
#define IDS_DATABASERRMSG  (IDS_GENERALERRMSG + INCREMENT)
#define IDS_FILERRMSG  (IDS_DATABASERRMSG + INCREMENT)
#define IDS_GAMEDEVERRMSG  (IDS_FILERRMSG + INCREMENT)
#define IDS_SYSERRMSG  (IDS_GAMEDEVERRMSG + INCREMENT)
#define IDS_REGERRMSG  (IDS_SYSERRMSG + INCREMENT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\pov.h ===
#ifndef __POV_H
#define __POV_H
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**
**    FILE:       POV.H
**    DATE:       3/31/97
**    PROJ:       ATLAS
**    PROG:       JKH
**    COMMENTS:   
**
**    DESCRIPTION:Header file for the POV control class
**				      
**				      
**
**    NOTE:       
**
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    3/31/97     a-kirkh        Wrote it.
**    
**
** Copyright (C) Microsoft 1997.  All Rights Reserved.
**
**~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~INCLUDES=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
//    
//
#include <windows.h>
#include <math.h>
#include <assert.h>

#include "resource.h"

//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~STRUCTS~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
//    
//
typedef struct tag_VerticeInfo
{
   /*
   int   x;
   long  y;
   */
   short x;
   short y;
}VERTICEINFO, *PVERTICEINFO;



//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~DEFINES~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
// ARROWVERTICES DESCRIPTIONS
//                                /\  ------------- X/YARROWPOINT
//                              /    \
//                            /__    __\ ---------- X/YARROWRIGHT/LEFTOUT
//     X/YARROWBOTTOM  \         |  |\
//                       \_______|__|  \----------- X/YARROWRIGHT/LEFTIN 
//

#define        NUMARROWVERTICES           8									// IN ARROW BITMAP
#define        PIPI                       6.283185307179586476925286766559  // 2 * PI
#define        PM_MYJOYPOSCHANGED         WM_USER + 1000					// PRIVATE MESSAGE
#define        CIRCLECOLOR                RGB(96, 96, 96)

//VERTICES COORDINATES
//X
#define        XARROWPOINT                0     //USE TWICE, AT START AND AT END
#define        XARROWRIGHTOUT             150
#define        XARROWRIGHTIN              75
#define        XARROWRIGHTBOTTOM          75
#define        XARROWLEFTBOTTOM           -75
#define        XARROWLEFTIN               -75
#define        XARROWLEFTOUT              -150

//VERTICES COORDINATES
//Y
#define        YARROWPOINT                1000
#define        YARROWRIGHTOUT             850
#define        YARROWRIGHTIN              850
#define        YARROWRIGHTBOTTOM          750
#define        YARROWLEFTBOTTOM           750
#define        YARROWLEFTIN               850
#define        YARROWLEFTOUT              850

#define        CIRCLERADIUS               YARROWRIGHTOUT

#define 	   POV1_COLOUR	RGB(255,0,0)
#define 	   POV2_COLOUR	RGB(0,0,255)
#define 	   POV3_COLOUR	RGB(0,0,0)
#define 	   POV4_COLOUR	RGB(0,255,0)



//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~MACROS=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
// The sin function takes radians so use the conversion:
//
// DEGTORAD: DEGREES / 360 == RADIANS / 2PI -> DEGREES * 2PI == RADIANS    
//
// To rotate and translate a coordinate use the functions:
// 
// GETXCOORD: X' = Y * sin(angle) + X * cos(angle)
// where angle is in radians and
//
// GETYCOORD: Y' = Y * cos(angle) - X * sin(angle)
// where angle is in radians.
//

#define DEGTORAD(d) (double)((PIPI * (d))/360)

#define GETXCOORD(y, x, theta) (int)((((y) * sin((double)(DEGTORAD(theta))))) + (((x) * cos((double)(DEGTORAD(theta))))))
#define GETYCOORD(y, x, theta) (int)((((y) * cos((double)(DEGTORAD(theta))))) - (((x) * sin((double)(DEGTORAD(theta))))))

void SetDegrees(BYTE nPov, short *dDegrees, HWND hPOVWnd);
/*
void DrawROPLine(HDC hDC, POINT ptStart, 
                 POINT ptEnd, COLORREF rgb = RGB(0, 0, 0), 
                 int iWidth = 1, int iStyle = PS_SOLID, int iROPCode = R2_COPYPEN);

void     DrawControl(HDC hDC, LPRECT prcClient);
*/
void     GetCurrentArrowRegion(HRGN* hRegion, BYTE nPov);
extern   ATOM RegisterPOVClass();
LRESULT  CALLBACK POVWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
void     DrawBitmap(HDC hDC, HBITMAP hBitmap, BYTE xStart, BYTE yStart);
#endif
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=EOF=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

USE_NTDLL=1
WIN32_WINNT_VERSION=0x500
!ENDIF

MAJORCOMP=shell
MINORCOMP=accesory
USE_PDB=1

TARGETNAME=GCDEF
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=DllMain
DLLBASE=0x71000000

LINKER_STACKSIZE=-STACK:4096,1024

! IF defined( DIRECTX_REDIST )
WIN32_WINNT_VERSION=0x0500
! ENDIF

!IFDEF TARGET_WIN95
CHICAGO_PRODUCT=1
USE_MAPSYM = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DWIN95 -D_X86_ 
USE_MFC=1
!ELSE
C_DEFINES=$(C_DEFINES) -DWINNT -D_UNICODE 
LINKER_FLAGS=$(LINKER_FLAGS) -WS:AGGRESSIVE -HEAP:0x30D40,0x2000
USE_MFCUNICODE=1
!ENDIF

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\uuid.lib     \
           $(SDK_LIB_PATH)\dinput.lib   \
           $(SDK_LIB_PATH)\user32.lib   \
           $(SDK_LIB_PATH)\gdi32.lib    \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SDK_LIB_PATH)\shlwapi.lib


INCLUDES=$(INCLUDES);                   \
     ..;                                \
     ..\..\default;                     \
     $(DXROOT)\inc;                     \
 

DLLENTRY=DllMain
DLLDEF=..\GCDEF.DEF

SOURCES=\
        ..\button.cpp    \
        ..\CAL.cpp       \
        ..\CPLSVR1.cpp   \
        ..\CPLSVR1.rc    \
        ..\DICPUTIL.cpp  \
        ..\GRADIENT.CPP  \
        ..\POV.cpp       \
        ..\SETTINGS.CPP  \
        ..\TEST.cpp     
#		..\ff.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CPLSVR1.RC
//
#define IDI_JOYBTN                      101
#define IDI_GCICON                      108
#define IDD_FORCEFEEDBACK               111
#define IDB_CAL                         115
#define IDB_POVHUB                      127
#define IDB_CALSTART                    128
#define IDB_CALHD                       129
#define IDS_HELPFILENAME                850
#define IDC_GROUP_RUDDER                1018
#define IDC_TEXT_RUDDERHELP             1019
#define IDC_TEXT_AXESHELP               1021
#define IDC_GROUP_BUTTONS               1023
#define IDC_SLIDER1                     1032
#define IDC_MAGNITUDE_SLIDER            1032
#define IDC_SLIDER2                     1033
#define IDC_COEFFICIENT_SLIDER          1033
#define IDC_FF_RETURN                   1034
#define IDC_GAIN_SLIDER                 1034
#define IDC_FF_RETURN2                  1035
#define IDC_FF_RETURN3                  1036
#define IDC_FF_FEEDBACK                 1037
#define IDC_FF_FEEDBACK2                1038
#define IDC_FF_FEEDBACK3                1039
#define IDC_FF_DESC                     1040
#define IDC_FF_CENTREGRP                1041
#define IDC_FF_FFGRP                    1042
#define IDC_PROGRESS1                   1044
#define IDC_TEXT_CALHELP                1045
#define IDC_HEADERFRAME                 1045
#define IDC_SETTINGSGRP                 1046
#define IDC_RAWDATA                     1046
#define IDC_AXISGRP                     1047
#define IDC_RAWX                        1047
#define IDC_RAWY                        1048
#define IDC_RAWXOUTPUT                  1049
#define IDC_RAWYOUTPUT                  1050
#define IDC_WHITEFILL                   1051
#define IDC_INIT_TITLE                  1052
#define IDC_INIT_SUBTITLE               1055
#define IDC_JOYLIST2_SPIN               1056
#define IDC_JOYLIST3_SPIN               1057
#define IDC_JOYLIST2_SPIN3              1058
#define IDC_                            1059
#define IDC_X_DEADZONE                  1060
#define IDC_X_DEADZONE_SPIN             1061
#define IDC_X_DEADZONE2                 1062
#define IDC_X_DEADZONE_SPIN2            1063
#define IDC_JOYLIST5_SPIN               1064
#define IDC_X_AXIS_LABEL                1064
#define IDC_JOYLIST6_SPIN               1065
#define IDC_SATURATION_TITLE            1065
#define IDC_JOYLIST7_SPIN               1066
#define IDC_X_SATURATION                1066
#define IDC_X_SATURATION_SPIN           1067
#define IDC_X_AXIS_LABEL1               1068
#define IDC_X_DEADZONE3                 1069
#define IDC_X_DEADZONE_SPIN3            1070
#define IDC_Y_AXIS_LABEL1               1071
#define IDC_Y_AXIS_LABEL                1072
#define IDC_MAGNITUDE_GRP               1073
#define IDC_COEFFICIENT_GRP             1074
#define IDC_SETPOV                      1075
#define IDD_SETTINGS                    4201
#define IDD_TEST                        4203
#define IDS_GENERAL_TAB_1               5010
#define IDS_DEVICE_DESC_1               5020
#define IDS_DEVICE_DESC_2               5021
#define IDS_ASSIGN_1                    5030
#define IDS_PROPERTIES_1                5040
#define IDS_TEST_1                      5050
#define IDS_OK_1                        5060
#define IDS_CANCEL_1                    5070
#define IDS_APPLY_1                     5080
#define IDS_POSITION_LBL_1              5130
#define IDS_JOYSTICK_LBL_1              5150
#define IDS_THROTTLE_LBL_1              5160
#define IDS_RUDDER_LBL_1                5170
#define IDS_POVHAT_LBL_1                5180
#define IDS_BUTTONS_LBL_1               5190
#define IDS_PROP_TAB_1                  5300
#define IDS_RUDDERS_DESC_1              5310
#define IDS_RUDDERS_DESC_2              5311
#define IDS_LEGPROP_TBAR_1              5340
#define IDS_ASSIGN_TBAR_1               5360
#define IDS_DEVSEL_COBOX_1              5370
#define IDS_ASSIGN_COBOX_1              5380
#define ID_MAINCP_TBAR_1                5400
#define IDS_CALIBRATE_DESC_1            5410
#define IDS_SETTING_PRODUCT_NAME_1      5420
#define IDS_SETTING_PRODUCT_NAME_2      5421
#define IDS_SETTING_PRODUCT_NAME_3      5422
#define IDS_VERSION_1                   5430
#define IDS_COPYRIGHT_1                 5440
#define IDS_COPYRIGHT_2                 5441
#define IDS_PID_1                       5450
#define IDS_NUM_DEVICES_1               5460
#define IDS_DIAGNOSTICS_1               5470
#define IDS_ERROR_1                     5520
#define IDS_LVHEADING_DEVICE_1          5700
#define IDS_LVHEADING_STATUS_1          5710
#define IDS_LVHEADING_ASSIGN_1          5720
#define IDS_STATUS_OK_1                 5730
#define IDS_STATUS_NOTCONNECTED_1       5740
#define IDS_CPANEL_TITLE                5760
#define IDS_JOYINFO_1                   6000
#define IDS_JOY_1                       6010
#define IDS_JOY2_1                      6020
#define IDS_JOY2S_1                     6030
#define IDS_JOYCALXY_CENTER_1           6040
#define IDS_JOYCALXY_MOVE_1             6050
#define IDS_JOYCALZ_MOVE_1              6060
#define IDS_JOYCALPOV_MOVE_1            6070
#define IDS_JOYCAL_UP_1                 6080
#define IDS_JOYCAL_DOWN_1               6090
#define IDS_JOYCAL_LEFT_1               6100
#define IDS_JOYCAL_RIGHT_1              6110
#define IDS_JOYTESTCAPN_1               6120
#define IDS_JOYBUTTON1_1                6130
#define IDS_JOYBUTTON2_1                6140
#define IDS_JOYCALCAPN_1                6150
#define IDS_JOYUNPLUGGED_1              6160
#define IDS_JOYCALXY_MOVEYOKE_1         6170
#define IDS_JOYCAL_DONE_1               6180
#define IDS_JOYCALXY_MOVEGAMEPAD_1      6190
#define IDS_JOYCALXY_CENTERGAMEPAD_1    6200
#define IDS_JOYCALXY_CENTERYOKE_1       6210
#define IDS_JOYREADERROR_1              6220
#define IDS_JOYCALRUDDER_MOVE_1         6230
#define IDS_JOYCALXY_MOVECAR_1          6240
#define IDS_JOYCALXY_CENTERCAR_1        6250
#define IDS_JOYCALXY_CENTER2_1          6260
#define IDS_JOYCAL_YOKE_1               6270
#define IDS_JOYCAL_CAR_1                6280
#define IDS_JOYCAL_GAMEPAD_1            6290
#define IDS_JOYNOTPRESENT_1             6300
#define IDS_JOYCAL_NOTDONE_1            6310
#define IDS_JOYCALU_MOVE_1              6320
#define IDS_JOYCALV_MOVE_1              6330
#define IDS_JOYRESTARTMSG1_1            6340
#define IDS_JOYRESTARTMSG1_2            6341
#define IDS_JOYRESTARTMSG2_1            6350
#define IDS_JOYCALXY_CENTERGAMEPAD2_1   6360
#define IDS_JOYCALXY_CENTERYOKE2_1      6370
#define IDS_JOYCALXY_CENTERCAR2_1       6380
#define IDS_JOYCAL_YOKES_1              6390
#define IDS_JOYCAL_CARS_1               6400
#define IDS_JOYCAL_GAMEPADS_1           6410
#define IDS_JOYCALINDICATOR_1           6420
#define IDS_VAXIS_LABEL_1               6430
#define IDS_UAXIS_LABEL_1               6440
#define IDS_POVAXIS_LABEL_1             6450
#define IDS_ZAXIS_LABEL_1               6460
#define IDS_XYAXIS_LABEL_1              6470
#define IDS_RAXIS_LABEL_1               6480
#define IDS_JOYPICKPOV_1                6490
#define IDS_JOYCALBACK_1                6500
#define IDS_JOYCALNEXT_1                6510
#define IDS_JOYCALDONE_1                6520
#define IDS_JOYCALGROUP_1               6530
#define IDS_JOYCALS_MOVE                6531
#define IDS_JOYHW0_1                    7000
#define IDC_TESTJOYBTNICON1             7001
#define IDC_TESTJOYBTNICON2             7002
#define IDC_TESTJOYBTNICON3             7003
#define IDC_TESTJOYBTNICON4             7004
#define IDC_TESTJOYBTNICON5             7005
#define IDC_TESTJOYBTNICON6             7006
#define IDC_TESTJOYBTNICON7             7007
#define IDC_TESTJOYBTNICON8             7008
#define IDC_TESTJOYBTNICON9             7009
#define IDC_TESTJOYBTNICON10            7010
#define IDS_JOYHW1_1                    7010
#define IDC_TESTJOYBTNICON11            7011
#define IDC_TESTJOYBTNICON12            7012
#define IDC_TESTJOYBTNICON13            7013
#define IDC_TESTJOYBTNICON14            7014
#define IDC_TESTJOYBTNICON15            7015
#define IDC_TESTJOYBTNICON16            7016
#define IDC_TESTJOYBTNICON17            7017
#define IDC_TESTJOYBTNICON18            7018
#define IDC_TESTJOYBTNICON19            7019
#define IDC_TESTJOYBTNICON20            7020
#define IDC_TESTJOYBTNICON21            7021
#define IDC_TESTJOYBTNICON22            7022
#define IDC_TESTJOYBTNICON23            7023
#define IDC_TESTJOYBTNICON24            7024
#define IDC_TESTJOYBTNICON25            7025
#define IDC_TESTJOYBTNICON26            7026
#define IDC_TESTJOYBTNICON27            7027
#define IDC_TESTJOYBTNICON28            7028
#define IDC_TESTJOYBTNICON29            7029
#define IDC_TESTJOYBTNICON30            7030
#define IDC_TESTJOYBTNICON31            7031
#define IDC_TESTJOYBTNICON32            7032
#define IDS_CUSTOM_TBAR_1               8010
#define IDS_CUSTOM_AXES_1               8020
#define IDS_CUSTOM_SPECIAL_1            8090
#define IDS_SHEET_CAPTION               9000
#define IDS_PAGE_TITLE1                 9001
#define IDS_PAGE_TITLE2                 9002
#define IDI_BUTTONOFF                   9998
#define IDI_BUTTONON                    9999
#define IDS_TEXT_AXESHELP               10051
#define IDS_JOYREADERROR                10052
#define IDS_JOYUNPLUGGED                10053
#define IDS_JOYCAL_MOVE                 10054
#define IDS_JOYCALRUDDER_MOVE           10055
#define IDS_JOYCALU_MOVE                10056
#define IDS_JOYCALV_MOVE                10057
#define IDS_JOYCALPOV_MOVE              10058
#define IDS_JOYCAL_UP                   10059
#define IDS_JOYCAL_RIGHT                10060
#define IDS_JOYCAL_DOWN                 10061
#define IDS_JOYCAL_LEFT                 10062
#define IDS_JOYCAL_DONE                 10063
#define IDS_JOYCAL_NOTDONE              10064
#define IDS_JOYCAL_YOKES                10065
#define IDS_JOYCAL_YOKE                 10066
#define IDS_JOYCAL_CARS                 10067
#define IDS_JOYCAL_CAR                  10068
#define IDS_JOYCAL_GAMEPADS             10069
#define IDS_JOYCAL_GAMEPAD              10070
#define IDS_JOY2S                       10071
#define IDS_JOY2                        10072
#define IDC_JOYCALIBRATE                12291
#define IDC_JOY1HASRUDDER               12333
#define IDC_GROUP_POV                   12349
#define IDC_RESETCALIBRATION            12350
#define IDS_INTERNAL_ERROR              12351
#define IDS_NO_DIJOYCONFIG              12352
#define IDS_RENAME                      12353
#define IDC_RENAME                      12354
#define IDC_WIZARD_MSG                  12357
#define IDS_CALIBRATION                 12358
#define IDC_WIZARD_MSG_HDR              12358
#define IDS_INITIAL_CAL_TITLE           12359
#define IDS_SLIDER_CAL_TITLE            12360
#define IDS_POV_CAL_TITLE               12361
#define IDC_BLACKBAR                    12362
#define IDC_JOYLIST1_PROGRESS           12363
#define IDC_JOYLIST2_PROGRESS           12364
#define IDC_SLIDER                      12365
#define IDC_HEADERBITMAP                12366
#define IDS_RETRY                       12366
#define IDS_CENTER_HDR                  12367
#define IDS_VERIFY_CENTER_HDR           12368
#define IDS_AXIS_CALIBRATION            12369
#define IDS_CALIBRATION_FINI            12370
#define IDS_USER_MODE_TITLE             12371
#define IDS_USER_MODE                   12372
#define IDS_POV_CALIBRATION				12373
#define IDC_BITMAP                      -1
#define IDC_DEADZONE_TITLE              -1
#define IDC_GAIN_GRP                    -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1076
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\comstr.h ===
// the great escape ( and may the devil have mercy on our souls ! )
// 666 and whatever the modulus of that by 3.14159 is ...
// Thank You.
extern CString * pszCommonString;


BOOL SetDialogItemText( HWND hdlg, UINT nctrl, UINT nstr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\default\test.cpp ===
//===========================================================================
// TEST.CPP
//
// Functions:
//    Test_DlgProc()
//    DoJoyMove()
//    DoTestButtons()
//    DoTestPOV()
//    DrawCross()
//    DisplayAvailableButtons()
//    JoyError()
//    DisplayAvailablePOVs()
//    SetOEMWindowText()
//
//===========================================================================

// This is necessary for UnregisterDeviceNotification!
#if (WINVER < 0x0500)
    #undef WINVER
    #define WINVER 0x0500
#endif

#include "cplsvr1.h"
#include <initguid.h>
#include <winuser.h>  // For RegisterDeviceNotification stuff!
#include <dbt.h>      // for DBT_ defines!!!
#include <hidclass.h>

#include "dicputil.h"
#include "resource.h"
#include "pov.h"
#include "assert.h"
#include <regstr.h>  // for REGSTR_VAL_'s below
#include <commctrl.h> // for CProgressCtrl!
#include <shlwapi.h>  // for Str... functions!
#include <malloc.h>   // _alloca

#include "Gradient.h" // for Gradient Fill Slider!

#ifndef LONG2POINT
    #define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))
#endif // LONG2POINT

// local functions for services exclusive to this module!
static void DisplayAvailablePOVs    ( const HWND hWndToolTip, const HWND hDlg, BYTE nPOVs );
static void DisplayAvailableButtons( const HWND hWndToolTip, const HWND hDlg, const int nNumButtons );
static void DisplayAvailableAxisTest(const HWND hWndToolTip, const HWND hDlg, BYTE nAxisFlags, LPDIRECTINPUTDEVICE2 pdiDevice2);
static void DoTestButtons           ( const HWND hDlg, PBYTE pbButtons, int nButtons );
static short JoyError            ( const HWND hDlg );
static BOOL SetDeviceRanges     ( const HWND hDlg, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis );
static DWORD DecodeAxisPOV( DWORD dwVal );

// Local defines
#define DELTA              5
#define ID_JOY_TIMER       2002
#define TIMER_INTERVAL     45      // time between polls in milliseconds
#define MAX_SLIDER_POS     100
#define MIN_SLIDER_POS     0
#define FORCE_POV_REFRESH  254


#define ACTIVE_COLOR       RGB(255,0,0)
#define INACTIVE_COLOR     RGB(128,0,0)

extern BOOL bDlgCentered;
extern BYTE nStatic;
extern CDIGameCntrlPropSheet_X *pdiCpl;
extern HINSTANCE ghInst;

BOOL bGradient;

static HWND ProgWnd[NUM_WNDS];
static CGradientProgressCtrl *pProgs[NUM_WNDS];
static HPEN hTextPen;
static HPEN hWinPen;

LPDIJOYSTATE lpDIJoyState;

extern HICON hIconArray[2];

//===========================================================================
// Test_DlgProc
//
// Parameters:
//  HWND    hWnd    - handle to dialog window
//  UINT    uMsg    - dialog message
//  WPARAM  wParam  - message specific data
//  LPARAM  lParam  - message specific data
//
// Returns: BOOL
//
//===========================================================================
BOOL CALLBACK Test_DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPDIRECTINPUTDEVICE2 pdiDevice2;
    static PVOID hNotifyDevNode;     
    static HWND hWndToolTip;
    static BYTE nAxis;

    switch( uMsg ) {
/*
#ifdef _UNICODE
       case WM_DEVICECHANGE:  
        if ((UINT)wParam == DBT_DEVICEREMOVECOMPLETE)
        {
                if (nStatic & CALIBRATING)
                    break;

                pdiDevice2->Unacquire();

                if (FAILED(pdiDevice2->Acquire()))
                {
                    KillTimer(hWnd, ID_JOY_TIMER);

                    Error(hWnd, (short)IDS_JOYREADERROR, (short)IDS_JOYUNPLUGGED);

// if you call this function you will hang up the system for 30 seconds or more!!!
               if (hNotifyDevNode)
                    UnregisterDeviceNotification(hNotifyDevNode);
                    ::PostMessage(GetParent(hWnd), WM_COMMAND, IDOK, 0);
                }
        }
        break;
#endif
*/
    case WM_ACTIVATEAPP:
        if( wParam ) {
            pdiDevice2->Acquire();

            // Hack for bug #228798
            if( lpDIJoyState ) {
                // This is to refresh the cross hair...
                lpDIJoyState->lX+=1;
                DoJoyMove( hWnd, nAxis );

                // This is to refresh the POV
                if( pdiCpl->GetStateFlags()->nPOVs )
                    DoTestPOV(FORCE_POV_REFRESH, lpDIJoyState->rgdwPOV, hWnd);
            }

            SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);
        } else {
            KillTimer(hWnd, ID_JOY_TIMER);
            pdiDevice2->Unacquire();
        }
        break;

    case WM_LBUTTONDOWN:
        // Click Drag service for PropSheets!
        PostMessage(GetParent(hWnd), WM_NCLBUTTONDOWN, (WPARAM)HTCAPTION, lParam);
        break;

        // OnHelp
    case WM_HELP:
        KillTimer(hWnd, ID_JOY_TIMER);
        OnHelp(lParam);
        SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);
        return(TRUE);

        // OnContextMenu
    case WM_CONTEXTMENU:
        KillTimer(hWnd, ID_JOY_TIMER);
        OnContextMenu(wParam);
        SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);
        return(TRUE);

        // OnInit
    case WM_INITDIALOG:
        // get ptr to our object
        if( !pdiCpl )
            pdiCpl = (CDIGameCntrlPropSheet_X*)((LPPROPSHEETPAGE)lParam)->lParam;

        hTextPen = hWinPen = NULL;

        // Establish if you have enough colours to display the gradient fill scroll bar!
        {
            HDC hDC = ::GetWindowDC(hWnd);
            if( hDC ) { // Prefix Whistler Bug#45099
                bGradient = (BOOL)(GetDeviceCaps(hDC, NUMCOLORS) < 0);
                ::ReleaseDC(hWnd, hDC);
            }
        }

        // load the up and down states!
        hIconArray[0] = (HICON)LoadImage(ghInst, (PTSTR)IDI_BUTTONON,  IMAGE_ICON, 0, 0, NULL);
        assert (hIconArray[0]);

        hIconArray[1] = (HICON)LoadImage(ghInst, (PTSTR)IDI_BUTTONOFF, IMAGE_ICON, 0, 0, NULL);
        assert (hIconArray[1]);

        // initialize DirectInput
        if( FAILED(InitDInput(GetParent(hWnd), pdiCpl)) ) {
            Error(hWnd, (short)IDS_INTERNAL_ERROR, (short)IDS_NO_DIJOYCONFIG);
            // Fix #108983 NT, Remove Flash on Error condition.
            SetWindowPos(::GetParent(hWnd), HWND_BOTTOM, 0, 0, 0, 0, SWP_HIDEWINDOW);
            PostMessage(GetParent(hWnd), WM_SYSCOMMAND, SC_CLOSE, 0);

            return(FALSE);
        }

        // Get the device2 interface pointer
        pdiCpl->GetDevice(&pdiDevice2);

        nAxis = pdiCpl->GetStateFlags()->nAxis;

        // Set The scale for the Device Range!!!
        SetDeviceRanges(hWnd, pdiDevice2, nAxis);

        LPDIRECTINPUTJOYCONFIG pdiJoyConfig;
        pdiCpl->GetJoyConfig(&pdiJoyConfig);

        // Create the Pens for X/Y axis!
        CreatePens();

        // Create ToolTip window!
        hWndToolTip = CreateWindowEx( 0, TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_ALWAYSTIP, 
                                      CW_USEDEFAULT, CW_USEDEFAULT, 10, 10, hWnd, NULL, ghInst, NULL);

        // Show the available Axis!
        DisplayAvailableAxisTest(hWndToolTip, hWnd, nAxis, pdiDevice2);

        DisplayAvailableButtons(hWndToolTip, hWnd, pdiCpl->GetStateFlags()->nButtons);

        DisplayAvailablePOVs(hWndToolTip, hWnd, pdiCpl->GetStateFlags()->nPOVs);

        lpDIJoyState = new (DIJOYSTATE);
        assert(lpDIJoyState);

        ZeroMemory(lpDIJoyState, sizeof(DIJOYSTATE));

        // Clear the Static vars in DoJoyMove!
        DoJoyMove(hWnd, nAxis);

        // Center the Dialog!
        // If it's not been centered!
        if( !bDlgCentered ) {
            SetTitle(hWnd);
            CenterDialog(hWnd);
            bDlgCentered = TRUE;
        }

        {
            // Get the Type name
            LPDIJOYCONFIG_DX5 lpDIJoyConfig = (LPDIJOYCONFIG_DX5)_alloca(sizeof(DIJOYCONFIG_DX5));
            ASSERT (lpDIJoyConfig);

            ZeroMemory(lpDIJoyConfig, sizeof(DIJOYCONFIG_DX5));

            lpDIJoyConfig->dwSize = sizeof(DIJOYCONFIG_DX5);

            if( SUCCEEDED(pdiJoyConfig->GetConfig(pdiCpl->GetID(), (LPDIJOYCONFIG)lpDIJoyConfig, DIJC_REGHWCONFIGTYPE)) ) {
                if( lpDIJoyConfig->hwc.dwUsageSettings & JOY_US_ISOEM ) {
                    LPCTSTR pszLabels[] = { 
                        REGSTR_VAL_JOYOEMTESTMOVEDESC,
                        REGSTR_VAL_JOYOEMTESTMOVECAP,
                        REGSTR_VAL_JOYOEMTESTBUTTONCAP,
                        REGSTR_VAL_JOYOEMPOVLABEL,
                        REGSTR_VAL_JOYOEMTESTWINCAP};

                    const short nControlIDs[] = {
                        IDC_TEXT_AXESHELP,
                        IDC_AXISGRP,
                        IDC_GROUP_BUTTONS,
                        IDC_GROUP_POV,
                        0};

                    SetOEMWindowText(hWnd, nControlIDs, pszLabels, lpDIJoyConfig->wszType, pdiJoyConfig, (BYTE)(sizeof(nControlIDs)/sizeof(short))-1);
                }
                
                bPolledPOV = (lpDIJoyConfig->hwc.hws.dwFlags & JOY_HWS_HASPOV) && (lpDIJoyConfig->hwc.hws.dwFlags & JOY_HWS_POVISPOLL);
                CalibratePolledPOV( &lpDIJoyConfig->hwc );
            }

#ifdef _UNICODE     
            // Set up the Device Notification
            // Removed per Om...
            //RegisterForDevChange(hWnd, &hNotifyDevNode);
#endif
        }
        break; // end of WM_INITDIALOG

        // OnTimer
    case WM_TIMER:
        if( SUCCEEDED(DIUtilPollJoystick(pdiDevice2,  lpDIJoyState)) ) {
            if( nAxis )
                DoJoyMove( hWnd, nAxis );

            if( pdiCpl->GetStateFlags()->nButtons )
                DoTestButtons( hWnd, lpDIJoyState->rgbButtons, pdiCpl->GetStateFlags()->nButtons );

            if( pdiCpl->GetStateFlags()->nPOVs )
                DoTestPOV( pdiCpl->GetStateFlags()->nPOVs, lpDIJoyState->rgdwPOV, hWnd );
        } else {
            KillTimer(hWnd, ID_JOY_TIMER);
            pdiDevice2->Unacquire();
            if( JoyError( hWnd ) == IDRETRY ) {
                pdiDevice2->Acquire();
                SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);
            } else {
                // Send a message back to the CPL to update list, as it may have changed!
                ::PostMessage(GetParent(hWnd), WM_COMMAND, IDOK, 0);
            }
        }
        break;  // end of WM_TIMER

        // All this has to be done because WM_MOUSEMOVE doesn't get sent to static text!
    case WM_MOUSEMOVE:
        if( hWndToolTip ) {
            POINT pt;
            LONG2POINT(lParam, pt);
            HWND hChildWnd = ::ChildWindowFromPoint(hWnd, pt);
            static HWND hPrev;

            if( hChildWnd != hPrev && hChildWnd !=NULL ) {
                switch( GetDlgCtrlID(hChildWnd) ) {
                case IDC_JOYLIST1_LABEL:
                case IDC_JOYLIST2_LABEL:
                case IDC_JOYLIST3_LABEL:
                case IDC_JOYLIST4_LABEL:
                case IDC_JOYLIST5_LABEL:
                case IDC_JOYLIST6_LABEL:
                case IDC_JOYLIST7_LABEL:
                    if( IsWindowVisible(hChildWnd) ) {
                        MSG   msg;

                        //we need to fill out a message structure and pass it to the tooltip 
                        //with the TTM_RELAYEVENT message
                        msg.hwnd    = hWnd;
                        msg.message = uMsg;
                        msg.wParam  = wParam;
                        msg.lParam  = lParam;
                        msg.time    = GetMessageTime();
                        GetCursorPos(&msg.pt);

                        ::SendMessage(hWndToolTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);
                    }
                    break;

                    // We don't need to trap for anything else, as the rest are TTF_SUBCLASS'd
                default:
                    break;
                }

                // store the last one so we don't have to do this again...
                hPrev = hChildWnd;
            }
        }
        break;

        // OnDestroy
    case WM_DESTROY:
        bDlgCentered = FALSE;

        KillTimer(hWnd, ID_JOY_TIMER);

        // Delete the button icons...
        DestroyIcon(hIconArray[0]);
        DestroyIcon(hIconArray[1]);
        
        // Kill pProgs
        if( bGradient ) {
            BYTE nAxisCounter = MAX_AXIS - 2;

            BYTE nTmpFlags = nAxis;

            // Clear the X and Y flags... they don't have progress controls
            // associated with them!
            nTmpFlags &= ~(HAS_X | HAS_Y);

            while( nTmpFlags ) {
                if( nTmpFlags & (HAS_Z<<nAxisCounter) ) {
                    delete (pProgs[nAxisCounter]);
                    pProgs[nAxisCounter] = 0;
                    nTmpFlags &= ~(HAS_Z<<nAxisCounter);
                }
                nAxisCounter--;
            }
        }

        // Destroy the pens!
        if (hTextPen)
            DeleteObject(hTextPen);

        if( hWinPen )
            DeleteObject(hWinPen);

        if( lpDIJoyState ) {
            delete (lpDIJoyState);
            lpDIJoyState = NULL;
        }

        // Make sure you set this to NULL!
        pdiDevice2 = NULL;

        break;  // end of WM_DESTROY

        // OnNotify
    case WM_NOTIFY:
        switch( ((NMHDR*)lParam)->code ) {
        case PSN_SETACTIVE:
            if( pdiDevice2 ) {
                pdiDevice2->Acquire();

                // if you have this, you are safe to start the timer!
                if( lpDIJoyState )
                    SetTimer( hWnd, ID_JOY_TIMER, TIMER_INTERVAL, NULL);

                lpDIJoyState->lX+=1;
                DoJoyMove(hWnd, HAS_X | HAS_Y);
            }
            break;

        case PSN_KILLACTIVE:
            KillTimer(hWnd, ID_JOY_TIMER);
            pdiDevice2->Unacquire();
            break;
        }

        break;  // end of WM_NOTIFY

    case WM_SYSCOLORCHANGE:
        {
            //Destroy old pens.
            if (hTextPen)
            {
                DeleteObject(hTextPen);
                hTextPen=NULL;
            }

            if(hWinPen)
            {
                DeleteObject(hWinPen);
                hWinPen=NULL;
            }
            //Recreate pens with new colors.
            CreatePens();

            //Change colors of slider bars.
            for(int i=0;i<NUM_WNDS;i++)
            {
                if(pProgs[i]) {
                    pProgs[i]->SetBkColor(GetSysColor(COLOR_WINDOW));
                }
            }
        }
        break;

    }
    return(FALSE);
} //*** end Test_DlgProc()


//===========================================================================
// DoJoyMove( HWND hDlg, LPDIJOYSTATE pDIJoyState, int nDrawFlags )
//
// Reports to hDlg state information from pDIJoyState, dwDrawFlags, and pJoyRange;
//
// Parameters:
//  HWND                    hDlg                -       Handle to Dialog
//  LPDIJOYSTATE        pDIJoyState     -       State information about the device
//  LPJOYRANGE          pJoyRange
//
// Returns:             nichts
//
//===========================================================================
void DoJoyMove( const HWND hDlg, BYTE nDrawFlags )
{
    if( !::IsWindow(hDlg) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("DoJoyMove: hDlg: Not a valid window!\n"));
#endif
        return;
    }

    if( nDrawFlags == 0 ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("DoJoyMove: nDrawFlags is Zero!\n"));
#endif
        return;
    }

    // draw the cross in the XY box if needed
    if( (nDrawFlags & HAS_X) || (nDrawFlags & HAS_Y) ) {
        static POINTS ptOld = {DELTA,DELTA};

        HWND hCtrl = GetDlgItem( hDlg, IDC_JOYLIST1 );
        assert(hCtrl);

        //RedrawWindow(hCtrl, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

        RECT rc;
        GetClientRect(hCtrl, &rc);

        // The Real Max is rc.bottom-DELTA!
        rc.bottom -= DELTA;

        // Check for ranges - Y Axis
        if( lpDIJoyState->lY > rc.bottom ) {
#ifdef   _DEBUG
            OutputDebugString(TEXT("GCDEF: DoJoyMove: retrieved Y pos > Max Y pos!\n"));
#endif   
            lpDIJoyState->lY = rc.bottom;
        } else if( lpDIJoyState->lY < DELTA ) {
#ifdef   _DEBUG
            OutputDebugString(TEXT("GCDEF: DoJoyMove: retrieved Y pos < Min Y pos!\n"));
#endif   
            lpDIJoyState->lY = DELTA;
        }

        // Check for ranges - X Axis
        if( lpDIJoyState->lX > rc.right ) {
#ifdef   _DEBUG
            OutputDebugString(TEXT("GCDEF: DoJoyMove: retrieved X pos > Max X pos!\n"));
#endif   
            lpDIJoyState->lX = rc.right;
        } else if( lpDIJoyState->lX < DELTA ) {
#ifdef   _DEBUG
            OutputDebugString(TEXT("GCDEF: DoJoyMove: retrieved X pos < Min X pos!\n"));
#endif   
            lpDIJoyState->lX = DELTA;
        }

        // out with the old...
        if( (ptOld.x != (short)lpDIJoyState->lX) || (ptOld.y != (short)lpDIJoyState->lY) ) {
            // Sorry... no drawing outside of your RECT!
            if( (ptOld.x > (rc.right-DELTA)) || (ptOld.y > rc.bottom) ) {
                ptOld.x = ptOld.y = DELTA;
                return;
            }

            DrawCross(hCtrl, &ptOld, COLOR_WINDOW );

            ptOld.x = (short)lpDIJoyState->lX;
            ptOld.y = (short)lpDIJoyState->lY;

            // in with the new...
            DrawCross( hCtrl, &ptOld, COLOR_WINDOWTEXT );
        }

        nDrawFlags &= ~(HAS_X | HAS_Y);
    }

    // draw Z bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_Z ) {
            static BYTE nOldZ; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->lZ != nOldZ ) {
                if( bGradient )
                    pProgs[Z_INDEX]->SetPos(lpDIJoyState->lZ);

                ::PostMessage(ProgWnd[Z_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->lZ - MAX_SLIDER_POS), 0L);

                nOldZ = (BYTE)lpDIJoyState->lZ;
            }
            nDrawFlags &= ~HAS_Z;
        }
    } else return;

    // draw Slider0 bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_SLIDER0 ) {
            // Any value > 100, as that's the largest one we'll ever recieve!
            static BYTE nOldS0; //  = MAX_SLIDER_POS+1;

            if( lpDIJoyState->rglSlider[0] != nOldS0 ) {
                nOldS0 = (BYTE)lpDIJoyState->rglSlider[0];

                if( bGradient )
                    pProgs[S0_INDEX]->SetPos(lpDIJoyState->rglSlider[0]);

                ::PostMessage(ProgWnd[S0_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->rglSlider[0]-MAX_SLIDER_POS), 0L);
            }
            nDrawFlags &= ~HAS_SLIDER0;
        }
    } else return;

    // draw Rx bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_RX ) {
            static BYTE nOldRx; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->lRx != nOldRx ) {
                nOldRx = (BYTE)lpDIJoyState->lRx;

                if( bGradient )
                    pProgs[RX_INDEX]->SetPos(lpDIJoyState->lRx);

                ::PostMessage(ProgWnd[RX_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->lRx - MAX_SLIDER_POS), 0L);
            }
            nDrawFlags &= ~HAS_RX;
        }
    } else return;

    // draw Ry bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_RY ) {
            static BYTE nOldRy; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->lRy != nOldRy ) {
                nOldRy = (BYTE)lpDIJoyState->lRy;

                if( bGradient )
                    pProgs[RY_INDEX]->SetPos(lpDIJoyState->lRy);

                ::PostMessage(ProgWnd[RY_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->lRy - MAX_SLIDER_POS), 0L);
            }
            nDrawFlags &= ~HAS_RY;
        }
    } else return;

    // draw Rz bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_RZ ) {
            static BYTE nOldRz; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->lRz != nOldRz ) {
                nOldRz = (BYTE)lpDIJoyState->lRz;

                if( bGradient )
                    pProgs[RZ_INDEX]->SetPos(lpDIJoyState->lRz);

                ::PostMessage(ProgWnd[RZ_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->lRz - MAX_SLIDER_POS), 0L);
            }
            nDrawFlags &= ~HAS_RZ;
        }
    } else return;

    // draw Slider1 bar if needed
    if( nDrawFlags ) {
        if( nDrawFlags & HAS_SLIDER1 ) {
            static BYTE nOldS1; // = MAX_SLIDER_POS+1;

            if( lpDIJoyState->rglSlider[1] != nOldS1 ) {
                nOldS1 = (BYTE)lpDIJoyState->rglSlider[1];
                if( bGradient )
                    pProgs[S1_INDEX]->SetPos(lpDIJoyState->rglSlider[1]);

                ::PostMessage(ProgWnd[S1_INDEX], PBM_SETPOS, (WPARAM)abs(lpDIJoyState->rglSlider[1] - MAX_SLIDER_POS), 0L);
            }
        }
    }
} // *** end of DoJoyMove

//===========================================================================
// DoTestButtons( HWND hDlg, PBYTE pbButtons, short nButtons )
// 
// Lites whatever button(s) that may be pressed.
//
// Parameters:
//  HWND                    hDlg            -       Handle to Dialog
//  PBYTE                   pbButtons       -       Pointer to byte array of buttons and their states
//  int                     dwButtons       -       Number of buttons on device (per STATEFLAGS struct)
//
// Returns:                 nichts
//
//===========================================================================
static void DoTestButtons( const HWND hDlg, PBYTE pbButtons, int nButtons )
{
    // validate pointer(s)
    if( (IsBadReadPtr((void*)pbButtons, sizeof(BYTE))) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("DoTestButtons: Bad Read Pointer argument!\n"));
#endif
        return;
    }

    if( (IsBadWritePtr((void*)pbButtons, sizeof(BYTE))) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("DoTestButtons: Bad Write Pointer argument!\n"));
#endif
        return;
    }

    // Don't worry about the Zero Button condition!
    // It's being done in the timer!
    static BYTE bLookup[MAX_BUTTONS] = {NULL};

    BYTE i = 0;

    // Loop threw the buttons looking only at the ones we know we have!
    while( nButtons && (nButtons & (HAS_BUTTON1<<i)) ) {
        // check for a button press
        if( pbButtons[i] != bLookup[i] ) {
            // update the button with the proper bitmap
            HWND hCtrl = GetDlgItem(hDlg, IDC_TESTJOYBTNICON1+i);

            // Set the Extra Info
            SetWindowLongPtr(hCtrl, GWLP_USERDATA, (LONG_PTR)(pbButtons[i] & 0x80) ? 1 : 0);

            RedrawWindow(hCtrl, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            // update the lookup table
            bLookup[i] = pbButtons[i];
        }

        // strip the button!
        nButtons &= ~(HAS_BUTTON1<<i++);
    } 
} // end of DoTestButtons

//===========================================================================
// DoTestPOV( PDWORD pdwPOV )
//
// Routes a call to SetDegrees to set the degrees to pdwPOV 
//
// Parameters:
//  PDWORD                  pdwPOV          -       degrees at which to display the POV arrow
//
// Returns:                 nichts
//
//===========================================================================
void DoTestPOV( BYTE nPov, PDWORD pdwPOV, HWND hDlg )
{
    // Assume all POV's to be centred at start
    // JOY_POVCENTERED is defined as 0xffffffff
    static short dwOldPOV[MAX_POVS] = {-1,-1,-1,-1};
    BYTE nPovCounter = MAX_POVS-1;
    BYTE nPovs = 0;
    BOOL bChanged = FALSE;

    if( nPov == FORCE_POV_REFRESH ) {
        nPovs = 1;
        bChanged = TRUE;
    } else {
        // You Never have to worry about nPov being Zero, 
        // it is checked before entering this function!
        do {
            // Be aware that nPov is not just a number... it's a bit mask!
            if( nPov & (HAS_POV1<<nPovCounter) ) {
                DWORD dwPov = (nPov & HAS_CALIBRATED) ? pdwPOV[nPovCounter] : pdwPOV[nPovCounter];

                if( dwOldPOV[nPovCounter] != (int)dwPov ) {
                    dwOldPOV[nPovCounter] = (dwPov > 36001) ? -1 : (int)dwPov;

                    bChanged = TRUE;
                }

                nPovs++;
                nPov &= ~(HAS_POV1<<nPovCounter);
            }
        } while( nPovCounter-- && nPov );
    }

    if( bChanged ) {
        SetDegrees(nPovs, dwOldPOV, GetDlgItem(hDlg, IDC_JOYPOV));
    }

} // *** end of DoTestPOV 

//===========================================================================
// DrawCross( HWND hwnd, LPPOINTS pPoint, short nFlag)
//
// Draws a cross on hwnd at pPoint of type nFlag
//
// Parameters:
//  HWND                    hwnd
//  LPPOINTS            pPoint
//  int                 nFlag
//
// Returns:             nichts
//
//===========================================================================
static void DrawCross(const HWND hwnd, LPPOINTS pPoint, short nFlag)
{
    assert(hwnd);

    HDC hdc = GetDC( hwnd ); 

    HPEN holdpen = (struct HPEN__ *) SelectObject( hdc, (nFlag == COLOR_WINDOW) ? hWinPen : hTextPen );

    MoveToEx( hdc, pPoint->x-(DELTA-1), pPoint->y, NULL);

    LineTo( hdc, pPoint->x+DELTA, pPoint->y );
    MoveToEx( hdc, pPoint->x, pPoint->y-(DELTA-1), NULL );

    LineTo( hdc, pPoint->x, pPoint->y+DELTA );

    SelectObject( hdc, holdpen );

    ReleaseDC( hwnd, hdc );
} // *** end of DrawCross 

void CreatePens( void )
{
    // We always create both at the same time so checking one is sufficient!
    if( hTextPen == NULL ) {
        LOGPEN LogPen;

        LogPen.lopnStyle   = PS_SOLID;
        LogPen.lopnWidth.x = LogPen.lopnWidth.y = 0;
        LogPen.lopnColor = GetSysColor( COLOR_WINDOW );

        hWinPen  = CreatePenIndirect(&LogPen);
        
        LogPen.lopnColor = GetSysColor( COLOR_WINDOWTEXT );

        hTextPen = CreatePenIndirect(&LogPen); 
    }
}

//===========================================================================
// DisplayAvailableButtons(HWND hWnd, int nNumButtons)
//
// Removes buttons not found on the device!  
// 
//
// Parameters:
//  HWND                hDlg        - Dialog handle
//  int                 nNumButtons - Number of buttons to display
//
// Returns:
//
//===========================================================================
void DisplayAvailableButtons(const HWND hWndToolTip, const HWND hDlg, const int nButtonFlags)
{
    LPTOOLINFO pToolInfo;
    LPTSTR lpStr;

    if( nButtonFlags ) {
        if( hWndToolTip ) {
            pToolInfo = new (TOOLINFO);
            ASSERT (pToolInfo);

            lpStr = new (TCHAR[STR_LEN_32]);
            ASSERT(lpStr);

            ZeroMemory(pToolInfo, sizeof(TOOLINFO));

            pToolInfo->cbSize    = sizeof(TOOLINFO);
            pToolInfo->uFlags    = 0; 
            pToolInfo->hwnd        = hDlg;

            ::SendDlgItemMessage(hDlg, IDC_GROUP_BUTTONS, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)lpStr);
            pToolInfo->lpszText = lpStr;
        }
    }

    HWND hCtrl;

    // Show the ones we have...
    // Destroy the ones we don't!
    BYTE i = MAX_BUTTONS;

    do {
        hCtrl = GetDlgItem(hDlg, IDC_TESTJOYBTNICON1+(--i));

        if( (nButtonFlags & HAS_BUTTON1<<i) && pToolInfo ) {
            // Add the Control to the tool!
            pToolInfo->uFlags    = TTF_IDISHWND | TTF_SUBCLASS;  
            pToolInfo->uId       = (ULONG_PTR) hCtrl;

            // Add the control!
            ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);

            continue;
        }
        DestroyWindow(hCtrl);
    } while( i );

    if( nButtonFlags ) {
        if( lpStr )
            delete[] (lpStr);

        if( pToolInfo )
            delete (pToolInfo);
    } else {
        // don't forget to remove the groupe!
        hCtrl = GetDlgItem(hDlg, IDC_GROUP_BUTTONS);
        DestroyWindow(hCtrl);
    }

} //*** end DisplayAvailableButtons()


//===========================================================================
// JoyError(HWND hwnd)
//
// Displays the "Device Not Connected" 
//
// Parameters:
//  HWND         hwnd - window handle
//                
// Returns:      rc - User selection from MessageBox 
//
//===========================================================================
short JoyError( const HWND hwnd )
{
    assert(hwnd);

    LPTSTR lptszTitle = (LPTSTR)_alloca(sizeof(TCHAR[STR_LEN_32]));
    assert (lptszTitle);

    short rc;

    if( LoadString(ghInst, IDS_JOYREADERROR, lptszTitle, STR_LEN_32) ) {
        LPTSTR  lptszMsg = (LPTSTR)_alloca(sizeof(TCHAR[STR_LEN_128]));
        assert(lptszMsg);

        if( LoadString(ghInst, IDS_JOYUNPLUGGED, lptszMsg, STR_LEN_128) ) {
            rc = (short)MessageBox( hwnd, lptszMsg, lptszTitle, MB_RETRYCANCEL | MB_ICONERROR );

            if( rc == IDCANCEL ) {
                // terminate the dialog if we give up
                PostMessage( GetParent(hwnd), WM_COMMAND, IDCANCEL, 0 );
            }
        }
    }

    return(rc);
} // *** end of JoyError 

//===========================================================================
// DisplayAvailablePOVs( const HWND hWndToolTip, const HWND hDlg, BYTE nPOVs )
//
// Displays POV window if there are any associated with the device.
//
// Parameters:
//    HWND              hDlg      - window handle
//     short                    nPOVs       - number of POVs
//
// Returns:                 nichts
//
//===========================================================================
static void DisplayAvailablePOVs ( const HWND hWndToolTip, const HWND hDlg, BYTE nPOVs )
{
    HWND hwndPOV = GetDlgItem(hDlg, IDC_JOYPOV);

    SetWindowPos( hwndPOV, NULL, NULL, NULL, NULL, NULL, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((nPOVs) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));

    SetWindowPos( GetDlgItem( hDlg, IDC_GROUP_POV ), NULL, NULL, NULL, NULL, NULL, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | ((nPOVs) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));

    if( nPOVs ) {
        // Disable RTL flag
        SetWindowLongPtr(hwndPOV, GWL_EXSTYLE, GetWindowLongPtr(hwndPOV,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL );
        
        if( hWndToolTip ) {
            LPTOOLINFO pToolInfo = (LPTOOLINFO)_alloca(sizeof(TOOLINFO));
            ASSERT (pToolInfo);

            LPTSTR lpStr = (LPTSTR)_alloca(sizeof(TCHAR[STR_LEN_32]));
            ASSERT (lpStr);

            if( pToolInfo && lpStr ) {

                ZeroMemory(pToolInfo, sizeof(TOOLINFO));

                pToolInfo->cbSize    = sizeof(TOOLINFO);
                pToolInfo->uFlags    = 0; 
                pToolInfo->hwnd        = hDlg;

                ::SendDlgItemMessage(hDlg, IDC_GROUP_POV, WM_GETTEXT, (WPARAM)STR_LEN_32, (LPARAM)lpStr);
                pToolInfo->lpszText = lpStr;

                pToolInfo->uFlags    = TTF_IDISHWND | TTF_SUBCLASS;  
                pToolInfo->uId       = (ULONG_PTR)hwndPOV;

                // Add the control!
                ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);
            }
        }
    }
} // *** end of DisplayAvailablePOVs


//===========================================================================
// SetOEMWindowText( HWND hDlg, short *nControlIDs, LPTSTR *pszLabels, BYTE nCount )
//
// Retrieves text from registry keys and Displays it in a Dialog Control or title!
//
// Parameters:
//  HWND             hDlg        - Handle to dialog where strings are to be sent
//                    nControlIDs - Pointer to array of Dialog Item ID's
//                                 Zero may be used if you want the Title!          
//                   pszLabels   - Pointer to array of Registry Keys to read
//                   nCount      - Number of ellements in the array
//
// Returns:            nichts
//
//===========================================================================
void SetOEMWindowText ( const HWND hDlg, const short *nControlIDs, LPCTSTR *pszLabels, LPCWSTR wszType, LPDIRECTINPUTJOYCONFIG pdiJoyConfig, BYTE nCount )
{
    if( nCount == 0 ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: Test.cpp: SetOEMWindowText: nCount is Zero!\n"));
#endif
        return;
    }

    // validate nControlIDs pointer
    if( IsBadReadPtr((void*)nControlIDs, sizeof(short)) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: Test.cpp: SetOEMWindowText: nControlIDs is not a valid Read Pointer!\n"));
#endif
        return;
    }

    // validate pointers
    if( IsBadReadPtr((void*)pszLabels, sizeof(TCHAR)) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("JOY.CPL: Test.cpp: SetOEMWindowText: pszLabels is not a valid Read Pointer!\n"));
#endif
        return;
    }

    HKEY hKey;

    pdiJoyConfig->Acquire();

    // Open the TypeKey
    if( FAILED(pdiJoyConfig->OpenTypeKey( wszType, KEY_ALL_ACCESS, &hKey)) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("Test.cpp: SetOEMWindowText: OpenTypeKey FAILED!\n"));
#endif
        return;
    }

    DWORD dwCount = MAX_STR_LEN; 

    LPTSTR pszBuff = (LPTSTR)_alloca(sizeof(TCHAR[MAX_STR_LEN]));
    assert(pszBuff);

    DWORD dwType  = REG_SZ;

    do {
        if( RegQueryValueEx( hKey, pszLabels[nCount], NULL, &dwType, (CONST LPBYTE)pszBuff, &dwCount ) == ERROR_SUCCESS ) {
            // This is because RegQueryValueEx returns dwCount size as the size
            // of the terminating char if the label is found w/o a string!
            if( dwCount > sizeof(TCHAR) ) {
                if( nControlIDs[nCount] )
                    ::SendMessage(GetDlgItem(hDlg, nControlIDs[nCount]), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pszBuff);
                else
                    ::SendMessage(GetParent(hDlg), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)pszBuff);
            }
#ifdef _DEBUG
            else OutputDebugString(TEXT("Test.cpp: SetOEMWindowText: ReqQueryValueEx failed to find Registry string!\n"));
#endif
        }
        dwCount = MAX_STR_LEN;
    } while( nCount-- );

    RegCloseKey(hKey);
} // *** end of SetOEMWindowText


//===========================================================================
// DisplayAvailableAxisTest(HWND hDlg, BYTE nAxisFlags, LPDIRECTINPUTDEVICE2 pdiDevice2)
//
// Displays the number and names of the device Axis in the provided dialog.
// This EXPECTS that the controls are not visible by default!
//
// Parameters:
//  HWND             hDlg       - Dialog handle
//  BYTE                    nAxisFlags - Flags for number of Axis to display
//
// Returns:
//
//===========================================================================
void DisplayAvailableAxisTest(const HWND hWndToolTip, const HWND hDlg, BYTE nAxisFlags, LPDIRECTINPUTDEVICE2 pdiDevice2)
{
    if( nAxisFlags == 0 ) {
        DestroyWindow(GetDlgItem(hDlg, IDC_AXISGRP));
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF.DLL: DisplayAvailableAxis: Number of Axis is 0!\n"));
#endif
        return;
    }

    LPDIDEVICEOBJECTINSTANCE_DX3 pDevObjInst = new (DIDEVICEOBJECTINSTANCE_DX3);
    assert (pDevObjInst);

    pDevObjInst->dwSize = sizeof(DIDEVICEOBJECTINSTANCE_DX3);

    LPTOOLINFO pToolInfo;

    if( hWndToolTip ) {
        pToolInfo = new (TOOLINFO);
        ASSERT (pToolInfo);


        ZeroMemory(pToolInfo, sizeof(TOOLINFO));

        pToolInfo->cbSize    = sizeof(TOOLINFO);
        pToolInfo->uFlags    = 0; 
        pToolInfo->hwnd        = hDlg;
    }

    HWND hCtrl;

    // X and Y use the same control so they are isolated!
    if( (nAxisFlags & HAS_X) || (nAxisFlags & HAS_Y) ) {
        HWND hwndXY = GetDlgItem(hDlg, IDC_JOYLIST1);

        // Show the Window
        SetWindowPos( hwndXY, NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        // Disable RTL flag
        SetWindowLongPtr(hwndXY, GWL_EXSTYLE, GetWindowLongPtr(hwndXY,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL );

        hCtrl = GetDlgItem(hDlg, IDC_JOYLIST1_LABEL);

        // Show it's text
        SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                      SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        LPTSTR ptszBuff = (LPTSTR)_alloca(sizeof(TCHAR[STR_LEN_64]));
        assert (ptszBuff);

        ZeroMemory(ptszBuff, sizeof(TCHAR[STR_LEN_64]));

        // Set it's text
        if( nAxisFlags & HAS_X ) {
            if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_X, DIPH_BYOFFSET)) )
            {
                int nLen=lstrlen(pDevObjInst->tszName)+1;
                if(nLen>STR_LEN_64)
                    nLen=STR_LEN_64;
                StrCpyN(ptszBuff, pDevObjInst->tszName, nLen);
            }

            // Remove the HAS_X flag
            nAxisFlags &= ~HAS_X;
        }

        if( nAxisFlags & HAS_Y ) {
            if( FAILED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, DIJOFS_Y, DIPH_BYOFFSET)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF.DLL: DisplayAvailableAxis: GetObjectInfo Failed to find DIJOFS_Y!\n"));
#endif
            }

            if( ptszBuff && lstrlen(ptszBuff) ) {
                int nLen=STR_LEN_64-lstrlen(ptszBuff);
                StrNCat(ptszBuff, TEXT(" / "), nLen);
            }

            int nLen=STR_LEN_64-lstrlen(ptszBuff);
            StrNCat(ptszBuff, pDevObjInst->tszName, nLen);

            // Remove the HAS_Y flag
            nAxisFlags &= ~HAS_Y;

        }

        ::SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)ptszBuff);

        // CreateWindow could have failed... if so, no tooltips!
        if( hWndToolTip ) {
            GetWindowRect(hCtrl, &pToolInfo->rect);
            ScreenToClient(GetParent(hDlg), (LPPOINT)&pToolInfo->rect);
            ScreenToClient(GetParent(hDlg), ((LPPOINT)&pToolInfo->rect)+1);

            pToolInfo->lpszText = ptszBuff;

            // Add the Label...
            ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);

            // Add the Control!
            pToolInfo->uFlags    = TTF_IDISHWND | TTF_SUBCLASS;  
            pToolInfo->uId       = (ULONG_PTR)hwndXY;

            // Add the control!
            ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);
        }
    }
    // if you have additional axis, keep going!
    if( nAxisFlags ) {
        // Array of supported axis!
        DWORD dwOffsetArray[] = {DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};

        BYTE nAxisCounter = MAX_AXIS - 2;

        // Go 'till you run out of axis!
        do {
            if( nAxisFlags & (HAS_Z<<nAxisCounter) ) {
                // Create and Assign to the global list!
                ProgWnd[nAxisCounter] = GetDlgItem(hDlg, nAxisCounter+IDC_JOYLIST2);
                ASSERT (ProgWnd[nAxisCounter]); 

                // Create Gradient Class
                if( bGradient ) {
                    pProgs[nAxisCounter] = new (CGradientProgressCtrl);
                    assert (pProgs[nAxisCounter]);

                    // Subclass the Progress Control Window
                    pProgs[nAxisCounter]->SubclassWindow(ProgWnd[nAxisCounter]); 

                } else {
                    // Set the colour
                    // PBM_SETBARCOLOR is WM_USER+9
                    ::PostMessage(ProgWnd[nAxisCounter], WM_USER+9, 0, (LPARAM)ACTIVE_COLOR);
                }

                // Show the control... ProgWnd[nAxisCounter]
                SetWindowPos( ProgWnd[nAxisCounter], NULL, NULL, NULL, NULL, NULL, 
                              SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

                hCtrl = GetDlgItem(hDlg, nAxisCounter+IDC_JOYLIST2_LABEL);

                // Now, Show it's text
                SetWindowPos( hCtrl, NULL, NULL, NULL, NULL, NULL, 
                              SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

                // Get it's text
                if( SUCCEEDED(pdiDevice2->GetObjectInfo((LPDIDEVICEOBJECTINSTANCE)pDevObjInst, dwOffsetArray[nAxisCounter], DIPH_BYOFFSET)) ) {
                    TCHAR tszAxisName[20];

                    int nLen=lstrlen(pDevObjInst->tszName)+1;
                    if(nLen>20)
                        nLen=20;
                    StrCpyN(tszAxisName, pDevObjInst->tszName, nLen);

                    if( lstrlen( tszAxisName ) > 4 ) {
                        tszAxisName[4] = L'.';
                        tszAxisName[5] = L'.';
                        tszAxisName[6] = 0;
                    }

                    ::SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tszAxisName);

                    // Just in case CreateWindow failed!!!
                    if( hWndToolTip ) {
                        GetWindowRect(hCtrl, &pToolInfo->rect);
                        ScreenToClient(GetParent(hDlg), (LPPOINT)&pToolInfo->rect);
                        ScreenToClient(GetParent(hDlg), ((LPPOINT)&pToolInfo->rect)+1);

                        pToolInfo->uFlags    = 0; 
                        pToolInfo->lpszText     = pDevObjInst->tszName;

                        // Add the Label...
                        ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);

                        // Add the Control!
                        pToolInfo->uFlags    = TTF_IDISHWND | TTF_SUBCLASS;  
                        pToolInfo->uId       = (ULONG_PTR) ProgWnd[nAxisCounter];

                        // Now, Add the control!
                        ::SendMessage(hWndToolTip, TTM_ADDTOOL, 0, (LPARAM)pToolInfo);
                    }
                }

                // Remove the flag you just hit!
                nAxisFlags &= ~(HAS_Z<<nAxisCounter);
            }
        } while( nAxisCounter-- && nAxisFlags );
    }

    if( hWndToolTip ) {
        if( pToolInfo )
            delete (pToolInfo);
    }

    if( pDevObjInst )
        delete (pDevObjInst);
} //*** end of DisplayAvailableAxisTest



//===========================================================================
// BOOL SetDeviceRanges( HWND hDlg, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis)
//
// Parameters:
//    HWND                 hDlg       - Handle of Dialog containing controls to scale to
//    LPDIRECTINPUTDEVICE2 pdiDevice2 - Device2 Interface pointer
//    BYTE                 nAxis      - Bit mask of axis ranges to set
//
// Returns: FALSE if failed
//
//===========================================================================
BOOL SetDeviceRanges( const HWND hDlg, LPDIRECTINPUTDEVICE2 pdiDevice2, BYTE nAxis)
{
    if( !::IsWindow(hDlg) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF: SetDeviceRanges: hDlg: Not a valid window!\n"));
#endif
        return(FALSE);
    }

    // validate pDIDevice2 pointer
    if( IsBadReadPtr((void*)pdiDevice2, sizeof(IDirectInputDevice2)) ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF: SetDeviceRanges: pdiDevice2: Bad Read Pointer argument!\n"));
#endif
        return(FALSE);
    }

    if( !nAxis ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF: SetDeviceRanges: nAxis is Zero!\n"));
#endif
        return(FALSE);
    }

    LPDIPROPRANGE pDIPropRange = (LPDIPROPRANGE)_alloca(sizeof(DIPROPRANGE));
    assert (pDIPropRange);

    if( !pDIPropRange ) {
#ifdef _DEBUG
        OutputDebugString(TEXT("GCDEF: SetDeviceRanges: Failed to malloc DIPROPDRANGE!\n"));
#endif
        return(FALSE);
    }

    pDIPropRange->diph.dwSize       = sizeof(DIPROPRANGE);
    pDIPropRange->diph.dwHeaderSize = sizeof(DIPROPHEADER);
    pDIPropRange->diph.dwHow        = DIPH_BYOFFSET;


    BOOL bRet = TRUE;

    HWND hCtrl;
    RECT rc;

    // since X and Y share the same window..
    if( (nAxis & HAS_X) || (nAxis & HAS_Y) ) {
        hCtrl = GetDlgItem(hDlg, IDC_JOYLIST1);
        assert (hCtrl);

        GetClientRect( hCtrl, &rc );

        // Check if it's X
        if( nAxis & HAS_X ) {
            pDIPropRange->diph.dwObj = DIJOFS_X;
            pDIPropRange->lMin = DELTA;
            pDIPropRange->lMax = rc.right-DELTA;

            if( FAILED(pdiDevice2->SetProperty(DIPROP_RANGE, &pDIPropRange->diph)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF: SetDeviceRanges: SetProperty Failed to return X axis Ranges!\n"));
#endif
                bRet = FALSE;
            }

            // strip off the bits you just used
            nAxis &= ~HAS_X;
        }

        // Check if it's Y
        if( nAxis & HAS_Y ) {
            pDIPropRange->diph.dwObj = DIJOFS_Y;
            pDIPropRange->lMin = DELTA;
            pDIPropRange->lMax = rc.bottom-DELTA;

            if( FAILED(pdiDevice2->SetProperty(DIPROP_RANGE, &pDIPropRange->diph)) ) {
#ifdef _DEBUG
                OutputDebugString(TEXT("GCDEF: SetDeviceRanges: SetProperty Failed to return Y axis Ranges!\n"));
#endif
                bRet = FALSE;
            }

            // strip off the bits you just used
            nAxis &= ~HAS_Y;
        }
    }

    // you've got axes > X & Y...
    if( nAxis ) {
        const DWORD dwOfset[] = {DIJOFS_Z, DIJOFS_RX, DIJOFS_RY, DIJOFS_RZ, DIJOFS_SLIDER(0), DIJOFS_SLIDER(1)};

        // Minus 2 is because we've already done X/Y!
        // the third decrement is for the Zero based dwOffset!
        BYTE nAxisCounter = MAX_AXIS-3;

        // These aren't random!
        // These are the default ranges for the CProgressCtrl!!!
        pDIPropRange->lMin = MIN_SLIDER_POS;
        pDIPropRange->lMax = MAX_SLIDER_POS;

        do {
            if( nAxis & (HAS_Z<<nAxisCounter) ) {
                pDIPropRange->diph.dwObj = dwOfset[nAxisCounter];

                VERIFY(SUCCEEDED(pdiDevice2->SetProperty(DIPROP_RANGE, &pDIPropRange->diph)));

                // Remove the flag you just hit!
                nAxis &= ~(HAS_Z<<nAxisCounter);
            }

            nAxisCounter--;

        } while( nAxis );
    }

    return(bRet);
}


#ifdef _UNICODE
///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    RegisterForDevChange ( HWND hDlg, PVOID *hNoditfyDevNode )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void RegisterForDevChange(HWND hDlg, PVOID *hNotifyDevNode)
{
    DEV_BROADCAST_DEVICEINTERFACE *pFilterData =  (DEV_BROADCAST_DEVICEINTERFACE *)_alloca(sizeof(DEV_BROADCAST_DEVICEINTERFACE));
    ASSERT (pFilterData);

    ZeroMemory(pFilterData, sizeof(DEV_BROADCAST_DEVICEINTERFACE));

    pFilterData->dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    pFilterData->dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    pFilterData->dbcc_classguid  = GUID_CLASS_INPUT; 

    *hNotifyDevNode = RegisterDeviceNotification(hDlg, pFilterData, DEVICE_NOTIFY_WINDOW_HANDLE);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    DecodeAxisPOV ( DWORD dwVal )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////

static DWORD DecodeAxisPOV( DWORD dwVal )
{
    DWORD dwResult;

    if( bPolledPOV ) {
        /*
         * figure out which direction this value indicates...
         */
        if( (dwVal > myPOV[POV_MIN][JOY_POVVAL_FORWARD])
          &&(dwVal < myPOV[POV_MAX][JOY_POVVAL_FORWARD]) ) 
        {
            dwResult = JOY_POVFORWARD;
        } 
        else if( (dwVal > myPOV[POV_MIN][JOY_POVVAL_BACKWARD])
               &&(dwVal < myPOV[POV_MAX][JOY_POVVAL_BACKWARD]) ) 
        {
            dwResult = JOY_POVBACKWARD;
        } 
        else if( (dwVal > myPOV[POV_MIN][JOY_POVVAL_LEFT])
               &&(dwVal < myPOV[POV_MAX][JOY_POVVAL_LEFT]) ) 
        {
            dwResult = JOY_POVLEFT;
        } 
        else if( (dwVal > myPOV[POV_MIN][JOY_POVVAL_RIGHT])
               &&(dwVal < myPOV[POV_MAX][JOY_POVVAL_RIGHT]) ) 
        {
            dwResult = JOY_POVRIGHT;
        }
        else 
        {
            dwResult = JOY_POVCENTERED;
        }
    } else {
        dwResult = dwVal;
    }
        
    #if 0
    {
        TCHAR buf[100];
        if( bPolledPOV ) {
            wsprintf(buf, TEXT("calibrated pov: %d\r\n"), dwResult);
        } else {
        	wsprintf(buf, TEXT("uncalibrated pov: %d\r\n"), dwResult);
        }
        OutputDebugString(buf);
    }
    #endif

    return dwResult;
}


/*
 * doPOVCal - compute calibration for POV for a direction
 */
static void __inline doPOVCal( LPJOYREGHWCONFIG pHWCfg, DWORD dwDir, LPDWORD dwOrder )
{
    DWORD   dwVal;
    int     nDir;

    for( nDir=0; nDir<JOY_POV_NUMDIRS; nDir++ ) 
    {
        if( dwOrder[nDir] == dwDir ) 
        {
            break;
        }
    }

    if( nDir == 0 ) 
    {
        dwVal = 1;
    } 
    else 
    {
        dwVal = (pHWCfg->hwv.dwPOVValues[dwDir] + pHWCfg->hwv.dwPOVValues[dwOrder[nDir-1]])/2;
    }
    
    myPOV[POV_MIN][dwDir] = dwVal;

    if( nDir == JOY_POV_NUMDIRS-1 ) {
        dwVal = pHWCfg->hwv.dwPOVValues[dwDir]/10l;
        dwVal += pHWCfg->hwv.dwPOVValues[dwDir];
    } else {
        dwVal = (pHWCfg->hwv.dwPOVValues[dwOrder[nDir+1]] + pHWCfg->hwv.dwPOVValues[dwDir])/2;
    }
    
    myPOV[POV_MAX][dwDir] = dwVal;

} /* doPOVCal */


///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    CalibratePolledPOV( LPJOYREGHWCONFIG pHWCfg )
//
// PARAMETERS:  
//                  
//
// PURPOSE:     
//
// RETURN:      
///////////////////////////////////////////////////////////////////////////////
void CalibratePolledPOV( LPJOYREGHWCONFIG pHWCfg )
{
    DWORD       dwOrder[JOY_POV_NUMDIRS];
    DWORD       dwTmp[JOY_POV_NUMDIRS];
    DWORD       dwVal;
    int         nDir,nDir2;

    /*
     * calibrate POV for polling based ones
     */
    for( nDir=0; nDir<JOY_POV_NUMDIRS; nDir++ ) 
    {
        dwTmp[nDir]   = pHWCfg->hwv.dwPOVValues[nDir];
        dwOrder[nDir] = nDir;
    }

    /*
     * sort (did you ever think you'd see a bubble sort again?)
     */
    for( nDir=0;nDir<JOY_POV_NUMDIRS;nDir++ ) 
    {
        for( nDir2=nDir; nDir2<JOY_POV_NUMDIRS; nDir2++ ) 
        {
            if( dwTmp[nDir] > dwTmp[nDir2] ) 
            {
                dwVal          = dwTmp[nDir];
                dwTmp[nDir]    = dwTmp[nDir2];
                dwTmp[nDir2]   = dwVal;
                dwVal          = dwOrder[nDir];
                dwOrder[nDir]  = dwOrder[nDir2];
                dwOrder[nDir2] = dwVal;
            }
        }
    }

    for( nDir=0; nDir<JOY_POV_NUMDIRS; nDir++ ) 
    {
        doPOVCal( pHWCfg, nDir, dwOrder );
    }
    
    myPOV[POV_MIN][JOY_POV_NUMDIRS] = 0;
    myPOV[POV_MAX][JOY_POV_NUMDIRS] = 0;
} /* CalibratePolledPOV */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\joyarray.h ===
#include "joyhelp.h"

const DWORD gaHelpIDs[]=
{
	IDC_JOYCALIBRATE,	      IDH_4201_12291,	// Settings: "&Calibrate..." (Button)
	IDC_JOY1HASRUDDER,      IDH_4201_1019,	   // Settings: "&Rudder/Pedals" (Button)
	IDC_JOYBTN19,	         IDH_4201_1019,	// Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
	IDC_JOYLIST1,	         IDH_4203_12293,	// -: "" (ListBox)
	IDC_JOYLIST2,	         IDH_4203_12308,	// -: "" (ListBox)
	IDC_JOYLIST3,	         IDH_4203_12334,	// -: "" (ListBox)
	IDC_JOYLIST4,	         IDH_4203_12347,	// -: "" (ListBox)
	IDC_JOYLIST5,	         IDH_4203_12349,	// -: "" (ListBox)
	IDC_JOYPOV,	            IDH_4203_12309,	// -: "" (POVHAT)
	IDC_GROUP_BUTTONS,	   IDH_4203_1023,	// -: "Buttons" (Button)
	IDC_TESTJOYBTNICON1,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON2,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON3,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON4,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON5,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON6,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON7,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON8,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON9,	   IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON10,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON11,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON12,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON13,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON14,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON15,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON16,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON17,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON18,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON19,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON20,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON21,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON22,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON23,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON24,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON25,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON26,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON27,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON28,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON29,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON30,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON31,	IDH_4203_1023,	// -: "x" (Static)
	IDC_TESTJOYBTNICON32,	IDH_4203_1023,	// -: "x" (Static)
	0, 0
};

// Had to split into two arrays because the test and calibrate pages use the same
// IDs for their controls!  -tmc
const DWORD gaHelpIDs_Cal[]=
{
   IDC_JOYLIST1,	IDH_4101_12293,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST2,	IDH_4101_12308,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST3,	IDH_4101_12334,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST4,	IDH_4101_12347,	// Joystick Calibration: "" (ListBox)
	IDC_JOYLIST5,	IDH_4101_12349,	// Joystick Calibration: "" (ListBox)
	IDC_JOYPOV,	   IDH_4101_12309,	// Joystick Calibration: "f" (Static)
   IDC_JOYPICKPOV,IDH_4101_12328,	// Joystick Calibration: "Capture &POV" (Button)
   IDC_JOYCALBACK,IDH_4101_12329,	// Joystick Calibration: "< &Back" (Button)
   IDC_JOYCALNEXT,IDH_4101_12330,	// Joystick Calibration: "&Next >" (Button)
   IDC_JOYLIST1,	IDH_4202_12293,	// Game Controller Calibration: "" (ListBox)
	IDC_JOYLIST2,	IDH_4202_12308,	// Game Controller Calibration: "" (ListBox)
   IDC_JOYPICKPOV,IDH_4202_12328,	// Joystick Calibration: "Capture &POV" (Button)
   IDC_JOYCALBACK,IDH_4202_12329,	// Joystick Calibration: "< &Back" (Button)
   IDC_JOYCALNEXT,IDH_4202_12330,	// Joystick Calibration: "&Next >" (Button)
	IDC_JOYLIST3,	IDH_4202_12334,	// Game Controller Calibration: "" (ListBox)
	IDC_GROUPBOX,	IDH_4202_8199,	   // Game Controller Calibration: "Calibration Information" (Button)
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\dicpl.h ===
//
//                                                                       
//    This is a part of the Microsoft Direct Input SDK.                  
//    Copyright (C) 1992-1997 Microsoft Corporation                      
//    All rights reserved.                                               
//                                                                       
//    This source code is only intended as a supplement to the           
//    Microsoft Direct Input SDK References and related                  
//    electronic documentation provided with the SDK.                    
//    See these sources for detailed information regarding the           
//    Microsoft Direct Input API.                                        
//                                                                       
//

#ifndef _DX_CPL_
#define _DX_CPL_

// maximum pages allowed on a server
#define MAX_PAGES 26

// Interface ID
// {7854FB22-8EE3-11d0-A1AC-0000F8026977}
DEFINE_GUID(IID_IDIGameCntrlPropSheet, 
0x7854fb22, 0x8ee3, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);


//
//                                                                       
//                           STRUCTURES                                  
//                                                                       
//

// This pragma may not be supported by all compilers.
// Please consult your compiler documentation.
#pragma pack(8)

typedef struct 
{
	DWORD		 dwSize;
	LPWSTR  	 lpwszPageTitle;
	DLGPROC	     fpPageProc;
	BOOL		 fProcFlag;
	DLGPROC	  	 fpPrePostProc;
	BOOL		 fIconFlag;
	LPWSTR		 lpwszPageIcon;
	LPWSTR       lpwszTemplate; 
	LPARAM		 lParam;
	HINSTANCE	 hInstance;
} DIGCPAGEINFO, *LPDIGCPAGEINFO;
  

typedef struct 
{
	DWORD		 dwSize;
	USHORT	     nNumPages;
	LPWSTR	     lpwszSheetCaption;
	BOOL		 fSheetIconFlag;
	LPWSTR		 lpwszSheetIcon;
} DIGCSHEETINFO, *LPDIGCSHEETINFO;


//
//                                                                       
//         Interface as Exposed by the InProcServer Property Sheet       
//                                                                       
//
DECLARE_INTERFACE_( IDIGameCntrlPropSheet, IUnknown)
{
	// IUnknown Members
	STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// IServerProperty Members
	STDMETHOD(GetSheetInfo)		(THIS_ LPDIGCSHEETINFO *) PURE; 	
	STDMETHOD(GetPageInfo)		(THIS_ LPDIGCPAGEINFO *) PURE; 	
	STDMETHOD(SetID)			(THIS_ USHORT nID) PURE;
};
typedef IDIGameCntrlPropSheet *LPIDIGAMECNTRLPROPSHEET;

//
//                                                                       
//                CLASS DEFINITION for CServerClassFactory				  
//                                                                       
//
class CServerClassFactory : public IClassFactory
{
	protected:
		ULONG   			m_ServerCFactory_refcount;
    
	public:
		// constructor
		CServerClassFactory(void);
		// destructor
		~CServerClassFactory(void);
        
		// IUnknown methods
		STDMETHODIMP            QueryInterface(REFIID, PPVOID);
		STDMETHODIMP_(ULONG)    AddRef(void);
		STDMETHODIMP_(ULONG)    Release(void);
    
		// IClassFactory methods
		STDMETHODIMP    		CreateInstance(LPUNKNOWN, REFIID, PPVOID);
		STDMETHODIMP    		LockServer(BOOL);
};

//
//                                                                       
//				  CLASS DEFINITION for CDIGameCntrlPropSheet			  
//                                                                       
//
class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
	friend					CServerClassFactory;

	private:
		short				m_cProperty_refcount;
		short				m_nID;
		
	public:
		CDIGameCntrlPropSheet(void);
		~CDIGameCntrlPropSheet(void);
		
		// IUnknown methods
	   virtual STDMETHODIMP            QueryInterface(REFIID, PPVOID);
	   virtual STDMETHODIMP_(ULONG)    AddRef(void);
	   virtual STDMETHODIMP_(ULONG)    Release(void);
		
		virtual STDMETHODIMP			   GetSheetInfo(LPDIGCSHEETINFO *ppSheetInfo);
		virtual STDMETHODIMP			   GetPageInfo (LPDIGCPAGEINFO  *ppPageInfo );
		virtual STDMETHODIMP			   SetID(USHORT nID);
		virtual STDMETHODIMP_(USHORT)	GetID(void)			{return m_nID;}
};
typedef CDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;


//
//                                                                       
//                             ERRORS                                    
//                                                                       
//
#define DIGCERR_ERRORSTART			0x80097000
#define DIGCERR_NUMPAGESZERO	   	0x80097001
#define DIGCERR_NODLGPROC		   	0x80097002
#define DIGCERR_NOPREPOSTPROC		0x80097003
#define DIGCERR_NOTITLE				0x80097004
#define DIGCERR_NOCAPTION		   	0x80097005
#define DIGCERR_NOICON				0x80097006
#define DIGCERR_STARTPAGETOOLARGE	0x80097007
#define DIGCERR_NUMPAGESTOOLARGE	0x80097008
#define DIGCERR_INVALIDDWSIZE		0x80097009
#define DIGCERR_ERROREND			0x80097100

#endif // _DX_CPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\joycpl.cpp ===
//****************************************************************************
//
//  File:       joycpl.c
//  Content:    Joystick configuration and testing
//  History:
//   Date   By  Reason
//   ====   ==  ======
//   03-oct-94  craige  initial implementation
//   05-nov-94  craige  generalized 4 axis joysticks and other improvements
//   11-nov-94  craige  allow multiple copies of tab to run
//   22-nov-94  craige  tweaks to calibration code
//   29-nov-94  craige  small bugs
//   08-dec-94  craige  generalized second joystick
//   11-dec-94  craige  split into component parts
//   15-dec-94  craige  allow N joysticks
//   18-dec-94  craige  process UV
//   05-jan-95  craige  external rudder bug
//   05-mar-95  craige  Bug 9998: pass id -1 to get base dev caps
//          Bug 15334: allow reset of user values for compatiblity
//   06-mar-95  craige  Bug 7608: deleting VxD name if joystick not present
//                caused unplugged joystick to never come back
//
//  Copyright (c) Microsoft Corporation 1994
//
//****************************************************************************

#pragma pack (8)

#include "stdafx.h"
#include "assert.h"

#include "joycpl.h"
#include "resource.h"

#include "baseids.h"
#include "pov.h"

#include "pinfo.h"
#include "comstr.h"

#include "joyarray.h"     // Help array

extern USHORT gnID; // ID as sent from Client via SetID
extern BOOL fIsSideWinder;
static BOOL fIsLoaded = 0;

// Context sensitive help stuff!
static void OnContextMenu(WPARAM wParam);
extern const DWORD gaHelpIDs[];

#ifdef DEBUG
void cdecl MBOX(LPSTR szFormat, ...)
{
    char ach[256];

    wvsprintf( ach,szFormat,(LPSTR)(&szFormat+1));
    MessageBox( NULL, ach, "JOYCPL", MB_OK | MB_SYSTEMMODAL );

}
#endif

extern "C" WINMMAPI MMRESULT WINAPI joyConfigChanged(DWORD);

/***************************************************************************
 
 
  MEMORY MANAGEMENT ROUTINES FOLLOW
 
 
 ***************************************************************************/

#ifdef DEBUG
DWORD   allocCount;
#endif

// DoAlloc - allocate memory
LPVOID DoAlloc( DWORD size )
{
    LPVOID  res;

    res = LocalAlloc( LPTR, size );
#ifdef DEBUG
    allocCount++;
#endif
    return(res);

} /* DoAlloc */

/*
 * DoFree - free allocated memory
 */
void DoFree( LPVOID ptr )
{
    if( ptr != NULL )
    {
        LocalFree( ptr );
#ifdef DEBUG
        allocCount--;
        if( allocCount < 0 )
        {
            DPF( "JOYCPL:  Too many frees, allocCount=%d\r\n", allocCount );
        }
#endif
    }

} /* DoFree */


/***************************************************************************
 
 
  REGISTRY RELATED ROUTINES FOLLOW
 
 
 ***************************************************************************/

//  getDevCaps - get the joystick device caps
static void getDevCaps( LPGLOBALVARS pgv )
{
    JOYCAPS jc;

    if( joyGetDevCaps( pgv->iJoyId, &jc, sizeof( jc ) ) == JOYERR_NOERROR )
    {
        pgv->joyRange.jpMin.dwX = jc.wXmin;
        pgv->joyRange.jpMax.dwX = jc.wXmax;
        pgv->joyRange.jpMin.dwY = jc.wYmin;
        pgv->joyRange.jpMax.dwY = jc.wYmax;
        pgv->joyRange.jpMin.dwZ = jc.wZmin;
        pgv->joyRange.jpMax.dwZ = jc.wZmax;
        pgv->joyRange.jpMin.dwR = jc.wRmin;
        pgv->joyRange.jpMax.dwR = jc.wRmax;
        pgv->joyRange.jpMin.dwU = jc.wUmin;
        pgv->joyRange.jpMax.dwU = jc.wUmax;
        pgv->joyRange.jpMin.dwV = jc.wVmin;
        pgv->joyRange.jpMax.dwV = jc.wVmax;
        pgv->dwMaxAxes = (DWORD) jc.wMaxAxes;
    }

} /* getDevCaps */

/*
 * RegistryUpdated - notify the driver that the registry is updated
 */
void RegistryUpdated( LPGLOBALVARS pgv )
{
    // joyConfigChanged( 0 );
    if( pgv != NULL )
        getDevCaps( pgv );      // devcaps could change

} /* RegistryUpdated */

/*
 * createSettingsKeyFromCurr - create a settings key for a specific joystick
 */
static void createSettingsKeyFromCurr( LPGLOBALVARS pgv, LPSTR str )
{
    assert(pgv);

    char    tmp[MAX_STR];
    int     type;
    LPJOYDATA   pjd;

    pjd = pgv->pjd;
    assert(pjd);

    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_ISOEM )
    {
        type = pgv->joyHWCurr.dwType - JOY_HW_LASTENTRY;

        if( type < 0 || type >= pjd->oemCount )
            tmp[0] = 0;
        else
            lstrcpy( tmp, pjd->oemList[type].keyname );
    } else wsprintf( tmp, "predef%d", pgv->joyHWCurr.dwType );

    wsprintf( str, "%s\\%s", pjd->regSettingsCfgKey, tmp );

} /* createSettingsKeyFromCurr */

static CListBox  ChangeListCtrl;

// regSaveSpecificJoyHW - save specific joystick hardware config. to the registry
static void regSaveSpecificJoyHW( LPGLOBALVARS pgv )
{
    assert(pgv);

    char    str[MAX_STR];
    HKEY    hkey;
    char    jcfg[MAX_STR];

    if( pgv->joyHWCurr.dwType == JOY_HW_NONE )  return;

    createSettingsKeyFromCurr( pgv, str );

    if( !RegCreateKey( HKEY_LOCAL_MACHINE, str, &hkey ) )
    {
        GETKEYNAME( pgv, jcfg, REGSTR_VAL_JOYNCONFIG );
        RegSetValueEx( hkey, jcfg, 0, REG_BINARY, (CONST LPBYTE)&pgv->joyHWCurr, sizeof( pgv->joyHWCurr ));
        RegCloseKey( hkey );
    }

} /* regSaveSpecificJoyHW */

/*
 * regCreateCurrKey - create the current joystick settings key
 */
static HKEY regCreateCurrKey( LPGLOBALVARS pgv )
{
    assert(pgv);

    HKEY    hkey;

    if( !RegCreateKey( HKEY_LOCAL_MACHINE, pgv->pjd->regCurrCfgKey, &hkey ) )
        return(hkey);
    else
        return(NULL);

} /* regCreateCurrKey */

// RegSaveCurrentJoyHW - save the joystick info to the current entry in the registry
void RegSaveCurrentJoyHW( LPGLOBALVARS pgv )
{
    HKEY    hkey;
    LPSTR   sptr;
    char    vname[MAX_STR];
    char    oname[MAX_STR];
    char    coname[MAX_STR];
    int     type;
    LPJOYDATA   pjd;

    assert(pgv);

    hkey = regCreateCurrKey( pgv );
    assert(hkey);

    if( hkey == NULL )
    {
        DPF( "Could not save current joystick settings!\r\n" );
        return;
    }

    pjd = pgv->pjd;
    assert(pjd);

    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_ISOEM )
        sptr = pjd->oemList[ pgv->joyHWCurr.dwType - JOY_HW_LASTENTRY ].keyname;

    GETKEYNAME( pgv, vname, REGSTR_VAL_JOYNCONFIG );
    GETKEYNAME( pgv, oname, REGSTR_VAL_JOYNOEMNAME );
    GETKEYNAME( pgv, coname, REGSTR_VAL_JOYNOEMCALLOUT );

    RegSetValueEx( hkey, vname, 0, REG_BINARY, (CONST LPBYTE)&pgv->joyHWCurr, sizeof( pgv->joyHWCurr ) );
    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_ISOEM )
    {
        RegSetValueEx( hkey, oname, 0, REG_SZ,(const unsigned char *) sptr, strlen( sptr ) + 1 );

        // set up VxD name for this joystick
        type = pgv->joyHWCurr.dwType - JOY_HW_LASTENTRY;
        if( (pjd->oemList[type].vxd_name[0] != 0) )
        {
            RegSetValueEx( hkey, coname, 0, REG_SZ, (const unsigned char *) pjd->oemList[type].vxd_name,
                           lstrlen( pjd->oemList[type].vxd_name )+1 );
        } else RegDeleteValue( hkey, coname );
    } else
    {
        RegDeleteValue( hkey, oname );
        RegDeleteValue( hkey, coname );
    }

    RegCloseKey( hkey );

} /* RegSaveCurrentJoyHW */

// regPermSaveAllInfo - save joystick data to the registry for good
static void regPermSaveAllInfo( LPGLOBALVARS pgv )
{

    assert(pgv);

    // save specific hardware settings to the registry
    regSaveSpecificJoyHW( pgv );

    // save current current hardware to the registry
    RegSaveCurrentJoyHW( pgv );

    RegistryUpdated( pgv );

} /* regPermSaveAllInfo */

// setHWCurrType - set the current hardware type (check for OEM type)
static BOOL setHWCurrType( LPGLOBALVARS pgv, HKEY hkey, LPJOYREGHWCONFIG pcfg )
{
    assert(pgv);
    assert(hkey);
    assert(pcfg);

    char    str[MAX_STR];
    char    pname[MAX_STR];
    int     i;
    DWORD   regtype;
    DWORD   cb;
    LPJOYDATA   pjd;

    if( !(pcfg->dwUsageSettings & JOY_US_ISOEM) )
        return(TRUE);

    GETKEYNAME( pgv, pname, REGSTR_VAL_JOYNOEMNAME );
    cb = sizeof( str );
    if( RegQueryValueEx( hkey, pname, NULL, &regtype, (CONST LPBYTE)str, &cb) )
        return(FALSE);

    if( regtype != REG_SZ )
        return(FALSE);

    pjd = pgv->pjd;
    assert(pjd);

    for( i=0;i<pjd->oemCount;i++ )
    {
        if( !lstrcmpi( str, pjd->oemList[i].keyname ) )
        {
            pcfg->dwType = i + JOY_HW_LASTENTRY;
            return(TRUE);
        }
    }
    return(FALSE);

} /* setHWCurrType */

// regGetCurrHW - get the information about the current configuration from the registry
static void regGetCurrHW( LPGLOBALVARS pgv )
{
    assert(pgv);

    DWORD       regtype;
    DWORD       cb;
    JOYREGHWCONFIG  config;
    HKEY        hkey;
    char        str[MAX_STR];

    if( hkey = regCreateCurrKey( pgv ) )
    {
        cb = sizeof( config );
        GETKEYNAME( pgv, str, REGSTR_VAL_JOYNCONFIG );

        if( !RegQueryValueEx( hkey, str, NULL, &regtype, (CONST LPBYTE)&config, &cb) )
        {
            if( regtype == REG_BINARY && cb == sizeof( config ) )
            {
                if( setHWCurrType( pgv, hkey, &config ) )
                    pgv->joyHWCurr = config;
            }
        }
    }

    cb = sizeof( config );
    RegCloseKey(  hkey );

} /* regGetCurrHW */

// regGetOEMStr - get an OEM string
static BOOL regGetOEMStr( HKEY hkey, LPSTR keyname, LPSTR buff, int size, LPSTR *res )
{
    assert(hkey);
    assert(keyname);

    DWORD   cb;
    DWORD   type;
    LPSTR   str;
    int     slen;

    cb = size;
    slen = 1;
    if( !RegQueryValueEx( hkey, keyname, NULL, &type, (CONST LPBYTE)buff, &cb ) )
    {
        if( type == REG_SZ )
            slen = strlen( buff ) + 1;
    }

    str = (char *) DoAlloc( slen );
    assert(str);
    if( str != NULL )
    {
        if( slen == 1 )
            str[0] = 0;
        else
            lstrcpy( str, buff );
    }

    *res = str;

    if( str == NULL )
        return(TRUE);

    return(FALSE);

} /* regGetOEMStr */

#define RANGE_MIN   0
#define RANGE_MAX   65535

/*
 * checkNonStandardUserVals
 */
static BOOL checkNonStandardUserVals( LPJOYREGUSERVALUES puv )
{
    assert(puv);

    if( (puv->jrvRanges.jpMin.dwX != RANGE_MIN) ||
        (puv->jrvRanges.jpMin.dwY != RANGE_MIN) ||
        (puv->jrvRanges.jpMin.dwZ != RANGE_MIN) ||
        (puv->jrvRanges.jpMin.dwR != RANGE_MIN) ||
        (puv->jrvRanges.jpMin.dwU != RANGE_MIN) ||
        (puv->jrvRanges.jpMin.dwV != RANGE_MIN) ||
        (puv->jrvRanges.jpMax.dwX != RANGE_MAX) ||
        (puv->jrvRanges.jpMax.dwY != RANGE_MAX) ||
        (puv->jrvRanges.jpMax.dwZ != RANGE_MAX) ||
        (puv->jrvRanges.jpMax.dwR != RANGE_MAX) ||
        (puv->jrvRanges.jpMax.dwU != RANGE_MAX) ||
        (puv->jrvRanges.jpMax.dwV != RANGE_MAX) ||
        (puv->dwTimeOut != 0x1000) ||
        (puv->jpDeadZone.dwX != 0) ||
        (puv->jpDeadZone.dwY != 0) )
    {
        return(TRUE);
    }
    return(FALSE);

} /* checkNonStandardUserVals */

// regSetUserVals - set user values to our defaults
static void regSetUserVals( LPJOYDATA pjd, BOOL retest )
{
    assert(pjd);

    JOYREGUSERVALUES    uv;
    JOYREGUSERVALUES    ouv;
    HKEY        hkey;
    DWORD       regtype;
    DWORD       cb;

    if( !RegOpenKey( HKEY_LOCAL_MACHINE, pjd->regCfgKey, &hkey ) )
    {
        /*
         * build the default settings
         */
        memset( &uv, 0, sizeof( uv ) );

        // fix #2245, take the Greater of the two timeout values.
        uv.dwTimeOut = (pjd->userVals.dwTimeOut > 0x1000) ? pjd->userVals.dwTimeOut : 0x1000;

        uv.jpDeadZone.dwX = 0;
        uv.jpDeadZone.dwY = 0;
        uv.jrvRanges.jpMin.dwX = RANGE_MIN;
        uv.jrvRanges.jpMin.dwY = RANGE_MIN;
        uv.jrvRanges.jpMin.dwZ = RANGE_MIN;
        uv.jrvRanges.jpMin.dwR = RANGE_MIN;
        uv.jrvRanges.jpMin.dwU = RANGE_MIN;
        uv.jrvRanges.jpMin.dwV = RANGE_MIN;
        uv.jrvRanges.jpMax.dwX = RANGE_MAX;
        uv.jrvRanges.jpMax.dwY = RANGE_MAX;
        uv.jrvRanges.jpMax.dwZ = RANGE_MAX;
        uv.jrvRanges.jpMax.dwR = RANGE_MAX;
        uv.jrvRanges.jpMax.dwU = RANGE_MAX;
        uv.jrvRanges.jpMax.dwV = RANGE_MAX;

        if( retest )
        {
            /*
             * see if the values have changed since we last set them:
             * if yes, then we need to reset our remembered values
             */
            DPF( "Looking for USER entries\r\n" );
            cb = sizeof( ouv );
            if( !RegQueryValueEx( hkey, REGSTR_VAL_JOYUSERVALUES, NULL,
                                  &regtype, (CONST LPBYTE)&ouv, &cb) )
            {
                DPF( "found REGSTR_VAL_JOYUSERVALUES\r\n" );
                if( regtype == REG_BINARY && cb == sizeof( ouv ) )
                {
                    if( memcmp( &uv, &ouv, sizeof( uv ) ) )
                    {
                        DPF( "USER entries changed!\r\n" );
                        pjd->bHasUserVals = TRUE;
                        pjd->bDeleteUserVals = FALSE;
                        pjd->userVals = ouv;
                    }
                }
            } else
            {
                if( pjd->bHasUserVals )
                {
                    DPF( "USER entries changed, no longer exist!\r\n" );
                    pjd->bHasUserVals = FALSE;
                    pjd->bDeleteUserVals = TRUE;
                }
            }
        }

        /*
         * set our new values
         */
        RegSetValueEx( hkey, REGSTR_VAL_JOYUSERVALUES, 0, REG_BINARY,
                       (CONST LPBYTE)&uv, sizeof( uv ) );
        RegCloseKey( hkey );
    }

} /* regSetUserVals */

// regUserValsInit - save old user values, and init to ones we like
static void regUserValsInit( LPJOYDATA pjd )
{
    assert(pjd);

    HKEY     hkey;
    DWORD        regtype;
    DWORD        cb;

    pjd->bHasUserVals    = FALSE;
    pjd->bDeleteUserVals = FALSE;

    if( !RegOpenKey( HKEY_LOCAL_MACHINE, pjd->regCfgKey, &hkey ) )
    {
        cb = sizeof( pjd->userVals );

        if( !RegQueryValueEx( hkey, REGSTR_VAL_JOYUSERVALUES, NULL,
                              &regtype, (CONST LPBYTE)&pjd->userVals, &cb) )
        {
            if( regtype == REG_BINARY && cb == sizeof( pjd->userVals ) )
            {
                pjd->bHasUserVals = TRUE;
                DPF( "USER entries exist!\r\n" );
            }

            pjd->bHasNonStandardUserVals = checkNonStandardUserVals( &pjd->userVals );
        } else
        {
            pjd->bDeleteUserVals = TRUE;
            pjd->bHasNonStandardUserVals = FALSE;
            DPF( "USER entries don't exist!\r\n" );
        }

        RegCloseKey( hkey );
    }

    regSetUserVals( pjd, FALSE );

} /* regUserValsInit */

// regUserValsFini - restore old user values
static void regUserValsFini( LPJOYDATA pjd )
{
    assert(pjd);

    HKEY    hkey = 0;
    
    if( pjd->bHasUserVals || pjd->bDeleteUserVals )
    {
        if( !RegOpenKey( HKEY_LOCAL_MACHINE, pjd->regCfgKey, &hkey ) )
        {
            if( pjd->bHasUserVals )
            {
                DPF( "resetting USER entries!\r\n" );
                RegSetValueEx( hkey, REGSTR_VAL_JOYUSERVALUES, 0, REG_BINARY,
                               (CONST LPBYTE)&pjd->userVals, sizeof( pjd->userVals ) );
            } else
            {
                DPF( "deleting USER entries!\r\n" );
                RegDeleteValue( hkey, REGSTR_VAL_JOYUSERVALUES );
            }
            RegistryUpdated( NULL );
        }
        pjd->bHasUserVals = FALSE;
        pjd->bDeleteUserVals = FALSE;
    }

} /* regUserValsFini */


/***************************************************************************
 
 
  CUSTOM JOYSTICK SELECTION FUNCTIONS FOLLOW
 
 
 ***************************************************************************/


/*
 * custom joystick variables
 */
typedef struct
{
    LPGLOBALVARS    pgv;
    BOOL        bHasZ;
    BOOL        bHasR;
    BOOL        bHasPOV;
    BOOL        bIsYoke;
    BOOL        bIsGamePad;
    BOOL        bIsCarCtrl;
    BOOL        bHas2Buttons;
} cust_vars, *LPCUSTVARS;


// enableCustomSpecial - enable the special section of the custom dialog box
static void enableCustomSpecial( HWND hwnd, BOOL on )
{
    ASSERT (::IsWindow(hwnd));

    HWND hCtrl = GetDlgItem( hwnd, IDC_JOYISYOKE );
    ASSERT (::IsWindow(hCtrl));
    EnableWindow( hCtrl, on );

    hCtrl = GetDlgItem( hwnd, IDC_JOYISGAMEPAD );
    ASSERT (::IsWindow(hCtrl));
    EnableWindow( hCtrl, on );

    hCtrl = GetDlgItem( hwnd, IDC_JOYISCARCTRL );
    ASSERT (::IsWindow(hCtrl));
    EnableWindow( hCtrl, on );

    CheckDlgButton( hwnd, IDC_JOYUSESPECIAL, on );

    if( !on )
    {
        CheckDlgButton( hwnd, IDC_JOYISYOKE,    FALSE );
        CheckDlgButton( hwnd, IDC_JOYISGAMEPAD, FALSE );
        CheckDlgButton( hwnd, IDC_JOYISCARCTRL, FALSE );
    }

} /* enableCustomSpecial */


// CustomProc - callback procedure for custom joystick setup
BOOL CALLBACK CustomProc( HWND hwnd, UINT umsg, WPARAM wParam, LPARAM lParam)
{
    int         id;
    LPGLOBALVARS    pgv;
    LPCUSTVARS      pcv;

    switch( umsg )
    {
    case WM_DESTROY:
        /*
     * don't free the dialog's variables here, they are returned to the
     * creator; the creator will free them
     */
        break;
    case WM_INITDIALOG:
        // create variables for the custom dialog
        pcv = (cust_vars *) DoAlloc( sizeof( cust_vars ) );
        assert(pcv);
        SetWindowLong( hwnd, DWL_USER, (LONG) pcv );
        if( pcv == NULL )
        {
            EndDialog( hwnd, 0 );
            return(FALSE);
        }
        pgv = (LPGLOBALVARS) lParam;

        assert(pgv);
        pcv->pgv = pgv;

        // set up initial dialog state
        pcv->bHasZ      = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_HASZ);
        pcv->bHasR      = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_HASR);
        pcv->bHas2Buttons = (pgv->joyHWCurr.hws.dwNumButtons == 2);
        pcv->bHasPOV    = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_HASPOV);
        pcv->bIsYoke    = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_ISYOKE);
        pcv->bIsGamePad = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_ISGAMEPAD);
        pcv->bIsCarCtrl = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_ISCARCTRL);

        if( pcv->bHasZ && pcv->bHasR )
        {
            CheckRadioButton( hwnd, IDC_JOY2AXIS, IDC_JOY4AXIS, IDC_JOY4AXIS );
        } else if( pcv->bHasZ )
        {
            CheckRadioButton( hwnd, IDC_JOY2AXIS, IDC_JOY4AXIS, IDC_JOY3AXIS );
        } else
        {
            CheckRadioButton( hwnd, IDC_JOY2AXIS, IDC_JOY4AXIS, IDC_JOY2AXIS );
        }

        if( pcv->bHas2Buttons )
        {
            CheckRadioButton( hwnd, IDC_JOY2BUTTON, IDC_JOY4BUTTON, IDC_JOY2BUTTON );
        } else
        {
            CheckRadioButton( hwnd, IDC_JOY2BUTTON, IDC_JOY4BUTTON, IDC_JOY4BUTTON );
        }

        CheckDlgButton( hwnd, IDC_JOYHASPOV, pcv->bHasPOV );
        id = -1;
        if( pcv->bIsYoke )
        {
            id = IDC_JOYISYOKE;
        } else if( pcv->bIsGamePad )
        {
            id = IDC_JOYISGAMEPAD;
        } else if( pcv->bIsCarCtrl )
        {
            id = IDC_JOYISCARCTRL;
        }
        if( id != -1 )
        {
            enableCustomSpecial( hwnd, TRUE );
            CheckRadioButton( hwnd, IDC_JOYISYOKE, IDC_JOYISCARCTRL, id );
        } else
        {
            enableCustomSpecial( hwnd, FALSE );
        }
        return(FALSE);

    case WM_COMMAND:
        pcv = (LPCUSTVARS) GetWindowLong( hwnd, DWL_USER );
        id = GET_WM_COMMAND_ID(wParam, lParam);
        switch( id )
        {
        case IDC_JOY2AXIS:
        case IDC_JOY3AXIS:
        case IDC_JOY4AXIS:
            CheckRadioButton( hwnd, IDC_JOY2AXIS, IDC_JOY4AXIS, id );
            pcv->bHasZ = FALSE;
            pcv->bHasR = FALSE;
            if( id == IDC_JOY3AXIS )
            {
                pcv->bHasZ = TRUE;
            } else if( id == IDC_JOY4AXIS )
            {
                pcv->bHasZ = TRUE;
                pcv->bHasR = TRUE;
            }
            break;
        case IDC_JOY2BUTTON:
        case IDC_JOY4BUTTON:
            CheckRadioButton( hwnd, IDC_JOY2BUTTON, IDC_JOY4BUTTON, id );
            pcv->bHas2Buttons = (id == IDC_JOY2BUTTON);
            break;
        case IDC_JOYUSESPECIAL:
            enableCustomSpecial( hwnd, IsDlgButtonChecked( hwnd, IDC_JOYUSESPECIAL ) );
            pcv->bIsYoke = FALSE;
            pcv->bIsGamePad = FALSE;
            pcv->bIsCarCtrl = FALSE;
            break;
        case IDC_JOYHASPOV:
            pcv->bHasPOV = !pcv->bHasPOV;
            break;
        case IDC_JOYISYOKE:
        case IDC_JOYISGAMEPAD:
        case IDC_JOYISCARCTRL:
            pcv->bIsYoke = (id == IDC_JOYISYOKE);
            pcv->bIsGamePad = (id == IDC_JOYISGAMEPAD);
            pcv->bIsCarCtrl = (id == IDC_JOYISCARCTRL);
            CheckRadioButton( hwnd, IDC_JOYISYOKE, IDC_JOYISCARCTRL, id );
            break;
        case IDCANCEL:
            EndDialog( hwnd, 0 );
            break;
        case IDOK:
            pcv = (LPCUSTVARS) GetWindowLong( hwnd, DWL_USER );
            EndDialog(hwnd, (int) pcv );
            break;
        }
        break;
    default:
        break;
    }
    return(FALSE);

} /* CustomProc */


/***************************************************************************
 
 
  MAIN DIALOG FUNCTIONS FOLLOW
 
 
 ***************************************************************************/


// variables used by joystick tab dialog
typedef struct
{
    LPGLOBALVARS    pgv;
} JTVARS, *LPJTVARS;

// numJoyAxes - get number of axes on a joystick
static int numJoyAxes( LPGLOBALVARS pgv )
{
    assert(pgv);

    DWORD   flags;
    int     axis_count;

    flags = pgv->joyHWCurr.hws.dwFlags;
    axis_count = 2;
    if( flags & JOY_HWS_HASZ )
    {
        axis_count++;
    }
    if( flags & JOY_HWS_HASR )
    {
        axis_count++;
    }
    if( (flags & JOY_HWS_HASPOV) && (flags & JOY_HWS_POVISPOLL) )
    {
        axis_count++;
    }
    return(axis_count);

} /* numJoyAxes */

// saveHWSettings - save the current hardware settings
static void saveHWSettings( LPGLOBALVARS pgv )
{
    assert(pgv);

    pgv->joyHWOrig = pgv->joyHWCurr;

} /* saveHWSettings */

// restoreHWSettings - restore current hw settings to saved values
static void restoreHWSettings( LPGLOBALVARS pgv )
{
    assert(pgv);

    pgv->joyHWCurr = pgv->joyHWOrig;
    RegSaveCurrentJoyHW( pgv );

} /* restoreHWSettings */

// getActiveFlags - poll and test which joysticks are currently plugged in
static unsigned getActiveFlags( LPGLOBALVARS pgv )
{
    JOYINFOEX   ji;
    MMRESULT    rc;
    unsigned    val;

    assert(pgv);

    //  check for presense of joystick 1 and joystick 2
    val = 0;
    ji.dwSize = sizeof( ji );
    ji.dwFlags = JOY_RETURNX|JOY_RETURNY|JOY_CAL_READXYONLY|JOY_CAL_READALWAYS;
    rc = joyGetPosEx( pgv->iJoyId, &ji );
    DPF( "joyGetPosEx = %d\r\n", rc );
    if( rc == JOYERR_NOERROR )
    {
        val = HASJOY;
    }

    // check if either could have a rudder attached.
    ji.dwFlags = JOY_RETURNR | JOY_CAL_READRONLY;
    if( (numJoyAxes( pgv ) < 4) &&
        !(pgv->joyHWCurr.hws.dwFlags & JOY_HWS_HASR ) )
    {
        rc = joyGetPosEx( pgv->iJoyId, &ji );
        if( rc ==JOYERR_NOERROR )
        {
            val |= HASRUDDERMAYBE;
        }
    }
    return(val);

} /* getActiveFlags */

// enableTestCal - enable/disable test and calibrate buttons
static void enableTestCal( HWND hwnd, int hw_type )
{
    ASSERT(::IsWindow(hwnd));

    BOOL enable = (hw_type != JOY_HW_NONE);

    HWND hCtrl = GetDlgItem( hwnd, IDC_JOYCALIBRATE );
    ASSERT (::IsWindow(hCtrl));
    EnableWindow( hCtrl, enable );
} /* enableTestCal */

// cleanUpJoyDlg - clean up allocated stuff
static void cleanUpJoyDlg( HWND hwnd )
{
    assert(hwnd);

    LPGLOBALVARS    pgv;

    pgv = (LPGLOBALVARS) GetWindowLong( hwnd, DWL_USER );
    if( pgv == NULL )
        return;

    // ditch timer
    if( pgv->pjd->bHasTimer )
    {
        KillTimer( hwnd, TIMER_ID );
        pgv->pjd->bHasTimer = FALSE;
    }

    // done with our variables
#if defined( WANT_SHEETS )
    DoFree( pgv );
#endif

} /* cleanUpJoyDlg */

// enableJoyWindows - enable controls for a joystick
static void  enableJoyWindows( LPGLOBALVARS pgv, HWND hwnd, BOOL enable )
{
    HWND hCtrl = GetDlgItem(hwnd,IDC_JOYCALIBRATE);
    ASSERT (::IsWindow(hCtrl));
    EnableWindow( hCtrl, enable );
} /* enableJoyWindows */

// enableActiveJoystick - enable dialog controls based on presence of joysticks
static void enableActiveJoystick( LPGLOBALVARS pgv, HWND hwnd )
{
    assert(pgv);
    assert(hwnd);

    BOOL        allowj;
    char        str[MAX_STR];
    unsigned    joys;
    LPSTR       text;

    // check what joysticks are active; if it hasn't changed, just return
    joys = getActiveFlags( pgv );    
    if( pgv->joyActiveFlags == joys )
        return;

    pgv->joyActiveFlags = joys;

    // turn off the rudder if it is gone
    if( !(joys & HASRUDDERMAYBE) )
    {
        pgv->joyHWCurr.dwUsageSettings &= ~JOY_US_HASRUDDER;
        CheckDlgButton( hwnd, IDC_JOY1HASRUDDER, FALSE );
    }

    // enable the appropriate windows
    allowj = ((joys & HASJOY) != 0);
    enableJoyWindows( pgv, hwnd, allowj );

    HWND hCtrl = GetDlgItem( hwnd, IDC_JOY1HASRUDDER );
    ASSERT (::IsWindow(hCtrl));
    EnableWindow( hCtrl, allowj && (joys & HASRUDDERMAYBE) );

    // set message for the user if there is no joystick plugged in, or if there is no joystick driver present
    if( allowj )
    {
        text = "";
    } else
    {
        text    =    str;

        LoadString( GetResourceInstance(), (joyGetNumDevs()) ? IDS_JOYUNPLUGGED : IDS_JOYNOTPRESENT, str, sizeof( str ) );
    }

    if( allowj )
        enableTestCal( hwnd, pgv->joyHWCurr.dwType );

    if( allowj )
        pgv->joyHWCurr.dwUsageSettings |= JOY_US_PRESENT;
    else
        pgv->joyHWCurr.dwUsageSettings &= ~JOY_US_PRESENT;

    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

} /* enableActiveJoystick */


#ifdef DEAD_CODE
/*
 * getNewJoyInfo - get information from the registry about a new joystick.
 *         If no info, default to joyHWDefault settings
 */
static void getNewJoyInfo( LPGLOBALVARS pgv, HWND hwnd )
{
    assert(pgv);
    assert(hwnd);


    DWORD       hw_type;
    HKEY        hkey;
    char        str[MAX_STR];
    char        jcfg[MAX_STR];
    DWORD       regtype;
    JOYREGHWCONFIG  config;
    DWORD       cb;
    BOOL        same;
    int         rc;

    GETKEYNAME( pgv, jcfg, REGSTR_VAL_JOYNCONFIG );

    // get the hardware type
    hw_type = SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_GETCURSEL, 0, 0L );
    same = (hw_type == pgv->joyHWCurr.dwType);

    // read the info from the registry if a new hardware type selected
    if( !same )
    {
        pgv->joyHWCurr = pgv->pjd->joyHWDefaults[ hw_type ];
        createSettingsKeyFromCurr( pgv, str );
        if( !RegOpenKey( HKEY_LOCAL_MACHINE, str, &hkey ) )
        {
            cb = sizeof( pgv->joyHWCurr );
            if( !RegQueryValueEx( hkey, jcfg, NULL, &regtype,
                                  (CONST LPBYTE)&config, &cb) )
            {
                if( regtype == REG_BINARY && cb == sizeof( config ) )
                {
                    pgv->joyHWCurr.hws = config.hws;
                    pgv->joyHWCurr.hwv = config.hwv;
                    pgv->joyHWCurr.dwUsageSettings = config.dwUsageSettings;
                }
            }
            RegCloseKey( hkey );
        }

        // set up the rudder bit
        if( pgv->joyHWCurr.dwUsageSettings & JOY_US_HASRUDDER )
        {
            CheckDlgButton( hwnd, IDC_JOY1HASRUDDER, TRUE );
        } else
        {
            if( IsDlgButtonChecked( hwnd, IDC_JOY1HASRUDDER ) )
            {
                pgv->joyHWCurr.dwUsageSettings |= JOY_US_HASRUDDER;
            } else
            {
                pgv->joyHWCurr.dwUsageSettings &= ~JOY_US_HASRUDDER;
            }
        }
    }

    // disable test/calibrate buttons based on hardware picked
    enableTestCal( hwnd, hw_type );

    // if custom selected, go get the data from the user
    if( hw_type == JOY_HW_CUSTOM )
    {
        //ISSUE-2001/03/29-timgill  Old code issue
        //HINSTANCE hInst = (HINSTANCE)GetWindowLong(hwnd,GWL_HINSTANCE);
        HINSTANCE hInst = (HINSTANCE)GetResourceInstance();
        assert(hInst);
        rc = DialogBoxParam(hInst,
                            MAKEINTRESOURCE(IDD_JOYCUSTOM), hwnd,
                            (int (__stdcall *)(struct HWND__ *,unsigned int,unsigned int,long))CustomProc, (LONG) pgv );
        if( rc )
        {
            LPCUSTVARS  pcv;

            pcv = (LPCUSTVARS) rc;
            pgv->joyHWCurr.dwUsageSettings |= JOY_US_PRESENT;
            pgv->joyHWCurr.hws.dwFlags &= ~(JOY_HWS_HASR|JOY_HWS_HASZ|
                                            JOY_HWS_HASPOV|JOY_HWS_ISYOKE| JOY_HWS_ISGAMEPAD|
                                            JOY_HWS_ISCARCTRL| JOY_HWS_POVISPOLL|
                                            JOY_HWS_POVISBUTTONCOMBOS );
            /*
             * NOTE: for a custom joystick, we always assume that Z is
             * implemented on J2 Y.
             */
            if( pcv->bHasZ )
                pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_HASZ;
            /*
             * NOTE: for a custom joystick, we always assume that R is
             * implemented on J2 X.
             */
            if( pcv->bHasR )
                pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_HASR;

            if( pcv->bHasPOV )
                pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_HASPOV;

            if( pcv->bIsYoke )
                pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_ISYOKE;

            if( pcv->bIsGamePad )
            {
                pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_ISGAMEPAD;
            }
            if( pcv->bIsCarCtrl )
            {
                pgv->joyHWCurr.hws.dwFlags |= JOY_HWS_ISCARCTRL;
            }
            if( pcv->bHas2Buttons )
            {
                pgv->joyHWCurr.hws.dwNumButtons = 2;
            } else
            {
                pgv->joyHWCurr.hws.dwNumButtons = 4;
            }
            DoFree( pcv );
            same = FALSE;
        }
    }

    /*
     * update the registry with the new current joystick
     */
    if( !same )
    {
        RegSaveCurrentJoyHW( pgv );
        RegistryUpdated( pgv );
        PropSheet_Changed( GetParent(hwnd), hwnd );
        pgv->joyActiveFlags = (unsigned) -1;
        enableActiveJoystick( pgv, hwnd );
    }

} /* getNewJoyInfo */
#endif //DEAD_CODE

// initCurrentHW - set up the current hardware for the first  time
static void initCurrentHW( LPGLOBALVARS pgv )
{
    assert(pgv);


    regGetCurrHW( pgv );
    pgv->joyActiveFlags = (unsigned) -1;
    saveHWSettings( pgv );

} /* initCurrentHW */

// newJoyId - set up for a new joystick id
static LPGLOBALVARS newJoyId( LPGLOBALVARS pgv, HWND hwnd, int joyid )
{

    assert(pgv);
    assert(hwnd);

//   if( joyid == pgv->iJoyId )
//  return pgv;

#if !defined( WANT_SHEETS )
    pgv = &pgv->pjd->pgvlist[ joyid ];
#endif
    pgv->iJoyId = joyid;

    /*
     * save the pointer to the variables
     */
    SetWindowLong( hwnd, DWL_USER, (LONG) pgv );

#if defined( WANT_SHEETS )
    /*
     * set up current joystick hardware
     */
    initCurrentHW( pgv );
#endif

    // set up windows
    pgv->joyActiveFlags = (unsigned) -1;
    enableActiveJoystick( pgv, hwnd );

    CheckDlgButton( hwnd, IDC_JOY1HASRUDDER, ( pgv->joyHWCurr.dwUsageSettings & JOY_US_HASRUDDER ) ? TRUE : FALSE);

    // select the current info
//    SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_SETCURSEL, pgv->joyHWCurr.dwType, 0L );

#if !defined( WANT_SHEETS )
//  SendDlgItemMessage( hwnd, IDC_JOYCURRENTID, CB_SETCURSEL, pgv->iJoyId, 0L );
#endif
    return(pgv);


} /* newJoyId */

/*
 * showResetInfo
 *
static void showResetInfo( HWND hwnd, BOOL show )
{
    ASSERT (::IsWindow(hwnd));

//  HWND hCtrl = GetDlgItem( hwnd, IDC_JOYTROUBLESHOOT_FRAME );
//  ASSERT (::IsWindow(hCtrl));
//  EnableWindow( hCtrl, show );

//  hCtrl = GetDlgItem( hwnd, IDC_JOYTROUBLESHOOT_TEXT );
//  ASSERT (::IsWindow(hCtrl));
//  EnableWindow( hCtrl, show );

//  hCtrl = GetDlgItem( hwnd, IDC_JOYRESET );
//  ASSERT (::IsWindow(hCtrl));
//  EnableWindow( hCtrl, show );

} * showResetInfo */

// doJoyDlgInitDialog - process initialization for joystick tabbed dialog
static BOOL doJoyDlgInitDialog( HWND hwnd, LPARAM lParam )
{
    assert(IsWindow(hwnd));

    HINSTANCE       hinst = GetWindowInstance( hwnd );
    HINSTANCE     hResInst = GetResourceInstance();
    LPPROPSHEETPAGE ppsp;
//    int           i;
//    char      str[MAX_STR];
    LPGLOBALVARS    pgv;
    LPJOYDATA       pjd;
    LPJOYDATAPTR    pjdp;

    /*
     LRESULT lr;
     HKEY hKey;
     ULONG cb;
     PACKETINFO PacketInfo;
     //
     // set labels
     //
 
     // load icon
     if (fIsSideWinder)
     {
         HANDLE hDevice;
         DWORD dwVerSize;
         char sz[256];
         char sz2[256];
         JOYCAPS jc;
 
         // set icon
         HICON hIcon =(struct HICON__ *) LoadImage(hResInst,(PSTR)IDI_SIDEWINDER, IMAGE_ICON, 64, 64, 0);
         ASSERT(hIcon);
         
         HWND hCtrl = GetDlgItem(hwnd, IDC_SIDEWINDERICON);
         ASSERT (::IsWindow(hCtrl));
         ShowWindow(hCtrl, SW_SHOW);
 
         hCtrl = GetDlgItem(hwnd, IDC_SIDEWINDERICON);
         ASSERT (::IsWindow(hCtrl));
         Static_SetIcon(hCtrl, hIcon);
         
         // set title
         pszCommonString->LoadString(IDS_PROP_TBAR);
         lstrcpy(sz, (LPCTSTR)*pszCommonString);
     
         SetWindowText(GetParent(hwnd), sz);
 
         // product name
         SetDialogItemText(hwnd, IDC_TEXT_PRODUCTNAME, IDS_SETTING_PRODUCT_NAME+1);
 
         // version
         GetSystemDirectory(sz, sizeof(sz));
         lstrcat(sz, "\\MSGAME.VXD");           
         dwVerSize = GetFileVersionInfoSize(sz, &cb);
         if (dwVerSize)
         {
             VS_FIXEDFILEINFO* pVer;
             UINT cbVer;
             char* p = (char*)malloc(dwVerSize);
             GetFileVersionInfo(sz, 0, dwVerSize, (void*)p);
             VerQueryValue((void*)p, "\\", (void**)&pVer, &cbVer);
             wsprintf(
                 sz, "%d.%02d.%02d",
                 HIWORD(pVer->dwFileVersionMS),
                 LOWORD(pVer->dwFileVersionMS),
                 LOWORD(pVer->dwFileVersionLS));
             SetDlgItemText(hwnd, IDC_TEXT_VERSION, sz);
             free(p);
         }
 
         // copyright
         SetDialogItemText(hwnd, IDC_TEXT_COPYRIGHT, IDS_COPYRIGHT+1);
 
         // PID
         pszCommonString->LoadString(IDS_SETTING_PRODUCT_NAME+2);
         lstrcpy(sz2, (LPCTSTR)*pszCommonString);
     
         wsprintf(sz, "Software\\Microsoft\\%s\\1.0\\registration", sz2);
         lr = RegOpenKey(HKEY_LOCAL_MACHINE, sz,    &hKey);
         *sz = 0;
         cb = sizeof(sz);
         lr = RegQueryValueEx(hKey, "ProductID", 0, 0, (BYTE*)sz, &cb);
         RegCloseKey(hKey);
         SetDlgItemText(hwnd, IDC_TEXT_PID, sz);
 
         // diagnostics
         joyGetDevCaps(0, &jc, sizeof(jc));
         if (!strcmp(jc.szOEMVxD, "MSGAME.VXD"))
         {
             hDevice = CreateFile(
                         "\\\\.\\MSGAME.VXD",
                         0, 0, 0, 0,
                         FILE_FLAG_DELETE_ON_CLOSE, 0);
             if (hDevice!=INVALID_HANDLE_VALUE)
             {
                 lr = DeviceIoControl(
                         hDevice, 6,    
                         &PacketInfo, sizeof(PACKETINFO), 
                         0, 0, &cb, 0);
                 CloseHandle(hDevice);
             }
             wsprintf(
                 sz, "%08x-%08x-%02x", 
                 PacketInfo.nFailures, PacketInfo.nAttempts, PacketInfo.iMode);
             SetDlgItemText(hwnd, IDC_TEXT_DIAGNOSTIC, sz);
         }
 
         SetDlgItemText(hwnd, IDC_TEXT_DIAGNOSTIC, sz);
 
         // hide calibration button and rudder options
         hCtrl = GetDlgItem(hwnd, IDC_JOYCALIBRATE);
         ASSERT (::IsWindow(hCtrl));
         ShowWindow(hCtrl, 0);
 
         hCtrl = GetDlgItem(hwnd, IDC_GROUP_RUDDER);
         ASSERT (::IsWindow(hCtrl));
         ShowWindow(hCtrl, 0);
 
         hCtrl = GetDlgItem(hwnd, IDC_TEXT_RUDDERHELP);
         ASSERT (::IsWindow(hCtrl));
         ShowWindow(hCtrl, 0);
 
         hCtrl = GetDlgItem(hwnd, IDC_JOY1HASRUDDER);
         ASSERT (::IsWindow(hCtrl));
         ShowWindow(hCtrl, 0);
     }
    */

    // pointer to data
    ppsp = (LPPROPSHEETPAGE) lParam;
    pjdp = (LPJOYDATAPTR) ppsp->lParam;
    pjd = pjdp->pjd;

    // blj: Fix #8049, Assign the proper ID for the joysick assigned to this property sheet.
    pjdp->iJoyId = gnID;

    // create global variables.   These will be used by all dialogs
#if defined( WANT_SHEETS )
    pgv = DoAlloc( sizeof( GLOBALVARS ) );
    assert(pgv);
    if( pgv == NULL )
        return(FALSE);

    // get joystick id that this sheet is for
    pgv->iJoyId = pjdp->iJoyId;
    pgv->pjd = pjd;
    DPF( "Tab for joystick %d started\r\n", pgv->iJoyId );
#else
    pgv = &pjd->pgvlist[ pjdp->iJoyId ];
#endif

    // get device caps
    getDevCaps( pgv );

    /* these are for the old combo boxes that used to display the controllers... this is no longer needed
    // set up pre-defined joystick list
    for( i=IDS_JOYHW0; i<IDS_JOYHWLAST; i++ ) 
    {
        if (LoadString( hResInst , i, str, sizeof( str ))) 
            SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_ADDSTRING, 0, (LPARAM)(LPSTR) str );
    }

    // set up OEM joystick list
    for( i=0;i<pjd->oemCount;i++ ) 
        SendDlgItemMessage( hwnd, IDC_JOYSELECT, CB_ADDSTRING, 0, (LPARAM)(LPSTR) pjd->oemList[i].ident_string );

    // this can all go away!!!
    // set up joystick choices list
    #if !defined(WANT_SHEETS)
    {
    int numdevs;
    char    strid[MAX_STR];
    if( LoadString( hResInst, IDS_JOY, str, sizeof( str ) ) ) 
    {
        numdevs = joyGetNumDevs();
        
        for( i=0;i<numdevs;i++ ) 
        {
            wsprintf( strid, "%s %d", str, i+1 );
            SendDlgItemMessage( hwnd, IDC_JOYCURRENTID, CB_ADDSTRING, 0, (LPARAM)(LPSTR) strid );
        }
    }
    }
    #endif
    */

//  pgv->iJoyId = -1;
    newJoyId( pgv, hwnd, pjdp->iJoyId); 

    // enable/disable our Reset button
//    showResetInfo( hwnd, pjd->bHasNonStandardUserVals );

    return(TRUE);

} /* doJoyDlgInitDialog */

/*
 * doJoyDlgCommand - process WM_COMMAND message for main joystick tabbed dialog
 */
static void doJoyDlgCommand( HWND hwnd, int id, HWND hctl, UINT code )
{
    assert(hwnd);

    LPGLOBALVARS    pgv;

    pgv = (LPGLOBALVARS) GetWindowLong( hwnd, DWL_USER );
    assert(pgv);

    switch( id )
    {
#ifdef DEAD_CODE
    // new joystick has been picked
    case IDC_JOYSELECT:
        if( code == CBN_SELCHANGE )
            getNewJoyInfo( pgv, hwnd );
        break;
#endif // DEAD_CODE

#if !defined( WANT_SHEET )
        // new joystick id has been picked
    case IDC_JOYCURRENTID:
        if( code == CBN_SELCHANGE )
        {
            int joyid;
            joyid = SendDlgItemMessage( hwnd, IDC_JOYCURRENTID, CB_GETCURSEL, 0, 0L );
            pgv = newJoyId( pgv, hwnd, joyid );
            regSetUserVals( pgv->pjd, TRUE );
            RegSaveCurrentJoyHW( pgv );
            RegistryUpdated( pgv );
        }
        break;
#endif

        // calibrate current joystick
    case IDC_JOYCALIBRATE:
        pgv->pjd->bUseTimer = FALSE;
        DoCalibrate( pgv, hwnd );
        pgv->pjd->bUseTimer = TRUE;
        break;

#ifdef DEAD_CODE
        // test either joystick 1 or joystick 2
    case IDC_JOYTEST:
        pgv->pjd->bUseTimer = FALSE;
        DoTest( pgv, hwnd, NULL, pgv );
        pgv->pjd->bUseTimer = TRUE;
        break;
#endif

        // reset to user values
    case IDC_JOYRESET:
        pgv->pjd->bResetUserVals = TRUE;
        PropSheet_Changed( GetParent(hwnd), hwnd );
        break;

        // rudder selected/unselected
    case IDC_JOY1HASRUDDER:
        {
            LPJOYREGHWCONFIG    pcfg;
            // rudder status changed, force recalibration (leave POV alone if it was button based)
            pcfg = &pgv->joyHWCurr;
            assert(pcfg);

            if( (pcfg->hws.dwFlags & JOY_HWS_HASPOV) && (pcfg->hws.dwFlags & JOY_HWS_POVISBUTTONCOMBOS) )
                pcfg->hwv.dwCalFlags &= JOY_ISCAL_POV;
            else
                pcfg->hwv.dwCalFlags = 0;

            if( IsDlgButtonChecked( hwnd, id ) )
                pcfg->dwUsageSettings |= JOY_US_HASRUDDER;
            else
                pcfg->dwUsageSettings &= ~JOY_US_HASRUDDER;

            pgv->joyActiveFlags = (unsigned) -1;
            enableActiveJoystick( pgv, hwnd );

            // tell vjoyd that the device has changed!
            joyConfigChanged(0);

            PropSheet_Changed( GetParent(hwnd), hwnd );
            break;
        }

    case ID_APPLY:
        {
            DPF( "ID_APPLY\r\n" );

#if !defined( WANT_SHEETS )
            {
//      int i;
//      int numjoys;

//      numjoys = joyGetNumDevs();
//      for( i=0;i<numjoys;i++ ) 
                {
                    regPermSaveAllInfo( &pgv->pjd->pgvlist[gnID] );
                    saveHWSettings( &pgv->pjd->pgvlist[gnID] );
                }
            }
#else
            regPermSaveAllInfo( pgv );
            saveHWSettings( pgv );
#endif
            if( pgv->pjd->bResetUserVals )
            {
                regUserValsFini( pgv->pjd );
                regUserValsInit( pgv->pjd );
                pgv->pjd->bResetUserVals = FALSE;
            }
//  showResetInfo( hwnd, pgv->pjd->bHasNonStandardUserVals );
// BUG 419 FIX: brute force method
            InvalidateRect(GetParent(hwnd), 0, 0);
            break;
        }


    case ID_INIT:
        DPF( "ID_INIT\r\n" );
        joyConfigChanged(0);

        pgv->iJoyId = gnID;

        // we've been re-activated, reset the current joystick settings
        regSetUserVals( pgv->pjd, TRUE );
        RegSaveCurrentJoyHW( pgv );
        RegistryUpdated( pgv );
        break;

    case IDOK:
        DPF( "IDOK\r\n" );

        joyConfigChanged(0);

        EndDialog(hwnd, TRUE );
        break;

    case IDCANCEL:
        DPF( "IDCANCEL\r\n" );
        pgv->pjd->bResetUserVals = FALSE;
#if !defined( WANT_SHEETS )
        {
//      int i;
//      int numjoys;

//      numjoys = joyGetNumDevs();
//      for( i=0;i<numjoys;i++ ) {
            restoreHWSettings( &pgv->pjd->pgvlist[gnID] );
//      }
        }
#else
        restoreHWSettings( pgv );
#endif
        RegistryUpdated( pgv );
        EndDialog(hwnd, FALSE );
        break;

    default:
        break;
    }

} /* doJoyDlgCommand */


/*
 * JoystickDlg - dialog procedure for joystick tabbed dialog
 */
BOOL CALLBACK JoystickDlg( HWND hwnd, UINT umsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    rc;

    switch( umsg )
    {
    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam);
        return(1);

    case WM_INITDIALOG:
        rc = doJoyDlgInitDialog( hwnd, lParam );

        if( !rc )
            EndDialog( hwnd, 0 );
        return(FALSE);

    case WM_COMMAND:
        HANDLE_WM_COMMAND( hwnd, wParam, lParam, doJoyDlgCommand );
        break;

    case WM_ACTIVATE:
        // we've been activated, pretend we were re-selected
        if( LOWORD( wParam ) != WA_INACTIVE )
            FORWARD_WM_COMMAND( hwnd, ID_INIT, 0, 0, SendMessage );
        break;

    case WM_DESTROY:
        cleanUpJoyDlg( hwnd );
        break;

    case WM_NOTIFY:
        {
            NMHDR FAR * lpnm = (NMHDR FAR *)lParam;
            switch( lpnm->code )
            {
            case PSN_KILLACTIVE:
                FORWARD_WM_COMMAND( hwnd, IDOK, 0, 0, SendMessage );
                FORWARD_WM_COMMAND( hwnd, ID_INIT, 0, 0, SendMessage );
// ADDED CML 7/03/96
                KillTimer(hwnd, TIMER_ID);
                return(TRUE);            

            case PSN_APPLY:
                FORWARD_WM_COMMAND( hwnd, ID_APPLY, 0, 0, SendMessage );
                return(TRUE);

            case PSN_SETACTIVE:
                FORWARD_WM_COMMAND( hwnd, ID_INIT, 0, 0, SendMessage );
// ADDED CML 7/03/96
                // PSN_SETACTIVE gets sent for the first page on loading of the sheet, 
                // even if that page is not displayed
                // check to see if we have been loaded
                if( !fIsLoaded )
                {
                    fIsLoaded=1; break;
                }

                return(TRUE);

            case PSN_RESET:
                FORWARD_WM_COMMAND( hwnd, IDCANCEL, 0, 0, SendMessage );
                return(TRUE);
            }
            break;
        }
    default:
        break;
    }
    return(FALSE);

} /* JoystickDlg */


/***************************************************************************
 
 
  GLOBAL JOYSTICK DATA FUNCTIONS FOLLOW
 
 
 ***************************************************************************/

// default joysticks
#define TYPE00  0
#define TYPE01  0
#define TYPE02  0
#define TYPE03  0
#define TYPE04  JOY_HWS_ISGAMEPAD
#define TYPE05  JOY_HWS_ISYOKE
#define TYPE06  JOY_HWS_HASZ | JOY_HWS_ISYOKE
#define TYPE07  JOY_HWS_HASZ
#define TYPE08  JOY_HWS_HASZ
#define TYPE09  JOY_HWS_ISGAMEPAD
#define TYPE10  JOY_HWS_ISYOKE
#define TYPE11  JOY_HWS_HASZ | JOY_HWS_ISYOKE

static JOYREGHWCONFIG _joyHWDefaults[] =
{
    { {TYPE00,0},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_NONE},
    { {TYPE01,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_CUSTOM},
    { {TYPE02,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2A_2B_GENERIC},
    { {TYPE03,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2A_4B_GENERIC},
    { {TYPE04,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2B_GAMEPAD},
    { {TYPE05,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2B_FLIGHTYOKE},
    { {TYPE06,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_2B_FLIGHTYOKETHROTTLE},
    { {TYPE07,2},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_3A_2B_GENERIC},
    { {TYPE08,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_3A_4B_GENERIC},
    { {TYPE09,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_4B_GAMEPAD},
    { {TYPE10,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_4B_FLIGHTYOKE},
    { {TYPE11,4},JOY_US_PRESENT,{{0,0,0,0,0,0,0,0,0},{0,0,0,0}},JOY_HW_4B_FLIGHTYOKETHROTTLE},
};

// registry strings for calibration messages
static LPSTR _oemCalRegStrs[] =
{
    REGSTR_VAL_JOYOEMCAL1,
    REGSTR_VAL_JOYOEMCAL2,
    REGSTR_VAL_JOYOEMCAL3,
    REGSTR_VAL_JOYOEMCAL4,
    REGSTR_VAL_JOYOEMCAL5,
    REGSTR_VAL_JOYOEMCAL6,
    REGSTR_VAL_JOYOEMCAL7,
    REGSTR_VAL_JOYOEMCAL8,
    REGSTR_VAL_JOYOEMCAL9,
    REGSTR_VAL_JOYOEMCAL10,
    REGSTR_VAL_JOYOEMCAL11,
    REGSTR_VAL_JOYOEMCAL12,
};

/*
 * base registry keys
 */
static char szCfgKey[] = REGSTR_PATH_JOYCONFIG "\\";
static char szCurrCfgKey[] = "\\" REGSTR_KEY_JOYCURR;
static char szSettingsCfgKey[] = "\\" REGSTR_KEY_JOYSETTINGS;

// freeOEMListItem - free a list of oem data
static void freeOEMListItem( LPJOYDATA pjd, int i )
{
    int j;

    DoFree( pjd->oemList[i].keyname );
    DoFree( pjd->oemList[i].ident_string );
    DoFree( pjd->oemList[i].vxd_name );
    DoFree( pjd->oemList[i].xy_label );
    DoFree( pjd->oemList[i].z_label );
    DoFree( pjd->oemList[i].r_label );
    DoFree( pjd->oemList[i].u_label );
    DoFree( pjd->oemList[i].v_label );
    DoFree( pjd->oemList[i].pov_label );
    DoFree( pjd->oemList[i].testmove_desc );
    DoFree( pjd->oemList[i].testbutton_desc );
    DoFree( pjd->oemList[i].testmove_cap );
    DoFree( pjd->oemList[i].testbutton_cap );
    DoFree( pjd->oemList[i].testwin_cap );
    DoFree( pjd->oemList[i].cal_cap );
    DoFree( pjd->oemList[i].calwin_cap );
    for( j=0;j<NUM_CAL_STRS;j++ )
    {
        DoFree( pjd->oemList[i].cal_strs[j] );
    }

} /* freeOEMListItem */

/*
 * initHWDefaults - initialize the hardware list: use defaults + OEM types
 *          defined in the registry
 */
static void initHWDefaults( LPJOYDATA pjd )
{
    assert(pjd);

    int         list_size;
    int         def_size;
    DWORD       isubkey;
    DWORD       keyidx;
    HKEY        hkey;
    HKEY        hsubkey;
    char        str[MAX_STR];
    DWORD       clsize;
    DWORD       num_subkeys;
    DWORD       dont_care;
    DWORD       longest_key;
    FILETIME        ftime;
    LPSTR       keyname;
    JOYREGHWSETTINGS    hws;
    DWORD       longest_val;
    DWORD       type;
    DWORD       cb;
    int         i;
    int         j;
    int         ctype;
    LPSTR       tmpstr;
    int         fail;

    def_size = sizeof( _joyHWDefaults )/sizeof( _joyHWDefaults[0] );
    list_size = def_size;
    pjd->oemCount = 0;
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYOEM, &hkey ) )
    {
        clsize = sizeof( str );
        if( !RegQueryInfoKey ( hkey, str, &clsize, NULL, &num_subkeys,
                               &longest_key, &dont_care, &dont_care, &dont_care,
                               &dont_care, // address of buffer for longest value data length
                               &dont_care, &ftime ) )
        {
            pjd->oemList = (OEMLIST *)DoAlloc( num_subkeys * sizeof( OEMLIST ));
            if( pjd->oemList != NULL )
            {
                pjd->oemCount = num_subkeys;
                list_size += num_subkeys;
            }
            longest_key++;
        }
    }

    pjd->joyHWDefaults = (struct joyreghwconfig_tag *) DoAlloc( list_size * sizeof( JOYREGHWCONFIG ) );
    if( pjd->joyHWDefaults == NULL )
    {
        pjd->joyHWDefaults = _joyHWDefaults;
    } else
    {
        memcpy( pjd->joyHWDefaults, _joyHWDefaults, def_size * sizeof( JOYREGHWCONFIG ) );
        /*
         * if we have keys in the registry, go fetch them
         */
        if( list_size > def_size )
        {
            isubkey = 0;
            keyidx = 0;
            keyname = (char *) DoAlloc( longest_key );
            if( keyname == NULL )
            {
                keyname = str;
                longest_key = sizeof( str );
            }
            /*
             * run through all keys, getting the info on them
             */
            while( !RegEnumKey( hkey, keyidx, keyname, longest_key ) )
            {
                if( !RegOpenKey( hkey, keyname, &hsubkey ) )
                {
                    if( !RegQueryInfoKey ( hsubkey, str, &clsize, NULL,
                                           &dont_care, &dont_care, &dont_care, &dont_care,
                                           &dont_care, &longest_val, &dont_care, &ftime ) )
                    {
                        pjd->oemList[isubkey].keyname = (char *)DoAlloc( strlen( keyname ) +1 );
                        tmpstr = (char *) DoAlloc( longest_val+1 );
                        if( pjd->oemList[isubkey].keyname != NULL && tmpstr != NULL )
                        {
                            lstrcpy( pjd->oemList[isubkey].keyname, keyname );
                            cb = sizeof( hws );
                            if( !RegQueryValueEx( hsubkey, REGSTR_VAL_JOYOEMDATA, NULL,
                                                  &type, (CONST LPBYTE)&hws, &cb) )
                            {
                                if( type == REG_BINARY && cb == sizeof( hws ) )
                                {
                                    pjd->oemList[isubkey].hws = hws;
                                }
                            }
                            fail = 0;
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMCALLOUT,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].vxd_name );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMNAME,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].ident_string );
                            for( j=0;j<NUM_CAL_STRS;j++ )
                            {
                                fail |= regGetOEMStr( hsubkey, _oemCalRegStrs[j],
                                                      tmpstr, longest_val,
                                                      &pjd->oemList[isubkey].cal_strs[j] );
                            }
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMXYLABEL,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].xy_label );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMZLABEL,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].z_label );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMRLABEL,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].r_label );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMULABEL,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].u_label );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMVLABEL,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].v_label );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMPOVLABEL,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].pov_label );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTMOVEDESC,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].testmove_desc );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTBUTTONDESC,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].testbutton_desc );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTMOVECAP,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].testmove_cap );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTBUTTONCAP,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].testbutton_cap );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMTESTWINCAP,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].testwin_cap );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMCALCAP,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].cal_cap );
                            fail |= regGetOEMStr( hsubkey, REGSTR_VAL_JOYOEMCALWINCAP,
                                                  tmpstr, longest_val,
                                                  &pjd->oemList[isubkey].calwin_cap );
                            if( fail )
                            {
                                freeOEMListItem( pjd, isubkey );
                            } else
                            {
                                isubkey++;
                            }
                        } else
                        {
                            DoFree( pjd->oemList[isubkey].keyname );
                        }
                        DoFree( tmpstr );
                        RegCloseKey( hsubkey );
                    }
                }
                keyidx++;
            }
            pjd->oemCount = isubkey;

            /*
             * sort the list, and then fill in the joyHWDefault array
             */
            if( pjd->oemCount > 0 )
            {
                for( i=0;i<pjd->oemCount;i++ )
                {
                    for( j=i;j<pjd->oemCount;j++ )
                    {
                        OEMLIST ol;
                        if( lstrcmp( pjd->oemList[i].ident_string,
                                     pjd->oemList[j].ident_string ) > 0 )
                        {
                            ol = pjd->oemList[i];
                            pjd->oemList[i] = pjd->oemList[j];
                            pjd->oemList[j] = ol;
                        }
                    }
                }
                for( i=0;i<pjd->oemCount;i++ )
                {
                    ctype = i+JOY_HW_LASTENTRY;
                    memset( &pjd->joyHWDefaults[ctype], 0,
                            sizeof( pjd->joyHWDefaults[ctype] ) );
                    pjd->joyHWDefaults[ctype].hws = pjd->oemList[i].hws;
                    pjd->joyHWDefaults[ctype].dwUsageSettings = JOY_US_ISOEM|JOY_US_PRESENT;
                    pjd->joyHWDefaults[ctype].dwType = ctype;
                }
            }
            if( keyname != str )
            {
                DoFree( keyname );
            }
        }
    }

} /* initHWDefaults */

/*
 * finiHWList - finished with the hardware list, free it
 */
static void finiHWList( LPJOYDATA pjd )
{
    int i;

    assert(pjd);

    if( pjd->joyHWDefaults != NULL )
    {
        if( pjd->joyHWDefaults != _joyHWDefaults )
        {
            DoFree( pjd->joyHWDefaults );
        }
        pjd->joyHWDefaults = NULL;
    }
    if( pjd->oemList != NULL )
    {
        for( i=0;i<pjd->oemCount;i++ )
        {
            freeOEMListItem( pjd, i );
        }
        DoFree( pjd->oemList );
        pjd->oemList = NULL;
        pjd->oemCount = 0;
    }

} /* finiHWList */

/*
 * getRegKeys - get the registry keys we need
 */
static void getRegKeys( LPJOYDATA pjd )
{
    JOYCAPS jc;
    int     len;

    assert(pjd);

    /*
     * call with magic ID of -1, which retrieves base info without
     * checking for anything joystick specific
     */
    joyGetDevCaps( (UINT) -1, &jc, sizeof( jc ) );

    // set up registry keys
    pjd->regCfgKey = NULL;
    pjd->regCurrCfgKey = NULL;
    pjd->regSettingsCfgKey = NULL;

    len = sizeof( szCfgKey ) + strlen( jc.szRegKey );
    pjd->regCfgKey = (char *) DoAlloc( len );
    if( pjd->regCfgKey != NULL )
    {
        lstrcpy( pjd->regCfgKey, szCfgKey );
        lstrcpy( &pjd->regCfgKey[ sizeof( szCfgKey ) - 1], jc.szRegKey );
        pjd->regCurrCfgKey = (char *)DoAlloc( len + sizeof( szCurrCfgKey ) - 1 );
        if( pjd->regCurrCfgKey != NULL )
        {
            lstrcpy( pjd->regCurrCfgKey, pjd->regCfgKey );
            lstrcpy( &pjd->regCurrCfgKey[ len-1 ], szCurrCfgKey );
        }
        pjd->regSettingsCfgKey = (char *)DoAlloc( len + sizeof( szSettingsCfgKey ) - 1 );
        if( pjd->regSettingsCfgKey != NULL )
        {
            lstrcpy( pjd->regSettingsCfgKey, pjd->regCfgKey );
            lstrcpy( &pjd->regSettingsCfgKey[ len-1 ], szSettingsCfgKey );
        }
    }

} /* getRegKeys */

/*
 * JoystickDataInit
 */
LPJOYDATA JoystickDataInit( void )
{
    LPJOYDATA   pjd;

    pjd = (JOYDATA *) DoAlloc( sizeof( JOYDATA ) );
    assert(pjd);
    if( pjd == NULL )
        return(NULL);

    // go set up all our defaults + oem lists
    initHWDefaults( pjd );

    // get registry keys used by everyone
    getRegKeys( pjd );

    // brushes for use by button display and bar display (z & r info)
    pjd->hbUp   = CreateSolidBrush( ACTIVE_COLOR   );
    pjd->hbDown = CreateSolidBrush( INACTIVE_COLOR );

    // set up user values we like
    regUserValsInit( pjd );

#if !defined( WANT_SHEETS )
    {
        // set up array of "global" vars (global to a joystick id)
        int     numjoys;
        int     i;

        numjoys = joyGetNumDevs();
        if( numjoys == 0 )
        {
            // blj: I'd love to have called JoyError Here, but we don't have a
            // valid window handle to pass it!
            char szTitle[STR_LEN_32];
            char szMessage[STR_LEN_128];

            if( LoadString(GetResourceInstance(), IDS_JOYREADERROR, szTitle, sizeof(szTitle)) == 0 )
            {
                OutputDebugString (TEXT("GCDEF.DLL: Unable to load string IDS_JOYREADERROR!\n"));
                return(NULL);
            }

            if( LoadString(GetResourceInstance(), IDS_JOYUNPLUGGED, szMessage, sizeof(szMessage)) == 0 )
            {
                OutputDebugString (TEXT("GCDEF.DLL: Unable to load string IDS_JOYUNPLUGGED!\n"));
                return(NULL);
            }

            MessageBox( NULL, szMessage, szTitle, MB_OK | MB_ICONERROR | MB_TASKMODAL );

            return(NULL);
        }

        pjd->pgvlist = (_GLOBALVARS *)DoAlloc( sizeof( GLOBALVARS ) * numjoys );
        if( pjd->pgvlist == NULL )
            return(NULL);

        for( i=0;i<numjoys;i++ )
        {
            pjd->pgvlist[i].iJoyId = i;
            pjd->pgvlist[i].pjd = pjd;
            initCurrentHW( &pjd->pgvlist[i] );
        }

    }
#endif
    return(pjd);

} /* JoystickDataInit */

/*
 * JoystickDataFini - finished with DLL wide joystick data data
 */
void JoystickDataFini( LPJOYDATA pjd )
{
    assert(pjd);

    // ditch brushes
    if( pjd->hbUp != NULL )
        DeleteObject( pjd->hbUp );

    if( pjd->hbDown != NULL )
        DeleteObject( pjd->hbDown );

    // done with hardware list
    finiHWList( pjd );

    // restore user values in registry
    regUserValsFini( pjd );

    // done with registry keys
    DoFree( pjd->regCfgKey );
    DoFree( pjd->regCurrCfgKey );
    DoFree( pjd->regSettingsCfgKey );

#if !defined( WANT_SHEETS )
    DoFree( pjd->pgvlist );
#endif

    // free up the joystick data
    DoFree( pjd );
#ifdef DEBUG
    if( allocCount != 0 )
        MBOX( "Memory left unfreed: %d allocations", allocCount );
#endif

} /* JoystickDataFini */


////////////////////////////////////////////////////////////////////////////////////////
//  OnContextMenu(WPARAM wParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam)
{
    short nSize = STR_LEN_32;

    // point to help file
    char *pszHelpFileName = new char[nSize];
    ASSERT (pszHelpFileName);                      

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (DWORD)gaHelpIDs);

    if( pszHelpFileName ) delete[] (pszHelpFileName);
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION:    GetHelpFileName(LPSTR lpszHelpFileName)
//
// PURPOSE:     Populates lpszHelpFileName with the Help File Name from the registry
//
// RETURN:      ERROR_SUCCESS if successfull, -1 otherwise
///////////////////////////////////////////////////////////////////////////////

LRESULT GetHelpFileName(LPSTR lpszHelpFileName, short* nSize)
{
    if( LoadString(GetResourceInstance(), IDS_HELPFILENAME, lpszHelpFileName, *nSize) )
        return(S_OK);
    else
        return(E_FAIL);
}

void OnHelp(LPARAM lParam)
{                  
    ASSERT ( lParam );

    short nSize = STR_LEN_32;

    // point to help file
    char *pszHelpFileName = new char[nSize];
    ASSERT (pszHelpFileName);

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    LPHELPINFO lphi = (LPHELPINFO)lParam;
    if( lphi->iContextType==HELPINFO_WINDOW )
        WinHelp((HWND)lphi->hItemHandle, pszHelpFileName, HELP_WM_HELP, (DWORD)gaHelpIDs);

    if( pszHelpFileName ) delete[] (pszHelpFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\pinfo.h ===
//----------- Packet Info structure -------------
typedef struct _PACKETINFO
{
   DWORD iMode;			      // Interface mode. (see below defs)
   DWORD port;                // game port.
	DWORD Flags;			      // acquistion flags.
	DWORD nPackets;		      // number of packets
	DWORD TimeStamp;		      // last valid acquisition time stamp
	DWORD nClocksSampled;      // number of clocks sampled.
	DWORD nB4Transitions;      // number of B4 line transitions (std mode only).
	DWORD StartTimeout;        // Start timeout period (in samples).
	DWORD HighLowTimeout;      // Clock High to Low timeout period (in samples).
	DWORD LowHighTimeout;      // Clock Low to High timeout period (in samples).
	DWORD InterruptDelay;      // Delay between INTXA interrupts.
	DWORD nFailures;		      // Number of Packet Failures.
	DWORD nAttempts;		      // Number of Packet Attempts.
   DWORD nBufSize;            // size of Raw data buffer.
	DWORD *pData;      	      // pointer to Raw data (DWORD aligned).
} PACKETINFO, *PPACKETINFO;

//--------- Interface MODES ---------------------
#define IMODE_DIGITAL_STD     0        // Standard Digital Mode.
#define IMODE_DIGITAL_ENH     4        // Enhanced Digital Mode.
#define IMODE_ANALOG          8        // Analog Mode.
#define IMODE_NONE            -1       // Joystick Disconnected.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\joycpl.h ===
//****************************************************************************
//
//  File:       joycpl.h
//  Content:    Joystick cpl header file
//  History:
//   Date	By	Reason
//   ====	==	======
//   29-nov-94	craige	initial implementation
//   15-dec-94	craige	allow N joysticks
//
//  Copyright (c) Microsoft Corporation 1994, 1995
//
//****************************************************************************
#ifndef __JOYCPL_INCLUDED__
#define __JOYCPL_INCLUDED__

#include <windows.h>
#include <windowsx.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <stdlib.h>
#include <regstr.h>
#include <cpl.h>
#include "rcids.h"                      

//#define WANT_SHEETS

//#ifdef DEBUG
//    void cdecl dprintf( LPSTR szFormat, ... );
//    #define DPF	dprintf
	#define DPF	TRACE	
//#else
//    #define DPF 1 ? (void)0 : (void)
//#endif

/*
 * misc. defines
 */
#define HASJOY 		0x01
#define HASRUDDERMAYBE	0x02

#define ACTIVE_COLOR	RGB( 255, 0, 0 )
#define INACTIVE_COLOR	RGB( 128, 0, 0 )

#define TIMER_ID	1

#define MAX_STR_LEN	 255
#define STR_LEN_128	 128
#define STR_LEN_64	 64
#define STR_LEN_32	 32

#define JOYPOLLTIME	25		// time between polls in milliseconds
#define JOYCHECKTIME	2500		// time between hw check in milliseconds
#define MAX_STR		256		// max size for string resources
#define ALL_BUTTONS	(JOY_BUTTON1  | \
					 JOY_BUTTON2  | \
					 JOY_BUTTON3  | \
					 JOY_BUTTON4  | \
					 JOY_BUTTON5  | \
					 JOY_BUTTON6  | \
					 JOY_BUTTON7  | \
					 JOY_BUTTON8  | \
					 JOY_BUTTON9  | \
					 JOY_BUTTON10 | \
					 JOY_BUTTON11 | \
					 JOY_BUTTON12 | \
					 JOY_BUTTON13 | \
					 JOY_BUTTON14 | \
					 JOY_BUTTON15 | \
					 JOY_BUTTON16 | \
					 JOY_BUTTON17 | \
					 JOY_BUTTON18 | \
					 JOY_BUTTON19 | \
					 JOY_BUTTON20 | \
					 JOY_BUTTON21 | \
					 JOY_BUTTON22 | \
					 JOY_BUTTON23 | \
					 JOY_BUTTON24 | \
					 JOY_BUTTON25 | \
					 JOY_BUTTON26 | \
					 JOY_BUTTON27 | \
					 JOY_BUTTON28 | \
					 JOY_BUTTON29 | \
					 JOY_BUTTON30 | \
					 JOY_BUTTON31 | \
					 JOY_BUTTON32 )

#define GETKEYNAME( pgv, str, keystr ) wsprintf( str, keystr, pgv->iJoyId+1 )

#define JOYMOVE_DRAWXY	0x00000001
#define JOYMOVE_DRAWR	0x00000002
#define JOYMOVE_DRAWZ	0x00000004
#define JOYMOVE_DRAWU	0x00000008
#define JOYMOVE_DRAWV	0x00000010
#define JOYMOVE_DRAWALL	JOYMOVE_DRAWXY | JOYMOVE_DRAWR | JOYMOVE_DRAWZ | \
			JOYMOVE_DRAWU | JOYMOVE_DRAWV

/*
 * calibration strings defined by an OEM in the registry
 */
enum {
    CALSTR1=0,
    CALSTR2,
    CALSTR3,
    CALSTR4,
    CALSTR5,
    CALSTR6,
    CALSTR7,
    CALSTR8,
    CALSTR9,
    CALSTR10,
    CALSTR11,
    CALSTR12,
    CALSTR_END
};
#define NUM_CAL_STRS	CALSTR_END

/*
 * structure for holding all OEM data in the registry
 */
typedef struct {
    LPSTR		keyname;
    LPSTR		ident_string;
    LPSTR		vxd_name;
    LPSTR		xy_label;
    LPSTR		z_label;
    LPSTR		r_label;
    LPSTR		u_label;
    LPSTR		v_label;
    LPSTR		pov_label;
    LPSTR		testmove_desc;
    LPSTR		testbutton_desc;
    LPSTR		testmove_cap;
    LPSTR		testbutton_cap;
    LPSTR		testwin_cap;
    LPSTR		cal_cap;
    LPSTR		calwin_cap;
    LPSTR		cal_strs[NUM_CAL_STRS];
    JOYREGHWSETTINGS	hws;
} OEMLIST;

/*
 * generic joystick data
 */
typedef struct {
    LPJOYREGHWCONFIG	joyHWDefaults;
    OEMLIST		*oemList;
    int			oemCount;
    BOOL		bHasUserVals;
    BOOL		bDeleteUserVals;
    JOYREGUSERVALUES	userVals;
    LPSTR		regCfgKey;
    LPSTR		regCurrCfgKey;
    LPSTR		regSettingsCfgKey;
    HBRUSH		hbUp;
    HBRUSH		hbDown;
    BOOL		bHasTimer;
    BOOL		bUseTimer;
    #if !defined( WANT_SHEETS )
	struct _GLOBALVARS *pgvlist;
    #endif
    BOOL		bResetUserVals;
    BOOL		bHasNonStandardUserVals;
} JOYDATA, *LPJOYDATA;

/*
 * structure passed to each sheet
 */
typedef struct {
    LPJOYDATA	pjd;
    int		iJoyId;
} JOYDATAPTR, *LPJOYDATAPTR;

/*
 * structure defining all variables used globally by a tab
 */
typedef struct _GLOBALVARS {
    LPJOYDATA		pjd;
    JOYREGHWCONFIG	joyHWCurr;
    JOYREGHWCONFIG	joyHWOrig;
    JOYRANGE		joyRange;
    BOOL		bOrigPOVIsPoll;
    BOOL		bOrigPOVIsButtonCombos;
    DWORD		dwMaxAxes;
    int			iJoyId;
    /* these vars only used by the sheet */
    unsigned 		joyActiveFlags;
} GLOBALVARS, *LPGLOBALVARS;

/*
 * function prototypes
 */
/* joycal.c */
void DoCalibrate( LPGLOBALVARS pgv, HWND hwnd );

/* joycpl.c */
BOOL CALLBACK JoystickDlg( HWND	hwnd, UINT umsg, WPARAM wParam, LPARAM lParam);
LPVOID DoAlloc( DWORD size );
void DoFree( LPVOID ptr );
void RegistryUpdated( LPGLOBALVARS pgv );
void GetDevCaps( LPGLOBALVARS pgv );
void RegSaveCurrentJoyHW( LPGLOBALVARS pgv );
LPJOYDATA JoystickDataInit( void );
void JoystickDataFini( LPJOYDATA pjd );
LRESULT GetHelpFileName(LPSTR lpszHelpFileName, short* ulSize);
void OnHelp(LPARAM lParam);
#ifdef DEBUG
void cdecl MBOX(LPSTR szFormat, ...);
#endif

/* joymisc.c */
BOOL JoyError( HWND hwnd );
void ChangeIcon( HWND hwnd, int idi, int idc );
void CauseRedraw( LPJOYINFOEX pji, BOOL do_buttons );
void SetOEMText( LPGLOBALVARS pgv, HWND hwnd, BOOL istest );
void ShowControls( LPJOYREGHWCONFIG pcfg, HWND hwnd );
void DoJoyMove( LPGLOBALVARS pgv, HWND hwnd, LPJOYINFOEX pji, LPJOYINFOEX poji, DWORD drawflags );

/* joytest.c */
typedef void (*LPUPDCFGFN)( LPVOID parm );
void DoTest( LPGLOBALVARS pgv, HWND hwnd, LPUPDCFGFN pupdcfgfn, LPVOID pparm );
BOOL CALLBACK TestProc( HWND hwnd, UINT umsg, WPARAM wParam, LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\joyhelp.h ===
#define IDH_4101_12293	805638149	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12308	806621189	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12309	806686725	// Joystick Calibration: "f" (Static)
#define IDH_4101_12328	807931909	// Joystick Calibration: "Capture &POV" (Button)
#define IDH_4101_12329	807997445	// Joystick Calibration: "< &Back" (Button)
#define IDH_4101_12330	808062981	// Joystick Calibration: "&Next >" (Button)
#define IDH_4101_12334	808325125	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12347	809177093	// Joystick Calibration: "" (ListBox)
#define IDH_4101_12349	809308165	// Joystick Calibration: "" (ListBox)
#define IDH_4201_1019	66785385	// Settings: "If you have attached a rudder or pedals to your controller, select the check box below." (Static)
#define IDH_4201_12291	805507177	// Settings: "&Calibrate..." (Button)
#define IDH_4202_8199	537333866	// Game Controller Calibration: "Calibration Information" (Button)
#define IDH_4202_12293	805638250	// Game Controller Calibration: "" (ListBox)
#define IDH_4202_12308	806621290	// Game Controller Calibration: "" (ListBox)
#define IDH_4202_12328	807932010	// Game Controller Calibration: "Set &POV" (Button)
#define IDH_4202_12329	807997546	// Game Controller Calibration: "<&Back" (Button)
#define IDH_4202_12330	808063082	// Game Controller Calibration: "&Next>" (Button)
#define IDH_4202_12334	808325226	// Game Controller Calibration: "" (ListBox)
#define IDH_4203_1023	67047531	// -: "Buttons" (Button)
#define IDH_4203_12293	805638251	// -: "" (ListBox)
#define IDH_4203_12308	806621291	// -: "" (ListBox)
#define IDH_4203_12309	806686827	// -: "" (POVHAT)
#define IDH_4203_12334	808325227	// -: "" (ListBox)
#define IDH_4203_12347	809177195	// -: "" (ListBox)
#define IDH_4203_12349	809308267	// -: "" (ListBox)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\joycal.cpp ===
//****************************************************************************
//
//  File:       joycal.c
//  Content:    Joystick calibration dialog
//  History:
//   Date	By	Reason
//   ====	==	======
//   11-dec-94	craige	split out of joycpl.c; some tweaks
//   15-dec-94	craige	allow N joysticks
//   17-dec-94	craige	new UI as requested by ChrisB
//   18-dec-94	craige	process UV
//   05-jan-95	craige	new centering confirmation messages
//   04-mar-95	craige	bug 10761 - separate strings for pluralization
//			bug 12036 - now works when "Back" clicked off of
//				    custom 4-axis with POV hat
//
//  Copyright (c) Microsoft Corporation 1994-1995
//
//****************************************************************************

#pragma pack (8)

#include "stdafx.h"
#include "joycpl.h"
#include "resource.h"
#include "pov.h"
#include "assert.h"

#include "baseids.h"

#include "comstr.h"

#undef	NewLoadString
#define NewLoadString(a, b, c, d)     \
	pszCommonString->LoadString(b); \
	lstrcpy( c, (LPCTSTR)*pszCommonString )

// Context sensitive help stuff!
static void OnContextMenu(WPARAM wParam);
static void OnHelp       (LPARAM);

static const DWORD CalibrateHelpIDs[] =
{
    IDC_JOYLIST1,  IDC_JOYLIST1,
    IDC_JOYLIST2,  IDC_JOYLIST2,
    IDC_JOYLIST3,  IDC_JOYLIST3,
    IDC_JOYLIST4,  IDC_JOYLIST4,
    0,  0
};



/*
 * This has the look and feel of a wizard, but isn't   This leads to the
 * obvious...
 *
 * Q: Why isn't this a "real" wizard?
 *
 * A: - it doesn't have multiple pages, it has a single page.  the user
 *	sees different joystick items activate and de-activate on the dialog
 *	as he/she calibrates each axis. fussing with multiple sheets for each
 *	axis would be confusing and unnecessary.
 */

/*
 * calibration states
 */
// %%% debug %%% alpha days
extern "C"
{
    typedef enum
    {
        JCS_INIT=-1,
        JCS_XY_CENTER1,
        JCS_XY_MOVE,
        JCS_XY_CENTER2,
        JCS_Z_MOVE,
        JCS_Z_PLACEHOLDER,
        JCS_R_MOVE,
        JCS_R_PLACEHOLDER,
        JCS_U_MOVE,
        JCS_U_PLACEHOLDER,
        JCS_V_MOVE,
        JCS_V_PLACEHOLDER,
        JCS_POV_MOVEUP,
        JCS_POV_MOVERIGHT,
        JCS_POV_MOVEDOWN,
        JCS_POV_MOVELEFT,
        JCS_FINI
    } cal_states;

    typedef enum
    {
        JC_XY=0,
        JC_Z,
        JC_POV_UP,
        JC_POV_RIGHT,
        JC_POV_DOWN,
        JC_POV_LEFT,
        JC_R,
        JC_U,
        JC_V,
        JC_FINI
    } cal_wins;

// variables used in calibration
    typedef struct
    {
        LPGLOBALVARS    pgv;
        cal_states      cState;
        BOOL        bHasTimer;
        BOOL        bUseTimer;
        HINSTANCE       hinst;
        JOYINFOEX       ji;
        JOYRANGE        jr;
        DWORD       pov[JOY_POV_NUMDIRS];
        int         iAxisCount;
        BOOL        bPOVdone;
    } CALVARS, *LPCALVARS;

    extern "C" WINMMAPI MMRESULT WINAPI joyConfigChanged(DWORD);


#define JOY_CALIB_FLAGS	JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | \
			JOY_RETURNR | JOY_RETURNU | JOY_RETURNV | \
			JOY_RETURNBUTTONS | JOY_RETURNRAWDATA

/*
 * we use raw data during calibration; RAW_SHIFT allows us to convert to
 * a reasonable "real" value
 */
#define RAW_SHIFT	100
} // extern "C"

// setDefaultButton - make a button the default window
static void setDefaultButton( HWND hwnd, HWND hwdb )
{
    // Optimized New Method
    SendMessage(hwnd, WM_NEXTDLGCTL, (WPARAM)hwdb, (LPARAM)TRUE);

/* Optimized Old Method
   DWORD	style;
   HWND	hCtrl;
   int	idList[] = { IDC_JOYCALDONE, IDC_JOYCALNEXT,
                      IDC_JOYCALBACK, IDC_JOYPICKPOV };
   #define SIZEOF_LIST 4

    // turn off the current default push button
   for (short i=0; i < SIZEOF_LIST; i++ ) 
    {
        hCtrl = GetDlgItem( hwnd, idList[i] );

      if (hCtrl)
      {
        style = GetWindowLong( hCtrl, GWL_STYLE );

        if ( style & BS_DEFPUSHBUTTON ) 
           {
               style &= ~BS_DEFPUSHBUTTON;
           style |= BS_PUSHBUTTON;
           SetWindowLong( hCtrl, GWL_STYLE, style );
            break;
           }
      }
    }

   // make the specified button the default
   style = GetWindowLong( hwdb, GWL_STYLE );
   style &= ~(BS_PUSHBUTTON|BS_DEFPUSHBUTTON);
   style |= BS_DEFPUSHBUTTON;
   SetWindowLong( hwdb, GWL_STYLE, style );
*/

} // setDefaultButton 

/*
 * setLabel
 *
 * set the label for an axis based on current calibration state
 */
static void setLabel(
                    LPGLOBALVARS pgv,
                    HWND hwnd,
                    UINT id,
                    LPJOYREGHWCONFIG pcfg,
                    DWORD bit  )
{
    char        str[MAX_STR];
    int         type;
    HINSTANCE   hinst;
    HWND        hwtext;

    hinst = GetResourceInstance( );
    assert(hinst);

    // get text for this axis label...
    if( pcfg->dwUsageSettings & JOY_US_ISOEM )
    {
        type = pcfg->dwType - JOY_HW_LASTENTRY;
        if( type < 0 || type >= pgv->pjd->oemCount )
        {
            type = -1;
        }
    } else
    {
        type = -1;
    }

    switch( id )
    {
    case IDC_JOYLIST1_LABEL:
        if( (type == -1) || (pgv->pjd->oemList[type].xy_label[0] == 0) )
        {
            NewLoadString( hinst, IDS_XYAXIS_LABEL, str, sizeof( str ) );
            if( !lstrlen(str) ) return;
        } else lstrcpy( str, pgv->pjd->oemList[type].xy_label );
        break;

    case IDC_JOYLIST2_LABEL:
        if( (type == -1) || (pgv->pjd->oemList[type].z_label[0] == 0 ) )
        {
            NewLoadString( hinst, IDS_ZAXIS_LABEL, str, sizeof( str ) );
            if( !lstrlen(str) ) return;
        } else lstrcpy( str, pgv->pjd->oemList[type].z_label );
        break;

    case IDC_JOYLIST3_LABEL:
        if( (type == -1) || (pgv->pjd->oemList[type].r_label[0] == 0) )
        {
            NewLoadString( hinst, IDS_RAXIS_LABEL, str, sizeof( str ) );
            if( !lstrlen(str) ) return;
        } else lstrcpy( str, pgv->pjd->oemList[type].r_label );
        break;

    case IDC_JOYLIST4_LABEL:
        if( (type == -1) || (pgv->pjd->oemList[type].u_label[0] == 0) )
        {
            NewLoadString( hinst, IDS_UAXIS_LABEL, str, sizeof( str ) );
            if( !lstrlen(str) ) return;
        } else lstrcpy( str, pgv->pjd->oemList[type].u_label );
        break;

    case IDC_JOYLIST5_LABEL:
        if( (type == -1) || (pgv->pjd->oemList[type].v_label[0] == 0) )
        {
            NewLoadString( hinst, IDS_VAXIS_LABEL, str, sizeof( str ) );
            if( !lstrlen(str) ) return;
        } else lstrcpy( str, pgv->pjd->oemList[type].v_label );
        break;

    case IDC_JOYPOV_LABEL:
        if( (type == -1) || (pgv->pjd->oemList[type].pov_label[0] == 0) )
        {
            NewLoadString( hinst, IDS_POVAXIS_LABEL, str, sizeof( str ) );
            if( !lstrlen(str) ) return;
        } else lstrcpy( str, pgv->pjd->oemList[type].pov_label );
        break;
    }

    hwtext = GetDlgItem( hwnd, id );
    ASSERT (::IsWindow(hwtext));

    if( hwtext != NULL )
        SetWindowText( hwtext, str );

} /* setLabel */

// enableCalWindows - enable or disable specific calibration windows
static void enableCalWindows(
                            LPGLOBALVARS pgv,
                            LPJOYREGHWCONFIG pcfg,
                            HWND hwnd,
                            cal_wins id )
{
    BOOL        on;
    HWND        hwlb;
    HWND        hwb;
    int         iid;

    // set up the buttons
    hwb = GetDlgItem( hwnd,IDC_JOYCALDONE );
    ASSERT (hwb);

    if( id == JC_FINI )
    {
        hwlb = GetDlgItem( hwnd, IDC_JOYCALNEXT );
        ASSERT (::IsWindow(hwlb));
        ShowWindow(hwlb, SW_HIDE );

        EnableWindow( hwb, TRUE );
        ShowWindow( hwb, SW_NORMAL );
        SetFocus( hwb );
        setDefaultButton( hwnd, hwb );
    } else
    {
        hwlb = GetDlgItem( hwnd, IDC_JOYCALNEXT );
        ASSERT (::IsWindow(hwlb));
        ShowWindow( hwlb, SW_NORMAL );

        EnableWindow( hwb, FALSE );
        ShowWindow( hwb, SW_HIDE );
    }

    setLabel( pgv, hwnd, IDC_JOYLIST1_LABEL, pcfg, JOY_ISCAL_XY );

    // set up the XY window
    on = FALSE;

    if( id == JC_XY )
        on = TRUE;

    hwlb = GetDlgItem( hwnd, IDC_JOYLIST1 );
    ASSERT (::IsWindow(hwlb));

    if( !on )
        InvalidateRect( hwlb, NULL, TRUE );

    EnableWindow( hwlb, on );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST1_LABEL ), on );

    /*
     * set up the Z window
     */
    on = FALSE;
    if( id == JC_Z )
        on = TRUE;

    hwlb = GetDlgItem( hwnd, IDC_JOYLIST2 );
    if( !on )
    {
        InvalidateRect( hwlb, NULL, TRUE );
    }
    EnableWindow( hwlb, on );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST2_LABEL ), on );

    /*
     * set up the R window
     */
    on = FALSE;
    if( id == JC_R )
    {
        on = TRUE;
    }
    hwlb = GetDlgItem( hwnd, IDC_JOYLIST3 );
    if( !on )
    {
        InvalidateRect( hwlb, NULL, TRUE );
    }
    EnableWindow( hwlb, on );
    EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST3_LABEL ), on );

    /*
     * set up the U window
     */
    on = FALSE;
    if( id == JC_U )
    {
        on = TRUE;
    }
    hwlb = GetDlgItem( hwnd, IDC_JOYLIST4 );
    if( hwlb != NULL )
    {
        if( !on )
        {
            InvalidateRect( hwlb, NULL, TRUE );
        }
        EnableWindow( hwlb, on );
        EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST4_LABEL ), on );
    }

    /*
     * set up the V window
     */
    on = FALSE;
    if( id == JC_V )
    {
        on = TRUE;
    }
    hwlb = GetDlgItem( hwnd, IDC_JOYLIST5 );
    if( hwlb != NULL )
    {
        if( !on )
        {
            InvalidateRect( hwlb, NULL, TRUE );
        }
        EnableWindow( hwlb, on );
        EnableWindow( GetDlgItem( hwnd, IDC_JOYLIST5_LABEL ), on );
    }

    /*
     * set up the POV icon
     */
    on = FALSE;
    if( id >= JC_POV_UP && id <= JC_POV_LEFT )
    {
        on = TRUE;
    }
    EnableWindow( GetDlgItem( hwnd, IDC_JOYPOV_LABEL ), on );
    hwb = GetDlgItem( hwnd, IDC_JOYPICKPOV );
    EnableWindow( hwb, on );
    if( on )
    {
        ShowWindow( hwb, SW_NORMAL );
        SetFocus( hwb );
        setDefaultButton( hwnd, hwb );
        switch( id )
        {
        case JC_POV_UP:
            iid = IDI_JOYPOV_UP;
            break;
        case JC_POV_RIGHT:
            iid = IDI_JOYPOV_RIGHT;
            break;
        case JC_POV_LEFT:
            iid = IDI_JOYPOV_LEFT;
            break;
        case JC_POV_DOWN:
            iid = IDI_JOYPOV_DOWN;
            break;
        }
    } else
    {
        ShowWindow( hwb, SW_HIDE );
        UpdateWindow( hwb );
        iid = IDI_JOYPOV_GRAYED;
    }
    ChangeIcon( hwnd, iid, IDC_JOYPOV );

} /* enableCalWindows */


/*
 * getJoyName - get the name of a joystick
 */
static int getJoyName( LPJOYREGHWCONFIG pcfg, BOOL plural )
{
    int str2id;

    if( pcfg->hws.dwFlags & JOY_HWS_ISYOKE )
    {
        str2id = ( plural ) ? IDS_JOYCAL_YOKES : IDS_JOYCAL_YOKE;
    } else if( pcfg->hws.dwFlags & JOY_HWS_ISCARCTRL )
    {
        str2id = ( plural ) ? IDS_JOYCAL_CARS : IDS_JOYCAL_CAR;
    } else if( pcfg->hws.dwFlags & JOY_HWS_ISGAMEPAD )
    {
        str2id = ( plural ) ? IDS_JOYCAL_GAMEPADS : IDS_JOYCAL_GAMEPAD;
    } else
    {
        str2id = ( plural ) ? IDS_JOY2S : IDS_JOY2;
    }

    return(str2id);

} /* getJoyName */

/*
 * joyCalStateChange - calibration state change
 */
static BOOL joyCalStateChange( LPCALVARS pcv, HWND hwnd, BOOL back )
{
    HINSTANCE       hinst;
    HWND        hwtext;
    int         strid;
    int         stridx = 0;     // BUG FIX: CML 6/21/96 (FLASH RAID 270)
    int         str2id;
    int         str3id;
    int         str4id;
    char        str[2*MAX_STR];
    char        buff[2*MAX_STR];
    char        str2[64];
    char        str3[64];
    char        str4[64];
    BOOL        done;
    LPJOYREGHWCONFIG    pcfg;
    BOOL        rc;
    int         type;
    LPGLOBALVARS    pgv;
    BOOL        isdone;

    assert(pcv);
    assert(hwnd);

    /*
     * move to the next state: get the appropriate string
     * to display, and enable the correct controls
     */
    pgv = pcv->pgv;
    assert(pgv);
    rc = TRUE;
    done = FALSE;
    pcfg = &pgv->joyHWCurr;
    str2id = -1;
    str3id = -1;
    str4id = -1;
    (pcv->cState) = (cal_states) (pcv->cState + ((cal_states) 1));
    EnableWindow( GetDlgItem( hwnd, IDC_JOYCALBACK ), back );

    while( !done )
    {
        done = TRUE;

        switch( pcv->cState )
        {
        case JCS_XY_CENTER1:
            /*
             * init. range variables
             */
            pcv->jr.jpMin.dwX = (DWORD) -1;
            pcv->jr.jpMin.dwY = (DWORD) -1;
            pcv->jr.jpMin.dwZ = (DWORD) -1;
            pcv->jr.jpMin.dwR = (DWORD) -1;
            pcv->jr.jpMin.dwU = (DWORD) -1;
            pcv->jr.jpMin.dwV = (DWORD) -1;
            pcv->jr.jpMax.dwX = 0;
            pcv->jr.jpMax.dwY = 0;
            pcv->jr.jpMax.dwZ = 0;
            pcv->jr.jpMax.dwR = 0;
            pcv->jr.jpMax.dwU = 0;
            pcv->jr.jpMax.dwV = 0;

            // set strings to display
            stridx = CALSTR1;

            if( pcfg->hws.dwFlags & JOY_HWS_ISYOKE )
            {
                strid = IDS_JOYCALXY_CENTERYOKE;
            } else if( pcfg->hws.dwFlags & JOY_HWS_ISCARCTRL )
            {
                strid = IDS_JOYCALXY_CENTERCAR;
            } else if( pcfg->hws.dwFlags & JOY_HWS_ISGAMEPAD )
            {
                strid = IDS_JOYCALXY_CENTERGAMEPAD;
            } else
            {
                strid = IDS_JOYCALXY_CENTER;
            }

            enableCalWindows( pgv, pcfg, hwnd, JC_XY );
            break;

        case JCS_XY_MOVE:
            stridx = CALSTR2;
            if( pcfg->hws.dwFlags & JOY_HWS_ISYOKE )
            {
                strid = IDS_JOYCALXY_MOVEYOKE;
            } else if( pcfg->hws.dwFlags & JOY_HWS_ISCARCTRL )
            {
                strid = IDS_JOYCALXY_MOVECAR;
            } else if( pcfg->hws.dwFlags & JOY_HWS_ISGAMEPAD )
            {
                strid = IDS_JOYCALXY_MOVEGAMEPAD;
            } else
            {
                strid = IDS_JOYCALXY_MOVE;
            }
            break;

        case JCS_XY_CENTER2:
            stridx = CALSTR3;
            if( pcfg->hws.dwFlags & JOY_HWS_ISYOKE )
            {
                strid = IDS_JOYCALXY_CENTERYOKE2;
            } else if( pcfg->hws.dwFlags & JOY_HWS_ISCARCTRL )
            {
                strid = IDS_JOYCALXY_CENTERCAR2;
            } else if( pcfg->hws.dwFlags & JOY_HWS_ISGAMEPAD )
            {
                strid = IDS_JOYCALXY_CENTERGAMEPAD2;
            } else
            {
                strid = IDS_JOYCALXY_CENTER2;
            }
            break;

        case JCS_Z_MOVE:
            stridx = CALSTR4;
            if( !(pcfg->hws.dwFlags & JOY_HWS_HASZ) )
            {
                pcv->cState = JCS_R_MOVE;
                done = FALSE;
            } else
            {
                enableCalWindows( pgv, pcfg, hwnd, JC_Z );
                strid = IDS_JOYCALZ_MOVE;
                str2id = getJoyName( pcfg, TRUE );
            }
            break;

        case JCS_Z_PLACEHOLDER:
            pcv->cState = JCS_R_MOVE;
            done = FALSE;
            break;

        case JCS_R_MOVE:
            stridx = CALSTR5;
            if( !(pcfg->hws.dwFlags & JOY_HWS_HASR) && !(pcfg->dwUsageSettings & JOY_US_HASRUDDER) )
            {
                pcv->cState = JCS_U_MOVE;
                done = FALSE;
            } else
            {
                enableCalWindows( pgv, pcfg, hwnd, JC_R );
                strid = IDS_JOYCALRUDDER_MOVE;
                str2id = getJoyName( pcfg, TRUE );
            }
            break;

        case JCS_R_PLACEHOLDER:
            pcv->cState = JCS_U_MOVE;
            done = FALSE;
            break;

        case JCS_U_MOVE:
            stridx = CALSTR6;
            if( !(pcfg->hws.dwFlags & JOY_HWS_HASU) )
            {
                pcv->cState = JCS_V_MOVE;
                done = FALSE;
            } else
            {
                enableCalWindows( pgv, pcfg, hwnd, JC_U );
                strid = IDS_JOYCALU_MOVE;
                str2id = getJoyName( pcfg, TRUE );
            }
            break;

        case JCS_U_PLACEHOLDER:
            pcv->cState = JCS_V_MOVE;
            done = FALSE;
            break;

        case JCS_V_MOVE:
            stridx = CALSTR7;
            if( !(pcfg->hws.dwFlags & JOY_HWS_HASV) )
            {
                pcv->cState = JCS_POV_MOVEUP;
                done = FALSE;
            } else
            {
                enableCalWindows( pgv, pcfg, hwnd, JC_V );
                strid = IDS_JOYCALV_MOVE;
                str2id = getJoyName( pcfg, TRUE );
            }
            break;

        case JCS_V_PLACEHOLDER:
            pcv->cState = JCS_POV_MOVEUP;
            done = FALSE;
            break;

        case JCS_POV_MOVEUP:
            stridx = CALSTR8;
            if( !(pcfg->hws.dwFlags & JOY_HWS_HASPOV) )
            {
                pcv->cState = JCS_FINI;
                done = FALSE;
            } else
            {
                enableCalWindows( pgv, pcfg, hwnd, JC_POV_UP );
                strid = IDS_JOYCALPOV_MOVE;
                str2id = IDS_JOYCAL_UP;
                str3id = getJoyName( pcfg, TRUE );
                str4id = IDS_JOYCAL_UP;
            }
            break;

        case JCS_POV_MOVERIGHT:
            stridx = CALSTR9;
            enableCalWindows( pgv, pcfg, hwnd, JC_POV_RIGHT );
            strid = IDS_JOYCALPOV_MOVE;
            str2id = IDS_JOYCAL_RIGHT;
            str3id = getJoyName( pcfg, TRUE );
            str4id = IDS_JOYCAL_RIGHT;
            break;

        case JCS_POV_MOVEDOWN:
            stridx = CALSTR10;
            enableCalWindows( pgv, pcfg, hwnd, JC_POV_DOWN );
            strid = IDS_JOYCALPOV_MOVE;
            str2id = IDS_JOYCAL_DOWN;
            str3id = getJoyName( pcfg, TRUE );
            str4id = IDS_JOYCAL_DOWN;
            break;

        case JCS_POV_MOVELEFT:
            stridx = CALSTR11;
            enableCalWindows( pgv, pcfg, hwnd, JC_POV_LEFT );
            strid = IDS_JOYCALPOV_MOVE;
            str2id = IDS_JOYCAL_LEFT;
            str3id = getJoyName( pcfg, TRUE );
            str4id = IDS_JOYCAL_LEFT;
            break;

        case JCS_FINI:
            /*
             * see if everything that needs to be calibrated
             * was actually calibrated
             */
            if( !(pcfg->hwv.dwCalFlags & JOY_ISCAL_XY) )
            {
                isdone = FALSE;
            } else if( (pcfg->hws.dwFlags & JOY_HWS_HASZ) &&
                       !(pcfg->hwv.dwCalFlags & JOY_ISCAL_Z) )
            {
                isdone = FALSE;
            } else if( ((pcfg->hws.dwFlags & JOY_HWS_HASR) ||
                        (pcfg->dwUsageSettings & JOY_US_HASRUDDER)) &&
                       !(pcfg->hwv.dwCalFlags & JOY_ISCAL_R) )
            {
                isdone = FALSE;
            } else if( (pcfg->hws.dwFlags & JOY_HWS_HASPOV) &&
                       !(pcfg->hwv.dwCalFlags & JOY_ISCAL_POV) )
            {
                isdone = FALSE;
            } else if( (pcfg->hws.dwFlags & JOY_HWS_HASU) &&
                       !(pcfg->hwv.dwCalFlags & JOY_ISCAL_U) )
            {
                isdone = FALSE;
            } else if( (pcfg->hws.dwFlags & JOY_HWS_HASV) &&
                       !(pcfg->hwv.dwCalFlags & JOY_ISCAL_V) )
            {
                isdone = FALSE;
            } else
            {
                isdone = TRUE;
            }

            strid = ( isdone ) ? IDS_JOYCAL_DONE : IDS_JOYCAL_NOTDONE;

            str2id = getJoyName( pcfg, FALSE );
            str3id = getJoyName( pcfg, TRUE );
            stridx = CALSTR12;
            enableCalWindows( pgv, pcfg, hwnd, JC_FINI );
            rc = FALSE;
            break;
        }  // END OF SWITCH
    }  // END OF WHILE


    // see if there is any OEM text specified
    hinst = GetResourceInstance( );
    assert(hinst);
    hwtext = GetDlgItem( hwnd, IDC_JOYCALMSG );

    if( pcfg->dwUsageSettings & JOY_US_ISOEM )
    {
        LPJOYDATA   pjd;
        pjd = pgv->pjd;
        assert(pjd);
        type = pcfg->dwType - JOY_HW_LASTENTRY;
        if( pjd->oemList[type].cal_strs[ stridx ][0] != 0 )
        {
            SetWindowText( hwtext, pjd->oemList[type].cal_strs[ stridx] );
            return(rc);
        }
    }

    // no OEM text, use the defaults
    LoadString( hinst, strid, str, sizeof(str));

    if( lstrlen(str) )
    {
        if( str2id != -1 )
        {
            NewLoadString( hinst, str2id, str2, sizeof( str2 ) );

            if( str2 )
            {
                if( str3id != -1 )
                {
                    NewLoadString( hinst, str3id, str3, sizeof( str3 ) );

                    if( lstrlen(str3) )
                    {
                        if( str4id != -1 )
                        {
                            NewLoadString( hinst, str4id, str4, sizeof( str4 ) );

                            if( lstrlen(str4) )
                            {
                                // wsprintf( buff, str, str2, str3, str4 );
                                assert(str2);
                                assert(str3);
                                assert(str4);
                                LPSTR lpargs[] = {str2, str3, str4};

                                FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                              FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                              (LPSTR) str,
                                              0, 0,
                                              buff,
                                              sizeof(buff),
                                              lpargs);

                                SetWindowText( hwtext, buff );
                            }
                        } else
                        {
                            wsprintf( buff, str, str2, str3 );
                            SetWindowText( hwtext, buff );
                        }
                    }
                } else
                {
                    wsprintf( buff, str, str2, str2 );
                    SetWindowText( hwtext, buff );
                }
            }
        } else
        {
            SetWindowText( hwtext, str );
        }
    }

    return(rc);

} /* joyCalStateChange */

/*
 * joyCalStateSkip - skip the current state, move to the next one
 */
static void joyCalStateSkip( LPCALVARS pcv, HWND hwnd )
{

    assert(pcv);
    assert(hwnd);

#if 0
    /*
     * if we're calibrating XY, skip to Z
     */
    if( pcv->cState <= JCS_XY_CENTER2 )
    {
        pcv->cState = JCS_XY_CENTER2;
        /*
         * if we're calibrating Z, skip to R
         */
    } else if( pcv->cState < JCS_Z_PLACEHOLDER )
    {
        pcv->cState = JCS_Z_PLACEHOLDER;
        /*
         * if we're calibrating R, skip to U
         */
    } else if( pcv->cState < JCS_R_PLACEHOLDER )
    {
        pcv->cState = JCS_R_PLACEHOLDER;
        /*
         * if we're calibrating U, skip to V
         */
    } else if( pcv->cState < JCS_U_PLACEHOLDER )
    {
        pcv->cState = JCS_U_PLACEHOLDER;
        /*
         * if we're calibrating V, skip to POV
         */
    } else if( pcv->cState < JCS_V_PLACEHOLDER )
    {
        pcv->cState = JCS_V_PLACEHOLDER;
        /*
         * we must be calibration POV, skip to the end
         */
    } else
    {
        pcv->cState = JCS_POV_MOVELEFT;
    }
#endif

    /*
     * state changed, reset to the new one
     */
    CauseRedraw( &pcv->ji, FALSE );
    joyCalStateChange( pcv, hwnd, TRUE );

} /* joyCalStateSkip */

/*
 * resetCustomPOVFlags - set POV flags based on original values for custom joystick
 */
static void resetCustomPOVFlags( LPGLOBALVARS pgv, LPJOYREGHWCONFIG pcfg )
{
    assert(pgv);
    assert(pcfg);

    if( pcfg->dwType == JOY_HW_CUSTOM )
    {
        pcfg->hws.dwFlags &= ~(JOY_HWS_POVISPOLL|JOY_HWS_POVISBUTTONCOMBOS);

        if( pgv->bOrigPOVIsPoll )
            pcfg->hws.dwFlags |= JOY_HWS_POVISPOLL;

        if( pgv->bOrigPOVIsButtonCombos )
            pcfg->hws.dwFlags |= JOY_HWS_POVISBUTTONCOMBOS;
    }

} /* resetCustomPOVFlags */


/*
 * joyCalStateBack - move back to start the previous state
 */
static void joyCalStateBack( LPCALVARS pcv, HWND hwnd )
{
    assert(pcv);
    assert(hwnd);

    BOOL        back;
    LPJOYREGHWCONFIG    pcfg;
    LPGLOBALVARS    pgv;

    pgv = pcv->pgv;
    assert(pgv);
    back = TRUE;
    pcfg = &pgv->joyHWCurr;
    assert(pcfg);
    /*
     * at the end, backup
     */
    if( pcv->cState == JCS_FINI )
    {
// ADDED BY CML 6/21/96 TO FIX LOST FOCUS BUG (FLASH RAID 167)
        SetFocus(GetDlgItem(hwnd, IDC_JOYCALBACK));
// END ADD

        /*
         * if there is POV, back up to it
         */
        if( pcfg->hws.dwFlags & JOY_HWS_HASPOV )
        {
            pcv->cState = JCS_V_PLACEHOLDER;
            resetCustomPOVFlags( pgv, pcfg );
            /*
             * if there is V, back up to it
             */
        } else if( pcfg->hws.dwFlags & JOY_HWS_HASV )
        {
            pcv->cState = JCS_U_PLACEHOLDER;
            /*
             * if there is U, back up to it
             */
        } else if( pcfg->hws.dwFlags & JOY_HWS_HASU )
        {
            pcv->cState = JCS_R_PLACEHOLDER;
            /*
             * if there is R, back up to it
             */
        } else if( (pcfg->hws.dwFlags & JOY_HWS_HASR) || (pcfg->dwUsageSettings & JOY_US_HASRUDDER) )
        {
            pcv->cState = JCS_Z_PLACEHOLDER;
            /*
             * if there is Z, back up to it
             */
        } else if( pcfg->hws.dwFlags & JOY_HWS_HASZ )
        {
            pcv->cState = JCS_XY_CENTER2;
            /*
             * no where else to go, back up to XY
             */
        } else
        {
// ADDED BY CML 6/21/96 TO FIX LOST FOCUS BUG (FLASH RAID 167)
            SetFocus(GetDlgItem(hwnd, IDC_JOYCALNEXT));
// END ADD
//            pcv->cState = JCS_INIT;
            pcv->cState = JCS_XY_MOVE;
//            back = FALSE;
        }
        /*
         * doing POV, so restart it
         */
    } else if( pcv->cState > JCS_POV_MOVEUP )
    {
        pcv->cState = JCS_V_PLACEHOLDER;
//	pcfg->hws.dwFlags &= ~(JOY_HWS_POVISPOLL|JOY_HWS_POVISBUTTONCOMBOS);
        resetCustomPOVFlags( pgv, pcfg );
        /*
         * just starting POV, back up
         */
    } else if( pcv->cState == JCS_POV_MOVEUP )
    {

// ADDED BY CML 6/21/96 TO FIX LOST FOCUS BUG (FLASH RAID 167)
        SetFocus(GetDlgItem(hwnd, IDC_JOYCALBACK));
// END ADD

        /*
         * if there is V, back up to it
         */
        if( pcfg->hws.dwFlags & JOY_HWS_HASV )
        {
            pcv->cState = JCS_U_PLACEHOLDER;
            /*
             * if there is U, back up to it
             */
        } else if( pcfg->hws.dwFlags & JOY_HWS_HASU )
        {
            pcv->cState = JCS_R_PLACEHOLDER;
            /*
             * if there is R, back up to it
             */
        } else if( (pcfg->hws.dwFlags & JOY_HWS_HASR) ||
                   (pcfg->dwUsageSettings & JOY_US_HASRUDDER) )
        {
            pcv->cState = JCS_Z_PLACEHOLDER;
            /*
             * if there is Z, back up to it
             */
        } else if( pcfg->hws.dwFlags & JOY_HWS_HASZ )
        {
            pcv->cState = JCS_XY_CENTER2;
            /*
             * no where else to go, back up to XY
             */
        } else
        {
// ADDED BY CML 6/21/96 TO FIX LOST FOCUS BUG (FLASH RAID 167)
            SetFocus(GetDlgItem(hwnd, IDC_JOYCALNEXT));
// END ADD
//            pcv->cState = JCS_INIT;
            pcv->cState = JCS_XY_MOVE;
//            back = FALSE;
        }
        /*
         * doing V, backup
         */
    } else if( pcv->cState == JCS_V_MOVE )
    {
        /*
         * if there is U, back up to it
         */
        if( pcfg->hws.dwFlags & JOY_HWS_HASU )
        {
            pcv->cState = JCS_R_PLACEHOLDER;
            /*
             * if there is R, back up to it
             */
        } else if( (pcfg->hws.dwFlags & JOY_HWS_HASR) ||
                   (pcfg->dwUsageSettings & JOY_US_HASRUDDER) )
        {
            pcv->cState = JCS_Z_PLACEHOLDER;
            /*
             * if there is Z, back up to it
             */
        } else if( pcfg->hws.dwFlags & JOY_HWS_HASZ )
        {
            pcv->cState = JCS_XY_CENTER2;
            /*
             * no where else to go, back up to XY
             */
        } else
        {
// ADDED BY CML 6/21/96 TO FIX LOST FOCUS BUG (FLASH RAID 167)
            SetFocus(GetDlgItem(hwnd, IDC_JOYCALNEXT));
// END ADD
//            pcv->cState = JCS_INIT;
            pcv->cState = JCS_XY_MOVE;
//            back = FALSE;
        }
        /*
         * doing U, backup
         */
    } else if( pcv->cState == JCS_U_MOVE )
    {
        /*
         * if there is R, back up to it
         */
        if( (pcfg->hws.dwFlags & JOY_HWS_HASR) ||
            (pcfg->dwUsageSettings & JOY_US_HASRUDDER) )
        {
            pcv->cState = JCS_Z_PLACEHOLDER;
            /*
             * if there is Z, back up to it
             */
        } else if( pcfg->hws.dwFlags & JOY_HWS_HASZ )
        {
            pcv->cState = JCS_XY_CENTER2;
            /*
             * no where else to go, back up to XY
             */
        } else
        {
//            pcv->cState = JCS_INIT;
            pcv->cState = JCS_XY_MOVE;
//            back = FALSE;
        }
        /*
         * doing R, backup
         */
    } else if( pcv->cState == JCS_R_MOVE )
    {
        /*
         * if there is Z, back up to it
         */
        if( pcfg->hws.dwFlags & JOY_HWS_HASZ )
        {
            pcv->cState = JCS_XY_CENTER2;
            /*
             * no where else to go, back up to XY
             */
        } else
        {
// ADDED BY CML 6/21/96 TO FIX LOST FOCUS BUG (FLASH RAID 167)
            SetFocus(GetDlgItem(hwnd, IDC_JOYCALNEXT));
// END ADD
//          pcv->cState = JCS_INIT;
            pcv->cState = JCS_XY_MOVE;
//            back = FALSE;
        }
        /*
         * if we're doing Z or in the middle of XY, backup to XY
         */
    } else if( pcv->cState == JCS_XY_MOVE )
    {
        SetFocus(GetDlgItem(hwnd, IDC_JOYCALNEXT));
        pcv->cState = JCS_INIT;
        back = FALSE;
    } else
    {
// ADDED BY CML 6/21/96 TO FIX LOST FOCUS BUG (FLASH RAID 167)
        SetFocus(GetDlgItem(hwnd, IDC_JOYCALNEXT));
// END ADD
        pcv->cState = (cal_states)(pcv->cState - 2);
//        pcv->cState = JCS_INIT;
//        back = FALSE;
    }

    /*
     * state changed, reset to the new one
     */
    CauseRedraw( &pcv->ji, FALSE );
    joyCalStateChange( pcv, hwnd, back );

} /* joyCalStateBack */

// macro to get new max/min data for an axis
#define NEWMINMAX( a ) \
    if( pji->dw##a##pos > pcv->jr.jpMax.dw##a ) { \
	pcv->jr.jpMax.dw##a = pji->dw##a##pos; \
    } \
    if( pji->dw##a##pos < pcv->jr.jpMin.dw##a ) { \
	pcv->jr.jpMin.dw##a = pji->dw##a##pos; \
    } \
    pji->dw##a##pos *= RAW_SHIFT;

// joyCollectCalInfo - record calibration info 
static BOOL joyCollectCalInfo( LPCALVARS pcv, HWND hwnd, LPJOYINFOEX pji )
{
    assert(pcv);
    assert(hwnd);
    assert(pji);

    LPGLOBALVARS    pgv;
    LPJOYREGHWCONFIG    pcfg;

    pgv = pcv->pgv;
    assert(pgv);
    switch( pcv->cState )
    {
    // remember XY center
    case JCS_XY_CENTER1:
    case JCS_XY_CENTER2:
#ifdef _DEBUG
        TRACE("%s: %d: dwXpos is %d dwYpos is %d\n", __FILE__, __LINE__, pji->dwXpos, pji->dwYpos);
#endif // _DEBUG
        if( !pcv->jr.jpCenter.dwY )
        {
            pgv->joyRange.jpMax.dwY = pji->dwYpos << 1;
            pcv->jr.jpCenter.dwY    = pji->dwYpos;
        }

        if( !pcv->jr.jpCenter.dwX )
        {
            pgv->joyRange.jpMax.dwX = pji->dwXpos << 1;
            pcv->jr.jpCenter.dwX    = pji->dwXpos;
        }

        pgv->joyRange.jpMin.dwX = 0;
        pgv->joyRange.jpMin.dwY = 0;

        DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWXY );
        break;

        // remember max/min XY values
    case JCS_XY_MOVE:
        if( pji->dwXpos > pcv->jr.jpMax.dwX )
        {
            pcv->jr.jpMax.dwX = pji->dwXpos;
        }

        if( pji->dwXpos < pcv->jr.jpMin.dwX )
        {
            pcv->jr.jpMin.dwX = pji->dwXpos;
        }

        if( pji->dwYpos > pcv->jr.jpMax.dwY )
        {
            pcv->jr.jpMax.dwY = pji->dwYpos;
        }

        if( pji->dwYpos < pcv->jr.jpMin.dwY )
        {
            pcv->jr.jpMin.dwY = pji->dwYpos;
        }

        DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWXY );
        break;

        // remember max/min Z value
    case JCS_Z_MOVE:
        NEWMINMAX( Z );
        DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWZ );
        break;

        // remember max/min R value
    case JCS_R_MOVE:
        NEWMINMAX( R );
        DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWR );
        break;

        // remember max/min U value
    case JCS_U_MOVE:
        NEWMINMAX( U );
        DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWU );
        break;

        // remember max/min V value
    case JCS_V_MOVE:
        NEWMINMAX( V );
        DoJoyMove( pgv, hwnd, pji, &pcv->ji, JOYMOVE_DRAWV );
        break;
    }

    // if a button was pressed, move to the next state
    if( ((pcv->ji.dwButtons & ALL_BUTTONS) != (pji->dwButtons & ALL_BUTTONS)) &&
        ((pji->dwButtons & JOY_BUTTON1)  ||
         (pji->dwButtons & JOY_BUTTON2)  ||
         (pji->dwButtons & JOY_BUTTON3)  ||
         (pji->dwButtons & JOY_BUTTON4)  ||
         (pji->dwButtons & JOY_BUTTON5)  ||
         (pji->dwButtons & JOY_BUTTON6)  ||
         (pji->dwButtons & JOY_BUTTON7)  ||
         (pji->dwButtons & JOY_BUTTON8)  ||
         (pji->dwButtons & JOY_BUTTON9)  ||
         (pji->dwButtons & JOY_BUTTON10) ||
         (pji->dwButtons & JOY_BUTTON11) ||
         (pji->dwButtons & JOY_BUTTON12) ||
         (pji->dwButtons & JOY_BUTTON13) ||
         (pji->dwButtons & JOY_BUTTON14) ||
         (pji->dwButtons & JOY_BUTTON15) ||
         (pji->dwButtons & JOY_BUTTON16) ||
         (pji->dwButtons & JOY_BUTTON17) ||
         (pji->dwButtons & JOY_BUTTON18) ||
         (pji->dwButtons & JOY_BUTTON19) ||
         (pji->dwButtons & JOY_BUTTON20) ||
         (pji->dwButtons & JOY_BUTTON21) ||
         (pji->dwButtons & JOY_BUTTON22) ||
         (pji->dwButtons & JOY_BUTTON23) ||
         (pji->dwButtons & JOY_BUTTON24) ||
         (pji->dwButtons & JOY_BUTTON25) ||
         (pji->dwButtons & JOY_BUTTON26) ||
         (pji->dwButtons & JOY_BUTTON27) ||
         (pji->dwButtons & JOY_BUTTON28) ||
         (pji->dwButtons & JOY_BUTTON29) ||
         (pji->dwButtons & JOY_BUTTON30) ||
         (pji->dwButtons & JOY_BUTTON31) ||
         (pji->dwButtons & JOY_BUTTON32) ) )
    {
        // check and see if we are leaving one calibration to the next;
        // if yes, take time to stop and remember what the user just did
        pcfg = &pgv->joyHWCurr;
        assert(pcfg);

        switch( pcv->cState )
        {
        case JCS_XY_CENTER1:
            pcv->jr.jpCenter.dwX = pji->dwXpos;
            pcv->jr.jpCenter.dwY = pji->dwYpos;
            DPF( "Center 1: %d,%d\r\n", pji->dwXpos, pji->dwYpos );
            break;

        case JCS_XY_CENTER2:
            DPF( "Center 2: %d,%d\r\n", pji->dwXpos, pji->dwYpos );
            pcv->jr.jpCenter.dwX += pji->dwXpos;
            pcv->jr.jpCenter.dwY += pji->dwYpos;
            pcv->jr.jpCenter.dwX /= 2;
            pcv->jr.jpCenter.dwY /= 2;
            DPF( "Center Avg: %d,%d\r\n", pcv->jr.jpCenter.dwX, pcv->jr.jpCenter.dwY );
            pcfg->hwv.jrvHardware.jpMin.dwX = pcv->jr.jpMin.dwX;
            pcfg->hwv.jrvHardware.jpMin.dwY = pcv->jr.jpMin.dwY;
            pcfg->hwv.jrvHardware.jpMax.dwX = pcv->jr.jpMax.dwX;
            pcfg->hwv.jrvHardware.jpMax.dwY = pcv->jr.jpMax.dwY;
            pcfg->hwv.jrvHardware.jpCenter.dwX = pcv->jr.jpCenter.dwX;
            pcfg->hwv.jrvHardware.jpCenter.dwY = pcv->jr.jpCenter.dwY;
            pcfg->hwv.dwCalFlags |= JOY_ISCAL_XY;
            break;
        case JCS_Z_MOVE:
            pcfg->hwv.jrvHardware.jpMin.dwZ = pcv->jr.jpMin.dwZ;
            pcfg->hwv.jrvHardware.jpMax.dwZ = pcv->jr.jpMax.dwZ;
            pcfg->hwv.dwCalFlags |= JOY_ISCAL_Z;
            break;
        case JCS_R_MOVE:
            pcfg->hwv.jrvHardware.jpMin.dwR = pcv->jr.jpMin.dwR;
            pcfg->hwv.jrvHardware.jpMax.dwR = pcv->jr.jpMax.dwR;
            pcfg->hwv.dwCalFlags |= JOY_ISCAL_R;
            break;
        case JCS_U_MOVE:
            pcfg->hwv.jrvHardware.jpMin.dwU = pcv->jr.jpMin.dwU;
            pcfg->hwv.jrvHardware.jpMax.dwU = pcv->jr.jpMax.dwU;
            pcfg->hwv.dwCalFlags |= JOY_ISCAL_U;
            break;
        case JCS_V_MOVE:
            pcfg->hwv.jrvHardware.jpMin.dwV = pcv->jr.jpMin.dwV;
            pcfg->hwv.jrvHardware.jpMax.dwV = pcv->jr.jpMax.dwV;
            pcfg->hwv.dwCalFlags |= JOY_ISCAL_V;
            break;
        }

        pcv->ji.dwButtons = pji->dwButtons;
        return(joyCalStateChange( pcv, hwnd, TRUE ));
    }
    pcv->ji.dwButtons = pji->dwButtons;
    return(TRUE);

} /* joyCollectCalInfo */

/*
 * joyCalibrateInitDialog - init the calibration dialog
 */
static BOOL joyCalibrateInitDialog( HWND hwnd, LPARAM lParam )
{
    LPJOYREGHWCONFIG    pcfg;
    LPCALVARS       pcv = NULL;
    LPGLOBALVARS    pgv = NULL;

    ASSERT (::IsWindow(hwnd));

    // set up calibration variables
    pcv = (CALVARS *) DoAlloc( sizeof( CALVARS ) );
    ASSERT(pcv);

    if( pcv == NULL ) return(FALSE);

    SetWindowLong( hwnd, DWL_USER, (LONG) pcv );
    assert(pcv);

    pgv = (LPGLOBALVARS) lParam;
    assert(pgv);

    pcv->pgv = pgv;

    //
    // set labels
    //
    LPSTR psz1 = new char[MAX_STR_LEN];
    ASSERT (psz1);

    LPSTR psz2 = new char[MAX_STR_LEN];
    ASSERT (psz2);

    if( !LoadString(GetResourceInstance(), IDS_JOYCALCAPN, psz1, MAX_STR_LEN) )
    {
        TRACE( "%s: %s - LoadString Failure!\n", __FILE__, __LINE__);
    }

    wsprintf(psz2, psz1, pgv->iJoyId+1);
    SetWindowText(hwnd, psz2);

    if( psz1 )
        delete[] (psz1);

    if( psz2 )
        delete[] (psz2);


    // init state info
    pcv->cState = JCS_INIT;

    // set dialog text based on OEM strings
    SetOEMText( pgv, hwnd, FALSE );

    // customize dialog based on Z axis, R axis, and POV hat
    pcfg = &pgv->joyHWCurr;
    assert(pcfg);

    pcv->iAxisCount = 2;

    if( pcfg->hws.dwFlags & JOY_HWS_HASZ )
        pcv->iAxisCount++;

    if( (pcfg->hws.dwFlags & JOY_HWS_HASR) || (pcfg->dwUsageSettings & JOY_US_HASRUDDER) )
        pcv->iAxisCount++;

    if( (pcfg->hws.dwFlags & JOY_HWS_HASPOV) && (pcfg->hws.dwFlags & JOY_HWS_POVISPOLL) )
        pcv->iAxisCount++;

    if( pcfg->hws.dwFlags & JOY_HWS_HASU )
        pcv->iAxisCount++;

    if( pcfg->hws.dwFlags & JOY_HWS_HASV )
        pcv->iAxisCount++;

    ShowControls( pcfg, hwnd );

    HWND hCtrl = GetDlgItem( hwnd, IDC_JOYPOV_LABEL );
    ASSERT (::IsWindow(hCtrl));
    ShowWindow(hCtrl, pcfg->hws.dwFlags & JOY_HWS_HASPOV ? SW_SHOW : SW_HIDE);

    // if all axes are used and we have POV then it MUST be buttons
    if( pcfg->hws.dwFlags & JOY_HWS_HASPOV )
    {
        if( pgv->dwMaxAxes == 4 && pcv->iAxisCount == 4 )
            pcfg->hws.dwFlags |= JOY_HWS_POVISBUTTONCOMBOS;
    }

    // other misc setup
    pcv->bPOVdone  = FALSE;
    pcv->bHasTimer = SetTimer( hwnd, TIMER_ID, JOYPOLLTIME, NULL );
    pcv->bUseTimer = TRUE;

    if( !pcv->bHasTimer )
    {
        DPF( "No timer for joystick calibration!\r\n" );
        return(FALSE);
    }

    if( !joyCalStateChange( pcv, hwnd, FALSE ) )
    {
        DPF( "Could not initialize joystick calibration\r\n" );
        return(FALSE);
    }

    return(TRUE);

} /* joyCalibrateInitDialog */

/*
 * setJIFlagsForPOV - get joyinfo flags to allow a raw POV poll
 */
static void setJIFlagsForPOV( LPCALVARS pcv, LPJOYREGHWCONFIG pcfg, DWORD *pflags )
{
    /*
     * for polled POV, we need to specifiy JOY_CAL_READ(3|4) to make
     * the driver give us position values back instead of trying to
     * give us a POV value back
     */
//    if( pcfg->hws.dwFlags & JOY_HWS_HASPOV ) 
    {
        if( pcfg->hws.dwFlags & JOY_HWS_POVISPOLL )
        {
            switch( pcv->iAxisCount )
            {
            case 6:
                (*pflags) |= JOY_CAL_READ6;
                break;
            case 5:
                (*pflags) |= JOY_CAL_READ5;
                break;

            case 4: 
                (*pflags) |= JOY_CAL_READ4;
                break;

            case 3: 
                (*pflags) |= JOY_CAL_READ3;
                break;
            }
            // If we don't have a 3rd or 4th axis on this joystick, try reading
            // another axis anyway to see if the POV hat is on it
        } else if( !(pcfg->hws.dwFlags & (JOY_HWS_POVISPOLL|JOY_HWS_POVISBUTTONCOMBOS)) )
        {
            switch( pcv->iAxisCount )
            {
            case 5:
                (*pflags) |= JOY_CAL_READ6;
                break;

            case 4:
                (*pflags) |= JOY_CAL_READ5;
                break;

            case 3:
                (*pflags) |= JOY_CAL_READ4;
                break;

            case 2:
                (*pflags) |= JOY_CAL_READ3;
                break;
            }
        }
    }

} /* setJIFlagsForPOV */

// tryPOV - try for a POV access
static BOOL tryPOV( LPCALVARS pcv, HWND hwnd )
{
    assert(pcv);
    assert(hwnd);

    int         rc;
    BOOL        ispoll;
    BOOL        isb;
    BOOL        nowaypoll;
    JOYINFOEX       ji;
    DWORD       val;
    LPJOYREGHWCONFIG    pcfg;
    LPGLOBALVARS    pgv;
    int         i;

    pgv = pcv->pgv;
    assert(pgv);

    // reject call if not in a POV state
    if( !(pcv->cState == JCS_POV_MOVEUP ||  pcv->cState == JCS_POV_MOVEDOWN ||
          pcv->cState == JCS_POV_MOVELEFT ||  pcv->cState == JCS_POV_MOVERIGHT) )
        return(FALSE);

    // take a snapshot of the current joystick state
    pcfg = &pgv->joyHWCurr;
    assert(pcfg);
    nowaypoll = FALSE;
    ji.dwSize = sizeof( ji );
    while( 1 )
    {
        // get joystick info
        ji.dwFlags = JOY_CALIB_FLAGS;

        // if you have a POV, set the flags for it!
        if( pcfg->hws.dwFlags & JOY_HWS_HASPOV )
            setJIFlagsForPOV( pcv, pcfg, &ji.dwFlags );

        rc = joyGetPosEx( pgv->iJoyId, &ji );
        if( rc == JOYERR_NOERROR )
            break;

        if( !(pcfg->hws.dwFlags & JOY_HWS_POVISPOLL) && (ji.dwFlags & (JOY_CAL_READ3|JOY_CAL_READ4|JOY_CAL_READ5|JOY_CAL_READ6)) )
        {
            // try again, but don't ask for extra axis
            ji.dwFlags &= ~(JOY_CAL_READ6 | JOY_CAL_READ5 | JOY_CAL_READ4 | JOY_CAL_READ3);
            rc = joyGetPosEx( pgv->iJoyId, &ji );
            if( rc == JOYERR_NOERROR )
            {
                nowaypoll = TRUE;   // pov can't possibly be polled
                break;
            } else return(JoyError( hwnd )) ? TRUE : FALSE;  // have to wait for next "Select POV" to retry
        } else return(JoyError( hwnd )) ? TRUE : FALSE;  // have to wait for next "Select POV" to retry
    }

    /*
     * here is where we determine if POV is polled or is button combos.
     *
     * See if we already know the answer (bits in joyHWCurr):
     *     if yes:
     *	       we're done.
     *     if no:
     *         We see if there are currently multiple buttons down.
     *         if yes:
     *             POV is assumed to be button combos.
     *         if no:
     *             POV is assumed to be done with polling
     */
    ispoll = FALSE;
    isb = FALSE;
    if( pcfg->hws.dwFlags & JOY_HWS_POVISPOLL )
    {
        ispoll = TRUE;
    } else if( pcfg->hws.dwFlags & JOY_HWS_POVISBUTTONCOMBOS )
    {
        isb = TRUE;
    }

    if( !isb && !ispoll )
    {
        // the type is indeterminate, so we identify it 
        if( nowaypoll ||((ji.dwButtons != 0) && 
                         (ji.dwButtons != JOY_BUTTON1)    &&
                         (ji.dwButtons != JOY_BUTTON2)    && 
                         (ji.dwButtons != JOY_BUTTON3)    &&
                         (ji.dwButtons != JOY_BUTTON4)    &&
                         (ji.dwButtons != JOY_BUTTON5)    &&
                         (ji.dwButtons != JOY_BUTTON6)    &&
                         (ji.dwButtons != JOY_BUTTON7)    &&
                         (ji.dwButtons != JOY_BUTTON8)    &&
                         (ji.dwButtons != JOY_BUTTON9)    &&
                         (ji.dwButtons != JOY_BUTTON10)   &&
                         (ji.dwButtons != JOY_BUTTON11)   &&
                         (ji.dwButtons != JOY_BUTTON12)   &&
                         (ji.dwButtons != JOY_BUTTON13)   &&
                         (ji.dwButtons != JOY_BUTTON14)   &&
                         (ji.dwButtons != JOY_BUTTON15)   &&
                         (ji.dwButtons != JOY_BUTTON16)   &&
                         (ji.dwButtons != JOY_BUTTON17)   &&
                         (ji.dwButtons != JOY_BUTTON18)   &&
                         (ji.dwButtons != JOY_BUTTON19)   &&
                         (ji.dwButtons != JOY_BUTTON20)   &&
                         (ji.dwButtons != JOY_BUTTON21)   &&
                         (ji.dwButtons != JOY_BUTTON22)   &&
                         (ji.dwButtons != JOY_BUTTON23)   &&
                         (ji.dwButtons != JOY_BUTTON24)   &&
                         (ji.dwButtons != JOY_BUTTON25)   &&
                         (ji.dwButtons != JOY_BUTTON26)   &&
                         (ji.dwButtons != JOY_BUTTON27)   &&
                         (ji.dwButtons != JOY_BUTTON28)   &&
                         (ji.dwButtons != JOY_BUTTON29)   &&
                         (ji.dwButtons != JOY_BUTTON30)   &&
                         (ji.dwButtons != JOY_BUTTON31)   &&
                         (ji.dwButtons != JOY_BUTTON32)   ) )
        {
            isb = TRUE;
            pcfg->hws.dwFlags |= JOY_HWS_POVISBUTTONCOMBOS;
        } else
        {
            // we always assume J2 Y for a polling POV if unspecified
            ispoll = TRUE;
            pcfg->hws.dwFlags |= JOY_HWS_POVISPOLL;
        }

        // the driver needs to notified that we've made this decision
        RegSaveCurrentJoyHW( pgv );
        RegistryUpdated( pgv );
    }

    // record the data value for this POV reading
    if( isb )
        val = ji.dwButtons;
    else
        val = (pcfg->hws.dwFlags & JOY_HWS_HASZ) ? ji.dwRpos : ji.dwZpos;

    switch( pcv->cState )
    {
    case JCS_POV_MOVEUP:
        pcv->pov[JOY_POVVAL_FORWARD]  = val;
        break;

    case JCS_POV_MOVERIGHT:
        pcv->pov[JOY_POVVAL_RIGHT]    = val;
        break;

    case JCS_POV_MOVEDOWN:
        pcv->pov[JOY_POVVAL_BACKWARD] = val;
        break;

    case JCS_POV_MOVELEFT:
        pcv->pov[JOY_POVVAL_LEFT]     = val;

        // since this was the last POV thing to calibrate, we need to save the calibration info
        for( i=0;i<JOY_POV_NUMDIRS;i++ )
            pcfg->hwv.dwPOVValues[i] = pcv->pov[i];

        pcfg->hwv.dwCalFlags |= JOY_ISCAL_POV;
        pcv->bPOVdone = TRUE;
        break;
    }
    return(joyCalStateChange( pcv, hwnd, TRUE ));

} /* tryPOV */

#ifdef DEAD_CODE
// FixCustomPOVType - fix custom POV type info if POV wasn't calibrated;  called by test dlg to update config
void FixCustomPOVType( LPCALVARS pcv )
{
    assert(pcv);

    if( !pcv->bPOVdone )
        resetCustomPOVFlags( pcv->pgv, &pcv->pgv->joyHWCurr );

} /* FixCustomPOVType */
#endif // DEAD_CODE


// CalibrateProc - calibrate a joystick
BOOL CALLBACK CalibrateProc( HWND hwnd, UINT umsg, WPARAM wParam, LPARAM lParam)
{
    switch( umsg )
    {
    case WM_CONTEXTMENU:
        OnContextMenu(wParam);
        return(1);

    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_TIMER:
        {
            LPCALVARS  pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
            assert(pcv);

            if( pcv->bUseTimer )
            {
                JOYINFOEX           *ji = new JOYINFOEX;
                ASSERT (ji);

                MMRESULT            rc;
                LPJOYREGHWCONFIG    pcfg;
                LPGLOBALVARS        pgv;

                pgv = pcv->pgv;
                assert(pgv);

                pcv->bUseTimer = FALSE;
                ji->dwSize = sizeof( JOYINFOEX );

                while( 1 )
                {
                    // get current joystick info
                    ji->dwFlags = JOY_CALIB_FLAGS;
                    pcfg = &pgv->joyHWCurr;
                    ASSERT(pcfg);

                    // if there is a POV, set the flags for it!
                    if( pcfg->hws.dwFlags & JOY_HWS_HASPOV )
                        setJIFlagsForPOV( pcv, pcfg, &ji->dwFlags );

                    rc = joyGetPosEx( pgv->iJoyId, ji );

                    if( rc == JOYERR_NOERROR )
                        break;

                    // didn't work, try without extra POV axis
                    if( !(pcfg->hws.dwFlags & JOY_HWS_POVISPOLL) && (ji->dwFlags & (JOY_CAL_READ3|JOY_CAL_READ4|JOY_CAL_READ5|JOY_CAL_READ6)) )
                    {
                        ji->dwFlags &= ~(JOY_CAL_READ6 | JOY_CAL_READ5 | JOY_CAL_READ4 | JOY_CAL_READ3);

                        rc = joyGetPosEx( pgv->iJoyId, ji );

                        if( rc == JOYERR_NOERROR )
                            break;
                    }

                    if( !JoyError( hwnd ) )
                    {
                        // return now if cancel selected; don't turn back on the timer
                        PostMessage(hwnd, WM_COMMAND, IDCANCEL, 0); // ADDED CML 7/05/96
                        return(FALSE);   
                    }
                    continue;
                }

// how could you get here and rc != JOYERR_NOERROR?
                if( rc == JOYERR_NOERROR )
                    joyCollectCalInfo( pcv, hwnd, ji );

                if( ji )
                    delete (ji);

                /*
                 * If we've started POV calibration, we need to look at the
                 * keyboard and ignore joystick, so don't turn the timer
                 * back on if we've started the POV calibration
                 */
                if( pcv->cState < JCS_POV_MOVEUP )
                    pcv->bUseTimer = TRUE;
            }
            break;
        }


    case WM_DESTROY:
        {
            LPCALVARS   pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
            assert(pcv);
            DoFree( pcv );
            break;
        }

    case WM_INITDIALOG:
        if( !joyCalibrateInitDialog( hwnd, lParam ) )
        {
            LPCALVARS pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
            assert(pcv);

            if( pcv != NULL && pcv->bHasTimer )
            {
                KillTimer( hwnd, TIMER_ID );
                pcv->bHasTimer = FALSE;
            }

            EndDialog( hwnd, 0 );
        }
        return(FALSE);

    case WM_PAINT:
        {
            LPCALVARS   pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
            assert(pcv);
            CauseRedraw( &pcv->ji, FALSE );
            return(FALSE);
        }

    case WM_COMMAND:
        {
            LPCALVARS pcv = (LPCALVARS) GetWindowLong( hwnd, DWL_USER );
            assert(pcv);
            int id = GET_WM_COMMAND_ID(wParam, lParam);

            switch( id )
            {
#ifdef DEAD_CODE			
            case IDC_JOYTEST:
                {
                    BOOL        timeon;

                    timeon = pcv->bUseTimer;
                    pcv->bUseTimer = FALSE;
                    DoTest( pcv->pgv, hwnd, (void (__cdecl *)(void *)) FixCustomPOVType, pcv );
                    pcv->bUseTimer = timeon;
                    break;
                }
#endif //DEAD_CODE

            case IDCANCEL:
                // fall through
            case IDC_JOYCALDONE:
                if( pcv->bHasTimer )
                {
                    KillTimer( hwnd, TIMER_ID );
                    pcv->bHasTimer = FALSE;
                }

//			    {
//				LPJOYREGHWCONFIG	pcfg = &pcv->pgv->joyHWCurr;
//			    assert(pcfg);
//			    }
                EndDialog( hwnd, (id == IDC_JOYCALDONE) );
                break;

            case IDC_JOYPICKPOV:
                if( !tryPOV( pcv, hwnd ) )
                {
                    ASSERT (::IsWindow(hwnd));
                    HWND    hwb = GetDlgItem( hwnd, IDC_JOYPICKPOV );
                    ASSERT (::IsWindow(hwb));

                    ShowWindow( hwb, SW_HIDE );
                    EnableWindow( hwb, FALSE );
                }
                break;

            case IDC_JOYCALNEXT:
                pcv->bUseTimer = TRUE;
                joyCalStateSkip( pcv, hwnd );
                break;

            case IDC_JOYCALBACK:
                pcv->bUseTimer = TRUE;
                joyCalStateBack( pcv, hwnd );
                break;

            default:
                break;
            }
            break;
        }

    default:
        break;
    }
    return(FALSE);

} // CalibrateProc

// DoCalibrate - do the calibration dialog
void DoCalibrate( LPGLOBALVARS pgv, HWND hwnd )
{
    assert(pgv);

    JOYREGHWCONFIG  save_joycfg;
    int         rc;
    int         id;

    // save the current config, and then add the rudder if it is present
    save_joycfg = pgv->joyHWCurr;

    // if this is a custom joystick, then don't assume anything
    // about how the POV is set up
    if( pgv->joyHWCurr.dwType == JOY_HW_CUSTOM )
    {
        pgv->bOrigPOVIsPoll = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_POVISPOLL);
        pgv->bOrigPOVIsButtonCombos = (pgv->joyHWCurr.hws.dwFlags & JOY_HWS_POVISBUTTONCOMBOS);
        pgv->joyHWCurr.hws.dwFlags &= ~(JOY_HWS_POVISPOLL|JOY_HWS_POVISBUTTONCOMBOS);
    }

    // update the registry with our new joystick info
    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

    // Fix for 8738, missing IDD_JOYCALIBRATE1 in resource table!
    id = ( pgv->joyHWCurr.hws.dwFlags & (JOY_HWS_HASU|JOY_HWS_HASV)) ? IDD_JOYCALIBRATE1 : IDD_CAL;

    rc = DialogBoxParam(GetResourceInstance(), MAKEINTRESOURCE( id ), hwnd, 
                        (int (__stdcall *)(struct HWND__ *,unsigned int,unsigned int,long)) CalibrateProc, (LONG) pgv );

    // update the registry with the new info or the old info
    if( rc )
        PropSheet_Changed( GetParent(hwnd), hwnd );
    else
        pgv->joyHWCurr = save_joycfg;

    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

} /* DoCalibrate */


////////////////////////////////////////////////////////////////////////////////////////
//	OnContextMenu(WPARAM wParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam)
{
    short nSize = STR_LEN_32;

    // point to help file
    char *pszHelpFileName = new char[nSize];
    ASSERT (pszHelpFileName);                      

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (DWORD)CalibrateHelpIDs);

    if( pszHelpFileName ) delete[] (pszHelpFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
//	OnHelp(LPARAM lParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnHelp(LPARAM lParam)
{
    short nSize = STR_LEN_32;

    // point to help file
    char *pszHelpFileName = new char[nSize];
    ASSERT (pszHelpFileName);

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    LPHELPINFO lphi = (LPHELPINFO)lParam;
    if( lphi->iContextType==HELPINFO_WINDOW )
        WinHelp((HWND)lphi->hItemHandle, pszHelpFileName, HELP_WM_HELP, (DWORD)CalibrateHelpIDs);

    if( pszHelpFileName ) delete[] (pszHelpFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\joytest.cpp ===
//****************************************************************************
//
//  File:       joytest.c
//  Content:    Joystick test dialog
//  History:
//   Date   By  Reason
//   ====   ==  ======
//   11-dec-94  craige  split out of joycpl.c; some tweaks
//   15-dec-94  craige  allow N joysticks
//   4/2/97    a-kirkh  allow N buttons 
//
//  Copyright (c) Microsoft Corporation 1994-1995
//
//****************************************************************************

#include "stdafx.h"
#include "pov.h"
#include "assert.h"
#include "joycpl.h"
#include "resource.h"
#include "joyarray.h"     // Help array

#include "baseids.h"

#include "comstr.h"
LRESULT SetJoyInfo(UINT nID, LPCSTR szOEMKey);

// ADDED BY CML 2/20/96
LPGLOBALVARS gpgv;
BOOL fIsSideWinder = FALSE;
// END ADD

// Context sensitive help stuff!
static void OnContextMenu(WPARAM wParam);

extern const DWORD gaHelpIDs[];


extern USHORT gnID; // ID as sent from Client via SetID

/*
 * variables used by test process
 */
typedef struct
{
    LPGLOBALVARS    pgv;
    MMRESULT        mmr_capture;
    HWND        hwnd;
    BOOL        bHasTimer;
    BOOL        bUseTimer;
    int         iButtonShift;
    JOYINFOEX       ji;
} test_vars, *LPTESTVARS;


/*
 * fillButton - light up a specific button
 */
static void fillButton( LPGLOBALVARS pgv, HWND hwnd, int id, BOOL isup )
{
    HWND    hwb;
    RECT    r;
    HDC     hdc;

    assert(pgv);
    assert(hwnd);

    hwb = GetDlgItem( hwnd, id );
    ASSERT (::IsWindow(hwb));

    if( hwb == NULL )
    {
        return;
    }
    hdc = GetDC( hwb );
    if( hdc == NULL )
    {
        return;
    }
    GetClientRect( hwb, &r );
    if( isup )
    {
        FillRect( hdc, &r, pgv->pjd->hbUp );
    } else
    {
        FillRect( hdc, &r, pgv->pjd->hbDown );
    }
    ReleaseDC( hwb, hdc );

} /* fillButton */

// doTestButton - try to light the relevant buttons
static void doTestButton( LPTESTVARS ptv, HWND hwnd, LPJOYINFOEX pji )
{
    assert(ptv);
    assert(pji);

// ADDED BY CML 2/21/96
    if( ptv->ji.dwButtons != pji->dwButtons )
    {
        BYTE nIndex;
        HWND hCtrl;
        HICON hIconOn, hIconOff;
        UINT nButtons = ptv->pgv->joyHWCurr.hws.dwNumButtons;

        for( BYTE i=0; i<nButtons; i++ )
        {
            nIndex = i << 1;
            hIconOn  = LoadIcon(GetWindowInstance(hwnd), (PSTR)IDI_BUTTON1OFF+nIndex); 
            hIconOff = LoadIcon(GetWindowInstance(hwnd), (PSTR)IDI_BUTTON1OFF+(nIndex+1));

            hCtrl = GetDlgItem(hwnd, IDC_TESTJOYBTNICON1+i);
            ASSERT (::IsWindow(hCtrl));

            Static_SetIcon(hCtrl, (pji->dwButtons & 1<<i) ? hIconOn : hIconOff);
        }
    }
    ptv->ji.dwButtons = pji->dwButtons;
// END ADD
} /* doTestButton */

// doTestPOV - try to light the POV indicators
static void doTestPOV( LPTESTVARS ptv, HWND hwnd, LPJOYINFOEX pji )
{

    assert(ptv);
    assert(hwnd);
    assert(pji);

    if( ptv->ji.dwPOV != pji->dwPOV )
    {
        if( pji->dwPOV != JOY_POVCENTERED )
            SetDegrees(pji->dwPOV);
        else
            SetDegrees(-1);

        ptv->ji.dwPOV = pji->dwPOV;
    }
} /* doTestPOV */

/*
 * joyTestInitDialog - init the testing dialog
 */
static BOOL joyTestInitDialog( HWND hwnd, LPARAM lParam)
{
    HINSTANCE       hinst;
    LPJOYREGHWCONFIG    pcfg;
    LPTESTVARS      ptv = NULL;
    LPGLOBALVARS    pgv = NULL;
    UINT            i;      // ADDED BY CML 2/21/96

    assert(hwnd);

    hinst = GetResourceInstance();
    assert(hinst);


    // create test vars
    ptv = (test_vars *)DoAlloc( sizeof( test_vars ) );
    assert(ptv);
    SetWindowLong( hwnd, DWL_USER, (LONG) ptv );
    if( ptv == NULL )
        return(FALSE);

    pgv = gpgv;
    assert(pgv);
    ptv->pgv = pgv;
    ptv->hwnd = hwnd;

// ADDED BY CML 2/21/96
    // set default POV icon image
/*
    if (fIsSideWinder)
    {
        HICON hicon; //, holdicon;
        hicon = (struct HICON__ *) LoadImage(
                    GetWindowInstance(hwnd), 
                    (PSTR)IDI_POV_OFF, 
                    IMAGE_ICON, 
                    48, 48, 0);

      assert(hicon);
//      if (hicon) 
//      {
//          HWND hCtrl = GetDlgItem(hwnd,IDC_JOYPOV);
//          ASSERT (::IsWindow(hCtrl));
//
//          holdicon = Static_SetIcon(hCtrl, hicon);
//          if (holdicon) DestroyIcon(holdicon);
//      }
    }
    else
    {
        HICON hicon, holdicon;
        hicon = LoadIcon(GetWindowInstance(hwnd), (PSTR)IDI_JOYPOV_NONE);
        assert(hicon);
        if (hicon) 
        {
            HWND hCtrl = GetDlgItem(hwnd,IDC_JOYPOV);
            ASSERT (::IsWindow(hCtrl));
            holdicon = Static_SetIcon(hCtrl, hicon);
            if (holdicon) DestroyIcon(holdicon);
        }
    }
*/
// END ADD

    // set dialog text based on OEM strings
    SetOEMText( pgv, hwnd, TRUE );

    /*
     * customize test dialog's button display
     */
    pcfg = &pgv->joyHWCurr;
    assert(pcfg);
    if( pcfg->hws.dwNumButtons <= 2 )
    {
        ptv->iButtonShift = 1;
//      HWND hCtrl = GetDlgItem( hwnd, IDC_JOYB1 );
//      ASSERT (::IsWindow(hCtrl));
//      ShowWindow( hCtrl, SW_HIDE );

//      hCtrl = GetDlgItem( hwnd, IDC_JOYB4 );
//      ASSERT (::IsWindow(hCtrl));
//      ShowWindow( hCtrl, SW_HIDE );

//      hCtrl = GetDlgItem( hwnd, IDC_JOYB1_LABEL );
//      ASSERT (::IsWindow(hCtrl));
//      ShowWindow( hCtrl, SW_HIDE );

//      hCtrl = GetDlgItem( hwnd, IDC_JOYB4_LABEL );
//      ASSERT (::IsWindow(hCtrl));
//      ShowWindow( hCtrl, SW_HIDE );
    } else
    {
        ptv->iButtonShift = 0;
    }

// ADDED BY CML 10/23/96
    // size and position the text
    /* There is no text on the buttons anymore!
    for (i=0; i<8; i++)
    {
//      HWND hText = GetDlgItem(hwnd, IDC_TEXT_JOYBTN1+i);
//      ASSERT (::IsWindow(hText));

        HWND hIcon = GetDlgItem(hwnd, IDC_TESTJOYBTNICON1+i);
        ASSERT (::IsWindow(hIcon));

        RECT rcIcon, rcText;
        GetWindowRect(hIcon, &rcIcon);
        GetWindowRect(hText, &rcText);
        rcText.left  = rcIcon.left;
        rcText.right = rcIcon.right;
        MapWindowPoints(0, hwnd, (POINT*)&rcText, 2);
        MoveWindow(
            hText, 
            rcText.left, rcText.top,
            rcText.right-rcText.left, rcText.bottom-rcText.top,
            FALSE);
    }
    */
// END ADD

// ADDED BY CML 2/21/96
// display button lights
// ADDED BY JKH 3/29/97
// MORE BUTTONS SUPPORTED
    HWND hCtrl;

    for( i=pcfg->hws.dwNumButtons; i<32; i++ )
    {
        hCtrl = GetDlgItem(hwnd, IDC_TESTJOYBTNICON1+i);
        ASSERT (::IsWindow(hCtrl));
        ShowWindow(hCtrl, SW_HIDE);
    }

// END ADD

    ShowControls( pcfg, hwnd );

    /*
     * other misc setup
     */
    ptv->bHasTimer = SetTimer( hwnd, TIMER_ID, JOYPOLLTIME, NULL );
    ptv->bUseTimer = TRUE;
    if( !ptv->bHasTimer )
    {
        DPF( "No timer for joystick test!\r\n" );
        return(FALSE);
    }

    return(TRUE);

} /* joyTestInitDialog */


// TestProc - callback procedure for joystick test dialog
BOOL CALLBACK TestProc( HWND hwnd, UINT umsg, WPARAM wParam, LPARAM lParam)
{
    BOOL    rc;

    assert(hwnd);

    switch( umsg )
    {
    case WM_HELP:
        OnHelp(lParam);
        return(1);

    case WM_CONTEXTMENU:
        OnContextMenu(wParam);
        return(1);

    case WM_TIMER:
        {
            LPTESTVARS  ptv = (LPTESTVARS) GetWindowLong( hwnd, DWL_USER );
            assert(ptv);

            if( ptv->bUseTimer )
            {
                JOYINFOEX   ji;
                MMRESULT    rc;
                ptv->bUseTimer = FALSE;
                ji.dwSize = sizeof( ji );
                ji.dwFlags = JOY_RETURNALL | JOY_RETURNCENTERED | JOY_CAL_READALWAYS;
                rc = joyGetPosEx( ptv->pgv->iJoyId, &ji );
// ADDED BY CML 11/13/96
                // if this page is for sw3dpro, check for sw3dpro still active
                if( fIsSideWinder && rc==JOYERR_NOERROR )
                {
                    char sz[256];
                    char szValue[64];
                    DWORD cb = sizeof(szValue);
                    HKEY hKey;
                    JOYCAPS jc;
                    LRESULT lr;

                    // open reg key for device type  // JOYSTICKID1
                    joyGetDevCaps( ptv->pgv->iJoyId, &jc, sizeof(jc));
                    wsprintf(
                            sz, "%s\\%s\\%s", 
                            REGSTR_PATH_JOYCONFIG, 
                            jc.szRegKey,
                            REGSTR_KEY_JOYCURR);
                    lr = RegOpenKey(HKEY_LOCAL_MACHINE, sz, &hKey);
                    wsprintf(sz, REGSTR_VAL_JOYNOEMNAME, 1);
                    lr = RegQueryValueEx(hKey, sz, 0, 0, (BYTE*)szValue, &cb);
                    RegCloseKey(hKey);

                    // is the sw3dpro still connected and not some other device?
                    if( strcmp(szValue, "Microsoft SideWinder 3D Pro") )
                        // wrong device
                        rc = JOYERR_UNPLUGGED;
                }
// END ADD

                if( rc == JOYERR_NOERROR )
                {
                    DoJoyMove( ptv->pgv, hwnd, &ji, &ptv->ji, JOYMOVE_DRAWALL );
                    doTestButton( ptv, hwnd, &ji );
                    doTestPOV( ptv, hwnd, &ji );
                    ptv->bUseTimer = TRUE;
                } else
                {
                    if( JoyError( hwnd ) )
                        ptv->bUseTimer = TRUE;
                }
            }
        }
        break;

    case WM_DESTROY:
        {
            LPTESTVARS  ptv;
            ptv = (LPTESTVARS) GetWindowLong( hwnd, DWL_USER );
            assert(ptv);
            DoFree( ptv );
// ADDED BY CML 2/20/96
            //RegSaveCurrentJoyHW(gpgv);
            RegistryUpdated(gpgv);
// END ADD
            break;
        }

    case WM_INITDIALOG:
        {
            LRESULT lr=SetJoyInfo( 0, "" );
            ASSERT(lr==ERROR_SUCCESS);

            // blj: fix #8049, Set ID to ID of device assigned to property sheet.
            gpgv->iJoyId = gnID;

// ADDED BY CML 2/20/96
            RegSaveCurrentJoyHW(gpgv);
            RegistryUpdated(gpgv);
// END ADD
            rc = joyTestInitDialog( hwnd, lParam );

            if( !rc )
                EndDialog( hwnd, 0 );
        }
        return(FALSE);

// ADDED BY CML 2/21/96
    case WM_NOTIFY:
        switch( ((NMHDR*)lParam)->code )
        {
        case PSN_SETACTIVE:
            {
                LPTESTVARS  ptv = (LPTESTVARS)GetWindowLong(hwnd, DWL_USER);
                assert(ptv);
                ptv->bUseTimer = 1;
                joyTestInitDialog(hwnd, 0);
            }
            break;

// ADDED CML 6/27/96
        case PSN_KILLACTIVE:
            KillTimer(hwnd, TIMER_ID);
            break;
// END ADD 6/27/96
        }
        return(1);
// END ADD 2/21/96

    case WM_PAINT:
        {
            LPTESTVARS  ptv;
            ptv = (LPTESTVARS) GetWindowLong( hwnd, DWL_USER );
            assert(ptv);
            CauseRedraw( &ptv->ji, TRUE );
            return(FALSE);
        }

    case WM_COMMAND:
        {
            int         id;
            LPTESTVARS  ptv;

            ptv = (LPTESTVARS) GetWindowLong( hwnd, DWL_USER );
            assert(ptv);
            id = GET_WM_COMMAND_ID(wParam, lParam);
            switch( id )
            {
            case IDCANCEL:
            case IDOK:
                if( ptv->bHasTimer )
                {
                    KillTimer( hwnd, TIMER_ID );
                }
                EndDialog(hwnd, (id == IDOK));
                break;

            default:
                break;
            }
            break;
        }
    default:
        break;
    }
    return(FALSE);

} /* TestProc */

//  DoTest - do the test dialog
void DoTest( LPGLOBALVARS pgv, HWND hwnd, LPUPDCFGFN pupdcfgfn, LPVOID pparm )
{
    JOYREGHWCONFIG  save_joycfg;
    int         id;

    /*
     * save the current config, and then update config if required
     */
    save_joycfg = pgv->joyHWCurr;
    if( pupdcfgfn != NULL )
    {
        pupdcfgfn( pparm );
    }

    /*
     * update the registry with our new joystick info
     */
    RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

    /*
     * process the test dialog
     */
    if( pgv->joyHWCurr.hws.dwFlags & (JOY_HWS_HASU|JOY_HWS_HASV) )
    {
        id = IDD_JOYTEST1;
    } else
    {
        id = IDD_JOYTEST;
    }

    HINSTANCE hResInst = GetResourceInstance();
    DialogBoxParam( hResInst,
                    MAKEINTRESOURCE( id ), hwnd, (int (__stdcall *)(struct HWND__ *,unsigned int,unsigned int,long))TestProc, (LONG) pgv );

    /*
     * restore the old registry info
     */
    pgv->joyHWCurr = save_joycfg;
    //RegSaveCurrentJoyHW( pgv );
    RegistryUpdated( pgv );

} /* DoTest */

////////////////////////////////////////////////////////////////////////////////////////
//  OnContextMenu(WPARAM wParam)
////////////////////////////////////////////////////////////////////////////////////////
void OnContextMenu(WPARAM wParam)
{
    short nSize = STR_LEN_32;

    // point to help file
    char *pszHelpFileName = new char[nSize];
    ASSERT (pszHelpFileName);                      

    // returns help file name and size of string
    GetHelpFileName(pszHelpFileName, &nSize);

    WinHelp((HWND)wParam, pszHelpFileName, HELP_CONTEXTMENU, (DWORD)gaHelpIDs);

    if( pszHelpFileName ) delete[] (pszHelpFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\joymisc.cpp ===
//****************************************************************************
//
//  File:       joymisc.c
//  Content:    Misc routines used by calibration and testing dialogs
//  History:
//   Date   By  Reason
//   ====   ==  ======
//   11-dec-94  craige  split out of joycpl.c
//   15-dec-94  craige  allow N joysticks
//   18-dec-94  craige  process U&V
//   04-mar-95  craige  bug 13147: crosshair should erase background color
//
//  Copyright (c) Microsoft Corporation 1994-1995
//
//****************************************************************************

#pragma pack (8)

#include "stdafx.h"
#include "joycpl.h"
#include "assert.h"
#include "baseids.h"

#include "comstr.h"
#include "pov.h"

#define DELTA   5

// ADJ_VAL is used to convert a joystick position into a value in a new range
#define ADJ_VAL( a, pos, range ) (((pos-(pgv->joyRange.jpMin.dw##a))*range) / (pgv->joyRange.jpMax.dw##a-pgv->joyRange.jpMin.dw##a+1))

DWORD ADJ_VALX( DWORD pos, DWORD range, DWORD dwMaxX)
{ 
    if (dwMaxX == 0)
        dwMaxX++;

    DWORD nRet = (pos*range) / dwMaxX;

    nRet += DELTA;

    return nRet;
}

DWORD ADJ_VALY( DWORD pos, DWORD range, DWORD dwMaxY )
{ 
    if (dwMaxY == 0)
        dwMaxY++;

    DWORD nRet = (pos*range) / dwMaxY;

    nRet += DELTA;

    return nRet;
}



// setOEMWindowText - set window text with an OEM string
static void setOEMWindowText( HWND hwnd, int id, LPSTR str )
{
    assert(hwnd);

    HWND    hwndctl;
    if( str[0] != 0 ) 
    {
        hwndctl = GetDlgItem( hwnd, id );
        ASSERT (::IsWindow(hwndctl));

        if( hwndctl != NULL ) 
        {
            SetWindowText( hwndctl, str );
        }
    }

} /* setOEMWindowText */

// SetOEMText - set OEM defined text in the dialogs
void SetOEMText( LPGLOBALVARS pgv, HWND hwnd, BOOL istest )
{
    ASSERT(pgv);
    ASSERT (::IsWindow(hwnd));

    DWORD   type;
    char    str[MAX_STR];
    char    res[MAX_STR];
    HINSTANCE   hinst;
    int     id;
    LPSTR   pwincap;
    LPJOYDATA   pjd;

    pjd = pgv->pjd;
    ASSERT(pjd);

    // get the default window caption.   this will be replaced by an OEM string if it is avaliable.
    hinst = GetResourceInstance();
    if( istest ) 
    {
        id = IDS_JOYTESTCAPN;
    } 
    else 
    {
        id = IDS_JOYCALCAPN;
    }

    if( !LoadString( hinst, id, str, sizeof( str ) ) ) 
        res[0] = 0;
    else 
        wsprintf( res, str, pgv->iJoyId+1 );

    pwincap = res;

    // if this is an OEM joystick, use any strings that they may have defined
    if( pgv->joyHWCurr.dwUsageSettings & JOY_US_ISOEM ) 
    {
        type = pgv->joyHWCurr.dwType - JOY_HW_LASTENTRY;

        // set up labels under each of the controls
        setOEMWindowText( hwnd, IDC_JOYLIST1_LABEL, pjd->oemList[type].xy_label );
        setOEMWindowText( hwnd, IDC_JOYLIST2_LABEL, pjd->oemList[type].z_label );
        setOEMWindowText( hwnd, IDC_JOYLIST3_LABEL, pjd->oemList[type].r_label );
        setOEMWindowText( hwnd, IDC_JOYLIST4_LABEL, pjd->oemList[type].u_label );
        setOEMWindowText( hwnd, IDC_JOYLIST5_LABEL, pjd->oemList[type].v_label );
        setOEMWindowText( hwnd, IDC_JOYPOV_LABEL, pjd->oemList[type].pov_label );

        if( istest ) 
        {
            // set the various caption and description fields in the test dlg
//          setOEMWindowText( hwnd, IDC_TEXT_1, pjd->oemList[type].testmove_desc );
//          setOEMWindowText( hwnd, IDC_TEXT_2, pjd->oemList[type].testbutton_desc );
//          setOEMWindowText( hwnd, IDC_GROUPBOX, pjd->oemList[type].testmove_cap );
//          setOEMWindowText( hwnd, IDC_GROUPBOX_2, pjd->oemList[type].testbutton_cap );
            if( pjd->oemList[type].testwin_cap[0] != 0 ) 
            {
                pwincap = pjd->oemList[type].testwin_cap;
            }
        } 
        else 
        {
         // set the various caption and description fields in the calibration dialog
            setOEMWindowText( hwnd, IDC_GROUPBOX, pjd->oemList[type].cal_cap );
            if( pjd->oemList[type].calwin_cap[0] != 0 ) 
            pwincap = pjd->oemList[type].calwin_cap;
        }
    }

    // set the window caption
    if( pwincap[0] != 0 )
        SetWindowText( hwnd, pwincap );
} /* SetOEMText */

// ShowControls - show Z and R controls, based on configuration info
void ShowControls( LPJOYREGHWCONFIG pcfg, HWND hwnd )
{
   assert(pcfg);

// ADDED BY CML 2/21/96: added window *enabling*
    HWND    hwndctl;
    UINT    nShow;

    // Z axis
    nShow = pcfg->hws.dwFlags & JOY_HWS_HASZ ? SW_SHOW : SW_HIDE;
    
    hwndctl = GetDlgItem(hwnd, IDC_JOYLIST2);
    ASSERT (::IsWindow(hwndctl));
    ShowWindow(hwndctl, nShow);

    hwndctl = GetDlgItem(hwnd, IDC_JOYLIST2_LABEL);
    ASSERT (::IsWindow(hwndctl));
    ShowWindow(hwndctl, nShow);
                                           
    // R axis
    nShow = pcfg->hws.dwFlags & JOY_HWS_HASR 
         || pcfg->dwUsageSettings & JOY_US_HASRUDDER
          ? SW_SHOW
          : SW_HIDE;

    hwndctl = GetDlgItem(hwnd, IDC_JOYLIST3);
    ASSERT (::IsWindow(hwndctl));
    ShowWindow(hwndctl, nShow);

    hwndctl = GetDlgItem(hwnd, IDC_JOYLIST3_LABEL);
    ASSERT (::IsWindow(hwndctl));
    ShowWindow(hwndctl, nShow);

    // POV 
    nShow = pcfg->hws.dwFlags & JOY_HWS_HASPOV ? SW_SHOW : SW_HIDE;
    
    hwndctl = GetDlgItem( hwnd, IDC_JOYPOV );
    ASSERT (::IsWindow(hwndctl));
    ShowWindow( hwndctl, nShow);

    // U axis
    nShow = pcfg->hws.dwFlags & JOY_HWS_HASU ? SW_SHOW : SW_HIDE;
    if (hwndctl = GetDlgItem(hwnd, IDC_JOYLIST4)) 
    {
        ASSERT (::IsWindow(hwndctl));
        ShowWindow(hwndctl, nShow);

        hwndctl = GetDlgItem(hwnd, IDC_JOYLIST4_LABEL);
        ASSERT (::IsWindow(hwndctl));
        ShowWindow(hwndctl, nShow);
    }

    // V axis
    nShow = pcfg->hws.dwFlags & JOY_HWS_HASV ? SW_SHOW : SW_HIDE;
    if (hwndctl = GetDlgItem(hwnd, IDC_JOYLIST5))
    {
        ASSERT (::IsWindow(hwndctl));
        ShowWindow(hwndctl, nShow);

        hwndctl = GetDlgItem(hwnd, IDC_JOYLIST5_LABEL);
        ASSERT (::IsWindow(hwndctl));
        ShowWindow(hwndctl, nShow);
    }
// END ADD
} /* ShowControls */

/*
 * JoyError - error reading the joystick
 */
BOOL JoyError( HWND hwnd )
{
   assert(hwnd);

   char szTitle[STR_LEN_32];
   char szMessage[STR_LEN_128];

   if (pszCommonString->LoadString(IDS_JOYREADERROR) == 0)
   {
      OutputDebugString("GCDEF.DLL: WARING: Unable to load string IDS_JOYREADERROR!\n");
      return FALSE;      
   }
    lstrcpy(    szTitle, (LPCTSTR)*pszCommonString);

    if (pszCommonString->LoadString(IDS_JOYUNPLUGGED) == 0)
   {
      OutputDebugString("GCDEF.DLL: WARING: Unable to load string IDS_JOYREADERROR!\n");
      return FALSE;
   }
    lstrcpy( szMessage, (LPCTSTR)*pszCommonString);

    if (MessageBox( hwnd, szMessage, szTitle, 
         MB_RETRYCANCEL | MB_ICONERROR | MB_TASKMODAL ) == IDCANCEL)
    {
       // terminate the dialog if we give up
        PostMessage( GetParent(hwnd), WM_COMMAND, IDCANCEL, 0 );
        return FALSE;
   }
   return TRUE;

} // JoyError

/*
 * ChangeIcon - change the icon of a static control
 */
void ChangeIcon( HWND hwnd, int idi, int idc )
{

   assert(hwnd);

    HINSTANCE   hinst;
    HICON   hicon;
    HICON   holdicon;

    hinst = GetResourceInstance();
    assert(hinst);

    hicon = LoadIcon( hinst, MAKEINTRESOURCE(idi) );
    assert(hicon);

    if( hicon != NULL ) 
    {
        HWND hDlgItem = GetDlgItem(hwnd,idc);
        ASSERT (::IsWindow(hDlgItem));

        holdicon = Static_SetIcon( hDlgItem, hicon );

        if( holdicon != NULL ) 
            DestroyIcon( holdicon );
    }

} /* ChangeIcon */

/*
 * CauseRedraw - cause test or calibrate dialogs to redraw their controls
 */
void CauseRedraw( LPJOYINFOEX pji, BOOL do_buttons )
{
   assert(pji);

    pji->dwXpos = (DWORD) -1;
    pji->dwYpos = (DWORD) -1;
    pji->dwZpos = (DWORD) -1;
    pji->dwRpos = (DWORD) -1;
    pji->dwPOV = JOY_POVCENTERED;
    if( do_buttons ) {
    pji->dwButtons = ALL_BUTTONS;
    }

} /* CauseRedraw */

/*
 * fillBar - fill the bar for indicating Z or R info
 */
static void fillBar( LPGLOBALVARS pgv, HWND hwnd, DWORD pos, int id )
{
   assert(pgv);


    HWND    hwlb;
    RECT    r;
    HDC     hdc;
    int     height;
    LPJOYDATA   pjd;

    pjd = pgv->pjd;
    assert(pjd);

    // scale the height to be inside the bar window
    hwlb = GetDlgItem( hwnd, id );
    ASSERT (::IsWindow(hwlb));

    if( hwlb == NULL )
        return;

    hdc = GetDC( hwlb );
    if( hdc == NULL )
        return;

    GetClientRect( hwlb, &r );

    switch( id ) 
    {
        case IDC_JOYLIST2:
            height = ADJ_VAL( Z, pos, r.bottom );
            break;

        case IDC_JOYLIST3:
            height = ADJ_VAL( R, pos, r.bottom );
            break;

        case IDC_JOYLIST4:
            height = ADJ_VAL( U, pos, r.bottom );
            break;

        case IDC_JOYLIST5:
            height = ADJ_VAL( V, pos, r.bottom );
            break;
    }

    // fill in the inactive area
    r.top = height;
    FillRect( hdc, &r, pjd->hbUp );

    // fill in the active area
    r.top = 0;
    r.bottom = height;
    FillRect( hdc, &r, pjd->hbDown );

    ReleaseDC( hwlb, hdc );

} /* fillBar */

// drawCross - draw a cross in the position box
static void drawCross( HDC hdc, int x, int y, int obj )
{
    HPEN    hpen;
    HPEN    holdpen;

    assert(hdc);

    if( hdc == NULL ) 
        return;

    if( obj ) 
    {
        COLORREF    cr;
        cr = GetSysColor( obj ); // was COLOR_WINDOW
        hpen = CreatePen( PS_SOLID, 0, cr );
    } 
    else 
    {
       hpen = (struct HPEN__ *) GetStockObject( obj );
    }

    if ( hpen == NULL ) 
    {
        return;
    }

    holdpen = (struct HPEN__ *) SelectObject( hdc, hpen );
    MoveToEx( hdc, x-(DELTA-1), y, NULL );
    LineTo( hdc, x+DELTA, y );
    MoveToEx( hdc, x, y-(DELTA-1), NULL );
    LineTo( hdc, x, y+DELTA );
    SelectObject( hdc, holdpen );
    
    if( obj ) {
        DeleteObject( hpen );
    }
} /* drawCross */

#define FILLBAR( a, id ) \
    /* \
     * make sure we aren't out of alleged range \
     */ \
    if( pji->dw##a##pos > pgv->joyRange.jpMax.dw##a ) { \
    pji->dw##a##pos = pgv->joyRange.jpMax.dw##a; \
    } else if( pji->dw##a##pos < pgv->joyRange.jpMin.dw##a ) { \
    pji->dw##a##pos = pgv->joyRange.jpMin.dw##a; \
    } \
 \
    /* \
     * fill the bar if we haven't moved since last time \
     */ \
    if( pji->dw##a##pos != poji->dw##a##pos ) { \
    fillBar( pgv, hwnd, pji->dw##a##pos, id ); \
    poji->dw##a##pos = pji->dw##a##pos; \
    }

// DoJoyMove - process movement for the joystick 
void DoJoyMove( LPGLOBALVARS pgv, HWND hwnd, LPJOYINFOEX pji, LPJOYINFOEX poji, DWORD drawflags )
{
    HWND    hwlb;
    RECT    rc;
    int     width, height;
    int     x,y;
    static BOOL bFirstPoll = TRUE;

    assert(pgv);
    assert(hwnd);
    assert(pji);
    assert(poji);

    // draw the cross in the XY box if needed
    if( drawflags & JOYMOVE_DRAWXY ) 
    {
        // make sure we aren't out of alleged range
        if( pji->dwXpos > pgv->joyRange.jpMax.dwX ) 
            pji->dwXpos = pgv->joyRange.jpMax.dwX;
        else if( pji->dwXpos < pgv->joyRange.jpMin.dwX ) 
            pji->dwXpos = pgv->joyRange.jpMin.dwX;

        if( pji->dwYpos > pgv->joyRange.jpMax.dwY ) 
            pji->dwYpos = pgv->joyRange.jpMax.dwY;
        else if( pji->dwYpos < pgv->joyRange.jpMin.dwY ) 
            pji->dwYpos = pgv->joyRange.jpMin.dwY;

        // convert info to (x,y) position in window
        hwlb = GetDlgItem( hwnd, IDC_JOYLIST1 );
        ASSERT(::IsWindow(hwlb));

        GetClientRect( hwlb, &rc );
        height = rc.bottom - rc.top-2*DELTA;
        width  = rc.right - rc.left-2*DELTA;

        x = ADJ_VALX( pji->dwXpos, width,  pgv->joyRange.jpMax.dwX );
        y = ADJ_VALY( pji->dwYpos, height, pgv->joyRange.jpMax.dwY );

        // only draw the cross if it has moved since last time
        if( x != (int) poji->dwXpos || y != (int) poji->dwYpos ) 
        {
            HDC     hwlbDC;

            hwlbDC = GetDC( hwlb );

            if( hwlbDC == NULL ) {
                return;
            }

            if( poji->dwXpos != (DWORD) -1 ) 
            {
                drawCross( hwlbDC, (int) poji->dwXpos, (int) poji->dwYpos, COLOR_WINDOW );
            } else {
                FillRect( hwlbDC, &rc, (HBRUSH)(COLOR_WINDOW+1) );
            }
    
            if( !bFirstPoll ) {
                drawCross( hwlbDC, (int) x, (int) y, COLOR_WINDOWTEXT );
            } else {
                bFirstPoll = FALSE;
            }

            ReleaseDC( hwlb, hwlbDC );

            poji->dwXpos = x;
            poji->dwYpos = y;
        }
    }

    // draw Z bar if needed
    if ( drawflags & JOYMOVE_DRAWZ )
    {
        FILLBAR( Z, IDC_JOYLIST2 );
    }

    // draw R bar if needed
    if( drawflags & JOYMOVE_DRAWR )
    {
        FILLBAR( R, IDC_JOYLIST3 );
    }

    // draw U bar if needed
    if( drawflags & JOYMOVE_DRAWU )
    {
        FILLBAR( U, IDC_JOYLIST4 );
    }

    // draw V bar if needed
    if( drawflags & JOYMOVE_DRAWV )
    {
        FILLBAR( V, IDC_JOYLIST5 );
    }

} /* DoJoyMove */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\pov.cpp ===
/*~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
**
**    FILE:       POV.CPP
**    DATE:       3/31/97
**    PROJ:       ATLAS
**    PROG:       JKH
**    COMMENTS:   
**
**    DESCRIPTION: Window class for a 360 degree Point Of View control
**                    
**                    
**
**    NOTE:       There are some issues with using extern "C" in this file.
**                If you don't understand why they are there, you're not
**                alone.  For now, and probably for a while they will be
**                here though, because I can't get this file and others
**                that use these services to compile without them.
**                Unfortunately the dynamics of this project don't really
**                afford me the time at present to figure this out.
**                TODO: figure this out
**
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    3/31/97     a-kirkh        Wrote it.
**    
**
**
**
** Copyright (C) Microsoft 1997.  All Rights Reserved.
**
**~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=*/
#pragma pack (8)

#include "POV.H"           //This module's stuff. 

#include "resource.h"

extern   HWND           hPOVWnd = NULL;

static   HINSTANCE      ghResInst;
static   LPRECT         prctOldRegionBox;
static   LPRECT         prctNewRegionBox;
double   degrees = -1;

void SetDegrees(int dDegrees)
{
    degrees = (double)dDegrees;
    PostMessage(hPOVWnd, PM_MYJOYPOSCHANGED, 0, 0);
}


extern "C"{

    void SetResourceInstance(HINSTANCE hInstance)
    {
        ghResInst = hInstance;
    }

    HINSTANCE GetResourceInstance()
    {
        return(ghResInst);
    }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  POVWndProc
//    REMARKS  :  The callback function for the POVHat Window.
//                    
//    PARAMS   :  The usual callback funcs for message handling
//
//    RETURNS  :  LRESULT - Depends on the message
//    CALLS    :  
//    NOTES    :
//                WM_PAINT - Just calls DrawControl
//
//                PM_MYJOYPOSCHANGED - This is a private (WM_USER) message that is
//                called whenever a change in the POV hat occurs.
//                



    RECT        rClient;
    HDC         hDC;
    PAINTSTRUCT ps;
    LONG        cxClient, cyClient;
    HRGN        hRegion;
    HBITMAP     hPOVHubBitmap = NULL;

    LRESULT CALLBACK POVWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
    {
        switch( iMsg ) {
            case WM_CREATE:
                hPOVWnd = hWnd;
                return(0);

            case WM_PAINT:
                {
                    hDC = BeginPaint(hWnd, &ps);
                    DrawControl(hWnd, hDC);
                    EndPaint(hWnd, &ps);
                }
                return(0);

            case PM_MYJOYPOSCHANGED:
                {
                    degrees /= 100;         // if angle == 180, degrees comes in as 18000
                    GetCurrentArrowRegion(&hRegion);

                    if( hRegion ) {
                        GetRgnBox(hRegion, prctNewRegionBox);
                        InvalidateRect(hWnd, prctOldRegionBox, TRUE);
                        InvalidateRect(hWnd, prctNewRegionBox, TRUE);
                        DeleteObject(hRegion); 
                    }
                }

            default:
                return(DefWindowProc(hWnd, iMsg,wParam, lParam));
        }
    }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  DrawControl
//    REMARKS  :  Function called by WM_PAINT that draws the POV hat control
//    PARAMS   :  HWND - Control's window handle
//                HDC  - Control's dc created with BeginPaint
//    RETURNS  :  void
//    CALLS    :  GetCurrentArrowRegion
//    NOTES    :
//                1) So that stuff can be centered.
//                2) Bitblt that hub thingy in the middle.
//                3) Disallow any problems with aspect ratio.
//                4) Draw the circle, should be round because of 3.
//                5) a.Get the coordinates of the rotated arrow.
//                   b.Paint the region.
//                   c.Get the bounding rectangle of the region so we
//                     can invalidate it next time around.

    void DrawControl(HWND hWnd, HDC hDC)
    {
        assert(hWnd);
        assert(hDC);

        // 1) Get client size information
        SetMapMode(hDC, MM_TEXT);                              
        GetClientRect(hWnd, &rClient);
        cxClient = rClient.right - rClient.left;     
        cyClient = -(rClient.bottom - rClient.top);

        // 2) Load the hub bitmap and display it
        hPOVHubBitmap = LoadBitmap((HMODULE)ghResInst, MAKEINTRESOURCE(IDB_POVHUB));
        assert(hPOVHubBitmap);

        DrawBitmap(hDC, hPOVHubBitmap, cxClient/2 - 8, -cyClient/2 - 8);
        DeleteObject(hPOVHubBitmap);

        // 3) Setup the window to use symmetrical units on a 1000 X 1000 cartesian grid
        SetMapMode(hDC, MM_ISOTROPIC);                              
        SetWindowExtEx(hDC, 1000, 1000, NULL);                  
        SetViewportExtEx(hDC, cxClient / 2, cyClient / 2, NULL);   
        SetViewportOrgEx(hDC, cxClient / 2, -cyClient / 2, NULL);

        // 4) Draw the circle upon which the arrow seems to rotate
        SelectObject(hDC, (HBRUSH)GetStockObject(NULL_BRUSH));
        HPEN hPen = CreatePen( PS_SOLID, 1, CIRCLECOLOR);
        //PREFIX: dereferencing NULL pointer 'hPen'
        //Millen Bug#129156, manbug 29347
        if( hPen != NULL ) {
            HPEN hPenOld = (HPEN)SelectObject(hDC, hPen); 
            Ellipse(hDC, -CIRCLERADIUS, CIRCLERADIUS, CIRCLERADIUS, -CIRCLERADIUS);
            SelectObject(hDC, hPenOld); 
            DeleteObject(hPen); 
        }

        // 5) Paint the Arrow at the correct angle if POV active
        if( degrees >= 0 ) {
            HBRUSH hBrush = CreateSolidBrush( CIRCLECOLOR ); 
            if( !hBrush ) {
            	return;
            }

            HBRUSH hBrushOld = (HBRUSH)SelectObject(hDC, hBrush); 
            assert(hBrushOld);

            GetCurrentArrowRegion(&hRegion);
            if( !hRegion ) {
            	return;
            }

            PaintRgn(hDC, hRegion);

            // GetRgnBox returns zero if it fails...
            GetRgnBox(hRegion, prctOldRegionBox);
            SelectObject(hDC, hBrushOld); 

            DeleteObject(hBrush); 
            DeleteObject(hRegion);
        }
    }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  RegisterPOVClass
//    REMARKS  :  Registers the POV Hat window.
//                    
//    PARAMS   :  hInstance - Used for the call to RegisterClassEx
//
//    RETURNS  :  TRUE - if successfully registered
//                FALSE - failed to register
//    CALLS    :  RegisterClassEx
//    NOTES    :
//

    extern BOOL RegisterPOVClass(HINSTANCE hInstance)
    {

        WNDCLASSEX     POVWndClass;

        POVWndClass.cbSize         = sizeof(POVWndClass);
        POVWndClass.style          = CS_HREDRAW | CS_VREDRAW;
        POVWndClass.lpfnWndProc    = POVWndProc;
        POVWndClass.cbClsExtra     = 0;
        POVWndClass.cbWndExtra     = 0;
        POVWndClass.hInstance      = hInstance;
        POVWndClass.hIcon          = NULL;
        POVWndClass.hCursor        = LoadCursor(NULL, IDC_ARROW);
        POVWndClass.hbrBackground  = (HBRUSH) (COLOR_BTNFACE + 1);
        POVWndClass.lpszMenuName   = NULL;
        POVWndClass.lpszClassName  = "POVHAT";
        POVWndClass.hIconSm        = NULL; 

        if( RegisterClassEx( &POVWndClass ) == 0 )
            return(FALSE);

        return(TRUE);
    }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  DrawBitmap
//    REMARKS  :  Copied verbatim from Petzold (WIN95 pg 190)
//    PARAMS   :  HDC - dc for drawing
//                HBITMAP - bitmap to draw
//                int xstart, ystart - where to place the bitmap
//
//    RETURNS  :  void
//    CALLS    :  
//    NOTES    :
//

    void DrawBitmap(HDC hDC, HBITMAP hBitmap, int xStart, int yStart)
    {
        BITMAP         bm;
        HDC            hdcMem;
        POINT          ptSize, ptOrg;

        hdcMem = CreateCompatibleDC(hDC);
        // Found by prefix: Millen Bug129155. manbugs 29339
        // If CreateCompatibleDC fails, we should'nt proceed.
        if( hdcMem == NULL ) return;

        SelectObject(hdcMem, hBitmap);
        SetMapMode(hdcMem,GetMapMode(hDC));

        GetObject(hBitmap, sizeof(BITMAP), (LPVOID)&bm);
        ptSize.x = bm.bmWidth;
        ptSize.y = bm.bmHeight;
        DPtoLP(hDC, &ptSize, 1);
        ptOrg.x = 0;
        ptOrg.y = 0;
        DPtoLP(hdcMem, &ptOrg, 1);

        BitBlt(hDC, xStart, yStart, ptSize.x, ptSize.y, hdcMem, ptOrg.x, ptOrg.y, SRCAND);

        DeleteDC(hdcMem);
    }


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//    FUNCTION :  GetCurrentArrowRegion
//    REMARKS  :  Rotates and translate a set of vertices that represents
//                the POV hat arrow
//
//    PARAMS   :  HRGN - The region to be rotated
//
//    RETURNS  :  BOOL
//    CALLS    :  GETXCOORD, GETYCOORD  (POV.H)
//    NOTES    :  
//

    void GetCurrentArrowRegion(HRGN* hRegion)
    {
        POINT       aptPoints[8]; 


        VERTICEINFO aptVInfo[8] =  { XARROWPOINT      ,YARROWPOINT      ,
            XARROWRIGHTOUT   ,YARROWRIGHTOUT   ,
            XARROWRIGHTIN    ,YARROWRIGHTIN    ,
            XARROWRIGHTBOTTOM,YARROWRIGHTBOTTOM,
            XARROWLEFTBOTTOM ,YARROWLEFTBOTTOM ,
            XARROWLEFTIN     ,YARROWLEFTIN     ,
            XARROWLEFTOUT    ,YARROWLEFTOUT    ,
            XARROWPOINT      ,YARROWPOINT};               


        aptPoints[0].x = GETXCOORD(aptVInfo[0].y, aptVInfo[0].x, degrees);
        aptPoints[0].y = GETYCOORD(aptVInfo[0].y, aptVInfo[0].x, degrees);                    
        aptPoints[1].x = GETXCOORD(aptVInfo[1].y, aptVInfo[1].x, degrees);
        aptPoints[1].y = GETYCOORD(aptVInfo[1].y, aptVInfo[1].x, degrees);
        aptPoints[2].x = GETXCOORD(aptVInfo[2].y, aptVInfo[2].x, degrees);
        aptPoints[2].y = GETYCOORD(aptVInfo[2].y, aptVInfo[2].x, degrees);                    
        aptPoints[3].x = GETXCOORD(aptVInfo[3].y, aptVInfo[3].x, degrees);
        aptPoints[3].y = GETYCOORD(aptVInfo[3].y, aptVInfo[3].x, degrees);                    
        aptPoints[4].x = GETXCOORD(aptVInfo[4].y, aptVInfo[4].x, degrees);
        aptPoints[4].y = GETYCOORD(aptVInfo[4].y, aptVInfo[4].x, degrees);                    
        aptPoints[5].x = GETXCOORD(aptVInfo[5].y, aptVInfo[5].x, degrees);
        aptPoints[5].y = GETYCOORD(aptVInfo[5].y, aptVInfo[5].x, degrees);                    
        aptPoints[6].x = GETXCOORD(aptVInfo[6].y, aptVInfo[6].x, degrees);
        aptPoints[6].y = GETYCOORD(aptVInfo[6].y, aptVInfo[6].x, degrees);                    
        aptPoints[7].x = GETXCOORD(aptVInfo[7].y, aptVInfo[7].x, degrees);
        aptPoints[7].y = GETYCOORD(aptVInfo[7].y, aptVInfo[7].x, degrees);                    

        *hRegion = CreatePolygonRgn(aptPoints, 8, WINDING);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cplangex.RC
//
#define IDS_GENERAL_TAB_1               5010
#define IDS_DEVICE_DESC_1               5020
#define IDS_DEVICE_DESC_2               5021
#define IDS_ASSIGN_1                    5030
#define IDS_PROPERTIES_1                5040
#define IDS_TEST_1                      5050
#define IDS_OK_1                        5060
#define IDS_CANCEL_1                    5070
#define IDS_APPLY_1                     5080
#define IDS_TEST_TAB_1                  5090
#define IDS_MULTIPAD_DESC_1             5100
#define IDS_MULTIPAD_DESC_2             5101
#define IDS_SINGPAD_DESC_1              5110
#define IDS_SINGPAD_DESC_2              5111
#define IDS_TEST_DESC_1                 5120
#define IDS_POSITION_LBL_1              5130
#define IDS_JOYTEST_DESC_1              5140
#define IDS_JOYSTICK_LBL_1              5150
#define IDS_THROTTLE_LBL_1              5160
#define IDS_RUDDER_LBL_1                5170
#define IDS_POVHAT_LBL_1                5180
#define IDS_BUTTONS_LBL_1               5190
#define IDS_JOYTESTBUTT_DESC_1          5200
#define IDS_JOYTESTBUTT_DESC_2          5201
#define IDS_BUTTON1_LBL_1               5210
#define IDS_BUTTON2_LBL_1               5220
#define IDS_BUTTON3_LBL_1               5230
#define IDS_BUTTON4_LBL_1               5240
#define IDS_BUTTON5_LBL_1               5250
#define IDS_BUTTON6_LBL_1               5260
#define IDS_BUTTON7_LBL_1               5270
#define IDS_BUTTON8_LBL_1               5280
#define IDS_PROP_TBAR_1                 5290
#define IDS_PROP_TAB_1                  5300
#define IDS_RUDDERS_DESC_1              5310
#define IDS_RUDDERS_DESC_2              5311
#define IDS_PADPROP_TBAR_1              5320
#define IDS_RUDDER_CBOX_1               5330
#define IDS_LEGPROP_TBAR_1              5340
#define IDS_CALIBRATE_1                 5350
#define IDS_ASSIGN_TBAR_1               5360
#define IDS_DEVSEL_COBOX_1              5370
#define IDS_ASSIGN_COBOX_1              5380
#define IDS_CHANGEID_DESC_1             5390
#define IDS_CHANGEID_DESC_2             5391
#define IDS_CHANGEID_DESC_3             5392
#define IDS_CHANGEID_DESC_4             5393
#define ID_MAINCP_TBAR_1                5400
#define IDS_CALIBRATE_DESC_1            5410
#define IDS_SETTING_PRODUCT_NAME_1      5420
#define IDS_SETTING_PRODUCT_NAME_2      5421
#define IDS_SETTING_PRODUCT_NAME_3      5422
#define IDS_VERSION_1                   5430
#define IDS_COPYRIGHT_1                 5440
#define IDS_COPYRIGHT_2                 5441
#define IDS_PID_1                       5450
#define IDS_NUM_DEVICES_1               5460
#define IDS_DIAGNOSTICS_1               5470
#define IDS_TEST_GAMEPAD1_1             5480
#define IDS_TEST_GAMEPAD2_1             5490
#define IDS_TEST_GAMEPAD3_1             5500
#define IDS_TEST_GAMEPAD4_1             5510
#define IDS_ERROR_1                     5520
#define IDS_LVHEADING_DEVICE_1          5700
#define IDS_LVHEADING_STATUS_1          5710
#define IDS_LVHEADING_ASSIGN_1          5720
#define IDS_STATUS_OK_1                 5730
#define IDS_STATUS_NOTCONNECTED_1       5740
#define IDS_JOYINFO_1                   6000
#define IDS_JOY_1                       6010
#define IDS_JOY2_1                      6020
#define IDS_JOY2S_1                     6030
#define IDS_JOYCALXY_CENTER_1           6040
#define IDS_JOYCALXY_MOVE_1             6050
#define IDS_JOYCALZ_MOVE_1              6060
#define IDS_JOYCALPOV_MOVE_1            6070
#define IDS_JOYCAL_UP_1                 6080
#define IDS_JOYCAL_DOWN_1               6090
#define IDS_JOYCAL_LEFT_1               6100
#define IDS_JOYCAL_RIGHT_1              6110
#define IDS_JOYTESTCAPN_1               6120
#define IDS_JOYBUTTON1_1                6130
#define IDS_JOYBUTTON2_1                6140
#define IDS_JOYCALCAPN_1                6150
#define IDS_JOYUNPLUGGED_1              6160
#define IDS_JOYCALXY_MOVEYOKE_1         6170
#define IDS_JOYCAL_DONE_1               6180
#define IDS_JOYCALXY_MOVEGAMEPAD_1      6190
#define IDS_JOYCALXY_CENTERGAMEPAD_1    6200
#define IDS_JOYCALXY_CENTERYOKE_1       6210
#define IDS_JOYREADERROR_1              6220
#define IDS_JOYCALRUDDER_MOVE_1         6230
#define IDS_JOYCALXY_MOVECAR_1          6240
#define IDS_JOYCALXY_CENTERCAR_1        6250
#define IDS_JOYCALXY_CENTER2_1          6260
#define IDS_JOYCAL_YOKE_1               6270
#define IDS_JOYCAL_CAR_1                6280
#define IDS_JOYCAL_GAMEPAD_1            6290
#define IDS_JOYNOTPRESENT_1             6300
#define IDS_JOYCAL_NOTDONE_1            6310
#define IDS_JOYCALU_MOVE_1              6320
#define IDS_JOYCALV_MOVE_1              6330
#define IDS_JOYRESTARTMSG1_1            6340
#define IDS_JOYRESTARTMSG1_2            6341
#define IDS_JOYRESTARTMSG2_1            6350
#define IDS_JOYCALXY_CENTERGAMEPAD2_1   6360
#define IDS_JOYCALXY_CENTERYOKE2_1      6370
#define IDS_JOYCALXY_CENTERCAR2_1       6380
#define IDS_JOYCAL_YOKES_1              6390
#define IDS_JOYCAL_CARS_1               6400
#define IDS_JOYCAL_GAMEPADS_1           6410
#define IDS_JOYCALINDICATOR_1           6420
#define IDS_VAXIS_LABEL_1               6430
#define IDS_UAXIS_LABEL_1               6440
#define IDS_POVAXIS_LABEL_1             6450
#define IDS_ZAXIS_LABEL_1               6460
#define IDS_XYAXIS_LABEL_1              6470
#define IDS_RAXIS_LABEL_1               6480
#define IDS_JOYPICKPOV_1                6490
#define IDS_JOYCALBACK_1                6500
#define IDS_JOYCALNEXT_1                6510
#define IDS_JOYCALDONE_1                6520
#define IDS_JOYCALGROUP_1               6530
#define IDS_JOYHW0_1                    7000
#define IDS_JOYHW1_1                    7010
#define IDS_JOYHW2_1                    7020
#define IDS_JOYHW3_1                    7030
#define IDS_JOYHW4_1                    7040
#define IDS_JOYHW5_1                    7050
#define IDS_JOYHW6_1                    7060
#define IDS_JOYHW7_1                    7070
#define IDS_JOYHW8_1                    7080
#define IDS_JOYHW9_1                    7090
#define IDS_JOYHW10_1                   7100
#define IDS_JOYHW11_1                   7110
#define IDS_CUSTOM_TBAR_1               8010
#define IDS_CUSTOM_AXES_1               8020
#define IDS_CUSTOM_2AXES_1              8030
#define IDS_CUSTOM_3AXES_1              8040
#define IDS_CUSTOM_4AXES_1              8050
#define IDS_CUSTOM_BUTTON_1             8060
#define IDS_CUSTOM_2BUTTONS_1           8070
#define IDS_CUSTOM_4BUTTONS_1           8080
#define IDS_CUSTOM_SPECIAL_1            8090
#define IDS_CUSTOM_ISFLIGHTYOKE_1       8100
#define IDS_CUSTOM_ISRACECAR_1          8110
#define IDS_CUSTOM_ISGAMEPAD_1          8120
#define IDS_CUSTOM_HASPOV_1             8130
#define IDS_SHEET_CAPTION               9000
#define IDS_PAGE_TITLE1                 9001
#define IDS_PAGE_TITLE2                 9002
#define IDS_GENERALERRMSG_1             10000
#define IDS_FILERRMSG_1                 10020
#define IDS_GAMEDEVERRMSG_1             10030
#define IDS_SYSERRMSG_1                 10040
#define IDS_REGERRMSG_1                 10050
#define IDS_TEXT_AXESHELP               10051
#define IDS_HELPFILENAME                850

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        125
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by joy_old.rc
//
#define IDI_JOYPOV_OFF                  108
#define IDI_ICON1                       119
#define IDI_BUTTONOFF                   120
#define IDI_BUTTONON                    121
#define IDB_POVHUB                      127
#define IDC_JOYBTN1                     1001
#define IDC_JOYBTN2                     1002
#define IDC_JOYBTN3                     1003
#define IDC_JOYBTN4                     1004
#define IDC_JOYBTN5                     1005
#define IDC_JOYBTN6                     1006
#define IDC_JOYBTN7                     1007
#define IDC_JOYBTN8                     1008
#define IDC_TEXT_JOYBTN1                1009
#define IDC_TEXT_JOYBTN2                1010
#define IDC_TEXT_JOYBTN3                1011
#define IDC_TEXT_JOYBTN4                1012
#define IDC_TEXT_JOYBTN5                1013
#define IDC_TEXT_JOYBTN6                1014
#define IDC_TEXT_JOYBTN7                1015
#define IDC_TEXT_JOYBTN8                1016
#define IDC_SIDEWINDERICON              1017
#define IDC_JOYBTN17                    1017
#define IDC_GROUP_RUDDER                1018
#define IDC_JOYBTN18                    1018
#define IDC_TEXT_RUDDERHELP             1019
#define IDC_JOYBTN19                    1019
#define IDC_GROUP_AXES                  1020
#define IDC_TEXT_AXESHELP               1021
#define IDC_TEXT_BTNHELP                1022
#define IDC_GROUP_BUTTONS               1023
#define IDC_TEXT_PRODUCTNAME            1024
#define IDC_JOYBTN20                    1024
#define IDC_TEXT_VERSION                1025
#define IDC_JOYBTN21                    1025
#define IDC_TEXT_COPYRIGHT              1026
#define IDC_JOYBTN22                    1026
#define IDC_TEXT_PID                    1027
#define IDC_JOYBTN23                    1027
#define IDC_TEXT_DIAGNOSTIC             1028
#define IDC_JOYBTN24                    1028
#define IDC_JOYBTN25                    1029
#define IDC_JOYBTN26                    1030
#define IDC_JOYBTN27                    1031
#define IDC_JOYBTN28                    1032
#define IDC_JOYBTN29                    1033
#define IDC_JOYBTN30                    1034
#define IDC_JOYBTN31                    1035
#define IDC_JOYBTN32                    1036
#define IDC_JOYBTN33                    1037
#define IDC_JOYBTN34                    1038
#define IDC_JOYBTN35                    1039
#define IDC_JOYBTN36                    1040
#define IDC_JOYBTN37                    1041
#define IDC_JOYBTN38                    1042
#define IDC_JOYBTN39                    1043
#define IDC_JOYBTN40                    1044
#define IDC_TEXT_CALHELP                1045
#define IDD_SETTINGS                    4201
#define IDD_CAL                         4202
#define IDD_TEST                        4203
#define IDC_TESTJOYBTNICON1             7001
#define IDC_TESTJOYBTNICON2             7002
#define IDC_TESTJOYBTNICON3             7003
#define IDC_TESTJOYBTNICON4             7004
#define IDC_TESTJOYBTNICON5             7005
#define IDC_TESTJOYBTNICON6             7006
#define IDC_TESTJOYBTNICON7             7007
#define IDC_TESTJOYBTNICON8             7008
#define IDC_TESTJOYBTNICON9             7009
#define IDC_TESTJOYBTNICON10            7010
#define IDC_TESTJOYBTNICON11            7011
#define IDC_TESTJOYBTNICON12            7012
#define IDC_TESTJOYBTNICON13            7013
#define IDC_TESTJOYBTNICON14            7014
#define IDC_TESTJOYBTNICON15            7015
#define IDC_TESTJOYBTNICON16            7016
#define IDC_TESTJOYBTNICON17            7017
#define IDC_TESTJOYBTNICON18            7018
#define IDC_TESTJOYBTNICON19            7019
#define IDC_TESTJOYBTNICON20            7020
#define IDC_TESTJOYBTNICON21            7021
#define IDC_TESTJOYBTNICON22            7022
#define IDC_TESTJOYBTNICON23            7023
#define IDC_TESTJOYBTNICON24            7024
#define IDC_TESTJOYBTNICON25            7025
#define IDC_TESTJOYBTNICON26            7026
#define IDC_TESTJOYBTNICON27            7027
#define IDC_TESTJOYBTNICON28            7028
#define IDC_TESTJOYBTNICON29            7029
#define IDC_TESTJOYBTNICON30            7030
#define IDC_TESTJOYBTNICON31            7031
#define IDC_TESTJOYBTNICON32            7032

// NEW ICONS!!!
#define IDI_BUTTON1OFF                 10001
#define IDI_BUTTON1ON                  10002
#define IDI_BUTTON2OFF                 10003
#define IDI_BUTTON2ON                  10004
#define IDI_BUTTON3OFF                 10005
#define IDI_BUTTON3ON                  10006
#define IDI_BUTTON4OFF                 10007
#define IDI_BUTTON4ON                  10008
#define IDI_BUTTON5OFF                 10009
#define IDI_BUTTON5ON                  10010
#define IDI_BUTTON6OFF                 10011
#define IDI_BUTTON6ON                  10012
#define IDI_BUTTON7OFF                 10013
#define IDI_BUTTON7ON                  10014
#define IDI_BUTTON8OFF                 10015
#define IDI_BUTTON8ON                  10016
#define IDI_BUTTON9OFF                 10017
#define IDI_BUTTON9ON                  10018
#define IDI_BUTTON10OFF                10019
#define IDI_BUTTON10ON                 10020
#define IDI_BUTTON11OFF                10021
#define IDI_BUTTON11ON                 10022
#define IDI_BUTTON12OFF                10023
#define IDI_BUTTON12ON                 10024
#define IDI_BUTTON13OFF                10025
#define IDI_BUTTON13ON                 10026
#define IDI_BUTTON14OFF                10027
#define IDI_BUTTON14ON                 10028
#define IDI_BUTTON15OFF                10029
#define IDI_BUTTON15ON                 10030
#define IDI_BUTTON16OFF                10031
#define IDI_BUTTON16ON                 10032
#define IDI_BUTTON17OFF                10033
#define IDI_BUTTON17ON                 10034
#define IDI_BUTTON18OFF                10035
#define IDI_BUTTON18ON                 10036
#define IDI_BUTTON19OFF                10037
#define IDI_BUTTON19ON                 10038
#define IDI_BUTTON20OFF                10039
#define IDI_BUTTON20ON                 10040
#define IDI_BUTTON21OFF                10041
#define IDI_BUTTON21ON                 10042
#define IDI_BUTTON22OFF                10043
#define IDI_BUTTON22ON                 10044
#define IDI_BUTTON23OFF                10045
#define IDI_BUTTON23ON                 10046
#define IDI_BUTTON24OFF                10047
#define IDI_BUTTON24ON                 10048
#define IDI_BUTTON25OFF                10049
#define IDI_BUTTON25ON                 10050
#define IDI_BUTTON26OFF                10051
#define IDI_BUTTON26ON                 10052
#define IDI_BUTTON27OFF                10053
#define IDI_BUTTON27ON                 10054
#define IDI_BUTTON28OFF                10055
#define IDI_BUTTON28ON                 10056
#define IDI_BUTTON29OFF                10057
#define IDI_BUTTON29ON                 10058
#define IDI_BUTTON30OFF                10059
#define IDI_BUTTON30ON                 10060
#define IDI_BUTTON31OFF                10061
#define IDI_BUTTON31ON                 10062
#define IDI_BUTTON32OFF                10063
#define IDI_BUTTON32ON                 10064



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        125
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\plugsrvr.h ===
/************************** Om ***********************************
******************************************************************
*
*    Server Includes.
*
*    AUTHOR: Guru Datta Venkatarama
*
*    HISTORY:
*			   Created : 02/11/97
*  
*
*    SUMMARY:  
*
******************************************************************
(c) Microsoft 1997 - All right reserved.
******************************************************************/
#include "ifacesvr.h"

#ifndef _SERVER_PLUG_IN_
#define _SERVER_PLUG_IN_

/*------------------------------------------------------------
** Server Class Factory
*
*  DESCRIPTION  : ClassFactory Object for the In Proc Server
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       02/11/97 15:47:32 (PST)
*
------------------------------------------------------------*/
class CServerClassFactory : public IClassFactory
{
	protected:
		ULONG   			m_ServerCFactory_refcount;         // Object reference count
    
	public:
		// constructor
		CServerClassFactory(void);
		// destructor
		~CServerClassFactory(void);
        
		// IUnknown methods
		STDMETHODIMP            QueryInterface(REFIID, PPVOID);
		STDMETHODIMP_(ULONG)    AddRef(void);
		STDMETHODIMP_(ULONG)    Release(void);
    
		// IClassFactory methods
		STDMETHODIMP    		CreateInstance(LPUNKNOWN, REFIID, PPVOID);
		STDMETHODIMP    		LockServer(BOOL);
};
/*------------------------------------------------------------
** Property Sheet Class on the Plug in server
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       02/11/97 14:52:23 (PST)
*
------------------------------------------------------------*/
class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
	friend					CServerClassFactory;
	private:
		DWORD				m_cProperty_refcount;
//		tpCPluginHandler	m_pHandler;
		
	public:
		CDIGameCntrlPropSheet(void);
		~CDIGameCntrlPropSheet(void);
		
		// IUnknown methods
	    STDMETHODIMP            QueryInterface(REFIID, PPVOID);
	    STDMETHODIMP_(ULONG)    AddRef(void);
	    STDMETHODIMP_(ULONG)    Release(void);
		
		// CImpIServerProperty methods
		// %%% debug %%% add more methods here for fully modeless operation ? 
		STDMETHODIMP			GetSheetInfo(LPDIGCSHEETINFO *lpSheetInfo);
		STDMETHODIMP			GetPageInfo (LPDIGCPAGEINFO  *lpPageInfo );
		STDMETHODIMP			SetID(USHORT nID);
	    STDMETHODIMP_(USHORT)   GetID(void);
};
// ----------------------------------------------------------

inline void SetServerRefCounter(UINT l_setval);
inline UINT GetServerRefCounter(void);
inline UINT DllServerRelease(void);
inline UINT DllServerAddRef(void);

#endif
//---------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\pov.h ===
#ifndef __POV_H
#define __POV_H
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**
**    FILE:       POV.H
**    DATE:       3/31/97
**    PROJ:       ATLAS
**    PROG:       JKH
**    COMMENTS:   
**
**    DESCRIPTION:Header file for the POV control class
**				      
**				      
**
**    NOTE:       
**
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    3/31/97     a-kirkh        Wrote it.
**    
**
** Copyright (C) Microsoft 1997.  All Rights Reserved.
**
**~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~INCLUDES=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
//    
//
#include <windows.h>
#include <math.h>
#include <assert.h>

#include "resource.h"

//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~STRUCTS~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
//    
//
typedef struct tag_VerticeInfo
{
   int   x;
   long  y;
}VERTICEINFO, *PVERTICEINFO;



//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~DEFINES~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
// ARROWVERTICES DESCRIPTIONS
//                                /\  ------------- X/YARROWPOINT
//                              /    \
//                            /__    __\ ---------- X/YARROWRIGHT/LEFTOUT
//     X/YARROWBOTTOM  \         |  |\
//                       \_______|__|  \----------- X/YARROWRIGHT/LEFTIN 
//

#define        NUMARROWVERTICES           8                 // IN ARROW BITMAP
#define        PIPI                       6.28318           // 2 * PI
#define        PM_MYJOYPOSCHANGED         WM_USER + 1000    // PRIVATE MESSAGE
#define        CIRCLECOLOR                RGB(96, 96, 96)

//VERTICES COORDINATES
//X
#define        XARROWPOINT                0     //USE TWICE, AT START AND AT END
#define        XARROWRIGHTOUT             150
#define        XARROWRIGHTIN              75
#define        XARROWRIGHTBOTTOM          75
#define        XARROWLEFTBOTTOM           -75
#define        XARROWLEFTIN               -75
#define        XARROWLEFTOUT              -150

//VERTICES COORDINATES
//Y
#define        YARROWPOINT                1000
#define        YARROWRIGHTOUT             850
#define        YARROWRIGHTIN              850
#define        YARROWRIGHTBOTTOM          750
#define        YARROWLEFTBOTTOM           750
#define        YARROWLEFTIN               850
#define        YARROWLEFTOUT              850

#define        CIRCLERADIUS               YARROWRIGHTOUT


//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~MACROS=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~
//
// The sin function takes radians so use the conversion:
//
// DEGTORAD: DEGREES / 360 == RADIANS / 2PI -> DEGREES * 2PI == RADIANS    
//
// To rotate and translate a coordinate use the functions:
// 
// GETXCOORD: X' = Y * sin(angle) + X * cos(angle)
// where angle is in radians and
//
// GETYCOORD: Y' = Y * cos(angle) - X * sin(angle)
// where angle is in radians.
//

#define DEGTORAD(d) (double)((PIPI * (d))/360)

#define GETXCOORD(y, x, theta) (int)((((y) * sin((double)(DEGTORAD(theta))))) + (((x) * cos((double)(DEGTORAD(theta))))))
#define GETYCOORD(y, x, theta) (int)((((y) * cos((double)(DEGTORAD(theta))))) - (((x) * sin((double)(DEGTORAD(theta))))))

void SetDegrees(int dDegrees);
void DrawROPLine(HDC hDC, POINT ptStart, 
                 POINT ptEnd, COLORREF rgb = RGB(0, 0, 0), 
                 int iWidth = 1, int iStyle = PS_SOLID, int iROPCode = R2_COPYPEN);

extern "C"
{
void     DrawControl(HWND hWnd, HDC hDC);
void     GetCurrentArrowRegion(HRGN* hRegion);
extern   BOOL RegisterPOVClass(HINSTANCE hInstance);
LRESULT  CALLBACK POVWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
void     DrawBitmap(HDC hDC, HBITMAP hBitmap, int xStart, int yStart);
void     SetResourceInstance(HINSTANCE hInstance);
HINSTANCE GetResourceInstance();
}


#endif
//~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=EOF=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\rcids.h ===
//****************************************************************************
//
//  File:	rcids.h
//  Content:	resource constants
//  History:
//   Date	By	Reason
//   ====	==	======
//   29-nov-94	craige	split from mmse
//   15-dec-94	craige	allow N joysticks
//   05-jan-95	craige	new centering confirmation messages
//   04-mar-95	craige	bug 10761 - separate strings for pluralization
//
//  Copyright (c) Microsoft Corporation 1994, 1995
//
//****************************************************************************
#ifndef __RCIDS_INCLUDED__
#define __RCIDS_INCLUDED__

#include "joyhelp.h"

#define ID_GENERIC_START		0x1000

/*
 * Icons
 */
#define IDI_JOYPOV_NONE			102
#define IDI_JOYPOV_UP			103
#define IDI_JOYPOV_DOWN			104
#define IDI_JOYPOV_LEFT			105
#define IDI_JOYPOV_RIGHT		106
#define IDI_JOYPOV_GRAYED		107
#define IDI_JOYPOV_OFF          108

#define IDI_BUTTONOFF                   120
#define IDI_BUTTONON                    121

#define IDC_JOYBTN1                     1001
#define IDC_JOYBTN2                     1002
#define IDC_JOYBTN3                     1003
#define IDC_JOYBTN4                     1004
#define IDC_JOYBTN5                     1005
#define IDC_JOYBTN6                     1006
#define IDC_JOYBTN7                     1007
#define IDC_JOYBTN8                     1008
#define IDC_JOYBTN9                     1009
#define IDC_JOYBTN10                    1010
#define IDC_JOYBTN11                    1011
#define IDC_JOYBTN12                    1012
#define IDC_JOYBTN13                    1013
#define IDC_JOYBTN14                    1014
#define IDC_JOYBTN15                    1015
#define IDC_JOYBTN16                    1016
#define IDC_SIDEWINDERICON              1017

/*
 * strings
 */
#if 0

#define IDS_GENERIC_START		(ID_GENERIC_START)
#define IDS_GENERIC_STRINGS		(IDS_GENERIC_START)

#define IDS_JOYINFO			(IDS_GENERIC_STRINGS + 0x0001)
#define IDS_JOY				(IDS_GENERIC_STRINGS + 0x0002)
#define IDS_JOY2			(IDS_GENERIC_STRINGS + 0x0003)
#define IDS_JOY2S			(IDS_GENERIC_STRINGS + 0x0004)

#define IDS_JOYSTICK_STRINGS		(IDS_GENERIC_START+0x0100)
#define IDS_JOYCALXY_CENTER		(IDS_JOYSTICK_STRINGS+0x0001)
#define IDS_JOYCALXY_MOVE		(IDS_JOYSTICK_STRINGS+0x0002)
#define IDS_JOYCALZ_MOVE		(IDS_JOYSTICK_STRINGS+0x0003)
#define IDS_JOYCALPOV_MOVE		(IDS_JOYSTICK_STRINGS+0x0004)
#define IDS_JOYCAL_UP			(IDS_JOYSTICK_STRINGS+0x0005)
#define IDS_JOYCAL_DOWN			(IDS_JOYSTICK_STRINGS+0x0006)
#define IDS_JOYCAL_LEFT			(IDS_JOYSTICK_STRINGS+0x0007)
#define IDS_JOYCAL_RIGHT		(IDS_JOYSTICK_STRINGS+0x0008)
#define IDS_JOYTESTCAPN			(IDS_JOYSTICK_STRINGS+0x0009)
/* 0x000a unused */
#define IDS_JOYBUTTON1			(IDS_JOYSTICK_STRINGS+0x000b)
#define IDS_JOYBUTTON2			(IDS_JOYSTICK_STRINGS+0x000c)
#define IDS_JOYCALCAPN			(IDS_JOYSTICK_STRINGS+0x000d)
/* 0x000e unused */
#define IDS_JOYUNPLUGGED		(IDS_JOYSTICK_STRINGS+0x000f)
#define IDS_JOYCALXY_MOVEYOKE		(IDS_JOYSTICK_STRINGS+0x0010)
#define IDS_JOYCAL_DONE			(IDS_JOYSTICK_STRINGS+0x0011)
#define IDS_JOYCALXY_MOVEGAMEPAD	(IDS_JOYSTICK_STRINGS+0x0012)
#define IDS_JOYCALXY_CENTERGAMEPAD	(IDS_JOYSTICK_STRINGS+0x0013)
#define IDS_JOYCALXY_CENTERYOKE		(IDS_JOYSTICK_STRINGS+0x0014)
#define IDS_JOYREADERROR		(IDS_JOYSTICK_STRINGS+0x0015)
#define IDS_JOYCALRUDDER_MOVE		(IDS_JOYSTICK_STRINGS+0x0016)
#define IDS_JOYCALXY_MOVECAR		(IDS_JOYSTICK_STRINGS+0x0017)
#define IDS_JOYCALXY_CENTERCAR		(IDS_JOYSTICK_STRINGS+0x0018)
#define IDS_JOYCALXY_CENTER2		(IDS_JOYSTICK_STRINGS+0x0019)
#define IDS_JOYCAL_YOKE			(IDS_JOYSTICK_STRINGS+0x001a)
#define IDS_JOYCAL_CAR			(IDS_JOYSTICK_STRINGS+0x001b)
#define IDS_JOYCAL_GAMEPAD		(IDS_JOYSTICK_STRINGS+0x001c)
#define IDS_JOYNOTPRESENT		(IDS_JOYSTICK_STRINGS+0x001d)
#define IDS_JOYCAL_NOTDONE		(IDS_JOYSTICK_STRINGS+0x001e)
#define IDS_JOYCALU_MOVE		(IDS_JOYSTICK_STRINGS+0x001f)
#define IDS_JOYCALV_MOVE		(IDS_JOYSTICK_STRINGS+0x0020)
#define IDS_JOYRESTARTMSG1		(IDS_JOYSTICK_STRINGS+0x0021)
#define IDS_JOYRESTARTMSG2		(IDS_JOYSTICK_STRINGS+0x0022)
#define IDS_JOYCALXY_CENTERGAMEPAD2	(IDS_JOYSTICK_STRINGS+0x0023)
#define IDS_JOYCALXY_CENTERYOKE2	(IDS_JOYSTICK_STRINGS+0x0024)
#define IDS_JOYCALXY_CENTERCAR2		(IDS_JOYSTICK_STRINGS+0x0025)
#define IDS_JOYCAL_YOKES		(IDS_JOYSTICK_STRINGS+0x0026)
#define IDS_JOYCAL_CARS			(IDS_JOYSTICK_STRINGS+0x0027)
#define IDS_JOYCAL_GAMEPADS		(IDS_JOYSTICK_STRINGS+0x0028)
#define IDS_JOYCALINDICATOR		(IDS_JOYSTICK_STRINGS+0x0029)
#define IDS_VAXIS_LABEL			(IDS_JOYSTICK_STRINGS+0x002a)
#define IDS_UAXIS_LABEL			(IDS_JOYSTICK_STRINGS+0x002b)
#define IDS_POVAXIS_LABEL		(IDS_JOYSTICK_STRINGS+0x002c)
#define IDS_ZAXIS_LABEL			(IDS_JOYSTICK_STRINGS+0x002d)
#define IDS_XYAXIS_LABEL		(IDS_JOYSTICK_STRINGS+0x002e)
#define IDS_RAXIS_LABEL 		(IDS_JOYSTICK_STRINGS+0x002f)    

#define IDS_JOYHW0			(IDS_JOYSTICK_STRINGS+0x0040)
#define IDS_JOYHW1			(IDS_JOYSTICK_STRINGS+0x0041)
#define IDS_JOYHW2			(IDS_JOYSTICK_STRINGS+0x0042)
#define IDS_JOYHW3			(IDS_JOYSTICK_STRINGS+0x0043)
#define IDS_JOYHW4			(IDS_JOYSTICK_STRINGS+0x0044)
#define IDS_JOYHW5			(IDS_JOYSTICK_STRINGS+0x0045)
#define IDS_JOYHW6			(IDS_JOYSTICK_STRINGS+0x0046)
#define IDS_JOYHW7			(IDS_JOYSTICK_STRINGS+0x0047)
#define IDS_JOYHW8			(IDS_JOYSTICK_STRINGS+0x0048)
#define IDS_JOYHW9			(IDS_JOYSTICK_STRINGS+0x0049)
#define IDS_JOYHW10			(IDS_JOYSTICK_STRINGS+0x004a)
#define IDS_JOYHW11			(IDS_JOYSTICK_STRINGS+0x004b)
#define IDS_JOYHWLAST			(IDS_JOYSTICK_STRINGS+0x004c)

#endif // 0
/*
 * dialog ids
 */
#define IDD_JOYSTICK			0x1000
#define IDD_JOYCALIBRATE		0x1001
#define IDD_JOYTEST			0x1002
#define IDD_JOYCUSTOM			0x1003
#define IDD_JOYTEST1			0x1004
#define IDD_JOYCALIBRATE1		0x1005

/*
 * dialog constants
 */
#ifndef IDC_STATIC
#define IDC_STATIC			-1
#endif

#define ID_START			(ID_GENERIC_START+0x1000)
#define ID_APPLY			(ID_START + 0x0001)
#define ID_INIT				(ID_START + 0x0002)
#define IDC_ICON_1			(ID_START + 0x0003)
#define IDC_ICON_2			(ID_START + 0x0004)
#define IDC_TEXT_1			(ID_START + 0x0005)
#define IDC_TEXT_2			(ID_START + 0x0006)
#define IDC_GROUPBOX			(ID_START + 0x0007)
#define IDC_GROUPBOX_2			(ID_START + 0x0008)
#define IDC_GROUPBOX_3			(ID_START + 0x0009)

#define ID_JOYSTICK_START		(ID_GENERIC_START+0x2000)
#define IDC_JOYSTICK1_FRAME		(ID_JOYSTICK_START+0x0001)
#define IDC_JOYSTICK2_FRAME		(ID_JOYSTICK_START+0x0002)
#define IDC_JOYCALIBRATE		(ID_JOYSTICK_START+0x0003)
#define IDC_JOYTEST			(ID_JOYSTICK_START+0x0004)
#define IDC_JOYLIST1			(ID_JOYSTICK_START+0x0005)
#define IDC_JOYCALSTEP			(ID_JOYSTICK_START+0x0006)
#define IDC_JOYCALICON			(ID_JOYSTICK_START+0x0007)
#define IDC_JOYTESTBTN			(ID_JOYSTICK_START+0x0008)	   
#define IDC_JOYSELECT			(ID_JOYSTICK_START+0x0009)
#define IDC_JOYSELECT2			(ID_JOYSTICK_START+0x000a)
#define IDC_JOYSELECTMSG		(ID_JOYSTICK_START+0x000b)
#define IDC_JOYSELECTMSG2		(ID_JOYSTICK_START+0x000c)
#define IDC_JOYXYPOS			(ID_JOYSTICK_START+0x000d)
#define IDC_JOYB1			(ID_JOYSTICK_START+0x000e)
#define IDC_JOYB2			(ID_JOYSTICK_START+0x000f)
#define IDC_JOYB3			(ID_JOYSTICK_START+0x0010)
#define IDC_JOYB4			(ID_JOYSTICK_START+0x0011)
#define IDC_JOYB3TXT			(ID_JOYSTICK_START+0x0012)
#define IDC_JOYB4TXT			(ID_JOYSTICK_START+0x0013)
#define IDC_JOYLIST2			(ID_JOYSTICK_START+0x0014)
#define IDC_JOYPOV			(ID_JOYSTICK_START+0x0015)
#define IDC_JOYB1_LABEL			(ID_JOYSTICK_START+0x0016)
#define IDC_JOYB2_LABEL			(ID_JOYSTICK_START+0x0017)
#define IDC_JOYB3_LABEL			(ID_JOYSTICK_START+0x0018)
#define IDC_JOYB4_LABEL			(ID_JOYSTICK_START+0x0019)
#define IDC_JOYLIST1_LABEL		(ID_JOYSTICK_START+0x001a)
#define IDC_JOYLIST2_LABEL		(ID_JOYSTICK_START+0x001b)
#define IDC_JOYPOV_LABEL		(ID_JOYSTICK_START+0x001c)
#define IDC_JOYCALIBRATE2		(ID_JOYSTICK_START+0x001d)
#define IDC_JOYTEST2			(ID_JOYSTICK_START+0x001e)
#define IDC_JOYMSG			(ID_JOYSTICK_START+0x001f)
#define IDC_JOYCALMSG			(ID_JOYSTICK_START+0x0020)
#define IDC_JOYCALDONE			(ID_JOYSTICK_START+0x0021)
#define IDC_JOYHASPOV			(ID_JOYSTICK_START+0x0022)
#define IDC_JOYISYOKE			(ID_JOYSTICK_START+0x0023)
#define IDC_JOYISGAMEPAD		(ID_JOYSTICK_START+0x0024)
#define IDC_JOYISCARCTRL		(ID_JOYSTICK_START+0x0025)
#define IDC_JOY2BUTTON			(ID_JOYSTICK_START+0x0026)
#define IDC_JOY4BUTTON			(ID_JOYSTICK_START+0x0027)
#define IDC_JOYPICKPOV			(ID_JOYSTICK_START+0x0028)
#define IDC_JOYCALBACK			(ID_JOYSTICK_START+0x0029)
#define IDC_JOYCALNEXT			(ID_JOYSTICK_START+0x002a)
#define IDC_JOYSPECIALBOX		(ID_JOYSTICK_START+0x002b)
#define IDC_JOYUSESPECIAL		(ID_JOYSTICK_START+0x002c)
#define IDC_JOY1HASRUDDER		(ID_JOYSTICK_START+0x002d)
#define IDC_JOYLIST3			(ID_JOYSTICK_START+0x002e)
#define IDC_JOYLIST3_LABEL		(ID_JOYSTICK_START+0x002f)
#define IDC_JOY2AXIS			(ID_JOYSTICK_START+0x0030)
#define IDC_JOY3AXIS			(ID_JOYSTICK_START+0x0031)
#define IDC_JOY4AXIS			(ID_JOYSTICK_START+0x0032)
#define IDC_JOY_UNCAL1			(ID_JOYSTICK_START+0x0033)
#define IDC_JOY_UNCAL2			(ID_JOYSTICK_START+0x0034)
#define IDC_JOY_UNCAL3			(ID_JOYSTICK_START+0x0035)
#define IDC_JOY_UNCAL4			(ID_JOYSTICK_START+0x0036)
#define IDC_JOY_UNCAL5			(ID_JOYSTICK_START+0x0037)
#define IDC_JOY_UNCAL6			(ID_JOYSTICK_START+0x0038)
#define IDC_JOYCURRENTID		(ID_JOYSTICK_START+0x0039)
#define IDC_JOYCURRENTIDMSG		(ID_JOYSTICK_START+0x003a)
#define IDC_JOYLIST4			(ID_JOYSTICK_START+0x003b)
#define IDC_JOYLIST4_LABEL		(ID_JOYSTICK_START+0x003c)
#define IDC_JOYLIST5			(ID_JOYSTICK_START+0x003d)
#define IDC_JOYLIST5_LABEL		(ID_JOYSTICK_START+0x003e)
#define IDC_JOYRESET			(ID_JOYSTICK_START+0x003f)
#define IDC_JOYTROUBLESHOOT_FRAME	(ID_JOYSTICK_START+0x0040)
#define IDC_JOYTROUBLESHOOT_TEXT	(ID_JOYSTICK_START+0x0041)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\slang.h ===
/************************** Om ***********************************
******************************************************************
*
*    Server Language Includes
*
*    AUTHOR: Guru Datta Venkatarama
*
*    HISTORY:
*			   Created : 02/25/97
*  
*
*    SUMMARY:  
*
******************************************************************
(c) Microsoft 1997 - All right reserved.
******************************************************************/
#include <wtypes.h>

#ifndef _SERVLANG_
#define _SERVLANG_

BOOL LoadLangLib(HINSTANCE *lhinstance);
BOOL FreeLangLib(HINSTANCE *lhinstance);

#endif
//----------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\server.cpp ===
/******************************************************************
*
*    The Plug In Server.
*
*    HISTORY:
*              Created : 02/11/97
*           a-kirkh  4/2/97   Added call to SetInstance, RegisterPOVClass
*  
*
*    SUMMARY:  
*
******************************************************************
(c) Microsoft 1997 - All right reserved.
******************************************************************/
#define INC_OLE2

#pragma pack (8)

#include "stdafx.h"
#include <objbase.h>
#include <initguid.h>                                 
#include <shlobj.h>
#include "slang.h"

#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif

#include <joycpl.h>

#include "resource.h"
#include "dicpl.h"
#include "hsvrguid.h"
#include "pov.h"
#include <malloc.h>
#include <afxconv.h>

#define STR_LEN_128     128
#define NUMPROPAGES     2


DIGCPAGEINFO  page_info[NUMPROPAGES];
DIGCSHEETINFO sheet_info;

/// These strings are also defined in RESRC1.H
#define IDS_SHEET_CAPTION   9000
#define IDS_PAGE_TITLE1     9001
#define IDS_PAGE_TITLE2     9002


LRESULT SetJoyInfo(UINT nID, LPCSTR szOEMKey);

BOOL SetDialogItemText( HWND hdlg, UINT nctrl, UINT nstr );
CString *pszCommonString=NULL;

// %%% debug %%%
LPJOYDATA  pjd;
JOYDATAPTR jdp;

extern LPGLOBALVARS gpgv;           
extern BOOL fIsSideWinder;
static HINSTANCE ghInstance;

static LONG gcRefServerDll = 0;          // Reference count for this DLL

//const LPSTR   device_name="Gaming Input Device (Generic)";

USHORT gnID; // ID as sent from Client via SetID

static HINSTANCE ghModLang;

/*------------------------------------------------------------
** DllMain
*
*  PARAMETERS   :
*
*  DESCRIPTION  :   Entry point into the Inprocess handler.
*                   This implementation is a single thread, 
                    in process server.
 
*  RETURNS      :
*  AUTHOR       :       Guru Datta Venkatarama  
*                       02/12/97 12:21:17 (PST)
*
------------------------------------------------------------*/
int APIENTRY DllMain(HINSTANCE  hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch( dwReason ) {
        
        case DLL_PROCESS_ATTACH:
            {
                ghModLang = hInstance;
                // save the DLL instance
                ghInstance = hInstance;

                SetResourceInstance(ghModLang);

                AfxSetResourceHandle(ghModLang);
                pszCommonString = new CString;

                USES_CONVERSION;

                char lpStr[STR_LEN_64];

                // Populate page info stuff!
                BYTE nIndex = NUMPROPAGES;
                do {
                    nIndex--;
                    page_info[nIndex].dwSize        = sizeof(DIGCPAGEINFO);

                    page_info[nIndex].lpwszPageTitle = new WCHAR[STR_LEN_128];
                    ASSERT(page_info[nIndex].lpwszPageTitle);

                    VERIFY(LoadString(ghModLang, IDS_PAGE_TITLE2-(nIndex^1), lpStr, STR_LEN_64));
                    wcscpy(page_info[nIndex].lpwszPageTitle, A2W(lpStr));

                    page_info[nIndex].fpPageProc    = (nIndex) ? (DLGPROC)TestProc : (DLGPROC)JoystickDlg;
                    page_info[nIndex].fProcFlag     = FALSE;
                    page_info[nIndex].fpPrePostProc = NULL;

                    // if fIconFlag is TRUE, DON'T FORGET TO MALLOC YOUR MEMORY!!!
                    page_info[nIndex].fIconFlag     = FALSE;
                    page_info[nIndex].lpwszPageIcon = NULL;

                    page_info[nIndex].lpwszTemplate = (nIndex) ? (PWSTR)IDD_TEST : (PWSTR)IDD_SETTINGS ;
                    page_info[nIndex].lParam        = 0;
                    page_info[nIndex].hInstance     = ghModLang;
                }
                while( nIndex );


                // Populate Sheet Info stuff!
                sheet_info.dwSize            = sizeof(DIGCSHEETINFO);
                sheet_info.nNumPages         = NUMPROPAGES;        

                VERIFY(LoadString(ghModLang, IDS_SHEET_CAPTION, lpStr, STR_LEN_64));
                sheet_info.lpwszSheetCaption = new WCHAR[STR_LEN_64];
                ASSERT(sheet_info.lpwszSheetCaption);
                wcscpy(sheet_info.lpwszSheetCaption, A2W(lpStr));

                // Don't forget to malloc your memory here if you ever need to have an Icon!
                sheet_info.fSheetIconFlag    = FALSE;   
                sheet_info.lpwszSheetIcon    = NULL;   


                RegisterPOVClass(ghModLang); //Added by JKH 3/31/97 
            }
            break;

        case DLL_PROCESS_DETACH:

            // clean-up Page info
            for( BYTE nIndex = 0; nIndex < NUMPROPAGES; nIndex++ ) {
                if( page_info[nIndex].lpwszPageTitle ) {
                    delete[] (page_info[nIndex].lpwszPageTitle);
                }

                // if fIconFlag is TRUE, DON'T FORGET TO FREE YOUR MEMORY!!!
            }

            // clean-up Sheet info
            if( sheet_info.lpwszSheetCaption )
                delete[] (sheet_info.lpwszSheetCaption);

            // dll about to be released from process
            // time to clean up all local work ( if any )
            if( pszCommonString )
                delete(pszCommonString);
            break;
    }
    return(TRUE);
}
/*------------------------------------------------------------ DllGetClassObject

** DllGetClassObject
*
*  PARAMETERS   :  rclsid = Reference to class ID specifier
                   riid   = Reference to interface ID specifier
                   ppv    = Pointer to location to receive interface pointer
*
*  DESCRIPTION  :  Here be the entry point of COM.
                   DllGetClassObject is called by the Client socket to 
                   create a class factory object.
                   This Class factory will support the generation of three different class
                   Objects.
*
*  RETURNS      :  HRESULT code signifying success or failure
*
*  AUTHOR       :       Guru Datta Venkatarama  
*                       01/29/97 14:22:02 (PST)
*
------------------------------------------------------------*/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    // %%% debug %%% figure out this optimisation later.
    USHORT  l_clsidtype=0;

    *ppv = NULL;

    // Make sure the class ID valid for the class factory. Otherwise, the class
    // factory of the object type specified by rclsid cannot be generated.
    // %%% debug %%% - seems like we cannot implement this check because 
    // each server will have its own CLSID. so we need to hard code this for 
    // every server
    if( !IsEqualCLSID (rclsid, CLSID_LegacyServer) ) {
        return(ResultFromScode (CLASS_E_CLASSNOTAVAILABLE));
    }
    // Make sure that the interface id that is being requested is a valid one i.e. IID_IClassFactory
    if( !IsEqualIID (riid, IID_IClassFactory) ) {
        return(ResultFromScode (E_NOINTERFACE));
    }

    // create a new class factory ... ( here we associate the CLSID to object of a type )
    CServerClassFactory *pClassFactory = new CServerClassFactory ();

    // Verify .. was the class factory created ?
    if( pClassFactory == NULL ) {
        // Nope ! Return an ERROR !
        return(ResultFromScode (E_OUTOFMEMORY));
    }

    // Get the interface pointer from QueryInterface and copy it to *ppv.
    // The required type of riid is automatically being passed in ....
    HRESULT hr = pClassFactory->QueryInterface (riid, ppv);

    pClassFactory->Release ();

    return(hr);
}


/*------------------------------------------------------------ DllCanUnloadNow
** DllCanUnloadNow
*
*  PARAMETERS   : None
*
*  DESCRIPTION  : DllCanUnloadNow is called by the shell to find out if the DLL can be
*                 unloaded. The answer is yes if (and only if) the module reference count
*                 stored in gcRefServerDll is 0.
                  This Dll can be unloaded if and only if :
                    a) All the in process servers that it "spawns" can be unloaded and
                    b) Its own reference count is down to zero
*  RETURNS      : HRESULT code equal to S_OK if the DLL can be unloaded, S_FALSE if not
*  AUTHOR       :       Guru Datta Venkatarama  
*                       01/30/97 08:24:21 (PST)
*
------------------------------------------------------------*/
STDAPI DllCanUnloadNow(void)
{
    // %%% debug %%% implement / verify complex condition for return value ( lock servers actually )
    return((gcRefServerDll == 0) ? S_OK : S_FALSE);
}

/*------------------------------------------------------------ CServerClassFactory::CServerClassFactory
** CServerClassFactory Member Functions
*
*  DESCRIPTION  : This is the implementation of the standard member functions of the 
                  Server's class factory.
*
*  AUTHOR       :       Guru Datta Venkatarama  
*                       01/30/97 08:30:18 (PST)
*
------------------------------------------------------------*/
// constructor ..
CServerClassFactory::CServerClassFactory(void)
{
    m_ServerCFactory_refcount = 0; // was 1;
    AddRef();

    // increment the dll refcount
    InterlockedIncrement(&gcRefServerDll);
}
// ----------------------------------------------------------- CServerClassFactory::~CServerClassFactory
// destructor ..
CServerClassFactory::~CServerClassFactory(void)
{
    // decrement the dll refcount
    InterlockedDecrement(&gcRefServerDll);
}
// ----------------------------------------------------------- CServerClassFactory::QueryInterface
STDMETHODIMP CServerClassFactory::QueryInterface(
                                                REFIID riid, 
                                                PPVOID ppv)
{
    // Reflexive Response - return our own base Interface class pointer cast appropriately
    if( IsEqualIID(riid, IID_IUnknown) ) {
        *ppv = (LPUNKNOWN) (LPCLASSFACTORY) this;
    } else {
        // Reflexive Response - return our own class pointer 
        if( IsEqualIID(riid, IID_IClassFactory) ) {
            *ppv = (LPCLASSFACTORY) this;
        } else {
            // unsupported interface requested for 
            *ppv = NULL;
            return(ResultFromScode (E_NOINTERFACE));
        }
    }

    // add reference count every time a pointer is provided
    AddRef();

    return(NOERROR);
}
// ----------------------------------------------------------- CServerClassFactory::AddRef
STDMETHODIMP_(ULONG)CServerClassFactory::AddRef(void)
{
    InterlockedIncrement((LPLONG)&m_ServerCFactory_refcount);
    return(m_ServerCFactory_refcount);
}
// ----------------------------------------------------------- CServerClassFactory::Release
STDMETHODIMP_(ULONG)CServerClassFactory::Release(void)
{
    InterlockedDecrement((LPLONG)&m_ServerCFactory_refcount);

    if( m_ServerCFactory_refcount == 0 ) {
        delete this;
        return(0);
    } else {
        return(m_ServerCFactory_refcount);
    }
}
// -----------------------------------------------------------
/*------------------------------------------------------------  CServerClassFactory::CreateInstance
** CServerClassFactory::CreateInstance
*
*  PARAMETERS   : pUnkOuter = Pointer to controlling unknown
*                 riid      = Reference to interface ID specifier
*                 ppvObj    = Pointer to location to receive interface pointer
*  DESCRIPTION  : CreateInstance is the class factory implementation.
*                 It is called by the client to create the IServerCharacterstics interface
*                 It is called by the members of the IServerCharacteristics interface 
*                   viz CreatePropertySheet and CreateDiagnostics to create the
*                   appropriate interfaces for each.
*
*  RETURNS      : HRESULT code signifying success or failure
*
*  AUTHOR       :       Guru Datta Venkatarama  
*                       01/31/97 09:29:36 (PST)
*
------------------------------------------------------------*/

STDMETHODIMP CServerClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, PPVOID ppvObj)
{
    *ppvObj = NULL;
    HRESULT  hr=S_OK;

    // We don't support aggregation at this time!
    if( pUnkOuter != NULL )
        return(ResultFromScode(CLASS_E_NOAGGREGATION));

    // Instantiate a class factory object of the appropriate type and retrieve its pointer.
    if( IsEqualIID(riid, IID_IDIGameCntrlPropSheet) ) {
        LPCDIGAMECNTRLPROPSHEET pCServerProperty = new CDIGameCntrlPropSheet();

        if( pCServerProperty == NULL ) {
            return(ResultFromScode(E_OUTOFMEMORY));
        } else {
            // Get the interface pointer from QueryInterface and copy it to *ppvObj.
            hr = pCServerProperty->QueryInterface(riid, ppvObj);

            // add the reference and count to the parent in order to support "containment"
//      pCServerProperty->AddRef();

            // drop a refcount created by the constructor on the server property object
            pCServerProperty->Release ();
        }
    } else return(ResultFromScode (E_NOINTERFACE));

    return(hr);
}
/*------------------------------------------------------------ CServerClassFactory::LockServer
** CServerClassFactory::LockServer
*
*  PARAMETERS   :
*
*  DESCRIPTION  : LockServer increments or decrements the DLL's lock count.
*
*  RETURNS      :
*
*  AUTHOR       :       Guru Datta Venkatarama  
*                       01/31/97 18:40:17 (PST)
*  IMPLIMENTOR  :    Brycej   08/04/97
*
------------------------------------------------------------*/
STDMETHODIMP CServerClassFactory::LockServer(BOOL fLock)
{
    HRESULT hRes    = E_NOTIMPL;

    // increment/decrement based on fLock
    if( fLock ) {
        // increment the dll refcount
        InterlockedIncrement(&gcRefServerDll);
    } else {
        // decrement the dll refcount
        InterlockedDecrement(&gcRefServerDll);
    }

    // all done
    return(hRes);
}
// -----------------------------------------------------------
//****************************************************************************************************
//*********************************                                 **********************************
//****************************************************************************************************
// ----------------------------------------------------------- CImpIServerProperty::CImpIServerProperty
// constructor ..
CDIGameCntrlPropSheet::CDIGameCntrlPropSheet(void)
{
    m_cProperty_refcount = 0;
    AddRef();
    m_nID = -1;

    // increment the dll refcount
    InterlockedIncrement(&gcRefServerDll);
}
// ----------------------------------------------------------- CImpIServerProperty::~CImpIServerProperty
// destructor ..
CDIGameCntrlPropSheet::~CDIGameCntrlPropSheet(void)
{
    // decrement the dll refcount
    InterlockedDecrement(&gcRefServerDll);
}
// ----------------------------------------------------------- CImpIServerProperty::QueryInterface
STDMETHODIMP CDIGameCntrlPropSheet::QueryInterface(
                                                  REFIID riid, 
                                                  PPVOID ppv)
{
    // Reflexive Response - return our own base Interface class pointer cast appropriately
    if( IsEqualIID(riid, IID_IUnknown) ) {
        *ppv = (LPUNKNOWN) (LPCLASSFACTORY) this;
    } else {
        // Reflexive Response - return our own class pointer 
        if( IsEqualIID(riid, IID_IDIGameCntrlPropSheet) ) {
            *ppv = (LPCLASSFACTORY) this;
        } else {
            // unsupported interface requested for 
            *ppv = NULL;
            return(ResultFromScode (E_NOINTERFACE));
        }
    }

    // add reference count every time a pointer is provided
    AddRef();
    return(NOERROR);
}
// ----------------------------------------------------------- CImpIServerProperty::AddRef
STDMETHODIMP_(ULONG)CDIGameCntrlPropSheet::AddRef(void)
{
    // update and return our object's reference count
    InterlockedIncrement((LPLONG)&m_cProperty_refcount);

    return(m_cProperty_refcount);
}
// ----------------------------------------------------------- CImpIServerProperty::Release
STDMETHODIMP_(ULONG)CDIGameCntrlPropSheet::Release(void)
{
    // update and return our object's reference count
    InterlockedDecrement((LPLONG)&m_cProperty_refcount);

    if( m_cProperty_refcount == 0 ) {
        delete this;
        return(0);
    } else {
        return(m_cProperty_refcount);
    }
}
// ----------------------------------------------------------- CImpIServerProperty::ReportSheetStats
STDMETHODIMP CDIGameCntrlPropSheet::GetSheetInfo(LPDIGCSHEETINFO *svrshtptr) 
{
    // pass the pointer back to the caller
    *svrshtptr =(LPDIGCSHEETINFO) &sheet_info;

    // return   
    return(S_OK);
}   
// ----------------------------------------------------------- CImpIServerProperty::ReportPageStats
STDMETHODIMP CDIGameCntrlPropSheet::GetPageInfo(LPDIGCPAGEINFO * svrpagptr)
{
    pjd = JoystickDataInit();

    if( pjd == NULL ) {
        *svrpagptr = NULL;
        return(E_FAIL);
    }

    jdp.pjd = pjd;
    page_info[0].lParam = (LPARAM) &jdp;

    // pass pages information report structure pointer  back to the caller
    *svrpagptr = (LPDIGCPAGEINFO)page_info; 

    // return
    return(S_OK);
}

STDMETHODIMP CDIGameCntrlPropSheet::SetID(USHORT nID)
{
    gnID = m_nID = nID;
    return(S_OK);
}


/*
// ----------------------------------------------------------
BOOL SetDialogItemText( HWND hdlg, UINT nctrl, UINT nstr )
{
    CString * pszDialogString= new CString;
    
    ASSERT(pszDialogString);

    if(pszDialogString) 
   {
        pszDialogString->LoadString(nstr);
        SetDlgItemText( hdlg, nctrl, (LPCTSTR)*pszDialogString);

      if (pszDialogString)
           delete(pszDialogString);

        return(TRUE);
    }
    
   if (pszDialogString)
      delete (pszDialogString);

    return(FALSE);
}
*/

// ----------------------------------------------------------
LRESULT SetJoyInfo(UINT nID, LPCSTR szOEMKey)
{
    if( !strcmp(szOEMKey, "Microsoft SideWinder 3D Pro") )
        fIsSideWinder = 1;
    jdp.iJoyId = gnID;
    gpgv = &pjd->pgvlist[gnID];
    return(NOERROR);
}



// -------------------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\handler\plugsrvr.h ===
/************************** Om ***********************************
******************************************************************
*
*    Server Includes.
*
*    AUTHOR: Guru Datta Venkatarama
*
*    HISTORY:
*			   Created : 02/11/97
*  
*
*    SUMMARY:  
*
******************************************************************
(c) Microsoft 1997 - All right reserved.
******************************************************************/
#include "ifacesvr.h"

#ifndef _SERVER_PLUG_IN_
#define _SERVER_PLUG_IN_

/*------------------------------------------------------------
** Server Class Factory
*
*  DESCRIPTION  : ClassFactory Object for the In Proc Server
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       02/11/97 15:47:32 (PST)
*
------------------------------------------------------------*/
class CServerClassFactory : public IClassFactory
{
	protected:
		ULONG   			m_ServerCFactory_refcount;         // Object reference count
    
	public:
		// constructor
		CServerClassFactory(void);
		// destructor
		~CServerClassFactory(void);
        
		// IUnknown methods
		STDMETHODIMP            QueryInterface(REFIID, PPVOID);
		STDMETHODIMP_(ULONG)    AddRef(void);
		STDMETHODIMP_(ULONG)    Release(void);
    
		// IClassFactory methods
		STDMETHODIMP    		CreateInstance(LPUNKNOWN, REFIID, PPVOID);
		STDMETHODIMP    		LockServer(BOOL);
};
/*------------------------------------------------------------
** Property Sheet Class on the Plug in server
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       02/11/97 14:52:23 (PST)
*
------------------------------------------------------------*/
class CDIGameCntrlPropSheet : public IDIGameCntrlPropSheet
{
	friend					CServerClassFactory;
	private:
		DWORD				m_cProperty_refcount;
//		tpCPluginHandler	m_pHandler;
		
	public:
		CDIGameCntrlPropSheet(void);
		~CDIGameCntrlPropSheet(void);
		
		// IUnknown methods
	    STDMETHODIMP            QueryInterface(REFIID, PPVOID);
	    STDMETHODIMP_(ULONG)    AddRef(void);
	    STDMETHODIMP_(ULONG)    Release(void);
		
		// CImpIServerProperty methods
		// %%% debug %%% add more methods here for fully modeless operation ? 
		STDMETHODIMP			GetSheetInfo(LPDIGCSHEETINFO *lpSheetInfo);
		STDMETHODIMP			GetPageInfo (LPDIGCPAGEINFO  *lpPageInfo );
		STDMETHODIMP			SetID(USHORT nID);
	    STDMETHODIMP_(USHORT)   GetID(void);
};
// ----------------------------------------------------------

inline void SetServerRefCounter(UINT l_setval);
inline UINT GetServerRefCounter(void);
inline UINT DllServerRelease(void);
inline UINT DllServerAddRef(void);

#endif
//---------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\handler\hsvrguid.h ===
// --------------------------------------------
// Servers GUID's
// Author	: Guru Datta Venkatarama
// Date		: 1/20/1997
// Project	: ATLAS 1.0
// Notes 	: All the GUIDS here have been generated new as of 2/25/97. Hence
//			  They are guaranteed to be unique.
//				 {7854FB21-8EE3-11d0-A1AC-0000F8026977}
//				 {7854FB22-8EE3-11d0-A1AC-0000F8026977}
//				 {7854FB23-8EE3-11d0-A1AC-0000F8026977}
//				 {92187321-72B4-11d0-A1AC-0000F8026977}
//				 {92187322-72B4-11d0-A1AC-0000F8026977}
//				 {92187323-72B4-11d0-A1AC-0000F8026977}
//				 {92187323-72B4-11d0-A1AC-0000F8026977}
//				 {92187324-72B4-11d0-A1AC-0000F8026977}
//				 {92187325-72B4-11d0-A1AC-0000F8026977}
//				 {92187326-72B4-11d0-A1AC-0000F8026977}
// --------------------------------------------

// --------------------------------------------
// --------------------------------------------

#ifndef _HSVRGUID_
#define _HSVRGUID_
// These are the custom interfaces that we have defined
// {7854FB21-8EE3-11d0-A1AC-0000F8026977}
DEFINE_GUID(IID_IServerCharacteristics, 
0x7854fb21, 0x8ee3, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

#ifndef _DX_CPL_
// {7854FB22-8EE3-11d0-A1AC-0000F8026977}
DEFINE_GUID(IID_IDIGameCntrlPropSheet, 
0x7854fb22, 0x8ee3, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);
#endif //_DX_CPL_
// --------------------------------------------
// --------------------------------------------

// {92187321-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_FlashServer, 
0x92187321, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187322-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_MidasServer, 
0x92187322, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187323-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_ShazamServer, 
0x92187323, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187324-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_JoltServer, 
0x92187324, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187325-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_JunoServer, 
0x92187325, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// {92187326-72B4-11d0-A1AC-0000F8026977}
DEFINE_GUID(CLSID_LegacyServer, 
0x92187326, 0x72b4, 0x11d0, 0xa1, 0xac, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x77);

// --------------------------------------------
// --------------------------------------------
#endif
// -------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\handler\ifacesvr.h ===
/* ------------------------------------------------------------------------------------
----------																		-------
Plug In Server Interfaces Defintions.

Guru Datta Venkatarama		1/29/1997
----------																		-------
-------------------------------------------------------------------------------------*/
#include <objbase.h>
#include <hsvrguid.h>	// contains the handler and server inteface IID's and
						// the CLSID's for all our plug in servers
#include <sstructs.h>

#ifndef _PINTERFACEH_
#define _PINTERFACEH_
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
DECLARE_INTERFACE_( IServerCharacteristics, IUnknown)
{
	// IUnknown Members
	STDMETHOD(QueryInterface)	(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// CImpIServerProperty methods
	STDMETHOD(Launch)			(THIS_ HWND, USHORT, USHORT) PURE; 	
	STDMETHOD(GetReport)		(THIS_ LPDIGCSHEETINFO *lpSvrSheetInfo, LPDIGCPAGEINFO *lpServerPageInfo) PURE;
};

typedef IServerCharacteristics *pIServerCharacteristics;

DECLARE_INTERFACE_( IDIGameCntrlPropSheet, IUnknown)
{
	// IUnknown Members
	STDMETHOD(QueryInterface)	(THIS_ REFIID, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// IServerProperty Members
	STDMETHOD(GetSheetInfo)		(THIS_ LPDIGCSHEETINFO *) PURE; 	
	STDMETHOD(GetPageInfo)		(THIS_ LPDIGCPAGEINFO *) PURE; 	
	STDMETHOD(SetID)			(THIS_ USHORT nID) PURE;
	STDMETHOD_(USHORT, GetID)	(THIS) PURE; 	         	
											
};
typedef IDIGameCntrlPropSheet *LPIDIGAMECNTRLPROPSHEET;

#endif
//-----------------------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

USE_NTDLL=1
WIN32_WINNT_VERSION=0x500
!ENDIF

MAJORCOMP=shell
MINORCOMP=accesory
USE_PDB=1

TARGETNAME=GCDEF
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=DllMain
DLLBASE=0x71000000

!ifndef DXROOT
DXROOT=..\..\..\..
!endif

LINKER_STACKSIZE=-STACK:4096,1024

!IFDEF TARGET_WIN95
CHICAGO_PRODUCT=1
USE_MAPSYM = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DWIN95 -D_X86_ 
USE_MFC=1
!ELSE
C_DEFINES=$(C_DEFINES) -DWINNT -D_UNICODE 
LINKER_FLAGS=$(LINKER_FLAGS) -WS:AGGRESSIVE -HEAP:0x30D40,0x2000
USE_MFCUNICODE=1
!ENDIF

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(_NTBINDIR)\public\sdk\lib\*\uuid.lib     \
           $(_NTBINDIR)\public\sdk\lib\*\dinput.lib   \
           $(_NTBINDIR)\public\sdk\lib\*\user32.lib   \
           $(_NTBINDIR)\public\sdk\lib\*\gdi32.lib    \
           $(_NTBINDIR)\public\sdk\lib\*\kernel32.lib \
           $(_NTBINDIR)\public\sdk\lib\*\advapi32.lib \
           $(_NTBINDIR)\public\sdk\lib\*\comctl32.lib \
           $(_NTBINDIR)\public\sdk\lib\*\winmm.lib


INCLUDES=$(INCLUDES);                   \
     ..;                                \
     ..\..\handler;                     \
     ..\..\default;                     \
     $(DXROOT)\inc;                     \


DLLENTRY=DllMain
DLLDEF=..\GCDEF.DEF

SOURCES=\
        ..\joycal.cpp    \
        ..\joymisc.cpp   \
        ..\joytest.cpp   \
        ..\pov.cpp       \
        ..\server.cpp    \
        ..\joycpl.cpp    \
        ..\gcdef.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\handler\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\gcdef\sstructs.h ===
/* ------------------------------------------------------------------------------------
----------																		-------
Plug In Server Classes, Types & function prototypes Defintions.

Guru Datta Venkatarama		1/29/1997
----------																		-------
-------------------------------------------------------------------------------------*/


#ifndef _SERVERSTRUCT_H
#define _SERVERSTRUCT_H
// ------------------------------------ * STRUCTURES * -------
// maximum pages allowed on a server
#define MAX_PAGES 26

// errors returned by the handler on failure of a call to Launch
#define DIGCERR_ERRORSTART			0x80097000
#define DIGCERR_NUMPAGESZERO		0x80097001
#define DIGCERR_NODLGPROC			0x80097002
#define DIGCERR_NOPREPOSTPROC		0x80097003
#define DIGCERR_NOTITLE				0x80097004
#define DIGCERR_NOCAPTION			0x80097005
#define DIGCERR_NOICON				0x80097006
#define DIGCERR_STARTPAGETOOLARGE	0x80097007
#define DIGCERR_NUMPAGESTOOLARGE	0x80097008
#define DIGCERR_INVALIDDWSIZE		0x80097009
#define DIGCERR_ERROREND			0x80097100

// This structure is used to report all the characterstics of the plug in server to the
// client socket when requested through the IServerCharacteristics::GetReport method
#pragma pack (8)

typedef struct {
	DWORD			 dwSize;
	LPCWSTR	   		 lpwszPageTitle;
	DLGPROC	   		 fpPageProc;
	BOOL			 fProcFlag;
	DLGPROC	  		 fpPrePostProc;
	BOOL			 fIconFlag;
	LPCWSTR			 lpwszPageIcon;
    LPCWSTR        	 lpwszTemplate; 
	LPARAM			 lParam;
	HINSTANCE		 hInstance;
} DIGCPAGEINFO, *LPDIGCPAGEINFO;		// was tServerPageRep, *tServerPageRepPtr;

typedef struct {
	DWORD		dwSize;
	USHORT		nNumPages;
	LPCWSTR		lpwszSheetCaption;
	BOOL		fSheetIconFlag;
	LPCWSTR		lpwszSheetIcon;
} DIGCSHEETINFO, *LPDIGCSHEETINFO;	// was tServerSheetRep, *tServerSheetRepPtr;

// This structure is used to report all the characterstics of the plug in server to the
// client socket when requested through the IServerDiagnostics::GetPortInfo method

#endif   // _SERVERSTRUCT_H
//-----------------------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\handler\mainhand.cpp ===
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**
**    FILE:       MAINHANDLER.CPP 
**    DATE:       01/29/97
**    PROJ:       ATLAS
**    PROG:       Guru Datta Venkatarama  
**    COMMENTS:   Common interface to gaming devices in-proc servers
**
**    DESCRIPTION:This is the generic handler that supports a standard
**				      protocol to support plug in servers to implement its
**				      property sheet and diagnostics interface
**
**    NOTE:       
**
**    HISTORY:
**    DATE        WHO            WHAT
**    ----        ---            ----
**    1/29/97     Guru           CREATED
**    3/25/97     a-kirkh        ADDED COMMENTS
**
**
**
** Copyright (C) Microsoft 1997.  All Rights Reserved.
**
**~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

// %%% debug %%% check out the includes
#define INC_OLE2

#pragma pack (8)

#include "stdafx.h"
#include <objbase.h>
#include <initguid.h>								  
#include <shlobj.h>
#include <assert.h>

#ifndef _UNICODE
#include <malloc.h>     // needed for _alloca
#include <afxconv.h>
#endif

#include "mainhand.h"
#include "plugsrvr.h"


// BEGINNING OF UNICODE CONVERSION UTILITY DEFINITIONS
#ifndef USES_CONVERSION
#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0;
#endif
#endif // USES_CONVERSION

#ifndef A2W
#define A2W(lpa) (((LPCSTR)lpa == NULL) ? NULL : (_convert = (lstrlenA(lpa)+1),	AfxA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))
#endif // A2W

#ifndef W2A
#define W2A(lpw) (((LPCWSTR)lpw == NULL) ? NULL : (	_convert = (wcslen(lpw)+1)*2, AfxW2AHelper((LPSTR) alloca(_convert), lpw, _convert)))
#endif // W2A
// END OF UNICODE CONVERSION UTILITY DEFINITIONS


static USHORT g_cServerLocks;
static USHORT g_cComponents;

/*------------------------------------------------------------
** DllMain
*
*  DESCRIPTION  : Entry point into the Inprocess handler.
*				      Here is where it all begins !! This implementation
*				      is a single thread, in process handler. 
*
*  AUTHOR       :		Guru Datta Venkatarama  01/29/97 11:13:49 (PST)
*                    a-kirkh - Implemented reference counting
------------------------------------------------------------*/

int APIENTRY DllMain(
   HINSTANCE	hInstance, 
   DWORD		dwReason,
   LPVOID		lpReserved)
{
   switch (dwReason)
	{	
   	case DLL_PROCESS_ATTACH:
	   break;

	   case DLL_PROCESS_DETACH:
	   break;
	}
   return 1;
}

/*------------------------------------------------------------
*  DllGetClassObject
*
*  PARAMETERS   : rclsid = Reference to class ID specifier
*  				   riid   = Reference to interface ID specifier
*				      ppv    = Pointer to location to receive interface pointer
*
*  DESCRIPTION  : Here be the entry point of COM.
*				      DllGetClassObject is called by the Client socket to 
*				      create a class factory object.
*                 This Class factory will support the generation of three different class
*                 Objects.
*
*  RETURNS      : HRESULT code signifying success or failure
*
*  AUTHOR       :	Guru Datta Venkatarama 01/29/97 14:22:02 (PST)
*
------------------------------------------------------------*/
STDAPI DllGetClassObject(
	REFCLSID    rclsid, 
	REFIID      riid, 
	PPVOID      ppv)
{
   *ppv = NULL;

   if (!IsEqualIID (riid, IID_IClassFactory))
   {
      TRACE(TEXT("Mainhand.cpp: DllGetClassObject: Failed to find IID_IClassFactory!\n"));
      return ResultFromScode (E_NOINTERFACE);
   }

   CHandlerClassFactory *pClassFactory = new CHandlerClassFactory();
   ASSERT (pClassFactory);

	if (pClassFactory == NULL)
	{
		return ResultFromScode (E_OUTOFMEMORY);
	}
    
    // Get the interface pointer from QueryInterface and copy it to *ppv.
    // The required type of riid is automatically being passed in ....
    HRESULT hr = pClassFactory->QueryInterface (riid, ppv);
	 
	if(SUCCEEDED(hr))
		pClassFactory->m_CLSID_whoamI = rclsid;

    return hr;
}


/*------------------------------------------------------------
** DllCanUnloadNow
*
*  PARAMETERS   : None
*
*  DESCRIPTION  : DllCanUnloadNow is called by the shell to find out if the DLL can be
*                 unloaded. The answer is yes if (and only if) the module reference count
*   			      stored in g_cServerLocks and g_cComponents is 0.
*				      This Dll can be unloaded if and only if :
*                   a) All the in components that it "spawns" have been deleted and
*                   b) There are no locks on any of the class factory interfaces
*  RETURNS      : HRESULT code equal to S_OK if the DLL can be unloaded, S_FALSE if not
*  AUTHOR       :	Guru Datta Venkatarama 01/30/97 08:24:21 (PST)
*                 a-kirkh - Implemented.
*
------------------------------------------------------------*/
STDAPI DllCanUnloadNow(void)
{
	return ((!g_cComponents) && (!g_cServerLocks)) ? S_OK : S_FALSE;
}

/*------------------------------------------------------------
* CHandlerClassFactory Member Functions
*
*  DESCRIPTION  : This is the implementation of the standard member functions of the 
*				      Handler's class factory.
*
*  AUTHOR       :	Guru Datta Venkatarama 01/30/97 08:30:18 (PST)
*
------------------------------------------------------------*/
// constructor ..
CHandlerClassFactory::CHandlerClassFactory(void):m_ClassFactory_refcount(0){}

// -----------------------------------------------------------
// destructor ..
CHandlerClassFactory::~CHandlerClassFactory(void){/**/}

// -----------------------------------------------------------
STDMETHODIMP CHandlerClassFactory::QueryInterface(
	REFIID riid, 
	PPVOID ppv)
{    
    if (IsEqualIID(riid, IID_IUnknown)) 
    {
        *ppv = (LPUNKNOWN) (LPCLASSFACTORY) this;
        // add reference count every time a pointer is provided
        AddRef();
        return NOERROR;
    }
    else 
    {
		if (IsEqualIID(riid, IID_IClassFactory)) 
		{
		   *ppv = (LPCLASSFACTORY) this;
        	// add reference count every time a pointer is provided
		   AddRef();
		   return NOERROR;
		}
		else 
		{  
		   // unsupported interface requested
		   *ppv = NULL;

         TRACE(TEXT("Mainhand.cpp: QueryInterface: Failed to find IID_IClassFactory!\n"));

		   return ResultFromScode (E_NOINTERFACE);
		}
    }
}
// -----------------------------------------------------------
STDMETHODIMP_(ULONG)CHandlerClassFactory::AddRef(void)
{
    // bump up the usage count
	InterlockedIncrement((LPLONG)&m_ClassFactory_refcount);
	return m_ClassFactory_refcount;
}


// -----------------------------------------------------------
STDMETHODIMP_(ULONG)CHandlerClassFactory::Release(void)
{
	InterlockedDecrement((LPLONG)&m_ClassFactory_refcount);

	if(m_ClassFactory_refcount > 0)
	{
		return (m_ClassFactory_refcount);
	}
	else
	{
		delete this;
		return 0;
	}
}
// -----------------------------------------------------------

/*------------------------------------------------------------
** CHandlerClassFactory::CreateInstance
*
*  PARAMETERS   : pUnkOuter = Pointer to controlling unknown
*				      riid      = Reference to interface ID specifier
*				      ppvObj    = Pointer to location to receive interface pointer
*  DESCRIPTION  : CreateInstance is the class factory implementation.
*				      It is called by the client to create the IServerCharacterstics interface
*				      It is called by the members of the IServerCharacteristics interface 
*					   viz CreatePropertySheet and CreateDiagnostics to create the
*					   appropriate interfaces for each.
*
*  RETURNS      : HRESULT code signifying success or failure
*
*  AUTHOR       :	Guru Datta Venkatarama 01/31/97 09:29:36 (PST)
*
------------------------------------------------------------*/

STDMETHODIMP CHandlerClassFactory::CreateInstance(
	LPUNKNOWN pUnkOuter, 
	REFIID riid,
    PPVOID ppvObj)
{
   *ppvObj = NULL;
   HRESULT	  hr=S_OK;

   //Cannot aggregate here
   if (pUnkOuter != NULL)
   {
      return ResultFromScode(CLASS_E_NOAGGREGATION);
   }
	
   CPluginHandler *pCPluginHandler = new CPluginHandler;
   ASSERT (pCPluginHandler);

	if (!pCPluginHandler)  return E_OUTOFMEMORY;
	
	hr = pCPluginHandler->QueryInterface(riid, ppvObj);
   
   // Init the CLSID
   if(SUCCEEDED(hr))
      pCPluginHandler->m_CLSID_whoamI = m_CLSID_whoamI;
	
	return hr;
}

/*------------------------------------------------------------
** LockServer
*
*  PARAMETERS   :
*
*  DESCRIPTION  : LockServer increments or decrements the DLL's lock count.
*
*  RETURNS      :
*
*  AUTHOR       : Guru Datta Venkatarama 01/31/97 18:40:17 (PST)
*                 a-kirkh - Implemented
*
------------------------------------------------------------*/

STDMETHODIMP CHandlerClassFactory::LockServer(BOOL fLock)
{
   if(fLock)
	   InterlockedIncrement((LPLONG)&g_cServerLocks);
   else
	   InterlockedDecrement((LPLONG)&g_cServerLocks);

   return S_OK;
}


/*------------------------------------------------------------
** CPluginHandler Object member functions
*
*  PARAMETERS   :
*
*  DESCRIPTION  :
*
*  RETURNS      :
*
*  AUTHOR       : Guru Datta Venkatarama 02/03/97 10:55:34 (PST)
*                 a-kirkh - cleaned up the ref-counting
*
------------------------------------------------------------*/
CPluginHandler::CPluginHandler(void)
{
	InterlockedIncrement((LPLONG)&g_cComponents);
	m_pImpIServerProperty	  = NULL;
	m_cPluginHandler_refcount = 0;
	return;
}	

// -----------------------------------------------------------
CPluginHandler::~CPluginHandler(void)
{
	InterlockedDecrement((LPLONG)&g_cComponents);
	return;
}	

// -----------------------------------------------------------
STDMETHODIMP CPluginHandler::QueryInterface(
	REFIID riid, 
	PPVOID ppv)
{
   if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IServerCharacteristics)) 
   {
	   *ppv = this;
	}
	else
	{
		*ppv = NULL;

      TRACE(TEXT("Mainhand.cpp: QueryInterface: riid is != IID_IUnknown || IID_IServerCharacteristics!\n"));

		return ResultFromScode (E_NOINTERFACE);
	}

    AddRef();
    return(S_OK);
}
// -----------------------------------------------------------CPluginHandler::AddRef
STDMETHODIMP_(ULONG)CPluginHandler::AddRef(void)
{
    // bump up the usage count
	InterlockedIncrement((LPLONG)&m_cPluginHandler_refcount);
	return(m_cPluginHandler_refcount);
}
// -----------------------------------------------------------CPluginHandler::Release

STDMETHODIMP_(ULONG)CPluginHandler::Release(void)
{
	InterlockedDecrement((LPLONG)&m_cPluginHandler_refcount);
	if(m_cPluginHandler_refcount > 0)
	{
		return(m_cPluginHandler_refcount);
	}
	else
	{
		delete this;
		return 0;
	}
}

/*------------------------------------------------------------CPluginHandler::Launch
** CPluginHandler::Launch
*
*  PARAMETERS   : hWnd - Handle to window of the client (Control Panel) 
*				  startpage - Page to start with
*				  nID - Joystick ID that the device associated with this page is on!
*
*  DESCRIPTION  : Restricts the building of property pages to our supported method.
*
*  RETURNS      : Error standard COM error codes or our errors from E_ERROR_START to E_ERROR_STOP (defined in sstructs.h)
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       02/03/97 14:47:47 (PST)
*
------------------------------------------------------------*/
STDMETHODIMP CPluginHandler::Launch(HWND hWnd, USHORT startpage, USHORT nID)
{
   LPDIGCPAGEINFO			serverpage;
   LPDIGCSHEETINFO		serversheet;
   LPPROPSHEETPAGE 		pspptr;
	UINT					   loop_index;
	LPCDIGAMECNTRLPROPSHEET	propiface;
	HRESULT					hr=S_OK;

	ASSERT (::IsWindow(hWnd));

	if (startpage > MAX_PAGES)
		return DIGCERR_STARTPAGETOOLARGE;

	// check to make certain that the server has the required interface
	// step A : do we have an interface to work with ?
	// 
	if(!(propiface = GetServerPropIface()))
	{

      TRACE(TEXT("Mainhand.cpp: Launch: GetPropIface didn't find IID_IDIGameCntrlPropSheet!\n"));
		return ResultFromScode (E_NOINTERFACE);
	}

	// Step B. Use the interface ...
	// step 1 : get the property sheet info from the server
	if (FAILED(propiface->GetSheetInfo(&serversheet)))
   {
      TRACE(TEXT("GCHAND.DLL: MAINHAND.CPP: Launch: GetSheetInfo Failed!\n"));
      return E_FAIL;
   }

	if (serversheet->nNumPages > MAX_PAGES)
	{
		return DIGCERR_NUMPAGESTOOLARGE;
	}

	// step 2 : get the information for all the pages from the server
	if (FAILED(propiface->GetPageInfo(&serverpage)))
   {
      TRACE(TEXT("GCHAND.DLL: MAINHAND.CPP: Launch: GetPageInfo Failed!\n"));
      return E_FAIL;
   }

   /* BLJ: REMOVED 1/12/98
   // return for testing of interface!!!
#ifdef _DEBUG
	USES_CONVERSION;

	// PAGE TRACE MESSAGES
	for(loop_index=0; loop_index < serversheet->nNumPages; loop_index++)
	{
		TRACE(TEXT("GetPageInfo: Page %d dwSize is %d, expected %d\n"), loop_index, serverpage[loop_index].dwSize, sizeof(DIGCPAGEINFO));
#ifdef _UNICODE
		TRACE(TEXT("GetPageInfo: Page %d lpwszPageTitle (AFTER ANSI CONVERSION) is %s\n"), loop_index, serverpage[loop_index].lpwszPageTitle);
#else
		TRACE(TEXT("GetPageInfo: Page %d lpwszPageTitle (AFTER ANSI CONVERSION) is %s\n"), loop_index, W2A(serverpage[loop_index].lpwszPageTitle));
#endif
                                                              
		if (serverpage[loop_index].fpPageProc)
			TRACE(TEXT("GetPageInfo: Page %d Has an assigned page proc!\n"), loop_index);
		else 
			TRACE(TEXT("GetPageInfo: Page %d Has NO assigned page proc!\n"), loop_index);

		if (serverpage[loop_index].fProcFlag)
		{
			TRACE(TEXT("GetPageInfo: Page %d Has a PrePostPage proc and %s\n"), loop_index, 
				(serverpage[loop_index].fpPrePostProc) ? "it is NOT NULL" : "it is NULL!");
			
		}
		else TRACE(TEXT("GetPageInfo: Page %d's PrePostPage proc flag is FALSE!\n"), loop_index);

		if (serverpage[loop_index].fIconFlag)
		{
			TRACE(TEXT("GetPageInfo: Page %d's fIconFlag flag is TRUE!\n"), loop_index);
		}
		else 
			TRACE(TEXT("GetPageInfo: Page %d's fIconFlag flag is FALSE!\n"), loop_index);

		TRACE(TEXT("GetPageInfo: Page %d's lParam is %d\n"), loop_index, serverpage[loop_index].lParam);
//		TRACE(TEXT("GetPageInfo: Page %d's lpwszTemplate (AFTER ANSI CONVERSION) is %s\n"), loop_index, W2A(serverpage[loop_index].lpwszTemplate));
		TRACE(TEXT("GetPageInfo: Page %d's hInstance is %x\n"), loop_index, serverpage[loop_index].hInstance);
	}

	// SHEET TRACE MESSAGES!!!
	TRACE (TEXT("GetSheetInfo: dwSize %d, expected %d\n"), serversheet->dwSize, sizeof(DIGCSHEETINFO));
	TRACE (TEXT("GetSheetInfo: nNumPages %d\n"), serversheet->nNumPages);
#ifdef _UNICODE
	TRACE (TEXT("GetSheetInfo: lpwszSheetCaption (AFTER CONVERSION TO ANSI) is %s\n"), serversheet->lpwszSheetCaption);
#else
	TRACE (TEXT("GetSheetInfo: lpwszSheetCaption (AFTER CONVERSION TO ANSI) is %s\n"), W2A(serversheet->lpwszSheetCaption));
#endif

	if (serversheet->fSheetIconFlag)
	{
		TRACE (TEXT("GetSheetInfo: fSheetInfoFlag is set to TRUE!\n"));
//		TRACE (TEXT("GetSheetInfo: lpwszSheetIcon (AFTER CONVERSION TO ANSI) is %s\n"), W2A(serversheet->lpwszSheetIcon));
	}
	else
		TRACE (TEXT("GetSheetInfo: fSheetInfoFlag is set to FALSE!\n"));
#endif
   */

	// here's where we are sending the property sheet an ID describing the location of the installed device!
	hr = propiface->SetID(nID);
	ASSERT (SUCCEEDED(hr));

	// step 3 : construct the property pages structure
	// 3.1 allocate an array of PROPERTYSHEETPAGE for the number of pages required
	if(!(pspptr = (LPPROPSHEETPAGE) malloc(sizeof(PROPSHEETPAGE)*serversheet->nNumPages)))
	{
        return ResultFromScode (E_OUTOFMEMORY);
	}
	else
	{
#ifndef _UNICODE
		USES_CONVERSION;
#endif

		// 	 3.2 Now proceed to fill up each page
		for(loop_index=0;loop_index<serversheet->nNumPages;loop_index++)
		{
			// transfer data .. the size 
			pspptr[loop_index].dwSize		= sizeof(PROPSHEETPAGE);
			// 	transfer the lparam value
			pspptr[loop_index].lParam 		= serverpage[loop_index].lParam;

			// ---------- TITLING OF THE PAGE ----------------------------
			// set the basic flags
			pspptr[loop_index].dwFlags = 0;

			if (serverpage[loop_index].lpwszPageTitle)
			{
				pspptr[loop_index].dwFlags |= PSP_USETITLE; 

            // Check to see if you are a String!!!
            if (HIWORD((INT_PTR)serverpage[loop_index].lpwszPageTitle))
            {
#ifdef _UNICODE
					pspptr[loop_index].pszTitle = serverpage[loop_index].lpwszPageTitle;
#else
					pspptr[loop_index].pszTitle = W2A(serverpage[loop_index].lpwszPageTitle);
#endif
            }
            else pspptr[loop_index].pszTitle = (LPTSTR)serverpage[loop_index].lpwszPageTitle;
			}
			else
			{
				pspptr[loop_index].pszTitle = NULL;
			}

/*
			if (!lstrlen(pspptr[loop_index].pszTitle))
			{
				return DIGCERR_NOTITLE;
			}
*/

			// if icon is required go ahead and add it.
			if(serverpage[loop_index].fIconFlag)
			{
				pspptr[loop_index].dwFlags |= PSP_USEICONID;

				// Check to see if you are an INT or a String!
                                if (HIWORD((INT_PTR)serverpage[loop_index].lpwszPageIcon))
				{
					// You're a string!!!
#ifdef _UNICODE
					pspptr[loop_index].pszIcon	= serverpage[loop_index].lpwszPageIcon;
#else
					pspptr[loop_index].pszIcon	= W2A(serverpage[loop_index].lpwszPageIcon);
#endif
				}
				else pspptr[loop_index].pszIcon = (LPCTSTR)(serverpage[loop_index].lpwszPageIcon);

			}

			// ---------- PROCEDURAL SUPPORT FOR THE PAGE ----------------
			// if a pre - post processing call back proc is required go ahead and add it
			if(serverpage[loop_index].fProcFlag)
			{
				if(serverpage[loop_index].fpPrePostProc)
				{
					pspptr[loop_index].dwFlags |= PSP_USECALLBACK;
					pspptr[loop_index].pfnCallback	= (LPFNPSPCALLBACK) serverpage[loop_index].fpPrePostProc;
				}
				else
				{
					return DIGCERR_NOPREPOSTPROC;
				}
			}

			// and the essential "dialog" proc
			if(serverpage[loop_index].fpPageProc)			
			{
				pspptr[loop_index].pfnDlgProc = serverpage[loop_index].fpPageProc;
			}
			else
			{
				return DIGCERR_NODLGPROC;
			}
			  
			// ---------- INSTANCE & PARENTHOOD --------------------------
			pspptr[loop_index].hInstance	 = serverpage[loop_index].hInstance;
   	   pspptr[loop_index].pcRefParent = 0; 			
			
			// ---------- DIALOG TEMPLATE --------------------------------
         if (HIWORD((INT_PTR)serverpage[loop_index].lpwszTemplate))
         {
#ifdef _UNICODE
			pspptr[loop_index].pszTemplate = serverpage[loop_index].lpwszTemplate;
#else
			pspptr[loop_index].pszTemplate = W2A(serverpage[loop_index].lpwszTemplate);
#endif
         }
			else 
         {
            pspptr[loop_index].pszTemplate = (LPTSTR)serverpage[loop_index].lpwszTemplate;
         }

			// test to see if template will fit on the screen!
		}												  
	}

	// step 4 : construct the property sheet header
	// %%% debug %%% - strange stuff - not there in include file ! PSH_MULTILINETABS |
	LPPROPSHEETHEADER 		ppsh = new (PROPSHEETHEADER);
	ASSERT (ppsh);

	ZeroMemory(ppsh, sizeof(PROPSHEETHEADER));

	ppsh->dwSize		= sizeof(PROPSHEETHEADER);
	ppsh->dwFlags		= PSH_PROPSHEETPAGE;
	ppsh->hwndParent	= hWnd;

	if (serversheet->fSheetIconFlag)
	{
		if (serversheet->lpwszSheetIcon)
		{
			// check to see if you are an INT or a WSTR
         if (HIWORD((INT_PTR)serversheet->lpwszSheetIcon))
			{
				// You are a string!
#ifdef _UNICODE
				ppsh->pszIcon	= serversheet->lpwszSheetIcon;
#else
				USES_CONVERSION;
				ppsh->pszIcon	= W2A(serversheet->lpwszSheetIcon);
#endif
			}
			else ppsh->pszIcon = (LPTSTR)serversheet->lpwszSheetIcon;

         ppsh->dwFlags	|=	PSH_USEICONID;
		}
		else return DIGCERR_NOICON;
	}

	// do we have a sheet caption ?
	if (serversheet->lpwszSheetCaption)
	{
		// is the sheet caption provided physically existant ?
		if(wcslen(serversheet->lpwszSheetCaption))
		{
#ifdef _UNICODE
			ppsh->pszCaption	= serversheet->lpwszSheetCaption;
#else
			USES_CONVERSION;
			ppsh->pszCaption	= W2A(serversheet->lpwszSheetCaption);
#endif

         ppsh->dwFlags |= PSH_PROPTITLE;
		}
		else
		{
			return DIGCERR_NOCAPTION;
		}
	}

	// test for user error!
	if (!serversheet->nNumPages)	
		return DIGCERR_NUMPAGESZERO;

	// set the number of pages %%% debug %%% is this limit appropriate ?
	ppsh->nPages = serversheet->nNumPages;	

	// ( and whilst at it ) : select the current page
	if (serversheet->nNumPages > startpage)
		ppsh->nStartPage	= startpage;
	else 
		return DIGCERR_STARTPAGETOOLARGE;
	
	// set the property pages inofrmation into the header
	ppsh->ppsp = (LPCPROPSHEETPAGE)pspptr;

	// and set the standard call back function for the property sheet
	ppsh->pfnCallback	= NULL; 

	// step 5 : launch modal property sheet dialog
	switch (PropertySheet(ppsh))
   {
      // In the event that the user wants to reboot...
      case ID_PSREBOOTSYSTEM:
      case ID_PSRESTARTWINDOWS:
#ifdef _DEBUG
        TRACE(TEXT("GCHAND.DLL: PropertySheet returned a REBOOT request!\n"));
#endif
        ExitWindowsEx(EWX_REBOOT, NULL);
        break;
   }

	if (ppsh)
		delete (ppsh);

 	if (pspptr)
		free (pspptr);

	// step 6 : release all elements of the Property interface on the server
	propiface->Release();
	// step 7 : return success / failure code back to the caller
	return(hr);	
}

/*------------------------------------------------------------CPluginHandler::GetReport
** CPluginHandler::GetReport
*
*  PARAMETERS   :
*
*  DESCRIPTION  :  Provides the client with a report of the number of property pages that
*        			 this server supports and their names
*
*  RETURNS      :
*
*  AUTHOR       :	Guru Datta Venkatarama 02/11/97 15:26:56 (PST)
*                 a-kirkh - Added asserts
*
------------------------------------------------------------*/
STDMETHODIMP CPluginHandler::GetReport(LPDIGCSHEETINFO *pServerSheetData, LPDIGCPAGEINFO *pServerPageData)
{
	// check out your parameters
	ASSERT (pServerSheetData);
	ASSERT (pServerPageData );

	LPCDIGAMECNTRLPROPSHEET	pPropIFace = GetServerPropIface();
	ASSERT (pPropIFace);

	if(!pPropIFace)
		return ResultFromScode (E_NOINTERFACE);

	// A little temp pointer for error trapping...
	LPDIGCSHEETINFO pTmpSheet;

	//  get the property sheet info from the server
	HRESULT hr = pPropIFace->GetSheetInfo(&pTmpSheet);
	ASSERT (SUCCEEDED(hr));

#ifdef _DEBUG
	// SHEET TRACE MESSAGES!!!
	USES_CONVERSION;
	TRACE (TEXT("GetSheetInfo: dwSize %d, expected %d\n"), pTmpSheet->dwSize, sizeof(DIGCSHEETINFO));
	TRACE (TEXT("GetSheetInfo: nNumPages %d\n"), pTmpSheet->nNumPages);
#ifdef _UNICODE
	TRACE (TEXT("GetSheetInfo: lpwszSheetCaption (AFTER CONVERSION TO ANSI) is %s\n"), pTmpSheet->lpwszSheetCaption);
#else
	TRACE (TEXT("GetSheetInfo: lpwszSheetCaption (AFTER CONVERSION TO ANSI) is %s\n"), W2A(pTmpSheet->lpwszSheetCaption));
#endif
	if (pTmpSheet->fSheetIconFlag)
	{
		TRACE (TEXT("GetSheetInfo: fSheetInfoFlag is set to TRUE!\n"));
	
      // Check to see if you are a string!
		if (HIWORD((INT_PTR)pTmpSheet->lpwszSheetIcon))
#ifdef _UNICODE
			TRACE (TEXT("GetSheetInfo: lpwszSheetIcon (AFTER CONVERSION TO ANSI) is %s\n"), pTmpSheet->lpwszSheetIcon);
#else
			TRACE (TEXT("GetSheetInfo: lpwszSheetIcon (AFTER CONVERSION TO ANSI) is %s\n"), W2A(pTmpSheet->lpwszSheetIcon));
#endif
		else
			TRACE (TEXT("GetSheetInfo: lpwszSheetIcon id is %d\n"), pTmpSheet->lpwszSheetIcon);
	}
	else
		TRACE (TEXT("GetSheetInfo: fSheetInfoFlag is set to FALSE!\n"));
#endif

	if (pTmpSheet->dwSize != sizeof(DIGCSHEETINFO))
	{
		TRACE (TEXT("MainHand: GetReport: Error - Call to GetSheetInfo returned an invalid dwSize parameter!\n"));
		
		// Just in case someone's not checking their return values...
		memset (pServerSheetData, 0, sizeof(DIGCSHEETINFO));

		pPropIFace->Release();
		return DIGCERR_INVALIDDWSIZE;
	}

	// A little temp pointer for error trapping...
	LPDIGCPAGEINFO  pTmpPage;

	hr = pPropIFace->GetPageInfo (&pTmpPage); 
	ASSERT (SUCCEEDED(hr));

#ifdef _DEBUG
	// PAGE TRACE MESSAGES!!!
	for(BYTE loop_index=0; loop_index < pTmpSheet->nNumPages; loop_index++)
	{
		TRACE(TEXT("GetPageInfo: Page %d dwSize is %d, expected %d\n"), loop_index, pTmpPage[loop_index].dwSize, sizeof(DIGCPAGEINFO));

#ifdef _UNICODE
		TRACE(TEXT("GetPageInfo: Page %d lpwszPageTitle (AFTER CONVERSION TO ANSI) is %s\n"), loop_index, pTmpPage[loop_index].lpwszPageTitle);
#else
		TRACE(TEXT("GetPageInfo: Page %d lpwszPageTitle (AFTER CONVERSION TO ANSI) is %s\n"), loop_index, W2A(pTmpPage[loop_index].lpwszPageTitle));
#endif

		if (pTmpPage[loop_index].fpPageProc)
			TRACE(TEXT("GetPageInfo: Page %d Has an assigned page proc!\n"), loop_index);
		else 
			TRACE(TEXT("GetPageInfo: Page %d Has NO assigned page proc!\n"), loop_index);

		if (pTmpPage[loop_index].fProcFlag)
		{
			TRACE(TEXT("GetPageInfo: Page %d Has a PrePostPage proc and %s\n"), loop_index, 
				(pTmpPage[loop_index].fpPrePostProc) ? "it is NOT NULL" : "it is NULL!");
			
		}
		else TRACE(TEXT("GetPageInfo: Page %d's PrePostPage proc flag is FALSE!\n"), loop_index);
												   
		if (pTmpPage[loop_index].fIconFlag)
		{
         // Check to see if you are a string!
			if (HIWORD((INT_PTR)pTmpPage[loop_index].lpwszPageIcon))
#ifdef _UNICODE
				TRACE (TEXT("GetSheetInfo: lpwszPageIcon #%d (AFTER CONVERSION TO ANSI) is %s\n"), loop_index, pTmpPage[loop_index].lpwszPageIcon);
#else
				TRACE (TEXT("GetSheetInfo: lpwszPageIcon #%d (AFTER CONVERSION TO ANSI) is %s\n"), loop_index, W2A(pTmpPage[loop_index].lpwszPageIcon));
#endif
			else
				TRACE (TEXT("GetSheetInfo: lpwszPageIcon #%d id is %d\n"), loop_index, pTmpSheet->lpwszSheetIcon);
		}
		else TRACE(TEXT("GetPageInfo: Page %d's fIconFlag flag is FALSE!\n"), loop_index);

		TRACE(TEXT("GetPageInfo: Page %d's lParam is %d\n"), loop_index, pTmpPage->lParam);
//		TRACE(TEXT("GetPageInfo: Page %d's lpwszTemplate (AFTER ANSI CONVERSION) is %s\n"), loop_index, W2A(pTmpPage[loop_index].lpwszTemplate));
		TRACE(TEXT("GetPageInfo: Page %d's hInstance is %d\n"), loop_index, pTmpPage->hInstance);
	}
#endif

	for (BYTE nIndex = 0; nIndex < pTmpSheet->nNumPages; nIndex++) 
	{
		if (pTmpPage[nIndex].dwSize != sizeof(DIGCPAGEINFO))
		{
			TRACE (TEXT("MainHand: GetReport: Error - Call to GetPageInfo returned an invalid dwSize parameter!\n"));

			// Just in case someone's not checking their return values...
			memset (pServerPageData, 0, sizeof(DIGCPAGEINFO));

			pPropIFace->Release();
			return DIGCERR_INVALIDDWSIZE;
		}
	}

	// Assign and return...
	*pServerSheetData = pTmpSheet;
	*pServerPageData  = pTmpPage;

	pPropIFace->Release();

	return S_OK;
}		
/*------------------------------------------------------------PropSheetCallback
** PropSheetCallback
*
*  PARAMETERS   :
*
*  DESCRIPTION  :
*
*  RETURNS      :
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       02/11/97 14:01:50 (PST)
*
------------------------------------------------------------*/
int CALLBACK PropSheetCallback(
    HWND  hDlg,	
    UINT  uMsg,	
    LPARAM  lParam)
{
	switch (uMsg)
	{
		case PSCB_INITIALIZED:
			break;
		case PSCB_PRECREATE:
			break;
	}
	return 0;
}
/*------------------------------------------------------------CPluginHandler::LoadServerInterface
************************************ PRIVATE TO THE CLASS ***************************************

** CPluginHandler::LoadServerInterface
*
*  PARAMETERS   :
*
*  DESCRIPTION  :
*
*  RETURNS      :
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       02/10/97 10:54:25 (PST)
*
------------------------------------------------------------*/
BOOL CPluginHandler::LoadServerInterface(REFIID interfaceId,PPVOID ppv)
{
	IClassFactory* ppv_classfactory;

	if(SUCCEEDED(CoGetClassObject( m_CLSID_whoamI, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&ppv_classfactory)))
	{
		if(SUCCEEDED(ppv_classfactory->CreateInstance(NULL, interfaceId, ppv)))
		{
			ppv_classfactory->Release();

			return TRUE;
		}
      else
      {
         TRACE(TEXT("Mainhand.cpp: CreateInstance Failed!\n"));
      }

		// make sure the pointer is nulled
		*ppv = NULL;

		ppv_classfactory->Release();
	}
   else
   {
      TRACE(TEXT("Mainhand.cpp: LoadServerInterface Failed!\n"));
   }

	// Its time for the swarming herd of turtles
	return FALSE;	
}
//*********************************************************************************************
// -------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\handler\mainhand.h ===
/************************** Om ***********************************
******************************************************************
*
*    MainHandler.h
*
*    AUTHOR: Guru Datta Venkatarama
*
*    HISTORY:
*			   Created : 01/29/97
*  
*
*    SUMMARY:  
*
******************************************************************
(c) Microsoft 1997 - All right reserved.
******************************************************************/

#include <ifacesvr.h>

#ifndef PPVOID
typedef LPVOID* PPVOID;
#endif

#ifndef _MAINHANDLER_H
#define _MAINHANDLER_H

/*------------------------------------------------------------
** CHandlerClassFactory
*
*  DESCRIPTION  : ClassFactory Object for the In Proc Handler
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       01/29/97 11:02:35 (PST)
*
------------------------------------------------------------*/
class CHandlerClassFactory : public IClassFactory
{
private:

protected:
    ULONG   				m_ClassFactory_refcount;         // Object reference count
    
public:

	GUID					m_CLSID_whoamI;
	// constructor
	CHandlerClassFactory(void);
	// destructor
    ~CHandlerClassFactory(void);
        
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);
    
    // IClassFactory methods
    STDMETHODIMP    		CreateInstance(LPUNKNOWN, REFIID, PPVOID);
    STDMETHODIMP    		LockServer(BOOL);

	ULONG GetRefCount(void) { return(m_ClassFactory_refcount); }
};

/*------------------------------------------------------------
** Property Sheet Interface Object
*
*  DESCRIPTION  : Here be the C object that implements the Property 
				  interface.
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       01/31/97 11:09:54 (PST)
*
------------------------------------------------------------*/
class   CDIGameCntrlPropSheet;
typedef CDIGameCntrlPropSheet *LPCDIGAMECNTRLPROPSHEET;

class CServerClassFactory;
/*------------------------------------------------------------
** Actual handler Object
*
*  DESCRIPTION  :  Here be the actual Plug in handler object class...
*
*  AUTHOR       :		Guru Datta Venkatarama  
*                       01/31/97 11:15:32 (PST)
*
------------------------------------------------------------*/
class CPluginHandler : public IServerCharacteristics
{

	friend CDIGameCntrlPropSheet;

	private:
		// server interfaces
		LPCDIGAMECNTRLPROPSHEET		m_pImpIServerProperty;
		BOOL						LoadServerInterface(REFIID, PPVOID); 	 

	public:
		// object lifetime maintanence count
		ULONG						m_cPluginHandler_refcount;
		// generic handler to specific server identity
		GUID						m_CLSID_whoamI;
		// constructor ...
		CPluginHandler(void);
		// destructor ....
		~CPluginHandler(void);

		// Class Diagnostics code :
		ULONG	GetRefCount(void) { return(m_cPluginHandler_refcount); }

	    // IUnknown methods
	    STDMETHODIMP            QueryInterface(REFIID, PPVOID);
	    STDMETHODIMP_(ULONG)    AddRef(void);
	    STDMETHODIMP_(ULONG)    Release(void);

		// CImpIServerProperty methods
		STDMETHODIMP			Launch(HWND hWnd, USHORT startpage, USHORT nID);
		STDMETHODIMP			GetReport(LPDIGCSHEETINFO *lpSheetInfo, LPDIGCPAGEINFO *lpPageInfo);

		// accessors to the contined classes Interface pointers
		LPCDIGAMECNTRLPROPSHEET	GetServerPropIface(void) 
		{ 
			if(LoadServerInterface(IID_IDIGameCntrlPropSheet, (void **)&m_pImpIServerProperty))
				return(m_pImpIServerProperty);
			else
				return(NULL);
		}
};

typedef CPluginHandler *tpCPluginHandler;
int CALLBACK PropSheetCallback(HWND  hDlg,UINT  uMsg,LPARAM  lParam);
#endif
//--------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\gamectrl\handler\sstructs.h ===
/* ------------------------------------------------------------------------------------
----------																		-------
Plug In Server Classes, Types & function prototypes Defintions.

Guru Datta Venkatarama		1/29/1997
----------																		-------
-------------------------------------------------------------------------------------*/


#ifndef _SERVERSTRUCT_H
#define _SERVERSTRUCT_H
// ------------------------------------ * STRUCTURES * -------
// maximum pages allowed on a server
#define MAX_PAGES 26

// errors returned by the handler on failure of a call to Launch
#define DIGCERR_ERRORSTART			0x80097000
#define DIGCERR_NUMPAGESZERO		0x80097001
#define DIGCERR_NODLGPROC			0x80097002
#define DIGCERR_NOPREPOSTPROC		0x80097003
#define DIGCERR_NOTITLE				0x80097004
#define DIGCERR_NOCAPTION			0x80097005
#define DIGCERR_NOICON				0x80097006
#define DIGCERR_STARTPAGETOOLARGE	0x80097007
#define DIGCERR_NUMPAGESTOOLARGE	0x80097008
#define DIGCERR_INVALIDDWSIZE		0x80097009
#define DIGCERR_ERROREND			0x80097100

// This structure is used to report all the characterstics of the plug in server to the
// client socket when requested through the IServerCharacteristics::GetReport method
#pragma pack (8)

typedef struct {
	DWORD			 dwSize;
	LPCWSTR	   		 lpwszPageTitle;
	DLGPROC	   		 fpPageProc;
	BOOL			 fProcFlag;
	DLGPROC	  		 fpPrePostProc;
	BOOL			 fIconFlag;
	LPCWSTR			 lpwszPageIcon;
    LPCWSTR        	 lpwszTemplate; 
	LPARAM			 lParam;
	HINSTANCE		 hInstance;
} DIGCPAGEINFO, *LPDIGCPAGEINFO;		// was tServerPageRep, *tServerPageRepPtr;

typedef struct {
	DWORD		dwSize;
	USHORT		nNumPages;
	LPCWSTR		lpwszSheetCaption;
	BOOL		fSheetIconFlag;
	LPCWSTR		lpwszSheetIcon;
} DIGCSHEETINFO, *LPDIGCSHEETINFO;	// was tServerSheetRep, *tServerSheetRepPtr;

// This structure is used to report all the characterstics of the plug in server to the
// client socket when requested through the IServerDiagnostics::GetPortInfo method

#endif   // _SERVERSTRUCT_H
//-----------------------------------------------------------------------------------EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\dciddi.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1995  Microsoft Corporation\Intel.  All Rights Reserved.
 * 
 **************************************************************************/
/*******************************************************************
 *
 *	FILE:		dciddi.h
 *	
 *	DESCRIPTION:	definitions for MS/Intel-defined DCI interface
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */                                                               
#define DCICOMMAND			3075
#define DCI_VERSION			0x0100

#define DCICREATEPRIMARYSURFACE		1 
#define DCICREATEOFFSCREENSURFACE       2 
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4 
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                              	0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4    

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN			    -17
#define DCI_ERR_YALIGN			    -18
#define DCI_ERR_XYALIGN			    -19
#define DCI_ERR_WIDTHALIGN		    -20
#define DCI_ERR_HEIGHTALIGN		    -21
											 
/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16				
#define DCI_STATUS_WASSTILLDRAWING         32


/* DCI Capability Flags */
#define DCI_SURFACE_TYPE			0x0000000F
#define DCI_PRIMARY                 		0x00000000
#define DCI_OFFSCREEN               		0x00000001
#define DCI_OVERLAY                 		0x00000002

#define DCI_VISIBLE                 		0x00000010
#define DCI_CHROMAKEY               		0x00000020
#define DCI_1632_ACCESS             		0x00000040
#define DCI_DWORDSIZE               		0x00000080
#define DCI_DWORDALIGN              		0x00000100
#define DCI_WRITEONLY               		0x00000200
#define DCI_ASYNC                   		0x00000400

#define DCI_CAN_STRETCHX            		0x00001000
#define DCI_CAN_STRETCHY            		0x00002000
#define DCI_CAN_STRETCHXY           		(DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN           		0x00004000
#define DCI_CAN_STRETCHYN           		0x00008000
#define DCI_CAN_STRETCHXYN          		(DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  1

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

/**************************************************************************
 *	input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the 
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
	DWORD	dwCommand;
	DWORD	dwParam1;
	DWORD 	dwParam2;
	DWORD	dwVersion;
	DWORD	dwReserved;
} DCICMD;
typedef  DCICMD FAR *LPDCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for 
 * the DCICREATE... calls.  The fields that are actually relevant differ for 
 * each of the three calls.  Details are in the DCI Spec chapter providing 
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
	DCICMD	cmd;							/* common header structure */
	DWORD   dwCompression;          		/* format of surface to be created                      */
	DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
	DWORD   dwWidth;                        /* height of the surface to be created          */
	DWORD   dwHeight;                       /* width of input surfaces                                      */
	DWORD	dwDCICaps;						/* capabilities of surface wanted */
	DWORD	dwBitCount;					/* bit depth of format to be created */
	LPVOID  lpSurface;                      /* pointer to an associated surface             */      
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;
		
/**************************************************************************
 *	surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary 
 * surface, and as a member of the larger structures returned by the 
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
	DWORD   dwSize;                 	/* size of structure                                            */
	DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
	DWORD   dwCompression;          	/* format of surface to be created                      */
	DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

	DWORD   dwWidth;                    /* width of surface                                             */
	DWORD   dwHeight;                   /* height of surface                                            */
	LONG    lStride;                    /* distance in bytes betw. one pixel            */
										/* and the pixel directly below it                      */
	DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
        DWORD   dwOffSurface;               /* offset of surface pointer                            */
	WORD    wSelSurface;                /* selector of surface pointer                          */
        WORD    wReserved;
	DWORD   dwReserved1;                /* reserved for provider */
	DWORD   dwReserved2;                /* reserved for DCIMAN */     
	DWORD   dwReserved3;                /* reserved for future */     
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
	void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */      
	void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;

/*
 * This structure is used by a DCI client to provide input parameters for the 
 * DCIEnumSurface call.
 */
typedef struct _DCIENUMINPUT {
	DCICMD	cmd;							/* common header structure */
	RECT    rSrc;                           /* source rect. for stretch  */
	RECT    rDst;                           /* dest. rect. for stretch       */
	void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
	LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;

/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;
								   
/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

	DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

	DCISURFACEINFO  dciInfo;                                                /* surface info                  */
	DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
	DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */                    

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')                                             
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\dibeng.inc ===
;/*
;----------------------------------------------------------------------------
; DIBENG.INC
; Copyright (c) 1992 Microsoft Corporation
;
; Dib Engine Interface Definitions
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; General Comments:
; The DIB Engine is non-palettized from GDI's perspective.  When an app
; selects a DIB into a memory DC, GDI will create a DIB Engine PDevice 
; (see definition below) and will stuff in a 'DI' in the deType field.
; Subsequent operations on this DC will result in calls to the DIB Engine
; with this PDevice.  
; Device drivers can also use the DIB Engine to handle most, if not all,
; of their rendering work.  A device driver exports the DIB Engine PDevice
; as it's own PDevice to GDI.  This PDevice contains a pointer to a 
; BitmapInfo header in the driver's data segment. Immediately following
; this is an optional color table for devices less than 16 bpp.
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; E Q U A T E S
;----------------------------------------------------------------------------
BRUSHSIZE	equ	8		;height and width in pixels.
VER_DIBENG      equ     400h            ;version = 4.0
TYPE_DIBENG     equ     'RP'            ;deType
comment ~
*/
#define BRUSHSIZE       8
#define VER_DIBENG      0x400
#define TYPE_DIBENG     0x5250
/*
end comment ~
;----------------------------------------------------------------------------
; S T R U C T U R E S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; PDevice Structure for the DIB Engine.  deType will contain 'DI' when GDI
; calls the DIB Engine to perform graphics operations on the dib.  deType 
; will contain a 0 or a Selector if a mini-driver is calling the DIB Engine 
; to do graphics operations. 
;----------------------------------------------------------------------------
deCursorExclude		equ deBeginAccess
deCursorUnexclude	equ deEndAccess
comment ~
*/
#define deCursorExclude	deBeginAccess
#define deCursorUnexclude deEndAccess
/*
end comment ~

DIBENGINE	    struc						      ;*/ typedef struct {                        /*
  deType            dw  ?               ; contains TYPE_DIBENG or 0           ;*/ WORD         deType;                    /*
  deWidth	    dw	?		; Width of dib in pixels	      ;*/ WORD         deWidth;                   /*
  deHeight	    dw	?		; Height of dib in pixels	      ;*/ WORD         deHeight;                  /*
  deWidthBytes	    dw	?		; #bytes per scan line		      ;*/ WORD         deWidthBytes;              /*
  dePlanes	    db	?		; # of planes in bitmap 	      ;*/ BYTE         dePlanes;                  /*
  deBitsPixel	    db	?		; # of bits per pixel		      ;*/ BYTE         deBitsPixel;               /*
  deReserved1	    dd	?		; cannot be used.		      ;*/ DWORD        deReserved1;               /*
  deDeltaScan       dd  ?               ; + or -. Displacement to next scan.  ;*/ DWORD        deDeltaScan;               /*
  delpPDevice	    dd	?		; Pointer to associated PDevice       ;*/ LPBYTE       delpPDevice;               /*
  deBits	    df	?		; fword offset to bits of dib	      ;*/ DWORD        deBitsOffset;              /*
                                        ;                                     ;*/ WORD         deBitsSelector;            /*
  deFlags	    dw	?		; additional flags		      ;*/ WORD         deFlags;                   /*
  deVersion	    dw  ?		; lsb=minor, msb=major (0400h = 4.0)  ;*/ WORD         deVersion;                 /*
  deBitmapInfo	    dd	?		; pointer to the bitmapinfo header    ;*/ LPBITMAPINFO deBitmapInfo;              /*
  deBeginAccess     dd	?		; Begin surface access call back      ;*/ void         (FAR *deBeginAccess)();    /*
  deEndAccess       dd	?		; End surface access call back	      ;*/ void         (FAR *deEndAccess)();      /*
  deDriverReserved  dd  ?		; Reserved for Minidriver use.        ;*/ DWORD        deDriverReserved;          /*
DIBENGINE	    ends		                                      ;*/ } DIBENGINE, FAR *LPDIBENGINE;          /*
;----------------------------------------------------------------------------
; Definitions for DIBEngine.deFlags
;----------------------------------------------------------------------------
MINIDRIVER      equ     0000000000000001b       ;display driver
PALETTIZED      equ     0000000000000010b       ;paletized device
SELECTEDDIB     equ     0000000000000100b       ;DIB Section
OFFSCREEN       equ     0000000000001000b       ;offscreen surface (use with VRAM)
DISABLED        equ     0000000000010000b	;going away -- please use BUSY instead [raypat]
BUSY            equ     0000000000010000b	;
NOT_FRAMEBUFFER	equ	0000000000100000b	;example: 8514/a
FIVE6FIVE	equ	0000000001000000b	;16 bpp, 565 color format.
NON64KBANK      equ     0000000010000000b       ;bank size is not 64K
VRAM            equ     1000000000000000b       ;physical surface (video memory)
BANKEDVRAM      equ     0100000000000000b       ;VFlatD simulated
BANKEDSCAN      equ     0010000000000000b       ;VFlatD simulated (broken rasters)
PALETTE_XLAT    equ     0001000000000000b       ;background palette xlat
VGADITHER       equ     0000100000000000b       ;dither to VGA colors (first 8, and last 8)
CTCHANGE        equ     0000010000000000b       ;color table has been changed
DITHER256       equ     0000001000000000b       ;dither to 256 fixed colors
FREE2           equ     0000000100000000b       ;free

BUSY_BIT        equ     4                       ;bit number to test for BUSY


comment ~
*/
#define MINIDRIVER      0x0001	  
#define PALETTIZED      0x0002	  
#define SELECTEDDIB     0x0004	  
#define OFFSCREEN       0x0008
#define DISABLED        0x0010
#define BUSY            0x0010		
#define NOT_FRAMEBUFFER 0x0020
#define FIVE6FIVE       0x0040
#define NON64KBANK      0x0080
#define VRAM            0x8000	  
#define BANKEDVRAM      0x4000	  
#define BANKEDSCAN      0x2000
#define PALETTE_XLAT    0x1000
#define VGADITHER       0x0800
#define CTCHANGE        0x0400
#define DITHER256       0x0200

#define BUSY_BIT        0x0004
/*
end comment ~

;----------------------------------------------------------------------------
; Definitions for DIBEngine.deBeginAccess flags
;----------------------------------------------------------------------------
FB_ACCESS   	equ     0000000000000001b
CURSOREXCLUDE  	equ     0000000000001000b

comment ~
*/
#define FB_ACCESS	0x0001
#define CURSOREXCLUDE	0x0008
/*
end comment ~


;----------------------------------------------------------------------------
; Definitions for most significant byte of a physical color.
;----------------------------------------------------------------------------
GREY_BIT        equ     01000000b       ;color is grey (r=g=b)
comment ~
*/
#define GREY_BIT        0x40	  
/*
end comment ~
;----------------------------------------------------------------------------
; DIB Engine Color Table entry structure. This structure is used by device
; drivers that are using DIB Engine services for rendering.  This structure
; is identical to the RGBQuad structure except for some bit definitions
; in the 4th byte.
;----------------------------------------------------------------------------
DIBColorEntry	struc							      ;*/ typedef struct {		  /*
  dceBlue	    db	?                                                     ;*/ BYTE dceBlue;	                  /*
  dceGreen	    db	?                                                     ;*/ BYTE dceGreen;                  /*
  dceRed	    db	?                                                     ;*/ BYTE dceRed;	                  /*
  dceFlags          db  ?                                                     ;*/ BYTE dceFlags;                  /*
DIBColorEntry	ends                                                          ;*/ } DIBColorEntry;                /*
;----------------------------------------------------------------------------
; Definitions for DIBColorEntry.dceFlags
;----------------------------------------------------------------------------
NONSTATIC	equ	10000000b      ;Inhibits color matching to this entry.
MAPTOWHITE	equ	00000001b      ;0=Black, 1=White
comment ~
*/
#define NONSTATIC       0x80	  
#define MAPTOWHITE      0x01	  
/*
end comment ~
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; DIB Engine Physical Object Definitions
;----------------------------------------------------------------------------

DIB_Pen	struc                                                                 ;*/ typedef struct {                /*  
dpPenStyle	dw	?                                                     ;*/ WORD  dpPenStyle;               /*  
dpPenFlags	db	?		;currently none undefined.            ;*/ BYTE  dpPenFlags;               /*
dpPenBpp	db	?	                                              ;*/ BYTE  dpPenBpp;                 /*
dpPenMono	dd	?                                                     ;*/ DWORD dpPenMono;                /*
dpPenColor	dd	?                                                     ;*/ DWORD dpPenColor;               /*
DIB_Pen	ends                                                                  ;*/ } DIB_Pen;                      /*

DIB_Brush1	struc                                                         ;*/ typedef struct {                /*  
dp1BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp1BrushFlags;            /*
dp1BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp1BrushBpp;              /*
dp1BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp1BrushStyle;            /*
dp1FgColor	dd	?		    ;Physical fg color                ;*/ DWORD dp1FgColor;               /*
dp1Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp1Hatch;                 /*
dp1BgColor	dd	?		    ;Physical bg color                ;*/ DWORD dp1BgColor;               /*
dp1BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp1BrushMono [BRUSHSIZE*4];/*
dp1BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp1BrushMask [BRUSHSIZE*4];/*
dp1BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 1 bit/pixel ;*/ BYTE dp1BrushBits [BRUSHSIZE*4];/* 
DIB_Brush1	ends                                                          ;*/ } DIB_Brush1;                   /*  

DIB_Brush4	struc                                                         ;*/ typedef struct {                /*  
dp4BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp4BrushFlags;            /*
dp4BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp4BrushBpp;              /*
dp4BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp4BrushStyle;            /*
dp4FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp4FgColor;               /*
dp4Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp4Hatch;                 /*
dp4BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp4BgColor;               /*
dp4BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp4BrushMono [BRUSHSIZE*4];/*
dp4BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp4BrushMask [BRUSHSIZE*4];/*
dp4BrushBits	db	BRUSHSIZE*4 dup (?) ;8 rows, 8 columns of 4 bit/pixel ;*/ BYTE dp4BrushBits [BRUSHSIZE*4];/* 
DIB_Brush4	ends                                                          ;*/ } DIB_Brush4;                   /*  

DIB_Brush8	struc                                                         ;*/ typedef struct {                /*  
dp8BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp8BrushFlags;            /*
dp8BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp8BrushBpp;              /*
dp8BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp8BrushStyle;            /*
dp8FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp8FgColor;               /*
dp8Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp8Hatch;                 /*
dp8BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp8BgColor;               /*
dp8BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp8BrushMono [BRUSHSIZE*4];/*
dp8BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp8BrushMask [BRUSHSIZE*4];/*
dp8BrushBits	db	BRUSHSIZE*8 dup (?) ;8 rows,8 columns of 8 bit/pixel  ;*/ BYTE dp8BrushBits [BRUSHSIZE*8];/* 
DIB_Brush8	ends                                                          ;*/ } DIB_Brush8;                   /*  

DIB_Brush16	struc                                                         ;*/ typedef struct {                /*  
dp16BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp16BrushFlags;            /*
dp16BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp16BrushBpp;              /*
dp16BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp16BrushStyle;            /*
dp16FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp16FgColor;               /*
dp16Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp16Hatch;                 /*
dp16BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp16BgColor;               /*
dp16BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp16BrushMono [BRUSHSIZE*4];/*
dp16BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp16BrushMask [BRUSHSIZE*4];/*
dp16BrushBits	db	BRUSHSIZE*16 dup (?);8 rows,8 columns of 16 bit/pixel;*/ BYTE dp16BrushBits [BRUSHSIZE*16];/* 
DIB_Brush16	ends                                                          ;*/ } DIB_Brush16;                   /*  

DIB_Brush24	struc                                                         ;*/ typedef struct {                /*  
dp24BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp24BrushFlags;            /*
dp24BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp24BrushBpp;              /*
dp24BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp24BrushStyle;            /*
dp24FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp24FgColor;               /*
dp24Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp24Hatch;                 /*
dp24BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp24BgColor;               /*
dp24BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp24BrushMono [BRUSHSIZE*4];/*
dp24BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp24BrushMask [BRUSHSIZE*4];/*
dp24BrushBits	db	BRUSHSIZE*24 dup (?);8 rows,8 columns of 24 bit/pixel ;*/ BYTE dp24BrushBits [BRUSHSIZE*24];/* 
DIB_Brush24	ends                                                          ;*/ } DIB_Brush24;                   /*  

DIB_Brush32	struc                                                         ;*/ typedef struct {                /*  
dp32BrushFlags   db	?		    ;Accelerator for solids           ;*/ BYTE  dp32BrushFlags;            /*
dp32BrushBpp     db	?		    ;Brush Bits per pixel format      ;*/ BYTE  dp32BrushBpp;              /*
dp32BrushStyle   dw	?		    ;Style of the brush               ;*/ WORD  dp32BrushStyle;            /*
dp32FgColor	dd	?		    ;Physical fg color                 ;*/ DWORD dp32FgColor;               /*
dp32Hatch	dw	?		    ;Hatching style                   ;*/ WORD  dp32Hatch;                 /*
dp32BgColor	dd	?		    ;Physical bg color                 ;*/ DWORD dp32BgColor;               /*
dp32BrushMono	db	BRUSHSIZE*4 dup (?) ;Mono portion                     ;*/ BYTE dp32BrushMono [BRUSHSIZE*4];/*
dp32BrushMask	db	BRUSHSIZE*4 dup (?) ;transparency mask (hatch pattern);*/ BYTE dp32BrushMask [BRUSHSIZE*4];/*
dp32BrushBits	db	BRUSHSIZE*32 dup (?);8 rows,8 columns of 32 bit/pixel ;*/ BYTE dp32BrushBits [BRUSHSIZE*32];/* 
DIB_Brush32	ends                                                          ;*/ } DIB_Brush32;                   /*  

;----------------------------------------------------------------------------
; Definitions for DIB_Brushxx.dpxxBrushFlags
;----------------------------------------------------------------------------                                      
COLORSOLID     equ      00000001b ;Color part is solid.                        
MONOSOLID      equ      00000010b ;Mono part is solid.                         
PATTERNMONO    equ      00000100b ;Pattern brush came from a mono bitmap.      
MONOVALID      equ      00001000b ;Mono part is valid.                         
MASKVALID      equ      00010000b ;Transparency Mask part is valid.
PRIVATEDATA    equ      00100000b ;Vendor specific bit for Pens, Brushes
comment ~
*/
#define  COLORSOLID     0x01         
#define  MONOSOLID      0x02         
#define  PATTERNMONO    0x04         
#define  MONOVALID      0x08         
#define  MASKVALID      0x10
#define  PRIVATEDATA    0x20
/*
end comment ~
;----------------------------------------------------------------------------
; ColorToMono
; Entry: red, green, blue
; Exit:  blue = intensity.
;----------------------------------------------------------------------------
ColorToMono	macro	red, green, blue
	add	blue,red		;R+B
        rcr     blue,1                  ;(R+B)/2
	add	blue,green		;pitch in Green
        rcr     blue,1                  ;G/2 + (R+B)/4
endm	ColorToMono

;----------------------------------------------------------------------------
; ColorToMonoBit
; Entry: red, green, blue
; Exit:  blue = 0 if color maps to black
;        blue = 1 if color maps to white
;----------------------------------------------------------------------------
ColorToMonoBit	macro	red, green, blue
	ColorToMono red,green,blue    ; Call ColorToMono to derive intensity.
	cmp	blue,127
	setnc	blue
endm ColorToMonoBit

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\dciman.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1995  Microsoft Corporation.	All Rights Reserved.
 * 
 **************************************************************************/
/****************************************************************************

 DCIMAN.H

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"         // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

DECLARE_HANDLE(HWINWATCH);  // context handle for WinWatch instance

/****************************************************************************
 ***************************************************************************/

extern HDC WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, DWORD dwCompression, DWORD dwRedMask,
    DWORD dwGreenMask, DWORD dwBlueMask, DWORD dwWidth, DWORD dwHeight, 
    DWORD dwDCICaps, DWORD dwBitCount, LPDCIOFFSCREEN FAR *lplpSurface);
extern int WINAPI DCICreateOverlay(HDC hdc, LPVOID lpOffscreenSurf, 
    LPDCIOVERLAY FAR *lplpSurface);
extern int WINAPI DCIEnum(HDC hdc, LPRECT lprDst, LPRECT lprSrc, LPVOID lpFnCallback,
    LPVOID lpContext);
extern DCIRVAL WINAPI DCISetSrcDestClip(LPDCIOFFSCREEN pdci, LPRECT srcrc,
			LPRECT destrc, LPRGNDATA prd );

extern HWINWATCH WINAPI WinWatchOpen(HWND hwnd);
extern void      WINAPI WinWatchClose(HWINWATCH hWW);

// API changed to copy region data instead of return pointer to it
extern UINT	 WINAPI WinWatchGetClipList(HWINWATCH hWW, LPRECT prc,
				UINT size,  LPRGNDATA prd);
extern BOOL      WINAPI WinWatchDidStatusChange(HWINWATCH hWW);

extern DWORD     WINAPI GetWindowRegionData(HWND hwnd, DWORD size, LPRGNDATA prd);
extern DWORD     WINAPI GetDCRegionData(HDC hdc, DWORD size, LPRGNDATA prd);


#define WINWATCHNOTIFY_START        0
#define WINWATCHNOTIFY_STOP         1
#define WINWATCHNOTIFY_DESTROY      2
#define WINWATCHNOTIFY_CHANGING     3
#define WINWATCHNOTIFY_CHANGED      4
typedef void (CALLBACK *WINWATCHNOTIFYPROC)(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam);

extern BOOL WINAPI WinWatchNotify(HWINWATCH hWW, WINWATCHNOTIFYPROC NotifyCallback,
						LPARAM NotifyParam );

/****************************************************************************
 ***************************************************************************/

extern void    WINAPI DCIEndAccess(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
extern void    WINAPI DCIDestroy(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIDraw(LPDCIOFFSCREEN pdci);
extern DCIRVAL WINAPI DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd);
extern DCIRVAL WINAPI DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src);
extern int     WINAPI DCISendCommand(HDC hdc, VOID FAR *pcmd, int nSize, VOID FAR * FAR * lplpOut);

extern int     WINAPI DCICreatePrimary32(HDC hdc, LPDCISURFACEINFO pdci);

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\makefile.inc ===
$(O)\ntverp.h: $(O)\ntverp.sed
	sed -f $(O)\ntverp.sed $(BASEDIR)\public\sdk\inc\ntverp.h > $@
	attrib -r $(BASEDIR)\public\sdk\inc\ntverp.h
	copy $@ $(BASEDIR)\public\sdk\inc\ntverp.h
	attrib +r $(BASEDIR)\public\sdk\inc\ntverp.h

$(O)\ntverp.sed: verinfo.h
	type <<$@
/^#define VER_PRODUCTBUILD_QFE.*/c\
<<keep
	type <<$(O)\verinfo.sed
/#define BUILD_NUMBER /!d
s/BUILD_NUMBER/VER_PRODUCTBUILD_QFE/
<<keep
	sed -f $(O)\verinfo.sed verinfo.h >> $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\thktypes.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       thktypes.h
 *  Content:	base types used by thunk compiler
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   26-feb-95	craige	split out of ddraw\types.h
 *   22-jun-95	craige	added RECT
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
typedef unsigned short USHORT;
typedef          short  SHORT;
typedef unsigned long  ULONG;
typedef          long   LONG;
typedef unsigned int   UINT;
typedef          int    INT;
typedef unsigned char  UCHAR;
typedef hinstance HINSTANCE;
typedef		int	BOOL;

typedef void    VOID;
typedef void   *PVOID;
typedef void   *LPVOID;
typedef UCHAR   BYTE;
typedef USHORT  WORD;
typedef ULONG   DWORD;
typedef UINT    HANDLE;
typedef char   *LPSTR;
typedef BYTE   *PBYTE;
typedef BYTE   *LPBYTE;
typedef USHORT  SEL;
typedef INT    *LPINT;
typedef UINT   *LPUINT;
typedef DWORD  *LPDWORD;
typedef LONG   *LPLONG;
typedef WORD   *LPWORD;

typedef HANDLE  HWND;
typedef HANDLE  HDC;
typedef HANDLE  HBRUSH;
typedef HANDLE  HBITMAP;
typedef HANDLE  HRGN;
typedef HANDLE  HFONT;
typedef HANDLE  HCURSOR;
typedef HANDLE  HMENU;
typedef HANDLE  HPEN;
typedef HANDLE  HICON;
typedef HANDLE  HUSER;      /* vanilla user handle */
typedef HANDLE  HPALETTE;
typedef HANDLE  HMF;
typedef HANDLE  HEMF;
typedef HANDLE	HCOLORSPACE;
typedef HANDLE  HMEM;
typedef HANDLE  HGDI;       /* vanilla gdi handle */
typedef HANDLE  HGLOBAL;
typedef HANDLE  HRSRC;
typedef HANDLE  HACCEL;

typedef WORD    ATOM;

typedef struct tagRECTL {
    LONG         left;
    LONG         top;
    LONG         right;
    LONG         bottom;
} RECTL;
typedef RECTL *LPRECTL;

typedef struct tagRECT {
    UINT         left;
    UINT         top;
    UINT         right;
    UINT         bottom;
} RECT;
typedef RECT *LPRECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*	Copyright (c) 1993-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
****/

#ifndef _EHINCLUDE_DEFINED
#define _EHINCLUDE_DEFINED

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


/* Define _CRTAPI2 (for compatibility with the NT SDK) */

#ifndef _CRTAPI2
#if	( (_MSC_VER >= 800) && (_M_IX86 >= 300) )
#define _CRTAPI2 __cdecl
#else
#define _CRTAPI2
#endif
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */

typedef void (_CRTAPI1 *terminate_function)();
typedef void (_CRTAPI1 *unexpected_function)();

struct _EXCEPTION_POINTERS;
typedef void (_CRTAPI1 *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

_CRTIMP void _CRTAPI1 terminate(void);
_CRTIMP void _CRTAPI1 unexpected(void);

_CRTIMP terminate_function _CRTAPI1 set_terminate(terminate_function);
_CRTIMP unexpected_function _CRTAPI1 set_unexpected(unexpected_function);
_CRTIMP _se_translator_function _CRTAPI1 _set_se_translator(_se_translator_function);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\minivdd.h ===
//*****************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title:      minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:    4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//           the general include area.  Added services are ONLY for the
//           use of the Mini-VDD and should therefore not be documented.
//
//-----------------------------------------------------------------------------
//=============================================================================

#ifndef _MINIVDD_H_
#define _MINIVDD_H_

#ifndef Not_VxD

/*XLATOFF*/
#define VDD_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

#ifdef MINIVDD
#ifdef NEC_98
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version            ) // Get version number and ID string ptr
VDD_Service(     VDD_PIF_State              ) // Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn            ) // Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor            ) // Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType             ) // Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime            ) // Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk            ) // Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn            ) // Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor           ) // Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor           ) // Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut            ) // Output a string
VDD_Service(     VDD_Msg_SetCursPos         ) // Set cursor position
VDD_Service(     VDD_Query_Access           ) // Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon      ) // User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table) // Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port  ) // Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info            ) // Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs     ) // returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port      ) // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO        ) // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO         ) // perform physical I/O for trapped port
VDD_Service(     VDD_Register_Mini_VDD   )
VDD_Service(    VDD_Install_IO_Handler   )
VDD_Service(    VDD_Install_Mult_IO_Handlers    )
VDD_Service(    VDD_Enable_Local_Trapping       )
VDD_Service(    VDD_Disable_Local_Trapping      )
VDD_Service(    VDD_Trap_Suspend        )
VDD_Service(    Test_Vid_VM_Handle      )
VDD_Service(    VDD_Set_Core_Graphics   )
VDD_Service(    VDD_Load_AccBIOS        )
VDD_Service(    VDD_Map_AccBIOS         )
VDD_Service(    VDD_Map_VRAM            )
VDD_Service(    VDD_EnableDevice        )
End_Service_Table(VDD)
/*ENDMACROS*/
#else  /*NEC_98*/
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version             )// Get version number and ID string ptr
VDD_Service(     VDD_PIF_State               )// Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn             )// Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor             )// Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType              )// Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime             )// Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk             )// Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn             )// Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor            )// Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor            )// Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut             )// Output a string
VDD_Service(     VDD_Msg_SetCursPos          )// Set cursor position
VDD_Service(     VDD_Query_Access            )// Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon       )// User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table )// Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port   )// Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info             )// Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs      )// returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port   )    // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO     )    // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO      )    // perform physical I/O for trapped port
VDD_Service(     VDD_Set_Sleep_Flag_Addr )    // when display driver can't be interrupted
VDD_Service(     VDD_EnableDevice        )
End_Service_Table(VDD)                   
/*ENDMACROS*/
#endif  /*NEC_98*/
#endif  /*MINIVDD*/

/*XLATOFF*/
#pragma warning (default:4003)              // turn off not enough params warning
/*XLATON*/

#define VDD_VerNum      0x0400  // version 4.00
#define VDD_MinVerNum   0x030A  // supports down to 3.10

//***************
// PIF_State service definitions
//
// These definitions cannot change without changing the PIF editor!!!
//
#ifdef NEC_98
#define bVidTextMd	 4	; Allocate text mode mem
#define fVidTextMd	 (1 << 4)
#define bVidNTModeFF	 0	; NoTrap: Mode F/F
#define fVidNTModeFF	 (1 << 0)
#define bVidNTModeFFC16	 1	; Default is 16 color mode
#define fVidNTModeFFC16	 (1 << 1)
#define bVidNTDispRW	 2	; NoTrap: Bank Register
#define fVidNTDispRW	 (1 << 2)
#define bVidNTPal	 3	; NoTrap: Palette
#define fVidNTPal	 (1 << 3)
#define bVidNTGDC	 5	; NoTrap: GDC
#define fVidNTGDC	 (1 << 5)
#define bVidNTGDCTON	 6	; Default Text on
#define fVidNTGDCTON	 (1 << 6)
#define bVidNTGDCGON	 7	; Default Grph on
#define fVidNTGDCGON	 (1 << 7)
#define bVidNTFont	 8	; NoTrap: KCG
#define fVidNTFont	 (1 << 8)
#define bVidCRTC	 9	; Use CRTC Tracer
#define fVidCRTC	 (1 << 9)
#define bVidDispDataXfer 10	; Transrate mode (0:Text, 1:Text/Grph)
#define fVidDispDataXfer (1 << 10)
#define bVidXFERPlane0	 11	; Transrate plane Blue
#define fVidXFERPlane0	 (1 << 11)
#define bVidXFERPlane1	 12	; 		  Red
#define fVidXFERPlane1	 (1 << 12)
#define bVidXFERPlane2	 13	; 		  Green
#define fVidXFERPlane2	 (1 << 13)
#define bVidXFERPlane3	 14	; 		  Intensity
#define fVidXFERPlane3	 (1 << 14)

#define mVidXFERPlane	(fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
#define mVidNTH98	(fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
#else //NEC_98
#define fVidTxtEmulate  0x0001  // Do INT 10h TTY and cursor emulation
#define fVidNoTrpTxt    0x0002  // Do not trap text mode apps
#define fVidNoTrpLRGrfx 0x0004  // Do not trap lo res graphics mode apps
#define fVidNoTrpHRGrfx 0x0008  // Do not trap hi res graphics mode apps
#define fVidTextMd      0x0010  // Allocate text mode mem
#define fVidLowRsGrfxMd 0x0020  // Allocate lo res graphics mode mem
#define fVidHghRsGrfxMd 0x0040  // Allocate hi res graphics mode mem
#define fVidRetainAllo  0x0080  // Never deallocate once allocated
#endif //NEC_98

//
// The following stuff was added for mini-VDD support:
//
// Functions that we can call in the hardware-dependent mini-VDD.  Note that
// these equates are used to create the dispatch table for calling functions
// in the mini-VDD:
//
#ifdef NEC_98
#define REGISTER_DISPLAY_DRIVER 	     0
#define PRE_HIRES_TO_VGA		     1
#define SAVE_REGISTERS			     2
#define RESTORE_REGISTERS		     3
#define ENABLE_TRAPS			     4
#define DISABLE_TRAPS			     5
#define DISPLAY_DRIVER_DISABLING	     6
#define ENABLE_ACCELERATER		     7
#define DISABLE_ACCELERATER		     8
#define CHECK_UPDATE			     9
#define CHECK_WINDOWED			     10
#define ACC_VBE_PM			     11
#define ACC_VBE_DDC			     12
#define ACC_INT_10			     13
#define ACC_GET_CAPABILITIES		     14
#define ACC_GET_EXT_MODE_INFO		     15
#define ACC_GET_FLAT_SELECTOR		     16
#define ACC_ENABLE_BIOS			     17
#define ACC_DISABLE_BIOS		     18
#define ACC_SET_PALETTE			     19
#define ACC_GET_PALETTE			     20
#define ACC_SET_CURSOR			     21
#define ACC_SHOW_CURSOR			     22
#define ACC_HIDE_CURSOR			     23
#define ACC_SET_CURSOR_POS		     24
#define ACC_GET_CURSOR_POS		     25
;
// 970204 //#define NBR_MINI_VDD_FUNCTIONS               26      //REMEMBER TO RESET THIS!!!!!!
#define NBR_MINI_VDD_FUNCTIONS_40	     26     //
#define GET_NUM_UNITS                        26		// 970220 rev.1
#define SET_ADAPTER_POWER_STATE              27     // SetAdapterPowerState(DEVNODE, DWORD)
#define GET_ADAPTER_POWER_STATE_CAPS         28     // GetAdapterPowerStateCap(DEVNODE)
#define SET_MONITOR_POWER_STATE              29     // SetMonitorPowerState(DEVNODE, DWORD)
#define GET_MONITOR_POWER_STATE_CAPS         30     // GetMonitorPowerStateCaps(DEVNODE)
#define GET_MONITOR_INFO                     31     // GetMonitorInfo(DEVNODE, UINT, EDID *)
#define I2C_OPEN                             32     // OpenI2CPort(PDO, BOOL, I2CControl *)
#define I2C_ACCESS                           33     // AccessI2CPort(PDO, I2CControl *);
#define GPIO_OPEN                            34     // OpenGPIOPort(PDO, BOOL, GPIOControl *)
#define GPIO_ACCESS                          35     // AccessGPIOPort(PDO, GPIOControl *)
#define COPYPROTECTION_ACCESS                36     // AccessCopyProtection(PDO,CPControl * )
#define NBR_MINI_VDD_FUNCTIONS_41	     37

#ifdef MAINVDD
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_41
#else
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_40
#endif

#else //NEC_98
#define REGISTER_DISPLAY_DRIVER              0
#define GET_VDD_BANK                         1
#define SET_VDD_BANK                         2
#define RESET_BANK                           3
#define PRE_HIRES_TO_VGA                     4
#define POST_HIRES_TO_VGA                    5
#define PRE_VGA_TO_HIRES                     6
#define POST_VGA_TO_HIRES                    7
#define SAVE_REGISTERS                       8
#define RESTORE_REGISTERS                    9
#define MODIFY_REGISTER_STATE                10
#define ACCESS_VGA_MEMORY_MODE               11
#define ACCESS_LINEAR_MEMORY_MODE            12
#define ENABLE_TRAPS                         13
#define DISABLE_TRAPS                        14
#define MAKE_HARDWARE_NOT_BUSY               15
#define VIRTUALIZE_CRTC_IN                   16
#define VIRTUALIZE_CRTC_OUT                  17
#define VIRTUALIZE_SEQUENCER_IN              18
#define VIRTUALIZE_SEQUENCER_OUT             19
#define VIRTUALIZE_GCR_IN                    20
#define VIRTUALIZE_GCR_OUT                   21
#define SET_LATCH_BANK                       22
#define RESET_LATCH_BANK                     23
#define SAVE_LATCHES                         24
#define RESTORE_LATCHES                      25
#define DISPLAY_DRIVER_DISABLING             26
#define SELECT_PLANE                         27
#define PRE_CRTC_MODE_CHANGE                 28
#define POST_CRTC_MODE_CHANGE                29
#define VIRTUALIZE_DAC_OUT                   30
#define VIRTUALIZE_DAC_IN                    31
#define GET_CURRENT_BANK_WRITE               32
#define GET_CURRENT_BANK_READ                33
#define SET_BANK                             34
#define CHECK_HIRES_MODE                     35
#define GET_TOTAL_VRAM_SIZE                  36
#define GET_BANK_SIZE                        37
#define SET_HIRES_MODE                       38
#define PRE_HIRES_SAVE_RESTORE               39
#define POST_HIRES_SAVE_RESTORE              40
#define VESA_SUPPORT                         41
#define GET_CHIP_ID                          42
#define CHECK_SCREEN_SWITCH_OK               43
#define VIRTUALIZE_BLTER_IO                  44
#define SAVE_MESSAGE_MODE_STATE              45
#define SAVE_FORCED_PLANAR_STATE             46
#define VESA_CALL_POST_PROCESSING            47
#define PRE_INT_10_MODE_SET                  48
#define NBR_MINI_VDD_FUNCTIONS_40            49      //REMEMBER TO RESET THIS!!!!!!

//
//  new miniVDD functions that a 4.1 miniVDD should implement
//
#define GET_NUM_UNITS                        49     // GetNumUnits(DEVNODE)
#define TURN_VGA_OFF                         50     // TurnOffVGA(DEVNODE)
#define TURN_VGA_ON                          51     // TurnOnVGA(DEVNODE)
#define SET_ADAPTER_POWER_STATE              52     // SetAdapterPowerState(DEVNODE, DWORD)
#define GET_ADAPTER_POWER_STATE_CAPS         53     // GetAdapterPowerStateCap(DEVNODE)
#define SET_MONITOR_POWER_STATE              54     // SetMonitorPowerState(DEVNODE, DWORD)
#define GET_MONITOR_POWER_STATE_CAPS         55     // GetMonitorPowerStateCaps(DEVNODE)
#define GET_MONITOR_INFO                     56     // GetMonitorInfo(DEVNODE, UINT, EDID *)
#define I2C_OPEN                             57     // OpenI2CPort(PDO, BOOL, I2CControl *)
#define I2C_ACCESS                           58     // AccessI2CPort(PDO, I2CControl *);
#define GPIO_OPEN                            59     // OpenGPIOPort(PDO, BOOL, GPIOControl *)
#define GPIO_ACCESS                          60     // AccessGPIOPort(PDO, GPIOControl *)
#define COPYPROTECTION_ACCESS                61     // AccessCopyProtection(PDO,CPControl * )

#define NBR_MINI_VDD_FUNCTIONS_41            62

#ifdef MAINVDD
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_41
#else
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_40
#endif

#endif //NEC_98

#endif /*NotVxD*/

//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
// all these entry points take as input:
//
// Entry:
//      Client_EAX  - function code.
//      Client_EBX  - device handle, or device id (1-N)
//
#define VDD_QUERY_VERSION                   0
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PC98_RESERVED                   (10 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_VBE_PM                          (10 + MINIVDD_SVC_BASE_OFFSET)

//
//   all functions >= VDD_ENABLE also take the following params:
//
//      Client_ES:DI    - buffer
//      Client_ECX      - buffer size
//      Client_EDX      - flags
//
// Exit:
//      Client_EAX  = function code  if the function is not supported.
//                  = 0              if the function succeded.
//                  = -1             if the function failed.
//
#define VDD_ENABLE                          (11 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GETMEMBASE                      (12 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN                            (13 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_CLOSE                           (14 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN_KEY                        (15 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_POWER_STATE                 (16 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_POWER_STATE_CAPS            (17 + MINIVDD_SVC_BASE_OFFSET)

//
// special verion of VDD_GET_DISPLAY_CONFIG that always get the
// monitor data, even if the user has disabled using a refresh rate.
//
#define VDD_GET_DISPLAY_CONFIG2             0x8085

//
//  VDD_DRIVER_REGISTER
//
//  The display driver sends us some information needed to handle various
//  context changes.
//
//  Entry:
//         Client_ES:DI Selector:Offset of callback routine used
//                      to reset to Windows HiRes mode upon return
//                      from a full screen DOS VM to the Windows VM.
//         Client_ES    Main code segment of display driver.
//         Client_ECX   contains the total nbr of bytes on-screen (excluding
//                      off-screen memory).
//         Client_EDX   contain 0 if we are to attempt to allow 4 plane VGA
//                      virtualization.
//         Client_EDX   contains -1 if we are to not allow 4 plane VGA
//                      virtualization.
//         Client_EBX   device handle, or device id (1-N)
//  Exit:
//         Client_EAX   contains total bytes of memory used by visible screen
//                      AND the VDD virtualization area (ie: the start of
//                      off-screen memory available for use by the display
//                      driver as "scratch" memory).
//

//
//  VDD_DRIVER_UNREGISTER
//
//  Entry:
//          Client_EBX   device handle, or device id (1-N)
//  Exit:
//

//
//  VDD_ENABLE
//
//  entry:
//      Client_EAX      - VDD_ENABLE (0x008B)
//      Client_EBX      - device handle
//      Client_EDX      - enable flags (see below)
//
//  exit:
//      Client_EAX      - previous enable state.
//
//  only one device at a time can have VGAMEM, VGAIO, or ROM access
//  at a time.
//
#define ENABLE_IO               0x00000001  // enable IO.
#define ENABLE_MEM              0x00000002  // enable memory.
#define ENABLE_VGA              0x00000030  // enable VGA
#define ENABLE_ROM              0x00000080  // enable ROM at C000.
#define ENABLE_ALL              0x000000FF  // enable all access to this device
#define ENABLE_NONE             0x00000000  // disable device.
#define ENABLE_VALID            0x000000FF  // valid flags.
#define ENABLE_ERROR            0xFFFFFFFF  // enable fail code

//
//  VDD_OPEN
//
//      open a device given a name
//
//  Entry:
//          Client_ES:EDI   - device name
//          Client_EDX      - flags
//          Client_EBX      - device id (only for VDD_OPEN_ENUM)
//  Exit:
//          Client_EAX      - device handle
//
#define VDD_OPEN_EXIST      0x00000001      // check if the device name is valid
#define VDD_OPEN_ENUM       0x00000002      // return the Nth device
#define VDD_OPEN_LOCK       0x00000000      // lock the device (default)
#define VDD_OPEN_TEST       VDD_OPEN_EXIST

//
//  VDD_OPEN_KEY
//
//      opens the setting key in the registry for the given device
//      the caller must close the key when done.
//
//  Entry:
//          Client_ES:EDI   - points to place to store the opened registry key
//          Client_ECX      - must be 4, ie sizeof(HKEY)
//          Client_EDX      - flags
//          Client_EBX      - device handle
//  Exit:
//          Client_EAX      - 0 for success, or Win32 error code
//
#define VDD_OPEN_KEY_WRITE  0x00000001      // will be writing settings
#define VDD_OPEN_KEY_READ   0x00000002      // only gonig to read settings
#define VDD_OPEN_KEY_USER   0x00000010      // open the per user settings
#define VDD_OPEN_KEY_GLOBAL 0x00000020      // open the global (not per user) settings

//
//  WIN32 IOCTLS
//
//  The following defines are used with the Win32 function DeviceIOControl
//
#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD
#define VDD_IOCTL_COPY_PROTECTION 0x10000003  // copy protection enable/disable
#define VDD_IOCTL_I2C_OPEN      0x10000004  // open i2c port for access
#define VDD_IOCTL_I2C_ACCESS    0x10000005  // read/write interface

//
//  VDD_IOCTL_SET_NOTIFY
//
//  sets a notification function that will be called when events
//  happen on the device.
//
//  input:
//      NotifyMask      - bitfield of events
//
//          VDD_NOTIFY_START_MODE_CHANGE    - start of mode change in sysVM
//          VDD_NOTIFY_END_MODE_CHANGE      - end of mode change in sysVM
//          VDD_NOTIFY_ENABLE               - sysVM is gaining display focus
//          VDD_NOTIFY_DISABLE              - sysVM is losing display focus
//
//      NotifyType      - type of notify
//
//          VDD_NOTIFY_TYPE_CALLBACK        - NotifyProc is a Ring0 callback
//
//      NotifyProc      - notify procedure
//      NotifyData      - client data
//
//  output:
//      none
//
//  return:
//      ERROR_SUCCES if callback is set successfuly
//
//  notes:
//      currenly only one callback, per device can be active.
//
//      to unregister a callback do a SET_NOTIFY with a NotifyMask == 0
//
//      your callback better be in pagelocked code.
//
//  NotifyProc has the following form:
//
//      void __cdecl NotifyProc(DWORD NotifyDevice, DWORD NotifyEvent, DWORD NotifyData)
//
//          NotifyDevice    internal VDD device handle
//          NotifyEvent     event code (VDD_NOTIFY_*)
//          NotifyData      your client data
//

//
// VDD_IOCTL_SET_NOTIFY_INPUT
//
typedef struct tagVDD_IOCTL_SET_NOTIFY_INPUT {
    DWORD   NotifyMask;
    DWORD   NotifyType;
    DWORD   NotifyProc;
    DWORD   NotifyData;
}   VDD_IOCTL_SET_NOTIFY_INPUT;

//
// VDD_IOCTL_SET_NOTIFY_INPUT.NotifyMask
//
#define VDD_NOTIFY_START_MODE_CHANGE    0x00000001
#define VDD_NOTIFY_END_MODE_CHANGE      0x00000002
#define VDD_NOTIFY_ENABLE               0x00000004
#define VDD_NOTIFY_DISABLE              0x00000008

//
//  VDD_IOCTL_SET_NOTIFY_INPUT.NotifyType
//
#define VDD_NOTIFY_TYPE_CALLBACK        1

//
// Port size equates:
//
#define BYTE_LENGTHED                       1
#define WORD_LENGTHED                       2

//
// Flag equates:
//
#define GOING_TO_WINDOWS_MODE               1
#define GOING_TO_VGA_MODE                   2
#define DISPLAY_DRIVER_DISABLED             4
#define IN_WINDOWS_HIRES_MODE               8

//
//  DISPLAYINFO structure
//
typedef struct DISPLAYINFO {
        WORD  diHdrSize;
        WORD  diInfoFlags;
        //
        //  display mode specific data
        //
        DWORD diDevNodeHandle;
        char  diDriverName[16];
        WORD  diXRes;
        WORD  diYRes;
        WORD  diDPI;
        BYTE  diPlanes;
        BYTE  diBpp;
        //
        //  monitor specific data
        //
        WORD  diRefreshRateMax;
        WORD  diRefreshRateMin;
        WORD  diLowHorz;
        WORD  diHighHorz;
        WORD  diLowVert;
        WORD  diHighVert;
        DWORD diMonitorDevNodeHandle;
        BYTE  diHorzSyncPolarity;
        BYTE  diVertSyncPolarity;
        //
        // new 4.1 stuff
        //
        DWORD diUnitNumber;             // device unit number
        DWORD diDisplayFlags;           // mode specific flags
        DWORD diXDesktopPos;            // position of desktop
        DWORD diYDesktopPos;            // ...
        DWORD diXDesktopSize;           // size of desktop (for panning)
        DWORD diYDesktopSize;           // ...

} DISPLAYINFO;

/*ASM
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize
*/

//
// Following are values for the diInfoFlags word in DISPLAYINFO:
//
#define RETURNED_DATA_IS_STALE           0x0001
#define MINIVDD_FAILED_TO_LOAD           0x0002
#define MINIVDD_CHIP_ID_DIDNT_MATCH      0x0004
#define REGISTRY_BPP_NOT_VALID           0x0008
#define REGISTRY_RESOLUTION_NOT_VALID    0x0010
#define REGISTRY_DPI_NOT_VALID           0x0020
#define MONITOR_DEVNODE_NOT_ACTIVE       0x0040
#define MONITOR_INFO_NOT_VALID           0x0080
#define MONITOR_INFO_DISABLED_BY_USER    0x0100
#define REFRESH_RATE_MAX_ONLY            0x0200
#define CARD_VDD_LOADED_OK               0x0400
#define DEVICE_IS_NOT_VGA                0x0800

//
//  Following are explanations for the diInfoFlags word in DISPLAYINFO:
//
//  RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
//  or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
//  program would get the DISPLAYINFO structure returned to him) caused the VDD
//  to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
//  insted of actually going out and reading "fresh" data from the Registry.
//
//  This flag brings to light the fact that there are some circumstances when the
//  VDD cannot go out and read the registry in response to the call to
//  VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
//  considerations).  In this case, this flag will be set to a 1 to indicate that
//  the information being returned isn't "fresh" -- that is -- it may be
//  incorrect and obsolete.  The caller should respond accordingly if this flag
//  is set.
//
//
//  MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
//  that the MiniVDD didn't match the chipset installed in the machine), the
//  MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
//
//  MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
//  successfully, when the ChipID that the MiniVDD calculated was compared
//  against the value saved in the registry, they didn't match.  An example of
//  when this would happen is when the user is happily using an S3-911 card
//  and then decides to upgrade his display card to an S3-864.  Since both
//  cards use S3.VXD, the MiniVDD will load, however, since the card model
//  is different, the VDD will return a defect to configuration manager and
//  set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
//  flag to take appropriate actions to make sure that the user gets his
//  configuration correct.
//
//
//  REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
//  from the registry when the VDD tried to read it.
//
//
//  REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
//  resolution value from the registry when the VDD tried to read it.
//
//
//  REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
//  DPI value from the registry when the VDD tried to read it.
//
//
//  MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
//  GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
//  This is certainly not fatal by any means.  It simply means that the
//  monitor refresh rate info in the DISPLAYINFO data structure is totally
//  invalid!
//
//
//  MONITOR_INFO_NOT_VALID indicates that something within the code which
//  retrieves and calculates the refresh rate data has failed.  This indicates
//  that the values in diRefreshRateMax through diVertSyncPolarity are not
//  valid and could contain random data.
//
//
//  MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
//  string in SYSTEM.INI had a negative number in it or that the string in
//  the display's software key RefreshRate = string was 0 or a negative number.
//
//
//  REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
//  diLowVert, diHighVert, or sync polarity data in the registry.  The
//  value returned in diRefreshRateMax is the only refresh rate data that
//  we have available.  This was derived either from RefreshRate= in SYSTEM.INI
//  or the display software key RefreshRate = string in the registry.
//
//
//  CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
//  display card manufacturers wishing to extend the capabilities of the chip level
//  MiniVDD's ) has successfully been loaded and initialized.
//
//  DEVICE_IS_NOT_VGA indicates that this device is not the primary vga
//

#define NoTrace_VIRTUALIZE_CRTC_IN
#define NoTrace_VIRTUALIZE_CRTC_OUT
#define NoTrace_VIRTUALIZE_SEQUENCER_IN
#define NoTrace_VIRTUALIZE_SEQUENCER_OUT
#define NoTrace_VIRTUALIZE_GCR_IN
#define NoTrace_VIRTUALIZE_GCR_OUT
#define NoTrace_VIRTUALIZE_DAC_OUT
#define NoTrace_VIRTUALIZE_DAC_IN
#define NoTrace_CHECK_HIRES_MODE
/*ASM

ifdef NEC_98
;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

    ;
    ;	Mini-VDD Static Flags
    ;
vFlg_Machine_Std	equ			00000001b
vFlg_Machine_Multi	equ			00000010b
vFlg_Machine_Mate	equ			00000100b
vFlg_Machine_H98	equ			00001000b
vFlg_CRT_New		equ			00010000b
vFlg_CRT_NonInter	equ			00100000b
vFlg_GDC_5MHz		equ			01000000b
vFlg_GDC_Emulate	equ			10000000b
vFlg_Acc_Internal	equ		0000000100000000b
vFlg_Acc_External	equ		0000001000000000b
vFlg_Acc_PCI		equ		0000010000000000b
vFlg_Acc_ML		equ		0000100000000000b
vFlg_Acc_PVD		equ		0001000000000000b
vFlg_Mode_NH		equ		0010000000000000b
vFlg_Mode_H		equ		0100000000000000b
vFlg_Initialized	equ		1000000000000000b
vFlg_Opt_MFR		equ	000000010000000000000000b
vFlg_Opt_NewMFR		equ	000000100000000000000000b
vFlg_Opt_VDP		equ	000001000000000000000000b
vFlg_Opt_NewVDP		equ	000010000000000000000000b

vFlg_Local		equ	000000000100000010000000b

    ;
    ;	Mini-VDD Support Max
    ;
MaxMiniVDD	equ	16
MaxMiniTrap	equ	32
MaxMultiTrap	equ	3
MaxMultiFunc	equ	MaxMiniVDD

    ;
    ;	MiniVDD_LTrap_Struct.LTrap_Status
    ;	MiniVDD_LTrap_Struct.LTrap_Flags.xxxx
    ;
LT_Enable	equ	00000001b
LT_Enable_bit	equ	0
LT_Initialized	equ	10000000b
LT_Initialized_bit equ	7


;******************************************************************************
;			D A T A   S T R U C T U R E S
;******************************************************************************

    ;
    ;	Vids_struct
    ;

Vids_struct struc
   ;
   ;	Common Data supplied by Base-VDD. Some data(bits) set by Mini-VDD.
   ;
	Vids_SFlags		dd	?	; Static flags
	Vids_CB_Offset		dd	?	; 
	Vids_Msg_Pseudo_VM	dd	?	; 

   ;
   ;	Common Procedure supplied by Base-VDD
   ;
	VDD_TGDC_Draw_Off	dd	?	; 
	VDD_TGDC_Sync_Off	dd	?	; 
	VDD_TGDC_Sync_On	dd	?	; 
	VDD_TGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_Draw_Off	dd	?	; 
	VDD_GGDC_Sync_Off	dd	?	; 
	VDD_GGDC_Sync_On	dd	?	; 
	VDD_GGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_MOD_Emulate	dd	?	; 

   ;
   ;	Common Procedure supplied by Mini-VDD
   ;
	H98_FLORA_Change	dd	?	; H98 - NH mode
	H98_Clear_Text		dd	?	; H98 - NH mode
	H98_Rest_GCs		dd	?	; H98
	H98_Rest_etc		dd	?	; H98
	H98_Save_ModeFF		dd	?	; H98

Vids_struct ends


Vid_SFlags		equ	<Vids.Vids_SFlags>
VDD_CB_Offset		equ	<Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM	equ	<Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off		equ	<Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off		equ	<Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On		equ	<Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off		equ	<Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty		equ	<Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty		equ	<Vids.VDD_GGDC_FIFO_Empty>


    ;
    ;	RegTrapStruct
    ;
MiniFuncStruct	STRUC
MF_ProcAddr	dd	?
;;MF_Order	dw	?
;;MF_MiniID	db	?
;;MF_Flags	db	?
MiniFuncStruct	ENDS

    ;
    ;	MiniProcStruct
    ;
MiniVDD_Proc_Struct	STRUC
Proc_Address	dd	?
Proc_Order	dw	?
Proc_MiniID	db	?
Proc_Flags	db	?
MiniVDD_Proc_Struct	ENDS
.errnz	(size MiniVDD_Proc_Struct) mod 4

    ;
    ;	MiniTrapTable	- Global Info
    ;	LocalTrapTable	- Local Status
    ;
MiniVDD_GTrap_Struct	STRUC
GTrap_ProcAddr	dd	?
GTrap_PortAddr	dw	?
GTrap_NumMini	dw	?
GTrap_ProcTable	db	((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct	ENDS

MiniVDD_LTrap_Struct	STRUC
LTrap_ProcAddr	dd	?
LTrap_Status	db	?
LTrap_Flags	db	MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct	ENDS


;******************************************************************************
;				M A C R O S
;******************************************************************************

    ;
    ;	BeginMiniFunc	TableName
    ;	    MiniFunc	Function-ID, ProcedureName
    ;		|	
    ;	EndMiniFunc	TableName
    ;
EndMiniFunc_	MACRO	n
ifdef	MiniFunc&n
	dd	OFFSET32 MiniFunc&n		; MiniFuncStruct
else
	dd	0
endif
		ENDM

MiniFunc_	MACRO	FuncID, FuncName
		MiniFunc&FuncID equ <FuncName>
		ENDM

BeginMiniFunc	MACRO	TableName
public	TableName
TableName	label	near
		ENDM

if 1
EndMiniFunc	MACRO	TableName
		x = 0
		REPT	NBR_MINI_VDD_FUNCTIONS_41
		EndMiniFunc_	%x
		x = x + 1
		ENDM
		ENDM
else
EndMiniFunc	MACRO	TableName
		x = 0
		REPT	NBR_MINI_VDD_FUNCTIONS
		EndMiniFunc_	%x
		x = x + 1
		ENDM
		ENDM
endif

MiniFunc	MACRO	FuncID, FuncName
		MiniFunc_ %(FuncID), <FuncName>
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDCall	MACRO	FuncID, SetCarry
		local	MiniCall_Loop
		local	MiniCall_Exit

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		mov	ecx, [MiniVDD_NumMini]
MiniCall_Loop:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
		jc	MiniCall_Exit
		add	esi, size MiniVDD_Proc_Struct
		loop	MiniCall_Loop
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM
    ;
    ;	MiniVDDCall2	Function-ID
    ;
MiniVDDCall2	MACRO	FuncID, SetCarry
		local	MiniCall_Exit
		local	MiniCall_Proc

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
MiniCall_Proc:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM
    ;
    ;	MiniVDDCall3	Function-ID
    ;
MiniVDDCall3	MACRO	FuncID, MiniID, SetCarry
		local	MiniCall_Exit
		local	MiniCall_Loop
		local	MiniCall_Proc

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		movzx	ecx, MiniID
MiniCall_Loop:
		cmp	ecx, 0
		jz	MiniCall_Proc
		add	esi, size MiniVDD_Proc_Struct
		dec	ecx
		jmp	MiniCall_Loop
MiniCall_Proc:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDFunc	MACRO	TmpReg, FuncID
		mov	TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		ENDM

    ;
    ;	ExecMode/ExecModeThru
    ;	ExecModeNot/ExecModeThruNot
    ;	ExecModeOnly
    ;	ExecModeOnlyNot
    ;	ExecModeElse
    ;	ExecModeElseNot
    ;	ExecModeEnd
    ;

ExecModeLL	macro	Num
ExecMode_L&Num:
		endm

ExecModeLE	macro	Num
ExecMode_E&Num:
		endm

ExecModeJE	macro	Num
	jmp	ExecMode_E&Num
		endm

ExecModeJZ	macro	Num
	jz	ExecMode_L&Num
		endm

ExecModeJNZ	macro	Num
	jnz	ExecMode_L&Num
		endm

ExecModeJEZ	macro	Num
	jz	ExecMode_E&Num
		endm

ExecModeJENZ	macro	Num
	jnz	ExecMode_E&Num
		endm


ExecModeTest	macro	ModeFlag, CB_Reg
if	ModeFlag and vFlg_Local
ifidni	<CB_Reg>, <Vid>
	push	ebx
	mov	ebx, [Vid_VM_Handle]
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifidni	<CB_Reg>, <Cur>
	push	ebx
	VMMCall	Get_Cur_VM_Handle
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifb	<CB_Reg>
	push	ebx
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
	test	[CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
	test	[Vid_SFlags], ModeFlag
endif
	endm


ExecModeChk	macro	HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni	<HdrFlag>, <Jmp>
.erre	FlgExecMode
	ExecModeJE	%EndExecMode
endif
ExecModeLL	%NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb	<ModeFlag>
	ExecModeTest	<ModeFlag>, <CB_Reg>
ifidni	<JmpLabel>, <End>
ifidni	<JmpFlag>, <Not>
	ExecModeJENZ	%EndExecMode
else
	ExecModeJEZ	%EndExecMode
endif
else
ifidni	<JmpFlag>, <Not>
	ExecModeJNZ	%NumExecMode
else
	ExecModeJZ	%NumExecMode
endif
endif
endif
		endm

ExecModeEnd	macro
ExecModeLL	%NumExecMode
ExecModeLE	%EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
		endm

   ;
   ;	CB_Reg   = Regs/Vid/Cur
   ;	ModeFlag = vFlg_xxxx
   ;
ExecModeJmp	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jnz	JmpLabel
		endm

ExecModeJmpNot	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jz	JmpLabel
		endm

ExecMode	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeOnly	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
		endm

ExecModeOnlyNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
		endm

ExecModeElse	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeElseNot	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeThru	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeThruNot	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
		endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else ;NEC_98
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
CardVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi                     ;;save this register for now
ifnb    <SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm
endif ;NEC_98
*/

#endif  // _MINIVDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\poppack.h ===
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\mmdevldr.h ===
/*
 *  MMDEVLDR.H - The main include file for the DevLoader
 *
 *  Version 4.00
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 */

#ifdef _WIN32								/* ;BeginInternal */
#define MMDEVLDR_IOCTL_GETVERSION           0
#define MMDEVLDR_IOCTL_LINPAGELOCK          1
#define MMDEVLDR_IOCTL_LINPAGEUNLOCK        2
#define MMDEVLDR_IOCTL_RING0THREADHANDLE    3
#define MMDEVLDR_IOCTL_QUEUEAPC             4
#define MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR   5
#define MMDEVLDR_IOCTL_CLOSEVXDHANDLE       6
#define MMDEVLDR_IOCTL_PAGEALLOCATE         7
#define MMDEVLDR_IOCTL_PAGEFREE             8
#define MMDEVLDR_IOCTL_GETDEVICESTATUS      9

#define MM_DEVSTATUS_ERROR          0
#define MM_DEVSTATUS_STARTED        1
#define MM_DEVSTATUS_UNKNOWNPROB    2
#define MM_DEVSTATUS_DISABLED       3


typedef struct tagLOCKUNLOCKPARMS               
{                                               
    DWORD           dwStartPage;                
    DWORD           dwPageCount;                
    DWORD           fdwOperation;               
}   LOCKUNLOCKPARMS;

typedef struct tagQUEUEAPCPARMS
{                                               
    DWORD           fnCallback;
    DWORD           dwUser;
    DWORD           hRing0Thd;
}   QUEUEAPCPARMS;

typedef struct tagPAGEALLOCATEPARMS
{
    DWORD           dwFlags;
    DWORD           dwPageCount;
} PAGEALLOCATEPARMS;

typedef struct tagPAGEALLOCATERETURN
{
    VOID *          lpvBase;
    DWORD           hMem;
    DWORD           dwPageCount;
    DWORD           dwPhysBase;
} PAGEALLOCATERETURN;

#endif

#ifdef MMDEVLDR_VXD					
#define MM_STOP 	0					
#define MM_START 	1					
#define MM_MMDEVLDR_UP  3			

                        
#define CONFIG_QUERYSTART	0x01000

#define MAXLEN	256 					 

typedef struct tagMMDEVNODE            
{                                      
   DEVNODE      dn ;                   
   DWORD        dwDevStatus ;          
   VMMLIST      hlDrivers ;            
                                       
} MMDEVNODE, *PMMDEVNODE ;             


typedef struct tagMMDRVNODE            
{                                      
   CMCONFIGHANDLER  pConfigHandler ;   
   DWORD            dwRefData ;        
                                                             
} MMDRVNODE, *PMMDRVNODE ;

//
// macros
//

#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

#if defined(DEBUG_RETAIL) || defined(DEBUG)
#define	DBG_TRACE(strings) {\
	_Debug_Printf_Service( "MMDEVLDR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#ifdef DEBUG
#define	DBG_ERROR(strings) {\
	_Debug_Printf_Service( "MMDEVLDR ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");\
	{_asm	int	3}}
#else
#define	DBG_ERROR(strings) {\
	_Debug_Printf_Service( "MMDEVLDR ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}
#endif
#else
   #define DBG_TRACE(strings)
   #define DBG_ERROR(strings)
#endif

#ifdef DEBUG
#define DPF( strings ) _Debug_Printf_Service##strings;
#else
#define DPF( strings )
#endif

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

//
// internal function prototypes
//   
     
void MMDEVLDR_Call_MMSystem(DEVNODE dnDevNode, DWORD fLoad);
void MMDEVLDR_CheckForMMSystem(void);
DWORD StringLen(PCHAR psz);
PCHAR StringCopy(PCHAR pszDst, PCHAR pszSrc);
PCHAR StringCat(PCHAR pszDst, PCHAR pszSrc);

#pragma warning (disable:4035)		// turn off no return code warning
PSTR VXDINLINE Get_Environment_String
(
    PSTR            pszName
)
{
    _asm push esi
    _asm mov esi, pszName
    VMMCall( Get_Environment_String ) ;
    _asm mov   eax, edx
    _asm pop   esi
}
#pragma warning (default:4035)     // turn on no return code warning

BOOL _InitGlobalEnvironment() ;

VOID MMDEVLDR_SetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

BOOL MMDEVLDR_GetEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue,
    UINT            uBufSize
) ;

VOID MMDEVLDR_RemoveEnvironmentString
(
    PSTR            pszName
) ;

VOID	MMDEVLDR_AddEnvironmentString
(
    PSTR            pszName,
    PSTR            pszValue
) ;

#else								/* ;EndInternal */


#define Multimedia_OEM_ID   0x0440	//            ; MS Reserved OEM # 34
#define MMDEVLDR_DEVICE_ID  Multimedia_OEM_ID + 10 	//;MMDEVLDR's device ID

#ifdef Begin_Service_Table		// define only if vmm.h is included

#define	MMDEVLDR_Service	Declare_Service
#pragma warning (disable:4003)		// turn off not enough params warning

//MACROS
Begin_Service_Table(MMDEVLDR)

MMDEVLDR_Service	(MMDEVLDR_Register_Device_Driver, LOCAL)
MMDEVLDR_Service	(MMDEVLDR_SetDevicePresence)
MMDEVLDR_Service  (MMDEVLDR_SetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_GetEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_RemoveEnvironmentString)
MMDEVLDR_Service  (MMDEVLDR_AddEnvironmentString)

End_Service_Table(MMDEVLDR)
//ENDMACROS       

#pragma warning (default:4003)		// turn on not enough params warning

#pragma warning (disable:4035)		// turn off no return code warning

VOID VXDINLINE MMDEVLDR_Register_Device_Driver
(
    DEVNODE         dnDevNode,
    DWORD           fnConfigHandler,
    DWORD           dwUserData
)
{
    _asm push ebx
    _asm mov eax,dnDevNode
    _asm mov ebx,fnConfigHandler
    _asm mov ecx,dwUserData
    VxDCall(MMDEVLDR_Register_Device_Driver);
    _asm pop ebx
}

VOID VXDINLINE MMDEVLDR_SetDevicePresence
(
    DEVNODE         dn,
    PCHAR           pszReg,
    BOOL            fPresent
)
{
    _asm push fPresent
    _asm push pszReg
    _asm push dn
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetDevicePresence);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_SetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_SetEnvironmentString);
    _asm add  esp, 2*4
} ;

BOOL VXDINLINE MMDEVLDR_GetEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue,
    UINT            uBufSize
)
{
    _asm push uBufSize
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_GetEnvironmentString);
    _asm add  esp, 3*4
} ;

VOID VXDINLINE MMDEVLDR_RemoveEnvironmentString
(
    PCHAR           pszName
)
{
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_RemoveEnvironmentString);
    _asm add  esp, 4
} ;

VOID VXDINLINE MMDEVLDR_AddEnvironmentString
(
    PCHAR           pszName,
    PCHAR           pszValue
)
{
    _asm push pszValue
    _asm push pszName
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VxDCall(MMDEVLDR_AddEnvironmentString);
    _asm add  esp, 2*4
} ;

#pragma warning (disable:4035)		// turn on no return code warning

#endif // Begin_Service_Table

#endif 			/* ;Internal */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\mmdevldr.inc ===
;******************************************************************************
TITLE mmdevldr.inc - Windows/386 MMSYSTEM Device loader DLVxD include file
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1993 - 1995
;
;   Title:  mmdevldr.INC - Windows/386 Config Manager DLVxD DEVLOADER for MMSYSTEM
;
;   Version:    1.00
;
;
;==============================================================================
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID           equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_Ver_Major           equ 1                ; version 1.0 of this VxD
MMDEVLDR_Ver_Minor           equ 0

MMDEVLDR_API_MMSystem_Up        equ 0			;Internal
MMDEVLDR_API_Continue		equ 1			;Internal
MMDEVLDR_API_QueryVxD           equ 2                   ;Internal
MMDEVLDR_API_QueueCallback32    equ 3                   ;Internal
MMDEVLDR_API_SetEvent           equ 4                   ;Internal
MMDEVLDR_API_PageAllocate       equ 5                   ;Internal
MMDEVLDR_API_PageFree           equ 6                   ;Internal
MMDEVLDR_APIS                   equ 7                   ;Internal

ifdef DDB_Sys_Crit_Init_Done
 
Begin_Service_Table	MMDEVLDR
	MMDEVLDR_Service	MMDEVLDR_Register_Device_Driver, LOCAL
	MMDEVLDR_Service	_MMDEVLDR_SetDevicePresence
        MMDEVLDR_Service        _MMDEVLDR_SetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_GetEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_RemoveEnvironmentString
        MMDEVLDR_Service        _MMDEVLDR_AddEnvironmentString
End_Service_Table MMDEVLDR	

MMDEVLDR_IOCTL_GETVERSION       equ     0		;Internal
MMDEVLDR_IOCTL_LINPAGELOCK      equ     1		;Internal
MMDEVLDR_IOCTL_LINPAGEUNLOCK    equ     2		;Internal
MMDEVLDR_IOCTL_RING0THREADHANDLE equ    3		;Internal
MMDEVLDR_IOCTL_QUEUEAPC         equ     4		;Internal
MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR equ   5		;Internal
MMDEVLDR_IOCTL_CLOSEVXDHANDLE   equ     6		;Internal
MMDEVLDR_IOCTL_PAGEALLOCATE     equ     7		;Internal
MMDEVLDR_IOCTL_PAGEFREE         equ     8		;Internal
MMDEVLDR_IOCTL_GETDEVICESTATUS  equ     9		;Internal
							;Internal
MM_DEVSTATUS_ERROR          equ 0			;Internal
MM_DEVSTATUS_STARTED        equ 1			;Internal
MM_DEVSTATUS_UNKNOWNPROB    equ 2			;Internal
MM_DEVSTATUS_DISABLED       equ 3			;Internal
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\valmode.inc ===
;/*
;----------------------------------------------------------------------------
; VALMODE.INC
; Copyright (c) 1993-94 Microsoft Corporation
;
; Definitions for ValidateMode.
;
; UINT WINAPI ValidateMode(DISPVALMODE FAR *);
; NOTE: Display drivers must use the name "ValidateMode" in the .def file
; since windows dyna-links to this function by name, not by ordinal. Ordinal
; 700 is the recommended value for this function.
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; E Q U A T E S
;
; the possible return values from DisplayValidateMode
;----------------------------------------------------------------------------
VALMODE_YES		equ	0	;definitely valid
VALMODE_NO_WRONGDRV	equ	1	;driver doesn't work on adapter
VALMODE_NO_NOMEM	equ	2	;not enough memory for settings
VALMODE_NO_NODAC	equ	3	;DAC can't handle colors
VALMODE_NO_UNKNOWN	equ	4	;unknown problem
comment ~
*/
#define VALMODE_YES		0
#define VALMODE_NO_WRONGDRV	1
#define VALMODE_NO_NOMEM	2
#define VALMODE_NO_NODAC	3
#define VALMODE_NO_UNKNOWN	4
/*
end comment ~
;----------------------------------------------------------------------------
; S T R U C T U R E S
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; DISPVALMODE - basic structure for mode information
;----------------------------------------------------------------------------
DISPVALMODE	    struc						;*/ typedef struct {	/*
  dvmSize	    dw	?		; size of this structure	;*/ UINT dvmSize;	/*
  dvmBpp	    dw	?		; color resolution		;*/ UINT dvmBpp;	/*
  dvmXRes	    dw	?		; X resolution			;*/ int dvmXRes;	/*
  dvmYRes	    dw	?		; Y resolution			;*/ int dvmYRes;	/*
DISPVALMODE	    ends		                                ;*/ } DISPVALMODE;  	/*
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\verinfo.h ===
/*
 *  verinfo.h - header file to define the build version
 *
 */

//
// Force all builds to default to private
//

//#ifdef OFFICIAL_BUILD
#define OFFICIAL		1
//#endif

#ifndef DIRECTX_REDIST
// On official whistler build machines, the DX bits should not be timebombed, so
// we say that all whislter builds are "final release":
#define DX_FINAL_RELEASE           1
#else
// On DX build machines and private developer builds, we use non-final release builds
// unless this var. is set in the environment or uncommented here:

// Uncomment the following line for a non time bombed build
#define DX_FINAL_RELEASE           1

#endif


#ifndef DX_FINAL_RELEASE
#define DX_EXPIRE_YEAR          2001
#define DX_EXPIRE_MONTH            9 /* Jan=1, Feb=2, etc .. */
#define DX_EXPIRE_DAY              1
#define DX_EXPIRE_TEXT   TEXT("This pre-release version of DirectX has expired, please upgrade to the latest version from http://www.microsoft.com/directx")
#endif

#define MANVERSION              4
#define MANREVISION             8
#define MANMINORREV             1
#define BUILD_NUMBER            612
#define RC_NUMBER               0

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME      "Microsoft\256 DirectX for Windows\256  95 and 98\0"
#define VERSIONCOPYRIGHT        "Copyright \251 Microsoft Corp. 1994-2000\0"
#endif


/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME      "Microsoft Corporation\0"

/*
 *  Version flags
 */
//
// these two #define's are for RTM release
//
#define FINAL

#undef VER_PRIVATEBUILD
#ifndef OFFICIAL
#define VER_PRIVATEBUILD        VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD        0
#endif

#undef VER_PRERELEASE
#ifndef FINAL
#define VER_PRERELEASE          VS_FF_PRERELEASE
#else
#define VER_PRERELEASE          0
#endif

#undef VER_DEBUG
#ifdef DEBUG
#define VER_DEBUG               VS_FF_DEBUG
#elif RDEBUG
#define VER_DEBUG               VS_FF_DEBUG
#else
#define VER_DEBUG               0
#endif

#define VERSIONFLAGS            (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK    0x0030003FL
#endif

#ifdef ADJ_MANREVISION
#undef MANREVISION
// extra spaces intended to correct a problem
#define     MANREVISION ADJ_MANREVISION
#endif

#if 	(MANMINORREV < 10)
#define MMR_BPAD "0"
#else
#define MMR_BPAD
#endif

#if 	(MANREVISION < 10)
#define MR_BPAD "0"
#else
#define MR_BPAD
#endif

#if 	(BUILD_NUMBER < 10)
#define BN_BPAD "000"
#elif	(BUILD_NUMBER < 100)
#define BN_BPAD "00"
#elif	(BUILD_NUMBER < 1000)
#define BN_BPAD "0"
#else
#define BN_BPAD ""
#endif

#define BUILD_NUMBER_STR2(x) 	BN_BPAD #x
#define BUILD_NUMBER_STR1(x) 	BUILD_NUMBER_STR2(x)
#define BUILD_NUMBER_STR       	BUILD_NUMBER_STR1(BUILD_NUMBER)


#define VERSION_STR2(w,x,y,z) 	#w "." MR_BPAD #x "." MMR_BPAD #y "." BN_BPAD #z
#define VERSION_STR1(w,x,y,z) 	VERSION_STR2(w, x, y, z)
#define VERSIONSTR       	VERSION_STR1(MANVERSION, MANREVISION, MANMINORREV, BUILD_NUMBER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\inc\vflatd.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1993-1994
;
;   Title:	Virtual Flat Device Exported Services
;
;   Version:	2.00
;
;   Date:	8-Nov-1993
;
;   Author:	RAP
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   08-Nov-1993 RAP Original
;
;==============================================================================

IFDEF VMM_TRUE
Begin_Service_Table VFLATD

VFLATD_Service VFLATD_Get_Version, LOCAL
VFLATD_Service VFLATD_Unmap_Flat_Selector, LOCAL

End_Service_Table VFLATD
ENDIF

VflatD_Chicago_ID   equ     011Fh           ; OEM #8 Device #31
VflatD_Windows_ID   equ     (0440h + 29d)   ; MMSYS OEM# device 30

ifdef WIN31
VflatD_Device_ID    equ     VflatD_Windows_ID
VflatD_Version      equ     0160h           ; 1.60
else
VflatD_Device_ID    equ     VflatD_Chicago_ID
VflatD_Version      equ     0201h           ; 2.01
endif

;
;   PM API defines
;
VFlatD_Query                        equ 0
VFlatD_Get_Sel                      equ 1
VFlatD_ResetBank                    equ 2
VFlatD_Create_Virtual_Frame_Buffer  equ 3
VFlatD_Create_Physical_Frame_Buffer equ 4
VFlatD_Begin_Linear_Access          equ 5
VFlatD_End_Linear_Access            equ 6

;******************************************************************************
;
;   VFLATD_PM_API_Query
;
;   DESCRIPTION:
;       Query VFlatD info
;
;   ENTRY:
;       Client_DX = 0
;
;   EXIT:
;       Client_EAX = VFlatD version (HIWORD flags)
;       Client_EBX = GDT selector to the frame buffer
;       Client_ECX = size of frame buffer
;       Client_EDX = linear base of frame buffer. (if linear mode)
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_Create_Virtual_Frame_Buffer
;
;   DESCRIPTION:
;       Return a GDT selector to the flat video buffer
;
;   ENTRY:
;       Client_DL    = 3
;       Client_DH    = flags
;       Client_EAX   = size of frame buffer (in bytes) (ie 2MB)
;       Client_EBX   = size of a bank (in bytes) (ie 64k)
;       Client_ESI   = location of bank (ie A0000)
;       Client_CX    = size of bank switch code
;       Client_ES:DI = ptr to bank switch code
;
;   EXIT:
;       Client_AX  = Selector to flat video buffer
;       Client_EDX = Linear base of flat video buffer
;       Client carry flag clear
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_Create_Physical_Frame_Buffer
;
;   DESCRIPTION:
;       Return a GDT selector to a flat video buffer
;
;   ENTRY:
;       Client_DL    = 4
;       Client_DH    = flags
;       Client_EAX   = physical base of frame buffer
;       Client_ECX   = size of frame buffer (in bytes)
;
;   EXIT:
;       Client_AX  = Selector to flat video buffer
;       Client_EDX = Linear base of flat video buffer
;       Client carry flag clear
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_Get_Video_Base
;
;   this function has been replaced with VflatD_Create_Virtual_Frame_Buffer
;   it is still supported for old code.
;
;   DESCRIPTION:
;       Return a GDT selector to the flat video buffer
;
;   ENTRY:
;       Client_DX = 1
;       Client_AX = # of pages of video memory
;       Client_CX = size of bank switch code
;       Client_ES:DI -> bank switch code
;
;   EXIT:
;       Client_AX  = Selector to flat video buffer
;       Client_EDX = Linear base of flat video buffer
;       Client carry flag clear
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_Reset
;
;   DESCRIPTION:
;       Called when Video HW has been changed by someone other
;       than VFLATD.
;
;   ENTRY:
;       Client_DX = 2
;
;   EXIT:
;       Client carry flag clear
;
;   USES:
;       EAX, Flags, Client_AX, Client_Flags
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_Begin_Linear_Access
;
;   DESCRIPTION:
;       Start linear access to the frame buffer
;
;       the frame buffer can be accessed via its linear address
;       (by default the frame buffer *must* be accessed with
;       the default selector)
;
;       the frame bufffer will remain in linear access mode, until
;       VFLATD_PM_API_End_Linear_Access is called.
;
;       this call can be nested.
;
;   ENTRY:
;       Client_DX = 5
;
;   EXIT:
;       Client_EAX = access count
;
;==============================================================================

;******************************************************************************
;
;   VFLATD_PM_API_End_Linear_Access
;
;   DESCRIPTION:
;       Stop linear access to the frame buffer
;
;       this must be called the same number of times as
;       VFLATD_PM_API_Begin_Linear_Access to actualy leave linear mode.
;
;   ENTRY:
;       Client_DX = 6
;
;   EXIT:
;       Client_EAX = access count
;
;==============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\makefile.inc ===
SEDLOC=..\..\sed.exe

ORIGINAL1="/; localizeable/,$$d"
LOCALIZED1="/; localizeable/,$$!d"

ORIGINAL2="/;localizeable/,$$d"
LOCALIZED2="/;localizeable/,$$!d"

LOCEDJYSTK=jystk$(LANGUAGE).inf

$(O)\ks.inf $(O)\ks98.inf: $(_NTTREE)\$(@F) .\$(@F)
	@copy $(_NTTREE)\$(@F) .\$(*F).org
	$(SEDLOC) -e $(ORIGINAL1) .\$(*F).org > $@
	$(SEDLOC) -e $(LOCALIZED1) .\$(@F) >> $@
	@echo $(@F) localized\$(LANGUAGE)>$(O)\placefil.txt
	@del .\$(*F).org
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@

$(O)\ksfilter.inf $(O)\ksfilt98.inf: $(_NTTREE)\$(@F) .\$(@F)
	@copy $(_NTTREE)\$(@F) .\$(*F).org
	$(SEDLOC) -e $(ORIGINAL2) .\$(*F).org > $@
	$(SEDLOC) -e $(LOCALIZED2) .\$(@F) >> $@
	@echo $(@F) localized\$(LANGUAGE)>$(O)\placefil.txt
	@del .\$(*F).org
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@

$(O)\ksreg.inf: $(_NTTREE)\ks.inf .\ks.inf
	@copy $(_NTTREE)\ks.inf .\$(*F).org
	$(SEDLOC) -f ..\..\deldel.sed .\$(*F).org > $@
	$(SEDLOC) -e $(LOCALIZED1) .\ks.inf >> $@
	@echo $(@F) localized\$(LANGUAGE)>$(O)\placefil.txt
	@del .\$(*F).org
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@

$(O)\joystick.inf: .\$(@F)
	@copy .\$(@F) $@
	@copy .\$(@F) $O\$(LOCEDJYSTK)
	@echo $(@F) localized\$(LANGUAGE)>$(O)\placefil.txt
	@echo $(LOCEDJYSTK) localized\multi>>$(O)\placefil.txt
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $O\$(LOCEDJYSTK)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\brz\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\cht\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\sources.inc ===
!IF 0

This project contains files that are not built by the NT Build Lab.
This file is a template for all sources files within this project.

!ENDIF

TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

SOURCES=

NTTARGETFILES= \
	$(O)\ks.inf \
	$(O)\ksfilter.inf \
!if "$(ALT_PROJECT_TARGET)"=="Win9X"
	$(O)\ks98.inf \
	$(O)\ksfilt98.inf \
	$(O)\joystick.inf
!else
	$(O)\ksreg.inf
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\chs\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\cze\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\ger\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\itn\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\jpn\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\kor\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\pol\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\spa\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\rus\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\swe\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\brz\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\dut\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\chs\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\cht\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\cze\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\dut\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\frn\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\ger\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\frn\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\eng\makefile.inc ===
SEDLOC=..\..\sed.exe

$(O)\ks.inf:

$(O)\ksfilter.inf:

$(O)\ksreg.inf: $(_NTTREE)\ks.inf
	@copy $(_NTTREE)\ks.inf .\$(*F).org
	$(SEDLOC) -e "/^DelFiles=/d" .\$(*F).org > $@
	@echo $(@F) retail>$(O)\placefil.txt
	@del .\$(*F).org
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\jpn\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\kor\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\itn\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\pol\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\rus\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\spa\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\swe\makefile.inc ===
!ifndef LOROOT
LOROOT=..\..
!endif

!include $(LOROOT)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\daytona\multi\makefile.inc ===
SEDLOC=..\..\sed.exe

$(O)\ks.inf $(O)\ksfilter.inf: $(_NTTREE)\$(@F)
	@copy $(_NTTREE)\$(@F) $@
	@echo $(@F) localized\$(LANGUAGE)>$(O)\placefil.txt
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@

$(O)\ksreg.inf: $(_NTTREE)\ks.inf
	@copy $(_NTTREE)\ks.inf .\$(*F).org
	$(SEDLOC) -e "/^DelFiles=/d" .\$(*F).org > $@
	@echo $(@F) localized\$(LANGUAGE)>$(O)\placefil.txt
	@del .\$(*F).org
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\misc\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );

extern HANDLE HelperGetDDVxd( void );

#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );
extern HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName);
extern BOOL HelperFreeLibrary(HINSTANCE hInst);
extern void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);
extern void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:    debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-jan-95  craige  initial implementation
 *   03-mar-95  craige  added dprintf2
 *   31-mar-95  craige  add DPFInit to read WIN.INI for [DirectDraw] section;
 *                      added dprintf3
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   18-jun-95  craige  use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed DXdprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR       "DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT       "DirectDraw"
    #endif

    #define END_STR             "\r\n"

    HWND                hWndListBox;
    LONG                lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
            if( hWndListBox != NULL )
            {
                if( !IsWindow( hWndListBox ) )
                {
                    hWndListBox = NULL;
                }
            }
            if( hWndListBox != NULL )
            {
                UINT    sel;
                int     len;
                len = strlen( str );
                if( len > 0 )
                {
                    if( str[len-1] == '\r' || str[len-1] == '\n' )
                    {
                        str[len-1] = 0;
                    }
                    if( len > 1 )
                    {
                        if( str[len-2] == '\r' || str[len-2] == '\n' )
                        {
                            str[len-2] = 0;
                        }
                    }
                }
                SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
                sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
                if( sel != LB_ERR )
                {
                    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
                }
            }
        #endif

    } /* dumpStr */

    /*
     * DXdprintf
     */
    void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

        va_end(ap);
    } /* DXdprintf */


    static void cdecl D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;

        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            wsprintf( (LPSTR) str+lstrlen( str ), msgType );
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

    } /* D3Dprintf */

    void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap, szFormat);

        D3Dprintf(lvl, "(INFO) :", szFormat, ap);

        va_end(ap);
    }

    void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(lvl, "(WARN) :", szFormat, ap);
        va_end(ap);
    }

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        DXdprintf( ASSERT_MESSAGE_LEVEL, buffer );
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
            /*
             * Into the debugger we go...
             */
            DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return (LPVOID)lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
SIZE_T __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern SIZE_T __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\misc\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   09-may-95	craige	loading any DLL
 *   16-sep-95	craige	bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *   29-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

#undef E_FAIL
#define E_FAIL	0x80004005L

//extern DWORD	* pdwHelperPid;
//extern HANDLE	* phModule;	// must be defined
extern DWORD	dwHelperPid;
extern HINSTANCE hModule;	// must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( (HANDLE) 0xffffffff, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
	DPF( 1, "Could not create view of file!" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex!" );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
    }
    else
    {
	DPF( 1, "Could not signal event to notify DDHELP" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA	hd;

    if( dwHelperPid == 0 )
    {
	return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
	return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, 100000 );  // fail if this doesn't work within 100 seconds
    CloseHandle( hevent );
    if( rc == WAIT_TIMEOUT )
    {
        return FALSE;
    }
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
	hd.req = DDHELPREQ_LOADDLL;
	lstrcpy( hd.fname, dllname );
	if( fnname != NULL )
	{
	    strcpy( hd.func, fnname );
	    hd.context = context;
	    DPF( 3, "Context=%08lx", context );
	}
	else
	{
	    hd.func[0] = 0;
	}
	DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = (DWORD)hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */


/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */


/*
 * StopWatchProcess
 *
 * Signal DDHELP to stop watching a process.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA	hd;

    if( pid == dwHelperPid )
    {
	DPF( 3, "Helper connected to DLL - no signal required" );
	return;
    }

    DPF( 3, "Signalling DDHELP to stop watching a process" );
    hd.req = DDHELPREQ_STOPWATCHPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA	hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
	STARTUPINFO		si;
	PROCESS_INFORMATION	pi;
	HANDLE			h;

	h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
	if( h == NULL )
	{
	    si.cb = sizeof(STARTUPINFO);
	    si.lpReserved = NULL;
	    si.lpDesktop = NULL;
	    si.lpTitle = NULL;
	    si.dwFlags = 0;
	    si.cbReserved2 = 0;
	    si.lpReserved2 = NULL;

	    DPF( 3, "Creating helper process now" );
	    if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
			       NORMAL_PRIORITY_CLASS,
			       NULL, NULL, &si, &pi) )
	    {
		DPF( 2, "Could not create DDHELP.EXE" );
		return FALSE;
	    }
	    dwHelperPid = pi.dwProcessId;
	    DPF( 3, "Helper rocess created" );
	}
	else
	{
	    DDHELPDATA	hd;
	    DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
	    WaitForSingleObject( h, INFINITE );
	    CloseHandle( h );
	    DPF( 3, "Asking for DDHELP pid" );
	    hd.req = DDHELPREQ_RETURNHELPERPID;
	    sendRequest( &hd );
	    dwHelperPid = hd.pid;
	    DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
	}
	*ppid = dwHelperPid;
	return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifndef WINNT   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA	hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
	hd.req = DDHELPREQ_WAVEOPEN;
	hd.pData1 = lphwo;
	hd.dwData1 = dwDeviceID;
	hd.dwData2 = (DWORD)pwfx;
	DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Open param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA	hd;

    if( (hwo != 0) )
    {
	hd.req = DDHELPREQ_WAVECLOSE;
	hd.dwData1 = hwo;
	DPF( 3, "Asking DDHELP to Close Wave Device ");
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
			 LPVOID	pTimerProc,
			 DWORD dwInstanceData )
{
    DDHELPDATA	hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
	hd.req = DDHELPREQ_CREATETIMER;
	hd.pData1 = pTimerProc;
	hd.dwData1 = dwResolution;
	hd.dwData2 = dwInstanceData;
	DPF( 3, "Asking DDHELP to Create Timer" );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA	hd;

    if( (dwTimerID != 0) )
    {
	hd.req = DDHELPREQ_KILLTIMER;
	hd.dwData1 = dwTimerID;
	DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
	sendRequest( &hd );
	return hd.dwReturn;
    }
    else
    {
	DPF( 3, "Helper Wave Close param error");
	return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
				  LPDWORD pdwThreadParam,
				  DWORD dwFlags,
				  LPDWORD pThreadId )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open modeset event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */

#ifndef WINNT
/*
 * HelperCreateDOSBoxThread
 *
 * get the helper to create a thread so kernel mode can notify us of DOS box
 * changes.
 */
BOOL HelperCreateDOSBoxThread(
		LPVOID callback,
		HANDLE *ph,
		LPVOID lpdd,
		DWORD hInstance )
{
    DDHELPDATA	hd;
    HANDLE	h;
    char	str[64];

    hd.req = DDHELPREQ_CREATEDOSBOXTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
	DPF( 3, "Could not open DOS box event!" );
	*ph = NULL;
	return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateDOSBoxThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateDOSBoxThread */

/*
 * HelperKillDOSBoxThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillDOSBoxThread( DWORD hInstance )
{
    DDHELPDATA	hd;

    hd.req = DDHELPREQ_KILLDOSBOXTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillDOSBoxThread */

#endif //!winnt

// notify dphelp.c that we have a new server on this system
DWORD HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DDHELPDATA));
    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    if (sendRequest(&hd))
		return (DWORD)hd.dwReturn;
	else
		return ((DWORD) E_FAIL);
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef WIN95
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
	DDHELPDATA hd;
	hd.req = DDHELPREQ_GETDSVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */

    /*
     * Get DDHELP to load the DirectDraw VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDDVxd( void )
    {
	DDHELPDATA hd;
        hd.req = DDHELPREQ_GETDDVXDHANDLE;
	sendRequest( &hd );
	return (HANDLE) hd.dwReturn;
    } /* HelperGetDDVxd */

#endif /* WIN95 */

/*
 * HelperSetOnDisplayChangeNotify
 *
 * get the helper to call us back if there is DisplayChange
 * message. (This is for multi-mon topology changes.)
 */
void HelperSetOnDisplayChangeNotify( void *pfn )
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_NOTIFYONDISPLAYCHANGE;
    hd.dwData1 = (DWORD_PTR)pfn;
    sendRequest( &hd );
    return;
}

HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_LOADLIBRARY;
    hd.dwData1 = (DWORD_PTR)pszLibraryName;
    sendRequest(&hd);
    return (HINSTANCE)hd.dwReturn;
}

BOOL HelperFreeLibrary(HINSTANCE hInst)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_FREELIBRARY;
    hd.dwData1 = (DWORD_PTR)hInst;
    sendRequest(&hd);
    return (BOOL)hd.dwReturn;
}

void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_ADDDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}

void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_DELDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\loc\inf\win9x\multi\makefile.inc ===
SEDLOC=..\..\sed.exe

$(O)\ks.inf $(O)\ksfilter.inf $(O)\ks98.inf $(O)\ksfilt98.inf: $(_NTTREE)\$(@F)
	@copy $(_NTTREE)\$(@F) $@
	@echo $(@F) localized\$(LANGUAGE)>$(O)\placefil.txt
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@

$(O)\joystick.inf: .\$(@F)
	@copy .\$(@F) $@
	@echo $(@F) localized\$(LANGUAGE)>$(O)\placefil.txt
	binplace -R $(_NTTREE) -S $(_NTTREE)\Symbols -n $(_NTTREE)\Symbols.pri -j -P $(O)\placefil.txt -xa $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\misc\verinfo.h ===
/*
 *  verinfo.h - header file to define the build version
 *
 */

//
// Force all builds to default to private
//

#ifdef OFFICIAL_BUILD
#define OFFICIAL		1
#endif

// Uncomment the following line for a non time bombed build
//#define DX_FINAL_RELEASE           1

#ifndef DX_FINAL_RELEASE
#define DX_EXPIRE_YEAR          2000
#define DX_EXPIRE_MONTH            7 /* Jan=1, Feb=2, etc .. */
#define DX_EXPIRE_DAY              4
#define DX_EXPIRE_TEXT   TEXT("This pre-release version of DirectX has expired, please upgrade to the latest version.")
#endif

#define MANVERSION              4
#define MANREVISION             8
#define MANMINORREV             1
#define BUILD_NUMBER            0022

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME      "Microsoft\256 DirectX for Windows\256  95 and 98\0"
#define VERSIONCOPYRIGHT        "Copyright \251 Microsoft Corp. 1994-2000\0"
#endif


/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME      "Microsoft Corporation\0"

/*
 *  Version flags
 */
//
// these two #define's are for RTM release
//
//#define FINAL

#undef VER_PRIVATEBUILD
#ifndef OFFICIAL
#define VER_PRIVATEBUILD        VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD        0
#endif

#undef VER_PRERELEASE
#ifndef FINAL
#define VER_PRERELEASE          VS_FF_PRERELEASE
#else
#define VER_PRERELEASE          0
#endif

#undef VER_DEBUG
#ifdef DEBUG
#define VER_DEBUG               VS_FF_DEBUG
#elif RDEBUG
#define VER_DEBUG               VS_FF_DEBUG
#else
#define VER_DEBUG               0
#endif

#define VERSIONFLAGS            (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK    0x0030003FL
#endif

//
// Make versioning more automatic  
// bugbug clean up for 7.0
//

#ifdef ADJ_MANREVISION
#undef MANREVISION
// extra spaces intended to correct a problem
#define     MANREVISION ADJ_MANREVISION
#endif

#if 	(MANMINORREV < 10)
#define MMR_BPAD "0"
#else
#define MMR_BPAD
#endif

#if 	(MANREVISION < 10)
#define MR_BPAD "0"
#else
#define MR_BPAD
#endif

#if 	(BUILD_NUMBER < 10)
#define BN_BPAD "000"
#elif	(BUILD_NUMBER < 100)
#define BN_BPAD "00"
#elif	(BUILD_NUMBER < 1000)
#define BN_BPAD "0"
#else
#define BN_BPAD ""
#endif

#define BUILD_NUMBER_STR2(x) 	BN_BPAD #x
#define BUILD_NUMBER_STR1(x) 	BUILD_NUMBER_STR2(x)
#define BUILD_NUMBER_STR       	BUILD_NUMBER_STR1(BUILD_NUMBER)


#define VERSION_STR2(w,x,y,z) 	#w "." MR_BPAD #x "." MMR_BPAD #y "." BN_BPAD #z
#define VERSION_STR1(w,x,y,z) 	VERSION_STR2(w, x, y, z)
#define VERSIONSTR       	VERSION_STR1(MANVERSION, MANREVISION, MANMINORREV, BUILD_NUMBER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
	    #define DEBUG
        #endif
    #endif

    extern void cdecl dprintf( UINT lvl, LPSTR szFormat, ...);
    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPFINIT()   DPFInit()
        #define DPF         dprintf
        #define DPF_ERR(a)  dprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
	    #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
	    #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT
    #else
        #pragma warning(disable:4002)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\common.inc ===
# This file contains everything that's common between all AMovie directories.

SOURCES_USED=$(ROOT)\common.inc

SDK_ROOT=$(BASEDIR)\public\sdk\amovie

PASS0_HEADERDIR = $(O)
PASS0_SOURCEDIR = $(O)
MIDL_TLBDIR=$(O)

UMTYPE=windows

# Use NT4/Win95 base API's with IE4 addon support.

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

!ifndef USE_MFC
WIN32_IE_VERSION=0x0400
!endif

NOT_LEAN_AND_MEAN=1

# Runs on NT4/Win95 or better

SUBSYSTEM_VERSION=4.00

!if "$(BUILD_PRODUCT)" != "NT"
C_DEFINES=$(C_DEFINES) -DSTRICT -DWINVER=0x0400 -DNT_BUILD -DDIRECTDRAW_VERSION=0x0300 -DDIRECTSOUND_VERSION=0x0800 -DFINAL=1 -DOFFICIAL=1
!else
C_DEFINES=$(C_DEFINES) -DSTRICT -DWINVER=0x0501 -DNT_BUILD -DDIRECTDRAW_VERSION=0x0300 -DDIRECTSOUND_VERSION=0x0800 -DFINAL=1 -DOFFICIAL=1
!endif

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w
!endif

INCLUDES= \
    $(SDK_ROOT)\inc; \
    $(ROOT)\h;


!if exist( "$(ROOT)\qbuild.ver" )
C_DEFINES=$(C_DEFINES) -DQBUILD_VER
INCLUDES = $(INCLUDES)$(ROOT);
!endif

!if defined(DIRECTX_REDIST) && exist( "$(ROOT)\..\directx\inc\verinfo.h" )
C_DEFINES=$(C_DEFINES) -DDXBUILD_VER
INCLUDES=$(INCLUDES);$(ROOT)\..\directx\inc;
!endif

MSC_WARNING_LEVEL=/W3

!ifdef NTNOPCH
DISABLE_PCH=1
!endif

# unfortunately sources files define PRECOMPILED_INCLUDE after this
# file is preprocessed, and there doesn't appear to be a way to delay
# its evaluation
!ifndef PRECOMPILED_INCLUDE
!ifndef DISABLE_PCH
USER_C_FLAGS=/Yustreams.h /Fp$(PROJECT_ROOT)\published\dxmdev\dshowdev\base\$(O)\streams.pch
!endif
!endif

USE_MSVCRT=1

!ifndef PROJECT_OBJ_ROOT
PROJECT_OBJ_ROOT=$(PROJECT_ROOT)
!endif

!ifdef PERF
C_DEFINES=$(C_DEFINES) -DPERF
QUARTZ_PERF_LIB=$(QUARTZ_LIB_DIR)\measure.lib
!endif

# allow mixing debug/retail strmbase.lib in our builds only. the NT
# tree pulls it from nt\public\sdk\lib
STRMBASE_LIB=$(PROJECT_ROOT)\published\dxmdev\dshowdev\base\$(O)\strmbase.lib

!if "$(BUILD_PRODUCT)" != "NT"
!if !$(FREEBUILD)
#DEBUG_CRTS=1
!endif
!else
!ifndef NEVER_UNICODE
C_DEFINES=-DUNICODE -D_UNICODE $(C_DEFINES)
WIN32_WINNT_VERSION=0x0500
!endif
!endif

# Add lib flags for old platforms when shipping DX
!ifdef DIRECTX_REDIST
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) /link50compat
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\dvdec\resource.h ===
#define IDS_DECTITLE                    1
#define IDD_DVDEC                       101
#define IDC_DEC720x480                  1000
#define IDC_DEC360x240                  1001
#define IDC_DEC180x120                  1002
#define IDC_DEC88x60                    1003
#define IDC_DISPLAY                     1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\dvdec\dvdec.cpp ===
#include <dmocom.h>
#define DMO_NOATL // xfwrap.h needs this to work w/o ATL
#include <dmobase.h>
#include "decode.h"
#include <amvideo.h>
#include "resource.h"
#include "strmif.h" // DVINFO

#include "initguid.h"
DEFINE_GUID(CLSID_DVDecDMO, 0xb321fd8b,0xcf6c,0x4bbe,0xaf,0x37,0xd1,0xa5,0x10,0xe4,0xee,0xee);
DEFINE_GUID(MEDIASUBTYPE_dvc, 0x20637664,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);

const DWORD bits565[] = {0x00F800,0x0007E0,0x00001F};

class CDVDec : public CComBase,
               public C1for1QCDMO,
               public ISpecifyPropertyPages,
               public IIPDVDec
{
public:
   DECLARE_IUNKNOWN;
   STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
   static CComBase *CreateInstance(IUnknown *pUnk, HRESULT *phr);
   CDVDec(IUnknown *pUnk, HRESULT *phr);
   ~CDVDec();

   // entry points called by the base class
   HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
   HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
   HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
   HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
   HRESULT QCProcess(BYTE* pIn,ULONG ulBytesIn,BYTE* pOut,ULONG* pulProduced);
   HRESULT GetSampleSizes(ULONG* ulMaxInputSize, ULONG* ulMaxOutputSize);
   HRESULT Init();

   // internal methods
   HRESULT MapInputTypeToOutputType(const DMO_MEDIA_TYPE *pmtIn, DMO_MEDIA_TYPE *pmtOut);
   void InitDestinationVideoInfo(VIDEOINFO *pVI, DWORD Comp, int n);
   long ActualHeight(long biHeight);
   void SetDimensions();

   // ISpecifyPropertyPages interface
   STDMETHODIMP GetPages(CAUUID *pPages);

   // Entry points for communicating with the property page
   STDMETHODIMP get_IPDisplay(int *iDisplay);
   STDMETHODIMP put_IPDisplay(int iDisplay);

private:
   char *m_pMem;
   int m_iDisplay;
   long m_lPicWidth;
   long m_lPicHeight;
   long m_lStride;
   DWORD m_CodecCap;
   DWORD m_CodecReq;
};

CComBase* CDVDec::CreateInstance(IUnknown *pUnk, HRESULT *phr) {
   return new CDVDec(pUnk, phr);
}

HRESULT CDVDec::get_IPDisplay(int *iDisplay) {
   CDMOAutoLock l(&m_cs);
   *iDisplay = m_iDisplay;
   return NOERROR;
}
HRESULT CDVDec::put_IPDisplay(int iDisplay) {
   CDMOAutoLock l(&m_cs);
   m_iDisplay = iDisplay;
   SetDimensions();
   return NOERROR;
}


// Set m_lPicHeight and m_lPicWidth based on the m_iDisplay setting.
// The way this sets m_lPicHeight assumes NTSC, but the value of m_lPicHeight
// is used only for mediatype *enumeration* - the mediatype *checking* code
// will accept matching PAL values as well.
void CDVDec::SetDimensions() {
   switch (m_iDisplay) {
   case IDC_DEC360x240:
      m_lPicWidth = 360;
      m_lPicHeight = 240;
      break;
   case IDC_DEC720x480:
      m_lPicWidth = 720;
      m_lPicHeight = 480;
      break;
   case IDC_DEC180x120:
      m_lPicWidth = 180;
      m_lPicHeight = 120;
      break;
   case IDC_DEC88x60:
      m_lPicWidth = 88;
      m_lPicHeight = 60;
      break;
   // no default
   }
}

CDVDec::CDVDec(IUnknown *pUnk, HRESULT *phr)
  : CComBase(pUnk, phr),
   m_pMem(NULL),
   m_iDisplay(IDC_DEC360x240)
{
   SetDimensions();
   m_CodecCap = AM_DVDEC_DC |
                AM_DVDEC_Quarter |
                AM_DVDEC_Half |
                AM_DVDEC_Full |
                AM_DVDEC_NTSC |
                AM_DVDEC_PAL |
                AM_DVDEC_RGB24 |
                AM_DVDEC_UYVY |
                AM_DVDEC_YUY2 |
                AM_DVDEC_RGB565 |
                AM_DVDEC_RGB555 |
                AM_DVDEC_RGB8 |
                AM_DVDEC_DVSD |
                AM_DVDEC_MMX;
}

CDVDec::~CDVDec() {
    delete[] m_pMem;
}

HRESULT CDVDec::NDQueryInterface(REFIID riid, void **ppv) {
   if (riid == IID_IMediaObject)
      return GetInterface((IMediaObject*)this, ppv);
   if (riid == IID_ISpecifyPropertyPages)
      return GetInterface((ISpecifyPropertyPages*)this, ppv);
   if (riid == IID_IIPDVDec)
      return GetInterface((IIPDVDec*)this, ppv);
   if (riid == IID_IDMOQualityControl)
      return GetInterface((IDMOQualityControl*)this, ppv);
   return CComBase::NDQueryInterface(riid, ppv);
}

// Returns the clsid's of the property pages we support
STDMETHODIMP CDVDec::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_DVDecPropertiesPage;
    return NOERROR;

}

/***********************************************************************\
* IsMMXCPU
*
* Function to check if the current processor is an MMX processor.
*
\***********************************************************************/
BOOL IsMMXCPU() {
#ifdef _X86_
    //////////////////////////////////////////////////////
    // work around for Cyrix M2 hang (when MMX flag is on)
    // emit cpuid and detect Cyrix M2, if its present, then return FALSE
    // WARNING: This will not work in 64 bit architectures
    __try
    {
        DWORD   s1, s2, s3;     // temporary holders for the vendor name

        __asm
        {
            // null out eax
            mov eax, 0x00;

            // load opcode CPUID == (0x0FA2)
            _emit 0x0f;
            _emit 0xa2;
            mov s1, ebx;    // copy "Cyri" (backwards)
            mov s2, edx;    // copy "xIns" (backwards)
            mov s3, ecx;    // copy "tead" (backwards)
        }

        //DbgLog((LOG_TRACE, 1, TEXT("CPUID Instruction Supported")));

        // check Vendor Id
        if( (s1 == (('i' << 24) | ('r' << 16) | ('y' << 8) | ('C')))
            && (s2 == (('s' << 24) | ('n' << 16) | ('I' << 8) | ('x')))
            && (s3 == (('d' << 24) | ('a' << 16) | ('e' << 8) | ('t'))) )

        {
            //DbgLog((LOG_TRACE, 1, TEXT("Cyrix detected")));
            return FALSE;
        }
        else
        {
            // otherwise it's some other vendor and continue with MMX detection
            //DbgLog((LOG_TRACE, 1, TEXT("Cyrix not found, reverting to MMX detection")));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // log it and continue on to MMX detection sequence
        //DbgLog((LOG_TRACE, 1, TEXT("CPUID instruction not supported, reverting to MMX detection")));
    }
    // END Cyrix M2 detection
    //////////////////////////////////////////////////////

    //
    // If this is an Intel platform we need to make sure that we
    // are running on a machine that supports MMX instructions
    //
    __try {

    __asm _emit 0fh;
    __asm _emit 77h;

    return TRUE;

    }
     __except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
#else
    return FALSE;
#endif
}

///////////////////////////////////////////////////////////////
//                                                           //
//   M E D I A   T Y P E   N E G O T I A T I O N   C O D E   //
//                                                           //
///////////////////////////////////////////////////////////////

//
// A note about the mediatype code below.
//
// The code in GetOutputType(), CheckOutputType(), and Init() largely came from
// the original DV decoder's CheckInputType(), CheckTransform(), SetMediaType(),
// and GetMediaType().  I had to shuffle pieces of code around a lot to fit the
// different framework.  I tried to understand the code while porting it, but
// some of it is still beyond me, so it is quite possible I introduced some bugs
// in the process.
//


/////////////////////////////////////////////////////////////////////
// Helpers.  These were mostly inlined in the original DV decoder, //
// but I made them functions to eliminate some code duplication.   //
// Again, I probably introduced bugs in the process.               //
/////////////////////////////////////////////////////////////////////
long CDVDec::ActualHeight(long biHeight) {
//
// This function uses biHieght only to determine whether this format is PAL or
// NTSC.  Once that is determined, the code completely ignores the actual value
// of biHeight and relies exclusively on m_iDisplay.  I do not understand why
// this makes sense, but I swear that this is effectively what the code in the
// original DV decoder does.
//
   if ((biHeight == 480) ||
       (biHeight == 240) ||
       (biHeight == 120) ||
       (biHeight ==  60)) { // NTSC
      if (m_iDisplay == IDC_DEC720x480)
         return 480;
      if (m_iDisplay == IDC_DEC360x240)
         return 240;
      if (m_iDisplay == IDC_DEC180x120)
         return 120;
      if (m_iDisplay == IDC_DEC88x60)
         return 60;
      return 0;
   }
   if ((biHeight == 576) ||
            (biHeight == 288) ||
            (biHeight == 144) ||
            (biHeight ==  72)) { // PAL
      if (m_iDisplay == IDC_DEC720x480)
         return 576;
      if (m_iDisplay == IDC_DEC360x240)
         return 288;
      if (m_iDisplay == IDC_DEC180x120)
         return 144;
      if (m_iDisplay == IDC_DEC88x60)
         return 72;
      return 0;
   }
   return 0;
}


DWORD InputReq(REFGUID subtype) {
   if ((subtype == MEDIASUBTYPE_dvsd) ||
       (subtype == MEDIASUBTYPE_dvc))
      return AM_DVDEC_DVSD;
   if (subtype == MEDIASUBTYPE_dvhd)
      return AM_DVDEC_DVHD;
   if (subtype == MEDIASUBTYPE_dvsl)
      return AM_DVDEC_DVSL;
   return 0;
}

DWORD OutputReq(REFGUID subtype) {
   if (subtype == MEDIASUBTYPE_UYVY)
      return AM_DVDEC_UYVY;
   if (subtype == MEDIASUBTYPE_YUY2)
      return AM_DVDEC_YUY2;
   if (subtype == MEDIASUBTYPE_RGB565)
      return AM_DVDEC_RGB565;
   else if (subtype == MEDIASUBTYPE_RGB555)
      return AM_DVDEC_RGB555;
   if (subtype == MEDIASUBTYPE_RGB24)
      return AM_DVDEC_RGB24;
   if (subtype == MEDIASUBTYPE_Y41P)
      return AM_DVDEC_Y41P;
   if (subtype == MEDIASUBTYPE_RGB8)
      return AM_DVDEC_RGB8;
   return 0;
}

DWORD ScaleReq(long biHeight, long biWidth) {
   if ((biHeight == 480) || (biHeight == 576)) {
      if (biWidth != 720)
         return 0;
      return AM_DVDEC_Full;
   }
   if ((biHeight == 240) || (biHeight == 288)) {
      if (biWidth != 360)
         return 0;
      return AM_DVDEC_Half;
   }
   if ((biHeight == 120) || (biHeight == 144)) {
      if (biWidth != 180)
         return 0;
      return AM_DVDEC_Quarter;
   }
   if ((biHeight == 60) || (biHeight == 72)) {
      if (biWidth != 88)
         return 0;
      return AM_DVDEC_DC;
   }
   return 0;
}

void GetHeightAndWidth(VIDEOINFO *videoInfo, long *pbiHeight, long *pbiWidth) {
   // if rcTarget is not empty, use its dimensions instead of biWidth and biHeight,
   // to see if it's an acceptable size.  Then use biWidth as the stride.

   RECT* prcDst = &(videoInfo->rcTarget);
   if (!IsRectEmpty(prcDst)) {
      *pbiHeight = abs(prcDst->bottom - prcDst->top);
      *pbiWidth = abs(prcDst->right - prcDst->left);
   }
   else {
      *pbiHeight = abs(videoInfo->bmiHeader.biHeight);
      *pbiWidth = videoInfo->bmiHeader.biWidth;
   }
}
///////////////////////////
// End mediatype helpers //
///////////////////////////

///////////////////////////////////
// Public mediatype entry points //
///////////////////////////////////
HRESULT CDVDec::GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
   return DMO_E_NO_MORE_ITEMS;
}

HRESULT CDVDec::GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
   DMO_MEDIA_TYPE* pmtIn = InputType();
   if (!pmtIn)
      return DMO_E_NO_MORE_ITEMS;

   pmt->majortype = MEDIATYPE_Video;
   pmt->formattype = FORMAT_VideoInfo;

   DWORD cbFormat;
   DWORD dwCompression;
   int nBitCount;

   //looking for format flag
   DWORD  dw = 1L << 5; //first output format flag is the 7th bit in m_CodecCap
   do {
      dw <<= 1;
      while (!(m_CodecCap & dw))//will not do unlimited loop since AM_DVDEC_DVSD has to be 1
         dw <<= 1;

      if (dw > AM_DVDEC_Y41P)
         return DMO_E_NO_MORE_ITEMS;

      if (ulTypeIndex == 0)
         break;

      ulTypeIndex--;
   } while (1);

   dw =  m_CodecCap & dw;
   switch (dw ) {
   case AM_DVDEC_YUY2:
      cbFormat = SIZE_VIDEOHEADER;
      dwCompression = MAKEFOURCC('Y','U','Y','2');
      nBitCount = 16;
      pmt->subtype = MEDIASUBTYPE_YUY2;
      break;
   case AM_DVDEC_UYVY:
      cbFormat = SIZE_VIDEOHEADER;
      dwCompression = MAKEFOURCC('U','Y','V','Y');
      nBitCount = 16;
      pmt->subtype = MEDIASUBTYPE_UYVY;
      break;
   case AM_DVDEC_RGB24:
      cbFormat = SIZE_VIDEOHEADER;
      dwCompression = BI_RGB;
      nBitCount = 24;
      pmt->subtype = MEDIASUBTYPE_RGB24;
      break;
   case AM_DVDEC_RGB565:
      cbFormat = SIZE_VIDEOHEADER + SIZE_MASKS;
      dwCompression = BI_BITFIELDS;
      nBitCount = 16;
      pmt->subtype = MEDIASUBTYPE_RGB565;
      break;
   case AM_DVDEC_RGB555:
      cbFormat = SIZE_VIDEOHEADER;
      dwCompression = BI_RGB;
      nBitCount = 16;
      pmt->subtype = MEDIASUBTYPE_RGB555;
      break;
   case AM_DVDEC_RGB8:
      cbFormat = SIZE_VIDEOHEADER+SIZE_PALETTE;
      dwCompression = BI_RGB;
      nBitCount = 8;
      pmt->subtype = MEDIASUBTYPE_RGB8;
      break;
   case AM_DVDEC_Y41P:
      cbFormat = SIZE_VIDEOHEADER;
      dwCompression = MAKEFOURCC('Y','4','1','P');
      nBitCount = 12;
      pmt->subtype = MEDIASUBTYPE_Y41P;
      break;
   default:
      return DMO_E_NO_MORE_ITEMS;
   }

   MoInitMediaType(pmt, cbFormat);

   // copy input format block
   // Dirty trick !  The original DV decoder does this, and it seems to work,
   // but I don't have enough knowledge about what goes on in the format block
   // to feel confident about this.
   memcpy(pmt->pbFormat, pmtIn->pbFormat, min(pmt->cbFormat, pmtIn->cbFormat));

   VIDEOINFO* pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
   InitDestinationVideoInfo(pVideoInfo, dwCompression, nBitCount);
   if (dw == AM_DVDEC_RGB565) {
      DWORD *pdw;
      pdw = (DWORD *)(HEADER(pVideoInfo) + 1);
      pdw[iRED]   = bits565[iRED];
      pdw[iGREEN] = bits565[iGREEN];
      pdw[iBLUE]  = bits565[iBLUE];
   }

   pmt->bTemporalCompression = FALSE;
   pmt->lSampleSize = HEADER(pVideoInfo)->biSizeImage;

   return S_OK;
}

HRESULT CDVDec::CheckInputType(const DMO_MEDIA_TYPE *pmt) {
   if (pmt->majortype != MEDIATYPE_Video)
      return DMO_E_TYPE_NOT_ACCEPTED;

   // check format block
   if (!(((pmt->formattype == FORMAT_VideoInfo) &&
          (pmt->cbFormat >= SIZE_VIDEOHEADER) &&
          (pmt->pbFormat != NULL)) ||
         ((pmt->formattype == FORMAT_DvInfo) &&
          (pmt->cbFormat >= SIZE_VIDEOHEADER) &&
          (pmt->pbFormat != NULL))))
      return DMO_E_TYPE_NOT_ACCEPTED;

   DWORD dwReq = InputReq(pmt->subtype);
   if (!(dwReq & m_CodecCap))
      return DMO_E_TYPE_NOT_ACCEPTED;

   if (!ActualHeight((HEADER((VIDEOINFO*)pmt->pbFormat))->biHeight))
      return DMO_E_TYPE_NOT_ACCEPTED;

   return NOERROR;
}

HRESULT CDVDec::CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
   // check major type
   if (pmt->majortype != MEDIATYPE_Video)
      return DMO_E_TYPE_NOT_ACCEPTED;

   // check format block
   if ((pmt->formattype != FORMAT_VideoInfo) ||
       (pmt->cbFormat < SIZE_VIDEOHEADER) ||
       (pmt->pbFormat == NULL))
      return DMO_E_TYPE_NOT_ACCEPTED;

   // check subtype
   DWORD dwTmp = OutputReq(pmt->subtype);
   if(!(m_CodecCap & dwTmp))
      return DMO_E_TYPE_NOT_ACCEPTED;


   VIDEOINFO* videoInfo = (VIDEOINFO *)pmt->pbFormat;
   RECT* prcSrc = &(videoInfo->rcSource);
   RECT* prcDst = &(videoInfo->rcTarget);

   //if rcSource is not empty, it must be the same as rcTarget, otherwise, FAIL
   if (!IsRectEmpty(prcSrc)) {
      if ((prcSrc->left   != prcDst->left) ||
          (prcSrc->top    != prcDst->top) ||
          (prcSrc->right  != prcDst->right) ||
          (prcSrc->bottom != prcDst->bottom))
             return DMO_E_TYPE_NOT_ACCEPTED;
   }
   // Also, make sure biWidth and biHeight are bigger than the rcTarget size.
   if (!IsRectEmpty(prcDst)) {
      if((abs(videoInfo->bmiHeader.biHeight) < abs(prcDst->bottom - prcDst->top)) ||
         (abs(videoInfo->bmiHeader.biWidth) < abs(prcDst->right - prcDst->left)))
          return DMO_E_TYPE_NOT_ACCEPTED;
   }

   long biHeight, biWidth;
   GetHeightAndWidth(videoInfo, &biHeight, &biWidth);

   //check down stream filter's require height and width
   dwTmp = ScaleReq(biHeight, biWidth);
   if (!(m_CodecCap & dwTmp))
      return DMO_E_TYPE_NOT_ACCEPTED;

   return NOERROR;
}
///////////////////////////////////////
// End public mediatype entry points //
///////////////////////////////////////

//
// Fills in common video and bitmap info header fields
// Stolen from the original DV decoder, which I hear in turn stole it from
// some other filter.  Needless to say, I do not thoroughly understand it.
//
void
CDVDec::InitDestinationVideoInfo(
    VIDEOINFO *pVideoInfo,
    DWORD dwComppression,
    int nBitCount
    )
{
    LPBITMAPINFOHEADER lpbi = HEADER(pVideoInfo);
    lpbi->biSize          = sizeof(BITMAPINFOHEADER);
    lpbi->biWidth         = m_lPicWidth;	
    lpbi->biHeight        = m_lPicHeight;
    lpbi->biPlanes        = 1;
    lpbi->biBitCount      = (WORD)nBitCount;
    lpbi->biXPelsPerMeter = 0;
    lpbi->biYPelsPerMeter = 0;
    lpbi->biCompression   = dwComppression;
    lpbi->biSizeImage     = DIBSIZE(*lpbi);
    //pVideoInfo->bmiHeader.biClrUsed = STDPALCOLOURS;
    //pVideoInfo->bmiHeader.biClrImportant = STDPALCOLOURS;
    if(nBitCount >8 ){
        lpbi->biClrUsed	    = 0;
    	lpbi->biClrImportant  = 0;
    }else if( nBitCount==8)
    {
	lpbi->biClrUsed = SIZE_PALETTE / sizeof(RGBQUAD);
	lpbi->biClrImportant = 0;

	RGBQUAD * prgb = (RGBQUAD *) (lpbi+1);

	// fixed PALETTE table	(0 <= i < 256)
	for(int i=0; i<256;i++)
	{
	    prgb[i].rgbRed	    = (i/64) << 6;
	    prgb[i].rgbGreen	    = ((i/4)%16) << 4;
	    prgb[i].rgbBlue	    = (i%4) << 6 ;
	    prgb[i].rgbReserved	    =0;
	}
    }
	
    pVideoInfo->rcSource.top = 0;
    pVideoInfo->rcSource.left = 0;
    pVideoInfo->rcSource.right = m_lPicWidth;			
    pVideoInfo->rcSource.bottom = m_lPicHeight;			
    if( m_lPicHeight== 576 || m_lPicHeight== 288 || m_lPicHeight== 144 || m_lPicHeight== 72 )
	pVideoInfo->AvgTimePerFrame = 10000000 / 25; //InVidInfo->AvgTimePerFrame;
    else
	pVideoInfo->AvgTimePerFrame = 10000000 / 30; //InVidInfo->AvgTimePerFrame;
    pVideoInfo->rcTarget = pVideoInfo->rcSource;

    //
    // The "bit" rate is image size in bytes times 8 (to convert to bits)
    // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
    // so we multiply by 10000000 to convert to bits per second, this multiply
    // is combined with "times" 8 above so the calculations becomes:
    //
    // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
    //
    LARGE_INTEGER li;
    li.QuadPart = pVideoInfo->AvgTimePerFrame;
    pVideoInfo->dwBitRate = MulDiv(lpbi->biSizeImage, 80000000, li.LowPart);
    pVideoInfo->dwBitErrorRate = 0L;
}
///////////////////////////////////////////////////////////////////////
//                                                                   //
//   E N D   M E D I A   T Y P E   N E G O T I A T I O N   C O D E   //
//                                                                   //
///////////////////////////////////////////////////////////////////////


HRESULT CDVDec::GetSampleSizes(ULONG* pulMaxInputSize, ULONG* pulMaxOutputSize) {
   DMO_MEDIA_TYPE *pmtIn  = InputType();
   DMO_MEDIA_TYPE *pmtOut = OutputType();
   if (!pmtIn || !pmtOut)
      return DMO_E_TYPE_NOT_SET;

   long lHeight = ActualHeight((HEADER((VIDEOINFO*)pmtIn->pbFormat))->biHeight);
   if (lHeight % 60 == 0)
      *pulMaxInputSize = 150*80*10; // NTSC
   else if (lHeight % 72 == 0)
      *pulMaxInputSize = 150*80*12; // PAL
   else
      return E_FAIL;

   *pulMaxOutputSize = pmtOut->lSampleSize;

   return NOERROR;
}

//
// Like with mediatype nogotiation, the logic here came straight from the
// original DV decoder.  I made minor code changes, but they should not
// affect the outcome.
//
HRESULT CDVDec::Init() {
   HRESULT hr;
   DMO_MEDIA_TYPE *pmtIn  = InputType();
   DMO_MEDIA_TYPE *pmtOut = OutputType();

   m_lPicHeight = ActualHeight((HEADER((VIDEOINFO*)pmtIn->pbFormat))->biHeight);

   m_CodecReq  = 0;

   m_CodecReq |= InputReq(pmtIn->subtype);
   m_CodecReq |= OutputReq(pmtOut->subtype);

   // size
   long biHeight, biWidth;
   VIDEOINFO* pvi = (VIDEOINFO*)pmtOut->pbFormat;
   GetHeightAndWidth(pvi, &biHeight, &biWidth);
   m_CodecReq |= ScaleReq(biHeight, biWidth);

   if (m_lPicHeight % 60 == 0)
      m_CodecReq |= AM_DVDEC_NTSC;
   else
      m_CodecReq |= AM_DVDEC_PAL;

   if (IsMMXCPU() && (m_CodecCap & AM_DVDEC_MMX))
      m_CodecReq |= AM_DVDEC_MMX;

   //m_lStride = ((pvi->bmiHeader.biWidth * pvi->bmiHeader.biBitCount) + 7) / 8;
   m_lStride = pvi->bmiHeader.biWidth ;
   m_lStride = (m_lStride + 3) & ~3;

#define ABSOL(x) (x < 0 ? -x : x)
   if ((pvi->bmiHeader.biHeight < 0) || (pvi->bmiHeader.biCompression > BI_BITFIELDS))
      m_lStride = ABSOL(m_lStride); //directDraw
   else
      m_lStride = -ABSOL(m_lStride); //DIB

   //memory for MEI's decoder
   if (m_pMem == NULL)
      m_pMem = new char[440000];
   if(m_pMem == NULL)
      return E_OUTOFMEMORY;

   return C1for1QCDMO::Init();
}

HRESULT CDVDec::QCProcess(BYTE* pIn, ULONG ulBytesIn, BYTE* pOut, ULONG* pulProduced) {
   *m_pMem = 0;
   HRESULT hr = DvDecodeAFrame(pIn ,pOut, m_CodecReq, m_lStride, m_pMem);
   if (hr != S_OK)
      return E_FAIL;
   *pulProduced = OutputType()->lSampleSize;
   return NOERROR;
}

//
// COM DLL stuff
//
struct CComClassTemplate g_ComClassTemplates[] = {
   {
      &CLSID_DVDecDMO,
      CDVDec::CreateInstance
   }
};

int g_cComClassTemplates = 1;

STDAPI DllRegisterServer(void) {
   HRESULT hr;

   // Register as a COM class
   hr = CreateCLSIDRegKey(CLSID_DVDecDMO, "DV decoder media object");
   if (FAILED(hr))
      return hr;

   // Now register as a DMO
   DMO_PARTIAL_MEDIATYPE mtIn[4];
   mtIn[0].type = MEDIATYPE_Video;
   mtIn[0].subtype = MEDIASUBTYPE_dvsd;
   mtIn[1].type = MEDIATYPE_Video;
   mtIn[1].subtype = MEDIASUBTYPE_dvhd;
   mtIn[2].type = MEDIATYPE_Video;
   mtIn[2].subtype = MEDIASUBTYPE_dvsl;
   mtIn[3].type = MEDIATYPE_Video;
   mtIn[3].subtype = MEDIASUBTYPE_dvc;
   DMO_PARTIAL_MEDIATYPE mtOut[6];
   mtOut[0].type = MEDIATYPE_Video;
   mtOut[0].subtype = MEDIASUBTYPE_UYVY;
   mtOut[1].type = MEDIATYPE_Video;
   mtOut[1].subtype = MEDIASUBTYPE_YUY2;
   mtOut[2].type = MEDIATYPE_Video;
   mtOut[2].subtype = MEDIASUBTYPE_RGB565;
   mtOut[3].type = MEDIATYPE_Video;
   mtOut[3].subtype = MEDIASUBTYPE_RGB555;
   mtOut[4].type = MEDIATYPE_Video;
   mtOut[4].subtype = MEDIASUBTYPE_RGB24;
   mtOut[5].type = MEDIATYPE_Video;
   mtOut[5].subtype = MEDIASUBTYPE_Y41P;
   return DMORegister(L"DV decoder", CLSID_DVDecDMO, DMOCATEGORY_VIDEO_DECODER, 0, 4, mtIn, 6, mtOut);
}

STDAPI DllUnregisterServer(void) {
   //  Delete our clsid key
   RemoveCLSIDRegKey(CLSID_DVDecDMO);
   return DMOUnregister(CLSID_DVDecDMO, GUID_NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\dmocom\dllentry.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// classes used to support dll entrypoints for COM objects.
//
int g_cActiveObjects = 0;

#include "dmocom.h"
#include "dmoreg.h"
#include "dmoutils.h"
#include <shlwapi.h>

#ifdef DEBUG
bool g_fDbgInDllEntryPoint = false;
#endif

extern CComClassTemplate g_ComClassTemplates[];
extern int g_cComClassTemplates;

HINSTANCE g_hInst;

//
// an instance of this is created by the DLLGetClassObject entrypoint
// it uses the CComClassTemplate object it is given to support the
// IClassFactory interface

class CClassFactory : public IClassFactory,
                      CBaseObject
{

private:
    const CComClassTemplate *const m_pTemplate;

    ULONG m_cRef;

    static int m_cLocked;
public:
    CClassFactory(const CComClassTemplate *);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)AddRef();
    STDMETHODIMP_(ULONG)Release();

    // IClassFactory
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void **pv);
    STDMETHODIMP LockServer(BOOL fLock);

    // allow DLLGetClassObject to know about global server lock status
    static BOOL IsLocked() {
        return (m_cLocked > 0);
    };
};

// process-wide dll locked state
int CClassFactory::m_cLocked = 0;

CClassFactory::CClassFactory(const CComClassTemplate *pTemplate)
: m_cRef(0)
, m_pTemplate(pTemplate)
{
}


STDMETHODIMP
CClassFactory::QueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER)
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    // any interface on this object is the object pointer.
    if ((riid == IID_IUnknown) || (riid == IID_IClassFactory)) {
        *ppv = (LPVOID) this;
	// AddRef returned interface pointer
        ((LPUNKNOWN) *ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG)
CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CClassFactory::Release()
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    } else {
        return m_cRef;
    }
}

STDMETHODIMP
CClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    void **pv)
{
    CheckPointer(pv,E_POINTER)
    ValidateReadWritePtr(pv,sizeof(void *));

    /* Enforce the normal OLE rules regarding interfaces and delegation */

    if (pUnkOuter != NULL) {
        if (IsEqualIID(riid,IID_IUnknown) == FALSE) {
            return ResultFromScode(E_NOINTERFACE);
        }
    }

    /* Create the new object through the derived class's create function */

    HRESULT hr = NOERROR;
    CComBase *pObj = m_pTemplate->m_lpfnNew(pUnkOuter, &hr);

    if (pObj == NULL) {
	if (SUCCEEDED(hr)) {
	    hr = E_OUTOFMEMORY;
	}
	return hr;
    }

    /* Delete the object if we got a construction error */

    if (FAILED(hr)) {
        delete pObj;
        return hr;
    }

    /* Get a reference counted interface on the object */

    /* We wrap the non-delegating QI with NDAddRef & NDRelease. */
    /* This protects any outer object from being prematurely    */
    /* released by an inner object that may have to be created  */
    /* in order to supply the requested interface.              */
    pObj->NDAddRef();
    hr = pObj->NDQueryInterface(riid, pv);
    pObj->NDRelease();
    /* Note that if NDQueryInterface fails, it will  */
    /* not increment the ref count, so the NDRelease */
    /* will drop the ref back to zero and the object will "self-*/
    /* destruct".  Hence we don't need additional tidy-up code  */
    /* to cope with NDQueryInterface failing.        */

    if (SUCCEEDED(hr)) {
        ASSERT(*pv);
    }

    return hr;
}

STDMETHODIMP
CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        m_cLocked++;
    } else {
        m_cLocked--;
    }
    return NOERROR;
}


// --- COM entrypoints -----------------------------------------

//called by COM to get the class factory object for a given class
STDAPI
DllGetClassObject(
    REFCLSID rClsID,
    REFIID riid,
    void **pv)
{
    if (!(riid == IID_IUnknown) && !(riid == IID_IClassFactory)) {
            return E_NOINTERFACE;
    }

    // traverse the array of templates looking for one with this
    // class id
    for (int i = 0; i < g_cComClassTemplates; i++) {
        const CComClassTemplate * pT = &g_ComClassTemplates[i];
        if (*(pT->m_ClsID) == rClsID) {

            // found a template - make a class factory based on this
            // template

            *pv = (LPVOID) (LPUNKNOWN) new CClassFactory(pT);
            if (*pv == NULL) {
                return E_OUTOFMEMORY;
            }
            ((LPUNKNOWN)*pv)->AddRef();
            return NOERROR;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}


// called by COM to determine if this dll can be unloaded
// return ok unless there are outstanding objects or a lock requested
// by IClassFactory::LockServer
//
// CClassFactory has a static function that can tell us about the locks,
// and CCOMObject has a static function that can tell us about the active
// object count
STDAPI
DllCanUnloadNow()
{
    if (CClassFactory::IsLocked() || g_cActiveObjects) {
	return S_FALSE;
    } else {
        return S_OK;
    }
}


// --- standard WIN32 entrypoints --------------------------------------


extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI
DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
#ifdef DEBUG
    extern bool g_fDbgInDllEntryPoint;
    g_fDbgInDllEntryPoint = true;
#endif

    switch (ulReason)
    {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        g_hInst = hInstance;
        //DllInitClasses(TRUE);
        break;

    case DLL_PROCESS_DETACH:
        //DllInitClasses(FALSE);
        break;
    }

#ifdef DEBUG
    g_fDbgInDllEntryPoint = false;
#endif
    return TRUE;
}

// Automatically calls RegCloseKey when leaving scope
class CAutoHKey {
public:
   CAutoHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey) {
      if (RegCreateKey(hKey, szSubKey, phKey) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};

//
// Creates the COM registration key with subkeys under HKCR\CLSID
//
STDAPI CreateCLSIDRegKey(REFCLSID clsid, const char *szName) {
   // Get dll name
   char szFileName[MAX_PATH];
   GetModuleFileNameA(g_hInst, szFileName, MAX_PATH);
   char szRegPath[80] = "CLSID\\{";
   HKEY hKey;
   DMOGuidToStrA(szRegPath + 7, clsid);
   strcat(szRegPath, "}");
   CAutoHKey k1(HKEY_CLASSES_ROOT,szRegPath,&hKey);
   if (!hKey)
      return E_FAIL;
   if (RegSetValueA(hKey, NULL, REG_SZ, szName, strlen(szName)) != ERROR_SUCCESS)
      return E_FAIL;

   HKEY hInprocServerKey;
   CAutoHKey k2(hKey,"InprocServer32",&hInprocServerKey);
   if (!hInprocServerKey)
      return E_FAIL;

   if (RegSetValueA(hInprocServerKey, NULL, REG_SZ, szFileName, strlen(szFileName)) != ERROR_SUCCESS)
      return E_FAIL;
   if (RegSetValueExA(hInprocServerKey, "ThreadingModel", 0, REG_SZ, (BYTE*)"Both", 4) != ERROR_SUCCESS)
      return E_FAIL;
   return NOERROR;
}


STDAPI RemoveCLSIDRegKey(REFCLSID clsid)
{
   char szRegPath[80] = "CLSID\\{";
   DMOGuidToStrA(szRegPath + 7, clsid);
   strcat(szRegPath, "}");

   //  Delete this key
   if (ERROR_SUCCESS == SHDeleteKey(HKEY_CLASSES_ROOT, szRegPath)) {
       return S_OK;
   } else {
       return E_FAIL;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\msdmo\dmoutils.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <stdio.h>
#include "dmoutils.h"

// convert guid to string
void DMOGuidToStrA(char *szStr, REFGUID guid) {
   sprintf(szStr, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
           guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],
           guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5],
           guid.Data4[6], guid.Data4[7]);
}
void DMOGuidToStrW(WCHAR *szStr, REFGUID guid) {
   swprintf(szStr, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
           guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],
           guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5],
           guid.Data4[6], guid.Data4[7]);
}

// convert string to guid
BOOL DMOStrToGuidA(char *szStr, GUID *pguid) {
   DWORD temp[8];
   if (sscanf(szStr, "%08x-%04hx-%04hx-%02x%02x-%02x%02x%02x%02x%02x%02x",
           &pguid->Data1, &pguid->Data2, &pguid->Data3,
           &temp[0], &temp[1], &temp[2], &temp[3],
           &temp[4], &temp[5], &temp[6], &temp[7]) == 11) {
      for (DWORD c = 0; c < 8; c++)
         pguid->Data4[c] = (unsigned char)temp[c];
      return TRUE;
   }
   else
      return FALSE;
}
BOOL DMOStrToGuidW(WCHAR *szStr, GUID *pguid) {
   char szSrc[80];
   WideCharToMultiByte(0,0,szStr,-1,szSrc,80,NULL,NULL);
   return DMOStrToGuidA(szSrc, pguid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\msdmo\dmoutils.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __DMOUTILS_H__
#define __DMOUTILS_H__

#include <wchar.h>

// convert guid to string
STDAPI_(void) DMOGuidToStrA(char *szStr, REFGUID guid);
STDAPI_(void) DMOGuidToStrW(WCHAR *szStr, REFGUID guid);

// convert string to guid
STDAPI_(BOOL) DMOStrToGuidA(char *szStr, GUID *pguid);
STDAPI_(BOOL) DMOStrToGuidW(WCHAR *szStr, GUID *pguid);

#ifdef UNICODE
#define DMOStrToGuid DMOStrToGuidW
#define DMOGuidToStr DMOGuidToStrW
#else
#define DMOStrToGuid DMOStrToGuidA
#define DMOGuidToStr DMOGuidToStrA
#endif

#endif __DMOUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\gargle\gargle.cpp ===
#include <windows.h>
#include <dmocom.h>
#define DMO_NOATL // DMO base class needs this to work w/o ATL
#include <dmobase.h>

#include "initguid.h"
DEFINE_GUID(CLSID_GargleDMO, 0xdafd8210,0x5711,0x4b91,0x9f,0xe3,0xf7,0x5b,0x7a,0xe2,0x79,0xbf);

class CGargle : public CComBase,
                public CPCMDMO
{
public:
   DECLARE_IUNKNOWN;
   STDMETHODIMP NDQueryInterface(REFIID riid, void **ppv);
   static CComBase* WINAPI CreateInstance(IUnknown *pUnk, HRESULT *phr);
   CGargle(IUnknown *pUnk, HRESULT *phr);
   
   // All of these methods are called by the base class
   HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
   HRESULT Init();
   HRESULT Discontinuity();
   void GetWindowParams(DWORD *pdwMaxLookahead,DWORD *pdwMaxLookbehind);
private:
   // gargle params
   ULONG m_ulPeriod;
   ULONG m_ulShape;
   ULONG m_ulGargleFreqHz;

   // gargle state
   ULONG m_ulPhase;

   BOOL m_bInitialized;
};

CGargle::CGargle(IUnknown *pUnk, HRESULT *phr)
  : CComBase(pUnk, phr),
    m_ulShape(0),
    m_ulGargleFreqHz(20),
    m_bInitialized(FALSE)
{
}

void CGargle::GetWindowParams(
   DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
   DWORD *pdwMaxLookbehind
) {
   *pdwMaxLookahead        = 0;
   *pdwMaxLookbehind       = 0;
}

HRESULT CGargle::Init() {
   // compute the period
   m_ulPeriod = m_ulSamplingRate / m_ulGargleFreqHz;
   
   m_bInitialized = TRUE;
   return NOERROR;
}

HRESULT CGargle::Discontinuity() {
   m_ulPhase = 0;
   return NOERROR;
}

HRESULT CGargle::FBRProcess(DWORD cSamples, BYTE *pIn, BYTE *pOut) {
   if (!m_bInitialized)
      return DMO_E_TYPE_NOT_SET;
   
   // test code
   //memcpy(pOut, pIn, cSamples * m_cChannels * (m_b8bit ? 1 : 2));
   //return NOERROR;

   DWORD cSample, cChannel;
   for (cSample = 0; cSample < cSamples; cSample++) {
      // If m_Shape is 0 (triangle) then we multiply by a triangular waveform
      // that runs 0..Period/2..0..Period/2..0... else by a square one that
      // is either 0 or Period/2 (same maximum as the triangle) or zero.
      //
      // m_Phase is the number of samples from the start of the period.
      // We keep this running from one call to the next,
      // but if the period changes so as to make this more
      // than Period then we reset to 0 with a bang.  This may cause
      // an audible click or pop (but, hey! it's only a sample!)
      //
      ++m_ulPhase;
      if (m_ulPhase > m_ulPeriod)
         m_ulPhase = 0;

      ULONG ulM = m_ulPhase;      // m is what we modulate with

      if (m_ulShape == 0) {   // Triangle
          if (ulM > m_ulPeriod / 2)
              ulM = m_ulPeriod - ulM;  // handle downslope
      } else {             // Square wave
          if (ulM <= m_ulPeriod / 2)
             ulM = m_ulPeriod / 2;
          else
             ulM = 0;
      }

      for (cChannel = 0; cChannel < m_cChannels; cChannel++) {
         if (m_b8bit) {
             // sound sample, zero based
             int i = pIn[cSample * m_cChannels + cChannel] - 128;
             // modulate
             i = (i * (signed)ulM * 2) / (signed)m_ulPeriod;
             // 8 bit sound uses 0..255 representing -128..127
             // Any overflow, even by 1, would sound very bad.
             // so we clip paranoically after modulating.
             // I think it should never clip by more than 1
             //
             if (i > 127)
                i = 127;
             if (i < -128)
                i = -128;
             // reset zero offset to 128
             pOut[cSample * m_cChannels + cChannel] = (unsigned char)(i + 128);
   
         } else {
             // 16 bit sound uses 16 bits properly (0 means 0)
             // We still clip paranoically
             //
             int i = ((short*)pIn)[cSample * m_cChannels + cChannel];
             // modulate
             i = (i * (signed)ulM * 2) / (signed)m_ulPeriod;
             // clip
             if (i > 32767)
                i = 32767;
             if (i < -32768)
                i = -32768;
             ((short*)pOut)[cSample * m_cChannels + cChannel] = (short)i;
         }
      }
   }
   return NOERROR;
}

//
// COM stuff
//
CComBase* WINAPI CGargle::CreateInstance(IUnknown *pUnk, HRESULT *phr) {
   return new CGargle(pUnk, phr);
}

HRESULT CGargle::NDQueryInterface(REFIID riid, void **ppv) {
   if (riid == IID_IMediaObject)
      return GetInterface((IMediaObject*)this, ppv);
   else
      return CComBase::NDQueryInterface(riid, ppv);
}

struct CComClassTemplate g_ComClassTemplates[] = {
   {
      &CLSID_GargleDMO,
      CGargle::CreateInstance
   }
};

int g_cComClassTemplates = 1;

STDAPI DllRegisterServer(void) {
   HRESULT hr;
   
   // Register as a COM class
   hr = CreateCLSIDRegKey(CLSID_GargleDMO, "Gargle media object");
   if (FAILED(hr))
      return hr;
   
   // Now register as a DMO
   DMO_PARTIAL_MEDIATYPE mt;
   mt.type = MEDIATYPE_Audio;
   mt.subtype = MEDIASUBTYPE_PCM;
   return DMORegister(L"gargle", CLSID_GargleDMO, DMOCATEGORY_AUDIO_EFFECT, 0, 1, &mt, 1, &mt);
}

STDAPI DllUnregisterServer(void) {
   // BUGBUG - implement !
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\msdmo\dmort.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// dmort.cpp - DMO runtime misc.
//
#include <windows.h>
#include "mediaobj.h"
#include "dmort.h"

//
// Mediatype stuff
//
STDAPI MoInitMediaType(DMO_MEDIA_TYPE *pmt, ULONG cbFormat) {
   if (!pmt)
      return E_POINTER;
   pmt->pUnk = NULL;
   if (cbFormat) {
      pmt->pbFormat = (PBYTE)CoTaskMemAlloc(cbFormat);
      if (!pmt->pbFormat)
         return E_OUTOFMEMORY;
   }
   else
      pmt->pbFormat = NULL;
   pmt->cbFormat = cbFormat;
   return NOERROR;
}

STDAPI MoFreeMediaType(DMO_MEDIA_TYPE *pmt) {
   if (!pmt)
      return E_POINTER;
   if (pmt->pUnk) {
      pmt->pUnk->Release();
      pmt->pUnk = NULL;
   }
   if (pmt->pbFormat) {
      CoTaskMemFree(pmt->pbFormat);
      pmt->pbFormat = NULL;
   }
   return NOERROR;
}

// everything has been allocated - just copy
void CopyMediaTypeInternal(DMO_MEDIA_TYPE *pmtDest, DMO_MEDIA_TYPE const *pmtSrc) {
   if (pmtDest->cbFormat)
      memcpy(pmtDest->pbFormat, pmtSrc->pbFormat, pmtDest->cbFormat);

   if (pmtSrc->pUnk) {
      pmtSrc->pUnk->AddRef();
      pmtDest->pUnk = pmtSrc->pUnk;
   }
   
   pmtDest->majortype = pmtSrc->majortype;
   pmtDest->subtype = pmtSrc->subtype;
   pmtDest->bFixedSizeSamples = pmtSrc->bFixedSizeSamples;
   pmtDest->bTemporalCompression = pmtSrc->bTemporalCompression;
   pmtDest->lSampleSize = pmtSrc->lSampleSize;
   pmtDest->formattype = pmtSrc->formattype;
}

STDAPI MoCopyMediaType(DMO_MEDIA_TYPE *pmtDest, DMO_MEDIA_TYPE const *pmtSrc) {
   if ((!pmtDest) || (!pmtSrc))
      return E_POINTER;

   ULONG cbFormat = pmtSrc->pbFormat ? pmtSrc->cbFormat : 0;

   HRESULT hr = MoInitMediaType(pmtDest, cbFormat);
   if (FAILED(hr))
      return hr;
   
   CopyMediaTypeInternal(pmtDest, pmtSrc);

   return NOERROR;
}

STDAPI MoCreateMediaType(DMO_MEDIA_TYPE **ppmt, ULONG cbFormat) {
   if (!ppmt)
      return E_POINTER;
   *ppmt = (DMO_MEDIA_TYPE*) CoTaskMemAlloc(sizeof(DMO_MEDIA_TYPE));
   if (!*ppmt)
      return E_OUTOFMEMORY;
   HRESULT hr = MoInitMediaType(*ppmt, cbFormat);
   if (FAILED(hr)) {
      CoTaskMemFree(*ppmt);
      *ppmt = NULL;
   }
   return hr;
}

STDAPI MoDeleteMediaType(DMO_MEDIA_TYPE *pmt) {
   if (!pmt)
      return E_POINTER;
   HRESULT hr = MoFreeMediaType(pmt);
   CoTaskMemFree(pmt);
   return hr;
}

STDAPI MoDuplicateMediaType(DMO_MEDIA_TYPE **ppmtDest, DMO_MEDIA_TYPE const *pmtSrc) {
   if (!ppmtDest || !pmtSrc)
      return E_POINTER;

   ULONG cbFormat = pmtSrc->pbFormat ? pmtSrc->cbFormat : 0;

   HRESULT hr = MoCreateMediaType(ppmtDest, cbFormat);
   if (FAILED(hr))
      return hr;

   CopyMediaTypeInternal(*ppmtDest, pmtSrc);

   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\dvdec\decode.h ===
// flags for lFlags in codec capability
#define AM_DVDEC_Full		0x00000001
#define AM_DVDEC_Half		0x00000002
#define AM_DVDEC_Quarter	0x00000004
#define AM_DVDEC_DC	        0x00000008

#define AM_DVDEC_NTSC		0x00000010
#define AM_DVDEC_PAL		0x00000020

#define AM_DVDEC_YUY2		0x00000040
#define AM_DVDEC_UYVY		0x00000080
#define AM_DVDEC_RGB24		0x00000100
#define AM_DVDEC_RGB565		0x00000200
#define AM_DVDEC_RGB555		0x00000400
#define AM_DVDEC_RGB8		0x00000800
#define AM_DVDEC_Y41P		0x00001000


#define AM_DVDEC_DVSD		0x00002000
#define AM_DVDEC_DVHD		0x00004000
#define AM_DVDEC_DVSL		0x00008000

#define AM_DVDEC_DV		0x00010000
#define AM_DVDEC_DVCPRO		0x00020000

#define AM_DVDEC_MMX		0x01000000
		
typedef unsigned long DWORD;



//extern "C" int	__fastcall DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );

extern "C" int __stdcall    DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, long lwidth, char *pMem);
//extern "C" int	__stdcall   DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem,
//					 unsigned int iWidth, unsigned char bFlag);
//extern "C" int	__cdecl DvDecodeAFrame(unsigned char *pSrc,unsigned char *pDst, DWORD dwCodecReq, char *pMem );


int  InitMem4Decoder(char **ppMem,DWORD dwCodecReq);
void TermMem4Decoder(char *pMem);

DWORD GetCodecCapabilities(  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\inc\dmocom.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

/*

a. Derive your COM object from CComBase

b. Make a static CreateInstance function that takes an IUnknown* and an
   HRESULT*. The IUnknown* defines the object to delegate IUnknown calls
   to. The HRESULT * allows error codes to be passed around constructors.

   It is important that constructors only change the HRESULT * if they have
   to set an ERROR code, if it was successful then leave it alone or you may
   overwrite an error code from an object previously created.

c. Have a constructor for your object that passes the IUnknown* and HRESULT*
   to the CComBase constructor. You can set the HRESULT if you have an error,
   or just simply pass it through to the constructor.

   The object creation will fail in the class factory if the HRESULT indicates
   an error (ie FAILED(HRESULT) == TRUE)

d. Create a CComClassTemplate with your object's class id and CreateInstance
   function.

Then (for each interface) either

Multiple inheritance

1. Also derive it from ISomeInterface
2. Include DECLARE_IUNKNOWN in your class definition to declare
   implementations of QueryInterface, AddRef and Release that
   call the outer unknown
3. Override NDQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

4. Declare and implement the member functions of ISomeInterface.

or: Nested interfaces

1. Declare a class derived from CComBase
2. Include DECLARE_IUNKNOWN in your class definition
3. Override NDQueryInterface to expose ISomeInterface by
   code something like

     if (riid == IID_ISomeInterface) {
         return GetInterface((ISomeInterface *) this, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

4. Implement the member functions of ISomeInterface. Use \() to
   access the COM object class.

And in your COM object class:

5. Make the nested class a friend of the COM object class, and declare
   an instance of the nested class as a member of the COM object class.

   NOTE that because you must always pass the outer unknown and an hResult
   to the CComBase constructor you cannot use a default constructor, in
   other words you will have to make the member variable a pointer to the
   class and make a NEW call in your constructor to actually create it.

6. override the NDQueryInterface with code like this:

     if (riid == IID_ISomeInterface) {
         return m_pImplFilter->
            NDQueryInterface(IID_ISomeInterface, ppv);
     } else {
         return CComBase::NDQueryInterface(riid, ppv);
     }

You can have mixed classes which support some interfaces via multiple
inheritance and some via nested classes

*/

#ifndef __COMBASE__
#define __COMBASE__

#include <windows.h>
#include <basetyps.h>
#include <unknwn.h>

extern int g_cActiveObjects;

STDAPI CreateCLSIDRegKey(REFCLSID clsid, const char *szName);

STDAPI RemoveCLSIDRegKey(REFCLSID clsid);

#ifdef DEBUG
    // We chose a common name for our ASSERT macro, MFC also uses this name
    // So long as the implementation evaluates the condition and handles it
    // then we will be ok. Rather than override the behaviour expected we
    // will leave whatever first defines ASSERT as the handler (i.e. MFC)
    #ifndef ASSERT
        #define ASSERT(_x_) if (!(_x_))         \
            DbgAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)
    #endif
    #define EXECUTE_ASSERT(_x_) ASSERT(_x_)

    #define ValidateReadPtr(p,cb) \
        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid read pointer");}

    #define ValidateWritePtr(p,cb) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid write pointer");}

    #define ValidateReadWritePtr(p,cb) \
        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)}
#else
    #ifndef ASSERT
       #define ASSERT(_x_) ((void)0)
    #endif
    #define EXECUTE_ASSERT(_x_) ((void)(_x_))

    #define ValidateReadPtr(p,cb) 0
    #define ValidateWritePtr(p,cb) 0
    #define ValidateReadWritePtr(p,cb) 0
#endif

/* The DLLENTRY module initialises the module handle on loading */

extern HINSTANCE g_hInst;

/* On DLL load remember which platform we are running on */

/* Version of IUnknown that is renamed to allow a class to support both
   non delegating and delegating IUnknowns in the same COM object */

#ifndef INDUNKNOWN_DEFINED
DECLARE_INTERFACE(INDUnknown)
{
    STDMETHOD(NDQueryInterface) (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG, NDAddRef)(THIS) PURE;
    STDMETHOD_(ULONG, NDRelease)(THIS) PURE;
};
#define INDUNKNOWN_DEFINED
#endif

class CBaseObject {
public:
   CBaseObject() {g_cActiveObjects++;}
   ~CBaseObject() {g_cActiveObjects--;}
};

/* An object that supports one or more COM interfaces will be based on
   this class. It supports counting of total objects for DLLCanUnloadNow
   support, and an implementation of the core non delegating IUnknown */

class CComBase : public INDUnknown,
                 CBaseObject
{
private:
    IUnknown* m_pUnknown; /* Owner of this object */

protected:                      /* So we can override NDRelease() */
    volatile LONG m_cRef;       /* Number of reference counts */

public:

    CComBase(IUnknown* pUnk);
    virtual ~CComBase() {};

    // This is redundant, just use the other constructor
    //   as we never touch the HRESULT in this anyway
    CComBase(IUnknown* pUnk,HRESULT *phr);

    /* Return the owner of this object */

    IUnknown* GetOwner() const {
        return m_pUnknown;
    };

    /* Called from the class factory to create a new instance, it is
       pure virtual so it must be overriden in your derived class */

    /* static CComBase *CreateInstance(IUnknown*, HRESULT *) */

    /* Non delegating unknown implementation */

    STDMETHODIMP NDQueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) NDAddRef();
    STDMETHODIMP_(ULONG) NDRelease();
};

/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(IUnknown* pUnk, void **ppv);

/* A function that can create a new COM object */

typedef CComBase *(CALLBACK *LPFNNewCOMObject)(IUnknown* pUnkOuter, HRESULT *phr);

/*  A function (can be NULL) which is called from the DLL entrypoint
    routine for each factory template:

    bLoading - TRUE on DLL load, FALSE on DLL unload
    rclsid   - the m_ClsID of the entry
*/
typedef void (CALLBACK *LPFNInitRoutine)(BOOL bLoading, const CLSID *rclsid);

#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}

/* Create one of these per object class in an array so that
   the default class factory code can create new instances */

struct CComClassTemplate {
    const CLSID *              m_ClsID;
    LPFNNewCOMObject           m_lpfnNew;
};


/* You must override the (pure virtual) NDQueryInterface to return
   interface pointers (using GetInterface) to the interfaces your derived
   class supports (the default implementation only supports IUnknown) */

#define DECLARE_IUNKNOWN                                        \
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \
        return GetOwner()->QueryInterface(riid,ppv);            \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef() {                             \
        return GetOwner()->AddRef();                            \
    };                                                          \
    STDMETHODIMP_(ULONG) Release() {                            \
        return GetOwner()->Release();                           \
    };



HINSTANCE	LoadOLEAut32();


#endif /* __COMBASE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\dmocom\dmocom.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Base class hierachy for creating COM objects, December 1994

#include "dmocom.h"


#pragma warning( disable : 4514 )   // Disable warnings re unused inline functions



/* Constructor */

// We know we use "this" in the initialization list, we also know we don't modify *phr.
#pragma warning( disable : 4355 4100 )
CComBase::CComBase(IUnknown* pUnk)
: 
/* Start the object with a reference count of zero - when the      */
/* object is queried for it's first interface this may be          */
/* incremented depending on whether or not this object is          */
/* currently being aggregated upon                                 */
  m_cRef(0)
/* Set our pointer to our IUnknown interface.                      */
/* If we have an outer, use its, otherwise use ours.               */
/* This pointer effectivly points to the owner of                  */
/* this object and can be accessed by the GetOwner() method.       */
, m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<IUnknown*>( static_cast<INDUnknown*>(this) ) )
 /* Why the double cast?  Well, the inner cast is a type-safe cast */
 /* to pointer to a type from which we inherit.  The second is     */
 /* type-unsafe but works because INDUnknown "behaves   */
 /* like" IUnknown. (Only the names on the methods change.)        */
{
    // Everything we need to do has been done in the initializer list
}

// This does the same as above except it has a useless HRESULT argument
// use the previous constructor, this is just left for compatibility...
CComBase::CComBase(IUnknown* pUnk,HRESULT *phr) :
    m_cRef(0),
    m_pUnknown( pUnk != 0 ? pUnk : reinterpret_cast<IUnknown*>( static_cast<INDUnknown*>(this) ) )
{
}

#pragma warning( default : 4355 4100 )

/* QueryInterface */

STDMETHODIMP CComBase::NDQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* We know only about IUnknown */

    if (riid == IID_IUnknown) {
        GetInterface((IUnknown*) (INDUnknown*) this, ppv);
        return NOERROR;
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

/* We have to ensure that we DON'T use a max macro, since these will typically   */
/* lead to one of the parameters being evaluated twice.  Since we are worried    */
/* about concurrency, we can't afford to access the m_cRef twice since we can't  */
/* afford to run the risk that its value having changed between accesses.        */
#ifdef max
    #undef max
#endif

template<class T> inline static T max( const T & a, const T & b )
{
    return a > b ? a : b;
}

/* AddRef */

STDMETHODIMP_(ULONG) CComBase::NDAddRef()
{
    LONG lRef = InterlockedIncrement( &m_cRef );
    ASSERT(lRef > 0);
/*
    DbgLog((LOG_MEMORY,3,TEXT("    Obj %d ref++ = %d"),
           m_dwCookie, m_cRef));
*/
    return max(ULONG(m_cRef), 1ul);
}


/* Release */

STDMETHODIMP_(ULONG) CComBase::NDRelease()
{
    /* If the reference count drops to zero delete ourselves */

    LONG lRef = InterlockedDecrement( &m_cRef );
    ASSERT(lRef >= 0);

/*
    DbgLog((LOG_MEMORY,3,TEXT("    Object %d ref-- = %d"),
	    m_dwCookie, m_cRef));
*/
    if (lRef == 0) {

        // COM rules say we must protect against re-entrancy.
        // If we are an aggregator and we hold our own interfaces
        // on the aggregatee, the QI for these interfaces will
        // addref ourselves. So after doing the QI we must release
        // a ref count on ourselves. Then, before releasing the
        // private interface, we must addref ourselves. When we do
        // this from the destructor here it will result in the ref
        // count going to 1 and then back to 0 causing us to
        // re-enter the destructor. Hence we add an extra refcount here
        // once we know we will delete the object.
        // for an example aggregator see filgraph\distrib.cpp.

        m_cRef++;

        delete this;
        return ULONG(0);
    } else {
        return max(ULONG(m_cRef), 1ul);
    }
}


/* Return an interface pointer to a requesting client
   performing a thread safe AddRef as necessary */

STDAPI GetInterface(IUnknown* pUnk, void **ppv)
{
    CheckPointer(ppv, E_POINTER);
    *ppv = pUnk;
    pUnk->AddRef();
    return NOERROR;
}


/* Compares two interfaces and returns TRUE if they are on the same object */

BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    IUnknown* pUnknown1;     // Retrieve the IUnknown interface
    IUnknown* pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    ASSERT(pFirst);
    ASSERT(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\msdmo\guidenum.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __GUIDENUM_H__
#define __GUIDENUM_H__

#include "mediaobj.h"

template<typename T> class CArrayContainer {
public:
   CArrayContainer(ULONG ulSize = 0) {
      if (ulSize) {
         m_ulMax = ulSize;
         m_ulUsed = 0;
         m_ar = (T*)malloc(ulSize * sizeof(T));
      }
      else
         m_ar = NULL;
   }

   ~CArrayContainer() {if (m_ar) free(m_ar);}

   HRESULT Add(const T& el) {
      if (!m_ar) {
         m_ulMax = 20;
         m_ulUsed = 0;
         m_ar = (T*)malloc(m_ulMax * sizeof(T));
         if (!m_ar)
            return E_OUTOFMEMORY;
      }
      else if (m_ulUsed == m_ulMax) {
         ULONG ulNew = m_ulMax + 20;
         T* pNew = (T*)realloc(m_ar, ulNew * sizeof(T));
         if (!pNew)
            return E_OUTOFMEMORY;
         m_ulMax = ulNew;
         m_ar = pNew;
      }
      m_ar[m_ulUsed++] = el;
      return NOERROR;
   }

   T* GetNth(ULONG ulPos) {
      if (ulPos >= m_ulUsed)
         return NULL;
      return &m_ar[ulPos];
   }

   ULONG GetSize(void) {
      return m_ulUsed;
   }

private:
   T* m_ar;
   ULONG m_ulMax;
   ULONG m_ulUsed;
};

// implements IEnumDMO, which is returned by DMO enumeration API
class CEnumDMOCLSID : public IEnumDMO {
public:
   CEnumDMOCLSID();
   ~CEnumDMOCLSID();

   // IUnknown
   STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
   STDMETHODIMP_(ULONG) AddRef();
   STDMETHODIMP_(ULONG) Release();

   // enum
   STDMETHODIMP Next(ULONG celt, CLSID *pclsidItems, WCHAR **pszNames, ULONG *pceltFetched);
   STDMETHODIMP Skip(ULONG celt);
   STDMETHODIMP Reset(void);
   STDMETHODIMP Clone(IEnumDMO **ppenum);

   // private
   void Add(REFCLSID clsidDMO, WCHAR *szName);
private:
   typedef struct {
       CLSID clsid;
       WCHAR *szName;
   } Entry;
   volatile long m_cRef;
   CArrayContainer<Entry> m_store;
   ULONG m_ulPos;
};

#endif //__GUIDENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\wrapper\filter.h ===
#ifndef __FILTER_H__
#define __FILTER_H__

#include <wchar.h>
#include "mediaobj.h"
#include "dmodshow.h"
#include "mediabuf.h"
//  Filter to wrap filter Media objects
//
//  Need to have topology defined by Media objects

//  TODO:
//     Add persistence stuff for clsid of object wrapped
//        and persist its own stuff too.
//

//
// This code uses DbgLog as follows:
//   LOG_CUSTOM1 logs streaming state changes
//   LOG_CUSTOM2 logs recurring streaming/processing events
//   LOG_CUSTOM3 logs connection events
//   LOG_CUSTOM4 logs initialization events
//   LOG_CUSTOM5 logs function entries (level 3: public, level 4: private)
//
// Log levels are used as follows:
//   0 - critical errors
//   1 - non-critical errors
//   2 - unusual non-erratic events
//   3 - function entries
//   4 - detailed step-by-step logging
//   5 - extremely detailed logging
//
#define LOG_STATE           LOG_CUSTOM1
#define LOG_STREAM          LOG_CUSTOM2
#define LOG_CONNECT         LOG_CUSTOM3
#define LOG_INIT            LOG_CUSTOM4
#define LOG_ENTRY           LOG_CUSTOM5
#define LOG_SECURECHANNEL   LOG_CUSTOM2

//
// Define a DbgLog wrapper macro to automatically do the following on error:
//  - add LOG_ERROR to the log category mask
//  - lower the level to 1
// If hr does not indicate an error, the supplied category/level is used as is.
//
#define LogHResult(hr,LOG_CATEGORY,caller,callee) \
   DbgLog((LOG_CATEGORY | (FAILED(hr) ? LOG_ERROR : 0), \
           FAILED(hr) ? 1 : 4, \
           "%s%s(): %s() returned 0x%08X", \
           FAILED(hr) ? "!!! ERROR: " : "", \
           caller, \
           callee, \
           hr))

// Define a DbgLog wrapper macro to aotomatically add LOG_CUSTOM5 to all function entry logs
#define LogPublicEntry(LOG_CATEGORY,name) \
   DbgLog((LOG_CATEGORY | LOG_ENTRY, \
           3, \
           "Entering %s()", name))
#define LogPrivateEntry(LOG_CATEGORY,name) \
   DbgLog((LOG_CATEGORY | LOG_ENTRY, \
           4, \
           "Entering %s()", name))


//
// Used for output IMediaBuffers.  Reusable - final Release does not delete.
// AddRef()/Release() calls are ignored because DMOs are not supposed to use
// those on an output buffer.
//
class CStaticMediaBuffer : public CBaseMediaBuffer {
public:
//   CStaticMediaBuffer() {m_pData = NULL;}
   STDMETHODIMP_(ULONG) AddRef() {return 2;}
   STDMETHODIMP_(ULONG) Release() {return 1;}
   void Init(BYTE *pData, ULONG ulSize) {
      m_pData = pData;
      m_ulSize = ulSize;
      m_ulData = 0;
   }
};

extern const AMOVIESETUP_FILTER sudMediaWrap;

class CWrapperInputPin;
class CWrapperOutputPin;
class CStaticMediaBuffer;

class CMediaWrapperFilter : public CBaseFilter,
                            public IDMOWrapperFilter,
                            public IPersistStream

{
    friend class CWrapperInputPin;
    friend class CWrapperOutputPin;
public:
    DECLARE_IUNKNOWN

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnkOuter, HRESULT *phr);

    CMediaWrapperFilter(LPUNKNOWN pUnkOwner,
                        HRESULT *phr);


    ~CMediaWrapperFilter();

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME rtStart);
    STDMETHODIMP GetState(DWORD dwMilliseconds, FILTER_STATE *pfs);

    STDMETHODIMP Init(REFCLSID clsidDMO, REFCLSID guidCat);

    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    STDMETHODIMP NonDelegatingQueryInterface(REFGUID riid, void **ppv);

    CCritSec *FilterLock()
    {
        return &m_csFilter;
    }

    CBasePin *GetPin(int iPin);
    int GetPinCount();

    //  Refresh what pins we have
    HRESULT RefreshPinList();

    //  Remove pins
    void DeletePins();

    //  New input sample from a pin - called with pin streaming lock held.
    HRESULT NewSample(ULONG ulIndex, IMediaSample *pSample);

    //  EndOfStream - called with pin streaming lock held.
    HRESULT EndOfStream(ULONG ulIndex);

    //  Check Media Type
    HRESULT InputCheckMediaType(ULONG ulIndex, const AM_MEDIA_TYPE *pmt);
    HRESULT OutputCheckMediaType(ULONG ulIndex, const AM_MEDIA_TYPE *pmt);

    //  Get Media Type
    HRESULT InputGetMediaType(ULONG ulIndex, ULONG ulTypeIndex, AM_MEDIA_TYPE *pmt);
    HRESULT OutputGetMediaType(ULONG ulIndex, ULONG ulTypeIndex, AM_MEDIA_TYPE *pmt);

    //  Set the media type - our pin classes pointlessly duplicate
    //  the media type stored by the object here
    HRESULT InputSetMediaType(ULONG ulIndex, const CMediaType *pmt);
    HRESULT OutputSetMediaType(ULONG ulIndex, const AM_MEDIA_TYPE *pmt);

    //  Allocator stuff
    HRESULT InputGetAllocatorRequirements(ULONG ulInputIndex,
                                          ALLOCATOR_PROPERTIES *pProps);
    HRESULT OutputDecideBufferSize(ULONG ulIndex, IMemAllocator *pAlloc,
                                   ALLOCATOR_PROPERTIES *ppropRequest);

    //  QueryInternalConnections stuff
    bool InputMapsToOutput(ULONG ulInputIndex, ULONG ulOutputIndex);

    HRESULT BeginFlush(ULONG ulInputIndex);
    HRESULT EndFlush(ULONG ulInputIndex);

    // NewSegment
    HRESULT InputNewSegment(ULONG ulInputIndex, REFERENCE_TIME tStart,
                            REFERENCE_TIME tStop, double dRate);

    // IPersistStream
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP GetClassID(CLSID *clsid);

protected:
    //
    // Per stream stuff
    //
    CWrapperInputPin**                m_pInputPins;
    CWrapperOutputPin**               m_pOutputPins;

    DMO_OUTPUT_DATA_BUFFER*           m_OutputBufferStructs;

    HRESULT AllocatePerStreamStuff (ULONG cInputs, ULONG cOutputs);
    void FreePerStreamStuff ();
    CWrapperInputPin* GetInputPinForPassThru();
    HRESULT QualityNotify(ULONG ulOutputIndex, Quality q);

    //  The Media object
    IMediaObject*  m_pMediaObject;
    IUnknown*      m_pDMOUnknown;
    IDMOQualityControl* m_pDMOQualityControl;
    IDMOVideoOutputOptimizations* m_pDMOOutputOptimizations;
    ULONG m_cInputPins;
    ULONG m_cOutputPins;

    // app certificate for secure dmo unlocking
    IUnknown*     m_pCertUnknown;
    IWMSecureChannel* m_pWrapperSecureChannel;

    //  Filter lock
    CCritSec                   m_csFilter;

    //  Streaming lock
    CCritSec                   m_csStreaming;

    //  Stop event
    CAMEvent                   m_evStop;

    BOOL                       m_fErrorSignaled;

    HRESULT DeliverInputSample(ULONG ulInputIndex, IMediaSample *pSample);

    typedef enum { KeepOutput, NullBuffer, DiscardOutput } DiscardType;
    HRESULT SuckOutOutput(DiscardType bDiscard = KeepOutput);

    HRESULT EnqueueInputSample(ULONG ulInputStreamIndex, IMediaSample *pSample);
    IMediaSample* DequeueInputSample(ULONG ulInputStreamIndex);
    bool CMediaWrapperFilter::InputQueueEmpty(ULONG ulInputStreamIndex);

    void FreeOutputSamples();

    void PropagateAnyEOS();

    HRESULT SetupSecureChannel();

    BOOL m_fNoUpstreamQualityControl;
    IQualityControl* m_pUpstreamQualityControl;
    CCritSec m_csLastOutputSampleTimes;
    CCritSec m_csQualityPassThru;

    CLSID m_clsidDMO;
    CLSID m_guidCat;
};

//  Hack to make a string
class _PinName_
{
public:
    _PinName_(WCHAR *szPrefix, int iName)
    {
        swprintf(sz, L"%s%d", szPrefix, iName);
    }
    WCHAR sz[20];
    LPCWSTR Name()
    {
        return sz;
    }
};


typedef CBasePin *PBASEPIN;

//  Translate error codes to dshow codes
HRESULT TranslateDMOError(HRESULT hr);

#endif //__FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\wrapper\inpin.h ===
#ifndef __INPIN_H__
#define __INPIN_H__

class CWrapperInputPin : public CBaseInputPin
{
   friend class CMediaWrapperFilter; // stuff at the bottom is owned by the filter

public:
    CWrapperInputPin(CMediaWrapperFilter *pFilter,
                          ULONG Id,
                          HRESULT *phr);
    ~CWrapperInputPin();
    STDMETHODIMP EndOfStream();
    STDMETHODIMP Receive(IMediaSample *pSample);

    //  Override GetAllocator and Notify Allocator to allow
    //  for media object streams that hold on to buffer
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);


    //  Override to unset media type
    HRESULT BreakConnect();

    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    //  Synclock for stop
    void SyncLock();

    BOOL HoldsOnToBuffers();

protected:
    HRESULT MP3AndWMABufferSizeWorkAround(IMemAllocator* pProposedAllocator);
    HRESULT SetBufferSize(IMemAllocator* pAllocator, DWORD dwMinBufferSize);

    CMediaWrapperFilter *Filter() const
    {
        return static_cast<CMediaWrapperFilter *>(m_pFilter);
    }

    ULONG      m_Id;
    _PinName_  *m_pNameObject;
    CCritSec m_csStream;

    // This stuff is owned by the filter and is declared here for allocation convenience
    bool m_fEOS; // have received EOS during this streaming session
};

//  Special allocator class.  This class allocators extra internal
//  buffers to satisfy the lookahead scheme that are not reported
//  in GetProperties.  Thus the upstream pin's requirements are satisfied
//  in addition to our own.
class CSpecialAllocator : public CMemAllocator
{
    DWORD m_dwLookahead;
public:
    CSpecialAllocator(DWORD dwLookahead, HRESULT *phr) :
        CMemAllocator(NAME("CSpecialAllocator"), NULL, phr),
        m_dwLookahead(dwLookahead)
    {
    }

    //  Helper
    LONG BuffersRequired(LONG cbBuffer) const
    {
        if (cbBuffer <= 0 || m_dwLookahead == 0) {
            return 1;
        } else {
            return (m_dwLookahead + 2 * (cbBuffer - 1)) / cbBuffer;
        }
    }

    //  Override Set/GetProperties to create extra buffers not
    //  reported
    STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES *pProps)
    {
        CAutoLock lck(this);
        HRESULT hr = CMemAllocator::GetProperties(pProps);
        LONG cBuffersRequired = BuffersRequired(m_lSize);
        if (SUCCEEDED(hr)) {
            ASSERT(pProps->cBuffers >= cBuffersRequired);
            pProps->cBuffers -= cBuffersRequired - 1;
        }
        return hr;
    }
    STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES *pRequest,
                               ALLOCATOR_PROPERTIES *pActual)
    {
        CAutoLock lck(this);

        //  Compute the buffers required for this buffer size
        LONG cBuffersRequired = BuffersRequired(pRequest->cbBuffer);
        ALLOCATOR_PROPERTIES Request = *pRequest;
        Request.cBuffers += cBuffersRequired - 1;
        HRESULT hr = CMemAllocator::SetProperties(&Request, pActual);
        if (SUCCEEDED(hr)) {
            ASSERT(pActual->cBuffers >= pRequest->cBuffers);
            pActual->cBuffers -= cBuffersRequired - 1;
        }
        return hr;
    }
};

#endif //__INPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\msdmo\guidenum.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include "guidenum.h"

//
// implementation of the enumerator returned by DMO enumeration API
//

CEnumDMOCLSID::CEnumDMOCLSID() {
   m_cRef = 1;
   m_ulPos = 0;
}

CEnumDMOCLSID::~CEnumDMOCLSID() {
   Entry* pEntry;
   DWORD ulPos = 0;
   while (pEntry = m_store.GetNth(ulPos)) {
      delete [] pEntry->szName;
      ulPos++;
   }
}

HRESULT CEnumDMOCLSID::QueryInterface(REFIID riid, void **ppv) {

   if (NULL == ppv) {
      return E_POINTER;
   }

   if (riid == IID_IUnknown) {
      AddRef();
      *ppv = (IUnknown*)this;
      return NOERROR;
   }
   else if (riid == IID_IEnumDMO) {
      AddRef();
      *ppv = (IEnumDMO*)this;
      return NOERROR;
   }
   else
      return E_NOINTERFACE;
}

ULONG CEnumDMOCLSID::AddRef() {
   return InterlockedIncrement((long*)&m_cRef);
}

ULONG CEnumDMOCLSID::Release() {
   long l = InterlockedDecrement((long*)&m_cRef);
   if (l == 0) {
      delete this;
   }
   return l;
}

HRESULT CEnumDMOCLSID::Next(ULONG celt, CLSID *pCLSIDs, WCHAR **pszNames, ULONG *pceltFetched) {

   if( NULL == pCLSIDs ) {
      return E_POINTER;
   }

   if( (1 != celt) && (NULL == pceltFetched) ) {
      return E_INVALIDARG;
   }

   for (ULONG c = 0; c < celt; c++) {
      Entry* p = m_store.GetNth(m_ulPos + c);
      if (!p)
         break;
      pCLSIDs[c] = p->clsid;
      WCHAR* szSrc = p->szName;
      if (!szSrc)
         szSrc = L"";
      if (pszNames) {
          pszNames[c] = (WCHAR*) CoTaskMemAlloc(sizeof(WCHAR) * (wcslen(szSrc) + 1));
          if (pszNames[c]) {
             wcscpy(pszNames[c], szSrc);
          } else {
              for (ULONG c1 = 0; c1 < c; c1++) {
                  CoTaskMemFree(pszNames[c1]);
                  pszNames[c1] = NULL;
              }
              return E_OUTOFMEMORY;
          }
      }
   }
    
   if( NULL != pceltFetched ) {
      *pceltFetched = c;
   }

   m_ulPos += c;
   return (c == celt) ? S_OK : S_FALSE;
}

HRESULT CEnumDMOCLSID::Skip(ULONG celt) {
   m_ulPos += celt;

   // The documentation for IEnumXXXX::Skip() states that 
   // it returns "S_OK if the number of elements skipped 
   // is celt; otherwise S_FALSE." (MSDN Library April 2000).
   if( m_ulPos <= m_store.GetSize() ) {
      return S_OK;
   } else {
      return S_FALSE;
   }
}

HRESULT CEnumDMOCLSID::Reset(void) {
   m_ulPos = 0;
   return NOERROR;
}

HRESULT CEnumDMOCLSID::Clone(IEnumDMO ** ppenum) {
   return E_NOTIMPL;
}

void CEnumDMOCLSID::Add(REFCLSID clsidDMO, WCHAR* szName) {
   WCHAR *szNm = NULL;
   if (szName) {
      szNm = new WCHAR[wcslen(szName) + 1];
      if (szNm) {
         wcscpy(szNm, szName);
      } else {
          return;
      }
   }
   Entry e;
   e.clsid = clsidDMO;
   e.szName = szNm;
   m_store.Add(e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\msdmo\regenum.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// regenum.cpp - registration/enumeration part of DMO runtime
//
#include <windows.h>
#include <tchar.h>
#include "dmoreg.h"
#include "guidenum.h"
#include "shlwapi.h"
#include "dmoutils.h"

#define DMO_REGISTRY_HIVE HKEY_CLASSES_ROOT
#define DMO_REGISTRY_PATH TEXT("DirectShow\\MediaObjects")

#define INPUT_TYPES_STR   "InputTypes"
#define OUTPUT_TYPES_STR  "OutputTypes"
#define SUBTYPES_STR      "Subtypes"
#define KEYED_STR         "Keyed"
#define CATEGORIES_STR    "Categories"

#ifndef CHARS_IN_GUID
#define CHARS_IN_GUID 39
#endif


//  Helper copied from shwapi

/*----------------------------------------------------------
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

Returns:
Cond:    --
*/
DWORD
DeleteKeyRecursively(
    IN HKEY   hkey,
    IN LPCTSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKey(hkey, pszSubKey, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        TCHAR   szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = sizeof(szSubKeyName) / sizeof(szSubKeyName[0]);
        TCHAR   szClass[MAX_PATH];
        DWORD   cbClass = sizeof(szClass) / sizeof(szClass[0]);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkSubKey,
                                szClass,
                                &cbClass,
                                NULL,
                                &dwIndex, // The # of subkeys -- all we need
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (NO_ERROR == dwRet && dwIndex > 0)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKey(hkey, pszSubKey);
    }

    return dwRet;
}

// Automatically calls RegCloseKey when leaving scope
class CAutoHKey {
public:
   CAutoHKey() : m_hKey(NULL) {}
   ~CAutoHKey() {
       if (m_hKey)
           RegCloseKey(m_hKey);
   }
   LRESULT Create(HKEY hKey, LPCTSTR szSubKey)
   {
       return RegCreateKey(hKey, szSubKey, &m_hKey);
   }
   LRESULT Open(HKEY hKey, LPCTSTR szSubKey)
   {
       return RegOpenKey(hKey, szSubKey, &m_hKey);
   }
   void Close()
   {
       if (m_hKey) {
           RegCloseKey(m_hKey);
       }
       m_hKey = NULL;
   }
   HKEY m_hKey;
   HKEY Key() const { return m_hKey; }
};

// Automatically calls RegCloseKey when leaving scope
class CAutoCreateHKey {
public:
   CAutoCreateHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey) {
      if (RegCreateKeyEx(hKey,
                         szSubKey,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         MAXIMUM_ALLOWED,
                         NULL,
                         phKey,
                         NULL) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoCreateHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};

class CAutoOpenHKey {
public:
   CAutoOpenHKey(HKEY hKey, TCHAR* szSubKey, HKEY *phKey, REGSAM samDesired = KEY_READ) {
      if (RegOpenKeyEx(hKey,
                       szSubKey,
                       0,
                       samDesired,
                       phKey) != ERROR_SUCCESS)
         m_hKey = *phKey = NULL;
      else
         m_hKey = *phKey;
   }
   ~CAutoOpenHKey() {
      if (m_hKey)
         RegCloseKey(m_hKey);
   }
   HKEY m_hKey;
};


HRESULT ReadTypesFromKeys(HKEY hkDMO, LPCTSTR pszTypes, DWORD *pcbData, PVOID *ppvData)
{
    //  Collect all the types into 1 value - need to enumerate
    //  keys and subkeys
    LPVOID pMem = CoTaskMemAlloc(0);
    unsigned int nEntries = 0;
    DWORD dwTypeIndex;
    BOOL bSuccess = TRUE;
    DMO_PARTIAL_MEDIATYPE Type;
    CAutoHKey hkSrc;
    if (NOERROR != hkSrc.Open(hkDMO, pszTypes)) {
        bSuccess = FALSE;
    }
    for (dwTypeIndex = 0; bSuccess; dwTypeIndex++) {
        TCHAR szType[MAX_PATH];
        LONG lResult = RegEnumKey(hkSrc.Key(), dwTypeIndex, szType, MAX_PATH);
        if (NOERROR != lResult) {
            if (ERROR_NO_MORE_ITEMS != lResult) {
                bSuccess = FALSE;
            }
            break;
        }
        if (DMOStrToGuid(szType, &Type.type)) {
            CAutoHKey kType;
            kType.Open(hkSrc.Key(), szType);
            if (NULL == kType.Key()) {
                bSuccess = FALSE;
            } else {
                DWORD dwSubtypeIndex;
                for (dwSubtypeIndex = 0; bSuccess; dwSubtypeIndex++) {
                    TCHAR szSubtype[MAX_PATH];
                    lResult = RegEnumKey(kType.Key(), dwSubtypeIndex, szSubtype, MAX_PATH);
                    if (NOERROR != lResult) {
                        if (ERROR_NO_MORE_ITEMS != lResult) {
                            bSuccess = FALSE;
                        }
                        break;
                    }
                    if (DMOStrToGuid(szSubtype, &Type.subtype)) {
                        //  Add to our list
                        LPVOID pMemNew = CoTaskMemRealloc(pMem,
                                            (nEntries + 1) * sizeof(DMO_PARTIAL_MEDIATYPE));
                        if (NULL == pMemNew) {
                            bSuccess = FALSE;
                        } else {
                            pMem = pMemNew;
                            CopyMemory((LPBYTE)pMem +
                                        nEntries * sizeof(DMO_PARTIAL_MEDIATYPE),
                                        &Type,
                                        sizeof(DMO_PARTIAL_MEDIATYPE));
                            nEntries++;
                        }
                    }
                }
            }
        }
    }
    if (bSuccess && nEntries != 0) {
        *ppvData = pMem;
        *pcbData = nEntries * sizeof(DMO_PARTIAL_MEDIATYPE);
        return S_OK;
    } else {
        CoTaskMemFree(pMem);
        return S_FALSE;
    }
}

HRESULT ReadTypes(HKEY hkDMO, LPCTSTR pszTypes, DWORD *pcbData, PVOID *ppvData)
{
    *pcbData = 0;

    //  Try reading the value first
    DWORD cbData;
    if (NOERROR != RegQueryValueEx(hkDMO, pszTypes, NULL, NULL, NULL, &cbData)) {
        return ReadTypesFromKeys(hkDMO, pszTypes, pcbData, ppvData);
    }
    if (cbData == 0) {
        return S_OK;
    }
    PVOID pvData = (PBYTE)CoTaskMemAlloc(cbData);
    if (NULL == pvData) {
        return E_OUTOFMEMORY;
    }
    if (NOERROR == RegQueryValueEx(hkDMO, pszTypes, NULL, NULL, (PBYTE)pvData, &cbData)) {
        *ppvData = pvData;
        *pcbData = cbData;
        return S_OK;
    } else {
        CoTaskMemFree(pvData);
        return E_OUTOFMEMORY;
    }
}



/////////////////////////////////////////////////////////////////////////////
//
// DMO Registration code
//

// Registration helper
void CreateObjectGuidKey(HKEY hKey, REFCLSID clsidDMO) {
   TCHAR szSubkeyName[80];

   HKEY hObjectGuidKey;
   DMOGuidToStr(szSubkeyName, clsidDMO);
   CAutoCreateHKey kGuid(hKey, szSubkeyName, &hObjectGuidKey);
}

// Registration helper
// Registers types\subtypes underneath the object's key
void RegisterTypes(HKEY hObjectKey,
                   TCHAR* szInputOrOutput,
                   ULONG ulTypes,
                   const DMO_PARTIAL_MEDIATYPE* pTypes) {
    RegSetValueEx(hObjectKey, szInputOrOutput, 0, REG_BINARY,
                  (const BYTE *)pTypes,
                  ulTypes * sizeof(DMO_PARTIAL_MEDIATYPE));
}

//
// Public entry point
//
STDAPI DMORegister(
   LPCWSTR szName,
   REFCLSID clsidDMO,
   REFGUID guidCategory,
   DWORD dwFlags, // DMO_REGISTERF_XXX
   unsigned long ulInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes,
   unsigned long ulOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes
) {
   TCHAR szSubkeyName[80];
   if ((clsidDMO == GUID_NULL) || (guidCategory == GUID_NULL))
      return E_INVALIDARG;

   // Create/open the main DMO key
   HKEY hMainKey;
   CAutoCreateHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;

   HKEY hCategoriesKey;
   CAutoCreateHKey kCats(hMainKey, TEXT(CATEGORIES_STR), &hCategoriesKey);
   if (hCategoriesKey == NULL)
      return E_FAIL;

   // Create/open the category specific subkey underneath the main key
   DMOGuidToStr(szSubkeyName, guidCategory);
   HKEY hCategoryKey;
   CAutoCreateHKey kCat(hCategoriesKey, szSubkeyName, &hCategoryKey);
   if (hCategoryKey == NULL)
      return E_FAIL;

   //  Deletet the redundant old types keys
   DeleteKeyRecursively(hCategoryKey, TEXT(INPUT_TYPES_STR));
   DeleteKeyRecursively(hCategoryKey, TEXT(OUTPUT_TYPES_STR));

   // If the category key does not have a name yet, add one
   DWORD cbName;
   DWORD dwType;

   if ((RegQueryValueEx(hCategoryKey, NULL, NULL, &dwType, NULL, &cbName) != ERROR_SUCCESS) ||
       (cbName <= sizeof(TCHAR)) || (REG_SZ != dwType)) {
      TCHAR* szName;
      if (guidCategory == DMOCATEGORY_AUDIO_DECODER)
         szName = TEXT("Audio decoders");
      else if (guidCategory == DMOCATEGORY_AUDIO_ENCODER)
         szName = TEXT("Audio encoders");
      else if (guidCategory == DMOCATEGORY_VIDEO_DECODER)
         szName = TEXT("Video decoders");
      else if (guidCategory == DMOCATEGORY_VIDEO_ENCODER)
         szName = TEXT("Video encoders");
      else if (guidCategory == DMOCATEGORY_AUDIO_EFFECT)
         szName = TEXT("Audio effects");
      else if (guidCategory == DMOCATEGORY_VIDEO_EFFECT)
         szName = TEXT("Video effects");
      else if (guidCategory == DMOCATEGORY_AUDIO_CAPTURE_EFFECT)
         szName = TEXT("Audio capture effects");
     else if (guidCategory == DMOCATEGORY_ACOUSTIC_ECHO_CANCEL)
         szName = TEXT("Acoustic Echo Canceller");
      else if (guidCategory == DMOCATEGORY_AUDIO_NOISE_SUPPRESS)
         szName = TEXT("Audio Noise Suppressor");
      else if (guidCategory == DMOCATEGORY_AGC)
         szName = TEXT("Automatic Gain Control");
      else
         szName = TEXT("Unknown DMO category");
      RegSetValue(hCategoryKey, NULL, REG_SZ, szName, lstrlen(szName) * sizeof(TCHAR));
   }

   // Create/open the object specific key underneath the category key
   DMOGuidToStr(szSubkeyName, clsidDMO);

   //  Remove the old one
   DeleteKeyRecursively(hMainKey, szSubkeyName);

   HKEY hObjKey;
   CAutoCreateHKey kObj(hCategoryKey, szSubkeyName, &hObjKey);
   if (hObjKey == NULL)
      return E_FAIL;

   // Create/open the object specific key underneath the main key
   DMOGuidToStr(szSubkeyName, clsidDMO); // BUGBUG: redundant
   HKEY hObjectKey;
   CAutoCreateHKey kObject(hMainKey, szSubkeyName, &hObjectKey);
   if (hObjectKey == NULL)
      return E_FAIL;

   // set the default value of the object key to the name of the DMO
#ifdef UNICODE
   LPCWSTR sz = szName;
#else
   char sz[80];
   WideCharToMultiByte(0,0,szName,-1,sz,80,NULL,NULL);
#endif
   if (RegSetValue(hObjectKey, NULL, REG_SZ, sz, lstrlen(sz) * sizeof(TCHAR))
        != ERROR_SUCCESS)
      return E_FAIL;

   // If the object is keyed, add a registry value indicating so
   if (dwFlags & DMO_REGISTERF_IS_KEYED) {
      if (RegSetValue(hObjectKey, TEXT(KEYED_STR), REG_SZ, TEXT(""), 0)
            != ERROR_SUCCESS)
         return E_FAIL;
   }

   // Register types
   if (ulInTypes) {
      RegisterTypes(hObjectKey,   TEXT(INPUT_TYPES_STR), ulInTypes, pInTypes);
   }

   if (ulOutTypes) {
      RegisterTypes(hObjectKey,   TEXT(OUTPUT_TYPES_STR),ulOutTypes,pOutTypes);
   }

   // Nuke the DShow filter cache
   DeleteKeyRecursively(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie\\Filter Cache"));

   return NOERROR;
}

// helper
void MakeSubkeyName (TCHAR* szSubkeyName,
                     REFGUID guidCategory,
                     REFCLSID clsidDMO) {
   DMOGuidToStr(szSubkeyName, guidCategory);
   _tcscat(szSubkeyName, TEXT("\\"));
   DMOGuidToStr(szSubkeyName + lstrlen(szSubkeyName), clsidDMO);
}


//
// Public entry point
//
STDAPI DMOUnregister(
   REFCLSID clsidDMO,
   REFGUID guidCategory
) {
   HRESULT hr;

   // open the root DMO key
   HKEY hMainKey;
   CAutoOpenHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey, MAXIMUM_ALLOWED);
   if (hMainKey == NULL)
      return E_FAIL;

   // open the "Categories" key underneath the root key
   HKEY hCategoriesKey;
   CAutoOpenHKey kCats(hMainKey, TEXT(CATEGORIES_STR), &hCategoriesKey, MAXIMUM_ALLOWED);
   if (hCategoriesKey == NULL)
      return E_FAIL;

   // Iterate through all categories attempting to delete from each one
   TCHAR szCategory[80];
   DWORD dwIndex = 0;
   BOOL bDeletedAnything = FALSE;
   BOOL bDeletedAll = TRUE;
   DMOGuidToStr(szCategory, guidCategory);

   while (RegEnumKey(hCategoriesKey, dwIndex, szCategory, 80) == ERROR_SUCCESS) {

      // process the subkey only if it resembles a category GUID
      GUID guid;
      if (DMOStrToGuid(szCategory, &guid)) {

         // Try to delete from this category
         TCHAR szSubkeyName[256];
         MakeSubkeyName(szSubkeyName, guid, clsidDMO);
         if (guidCategory == GUID_NULL || guid == guidCategory) {
         if (DeleteKeyRecursively(hCategoriesKey, szSubkeyName) == ERROR_SUCCESS)
            bDeletedAnything = TRUE;
         } else {
             CAutoHKey hk;
             if (ERROR_FILE_NOT_FOUND != hk.Open(hCategoriesKey, szSubkeyName)) {
                 bDeletedAll = FALSE;
             }
         }
      }
      dwIndex++;
   }

   if (bDeletedAnything) {
      hr = S_OK;
      if (bDeletedAll) {
         // Now delete this object's key from underneath the root DMO key
         TCHAR szGuid[CHARS_IN_GUID];
         DMOGuidToStr(szGuid, clsidDMO);
         if (DeleteKeyRecursively(hMainKey, szGuid) != ERROR_SUCCESS) {
             hr = S_FALSE;
         }
      }
   }
   else
      hr = S_FALSE;

   return hr;

}
//
// End DMO Registration code
//
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//
// DMO Enumeration code
// Some of it leaves room for future improvements in terms of speed
//

// helper
HRESULT ReadName(HKEY hDMOKey, WCHAR szName[80]) {
   LONG cbSize = 80;
#ifdef UNICODE
   if (RegQueryValue(hDMOKey, NULL, szName, &cbSize) == ERROR_SUCCESS)
      return S_OK;
#else
   char szTmp[80];
   if (RegQueryValue(hDMOKey, NULL, szTmp, &cbSize) == ERROR_SUCCESS) {
      MultiByteToWideChar(0,0,szTmp,-1,szName,80);
      return S_OK;
   }
#endif
   else {
      szName[0] = L'\0'; // no name - corrupt registry ?
      return S_FALSE;
   }
}

// Enumeration helper, does what the name says
void LookupNameAndAddToEnum(HKEY hObjectKey,
                            TCHAR* szGuid,
                            DWORD dwFlags,
                            REFCLSID clsidDMO,
                            CEnumDMOCLSID* pEnum) {
   // Skip keyed DMOs unless explicitly asked to include them
   if (!(dwFlags & DMO_ENUMF_INCLUDE_KEYED)) {
      // open the DMO's registry key
      LONG cbValue;
      if (RegQueryValue(hObjectKey, TEXT(KEYED_STR), NULL, &cbValue)
           == ERROR_SUCCESS)
         return; // DMO is keyed - skip
   }

   WCHAR szName[80];
   if (FAILED(ReadName(hObjectKey, szName)))
      szName[0] = L'\0';

   pEnum->Add(clsidDMO, szName);
}


//  Check if any of the requested types match
//  If no requested types are specified then this is treated
//  as a match
BOOL CompareTypes(HKEY hkDMO,
                  unsigned long ulTypes,
                  const DMO_PARTIAL_MEDIATYPE *pTypes,
                  LPCTSTR pszTypesValue)
{
    if (ulTypes == 0) {
        return TRUE;
    }
    DWORD cbData;
    PVOID pvDMOTypes = NULL;
    if (S_OK == ReadTypes(hkDMO, pszTypesValue, &cbData, &pvDMOTypes)) {
        for (unsigned long ulType = 0; ulType < ulTypes; ulType++) {
            DMO_PARTIAL_MEDIATYPE *pDMOTypes = (DMO_PARTIAL_MEDIATYPE *)pvDMOTypes;
            while ((PBYTE)(pDMOTypes + 1) <= (PBYTE)pvDMOTypes + cbData) {
                if (pDMOTypes->type == pTypes[ulType].type ||
                    pDMOTypes->type == GUID_NULL ||
                    pTypes[ulType].type == GUID_NULL) {
                    if (pTypes[ulType].subtype == GUID_NULL ||
                        pDMOTypes->subtype == GUID_NULL ||
                        pTypes[ulType].subtype == pDMOTypes->subtype) {
                        CoTaskMemFree(pvDMOTypes);
                        return TRUE;
                    }
                }
                pDMOTypes++;
            }
        }
    }
    CoTaskMemFree(pvDMOTypes);
    return FALSE;
}

// Enumeration helper
HRESULT EnumerateDMOs(HKEY hMainKey,
                      HKEY hCatKey,
                      DWORD dwFlags,
                      unsigned long ulInputTypes,
                      const DMO_PARTIAL_MEDIATYPE *pInputTypes,
                      unsigned long ulOutputTypes,
                      const DMO_PARTIAL_MEDIATYPE *pOutputTypes,
                      CEnumDMOCLSID *pEnum) {
    DWORD dwIndex = 0;
    TCHAR szSubkey[80];
    while (RegEnumKey(hCatKey, dwIndex, szSubkey, 80) == ERROR_SUCCESS) {
        // Does this look like an object CLSID ?
        CLSID clsidDMO;
        if (DMOStrToGuid(szSubkey, &clsidDMO)) {
            // Do the type match?
            CAutoHKey hkDMO;
            if (NOERROR == hkDMO.Open(hMainKey, szSubkey)) {
                if (CompareTypes(hkDMO.Key(), ulInputTypes, pInputTypes, TEXT(INPUT_TYPES_STR)) &&
                    CompareTypes(hkDMO.Key(), ulOutputTypes, pOutputTypes, TEXT(OUTPUT_TYPES_STR))) {
                    LookupNameAndAddToEnum(hkDMO.Key(), szSubkey, dwFlags, clsidDMO, pEnum);
                }
            }
        }
        dwIndex++;
    }
    return S_OK;
}
//
// Public entry point
//
STDAPI DMOEnum(
   REFGUID guidCategory, // GUID_NULL for "all"
   DWORD dwFlags, // DMO_ENUMF_XXX
   unsigned long ulInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, // can be NULL only of ulInTypes = 0
   unsigned long ulOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes,// can be NULL only of ulOutTypes = 0
   IEnumDMO **ppEnum
) {
    if (ppEnum == NULL) {
        return E_POINTER;
    }
    if (ulInTypes > 0 && pInTypes == NULL ||
        ulOutTypes > 0 && pOutTypes == NULL) {
        return E_INVALIDARG;
    }

    *ppEnum = NULL;

    // open the root key
    CAutoHKey kMain;
    kMain.Open(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH);
    if (kMain.Key() == NULL)
        return E_FAIL;

    CEnumDMOCLSID *pEnum = new CEnumDMOCLSID();
    if (!pEnum)
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    if (guidCategory == GUID_NULL) {

        hr = EnumerateDMOs(kMain.Key(),
                           kMain.Key(),
                           dwFlags,
                           ulInTypes,
                           pInTypes,
                           ulOutTypes,
                           pOutTypes,
                           pEnum);
    } else {

        // open the subkey for the specified category and enumerate its subkeys
        TCHAR szCategory[CHARS_IN_GUID];
        TCHAR szCategoryPath[MAX_PATH];
        DMOGuidToStr(szCategory, guidCategory);
        wsprintf(szCategoryPath, TEXT(CATEGORIES_STR) TEXT("\\%s"), szCategory);
        CAutoHKey key2;
        key2.Open(kMain.Key(), szCategoryPath);
        if (key2.Key()) {
            hr = EnumerateDMOs(kMain.Key(),
                               key2.Key(),
                               dwFlags,
                               ulInTypes,
                               pInTypes,
                               ulOutTypes,
                               pOutTypes,
                               pEnum);
        }
    }

    if (SUCCEEDED(hr)) {
        *ppEnum = (IEnumDMO*) pEnum;
        hr = S_OK;
    } else {
        delete pEnum;
    }
    return hr;
}
//  Copy the type information
HRESULT FetchTypeInfo(HKEY hObjKey, LPCTSTR pszTypesValue,
                      unsigned long ulTypesRequested,
                      unsigned long *pulTypesSupplied,
                      DMO_PARTIAL_MEDIATYPE *pTypes)
{
    DWORD cbData;
    unsigned long ulTypesCopied = 0;
    PVOID pvData;
    if (S_OK == ReadTypes(hObjKey, pszTypesValue, &cbData, &pvData)) {
        ulTypesCopied =
                min(ulTypesRequested, cbData / sizeof(DMO_PARTIAL_MEDIATYPE));
        CopyMemory(pTypes, pvData,
                   ulTypesCopied * sizeof(DMO_PARTIAL_MEDIATYPE));
        CoTaskMemFree(pvData);
    }
    *pulTypesSupplied = ulTypesCopied;
    return ulTypesCopied != 0 ? S_OK : S_FALSE;
}

// Mediatype helper
HRESULT FetchMediatypeInfo(HKEY hObjKey,
                           unsigned long ulInputTypesRequested,
                           unsigned long *pulInputTypesSupplied,
                           DMO_PARTIAL_MEDIATYPE *pInputTypes,
                           unsigned long ulOutputTypesRequested,
                           unsigned long *pulOutputTypesSupplied,
                           DMO_PARTIAL_MEDIATYPE *pOutputTypes) {

   HRESULT hr1 = S_OK;
   if (ulInputTypesRequested) {
      hr1 = FetchTypeInfo(hObjKey,
                          TEXT(INPUT_TYPES_STR),
                          ulInputTypesRequested,
                          pulInputTypesSupplied,
                          pInputTypes);
   } else {
       *pulInputTypesSupplied = 0;
   }
   HRESULT hr2 = S_OK;
   if (ulOutputTypesRequested) {
      hr2 = FetchTypeInfo(hObjKey,
                          TEXT(OUTPUT_TYPES_STR),
                          ulOutputTypesRequested,
                          pulOutputTypesSupplied,
                          pOutputTypes);
   } else {
       *pulOutputTypesSupplied = 0;
   }
   if ((hr1 == S_OK) && (hr2 == S_OK))
      return S_OK;
   else
      return S_FALSE;
}

//
// Public entry point
//
STDAPI DMOGetTypes(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
) {
   // open the DMO root registry key
   HKEY hMainKey;
   CAutoOpenHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;

   // open the object specific guid key
   TCHAR szGuid[80];
   DMOGuidToStr(szGuid, clsidDMO);
   HKEY hObjKey;
   CAutoOpenHKey kObj(hMainKey, szGuid, &hObjKey);
   if (!hObjKey)
      return E_FAIL;

   return FetchMediatypeInfo(hObjKey,
                             ulInputTypesRequested,
                             pulInputTypesSupplied,
                             pInputTypes,
                             ulOutputTypesRequested,
                             pulOutputTypesSupplied,
                             pOutputTypes);
}


STDAPI DMOGetName(REFCLSID clsidDMO, WCHAR szName[80]) {
   // open the DMO root registry key
   HKEY hMainKey;
   CAutoOpenHKey kMain(DMO_REGISTRY_HIVE, DMO_REGISTRY_PATH, &hMainKey);
   if (hMainKey == NULL)
      return E_FAIL;

   // open the object specific guid key
   TCHAR szGuid[80];
   DMOGuidToStr(szGuid, clsidDMO);
   HKEY hObjKey;
   CAutoOpenHKey kObj(hMainKey, szGuid, &hObjKey);
   if (!hObjKey)
      return E_FAIL;

   return ReadName(hObjKey, szName);
}

//
// End DMO Enumeration code
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\wrapper\inpin.cpp ===
#include <wchar.h>
#include <streams.h>
#include <atlbase.h>
#include <wmsecure.h>
#include <limits.h>
#include "mediaobj.h"
#include "dmodshow.h"
#include "filter.h"
#include "inpin.h"
#include "outpin.h"

// BUGBUG - set proper name

CWrapperInputPin::CWrapperInputPin(
                      CMediaWrapperFilter *pFilter,
                      ULONG Id,
                      HRESULT *phr) :
    CBaseInputPin(NAME("CWrapperInputPin"),
                  pFilter,
                  pFilter->FilterLock(),
                  phr,
                  (m_pNameObject = new _PinName_(L"in", Id))->Name()
                 ),
    m_Id(Id),
    m_fEOS(false)
{
}

CWrapperInputPin::~CWrapperInputPin() {
   delete m_pNameObject;
}

STDMETHODIMP CWrapperInputPin::Receive(IMediaSample *pSample)
{
   HRESULT hr = Filter()->NewSample(m_Id, pSample);

   //  If something bad happens flush - this avoids some more deadlocks
   //  where we're holding on to the sample
   if (S_OK != hr) {
       Filter()->m_pMediaObject->Flush();
   }
   return hr;
}

HRESULT CWrapperInputPin::CheckMediaType(const CMediaType *pmt)
{
    return Filter()->InputCheckMediaType(m_Id, pmt);
}
HRESULT CWrapperInputPin::SetMediaType(const CMediaType *pmt)
{
    return Filter()->InputSetMediaType(m_Id, pmt);
}

HRESULT CWrapperInputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    return Filter()->InputGetMediaType(m_Id, (ULONG)iPosition, pMediaType);
}


//  Remove any media type when breaking a connection
HRESULT CWrapperInputPin::BreakConnect()
{
    HRESULT hr = CBaseInputPin::BreakConnect();
    Filter()->m_pMediaObject->SetInputType(m_Id, &CMediaType(), DMO_SET_TYPEF_CLEAR);
    return hr;
}

//  Override GetAllocator and Notify Allocator to allow
//  for media object streams that hold on to buffer
STDMETHODIMP CWrapperInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    CheckPointer(ppAllocator, E_POINTER);
    *ppAllocator = NULL;

    //  Already got an allocator or not using special behavior?
    if (m_pAllocator != NULL || !HoldsOnToBuffers()) {
        return CBaseInputPin::GetAllocator(ppAllocator);
    }

    DWORD dwLookahead;
    DWORD cbBuffer;
    DWORD cbAlign;
    HRESULT hr = TranslateDMOError(Filter()->m_pMediaObject->GetInputSizeInfo(
                               m_Id,
                               &cbBuffer,
                               &dwLookahead,
                               &cbAlign));
    if (FAILED(hr)) {
       return hr;
    }
    //  Create our own special allocator
    hr = S_OK;
    CSpecialAllocator *pAllocator = new CSpecialAllocator(dwLookahead, &hr);
    if (NULL == pAllocator) {
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        delete pAllocator;
        return hr;
    }

    m_pAllocator = pAllocator;
    m_pAllocator->AddRef();
    pAllocator->AddRef();
    *ppAllocator = pAllocator;
    return S_OK;
}
STDMETHODIMP CWrapperInputPin::NotifyAllocator(
    IMemAllocator *pAllocator,
    BOOL bReadOnly
)
{
    //  If we hold on to buffers only allow our own allocator to be
    //  used
    if (HoldsOnToBuffers()) {
        if (pAllocator != m_pAllocator) {
            return E_FAIL;
        }
    }

    CAutoLock cObjectLock(m_pLock);

    // It does not make sense to propose an allocator if the pin
    // is not connected.
    ASSERT(IsConnected());

    HRESULT hr = MP3AndWMABufferSizeWorkAround(pAllocator);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 5, TEXT("WARNING in CWrapperInputPin::NotifyAllocator(): MP3AndWMABufferSizeWorkAround() failed and returned %#08x"), hr ));
    }

    return CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
}

STDMETHODIMP CWrapperInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    return Filter()->InputGetAllocatorRequirements(m_Id, pProps);
}

//  Just grab our critical section so we know we're quiesced
void CWrapperInputPin::SyncLock()
{
    CAutoLock lck(&m_csStream);
}


STDMETHODIMP CWrapperInputPin::NewSegment(
                REFERENCE_TIME tStart,
                REFERENCE_TIME tStop,
                double dRate)
{
    return Filter()->InputNewSegment(m_Id, tStart, tStop, dRate);
}


STDMETHODIMP CWrapperInputPin::BeginFlush()
{
    CAutoLock lck(m_pLock);

    //  Avoid deadlocks because the object is holding on to a sample
    //  Note we flush the object in EndFlush
    if (m_pAllocator) {
        m_pAllocator->Decommit();
    }
    return Filter()->BeginFlush(m_Id);
}
STDMETHODIMP CWrapperInputPin::EndFlush()
{
    CAutoLock lck(m_pLock);

    //  Recommit the allocator - we know no samples are flowing
    //  when EndFlush is called so this is safe to do in any order
    if (m_pAllocator) {
        m_pAllocator->Commit();
    }
    return Filter()->EndFlush(m_Id);
}
STDMETHODIMP CWrapperInputPin::EndOfStream()
{
    HRESULT hr = Filter()->EndOfStream(m_Id);
    //  where we're holding on to the sample
    if (S_OK != hr) {
        Filter()->m_pMediaObject->Flush();
    }
    return hr;
}

STDMETHODIMP CWrapperInputPin::Notify(IBaseFilter * pSender, Quality q)
{
    return E_NOTIMPL;
}

BOOL CWrapperInputPin::HoldsOnToBuffers()
{
    DWORD dwFlags = 0;
    Filter()->m_pMediaObject->GetInputStreamInfo(m_Id, &dwFlags);

    return 0 != (dwFlags & DMO_INPUT_STREAMF_HOLDS_BUFFERS);
}

HRESULT CWrapperInputPin::MP3AndWMABufferSizeWorkAround(IMemAllocator* pProposedAllocator)
{
    if (!IsConnected()) {
        return E_FAIL;
    }

    PIN_INFO pi;
    IPin* pConnected = GetConnected();

    HRESULT hr = pConnected->QueryPinInfo(&pi);
    if (FAILED(hr)) {
        return hr;
    }

    if (NULL == pi.pFilter) {
        return E_UNEXPECTED;
    }

    // {38be3000-dbf4-11d0-860e-00a024cfef6d}
    const CLSID MPEG_LAYER_3_DECODER_FILTER = { 0x38be3000, 0xdbf4, 0x11d0, { 0x86, 0x0e, 0x00, 0xa0, 0x24, 0xcf, 0xef, 0x6d } };

    // {22E24591-49D0-11D2-BB50-006008320064}
    const CLSID WINDOWS_MEDIA_AUDIO_DECODER_FILTER = { 0x22E24591, 0x49D0, 0x11D2, { 0xBB, 0x50, 0x00, 0x60, 0x08, 0x32, 0x00, 0x64 } };

    CLSID clsidFilter;

    hr = pi.pFilter->GetClassID(&clsidFilter);

    QueryPinInfoReleaseFilter(pi);

    // The Windows Media Audio Decoder (WMAD) filter and the MPEG Layer 3
    // (MP3) Decoder filter incorrectly calculate the output allocator's
    // media sample size.  The output allocator is the allocator used by
    // filter's the output pin.  Both filters tell the output allocator to
    // create samples which are too small.  Both filters then refuse to deliver
    // any samples when the filter graph is running because the output
    // allocator's samples cannot hold enough data.  The DMO Wrapper filter
    // works around these bugs because the authors of both filters
    // refuse to fix any bugs. The work around is to increase the allocator's
    // sample size if the allocator's sample size is too small and the DMO
    // Wrapper filter is connected to the WMA Decoder or the MP3 decoder.
    // The bug stops reproing once we increase the sample size.
    if (IsEqualCLSID(WINDOWS_MEDIA_AUDIO_DECODER_FILTER, clsidFilter)) {

        const DWORD MIN_WMA_FILTER_BUFFER_SIZE = 0x80000;

        hr = SetBufferSize(pProposedAllocator, MIN_WMA_FILTER_BUFFER_SIZE);
        if (FAILED(hr)) {
            return hr;
        }

    } else if (IsEqualCLSID(MPEG_LAYER_3_DECODER_FILTER, clsidFilter)) {

        // The MP3 decoder's audio sample buffers never hold
        // more then one tenth of second.  One tenth of second
        // of 44.1 KHZ 16 bit stereo PCM audio can be stored in
        // 17640 bytes.  17640 = (44100*2*2)/10 = 44E8.
        const DWORD MIN_MP3_BUFFER_SIZE = 0x44E8;

        hr = SetBufferSize(pProposedAllocator, MIN_MP3_BUFFER_SIZE);
        if (FAILED(hr)) {
            return hr;
        }

    } else {
        // Do nothing because we have not found a known broken filter.
    }

    return S_OK;
}

HRESULT CWrapperInputPin::SetBufferSize(IMemAllocator* pAllocator, DWORD dwMinBufferSize)
{
    ALLOCATOR_PROPERTIES apRequested;

    // Make sure dwMinBufferSize can be converted to a long.
    ASSERT(dwMinBufferSize <= LONG_MAX);

    HRESULT hr = pAllocator->GetProperties(&apRequested);
    if (FAILED(hr)) {
        return hr;
    }

    apRequested.cbBuffer = max((long)dwMinBufferSize, apRequested.cbBuffer);

    ALLOCATOR_PROPERTIES apActual;

    hr = pAllocator->SetProperties(&apRequested, &apActual);
    if (FAILED(hr)) {
        return hr;
    }

    if ((apActual.cbAlign != apRequested.cbAlign) ||
        (apActual.cBuffers < apRequested.cBuffers) ||
        (apActual.cbBuffer < apRequested.cbBuffer) ||
        (apActual.cbPrefix != apRequested.cbPrefix)) {

        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\wrapper\filter.cpp ===
#include <streams.h>
#include <amstream.h>
#include <atlbase.h>
#include <initguid.h>
#include <dmoreg.h>
#include <mediaerr.h>
#include <wmsecure.h>
#include <wmsdk.h>      // needed for IWMReader
#include "filter.h"
#include "inpin.h"
#include "outpin.h"


//
//  Helper - locks or unlocks a sample if it represents a
//  DirectDraw surface
//
bool LockUnlockSurface(IMediaSample *pSample, bool bLock)
{
    CComPtr<IDirectDrawMediaSample> pDDSample;
    if (SUCCEEDED(pSample->QueryInterface(IID_IDirectDrawMediaSample, (void **)&pDDSample))) {
        if (!bLock) {
            return S_OK == pDDSample->GetSurfaceAndReleaseLock(NULL, NULL);
        } else {
            return S_OK == pDDSample->LockMediaSamplePointer();
        }
    }

    CComPtr<IDirectDrawSurface> pSurface;
    if (SUCCEEDED(pSample->QueryInterface(IID_IDirectDrawSurface, (void **)&pSurface))) {
        if (!bLock) {
            if (SUCCEEDED(pSurface->Unlock(NULL))) {
                return true;
            } else {
                return false;
            }
        } else {
            DDSURFACEDESC ddsd;
            ddsd.dwSize = sizeof(ddsd);
            HRESULT hr = pSurface->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);
            if (FAILED(hr)) {
                DbgLog((LOG_STREAM, 1, TEXT("Failed to relock surface code(%x)"), hr));
            }
            return S_OK == hr;
        }
    }
    return false;
}

//
// Used for input IMediaBuffers.  Has extra code to deal with IMediaSample.
//
class CMediaBufferOnIMediaSample : public CBaseMediaBuffer {
public:
      CMediaBufferOnIMediaSample(IMediaSample *pSample, HRESULT *phr) {
      *phr = pSample->GetPointer(&m_pData);
      if (FAILED(*phr)) {
         return;
      }
      if (!m_pData) {
         *phr = E_POINTER;
         return;
      }
      m_ulSize = pSample->GetSize();
      DbgLog((LOG_STREAM,4,"in %d", m_ulSize));
      m_ulData = pSample->GetActualDataLength();
      pSample->AddRef();
      m_pSample = pSample;
      m_cRef = 1;
      *phr = NOERROR;
   }
   STDMETHODIMP_(ULONG) Release() { // override to release the sample
      long l = InterlockedDecrement((long*)&m_cRef);
      if (l == 0) {
         m_pSample->Release();
         delete this;
      }
      return l;
   }
private:
   IMediaSample *m_pSample;
};

CMediaWrapperFilter::CMediaWrapperFilter(
    LPUNKNOWN pUnkOwner,
    HRESULT *phr
) : CBaseFilter(NAME("CMediaWrapperFilter"),
                NULL,
                &m_csFilter,
                CLSID_DMOWrapperFilter),
    m_pMediaObject(NULL),
    m_pDMOQualityControl(NULL),
    m_pDMOOutputOptimizations(NULL),
    m_pUpstreamQualityControl(NULL),
    m_pDMOUnknown(NULL),
    m_pWrapperSecureChannel(NULL),
    m_pCertUnknown(NULL),
    m_clsidDMO(GUID_NULL),
    m_guidCat(GUID_NULL),
    m_fErrorSignaled( FALSE )
{

    LogPrivateEntry(LOG_INIT, "filter ctor");
    m_pInputPins = NULL;
    m_pOutputPins = NULL;
    m_OutputBufferStructs = NULL;

    *phr = RefreshPinList();
}


CMediaWrapperFilter::~CMediaWrapperFilter()
{
   LogPrivateEntry(LOG_INIT, "filter dtor");
   FreePerStreamStuff();

    if (m_pDMOOutputOptimizations) {
        GetOwner()->AddRef(); // the AddRef is required by COM aggregation rules
        m_pDMOOutputOptimizations->Release();
    }
    if (m_pDMOQualityControl) {
        GetOwner()->AddRef(); // the AddRef is required by COM aggregation rules
        m_pDMOQualityControl->Release();
    }

    if (m_pMediaObject) {
        GetOwner()->AddRef(); // the AddRef is required by COM aggregation rules
        m_pMediaObject->Release();
    }

    // let the inner object know that the whole thing is going away
    if (m_pDMOUnknown) {
        m_pDMOUnknown->Release();
    }

    // release the app certificate if we got one, note that we expect this to have
    // been done when the filter was removed from the graph
    if (m_pCertUnknown) {
        m_pCertUnknown->Release();
    }

    // release secure channel object if we created one
    if( m_pWrapperSecureChannel ) {
        m_pWrapperSecureChannel->WMSC_Disconnect();
        m_pWrapperSecureChannel->Release();
    }

}

template <class T> void ArrayNew(T* &p, ULONG n, bool &fSuccess) {
   ASSERT(!p);
   delete[] p;
   p = NULL;

   if (!fSuccess) {
      return;
   }

   p = new T[n];

   if (!p) {
      fSuccess = false;
   }
}

HRESULT CMediaWrapperFilter::AllocatePerStreamStuff(ULONG cInputs, DWORD cOutputs) {
   LogPrivateEntry(LOG_INIT, "AllocatePerStreamStuff");
   bool fSuccess = true;
   ArrayNew(m_pInputPins, cInputs, fSuccess);
   ArrayNew(m_pOutputPins, cOutputs, fSuccess);
   ArrayNew(m_OutputBufferStructs, cOutputs, fSuccess);

   if (!fSuccess) {
      return E_OUTOFMEMORY;
   }
   // Initialize these so DeletePins() can be called right away
   DWORD c;
   for (c = 0; c < cInputs; c++)
      m_pInputPins[c] = NULL;
   for (c = 0; c < cOutputs; c++)
      m_pOutputPins[c] = NULL;
   return NOERROR;
}

void CMediaWrapperFilter::FreePerStreamStuff() {
   LogPrivateEntry(LOG_INIT, "FreePerStreamStuff");
   DeletePins();

   delete[] m_pInputPins;
   m_pInputPins = NULL;

   delete[] m_pOutputPins;
   m_pOutputPins = NULL;

   delete[] m_OutputBufferStructs;
   m_OutputBufferStructs = NULL;

   m_cInputPins = m_cOutputPins = 0;
}

void CMediaWrapperFilter::DeletePins()
{
   LogPrivateEntry(LOG_INIT, "DeletePins");
    if (m_pInputPins) {
        for (DWORD c = 0; c < m_cInputPins; c++) {
            if (m_pInputPins[c]) {
                delete m_pInputPins[c];
                m_pInputPins[c] = NULL;
            }
        }
    }
    if (m_pOutputPins) {
        for (DWORD c = 0; c < m_cOutputPins; c++) {
            if (m_pOutputPins[c]) {
                delete m_pOutputPins[c];
                m_pOutputPins[c] = NULL;
            }
        }
    }
}

STDMETHODIMP CMediaWrapperFilter::Run(REFERENCE_TIME rtStart) {
   HRESULT hrRun = CBaseFilter::Run(rtStart);
   LogHResult(hrRun, LOG_STATE, "Run", "CBaseFilter::Run()");
   if (FAILED(hrRun)) {
      return hrRun;
   }

   if (m_pDMOQualityControl) {
      HRESULT hr;
      hr = m_pDMOQualityControl->SetStatus(DMO_QUALITY_STATUS_ENABLED);
      LogHResult(hr, LOG_STATE, "Run", "m_pDMO->QualityEnable");
   }

   return hrRun;
}

STDMETHODIMP  CMediaWrapperFilter::Pause() {
   LogPublicEntry(LOG_STATE, "Pause");
   CAutoLock l(&m_csFilter);

   if(!m_pMediaObject) {
       return E_FAIL;
   }

   if (m_pDMOQualityControl) {
      HRESULT hr;
      hr = m_pDMOQualityControl->SetStatus(0);
      LogHResult(hr, LOG_STATE, "Pause", "m_pDMO->QualityDisable");
   }

   if (m_State == State_Stopped) {
      DbgLog((LOG_STATE,4,"Stopped => Paused"));

      m_fErrorSignaled = FALSE;

      //CAutoLock l2(&m_csStreaming);
      //  First allocate streaming resources
      HRESULT hr = TranslateDMOError(m_pMediaObject->AllocateStreamingResources());
      if (FAILED(hr)) {
          return hr;
      }
      for (DWORD c = 0; c < m_cInputPins; c++)
         m_pInputPins[c]->m_fEOS = false;
      for (c = 0; c < m_cOutputPins; c++) {
         m_pOutputPins[c]->m_fEOS = false;

         m_pOutputPins[c]->m_fNeedsPreviousSample = false;
         if (m_pOutputPins[c]->m_fAllocatorHasOneBuffer && m_pDMOOutputOptimizations) {
            // Offer to always supply the same buffer
            DWORD dwFlags;
            HRESULT hr = m_pDMOOutputOptimizations->QueryOperationModePreferences(c, &dwFlags);
            if (dwFlags & DMO_VOSF_NEEDS_PREVIOUS_SAMPLE) {
               hr = m_pDMOOutputOptimizations->SetOperationMode(c, DMO_VOSF_NEEDS_PREVIOUS_SAMPLE);
               if (SUCCEEDED(hr)) {
                  m_pOutputPins[c]->m_fNeedsPreviousSample = true;
               }
            }
         }
      }
      m_fNoUpstreamQualityControl = false;
      m_pUpstreamQualityControl = NULL;

   }
   HRESULT hr = CBaseFilter::Pause();
   LogHResult(hr, LOG_STATE, "Pause", "CBaseFilter::Pause");
   return hr;
}

STDMETHODIMP  CMediaWrapperFilter::Stop()
{
    LogPublicEntry(LOG_STATE, "Stop");
    CAutoLock l(&m_csFilter);

    if(!m_pMediaObject) {
        return E_FAIL;
    }

    //  BUGBUG do any graph rearrangement stuff

    //  Flush our object - but only after we've synced our input
    //  pins

    //  First stop the filter, free allocators or whatever
    HRESULT hr = CBaseFilter::Stop();
    LogHResult(hr, LOG_STATE, "Stop", "CBaseFilter::Stop");
    //  Sync to the input pins
    for (ULONG ulIndex = 0; ulIndex < m_cInputPins; ulIndex++) {
            m_pInputPins[ulIndex]->SyncLock();
    }

    //  NOW, grab our streaming lock and flush the object
    CAutoLock l2(&m_csStreaming);
    hr = TranslateDMOError(m_pMediaObject->Flush());
    LogHResult(hr, LOG_STATE, "Stop", "IMediaObject::Flush");

    hr = TranslateDMOError(m_pMediaObject->FreeStreamingResources());
    LogHResult(hr, LOG_STATE, "Stop", "IMediaObject::FreeStreamingResources");

    if (m_pUpstreamQualityControl) {
       m_pUpstreamQualityControl->Release();
       m_pUpstreamQualityControl = NULL;
    }
    m_fNoUpstreamQualityControl = false;

    return S_OK;
}

//  Override to handle multiple output streams case
STDMETHODIMP CMediaWrapperFilter::GetState(DWORD dwMilliseconds, FILTER_STATE *pfs)
{
    HRESULT hr = CBaseFilter::GetState(dwMilliseconds, pfs);

    //  If we have > 1 output pin connected then say we can't cue
    //  or we'll block pause forever
    //  We might want to use output queues in future
    if (SUCCEEDED(hr) && m_State == State_Paused) {
        DWORD cOutputPinsConnected = 0;
        for (DWORD c = 0; c < m_cOutputPins; c++) {
            if (m_pOutputPins[c]->IsConnected()) {
                cOutputPinsConnected++;
            }
        }
        if (cOutputPinsConnected > 1) {
            hr  = VFW_S_CANT_CUE;
        }
    }
    return hr;
}

int CMediaWrapperFilter::GetPinCount()
{
    CAutoLock l(&m_csFilter);
    return (int)(m_cInputPins + m_cOutputPins);
}

HRESULT CMediaWrapperFilter::Init(REFCLSID clsidDMO, REFCLSID guidCat)
{
    LogPublicEntry(LOG_INIT, "Init");
    CAutoLock l(&m_csFilter);

    ASSERT( !m_pDMOUnknown );
    
    HRESULT hr;
    m_cRef++;
    hr = CoCreateInstance(clsidDMO,
                          GetOwner(),
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void**)&m_pDMOUnknown);
    m_cRef--;
    LogHResult(hr, LOG_INIT, "Init", "CoCreateInstance");
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_pDMOUnknown->QueryInterface(IID_IMediaObject, (void**)&m_pMediaObject);
    LogHResult(hr, LOG_INIT, "Init", "QI(IMediaObject)");
    if (FAILED(hr)) {
        m_pDMOUnknown->Release();

        //  If we don't set this to NULL we crash in the destructor
        m_pDMOUnknown = NULL;
        m_pMediaObject = NULL;
        return hr;
    }
    GetOwner()->Release(); // this is the official COM hack for this situation

    //
    // check and see if we're already in the graph
    // (which will happen when we're loaded from a grf),
    // if so, we should know by now whether the app we're in is secure or not
    //
    if( m_pGraph )
    {
        HRESULT hrCert = SetupSecureChannel();
        LogHResult(hr, LOG_SECURECHANNEL, "Init", "SetupSecureChannel");
        if( FAILED( hrCert ) )
        {
            //
            // !!note that if we fail when loaded from a grf our best fallout is to
            // return the failure here, before we've created our pins
            //
            return hrCert;
        }
    }

    hr = m_pDMOUnknown->QueryInterface(IID_IDMOQualityControl, (void**)&m_pDMOQualityControl);
    if (SUCCEEDED(hr)) { // eliminate the cirtular ref count
        DbgLog((LOG_STREAM, 2, "DMO supports quality control"));
        GetOwner()->Release();
    }
    else { // No problem, just make sure m_pDMOQualityControl stays NULL
        DbgLog((LOG_STREAM, 2, "DMO does not support quality control"));
        m_pDMOQualityControl = NULL;
    }

    hr = m_pDMOUnknown->QueryInterface(IID_IDMOVideoOutputOptimizations, (void**)&m_pDMOOutputOptimizations);
    if (SUCCEEDED(hr)) { // eliminate the cirtular ref count
        DbgLog((LOG_STREAM, 4, "DMO supports output optimizations"));
        GetOwner()->Release();
    }
    else {
        DbgLog((LOG_STREAM, 4, "DMO does not support output optimizations"));
        m_pDMOOutputOptimizations = NULL;
    }

    m_clsidDMO = clsidDMO;
    m_guidCat = guidCat;
    RefreshPinList();

    return S_OK;
}

// This just returns the first input pin (if there is one).  Looks
// like we will never fully support multiple input streams anyway.
CWrapperInputPin* CMediaWrapperFilter::GetInputPinForPassThru() {
   LogPrivateEntry(LOG_INIT, "GetInputPinForPosPassThru");
   CAutoLock l(&m_csFilter);
   if (m_cInputPins) {
      return m_pInputPins[0];
   } else {
      return NULL;
   }
}

// ------------------------------------------------------------------------
//
// JoinFilterGraph - need to be in graph to initialize keying mechanism
//
// ------------------------------------------------------------------------
STDMETHODIMP CMediaWrapperFilter::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    LogPrivateEntry(LOG_INIT, "JoinFilterGraph");

    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if(FAILED( hr ) )
        return hr;

    if( !pGraph )
    {
        //
        // if filter is removed from the graph, release the certification object.
        // we don't allow secure DMOs to be run outside of a graph
        //
        if( m_pCertUnknown )
        {
            m_pCertUnknown->Release();
            m_pCertUnknown = NULL;
        }
    }
    else
    {
        ASSERT( !m_pCertUnknown );
        //
        // see whether the dshow app is an IServiceProvider (in case this is a secure dmo)
        //
        IObjectWithSite *pSite;
        HRESULT hrCert = m_pGraph->QueryInterface( IID_IObjectWithSite, (VOID **)&pSite );
        if( SUCCEEDED( hrCert ) )
        {
            IServiceProvider *pSP;
            hrCert = pSite->GetSite( IID_IServiceProvider, (VOID **)&pSP );
            pSite->Release();
            LogHResult(hrCert, LOG_SECURECHANNEL, "JoinFilterGraph", "IObjectWithSite->GetSite");
            if( SUCCEEDED( hrCert ) )
            {
                hrCert = pSP->QueryService( IID_IWMReader, IID_IUnknown, (void **) &m_pCertUnknown );
                pSP->Release();
                LogHResult(hrCert, LOG_SECURECHANNEL, "JoinFilterGraph", "IServiceProvider->QI(IWMReader)");
#ifdef DEBUG
                if( SUCCEEDED( hrCert ) )
                {
                    DbgLog( ( LOG_TRACE, 5, TEXT("CMediaWrapperFilter::JoinFilterGraph got app cert (pUnkCert = 0x%08lx)"), m_pCertUnknown ) );
                }
#endif
            }
        }
        // if we were loaded from a grf then our m_pMediaObject wouldn't have been
        // created yet so we can't check dmo security
        if( m_pMediaObject )
        {
            hr = SetupSecureChannel();
            LogHResult(hrCert, LOG_SECURECHANNEL, "JoinFilterGraph", "SetupSecureChannel");
            if( FAILED( hr ) )
            {
                // up-oh, we failed to join, but the base class thinks we did,
                // so we need to unjoin the base class
                CBaseFilter::JoinFilterGraph(NULL, NULL);
            }
        }
    }
    return hr;
}

// ------------------------------------------------------------------------
//
// SetupSecureChannel
//
// ------------------------------------------------------------------------
HRESULT CMediaWrapperFilter::SetupSecureChannel()
{
    ASSERT( m_pGraph );
    ASSERT( m_pMediaObject );
    if( !m_pGraph )
        return E_UNEXPECTED;

    if( !m_pMediaObject )
        return E_UNEXPECTED;

    if( m_pWrapperSecureChannel )
    {
        // must already have a secure channel set up, right?
        return S_OK;
    }

#ifdef _X86_
    //
    // next check whether this is a secure dmo
    //
    IWMGetSecureChannel * pGetSecureChannel;

    HRESULT hr = m_pMediaObject->QueryInterface( IID_IWMGetSecureChannel, ( void ** )&pGetSecureChannel );
    LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "m_pMediaObject->QI(IWMGetSecureChannel)");
    if( SUCCEEDED( hr ) )
    {
        // it is, do we have a certificate from the app?
        if( m_pCertUnknown )
        {
            //
            // pass app certification to dmo through secure channel
            //
            IWMSecureChannel * pCodecSecureChannel;
            hr = pGetSecureChannel->GetPeerSecureChannelInterface( &pCodecSecureChannel );
            LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "pGetSecureChannel->GetPeerSecureChannelInterface");
            if ( SUCCEEDED( hr ) )
            {
                // setup a secure channel on our side (the dmo wrapper side)
                hr = WMCreateSecureChannel( &m_pWrapperSecureChannel );
                LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "WMCreateSecureChannel failed");
                if( SUCCEEDED( hr ) )
                {
                    IWMAuthorizer * pWMAuthorizer;
                    // QI the pCertUnknown for IWMAuthorizer before passing it down to the dmo!
                    hr = m_pCertUnknown->QueryInterface( IID_IWMAuthorizer, (void ** ) &pWMAuthorizer );
                    if( SUCCEEDED( hr ) )
                    {
                        // pass the channel a pointer to the app certificate's IWMAuthorizer
                        hr = m_pWrapperSecureChannel->WMSC_AddCertificate( pWMAuthorizer );
                        LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "m_pWrapperSecureChannel->WMSC_AddCertificate");
                        if( SUCCEEDED( hr ) )
                        {
                            // connect the dmo wrapper's secure channel to the codec's
                            hr = m_pWrapperSecureChannel->WMSC_Connect( pCodecSecureChannel );
                            LogHResult(hr, LOG_SECURECHANNEL, "SetupSecureChannel", "m_pWrapperSecureChannel->WMSC_Connect");
                        }
                        pWMAuthorizer->Release();
                    }
                    if( FAILED( hr ) )
                    {
                        // release the m_pWrapperSecureChannel if anything failed within this scope
                        m_pWrapperSecureChannel->Release();
                        m_pWrapperSecureChannel = NULL;
                    }

                }
                pCodecSecureChannel->Release();
            }
        }
        else
        {
            // if not a secure app then refuse to join the graph
            hr = VFW_E_CERTIFICATION_FAILURE;
        }

        pGetSecureChannel->Release();
    }
    else
    {
        //
        // this dmo's not secure so just return success and continue on
        //
        hr = S_OK;
    }
    return hr;
#else
    // wmsdk not supported on non-x86 and WIN64 platforms, for those just return success
    return S_OK;
#endif
}


HRESULT CMediaWrapperFilter::QualityNotify(ULONG ulOutputIndex, Quality q) {
   HRESULT hr;
   DbgLog((LOG_STREAM, 4, "QualityNotify(%08X%08X = %08X%08X + %08X%08X)",
           (DWORD)((q.TimeStamp + q.Late) >> 32), (DWORD)(q.TimeStamp + q.Late),
           (DWORD)(q.TimeStamp >> 32), (DWORD)q.TimeStamp,
           (DWORD)(q.Late >> 32), (DWORD)q.Late));

   // Try our DMO
   if (m_pDMOQualityControl) {
      hr = m_pDMOQualityControl->SetNow(q.TimeStamp + q.Late);

      LogHResult(hr, LOG_STREAM, "QualityNotify", "DMO->SetNow");

      return hr;
   }

   { // lock scope
      CAutoLock l(&m_csQualityPassThru);
      // Try the upstream filter
      if (!m_fNoUpstreamQualityControl) {
         return E_FAIL; // Don't check for this more than once
      }

      if (!m_pUpstreamQualityControl) { // Try to get the interface
         // Assume falilure
         m_fNoUpstreamQualityControl = true;

         CWrapperInputPin* pInPin = GetInputPinForPassThru();
         if (!pInPin) {
            return E_FAIL;
            DbgLog((LOG_STREAM, 4, "QualityNotify: no input pin"));
         }
         IPin* pUpstreamPin = pInPin->GetConnected();
         if (!pUpstreamPin) {
            DbgLog((LOG_STREAM, 4, "QualityNotify: no upstream pin (???)"));
            return E_FAIL;
         }
         HRESULT hr;
         hr = pUpstreamPin->QueryInterface(IID_IQualityControl, (void**)&m_pUpstreamQualityControl);
         LogHResult(hr, LOG_STREAM, "QualityNotify", "UpstreamPin->QI(IQualityControl)");
         if (FAILED(hr)) {
            m_pUpstreamQualityControl = NULL;
            return hr;
         }

         // Succeeded if we got here
         m_fNoUpstreamQualityControl = false;
      }
   } // lock scope

   hr = m_pUpstreamQualityControl->Notify(this, q);
   LogHResult(hr, LOG_STREAM, "QualityNotify", "UpstreamPin->Notify");
   return hr;
}

CBasePin * CMediaWrapperFilter::GetPin(int iPin)
{
    CAutoLock l(&m_csFilter);
    DWORD ulPin = (DWORD) iPin;
    if (ulPin < m_cInputPins) {
        return m_pInputPins[ulPin];
    }
    else if (ulPin < m_cInputPins + m_cOutputPins) {
        return m_pOutputPins[ulPin - m_cInputPins];
    } else {
        return NULL;
    }
}

HRESULT CMediaWrapperFilter::RefreshPinList()
{
    CAutoLock l(&m_csFilter);
    LogPrivateEntry(LOG_INIT, "RefreshPinList");

    //  Free old ones
    FreePerStreamStuff();

    DWORD cInputStreams, cOutputStreams;
    HRESULT hr;

    if (m_pMediaObject) {
       hr = TranslateDMOError(m_pMediaObject->GetStreamCount(
           &cInputStreams,
           &cOutputStreams));

       if (FAILED(hr)) {
           return hr;
       }
    }
    else {
       cInputStreams = 0;
       cOutputStreams = 0;
    }

    m_cInputPins = cInputStreams;
    m_cOutputPins = cOutputStreams;
    if (FAILED(hr = AllocatePerStreamStuff(m_cInputPins, m_cOutputPins))) {
       return E_OUTOFMEMORY;
    }

    //  Check input and output pins
    //  Note that this loop is designed to recover if anything
    //  fails
    DWORD c;
    for (c = 0; c < m_cInputPins; c++) m_pInputPins[c] = NULL;
    for (c = 0; c < m_cOutputPins; c++) m_pOutputPins[c] = NULL;

    for (c = 0; c < m_cInputPins; c++) {
       m_pInputPins[c] = new CWrapperInputPin(this, c, &hr);
       if (NULL == m_pInputPins[c]) {
          hr = E_OUTOFMEMORY;
       }
    }
    for (c = 0; c < m_cOutputPins; c++) {
       //  See if this pin is optional
       DWORD dwFlags;
       hr = TranslateDMOError(m_pMediaObject->GetOutputStreamInfo(c, &dwFlags));
       if (SUCCEEDED(hr)) {
           m_pOutputPins[c] =
               new CWrapperOutputPin(this, c, 0 != (dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL), &hr);
           if (NULL == m_pOutputPins[c]) {
              hr = E_OUTOFMEMORY;
           }
       }
    }

    if (FAILED(hr)) {
        FreePerStreamStuff();
    }

    return hr;
}

// Check a media type
HRESULT CMediaWrapperFilter::InputCheckMediaType(ULONG ulInputIndex, const AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "InputCheckMediaType");
   return TranslateDMOError(m_pMediaObject->SetInputType(ulInputIndex,
                                                         pmt,
                                                         DMO_SET_TYPEF_TEST_ONLY));
}
HRESULT CMediaWrapperFilter::OutputCheckMediaType(ULONG ulOutputIndex, const AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "OutputCheckMediaType");
   return TranslateDMOError(m_pMediaObject->SetOutputType(ulOutputIndex, pmt, DMO_SET_TYPEF_TEST_ONLY));
}

// Set a media type
HRESULT CMediaWrapperFilter::InputSetMediaType(ULONG ulInputIndex, const CMediaType *pmt)
{
   LogPublicEntry(LOG_CONNECT, "InputSetMediaType");
    HRESULT hr = TranslateDMOError(m_pMediaObject->SetInputType(ulInputIndex, pmt, 0));
    if (FAILED(hr)) {
       return hr;
    }
    return m_pInputPins[ulInputIndex]->CBaseInputPin::SetMediaType(pmt);
}
HRESULT CMediaWrapperFilter::OutputSetMediaType(ULONG ulOutputIndex, const AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "OutputSetMediaType");
    return TranslateDMOError(m_pMediaObject->SetOutputType(ulOutputIndex, pmt, 0));
}

// get a media type
HRESULT CMediaWrapperFilter::InputGetMediaType(ULONG ulInputIndex, ULONG ulTypeIndex, AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "InputGetMediaType");
    CAutoLock lck(&m_csFilter);
    return TranslateDMOError(m_pMediaObject->GetInputType(ulInputIndex, ulTypeIndex, pmt));
}
HRESULT CMediaWrapperFilter::OutputGetMediaType(ULONG ulOutputIndex, ULONG ulTypeIndex, AM_MEDIA_TYPE *pmt)
{
   LogPublicEntry(LOG_CONNECT, "OutputGetMediaType");
    CAutoLock lck(&m_csFilter);
    return TranslateDMOError(m_pMediaObject->GetOutputType(ulOutputIndex, ulTypeIndex, pmt));
}

HRESULT CMediaWrapperFilter::InputGetAllocatorRequirements(ULONG ulInputIndex, ALLOCATOR_PROPERTIES *pProps) {
   DWORD dwLookahead;
   LogPublicEntry(LOG_CONNECT, "InputGetAllocatorRequirements");
   HRESULT hr = TranslateDMOError(m_pMediaObject->GetInputSizeInfo(
                              ulInputIndex,
                              (ULONG*)&pProps->cbBuffer,
                              &dwLookahead,
                              (ULONG*)&pProps->cbAlign));
   LogHResult(hr, LOG_CONNECT, "InputGetAllocatorRequirements", "IMediaObject::GetInputSizeInfo");
   if (FAILED(hr)) {
      return hr;
   }

   pProps->cBuffers = 1;

   return NOERROR;
}

HRESULT CMediaWrapperFilter::OutputDecideBufferSize(
    ULONG ulOutputIndex,
    IMemAllocator *pAlloc,
    ALLOCATOR_PROPERTIES *ppropRequest
)
{
   LogPublicEntry(LOG_CONNECT,"OutputDecideBufferSize");
    DWORD cbBuffer, cbAlign, cbPrefix;
    HRESULT hr = TranslateDMOError(m_pMediaObject->GetOutputSizeInfo(
                                     ulOutputIndex,
                                     &cbBuffer,
                                     &cbAlign));
    LogHResult(hr, LOG_CONNECT,"OutputDecideBufferSize", "GetOutputSizeInfo");

    DbgLog((LOG_CONNECT,3,"output stream %lu wants %d-byte buffers", ulOutputIndex, cbBuffer));

    //  Why?
    if (cbBuffer < 16384) {
       cbBuffer = 16384;
    }
    cbPrefix = 0;

    if (SUCCEEDED(hr)) {
        ppropRequest->cBuffers = 1;
        ppropRequest->cbBuffer = max((long)cbBuffer, ppropRequest->cbBuffer);
        ppropRequest->cbAlign = max((long)cbAlign, ppropRequest->cbAlign);
        ppropRequest->cbPrefix = max((long)cbPrefix, ppropRequest->cbPrefix);
        ALLOCATOR_PROPERTIES propActual;
        hr = pAlloc->SetProperties(ppropRequest, &propActual);
        LogHResult(hr, LOG_CONNECT,"OutputDecideBufferSize", "Allocator::SetProperties");

        DbgLog((LOG_CONNECT,3,"output stream %lu will use %d %d-byte buffers", ulOutputIndex, propActual.cBuffers, propActual.cbBuffer));

        if (propActual.cBuffers == 1) {
           m_pOutputPins[ulOutputIndex]->m_fAllocatorHasOneBuffer = true;
        } else {
           m_pOutputPins[ulOutputIndex]->m_fAllocatorHasOneBuffer = false;
        }
    }
    return hr;
}

HRESULT CMediaWrapperFilter::DeliverInputSample(ULONG ulInputIndex, IMediaSample *pSample) {
    HRESULT hr;
    BYTE* pData = NULL;
    bool bTimeStamp = false, bTimeLength = false;
    REFERENCE_TIME rtStart = 0, rtStop = 0;
    bool bSyncPoint = false;

    LogPrivateEntry(LOG_STREAM, "DeliverInputSample");

    // Get misc. flags and fields from the IMediaSample
    if (SUCCEEDED(hr = pSample->GetTime(&rtStart, &rtStop))) {
        bTimeStamp = true;
        // assume rtStop is invalid if it either precedes
        // start or trailis it by more than 1 hour.
        if ((rtStop >= rtStart) && (rtStop <= rtStart + 10000000 * (REFERENCE_TIME)3600)) {
            bTimeLength = true;
        }
    }
    if (pSample->IsSyncPoint() == S_OK) {
        bSyncPoint = true;
    }

    // If there is a discontinuity, send it before the data
    // BUGBUG: this requires additional code to work correctly with multiple input streams.
    // We should probably at least deliver anything stuck in the input queues before
    // executing the discontuinuity.  In any case, we haven't thought through the multiple
    // input stream case, so this is probably not the first place that would break...
    if (pSample->IsDiscontinuity() == S_OK) {
        DbgLog((LOG_STREAM, 4, "discontinuity on input stream %lu", ulInputIndex));
        hr = TranslateDMOError(m_pMediaObject->Discontinuity(ulInputIndex));
        LogHResult(hr,LOG_STREAM,"DeliverInputSample","IMediaObject::Discontinuity");
        if (FAILED(hr)) {
            return hr;
        }

        hr = SuckOutOutput();
        LogHResult(hr, LOG_STATE,"Discontinuity", "SuckOutOutput");
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create a media buffer from the sample
    CMediaBufferOnIMediaSample *pBuffer = new CMediaBufferOnIMediaSample(pSample, &hr);
    if (!pBuffer) {
        DbgLog((LOG_STREAM,0,"could not create a CMediaBufferOnIMediaSample"));
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        LogHResult(hr, LOG_STREAM, "DeliverInputSample", "CMediaBufferOnIMediaSample ctor");
        delete pBuffer;
        return hr;
    }

    if( m_pWrapperSecureChannel )
    {
        // encrypt the buffer pointer if this is a secure dmo
        CMediaBufferOnIMediaSample * pEncryptedBuffer = pBuffer;

        HRESULT hrSecure = m_pWrapperSecureChannel->WMSC_Encrypt(
                                   (BYTE *)&pEncryptedBuffer,
                                   sizeof(BYTE *) );
        LogHResult(hrSecure, LOG_SECURECHANNEL, "DeliverInputSample", "m_pWrapperSecureChannel->WMSC_Encrypt");
        if( SUCCEEDED( hrSecure ) )
        {
            // Deliver the buffer
            hr = TranslateDMOError(m_pMediaObject->ProcessInput(
                        ulInputIndex,
                        pEncryptedBuffer,
                        (bSyncPoint ? DMO_INPUT_DATA_BUFFERF_SYNCPOINT : 0) |
                        (bTimeStamp ? DMO_INPUT_DATA_BUFFERF_TIME : 0) |
                        (bTimeStamp ? DMO_INPUT_DATA_BUFFERF_TIMELENGTH : 0),
                        rtStart,
                        rtStop - rtStart));
        }
        else
        {
            // hmm, what should we do?
            hr = hrSecure; // ?
        }
    }
    else
    {
        // Deliver the buffer
        hr = TranslateDMOError(m_pMediaObject->ProcessInput(
                    ulInputIndex,
                    pBuffer,
                    (bSyncPoint ? DMO_INPUT_DATA_BUFFERF_SYNCPOINT : 0) |
                    (bTimeStamp ? DMO_INPUT_DATA_BUFFERF_TIME : 0) |
                    (bTimeStamp ? DMO_INPUT_DATA_BUFFERF_TIMELENGTH : 0),
                    rtStart,
                    rtStop - rtStart));
    }
    LogHResult(LOG_STREAM, 4, "DeliverInputSample", "IMediaObject::ProcessInput");
    pBuffer->Release();

    //  Handle flushing.  We test here so that if BeginFlush is
    //  called after we enter Receive() we still wind up flushing
    //  this buffer:
    //  Cases:
    //    1.  BeginFlush sets m_bFlushing before this line
    //        -- this is OK - we Flush()
    //    2.  BeginFlush sets m_bFlushing after this line
    //        -- this is OK - BeginFlush will call Flush()
    if (m_pInputPins[ulInputIndex]->m_bFlushing) {
        m_pMediaObject->Flush();
        hr = E_FAIL;
    }
    return hr;
}

// helper
void CMediaWrapperFilter::FreeOutputSamples() {
   LogPrivateEntry(LOG_STREAM,"FreeOutputSamples");
   for (DWORD c = 0; c < m_cOutputPins; c++) {
      if (m_pOutputPins[c]->m_pMediaSample) {
         if (m_pOutputPins[c]->m_fNeedToRelockSurface) {
             m_pOutputPins[c]->m_fNeedToRelockSurface = false;
             LockUnlockSurface(m_pOutputPins[c]->m_pMediaSample, true);
         }
         m_pOutputPins[c]->m_pMediaSample->Release();
         m_pOutputPins[c]->m_pMediaSample = NULL;
      }
   }
}
HRESULT CMediaWrapperFilter::SuckOutOutput(DiscardType bDiscard) {
    bool bOutputIncomplete;
    HRESULT hr;
    DWORD c;
    DWORD dwStatus;
    LogPrivateEntry(LOG_STREAM,"SuckOutOutput");
    for (c = 0; c < m_cOutputPins; c++) {
        // Initialize these so FreeOutputSamples() can work
        m_pOutputPins[c]->m_pMediaSample = NULL;
        // Initially all outputs need buffers because we just delivered new data
        if (m_pOutputPins[c]->IsConnected() && !(c == 0 && bDiscard == NullBuffer)) {
            m_pOutputPins[c]->m_fStreamNeedsBuffer = true;
        } else {
            m_pOutputPins[c]->m_fStreamNeedsBuffer = false;
        }
    }
    do { // do while incomplete

        bool bPrelock = false;

        // Prepare the output buffers
        for (c = 0; c < m_cOutputPins; c++) {
            // Does this output need a buffer ?
            if (m_pOutputPins[c]->m_fStreamNeedsBuffer) {
                DbgLog((LOG_STREAM,4,"output stream %lu needs a buffer", c));
                // Yes, make one
                // First check if the DMO insists on seeing the previous sample
                bool bUsePreviousSample = m_pOutputPins[c]->m_fNeedsPreviousSample;
                if (bUsePreviousSample) {
                    // ask if we could please use a different buffer this time
                    DWORD dwFlags;
                    hr = m_pDMOOutputOptimizations->GetCurrentSampleRequirements(c, &dwFlags);
                    if (SUCCEEDED(hr) && !(dwFlags & DMO_VOSF_NEEDS_PREVIOUS_SAMPLE)) {
                        bUsePreviousSample = false;
                    }
                }
                DWORD dwGBFlags = 0;
                if (bUsePreviousSample) {
                    dwGBFlags = AM_GBF_NOTASYNCPOINT; // this secretly means we want the same buffer
                    DbgLog((LOG_STREAM, 3, "Asking for the previous buffer again"));
                }
                hr = m_pOutputPins[c]->GetDeliveryBuffer(&(m_pOutputPins[c]->m_pMediaSample), NULL, NULL, dwGBFlags);
                LogHResult(hr, LOG_STREAM, "SuckOutOutput", "GetDeliveryBuffer");
                if (FAILED(hr)) {
                    FreeOutputSamples();
                    return hr;
                }

                BYTE *pData;
                hr = m_pOutputPins[c]->m_pMediaSample->GetPointer(&pData);
                LogHResult(hr, LOG_STREAM, "SuckOutOutput", "GetPointer");
                if (FAILED(hr)) {
                    FreeOutputSamples();
                    return hr;
                }

                //  Unlock prior to locking DMO
                if (m_pOutputPins[c]->m_fVideo) {
                    bool bNeedToRelock =
                        LockUnlockSurface(m_pOutputPins[c]->m_pMediaSample, false);
                    m_pOutputPins[c]->m_fNeedToRelockSurface = bNeedToRelock;
                    if (bNeedToRelock) {
                        bPrelock = true;
                    }
                } else {
                    m_pOutputPins[c]->m_fNeedToRelockSurface = false;
                }


                // check for dynamic output type change
                DMO_MEDIA_TYPE* pmt;
                hr = m_pOutputPins[c]->m_pMediaSample->GetMediaType(&pmt);
                if (hr == S_OK) {
                    DbgLog((LOG_CONNECT,2,"on-the-fly type change on output stream %lu", c));
                    hr = TranslateDMOError(m_pMediaObject->SetOutputType(c, pmt, 0));
                    LogHResult(hr, LOG_CONNECT, "SuckOutOutput", "IMediaObject::SetOutputType");
                    if (FAILED(hr)) {
                        FreeOutputSamples();
                        return hr;
                    }
                }

                m_pOutputPins[c]->m_MediaBuffer.Init(pData, m_pOutputPins[c]->m_pMediaSample->GetSize());
                m_OutputBufferStructs[c].pBuffer = &(m_pOutputPins[c]->m_MediaBuffer);

            }
            else { // No, this output does not need a buffer
                m_OutputBufferStructs[c].pBuffer = NULL;
            }
        }

        //  Do prelocking - this is all to get round ddraw surface
        //  locking issues - we want the surface locked after
        //  the DMO lock in case the DMO calls ddraw or something

        if (bPrelock) {
            m_pMediaObject->Lock(TRUE);

            //  Relock all the samples
            for (DWORD c = 0; c < m_cOutputPins; c++) {
                if (m_pOutputPins[c]->m_fNeedToRelockSurface) {
                    m_pOutputPins[c]->m_fNeedToRelockSurface = false;
                    if (!LockUnlockSurface(m_pOutputPins[c]->m_pMediaSample, true)) {
                        DbgLog((LOG_STREAM, 1, TEXT("Failed to relock surface")));
                        m_pMediaObject->Lock(FALSE);
                        FreeOutputSamples();
                        return E_FAIL;
                    }
                }
            }
        }

        if( m_pWrapperSecureChannel )
        {
            // encrypt the buffer pointer if this is a secure dmo
            DMO_OUTPUT_DATA_BUFFER * pEncryptedOutputBufferStructs = m_OutputBufferStructs;

            HRESULT hrSecure = m_pWrapperSecureChannel->WMSC_Encrypt(
                                        (BYTE *)&pEncryptedOutputBufferStructs,
                                        sizeof(BYTE *) );
            LogHResult(hrSecure, LOG_SECURECHANNEL, "SuckOutOutput", "m_pWrapperSecureChannel->WMSC_Encrypt");
            if( SUCCEEDED( hrSecure ) )
            {
                // call process using encrypted buffer ptr
                hr = TranslateDMOError(m_pMediaObject->ProcessOutput(
                                             DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER,
                                             m_cOutputPins,
                                             pEncryptedOutputBufferStructs,
                                             &dwStatus));
            }
            else
            {
                m_fErrorSignaled = TRUE;
                NotifyEvent( EC_ERRORABORT, hrSecure, 0 );
                return hrSecure;
            }
        }
        else
        {
            // call process
            hr = TranslateDMOError(m_pMediaObject->ProcessOutput(
                                         DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER,
                                         m_cOutputPins,
                                         m_OutputBufferStructs,
                                         &dwStatus));
        }

        if (bPrelock) {
            m_pMediaObject->Lock(FALSE);
        }
        LogHResult(hr, LOG_STREAM, "SuckOutOutput", "IMediaObject::ProcessOutput");
        if (FAILED(hr))
        {
            FreeOutputSamples();
            if( E_OUTOFMEMORY == hr )
            {
                //
                // abort on critical dmo failures only (it's still unclear what these are)
                //
                m_fErrorSignaled = TRUE;
                NotifyEvent( EC_ERRORABORT, hr, 0 );
                return hr;
            }
            else
            {
                //
                // in most cases the dmo can continue to receive samples (for instance on E_FAIL),
                // so just eat the error and return
                //
                return S_OK;
            }
        }

        // See what the object produced
        bOutputIncomplete = false;
        for (c = 0; c < m_cOutputPins; c++) {
            // Did we supply a buffer ?
            if (m_OutputBufferStructs[c].pBuffer) {

                // Migrate IMediaSample members to the IMediaBuffer
                if (m_OutputBufferStructs[c].dwStatus & DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT) {
                    m_pOutputPins[c]->m_pMediaSample->SetSyncPoint(TRUE);
                }
                if (m_OutputBufferStructs[c].dwStatus & DMO_OUTPUT_DATA_BUFFERF_TIME) {
                    if (m_OutputBufferStructs[c].dwStatus & DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH) {
                        m_OutputBufferStructs[c].rtTimelength += m_OutputBufferStructs[c].rtTimestamp;
                        m_pOutputPins[c]->m_pMediaSample->SetTime(&m_OutputBufferStructs[c].rtTimestamp, &m_OutputBufferStructs[c].rtTimelength);
                    }
                    else {
                        m_pOutputPins[c]->m_pMediaSample->SetTime(&m_OutputBufferStructs[c].rtTimestamp, NULL);
                    }
                }

                ULONG ulProduced;
                m_OutputBufferStructs[c].pBuffer->GetBufferAndLength(NULL, &ulProduced);
                DbgLog((LOG_STREAM, 4, "output stream %lu produced %lu bytes", c, ulProduced));
                if (ulProduced && (bDiscard == KeepOutput || c != 0)) {
                    m_pOutputPins[c]->m_pMediaSample->SetActualDataLength(ulProduced);
                    // Deliver
                    hr = m_pOutputPins[c]->Deliver(m_pOutputPins[c]->m_pMediaSample);
                    LogHResult(hr, LOG_STREAM, "SuckOutOutput", "Deliver");
                    if( S_OK != hr )
                    {
                        FreeOutputSamples();
                        return hr;
                    }
                }
                m_pOutputPins[c]->m_pMediaSample->Release();
                m_pOutputPins[c]->m_pMediaSample = NULL;
            }
            // check INCOMPLETE, even if it was previously set
            if ((m_OutputBufferStructs[c].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) &&
                m_pOutputPins[c]->IsConnected() && !(c == 0 && bDiscard == NullBuffer)) {
                DbgLog((LOG_STREAM, 4, "Output stream %lu is incomplete", c));
                m_pOutputPins[c]->m_fStreamNeedsBuffer = true;
                bOutputIncomplete = true;
            }
            else
                m_pOutputPins[c]->m_fStreamNeedsBuffer = false;
        }

    } while (bOutputIncomplete);
    return NOERROR;
}

//
// BUGBUG: implement these queue methods for real
//
HRESULT CMediaWrapperFilter::EnqueueInputSample(ULONG ulInputIndex,
                                             IMediaSample *pSample) {
   LogPrivateEntry(LOG_STREAM, "EnqueueInputSample");
   return E_NOTIMPL;
   // pSample->AddRef();
}
IMediaSample* CMediaWrapperFilter::DequeueInputSample(ULONG ulInputIndex) {
   LogPrivateEntry(LOG_STREAM, "DequeueInputSample");
   return NULL;
   // pSample->Release();
}
bool CMediaWrapperFilter::InputQueueEmpty(ULONG ulInputIndex) {
   LogPrivateEntry(LOG_STREAM, "InputQueueEmpty");
   return true;
}

HRESULT CMediaWrapperFilter::InputNewSegment
(
    ULONG ulInputIndex,
    REFERENCE_TIME tStart,
    REFERENCE_TIME tStop,
    double dRate
)
{
    LogPrivateEntry(LOG_STREAM, "InputNewSegment");
    CAutoLock lck(&m_csStreaming);

    HRESULT hr = S_OK;
    for (DWORD cOut = 0; cOut < m_cOutputPins; cOut++)
    {
        if (InputMapsToOutput(ulInputIndex, cOut))
        {
            hr = m_pOutputPins[cOut]->DeliverNewSegment(tStart, tStop, dRate);

            // just log any error and continue
            LogHResult(hr, LOG_STREAM, "InputNewSegment", "DeliverNewSegment");
        }
    }
    hr = m_pInputPins[ulInputIndex]->CBaseInputPin::NewSegment(tStart, tStop, dRate);
    LogHResult(hr, LOG_STREAM, "InputNewSegment", "CBaseInputPin::NewSegment");
    return hr;
}

void CMediaWrapperFilter::PropagateAnyEOS() {
   LogPrivateEntry(LOG_STREAM, "PropagateAnyEOS");
   // check every output pin
   for (DWORD cOut = 0; cOut < m_cOutputPins; cOut++) {
      // Have we already delivered an EOS on this output pin ?
      if (m_pOutputPins[cOut]->m_fEOS) {
         continue; // Yes, don't bother with this pin anymore.
         DbgLog((LOG_STATE,4,"EndOfStream already delivered on output stream %lu", cOut));
      }

      // check if all inputs connected to this output are done
      bool bEOSOnEveryConnectedInput = true;
      for (DWORD cIn = 0; cIn < m_cInputPins; cIn++) {
         if (InputMapsToOutput(cIn, cOut) &&
             !(m_pInputPins[cIn]->m_fEOS && InputQueueEmpty(cIn))
            ) { // some input not complete yet
            bEOSOnEveryConnectedInput = false;
            break;
         }
      }
      if (!bEOSOnEveryConnectedInput) {
         DbgLog((LOG_STATE, 5, "some input connected to output stream %lu has yet to receive an EOS", cOut));
         continue; // not yet, better luck next time
      }

      // deliver output EOS
      HRESULT hr;
      hr = m_pOutputPins[cOut]->DeliverEndOfStream(); // bugbug - retval ?
      LogHResult(hr, LOG_STATE, "PropagateAnyEOS", "DeliverEndOfStream");
      m_pOutputPins[cOut]->m_fEOS = true;
   }
}

HRESULT CMediaWrapperFilter::NewSample(ULONG ulInputIndex, IMediaSample *pSample)
{
   HRESULT hr;
   LogPublicEntry(LOG_STREAM, "NewSample");
   if( m_fErrorSignaled )
   {
      return S_FALSE;
   }

   ASSERT(ulInputIndex < m_cInputPins);

   { // stream lock scope
      CAutoLock lck(&(m_pInputPins[ulInputIndex]->m_csStream));

      hr = m_pInputPins[ulInputIndex]->CBaseInputPin::Receive(pSample);
      LogHResult(hr, LOG_STREAM, "NewSample", "CBaseInputPin::Receive");
      if (S_OK != hr) {
         return hr;
      }

      if (m_pInputPins[ulInputIndex]->m_fEOS) { // we have already received EOS on this input
         DbgLog((LOG_STREAM | LOG_STATE, 2, "Receive() after EOS on input stream %lu - rejecting !", ulInputIndex));
         return S_FALSE; // should this be a hard errror ?
      }
   }

   DbgLog((LOG_STREAM, 4, "Receive() on input stream %lu", ulInputIndex));

    CAutoLock lck(&m_csStreaming);

    // Is the stream ready to accept input ?
    DWORD dwStatus;
    DWORD c;
    hr = TranslateDMOError(m_pMediaObject->GetInputStatus(ulInputIndex, &dwStatus));
    LogHResult(hr, LOG_STREAM, "NewSample", "IMediaObject::GetInputStatus");
    if (FAILED(hr)) {
       return hr;
    }
    if (dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA) {

       // If the input stream became ready for data at some point and we
       // already had data waitingin q queue, we should have delivered that
       // data right then (see code below).  The assumption is that an input
       // stream can only become ready for input due to a ProcessInput() or
       // ProcessOutput() call.
       ASSERT(InputQueueEmpty(ulInputIndex));

       // Yes - deliver the sample
       hr = DeliverInputSample(ulInputIndex, pSample);
       LogHResult(hr, LOG_STREAM, "NewSample", "DeliverInputSample");
       if (FAILED(hr)) {
          return hr;
       }

       if (hr == S_FALSE) // S_FALSE means no new output is available, thus
          return NOERROR; // no need to do the SuckOutOutput loop below.

       //  Suck the output
       DiscardType bDiscard = KeepOutput;

       //  We discard the output for output stream 0 for preroll data for
       //  video decoders
       if (0 != (m_pInputPins[ulInputIndex]->SampleProps()->dwSampleFlags & AM_SAMPLE_PREROLL) &&
           m_guidCat == DMOCATEGORY_VIDEO_DECODER) {
           bDiscard = DiscardOutput; // Discard it ourselves
           //  Can't discard non-discardable streams
           DWORD dwFlags;
           if (SUCCEEDED(TranslateDMOError(m_pMediaObject->GetOutputStreamInfo(0, &dwFlags)))) {
               if (dwFlags & (DMO_OUTPUT_STREAMF_OPTIONAL |
                              DMO_OUTPUT_STREAMF_DISCARDABLE)) {
                   bDiscard = NullBuffer; // Pass a NULL buffer to the decoder
               }
           }
       }

#ifdef DEBUG
        if (bDiscard) {
            DbgLog((LOG_TRACE, 2, TEXT("Discarding")));
        }
#endif

       //
       // Now Repeatedly call ProcessOutput() until no output is incomplete.
       // Even after we've sucked out all output produced from the current
       // input, we may still have additional data waiting in some other
       // stream's input queue.  In that case we deliver that data and repeat
       // the process of sucking out output.
       //
       bool bNewInput;
       do { // while new input
          hr = SuckOutOutput(bDiscard);
          LogHResult(hr, LOG_STREAM, "NewSample", "SuckOutOutput");
          if (FAILED(hr))
             return hr;
          bNewInput = false; // we just called ProcessOutput

          // Check if we can now deliver something waiting in an input queue
          for (c = 0; c < m_cInputPins; c++) {
             // Data waiting on this stream ?
             if (!InputQueueEmpty(c)) {
                DbgLog((LOG_STREAM,4,"Input stream %lu has data waiting in the input queue", c));
                // Yes there is data, but is the object ready for it ?
                hr = TranslateDMOError(m_pMediaObject->GetInputStatus(c, &dwStatus));
                LogHResult(hr, LOG_STREAM | LOG_STATE, "NewSample", "GetInputStatus2");
                if (FAILED(hr)) {
                   return hr;
                }
                if (dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA) {
                   DbgLog((LOG_STREAM,4,"inputstream %lu is accepting", c));
                   // Object is now ready - deliver !
                   hr = DeliverInputSample(c, DequeueInputSample(c));
                   LogHResult(hr, LOG_STREAM, "NewSample", "DeliverInputSample2");
                   if (FAILED(hr)) {
                      return hr;
                   }
                   bNewInput = true;
                } // if stream ready
                else {
                   DbgLog((LOG_STREAM,4,"data in the queue but the DMO is not accepting on input stream %lu", c));
                }
             } // if data in queue
          } // for all input streams
       } while (bNewInput);

       // Two things are true when we are here: (1) no output is incomplete,
       // and (2) we just processed all input queues as far as possible w/o
       // additional input.  That makes this a good place to check EOS.
       PropagateAnyEOS();

       return NOERROR;
    } // if current input ready for data
    else {
       DbgLog((LOG_STREAM | LOG_STATE, 2, "Input stream %u is not accepting - the sample will be put in the queue", ulInputIndex));
       return EnqueueInputSample(ulInputIndex, pSample);
    }
}


bool CMediaWrapperFilter::InputMapsToOutput(
    ULONG ulInputIndex,
    ULONG ulOutputIndex
)
{
    //  BUGBUG fix!
    return true;
}

HRESULT CMediaWrapperFilter::EndOfStream(ULONG ulInputIndex)
{
    HRESULT hr;

    LogPublicEntry(LOG_STATE, "EndOfStream");
    //
    // Stream specific part
    //
    { // stream lock scope
       CAutoLock l(&(m_pInputPins[ulInputIndex]->m_csStream));

       // Are we stopped or something?
       HRESULT hr = m_pInputPins[ulInputIndex]->CBaseInputPin::CheckStreaming();
       if (S_OK != hr) {
           return hr;
       }

       // Ignore any EOS calls on the same stream after the first one
       if (m_pInputPins[ulInputIndex]->m_fEOS) {
          DbgLog((LOG_STATE,2,"Ignoring redundant EndOfStream() on stream %lu", ulInputIndex));
          return NOERROR; // we've already see one of those, thank you
       }
       m_pInputPins[ulInputIndex]->m_fEOS = true;
    }
    DbgLog((LOG_STATE,3,"EndOfStream() on input stream %lu", ulInputIndex));

    // BUGBUG: the rest of what this function does should happen only
    // *after* delivering any samples still stuck in the input queues.

    // Put code here to deliver the contents of each input stream's queue !
    // Remember to call SuckOutOutput() after delivering every input sample.

    // Note that nothing can ever end up in the queue if there is only one
    // input stream.


    //
    // Object global part
    //
    CAutoLock l2(&m_csStreaming);

    // Process the EOS
    hr = TranslateDMOError(m_pMediaObject->Discontinuity(ulInputIndex));
    LogHResult(hr, LOG_STATE,"EndOfStream", "IMediaObject::Discontinuity");
    if (FAILED(hr)) {
       return hr;
    }

    hr = SuckOutOutput();
    LogHResult(hr, LOG_STATE,"EndOfStream", "SuckOutOutput");
    if (FAILED(hr)) {
       return hr;
    }

    // Flush the object if this was the last input EOS
    bool bSomeInputStillIncomplete = false;
    for (DWORD c = 0; c < m_cInputPins; c++) {
       if (!m_pInputPins[c]->m_fEOS) {
          bSomeInputStillIncomplete = true;
          break;
       }
    }
    if (!bSomeInputStillIncomplete) {
       hr = TranslateDMOError(m_pMediaObject->Flush());
       LogHResult(hr,LOG_STREAM,"EndOfStream","IMediaObject::Flush");
    }
    else {
       DbgLog((LOG_STATE,4,"EndOfStream(): some input still incomplete - not flushing yet"));
    }

    PropagateAnyEOS();

    return NOERROR;
}

HRESULT CMediaWrapperFilter::BeginFlush(ULONG ulInputIndex)
{
    //
    // BUGBUG: synchronize with input queues !  (multiple input stream case only)
    //

    LogPublicEntry(LOG_STATE, "BeginFlush");
    ASSERT(ulInputIndex < m_cInputPins);
    DbgLog((LOG_STATE,3,"BeginFlush() on input stream %lu", ulInputIndex));
    HRESULT hr = m_pInputPins[ulInputIndex]->CBaseInputPin::BeginFlush();
    LogHResult(hr, LOG_STATE, "BeginFlush", "CBaseInputPin::BeginFlush");

    //  Need to also flush the object as not doing so could cause
    //  upstream filters to block
    //  Note also that bacause of the loose synchronization this also
    //  needs to be done after ProcessInput if we're flushing (see
    //  coments in side DeliverInputSample).
    m_pMediaObject->Flush();

    m_fErrorSignaled = FALSE;

    //  Propagate it to all output pins
    for (ULONG ulOutputIndex = 0; ulOutputIndex < m_cOutputPins; ulOutputIndex++) {
        if (InputMapsToOutput(ulInputIndex, ulOutputIndex)) {
            //  Decommit it's allocator
            hr = m_pOutputPins[ulOutputIndex]->DeliverBeginFlush();
            LogHResult(hr, LOG_STATE, "BeginFlush", "DeliverBeginFlush");
        }
    }
    return S_OK;
}

HRESULT CMediaWrapperFilter::EndFlush(ULONG ulInputIndex)
{
    LogPublicEntry(LOG_STATE, "EndFlush");
    ASSERT(ulInputIndex < m_cInputPins);
    DbgLog((LOG_STATE,3,"EndFlush() on input stream %lu", ulInputIndex));
    HRESULT hr;
    {
       CAutoLock l(&m_csStreaming);
       m_pMediaObject->Flush();

       //  Propagate it to all output pins
       for (ULONG ulOutputIndex = 0; ulOutputIndex < m_cOutputPins; ulOutputIndex++) {
           if (InputMapsToOutput(ulInputIndex, ulOutputIndex)) {
               //  Clear end of stream condition on this output pin
               //  and propagate flush
               m_pOutputPins[ulOutputIndex]->m_fEOS = false;
               hr = m_pOutputPins[ulOutputIndex]->DeliverEndFlush();
               LogHResult(hr, LOG_STATE, "EndFlush", "DeliverEndFlush");
           }
       }
    }

    // BUGBUG - lock the stream !
    m_pInputPins[ulInputIndex]->m_fEOS = false;
    hr = m_pInputPins[ulInputIndex]->CBaseInputPin::EndFlush();
    LogHResult(hr, LOG_STATE, "EndFlush", "CBaseInputPin::EndFlush");

    return S_OK;
}

HRESULT CMediaWrapperFilter::NonDelegatingQueryInterface(REFGUID riid, void **ppv) {
   LogPublicEntry(LOG_INIT, "NonDelegatingQueryInterface");
   if (riid == IID_IDMOWrapperFilter) {
      return GetInterface((IDMOWrapperFilter*)this, ppv);
   }
   if (riid == IID_IPersistStream) {
      return GetInterface((IPersistStream*)this, ppv);
   }

   if (SUCCEEDED(CBaseFilter::NonDelegatingQueryInterface(riid, ppv))) {
      return NOERROR;
   }

   if (m_pMediaObject) { // bugbug: conditional QI behavior is bad COM
      if (SUCCEEDED(m_pDMOUnknown->QueryInterface(riid, ppv)))
         return NOERROR;
   }

   return E_NOINTERFACE;
}

// IPersistStream
HRESULT CMediaWrapperFilter::IsDirty() {
   return S_OK; // bugbug
}
HRESULT CMediaWrapperFilter::Load(IStream *pStm) {

   CLSID clsidDMOFromStream;
   HRESULT hr = pStm->Read(&clsidDMOFromStream, sizeof(CLSID), NULL);
   if (FAILED(hr)) {
      return hr;
   }
   CLSID guidCatFromStream;
   hr = pStm->Read(&guidCatFromStream, sizeof(CLSID), NULL);
   if (FAILED(hr)) {
      return hr;
   }

   if( !m_pDMOUnknown )
   {
       // only necessary if object hasn't been created yet!
       hr = Init(clsidDMOFromStream, guidCatFromStream);
   }
   else if( ( m_clsidDMO != clsidDMOFromStream ) || 
            ( m_guidCat != guidCatFromStream ) )
   {
       ASSERT( ( m_clsidDMO == clsidDMOFromStream ) && ( m_guidCat == guidCatFromStream ) );
       DbgLog((LOG_TRACE,1,"ERROR: Invalid IStream ptr passed to Load method!"));
       hr = E_UNEXPECTED;
   }   
   
   if (SUCCEEDED(hr)) {
       //  Let the DMO return its data
       CComQIPtr<IPersistStream> pPersist(m_pDMOUnknown);
       if (pPersist != NULL && pPersist != static_cast<IPersistStream *>(this)) {
           hr = pPersist->Load(pStm);
           if (E_NOTIMPL == hr) {
               hr = S_OK;
           }
       }
   }
   return hr;
}
HRESULT CMediaWrapperFilter::Save(IStream *pStm, BOOL fClearDirty) {
   HRESULT hr = pStm->Write(&m_clsidDMO, sizeof(CLSID), NULL);
   if (SUCCEEDED(hr)) {
       HRESULT hr = pStm->Write(&m_guidCat, sizeof(CLSID), NULL);
   }
   //  Let the DMO return its data
   CComQIPtr<IPersistStream> pPersist(m_pDMOUnknown);
   if (pPersist != NULL && pPersist != static_cast<IPersistStream *>(this)) {
       hr = pPersist->Save(pStm, fClearDirty);
       if (E_NOTIMPL == hr) {
           hr = S_OK;
       }
   }
   return hr;
}
HRESULT CMediaWrapperFilter::GetSizeMax(ULARGE_INTEGER *pcbSize) {
   return sizeof(CLSID);
}
HRESULT CMediaWrapperFilter::GetClassID(CLSID *clsid) {
   CheckPointer(clsid, E_POINTER);
   *clsid = CLSID_DMOWrapperFilter;
   return S_OK;
}


//
// CreateInstance
//
// Provide the way for COM to create a CNullNull object
CUnknown * WINAPI CMediaWrapperFilter::CreateInstance(
    LPUNKNOWN punk,
    HRESULT *phr)
{
    return new CMediaWrapperFilter(punk, phr);
}


HRESULT TranslateDMOError(HRESULT hr)
{
    switch (hr) {
    case DMO_E_INVALIDSTREAMINDEX:
        hr = E_UNEXPECTED;
        break;

    case DMO_E_INVALIDTYPE:
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        break;

    case DMO_E_TYPE_NOT_SET:
        hr = E_UNEXPECTED;
        break;

    case DMO_E_NOTACCEPTING:
        hr = VFW_E_WRONG_STATE;
        break;

    case DMO_E_TYPE_NOT_ACCEPTED:
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        break;

    case DMO_E_NO_MORE_ITEMS:
        hr = E_INVALIDARG;
        break;

    }
    return hr;
}

#ifdef FILTER_DLL
//  Stuff to make this a dshow dll
// Needed for the CreateInstance mechanism
CFactoryTemplate g_Templates[]= {
    { L"DirectShow Media Object Wrapper Filter"
        , &CLSID_DMOWrapperFilter
        , CMediaWrapperFilter::CreateInstance
        , NULL
        , NULL
    },
};

int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif // FILTER_DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\dmo\wrapper\outpin.cpp ===
#include <wchar.h>
#include <streams.h>
#include <atlbase.h>
#include <wmsecure.h>
#include <dmoreg.h>
#include <mediaerr.h>
#include "mediaobj.h"
#include "dmodshow.h"
#include "filter.h"
#include "inpin.h"
#include "outpin.h"
#include "wmcodecstrs.h" // from wm encoder group, not public currently

CWrapperOutputPin::CWrapperOutputPin(
    CMediaWrapperFilter *pFilter,
    ULONG Id,
    BOOL bOptional,
    HRESULT *phr) :
    CBaseOutputPin(NAME("CWrapperOutputPin"),
                   pFilter,
                   pFilter->FilterLock(),
                   phr,
                   _PinName_(bOptional ? L"~out" : L"out", Id).Name()
                  ),
    m_Id(Id),
    m_fNoPosPassThru(FALSE),
    m_pPosPassThru(NULL),
    m_pMediaSample(NULL),
    // compression setting default values, move to struct eventually
    m_lQuality( -1 ),
    m_lKeyFrameRate( -1 ),
    m_bUseIAMStreamConfigOnDMO( false ),
    m_bUseIAMVideoCompressionOnDMO( false ),
    m_pmtFromSetFormat( NULL )
{
}

CWrapperOutputPin::~CWrapperOutputPin() {
    delete m_pPosPassThru;

    if( m_pmtFromSetFormat )
    {
        // clean up any media type we might have cached from a SetFormat call
        DeleteMediaType( m_pmtFromSetFormat );
    }
}

HRESULT CWrapperOutputPin::NonDelegatingQueryInterface(REFGUID riid, void **ppv) {
    if (SUCCEEDED(CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv)))
        return NOERROR;

    if ((riid == IID_IMediaPosition) || (riid == IID_IMediaSeeking)) {
        CAutoLock l(&m_csPassThru);

        // The first time we get here, we attempt to create a CPosPassThru
        // object.  If we succeed, we use the object in all subsequent QI
        // calls.  If we fail, we set m_fNoPassThru to TRUE so that we never
        // try again.  Trying again and succeeding would violate COM rules.
        if (m_fNoPosPassThru)
            return E_NOINTERFACE;

        // Create a CPosPassThru if we don't have one already
        if (!m_pPosPassThru) {
            CWrapperInputPin* pInPin = Filter()->GetInputPinForPassThru();
            if (pInPin) {
                HRESULT hr = S_OK;
                m_pPosPassThru = new CPosPassThru(TEXT("DMO wrapper PosPassThru"),
                                                (IPin*)this,
                                                &hr,
                                                pInPin);
                if (m_pPosPassThru && (FAILED(hr))) {
                    delete m_pPosPassThru;
                    m_pPosPassThru = NULL;
                }
            }
        }

        if (m_pPosPassThru) {
            return m_pPosPassThru->NonDelegatingQueryInterface(riid, ppv);
        }
        else {
            m_fNoPosPassThru = TRUE;
            return E_NOINTERFACE;
        }
    }
    else if (riid == IID_IAMStreamConfig )
    {
        // we support this interface for audio and video encoders
        if (IsAudioEncoder() || IsVideoEncoder() )
        {   
            if( 0 == m_Id && !m_bUseIAMStreamConfigOnDMO )
            {         
                // first check whether the dmo supports this natively and cache the interface pointer if so
                // BUGBUG needs to be per output stream!!
                // for now fail only ask if 1st output stream
                CComQIPtr< IAMStreamConfig, &IID_IAMStreamConfig > pStreamConfigOnDMO( Filter()->m_pMediaObject );
                if( pStreamConfigOnDMO )
                {
                    // so it is supported natively, but we must release it since it winds up addref'ing the filter
                    m_bUseIAMStreamConfigOnDMO = true;
                    DbgLog((LOG_TRACE,3,TEXT("CWrapperOutputPin::NonDelegatingQI - DMO supports IAMStreamConfig natively")));
                }
            }
            // either way it'll go through us
            return GetInterface( static_cast<IAMStreamConfig *> (this), ppv );
        }            
    }
    else if (riid == IID_IAMVideoCompression )
    {
        // we support this interface for video encoders
        if ( IsVideoEncoder() )
        {      
            if( 0 == m_Id && !m_bUseIAMVideoCompressionOnDMO )
            {         
