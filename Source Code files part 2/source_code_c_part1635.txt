t(enc, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cif4MPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cif16MPI - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureClockFrequency(ASN1decoding_t dec, CustomPictureClockFrequency *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 1, &(val)->clockConversionCode))
	return 0;
    (val)->clockConversionCode += 1000;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->clockDivisor))
	return 0;
    (val)->clockDivisor += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat(ASN1encoding_t enc, CustomPictureFormat *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxCustomPictureWidth - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxCustomPictureHeight - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->minCustomPictureWidth - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->minCustomPictureHeight - 1))
	return 0;
    if (!ASN1Enc_CustomPictureFormat_mPI(enc, &(val)->mPI))
	return 0;
    if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation(enc, &(val)->pixelAspectInformation))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat(ASN1decoding_t dec, CustomPictureFormat *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxCustomPictureWidth))
	return 0;
    (val)->maxCustomPictureWidth += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxCustomPictureHeight))
	return 0;
    (val)->maxCustomPictureHeight += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->minCustomPictureWidth))
	return 0;
    (val)->minCustomPictureWidth += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->minCustomPictureHeight))
	return 0;
    (val)->minCustomPictureHeight += 1;
    if (!ASN1Dec_CustomPictureFormat_mPI(dec, &(val)->mPI))
	return 0;
    if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation(dec, &(val)->pixelAspectInformation))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat(CustomPictureFormat *val)
{
    if (val) {
	ASN1Free_CustomPictureFormat_mPI(&(val)->mPI);
	ASN1Free_CustomPictureFormat_pixelAspectInformation(&(val)->pixelAspectInformation);
    }
}

static int ASN1CALL ASN1Enc_H263ModeComboFlags(ASN1encoding_t enc, H263ModeComboFlags *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->deblockingFilterMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->referencePicSelect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reducedResolutionUpdate))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modifiedQuantizationMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263ModeComboFlags(ASN1decoding_t dec, H263ModeComboFlags *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->deblockingFilterMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->referencePicSelect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reducedResolutionUpdate))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modifiedQuantizationMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCCapability(ASN1encoding_t enc, G7231AnnexCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(enc, &(val)->g723AnnexCAudioMode))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCCapability(ASN1decoding_t dec, G7231AnnexCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(dec, &(val)->g723AnnexCAudioMode))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling16k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling22k05))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling24k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels2_1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels3_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_0_2_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels3_1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_0_2_0))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling16k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling22k05))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling24k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels2_1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels3_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_0_2_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels3_1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_0_2_0))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_GSMAudioCapability(ASN1encoding_t enc, GSMAudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->audioUnitSize - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->comfortNoise))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->scrambled))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GSMAudioCapability(ASN1decoding_t dec, GSMAudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->audioUnitSize))
	return 0;
    (val)->audioUnitSize += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->comfortNoise))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->scrambled))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V42bis(ASN1encoding_t enc, V42bis *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->numberOfCodewords - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumStringLength - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V42bis(ASN1decoding_t dec, V42bis *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->numberOfCodewords))
	return 0;
    (val)->numberOfCodewords += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumStringLength))
	return 0;
    (val)->maximumStringLength += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_T84Profile_t84Restricted(enc, &(val)->u.t84Restricted))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_T84Profile_t84Restricted(dec, &(val)->u.t84Restricted))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_ConferenceCapability_nonStandardData(enc, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->chairControlCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->videoIndicateMixingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConferenceCapability_nonStandardData(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->chairControlCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->videoIndicateMixingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConferenceCapability_nonStandardData(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_Q2931Address_address(enc, &(val)->address))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_Q2931Address_address(dec, &(val)->address))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val)
{
    if (val) {
	ASN1Free_Q2931Address_address(&(val)->address);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeaderPresent))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeaderPresent))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->subChannelID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->pcr_pid))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->programDescriptors))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->streamDescriptors))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->subChannelID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->pcr_pid))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->programDescriptors))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->streamDescriptors))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->programDescriptors);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->streamDescriptors);
	}
    }
}

static int ASN1CALL ASN1Enc_H223AL2MParameters(ASN1encoding_t enc, H223AL2MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL2MParameters_headerFEC(enc, &(val)->headerFEC))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL2MParameters(ASN1decoding_t dec, H223AL2MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL2MParameters_headerFEC(dec, &(val)->headerFEC))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCArqParameters(ASN1encoding_t enc, H223AnnexCArqParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(enc, &(val)->numberOfRetransmissions))
	return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCArqParameters(ASN1decoding_t dec, H223AnnexCArqParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(dec, &(val)->numberOfRetransmissions))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EscrowData(ASN1encoding_t enc, EscrowData *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->escrowID))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->escrowValue).length - 1))
	return 0;
    if (!ASN1PEREncBits(enc, ((val)->escrowValue).length, ((val)->escrowValue).value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EscrowData(ASN1decoding_t dec, EscrowData *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->escrowID))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->escrowValue).length))
	return 0;
    ((val)->escrowValue).length += 1;
    if (!ASN1PERDecBits(dec, ((val)->escrowValue).length, &((val)->escrowValue).value))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EscrowData(EscrowData *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->escrowID);
	ASN1bitstring_free(&(val)->escrowValue);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_OpenLogicalChannelReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannelReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_CloseLogicalChannel_source(enc, &(val)->source))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_CloseLogicalChannel_reason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_CloseLogicalChannel_source(dec, &(val)->source))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_CloseLogicalChannel_reason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_RequestChannelCloseReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_RequestChannelCloseReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(enc, &(val)->multiplexEntryDescriptors))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(dec, &(val)->multiplexEntryDescriptors))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(&(val)->multiplexEntryDescriptors);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val)
{
    if (!ASN1Enc_MultiplexElement_type(enc, &(val)->type))
	return 0;
    if (!ASN1Enc_MultiplexElement_repeatCount(enc, &(val)->repeatCount))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val)
{
    if (!ASN1Dec_MultiplexElement_type(dec, &(val)->type))
	return 0;
    if (!ASN1Dec_MultiplexElement_repeatCount(dec, &(val)->repeatCount))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val)
{
    if (val) {
	ASN1Free_MultiplexElement_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if (!ASN1Enc_MultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_MultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntry_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntry_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntry_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryAck_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryAck_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryAck_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryRelease_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestMode_requestedModes(enc, &(val)->requestedModes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestMode_requestedModes(dec, &(val)->requestedModes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode(RequestMode *val)
{
    if (val) {
	ASN1Free_RequestMode_requestedModes(&(val)->requestedModes);
    }
}

static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestModeAck_response(enc, &(val)->response))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestModeAck_response(dec, &(val)->response))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_RequestModeReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_RequestModeReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H261VideoMode_resolution(enc, &(val)->resolution))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H261VideoMode_resolution(dec, &(val)->resolution))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1Enc_H262VideoMode_profileAndLevel(enc, &(val)->profileAndLevel))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1Dec_H262VideoMode_profileAndLevel(dec, &(val)->profileAndLevel))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	l = ASN1uint32_uoctets((val)->videoBitRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->vbvBufferSize);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->luminanceSampleRate);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_audioLayer(enc, &(val)->audioLayer))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_audioSampling(enc, &(val)->audioSampling))
	return 0;
    if (!ASN1Enc_IS11172AudioMode_multichannelType(enc, &(val)->multichannelType))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_audioLayer(dec, &(val)->audioLayer))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_audioSampling(dec, &(val)->audioSampling))
	return 0;
    if (!ASN1Dec_IS11172AudioMode_multichannelType(dec, &(val)->multichannelType))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_audioLayer(enc, &(val)->audioLayer))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_audioSampling(enc, &(val)->audioSampling))
	return 0;
    if (!ASN1Enc_IS13818AudioMode_multichannelType(enc, &(val)->multichannelType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_audioLayer(dec, &(val)->audioLayer))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_audioSampling(dec, &(val)->audioSampling))
	return 0;
    if (!ASN1Dec_IS13818AudioMode_multichannelType(dec, &(val)->multichannelType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCMode(ASN1encoding_t enc, G7231AnnexCMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	return 0;
    if (!ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(enc, &(val)->g723AnnexCAudioMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCMode(ASN1decoding_t dec, G7231AnnexCMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
	return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	return 0;
    if (!ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(dec, &(val)->g723AnnexCAudioMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopRequest_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopRequest_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopAck_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopAck_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_MaintenanceLoopReject_type(enc, &(val)->type))
	return 0;
    if (!ASN1Enc_MaintenanceLoopReject_cause(enc, &(val)->cause))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_MaintenanceLoopReject_type(dec, &(val)->type))
	return 0;
    if (!ASN1Dec_MaintenanceLoopReject_cause(dec, &(val)->cause))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CommunicationModeCommand_communicationModeTable(enc, &(val)->communicationModeTable))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CommunicationModeCommand_communicationModeTable(dec, &(val)->communicationModeTable))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val)
{
    if (val) {
	ASN1Free_CommunicationModeCommand_communicationModeTable(&(val)->communicationModeTable);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CommunicationModeResponse_communicationModeTable(enc, &(val)->u.communicationModeTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CommunicationModeResponse_communicationModeTable(dec, &(val)->u.communicationModeTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_CommunicationModeResponse_communicationModeTable(&(val)->u.communicationModeTable);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Criteria(ASN1encoding_t enc, Criteria *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->field))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->value, 1, 65535, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Criteria(ASN1decoding_t dec, Criteria *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->field))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->value, 1, 65535, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Criteria(Criteria *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->field);
    }
}

static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->mcuNumber))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->mcuNumber))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse(ASN1encoding_t enc, RequestAllTerminalIDsResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(enc, &(val)->terminalInformation))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse(ASN1decoding_t dec, RequestAllTerminalIDsResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(dec, &(val)->terminalInformation))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse(RequestAllTerminalIDsResponse *val)
{
    if (val) {
	ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(&(val)->terminalInformation);
    }
}

static int ASN1CALL ASN1Enc_TerminalInformation(ASN1encoding_t enc, TerminalInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInformation(ASN1decoding_t dec, TerminalInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInformation(TerminalInformation *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RemoteMCRequest(ASN1encoding_t enc, RemoteMCRequest *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCRequest(ASN1decoding_t dec, RemoteMCRequest *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RemoteMCResponse(ASN1encoding_t enc, RemoteMCResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_RemoteMCResponse_reject(enc, &(val)->u.reject))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCResponse(ASN1decoding_t dec, RemoteMCResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_RemoteMCResponse_reject(dec, &(val)->u.reject))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest(enc, &(val)->u.specificRequest))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest(dec, &(val)->u.specificRequest))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_SendTerminalCapabilitySet_specificRequest(&(val)->u.specificRequest);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_FlowControlCommand_scope(enc, &(val)->scope))
	return 0;
    if (!ASN1Enc_FlowControlCommand_restriction(enc, &(val)->restriction))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_FlowControlCommand_scope(dec, &(val)->scope))
	return 0;
    if (!ASN1Dec_FlowControlCommand_restriction(dec, &(val)->restriction))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SubstituteConferenceIDCommand(ASN1encoding_t enc, SubstituteConferenceIDCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceIdentifier, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubstituteConferenceIDCommand(ASN1decoding_t dec, SubstituteConferenceIDCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceIdentifier, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubstituteConferenceIDCommand(SubstituteConferenceIDCommand *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KeyProtectionMethod(ASN1encoding_t enc, KeyProtectionMethod *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->secureChannel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sharedSecret))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->certProtectedKey))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyProtectionMethod(ASN1decoding_t dec, KeyProtectionMethod *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->secureChannel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sharedSecret))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->certProtectedKey))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EncryptionUpdateRequest(ASN1encoding_t enc, EncryptionUpdateRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KeyProtectionMethod(enc, &(val)->keyProtectionMethod))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionUpdateRequest(ASN1decoding_t dec, EncryptionUpdateRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_KeyProtectionMethod(dec, &(val)->keyProtectionMethod))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration(ASN1encoding_t enc, H223MultiplexReconfiguration *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(enc, &(val)->u.h223ModeChange))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(enc, &(val)->u.h223AnnexADoubleFlag))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration(ASN1decoding_t dec, H223MultiplexReconfiguration *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(dec, &(val)->u.h223ModeChange))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(dec, &(val)->u.h223AnnexADoubleFlag))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_FunctionNotSupported_cause(enc, &(val)->cause))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->returnedFunction))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_FunctionNotSupported_cause(dec, &(val)->cause))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->returnedFunction))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->returnedFunction);
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ASN1encoding_t enc, TerminalYouAreSeeingInSubPictureNumber *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->subPictureNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(ASN1decoding_t dec, TerminalYouAreSeeingInSubPictureNumber *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->subPictureNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VideoIndicateCompose(ASN1encoding_t enc, VideoIndicateCompose *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->compositionNumber))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoIndicateCompose(ASN1decoding_t dec, VideoIndicateCompose *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->compositionNumber))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncBitVal(enc, 4, (val)->u.sbeNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalNumberAssign))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalJoinedConference))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalLeftConference))
	    return 0;
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalYouAreSeeing))
	    return 0;
	break;
    case 10:
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.floorRequested))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ee, &(val)->u.terminalYouAreSeeingInSubPictureNumber))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VideoIndicateCompose(ee, &(val)->u.videoIndicateCompose))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU16Val(dec, 4, &(val)->u.sbeNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalNumberAssign))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalJoinedConference))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalLeftConference))
	    return 0;
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalYouAreSeeing))
	    return 0;
	break;
    case 10:
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.floorRequested))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(dd, &(val)->u.terminalYouAreSeeingInSubPictureNumber))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_VideoIndicateCompose(dd, &(val)->u.videoIndicateCompose))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_JitterIndication_scope(enc, &(val)->scope))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->estimatedReceivedJitterMantissa))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->estimatedReceivedJitterExponent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->skippedFrameCount))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->additionalDecoderBuffer);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->additionalDecoderBuffer))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_JitterIndication_scope(dec, &(val)->scope))
	return 0;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->estimatedReceivedJitterMantissa))
	return 0;
    if (!ASN1PERDecU16Val(dec, 3, &(val)->estimatedReceivedJitterExponent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->skippedFrameCount))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->additionalDecoderBuffer))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->skew))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
	return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
	return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->skew))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumSkew))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
	return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
	return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumSkew))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->vendor);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_aal(enc, &(val)->aal))
	return 0;
    if (!ASN1Enc_NewATMVCIndication_multiplex(enc, &(val)->multiplex))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_NewATMVCIndication_reverseParameters(ee, &(val)->reverseParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_aal(dec, &(val)->aal))
	return 0;
    if (!ASN1Dec_NewATMVCIndication_multiplex(dec, &(val)->multiplex))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_NewATMVCIndication_reverseParameters(dd, &(val)->reverseParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (!ASN1Enc_RTPH263VideoRedundancyFrameMapping(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (!ASN1Dec_RTPH263VideoRedundancyFrameMapping(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (val) {
	ASN1Free_RTPH263VideoRedundancyFrameMapping(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 8, (*val)->count - 2))
	return 0;
    for (i = 0; i < (*val)->count; i++) {
	if (!ASN1Enc_MultiplexElement(enc, &((*val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 8, &(*val)->count))
	return 0;
    (*val)->count += 2;
    for (i = 0; i < (*val)->count; i++) {
	if (!ASN1Dec_MultiplexElement(dec, &((*val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (*val)->count; i++) {
	    ASN1Free_MultiplexElement(&(*val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (!ASN1Enc_TerminalInformation(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (!ASN1Dec_TerminalInformation(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (val) {
	ASN1Free_TerminalInformation(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalCertificateResponse(ASN1encoding_t enc, ConferenceResponse_terminalCertificateResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->certificateResponse, 1, 65535, 16))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalCertificateResponse(ASN1decoding_t dec, ConferenceResponse_terminalCertificateResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->certificateResponse, 1, 65535, 16))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalCertificateResponse(ConferenceResponse_terminalCertificateResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ASN1encoding_t enc, ConferenceResponse_chairTokenOwnerResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(ASN1decoding_t dec, ConferenceResponse_chairTokenOwnerResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_chairTokenOwnerResponse(ConferenceResponse_chairTokenOwnerResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TerminalLabel(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_TerminalLabel(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest_requestTerminalCertificate(ASN1encoding_t enc, ConferenceRequest_requestTerminalCertificate *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CertSelectionCriteria(enc, &(val)->certSelectionCriteria))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	l = ASN1uint32_uoctets((val)->sRandom - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->sRandom - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest_requestTerminalCertificate(ASN1decoding_t dec, ConferenceRequest_requestTerminalCertificate *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_CertSelectionCriteria(dec, &(val)->certSelectionCriteria))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sRandom))
	    return 0;
	(val)->sRandom += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceRequest_requestTerminalCertificate(ConferenceRequest_requestTerminalCertificate *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CertSelectionCriteria(&(val)->certSelectionCriteria);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MultiplexElement(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MultiplexElement(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_MultiplexElement(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry(ASN1encoding_t enc, PEncryptionSync_escrowentry *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EncryptionSync_escrowentry_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val)
{
    if (!ASN1Enc_EscrowData(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry(ASN1decoding_t dec, PEncryptionSync_escrowentry *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EncryptionSync_escrowentry_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val)
{
    if (!ASN1Dec_EscrowData(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionSync_escrowentry(PEncryptionSync_escrowentry *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EncryptionSync_escrowentry_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val)
{
    if (val) {
	ASN1Free_EscrowData(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_arqType(ASN1encoding_t enc, H223AL3MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIIArq))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_arqType(ASN1decoding_t dec, H223AL3MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIIArq))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_arqType(ASN1encoding_t enc, H223AL1MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIIArq))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_arqType(ASN1decoding_t dec, H223AL1MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIArq))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIIArq))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(ASN1encoding_t enc, H263VideoModeCombos_h263VideoCoupledModes *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_H263ModeComboFlags(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(ASN1decoding_t dec, H263VideoModeCombos_h263VideoCoupledModes *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_H263ModeComboFlags(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(H263VideoModeCombos_h263VideoCoupledModes *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H263Options_customPictureFormat(ASN1encoding_t enc, PH263Options_customPictureFormat *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_customPictureFormat_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val)
{
    if (!ASN1Enc_CustomPictureFormat(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_customPictureFormat(ASN1decoding_t dec, PH263Options_customPictureFormat *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_customPictureFormat_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val)
{
    if (!ASN1Dec_CustomPictureFormat(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_customPictureFormat(PH263Options_customPictureFormat *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_customPictureFormat_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val)
{
    if (val) {
	ASN1Free_CustomPictureFormat(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency(ASN1encoding_t enc, PH263Options_customPictureClockFrequency *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_customPictureClockFrequency_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val)
{
    if (!ASN1Enc_CustomPictureClockFrequency(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency(ASN1decoding_t dec, PH263Options_customPictureClockFrequency *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_customPictureClockFrequency_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val)
{
    if (!ASN1Dec_CustomPictureClockFrequency(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency(PH263Options_customPictureClockFrequency *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_customPictureClockFrequency_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Enc_MediaDistributionCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Dec_MediaDistributionCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val)
{
    if (val) {
	ASN1Free_MediaDistributionCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportCapability_mediaChannelCapabilities(ASN1encoding_t enc, TransportCapability_mediaChannelCapabilities *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MediaChannelCapability(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability_mediaChannelCapabilities(ASN1decoding_t dec, TransportCapability_mediaChannelCapabilities *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_MediaChannelCapability(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability_mediaChannelCapabilities(TransportCapability_mediaChannelCapabilities *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H222Capability_vcCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val)
{
    if (!ASN1Enc_VCCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H222Capability_vcCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val)
{
    if (!ASN1Dec_VCCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H222Capability_vcCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Enc_AlternativeCapabilitySet(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Dec_AlternativeCapabilitySet(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (val) {
	ASN1Free_AlternativeCapabilitySet(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CapabilityDescriptor(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_CapabilityDescriptor(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_CapabilityDescriptor(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    o[0] |= 0x40;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->transportWithI_frames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl2SDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl3SDUSize))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumDelayJitter))
	return 0;
    if (!ASN1Enc_H223Capability_h223MultiplexTableCapability(enc, &(val)->h223MultiplexTableCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->maxMUXPDUSizeCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1PEREncBoolean(ee, (val)->nsrpSupport))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1Enc_H223Capability_mobileOperationTransmitCapability(ee, &(val)->mobileOperationTransmitCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x10) {
	    if (!ASN1Enc_H223AnnexCCapability(ee, &(val)->h223AnnexCCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->transportWithI_frames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl2SDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl3SDUSize))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumDelayJitter))
	return 0;
    if (!ASN1Dec_H223Capability_h223MultiplexTableCapability(dec, &(val)->h223MultiplexTableCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->maxMUXPDUSizeCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->nsrpSupport))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H223Capability_mobileOperationTransmitCapability(dd, &(val)->mobileOperationTransmitCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H223AnnexCCapability(dd, &(val)->h223AnnexCCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywoAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rejCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sREJCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->mREJCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc8bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc16bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc32bitCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uihCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numOfDLCS - 2))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoOctetAddressFieldCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopBackTestCapability))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401Capability - 1))
	return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->maxWindowSizeCapability - 1))
	return 0;
    if (!ASN1Enc_V75Capability(enc, &(val)->v75Capability))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywoAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rejCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sREJCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->mREJCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc8bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc16bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc32bitCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uihCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numOfDLCS))
	return 0;
    (val)->numOfDLCS += 2;
    if (!ASN1PERDecBoolean(dec, &(val)->twoOctetAddressFieldCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->loopBackTestCapability))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401Capability))
	return 0;
    (val)->n401Capability += 1;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->maxWindowSizeCapability))
	return 0;
    (val)->maxWindowSizeCapability += 1;
    if (!ASN1Dec_V75Capability(dec, &(val)->v75Capability))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RSVPParameters(ASN1encoding_t enc, RSVPParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_QOSMode(enc, &(val)->qosMode))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	l = ASN1uint32_uoctets((val)->tokenRate - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->tokenRate - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	l = ASN1uint32_uoctets((val)->bucketSize - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->bucketSize - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	l = ASN1uint32_uoctets((val)->peakRate - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->peakRate - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	l = ASN1uint32_uoctets((val)->minPoliced - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->minPoliced - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->maxPktSize - 1);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxPktSize - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RSVPParameters(ASN1decoding_t dec, RSVPParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_QOSMode(dec, &(val)->qosMode))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->tokenRate))
	    return 0;
	(val)->tokenRate += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bucketSize))
	    return 0;
	(val)->bucketSize += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->peakRate))
	    return 0;
	(val)->peakRate += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->minPoliced))
	    return 0;
	(val)->minPoliced += 1;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxPktSize))
	    return 0;
	(val)->maxPktSize += 1;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QOSCapability(ASN1encoding_t enc, QOSCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RSVPParameters(enc, &(val)->rsvpParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ATMParameters(enc, &(val)->atmParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_QOSCapability(ASN1decoding_t dec, QOSCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RSVPParameters(dec, &(val)->rsvpParameters))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ATMParameters(dec, &(val)->atmParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_QOSCapability(QOSCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_TransportCapability(ASN1encoding_t enc, TransportCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TransportCapability_qOSCapabilities(enc, &(val)->qOSCapabilities))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TransportCapability_mediaChannelCapabilities(enc, &(val)->mediaChannelCapabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability(ASN1decoding_t dec, TransportCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TransportCapability_qOSCapabilities(dec, &(val)->qOSCapabilities))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TransportCapability_mediaChannelCapabilities(dec, &(val)->mediaChannelCapabilities))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability(TransportCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TransportCapability_qOSCapabilities(&(val)->qOSCapabilities);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TransportCapability_mediaChannelCapabilities(&(val)->mediaChannelCapabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMethod(ASN1encoding_t enc, RedundancyEncodingMethod *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RTPH263VideoRedundancyEncoding(ee, &(val)->u.rtpH263VideoRedundancyEncoding))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMethod(ASN1decoding_t dec, RedundancyEncodingMethod *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_RTPH263VideoRedundancyEncoding(dd, &(val)->u.rtpH263VideoRedundancyEncoding))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMethod(RedundancyEncodingMethod *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_RTPH263VideoRedundancyEncoding(&(val)->u.rtpH263VideoRedundancyEncoding);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H263Options(ASN1encoding_t enc, H263Options *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->deblockingFilterMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fullPictureFreeze))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partialPictureFreezeAndRelease))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->resizingPartPicFreezeAndRelease))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fullPictureSnapshot))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partialPictureSnapshot))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoSegmentTagging))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->progressiveRefinement))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modifiedQuantizationMode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reducedResolutionUpdate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransparencyParameters(enc, &(val)->transparencyParameters))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->separateVideoBackChannel))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_RefPictureSelection(enc, &(val)->refPictureSelection))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H263Options_customPictureClockFrequency(enc, &(val)->customPictureClockFrequency))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_H263Options_customPictureFormat(enc, &(val)->customPictureFormat))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_H263Options_modeCombos(enc, &(val)->modeCombos))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options(ASN1decoding_t dec, H263Options *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedIntraCodingMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->deblockingFilterMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->improvedPBFramesMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unlimitedMotionVectors))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fullPictureFreeze))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partialPictureFreezeAndRelease))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->resizingPartPicFreezeAndRelease))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fullPictureSnapshot))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partialPictureSnapshot))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoSegmentTagging))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->progressiveRefinement))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingByFour))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingHalfPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingSixteenthPel))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->independentSegmentDecoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_NonRect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_Rect))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alternateInterVLCMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modifiedQuantizationMode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reducedResolutionUpdate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransparencyParameters(dec, &(val)->transparencyParameters))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->separateVideoBackChannel))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_RefPictureSelection(dec, &(val)->refPictureSelection))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H263Options_customPictureClockFrequency(dec, &(val)->customPictureClockFrequency))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H263Options_customPictureFormat(dec, &(val)->customPictureFormat))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_H263Options_modeCombos(dec, &(val)->modeCombos))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263Options(H263Options *val)
{
    if (val) {
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H263Options_customPictureClockFrequency(&(val)->customPictureClockFrequency);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H263Options_customPictureFormat(&(val)->customPictureFormat);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_H263Options_modeCombos(&(val)->modeCombos);
	}
    }
}

static int ASN1CALL ASN1Enc_H263VideoModeCombos(ASN1encoding_t enc, H263VideoModeCombos *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H263ModeComboFlags(enc, &(val)->h263VideoUncoupledModes))
	return 0;
    if (!ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(enc, &(val)->h263VideoCoupledModes))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoModeCombos(ASN1decoding_t dec, H263VideoModeCombos *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H263ModeComboFlags(dec, &(val)->h263VideoUncoupledModes))
	return 0;
    if (!ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(dec, &(val)->h263VideoCoupledModes))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoModeCombos(H263VideoModeCombos *val)
{
    if (val) {
	ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(&(val)->h263VideoCoupledModes);
    }
}

static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw64k - 1))
	    return 0;
	break;
    case 3:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw56k - 1))
	    return 0;
	break;
    case 4:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw64k - 1))
	    return 0;
	break;
    case 5:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw56k - 1))
	    return 0;
	break;
    case 6:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_64k - 1))
	    return 0;
	break;
    case 7:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_56k - 1))
	    return 0;
	break;
    case 8:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_48k - 1))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_AudioCapability_g7231(enc, &(val)->u.g7231))
	    return 0;
	break;
    case 10:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g728 - 1))
	    return 0;
	break;
    case 11:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729 - 1))
	    return 0;
	break;
    case 12:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729AnnexA - 1))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_IS11172AudioCapability(enc, &(val)->u.is11172AudioCapability))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_IS13818AudioCapability(enc, &(val)->u.is13818AudioCapability))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729wAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_G7231AnnexCCapability(ee, &(val)->u.g7231AnnexCCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmHalfRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw64k))
	    return 0;
	(val)->u.g711Alaw64k += 1;
	break;
    case 3:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw56k))
	    return 0;
	(val)->u.g711Alaw56k += 1;
	break;
    case 4:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw64k))
	    return 0;
	(val)->u.g711Ulaw64k += 1;
	break;
    case 5:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw56k))
	    return 0;
	(val)->u.g711Ulaw56k += 1;
	break;
    case 6:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_64k))
	    return 0;
	(val)->u.g722_64k += 1;
	break;
    case 7:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_56k))
	    return 0;
	(val)->u.g722_56k += 1;
	break;
    case 8:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_48k))
	    return 0;
	(val)->u.g722_48k += 1;
	break;
    case 9:
	if (!ASN1Dec_AudioCapability_g7231(dec, &(val)->u.g7231))
	    return 0;
	break;
    case 10:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g728))
	    return 0;
	(val)->u.g728 += 1;
	break;
    case 11:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729))
	    return 0;
	(val)->u.g729 += 1;
	break;
    case 12:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729AnnexA))
	    return 0;
	(val)->u.g729AnnexA += 1;
	break;
    case 13:
	if (!ASN1Dec_IS11172AudioCapability(dec, &(val)->u.is11172AudioCapability))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_IS13818AudioCapability(dec, &(val)->u.is13818AudioCapability))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729wAnnexB))
	    return 0;
	(val)->u.g729wAnnexB += 1;
	ASN1_CloseDecoder(dd);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwAnnexB))
	    return 0;
	(val)->u.g729AnnexAwAnnexB += 1;
	ASN1_CloseDecoder(dd);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_G7231AnnexCCapability(dd, &(val)->u.g7231AnnexCCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmHalfRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	//ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	//nik: any number greate than 20 is extension case.
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CompressionType(ASN1encoding_t enc, CompressionType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_V42bis(enc, &(val)->u.v42bis))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CompressionType(ASN1decoding_t dec, CompressionType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_V42bis(dec, &(val)->u.v42bis))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaEncryptionAlgorithm(ASN1encoding_t enc, MediaEncryptionAlgorithm *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.algorithm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaEncryptionAlgorithm(ASN1decoding_t dec, MediaEncryptionAlgorithm *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.algorithm))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaEncryptionAlgorithm(MediaEncryptionAlgorithm *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1objectidentifier_free(&(val)->u.algorithm);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AuthenticationCapability(ASN1encoding_t enc, AuthenticationCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationCapability(ASN1decoding_t dec, AuthenticationCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationCapability(AuthenticationCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_IntegrityCapability(ASN1encoding_t enc, IntegrityCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntegrityCapability(ASN1decoding_t dec, IntegrityCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntegrityCapability(IntegrityCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
    }
}

static int ASN1CALL ASN1Enc_H223AL1MParameters(ASN1encoding_t enc, H223AL1MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_transferMode(enc, &(val)->transferMode))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_headerFEC(enc, &(val)->headerFEC))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_crcLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->rcpcCodeRate - 8))
	return 0;
    if (!ASN1Enc_H223AL1MParameters_arqType(enc, &(val)->arqType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alsduSplitting))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters(ASN1decoding_t dec, H223AL1MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_transferMode(dec, &(val)->transferMode))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_headerFEC(dec, &(val)->headerFEC))
	return 0;
    if (!ASN1Dec_H223AL1MParameters_crcLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->rcpcCodeRate))
	return 0;
    (val)->rcpcCodeRate += 8;
    if (!ASN1Dec_H223AL1MParameters_arqType(dec, &(val)->arqType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alsduSplitting))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters(ASN1encoding_t enc, H223AL3MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_headerFormat(enc, &(val)->headerFormat))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_crcLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->rcpcCodeRate - 8))
	return 0;
    if (!ASN1Enc_H223AL3MParameters_arqType(enc, &(val)->arqType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters(ASN1decoding_t dec, H223AL3MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223AL3MParameters_headerFormat(dec, &(val)->headerFormat))
	return 0;
    if (!ASN1Dec_H223AL3MParameters_crcLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->rcpcCodeRate))
	return 0;
    (val)->rcpcCodeRate += 8;
    if (!ASN1Dec_H223AL3MParameters_arqType(dec, &(val)->arqType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CRCLength(enc, &(val)->crcLength))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401 - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopbackTestProcedure))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CRCLength(dec, &(val)->crcLength))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401))
	return 0;
    (val)->n401 += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->loopbackTestProcedure))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UnicastAddress_iPAddress(enc, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_UnicastAddress_iPXAddress(enc, &(val)->u.iPXAddress))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_UnicastAddress_iP6Address(enc, &(val)->u.iP6Address))
	    return 0;
	break;
    case 4:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress(enc, &(val)->u.iPSourceRouteAddress))
	    return 0;
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UnicastAddress_iPAddress(dec, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_UnicastAddress_iPXAddress(dec, &(val)->u.iPXAddress))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_UnicastAddress_iP6Address(dec, &(val)->u.iP6Address))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress(dec, &(val)->u.iPSourceRouteAddress))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UnicastAddress_iPAddress(&(val)->u.iPAddress);
	    break;
	case 2:
	    ASN1Free_UnicastAddress_iPXAddress(&(val)->u.iPXAddress);
	    break;
	case 3:
	    ASN1Free_UnicastAddress_iP6Address(&(val)->u.iP6Address);
	    break;
	case 4:
	    break;
	case 5:
	    ASN1Free_UnicastAddress_iPSourceRouteAddress(&(val)->u.iPSourceRouteAddress);
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_MulticastAddress_iPAddress(enc, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MulticastAddress_iP6Address(enc, &(val)->u.iP6Address))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_MulticastAddress_iPAddress(dec, &(val)->u.iPAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MulticastAddress_iP6Address(dec, &(val)->u.iP6Address))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_MulticastAddress_iPAddress(&(val)->u.iPAddress);
	    break;
	case 2:
	    ASN1Free_MulticastAddress_iP6Address(&(val)->u.iP6Address);
	    break;
	case 3:
	    break;
	case 4:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionSync(ASN1encoding_t enc, EncryptionSync *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
	    return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->synchFlag))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->h235Key, 1, 65535, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_EncryptionSync_escrowentry(enc, &(val)->escrowentry))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionSync(ASN1decoding_t dec, EncryptionSync *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
	    return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->synchFlag))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->h235Key, 1, 65535, 16))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_EncryptionSync_escrowentry(dec, &(val)->escrowentry))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionSync(EncryptionSync *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EncryptionSync_escrowentry(&(val)->escrowentry);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_QOSCapability(ee, &(val)->qosCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_RequestChannelClose_reason(ee, &(val)->reason))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_QOSCapability(dd, &(val)->qosCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RequestChannelClose_reason(dd, &(val)->reason))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestChannelClose(RequestChannelClose *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_QOSCapability(&(val)->qosCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MultiplexEntryDescriptor_elementList(enc, &(val)->elementList))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
	return 0;
    (val)->multiplexTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MultiplexEntryDescriptor_elementList(dec, &(val)->elementList))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MultiplexEntryDescriptor_elementList(&(val)->elementList);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val)
{
    if (val) {
	ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_entryNumbers(enc, &(val)->entryNumbers))
	return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_entryNumbers(dec, &(val)->entryNumbers))
	return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val)
{
    if (val) {
	ASN1Free_RequestMultiplexEntryReject_entryNumbers(&(val)->entryNumbers);
	ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1Enc_H263VideoMode_resolution(enc, &(val)->resolution))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_EnhancementLayerInfo(ee, &(val)->enhancementLayerInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1Enc_H263Options(ee, &(val)->h263Options))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H263VideoMode_resolution(dec, &(val)->resolution))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
	return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_EnhancementLayerInfo(dd, &(val)->enhancementLayerInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H263Options(dd, &(val)->h263Options))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoMode(H263VideoMode *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_EnhancementLayerInfo(&(val)->enhancementLayerInfo);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Enc_AudioMode_g7231(enc, &(val)->u.g7231))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_IS11172AudioMode(enc, &(val)->u.is11172AudioMode))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_IS13818AudioMode(enc, &(val)->u.is13818AudioMode))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729wAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwAnnexB - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_G7231AnnexCMode(ee, &(val)->u.g7231AnnexCMode))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmHalfRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	break;
    case 12:
	if (!ASN1Dec_AudioMode_g7231(dec, &(val)->u.g7231))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_IS11172AudioMode(dec, &(val)->u.is11172AudioMode))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_IS13818AudioMode(dec, &(val)->u.is13818AudioMode))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729wAnnexB))
	    return 0;
	(val)->u.g729wAnnexB += 1;
	ASN1_CloseDecoder(dd);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwAnnexB))
	    return 0;
	(val)->u.g729AnnexAwAnnexB += 1;
	ASN1_CloseDecoder(dd);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_G7231AnnexCMode(dd, &(val)->u.g7231AnnexCMode))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmHalfRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmEnhancedFullRate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioMode(AudioMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.dropTerminal))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.requestTerminalID))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceRequest_requestTerminalCertificate(ee, &(val)->u.requestTerminalCertificate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncUnsignedShort(ee, (val)->u.broadcastMyLogicalChannel - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TerminalLabel(ee, &(val)->u.sendThisSource))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RemoteMCRequest(ee, &(val)->u.remoteMCRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.dropTerminal))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.requestTerminalID))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceRequest_requestTerminalCertificate(dd, &(val)->u.requestTerminalCertificate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1PERDecUnsignedShort(dd, &(val)->u.broadcastMyLogicalChannel))
	    return 0;
	(val)->u.broadcastMyLogicalChannel += 1;
	ASN1_CloseDecoder(dd);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_TerminalLabel(dd, &(val)->u.sendThisSource))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_RemoteMCRequest(dd, &(val)->u.remoteMCRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceRequest(ConferenceRequest *val)
{
    if (val) {
	switch ((val)->choice) {
	case 11:
	    ASN1Free_ConferenceRequest_requestTerminalCertificate(&(val)->u.requestTerminalCertificate);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CertSelectionCriteria(ASN1encoding_t enc, PCertSelectionCriteria *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CertSelectionCriteria_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val)
{
    if (!ASN1Enc_Criteria(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertSelectionCriteria(ASN1decoding_t dec, PCertSelectionCriteria *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CertSelectionCriteria_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val)
{
    if (!ASN1Dec_Criteria(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertSelectionCriteria(PCertSelectionCriteria *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CertSelectionCriteria_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val)
{
    if (val) {
	ASN1Free_Criteria(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceResponse_mCTerminalIDResponse(enc, &(val)->u.mCTerminalIDResponse))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceResponse_terminalIDResponse(enc, &(val)->u.terminalIDResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceResponse_conferenceIDResponse(enc, &(val)->u.conferenceIDResponse))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceResponse_passwordResponse(enc, &(val)->u.passwordResponse))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceResponse_terminalListResponse(enc, &(val)->u.terminalListResponse))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1Enc_ConferenceResponse_makeMeChairResponse(enc, &(val)->u.makeMeChairResponse))
	    return 0;
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_extensionAddressResponse(ee, &(val)->u.extensionAddressResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ee, &(val)->u.chairTokenOwnerResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_terminalCertificateResponse(ee, &(val)->u.terminalCertificateResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ee, &(val)->u.broadcastMyLogicalChannelResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ee, &(val)->u.makeTerminalBroadcasterResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse_sendThisSourceResponse(ee, &(val)->u.sendThisSourceResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RequestAllTerminalIDsResponse(ee, &(val)->u.requestAllTerminalIDsResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RemoteMCResponse(ee, &(val)->u.remoteMCResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceResponse_mCTerminalIDResponse(dec, &(val)->u.mCTerminalIDResponse))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceResponse_terminalIDResponse(dec, &(val)->u.terminalIDResponse))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceResponse_conferenceIDResponse(dec, &(val)->u.conferenceIDResponse))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceResponse_passwordResponse(dec, &(val)->u.passwordResponse))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceResponse_terminalListResponse(dec, &(val)->u.terminalListResponse))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1Dec_ConferenceResponse_makeMeChairResponse(dec, &(val)->u.makeMeChairResponse))
	    return 0;
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_extensionAddressResponse(dd, &(val)->u.extensionAddressResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(dd, &(val)->u.chairTokenOwnerResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_terminalCertificateResponse(dd, &(val)->u.terminalCertificateResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(dd, &(val)->u.broadcastMyLogicalChannelResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(dd, &(val)->u.makeTerminalBroadcasterResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse_sendThisSourceResponse(dd, &(val)->u.sendThisSourceResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_RequestAllTerminalIDsResponse(dd, &(val)->u.requestAllTerminalIDsResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_RemoteMCResponse(dd, &(val)->u.remoteMCResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceResponse_mCTerminalIDResponse(&(val)->u.mCTerminalIDResponse);
	    break;
	case 2:
	    ASN1Free_ConferenceResponse_terminalIDResponse(&(val)->u.terminalIDResponse);
	    break;
	case 3:
	    ASN1Free_ConferenceResponse_conferenceIDResponse(&(val)->u.conferenceIDResponse);
	    break;
	case 4:
	    ASN1Free_ConferenceResponse_passwordResponse(&(val)->u.passwordResponse);
	    break;
	case 5:
	    ASN1Free_ConferenceResponse_terminalListResponse(&(val)->u.terminalListResponse);
	    break;
	case 9:
	    ASN1Free_ConferenceResponse_extensionAddressResponse(&(val)->u.extensionAddressResponse);
	    break;
	case 10:
	    ASN1Free_ConferenceResponse_chairTokenOwnerResponse(&(val)->u.chairTokenOwnerResponse);
	    break;
	case 11:
	    ASN1Free_ConferenceResponse_terminalCertificateResponse(&(val)->u.terminalCertificateResponse);
	    break;
	case 15:
	    ASN1Free_RequestAllTerminalIDsResponse(&(val)->u.requestAllTerminalIDsResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_EndSessionCommand_gstnOptions(enc, &(val)->u.gstnOptions))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EndSessionCommand_isdnOptions(ee, &(val)->u.isdnOptions))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_EndSessionCommand_gstnOptions(dec, &(val)->u.gstnOptions))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_EndSessionCommand_isdnOptions(dd, &(val)->u.isdnOptions))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.broadcastMyLogicalChannel - 1))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.cancelBroadcastMyLogicalChannel - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Enc_TerminalLabel(enc, &(val)->u.sendThisSource))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_SubstituteConferenceIDCommand(ee, &(val)->u.substituteConferenceIDCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.broadcastMyLogicalChannel))
	    return 0;
	(val)->u.broadcastMyLogicalChannel += 1;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.cancelBroadcastMyLogicalChannel))
	    return 0;
	(val)->u.cancelBroadcastMyLogicalChannel += 1;
	break;
    case 3:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.makeTerminalBroadcaster))
	    return 0;
	break;
    case 4:
	break;
    case 5:
	if (!ASN1Dec_TerminalLabel(dec, &(val)->u.sendThisSource))
	    return 0;
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_SubstituteConferenceIDCommand(dd, &(val)->u.substituteConferenceIDCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCommand(ConferenceCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 8:
	    ASN1Free_SubstituteConferenceIDCommand(&(val)->u.substituteConferenceIDCommand);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication_userInputSupportIndication(ASN1encoding_t enc, UserInputIndication_userInputSupportIndication *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_userInputSupportIndication(ASN1decoding_t dec, UserInputIndication_userInputSupportIndication *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication_userInputSupportIndication(UserInputIndication_userInputSupportIndication *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ee, &(val)->u.videoNotDecodedMBs))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_TransportCapability(ee, &(val)->u.transportCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(dd, &(val)->u.videoNotDecodedMBs))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_TransportCapability(dd, &(val)->u.transportCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousIndication_type(MiscellaneousIndication_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 12:
	    ASN1Free_TransportCapability(&(val)->u.transportCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(enc, &(val)->u.videoFastUpdateGOB))
	    return 0;
	break;
    case 8:
	if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ee, &(val)->u.videoFastUpdateMB))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncUnsignedShort(ee, (val)->u.maxH223MUXPDUsize - 1))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EncryptionSync(ee, &(val)->u.encryptionUpdate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_EncryptionUpdateRequest(ee, &(val)->u.encryptionUpdateRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ee, &(val)->u.progressiveRefinementStart))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(dec, &(val)->u.videoFastUpdateGOB))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(dd, &(val)->u.videoFastUpdateMB))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1PERDecUnsignedShort(dd, &(val)->u.maxH223MUXPDUsize))
	    return 0;
	(val)->u.maxH223MUXPDUsize += 1;
	ASN1_CloseDecoder(dd);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_EncryptionSync(dd, &(val)->u.encryptionUpdate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_EncryptionUpdateRequest(dd, &(val)->u.encryptionUpdateRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(dd, &(val)->u.progressiveRefinementStart))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousCommand_type(MiscellaneousCommand_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 13:
	    ASN1Free_EncryptionSync(&(val)->u.encryptionUpdate);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233AlgorithmIdentifier))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->associatedAlgorithm))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233AlgorithmIdentifier))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->associatedAlgorithm))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->associatedAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMode_secondaryEncoding(ASN1encoding_t enc, RedundancyEncodingMode_secondaryEncoding *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioData))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMode_secondaryEncoding(ASN1decoding_t dec, RedundancyEncodingMode_secondaryEncoding *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMode_secondaryEncoding(RedundancyEncodingMode_secondaryEncoding *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_AudioMode(&(val)->u.audioData);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_H223ModeParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL1MParameters(ee, &(val)->u.al1M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL2MParameters(ee, &(val)->u.al2M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL3MParameters(ee, &(val)->u.al3M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_H223ModeParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H223AL1MParameters(dd, &(val)->u.al1M))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H223AL2MParameters(dd, &(val)->u.al2M))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H223AL3MParameters(dd, &(val)->u.al3M))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, 1, 15, 4);
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Enc_MultiplexEntryDescriptor(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, sizeof(**val), 1, 15, 4);
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Dec_MultiplexEntryDescriptor(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (val) {
	ASN1Free_MultiplexEntryDescriptor(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RTPPayloadType_payloadDescriptor(ASN1encoding_t enc, RTPPayloadType_payloadDescriptor *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardIdentifier))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncExtensionBitClear(enc))
	    return 0;
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.rfc_number - 1))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.oid))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPPayloadType_payloadDescriptor(ASN1decoding_t dec, RTPPayloadType_payloadDescriptor *val)
{
    ASN1uint32_t x;
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardIdentifier))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecExtensionBit(dec, &x))
	    return 0;
	if (!x) {
	    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.rfc_number))
		return 0;
	    (val)->u.rfc_number += 1;
	} else {
	    ASN1PERDecAlignment(dec);
	    if (!ASN1PERDecFragmentedLength(dec, &l))
		return 0;
	    if (!ASN1PERDecSkipBits(dec, l * 8))
		return 0;
	}
	break;
    case 3:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.oid))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPPayloadType_payloadDescriptor(RTPPayloadType_payloadDescriptor *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardIdentifier);
	    break;
	case 3:
	    ASN1objectidentifier_free(&(val)->u.oid);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL1MParameters(ee, &(val)->u.al1M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL2MParameters(ee, &(val)->u.al2M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223AL3MParameters(ee, &(val)->u.al3M))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H223AL1MParameters(dd, &(val)->u.al1M))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H223AL2MParameters(dd, &(val)->u.al2M))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H223AL3MParameters(dd, &(val)->u.al3M))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConferenceCapability_nonStandardData_ElmFn);
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConferenceCapability_nonStandardData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConferenceCapability_nonStandardData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserInputCapability_nonStandard(ASN1encoding_t enc, UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_NonStandardParameter(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputCapability_nonStandard(ASN1decoding_t dec, UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_NonStandardParameter(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputCapability_nonStandard(UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_NonStandardParameter(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability_v76wCompression(ASN1encoding_t enc, DataProtocolCapability_v76wCompression *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.transmitCompression))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.receiveCompression))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CompressionType(enc, &(val)->u.transmitAndReceiveCompression))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability_v76wCompression(ASN1decoding_t dec, DataProtocolCapability_v76wCompression *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.transmitCompression))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.receiveCompression))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CompressionType(dec, &(val)->u.transmitAndReceiveCompression))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263Options_modeCombos(ASN1encoding_t enc, PH263Options_modeCombos *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_modeCombos_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val)
{
    if (!ASN1Enc_H263VideoModeCombos(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_modeCombos(ASN1decoding_t dec, PH263Options_modeCombos *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_modeCombos_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val)
{
    if (!ASN1Dec_H263VideoModeCombos(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_modeCombos(PH263Options_modeCombos *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_modeCombos_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val)
{
    if (val) {
	ASN1Free_H263VideoModeCombos(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities(ASN1encoding_t enc, PTransportCapability_qOSCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportCapability_qOSCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val)
{
    if (!ASN1Enc_QOSCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities(ASN1decoding_t dec, PTransportCapability_qOSCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportCapability_qOSCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val)
{
    if (!ASN1Dec_QOSCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities(PTransportCapability_qOSCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportCapability_qOSCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val)
{
    if (val) {
	ASN1Free_QOSCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->nonStandardData);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability(ASN1encoding_t enc, RedundancyEncodingCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->primaryEncoding - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability(ASN1decoding_t dec, RedundancyEncodingCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->primaryEncoding))
	return 0;
    (val)->primaryEncoding += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability(RedundancyEncodingCapability *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingCapability_secondaryEncoding(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if (o[0] & 0x4) {
	l = ASN1uint32_uoctets((val)->hrd_B);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->hrd_B))
	    return 0;
    }
    if (o[0] & 0x2) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->bppMaxKb))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowSqcifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowQcifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x20) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCifMPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x10) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif4MPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x8) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif16MPI - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x4) {
	    if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x2) {
	    if (!ASN1Enc_EnhancementLayerInfo(ee, &(val)->enhancementLayerInfo))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x1) {
	    if (!ASN1Enc_H263Options(ee, &(val)->h263Options))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->hrd_B))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->bppMaxKb))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowSqcifMPI))
		return 0;
	    (val)->slowSqcifMPI += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowQcifMPI))
		return 0;
	    (val)->slowQcifMPI += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCifMPI))
		return 0;
	    (val)->slowCifMPI += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif4MPI))
		return 0;
	    (val)->slowCif4MPI += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x8) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif16MPI))
		return 0;
	    (val)->slowCif16MPI += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x4) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x2) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_EnhancementLayerInfo(dd, &(val)->enhancementLayerInfo))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x1) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H263Options(dd, &(val)->h263Options))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoCapability(H263VideoCapability *val)
{
    if (val) {
	if ((val)->o[1] & 0x2) {
	    ASN1Free_EnhancementLayerInfo(&(val)->enhancementLayerInfo);
	}
	if ((val)->o[1] & 0x1) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementOptions(ASN1encoding_t enc, EnhancementOptions *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 11, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
	    return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowSqcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowQcifMPI - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCifMPI - 1))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCif4MPI - 1))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->slowCif16MPI - 1))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->errorCompensation))
	return 0;
    if ((val)->o[1] & 0x20) {
	if (!ASN1Enc_H263Options(enc, &(val)->h263Options))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementOptions(ASN1decoding_t dec, EnhancementOptions *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 11, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
	    return 0;
	(val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
	    return 0;
	(val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
	    return 0;
	(val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
	    return 0;
	(val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
	    return 0;
	(val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
	return 0;
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowSqcifMPI))
	    return 0;
	(val)->slowSqcifMPI += 1;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowQcifMPI))
	    return 0;
	(val)->slowQcifMPI += 1;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCifMPI))
	    return 0;
	(val)->slowCifMPI += 1;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCif4MPI))
	    return 0;
	(val)->slowCif4MPI += 1;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCif16MPI))
	    return 0;
	(val)->slowCif16MPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->errorCompensation))
	return 0;
    if ((val)->o[1] & 0x20) {
	if (!ASN1Dec_H263Options(dec, &(val)->h263Options))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementOptions(EnhancementOptions *val)
{
    if (val) {
	if ((val)->o[1] & 0x20) {
	    ASN1Free_H263Options(&(val)->h263Options);
	}
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability_v76wCompression(ee, &(val)->u.v76wCompression))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability_v76wCompression(dd, &(val)->u.v76wCompression))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionAuthenticationAndIntegrity(ASN1encoding_t enc, EncryptionAuthenticationAndIntegrity *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_EncryptionCapability(enc, &(val)->encryptionCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AuthenticationCapability(enc, &(val)->authenticationCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_IntegrityCapability(enc, &(val)->integrityCapability))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAuthenticationAndIntegrity(ASN1decoding_t dec, EncryptionAuthenticationAndIntegrity *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_EncryptionCapability(dec, &(val)->encryptionCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_AuthenticationCapability(dec, &(val)->authenticationCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_IntegrityCapability(dec, &(val)->integrityCapability))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAuthenticationAndIntegrity(EncryptionAuthenticationAndIntegrity *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_EncryptionCapability(&(val)->encryptionCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AuthenticationCapability(&(val)->authenticationCapability);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_IntegrityCapability(&(val)->integrityCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCapability(ASN1encoding_t enc, PEncryptionCapability *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EncryptionCapability_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val)
{
    if (!ASN1Enc_MediaEncryptionAlgorithm(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCapability(ASN1decoding_t dec, PEncryptionCapability *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EncryptionCapability_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val)
{
    if (!ASN1Dec_MediaEncryptionAlgorithm(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCapability(PEncryptionCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EncryptionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val)
{
    if (val) {
	ASN1Free_MediaEncryptionAlgorithm(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserInputCapability(ASN1encoding_t enc, UserInputCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UserInputCapability_nonStandard(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputCapability(ASN1decoding_t dec, UserInputCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UserInputCapability_nonStandard(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputCapability(UserInputCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UserInputCapability_nonStandard(&(val)->u.nonStandard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_H223LogicalChannelParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_V76HDLCParameters(enc, &(val)->hdlcParameters))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_suspendResume(enc, &(val)->suspendResume))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uIH))
	return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode(enc, &(val)->mode))
	return 0;
    if (!ASN1Enc_V75Parameters(enc, &(val)->v75Parameters))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_V76HDLCParameters(dec, &(val)->hdlcParameters))
	return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_suspendResume(dec, &(val)->suspendResume))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uIH))
	return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_mode(dec, &(val)->mode))
	return 0;
    if (!ASN1Dec_V75Parameters(dec, &(val)->v75Parameters))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPPayloadType(ASN1encoding_t enc, RTPPayloadType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RTPPayloadType_payloadDescriptor(enc, &(val)->payloadDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 7, (val)->payloadType))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPPayloadType(ASN1decoding_t dec, RTPPayloadType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RTPPayloadType_payloadDescriptor(dec, &(val)->payloadDescriptor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 7, &(val)->payloadType))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPPayloadType(RTPPayloadType *val)
{
    if (val) {
	ASN1Free_RTPPayloadType_payloadDescriptor(&(val)->payloadDescriptor);
    }
}

static int ASN1CALL ASN1Enc_H245TransportAddress(ASN1encoding_t enc, H245TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UnicastAddress(enc, &(val)->u.unicastAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MulticastAddress(enc, &(val)->u.multicastAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H245TransportAddress(ASN1decoding_t dec, H245TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UnicastAddress(dec, &(val)->u.unicastAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MulticastAddress(dec, &(val)->u.multicastAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H245TransportAddress(H245TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_UnicastAddress(&(val)->u.unicastAddress);
	    break;
	case 2:
	    ASN1Free_MulticastAddress(&(val)->u.multicastAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 5, o))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[1] & 0x80) {
	    if (!ASN1PEREncBoolean(ee, (val)->flowControlToZero))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->portNumber))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	    return 0;
	(val)->sessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
	    return 0;
	(val)->dynamicRTPPayloadType += 96;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->flowControlToZero))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->portNumber))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H2250LogicalChannelAckParameters_nonStandard(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H223ModeParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H223ModeParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val)
{
    if (val) {
	ASN1Free_H223ModeParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMode(ASN1encoding_t enc, RedundancyEncodingMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingMode_secondaryEncoding(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMode(ASN1decoding_t dec, RedundancyEncodingMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingMode_secondaryEncoding(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMode(RedundancyEncodingMode *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingMode_secondaryEncoding(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H261VideoMode(enc, &(val)->u.h261VideoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H262VideoMode(enc, &(val)->u.h262VideoMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H263VideoMode(enc, &(val)->u.h263VideoMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_IS11172VideoMode(enc, &(val)->u.is11172VideoMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H261VideoMode(dec, &(val)->u.h261VideoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H262VideoMode(dec, &(val)->u.h262VideoMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H263VideoMode(dec, &(val)->u.h263VideoMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_IS11172VideoMode(dec, &(val)->u.is11172VideoMode))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoMode(VideoMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 4:
	    ASN1Free_H263VideoMode(&(val)->u.h263VideoMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.encryptionSE))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_EncryptionCommand_encryptionAlgorithmID(enc, &(val)->u.encryptionAlgorithmID))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.encryptionSE))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_EncryptionCommand_encryptionAlgorithmID(dec, &(val)->u.encryptionAlgorithmID))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.encryptionSE);
	    break;
	case 3:
	    ASN1Free_EncryptionCommand_encryptionAlgorithmID(&(val)->u.encryptionAlgorithmID);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_MiscellaneousCommand_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousCommand_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousCommand(MiscellaneousCommand *val)
{
    if (val) {
	ASN1Free_MiscellaneousCommand_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_MiscellaneousIndication_type(enc, &(val)->type))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
	return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousIndication_type(dec, &(val)->type))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousIndication(MiscellaneousIndication *val)
{
    if (val) {
	ASN1Free_MiscellaneousIndication_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->signalAddress))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->signalAddress))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val)
{
    if (val) {
	ASN1Free_H245TransportAddress(&(val)->signalAddress);
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.alphanumeric);
	if (!ASN1PEREncFragmentedCharString(enc, t, (val)->u.alphanumeric, 8))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_userInputSupportIndication(ee, &(val)->u.userInputSupportIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_signal(ee, &(val)->u.signal))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputIndication_signalUpdate(ee, &(val)->u.signalUpdate))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->u.alphanumeric, 8))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_userInputSupportIndication(dd, &(val)->u.userInputSupportIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_signal(dd, &(val)->u.signal))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_UserInputIndication_signalUpdate(dd, &(val)->u.signalUpdate))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1ztcharstring_free((val)->u.alphanumeric);
	    break;
	case 3:
	    ASN1Free_UserInputIndication_userInputSupportIndication(&(val)->u.userInputSupportIndication);
	    break;
	case 4:
	    ASN1Free_UserInputIndication_signal(&(val)->u.signal);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
	ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->t84Protocol))
	return 0;
    if (!ASN1Enc_T84Profile(enc, &(val)->t84Profile))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->t84Protocol))
	return 0;
    if (!ASN1Dec_T84Profile(dec, &(val)->t84Profile))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->t84Protocol);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val)
{
    if (val) {
	ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
	ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataMode_application_nlpid(enc, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t30fax))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t140))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataMode_application_nlpid(dec, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t30fax))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t140))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_DataProtocolCapability(&(val)->u.t120);
	    break;
	case 3:
	    ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
	    break;
	case 4:
	    ASN1Free_DataProtocolCapability(&(val)->u.userData);
	    break;
	case 5:
	    ASN1Free_DataProtocolCapability(&(val)->u.t84);
	    break;
	case 6:
	    ASN1Free_DataProtocolCapability(&(val)->u.t434);
	    break;
	case 7:
	    ASN1Free_DataProtocolCapability(&(val)->u.h224);
	    break;
	case 8:
	    ASN1Free_DataMode_application_nlpid(&(val)->u.nlpid);
	    break;
	case 10:
	    ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
	    break;
	case 11:
	    ASN1Free_DataProtocolCapability(&(val)->u.t30fax);
	    break;
	case 12:
	    ASN1Free_DataProtocolCapability(&(val)->u.t140);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H2250LogicalChannelAckParameters(enc, &(val)->u.h2250LogicalChannelAckParameters))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H2250LogicalChannelAckParameters(dec, &(val)->u.h2250LogicalChannelAckParameters))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H2250LogicalChannelAckParameters(&(val)->u.h2250LogicalChannelAckParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_RTPPayloadType(ee, &(val)->u.rtpPayloadType))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_RTPPayloadType(dd, &(val)->u.rtpPayloadType))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_mediaPacketization(H2250LogicalChannelParameters_mediaPacketization *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_RTPPayloadType(&(val)->u.rtpPayloadType);
	    break;
	}
    }
}

static ASN1stringtableentry_t NetworkAccessParameters_networkAddress_e164Address_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t NetworkAccessParameters_networkAddress_e164Address_StringTable = {
    4, NetworkAccessParameters_networkAddress_e164Address_StringTableEntries
};

static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Q2931Address(enc, &(val)->u.q2931Address))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.e164Address);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->u.localAreaAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Q2931Address(dec, &(val)->u.q2931Address))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->u.localAreaAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Q2931Address(&(val)->u.q2931Address);
	    break;
	case 2:
	    break;
	case 3:
	    ASN1Free_H245TransportAddress(&(val)->u.localAreaAddress);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataApplicationCapability_application_t84(enc, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataApplicationCapability_application_nlpid(enc, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t30fax))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t140))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataApplicationCapability_application_t84(dec, &(val)->u.t84))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataApplicationCapability_application_nlpid(dec, &(val)->u.nlpid))
	    return 0;
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t30fax))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t140))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_DataProtocolCapability(&(val)->u.t120);
	    break;
	case 3:
	    ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
	    break;
	case 4:
	    ASN1Free_DataProtocolCapability(&(val)->u.userData);
	    break;
	case 5:
	    ASN1Free_DataApplicationCapability_application_t84(&(val)->u.t84);
	    break;
	case 6:
	    ASN1Free_DataProtocolCapability(&(val)->u.t434);
	    break;
	case 7:
	    ASN1Free_DataProtocolCapability(&(val)->u.h224);
	    break;
	case 8:
	    ASN1Free_DataApplicationCapability_application_nlpid(&(val)->u.nlpid);
	    break;
	case 10:
	    ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
	    break;
	case 11:
	    ASN1Free_DataProtocolCapability(&(val)->u.t30fax);
	    break;
	case 12:
	    ASN1Free_DataProtocolCapability(&(val)->u.t140);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val)
{
    if (!ASN1Enc_EnhancementOptions(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val)
{
    if (!ASN1Dec_EnhancementOptions(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement(PEnhancementLayerInfo_spatialEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&val->value);
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val)
{
    if (!ASN1Enc_EnhancementOptions(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val)
{
    if (!ASN1Dec_EnhancementOptions(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement(PEnhancementLayerInfo_snrEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ASN1encoding_t enc, MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RTPPayloadType(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability_rtpPayloadType(ASN1decoding_t dec, MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_RTPPayloadType(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaPacketizationCapability_rtpPayloadType(MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_RTPPayloadType(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val)
{
    if (!ASN1Enc_RedundancyEncodingCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val)
{
    if (!ASN1Dec_RedundancyEncodingCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability(PH2250Capability_redundancyEncodingCapability *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val)
{
    if (val) {
	ASN1Free_RedundancyEncodingCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MaintenanceLoopOffCommand(enc, &(val)->u.maintenanceLoopOffCommand))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SendTerminalCapabilitySet(enc, &(val)->u.sendTerminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_EncryptionCommand(enc, &(val)->u.encryptionCommand))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_FlowControlCommand(enc, &(val)->u.flowControlCommand))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_EndSessionCommand(enc, &(val)->u.endSessionCommand))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MiscellaneousCommand(enc, &(val)->u.miscellaneousCommand))
	    return 0;
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeCommand(ee, &(val)->u.communicationModeCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 9:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceCommand(ee, &(val)->u.conferenceCommand))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 10:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H223MultiplexReconfiguration(ee, &(val)->u.h223MultiplexReconfiguration))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MaintenanceLoopOffCommand(dec, &(val)->u.maintenanceLoopOffCommand))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SendTerminalCapabilitySet(dec, &(val)->u.sendTerminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_EncryptionCommand(dec, &(val)->u.encryptionCommand))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_FlowControlCommand(dec, &(val)->u.flowControlCommand))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_EndSessionCommand(dec, &(val)->u.endSessionCommand))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MiscellaneousCommand(dec, &(val)->u.miscellaneousCommand))
	    return 0;
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeCommand(dd, &(val)->u.communicationModeCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 9:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceCommand(dd, &(val)->u.conferenceCommand))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 10:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H223MultiplexReconfiguration(dd, &(val)->u.h223MultiplexReconfiguration))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_SendTerminalCapabilitySet(&(val)->u.sendTerminalCapabilitySet);
	    break;
	case 4:
	    ASN1Free_EncryptionCommand(&(val)->u.encryptionCommand);
	    break;
	case 6:
	    ASN1Free_EndSessionCommand(&(val)->u.endSessionCommand);
	    break;
	case 7:
	    ASN1Free_MiscellaneousCommand(&(val)->u.miscellaneousCommand);
	    break;
	case 8:
	    ASN1Free_CommunicationModeCommand(&(val)->u.communicationModeCommand);
	    break;
	case 9:
	    ASN1Free_ConferenceCommand(&(val)->u.conferenceCommand);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235SecurityCapability(ASN1encoding_t enc, H235SecurityCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->mediaCapability - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235SecurityCapability(ASN1decoding_t dec, H235SecurityCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->mediaCapability))
	return 0;
    (val)->mediaCapability += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235SecurityCapability(H235SecurityCapability *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
    }
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h261aVideoPacketization))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ee, &(val)->rtpPayloadType))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h261aVideoPacketization))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_MediaPacketizationCapability_rtpPayloadType(dd, &(val)->rtpPayloadType))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaPacketizationCapability(MediaPacketizationCapability *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MediaPacketizationCapability_rtpPayloadType(&(val)->rtpPayloadType);
	}
    }
}

static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H261VideoCapability(enc, &(val)->u.h261VideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H262VideoCapability(enc, &(val)->u.h262VideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H263VideoCapability(enc, &(val)->u.h263VideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_IS11172VideoCapability(enc, &(val)->u.is11172VideoCapability))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H261VideoCapability(dec, &(val)->u.h261VideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H262VideoCapability(dec, &(val)->u.h262VideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H263VideoCapability(dec, &(val)->u.h263VideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_IS11172VideoCapability(dec, &(val)->u.is11172VideoCapability))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 4:
	    ASN1Free_H263VideoCapability(&(val)->u.h263VideoCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BEnhancementParameters(ASN1encoding_t enc, BEnhancementParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EnhancementOptions(enc, &(val)->enhancementOptions))
	return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->numberOfBPictures - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BEnhancementParameters(ASN1decoding_t dec, BEnhancementParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EnhancementOptions(dec, &(val)->enhancementOptions))
	return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->numberOfBPictures))
	return 0;
    (val)->numberOfBPictures += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BEnhancementParameters(BEnhancementParameters *val)
{
    if (val) {
	ASN1Free_EnhancementOptions(&(val)->enhancementOptions);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_DataApplicationCapability_application(enc, &(val)->application))
	return 0;
    l = ASN1uint32_uoctets((val)->maxBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_DataApplicationCapability_application(dec, &(val)->application))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val)
{
    if (val) {
	ASN1Free_DataApplicationCapability_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NetworkAccessParameters_distribution(enc, &(val)->distribution))
	    return 0;
    }
    if (!ASN1Enc_NetworkAccessParameters_networkAddress(enc, &(val)->networkAddress))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->associateConference))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ee, &(val)->t120SetupProcedure))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NetworkAccessParameters_distribution(dec, &(val)->distribution))
	    return 0;
    }
    if (!ASN1Dec_NetworkAccessParameters_networkAddress(dec, &(val)->networkAddress))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->associateConference))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters_t120SetupProcedure(dd, &(val)->t120SetupProcedure))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val)
{
    if (val) {
	ASN1Free_NetworkAccessParameters_networkAddress(&(val)->networkAddress);
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_H2250ModeParameters(ASN1encoding_t enc, H2250ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_RedundancyEncodingMode(enc, &(val)->redundancyEncodingMode))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250ModeParameters(ASN1decoding_t dec, H2250ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_RedundancyEncodingMode(dec, &(val)->redundancyEncodingMode))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250ModeParameters(H2250ModeParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_RedundancyEncodingMode(&(val)->redundancyEncodingMode);
	}
    }
}

static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_DataMode_application(enc, &(val)->application))
	return 0;
    l = ASN1uint32_uoctets((val)->bitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitRate))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_DataMode_application(dec, &(val)->application))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitRate))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode(DataMode *val)
{
    if (val) {
	ASN1Free_DataMode_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 2:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 3:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235Mode_mediaMode(ASN1encoding_t enc, H235Mode_mediaMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H235Mode_mediaMode(ASN1decoding_t dec, H235Mode_mediaMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Mode_mediaMode(H235Mode_mediaMode *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoMode(&(val)->u.videoMode);
	    break;
	case 3:
	    ASN1Free_AudioMode(&(val)->u.audioMode);
	    break;
	case 4:
	    ASN1Free_DataMode(&(val)->u.dataMode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H235Media_mediaType(ASN1encoding_t enc, H235Media_mediaType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H235Media_mediaType(ASN1decoding_t dec, H235Media_mediaType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Media_mediaType(H235Media_mediaType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 3:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 4:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (!ASN1Enc_BEnhancementParameters(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (!ASN1Dec_BEnhancementParameters(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement(PEnhancementLayerInfo_bPictureEnhancement *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (val) {
	ASN1Free_BEnhancementParameters(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_distributedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_distributedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_distributedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val)
{
    if (val) {
	ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_centralizedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val)
{
    if (val) {
	ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveVideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.transmitVideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveAndTransmitVideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAudioCapability))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.transmitAudioCapability))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAndTransmitAudioCapability))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveDataApplicationCapability))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.transmitDataApplicationCapability))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveAndTransmitDataApplicationCapability))
	    return 0;
	break;
    case 11:
	if (!ASN1PEREncBoolean(enc, (val)->u.h233EncryptionTransmitCapability))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_Capability_h233EncryptionReceiveCapability(enc, &(val)->u.h233EncryptionReceiveCapability))
	    return 0;
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceCapability(ee, &(val)->u.conferenceCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 14:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235SecurityCapability(ee, &(val)->u.h235SecurityCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	ASN1PEREncAlignment(ee);
	if (!ASN1PEREncBitVal(ee, 8, (val)->u.maxPendingReplacementFor))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.receiveUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.transmitUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_UserInputCapability(ee, &(val)->u.receiveAndTransmitUserInputCapability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveVideoCapability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.transmitVideoCapability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveAndTransmitVideoCapability))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAudioCapability))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.transmitAudioCapability))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAndTransmitAudioCapability))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveDataApplicationCapability))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.transmitDataApplicationCapability))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveAndTransmitDataApplicationCapability))
	    return 0;
	break;
    case 11:
	if (!ASN1PERDecBoolean(dec, &(val)->u.h233EncryptionTransmitCapability))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_Capability_h233EncryptionReceiveCapability(dec, &(val)->u.h233EncryptionReceiveCapability))
	    return 0;
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceCapability(dd, &(val)->u.conferenceCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 14:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H235SecurityCapability(dd, &(val)->u.h235SecurityCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1PERDecAlignment(dd);
	if (!ASN1PERDecU16Val(dd, 8, &(val)->u.maxPendingReplacementFor))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.receiveUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.transmitUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_UserInputCapability(dd, &(val)->u.receiveAndTransmitUserInputCapability))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Capability(Capability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoCapability(&(val)->u.receiveVideoCapability);
	    break;
	case 3:
	    ASN1Free_VideoCapability(&(val)->u.transmitVideoCapability);
	    break;
	case 4:
	    ASN1Free_VideoCapability(&(val)->u.receiveAndTransmitVideoCapability);
	    break;
	case 5:
	    ASN1Free_AudioCapability(&(val)->u.receiveAudioCapability);
	    break;
	case 6:
	    ASN1Free_AudioCapability(&(val)->u.transmitAudioCapability);
	    break;
	case 7:
	    ASN1Free_AudioCapability(&(val)->u.receiveAndTransmitAudioCapability);
	    break;
	case 8:
	    ASN1Free_DataApplicationCapability(&(val)->u.receiveDataApplicationCapability);
	    break;
	case 9:
	    ASN1Free_DataApplicationCapability(&(val)->u.transmitDataApplicationCapability);
	    break;
	case 10:
	    ASN1Free_DataApplicationCapability(&(val)->u.receiveAndTransmitDataApplicationCapability);
	    break;
	case 13:
	    ASN1Free_ConferenceCapability(&(val)->u.conferenceCapability);
	    break;
	case 14:
	    ASN1Free_H235SecurityCapability(&(val)->u.h235SecurityCapability);
	    break;
	case 16:
	    ASN1Free_UserInputCapability(&(val)->u.receiveUserInputCapability);
	    break;
	case 17:
	    ASN1Free_UserInputCapability(&(val)->u.transmitUserInputCapability);
	    break;
	case 18:
	    ASN1Free_UserInputCapability(&(val)->u.receiveAndTransmitUserInputCapability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x20;
    o[0] |= 0x10;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAudioDelayJitter))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveMultipointCapability))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->transmitMultipointCapability))
	return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveAndTransmitMultipointCapability))
	return 0;
    if (!ASN1Enc_H2250Capability_mcCapability(enc, &(val)->mcCapability))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rtcpVideoControlCapability))
	return 0;
    if (!ASN1Enc_MediaPacketizationCapability(enc, &(val)->mediaPacketizationCapability))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 4, o + 0))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (o[0] & 0x80) {
	    if (!ASN1Enc_TransportCapability(ee, &(val)->transportCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x40) {
	    if (!ASN1Enc_H2250Capability_redundancyEncodingCapability(ee, &(val)->redundancyEncodingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x20) {
	    if (!ASN1PEREncBoolean(ee, (val)->logicalChannelSwitchingCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if (o[0] & 0x10) {
	    if (!ASN1PEREncBoolean(ee, (val)->t120DynamicPortCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAudioDelayJitter))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveMultipointCapability))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->transmitMultipointCapability))
	return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveAndTransmitMultipointCapability))
	return 0;
    if (!ASN1Dec_H2250Capability_mcCapability(dec, &(val)->mcCapability))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rtcpVideoControlCapability))
	return 0;
    if (!ASN1Dec_MediaPacketizationCapability(dec, &(val)->mediaPacketizationCapability))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 0, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 0))
	    return 0;
	if ((val)->o[0] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_TransportCapability(dd, &(val)->transportCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H2250Capability_redundancyEncodingCapability(dd, &(val)->redundancyEncodingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->logicalChannelSwitchingCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[0] & 0x10) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecBoolean(dd, &(val)->t120DynamicPortCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val)
{
    if (val) {
	ASN1Free_MultipointCapability(&(val)->receiveMultipointCapability);
	ASN1Free_MultipointCapability(&(val)->transmitMultipointCapability);
	ASN1Free_MultipointCapability(&(val)->receiveAndTransmitMultipointCapability);
	ASN1Free_MediaPacketizationCapability(&(val)->mediaPacketizationCapability);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportCapability(&(val)->transportCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_H2250Capability_redundancyEncodingCapability(&(val)->redundancyEncodingCapability);
	}
    }
}

static int ASN1CALL ASN1Enc_H235Media(ASN1encoding_t enc, H235Media *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Enc_H235Media_mediaType(enc, &(val)->mediaType))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235Media(ASN1decoding_t dec, H235Media *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Dec_H235Media_mediaType(dec, &(val)->mediaType))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Media(H235Media *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
	ASN1Free_H235Media_mediaType(&(val)->mediaType);
    }
}

static int ASN1CALL ASN1Enc_H235Mode(ASN1encoding_t enc, H235Mode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Enc_H235Mode_mediaMode(enc, &(val)->mediaMode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235Mode(ASN1decoding_t dec, H235Mode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
	return 0;
    if (!ASN1Dec_H235Mode_mediaMode(dec, &(val)->mediaMode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Mode(H235Mode *val)
{
    if (val) {
	ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
	ASN1Free_H235Mode_mediaMode(&(val)->mediaMode);
    }
}

static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionMode))
	    return 0;
	break;
    case 6:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235Mode(ee, &(val)->u.h235Mode))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionMode))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H235Mode(dd, &(val)->u.h235Mode))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_VideoMode(&(val)->u.videoMode);
	    break;
	case 3:
	    ASN1Free_AudioMode(&(val)->u.audioMode);
	    break;
	case 4:
	    ASN1Free_DataMode(&(val)->u.dataMode);
	    break;
	case 5:
	    ASN1Free_EncryptionMode(&(val)->u.encryptionMode);
	    break;
	case 6:
	    ASN1Free_H235Mode(&(val)->u.h235Mode);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->capabilityTableEntryNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Capability(enc, &(val)->capability))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->capabilityTableEntryNumber))
	return 0;
    (val)->capabilityTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_Capability(dec, &(val)->capability))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Capability(&(val)->capability);
	}
    }
}

static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H222Capability(enc, &(val)->u.h222Capability))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H223Capability(enc, &(val)->u.h223Capability))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_V76Capability(enc, &(val)->u.v76Capability))
	    return 0;
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250Capability(ee, &(val)->u.h2250Capability))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H222Capability(dec, &(val)->u.h222Capability))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H223Capability(dec, &(val)->u.h223Capability))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_V76Capability(dec, &(val)->u.v76Capability))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H2250Capability(dd, &(val)->u.h2250Capability))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_H222Capability(&(val)->u.h222Capability);
	    break;
	case 5:
	    ASN1Free_H2250Capability(&(val)->u.h2250Capability);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionData))
	    return 0;
	break;
    case 7:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.h235Control))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 8:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H235Media(ee, &(val)->u.h235Media))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionData))
	    return 0;
	break;
    case 7:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.h235Control))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 8:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H235Media(dd, &(val)->u.h235Media))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataType(DataType *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_VideoCapability(&(val)->u.videoData);
	    break;
	case 4:
	    ASN1Free_AudioCapability(&(val)->u.audioData);
	    break;
	case 5:
	    ASN1Free_DataApplicationCapability(&(val)->u.data);
	    break;
	case 6:
	    ASN1Free_EncryptionMode(&(val)->u.encryptionData);
	    break;
	case 7:
	    ASN1Free_NonStandardParameter(&(val)->u.h235Control);
	    break;
	case 8:
	    ASN1Free_H235Media(&(val)->u.h235Media);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncoding(ASN1encoding_t enc, RedundancyEncoding *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_DataType(enc, &(val)->secondaryEncoding))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncoding(ASN1decoding_t dec, RedundancyEncoding *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_DataType(dec, &(val)->secondaryEncoding))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncoding(RedundancyEncoding *val)
{
    if (val) {
	ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DataType(&(val)->secondaryEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ModeElement_type(enc, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H223ModeParameters(enc, &(val)->h223ModeParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_V76ModeParameters(ee, &(val)->v76ModeParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_H2250ModeParameters(ee, &(val)->h2250ModeParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ModeElement_type(dec, &(val)->type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H223ModeParameters(dec, &(val)->h223ModeParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_V76ModeParameters(dd, &(val)->v76ModeParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_H2250ModeParameters(dd, &(val)->h2250ModeParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement(ModeElement *val)
{
    if (val) {
	ASN1Free_ModeElement_type(&(val)->type);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H223ModeParameters(&(val)->h223ModeParameters);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H2250ModeParameters(&(val)->h2250ModeParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CommunicationModeTableEntry_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
	    return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->sessionDescription).length - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->sessionDescription).length, ((val)->sessionDescription).value, 16))
	return 0;
    if (!ASN1Enc_CommunicationModeTableEntry_dataType(enc, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_RedundancyEncoding(ee, &(val)->redundancyEncoding))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncBitVal(ee, 8, (val)->sessionDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_TerminalLabel(ee, &(val)->destination))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CommunicationModeTableEntry_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	return 0;
    (val)->sessionID += 1;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
	    return 0;
	(val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
	    return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->sessionDescription).length))
	return 0;
    ((val)->sessionDescription).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->sessionDescription).length, &((val)->sessionDescription).value, 16))
	return 0;
    if (!ASN1Dec_CommunicationModeTableEntry_dataType(dec, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RedundancyEncoding(dd, &(val)->redundancyEncoding))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecU16Val(dd, 8, &(val)->sessionDependency))
		return 0;
	    (val)->sessionDependency += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_TerminalLabel(dd, &(val)->destination))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CommunicationModeTableEntry_nonStandard(&(val)->nonStandard);
	}
	ASN1char16string_free(&(val)->sessionDescription);
	ASN1Free_CommunicationModeTableEntry_dataType(&(val)->dataType);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_RedundancyEncoding(&(val)->redundancyEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val)
{
    if (val) {
	ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val)
{
    if (val) {
	ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Enc_CapabilityTableEntry(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Dec_CapabilityTableEntry(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val)
{
    if (val) {
	ASN1Free_CapabilityTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MultiplexCapability(enc, &(val)->multiplexCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_TerminalCapabilitySet_capabilityTable(enc, &(val)->capabilityTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(enc, &(val)->capabilityDescriptors))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_MultiplexCapability(dec, &(val)->multiplexCapability))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_TerminalCapabilitySet_capabilityTable(dec, &(val)->capabilityTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(dec, &(val)->capabilityDescriptors))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MultiplexCapability(&(val)->multiplexCapability);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_TerminalCapabilitySet_capabilityTable(&(val)->capabilityTable);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_TerminalCapabilitySet_capabilityDescriptors(&(val)->capabilityDescriptors);
	}
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 2);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H2250LogicalChannelParameters_nonStandard(enc, &(val)->nonStandard))
	    return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_TerminalLabel(enc, &(val)->destination))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(enc, &(val)->mediaPacketization))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 2))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[2] & 0x80) {
	    if (!ASN1Enc_TransportCapability(ee, &(val)->transportCapability))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1Enc_RedundancyEncoding(ee, &(val)->redundancyEncoding))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1Enc_TerminalLabel(ee, &(val)->source))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H2250LogicalChannelParameters_nonStandard(dec, &(val)->nonStandard))
	    return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
	    return 0;
	(val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_TerminalLabel(dec, &(val)->destination))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
	    return 0;
	(val)->dynamicRTPPayloadType += 96;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(dec, &(val)->mediaPacketization))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 2, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 2))
	    return 0;
	if ((val)->o[2] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_TransportCapability(dd, &(val)->transportCapability))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[2] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_RedundancyEncoding(dd, &(val)->redundancyEncoding))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[2] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_TerminalLabel(dd, &(val)->source))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H2250LogicalChannelParameters_nonStandard(&(val)->nonStandard);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_H245TransportAddress(&(val)->mediaChannel);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_H2250LogicalChannelParameters_mediaPacketization(&(val)->mediaPacketization);
	}
	if ((val)->o[2] & 0x80) {
	    ASN1Free_TransportCapability(&(val)->transportCapability);
	}
	if ((val)->o[2] & 0x40) {
	    ASN1Free_RedundancyEncoding(&(val)->redundancyEncoding);
	}
    }
}

static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ModeElement(enc, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
	return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Dec_ModeElement(dec, &((val)->value)[i]))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 0; i < (val)->count; i++) {
	    ASN1Free_ModeElement(&(val)->value[i]);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 4:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 5:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 4:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 5:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
	    break;
	case 2:
	    ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
	    break;
	case 4:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
	    break;
	case 3:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
	    break;
	case 2:
	    ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestMode_requestedModes_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val)
{
    if (!ASN1Enc_ModeDescription(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestMode_requestedModes_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val)
{
    if (!ASN1Dec_ModeDescription(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestMode_requestedModes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val)
{
    if (val) {
	ASN1Free_ModeDescription(&val->value);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->reverseLogicalChannelNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->reverseLogicalChannelNumber))
	return 0;
    (val)->reverseLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->reverseLogicalChannelDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->reverseLogicalChannelDependency))
		return 0;
	    (val)->reverseLogicalChannelDependency += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_DataType(&(val)->dataType);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
	    return 0;
    }
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
	return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->forwardLogicalChannelDependency - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
	    return 0;
    }
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
	return 0;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->forwardLogicalChannelDependency))
		return 0;
	    (val)->forwardLogicalChannelDependency += 1;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
		return 0;
	    (val)->replacementFor += 1;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    if (val) {
	ASN1Free_DataType(&(val)->dataType);
	ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(enc, &(val)->forwardLogicalChannelParameters))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_EncryptionSync(ee, &(val)->encryptionSync))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(dec, &(val)->forwardLogicalChannelParameters))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_EncryptionSync(dd, &(val)->encryptionSync))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val)
{
    if (val) {
	ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(&(val)->forwardLogicalChannelParameters);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_NetworkAccessParameters(&(val)->separateStack);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_EncryptionSync(&(val)->encryptionSync);
	}
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ee, &(val)->forwardMultiplexAckParameters))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1Enc_EncryptionSync(ee, &(val)->encryptionSync))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
	return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
	    return 0;
    }
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(dd, &(val)->forwardMultiplexAckParameters))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	if ((val)->o[1] & 0x20) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
		return 0;
	    if (!ASN1Dec_EncryptionSync(dd, &(val)->encryptionSync))
		return 0;
	    ASN1_CloseDecoder(dd);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_NetworkAccessParameters(&(val)->separateStack);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(&(val)->forwardMultiplexAckParameters);
	}
	if ((val)->o[1] & 0x20) {
	    ASN1Free_EncryptionSync(&(val)->encryptionSync);
	}
    }
}

static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 11))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MasterSlaveDetermination(enc, &(val)->u.masterSlaveDetermination))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TerminalCapabilitySet(enc, &(val)->u.terminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_OpenLogicalChannel(enc, &(val)->u.openLogicalChannel))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_CloseLogicalChannel(enc, &(val)->u.closeLogicalChannel))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelClose(enc, &(val)->u.requestChannelClose))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySend(enc, &(val)->u.multiplexEntrySend))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntry(enc, &(val)->u.requestMultiplexEntry))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestMode(enc, &(val)->u.requestMode))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RoundTripDelayRequest(enc, &(val)->u.roundTripDelayRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_MaintenanceLoopRequest(enc, &(val)->u.maintenanceLoopRequest))
	    return 0;
	break;
    case 12:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeRequest(ee, &(val)->u.communicationModeRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 13:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceRequest(ee, &(val)->u.conferenceRequest))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 11))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MasterSlaveDetermination(dec, &(val)->u.masterSlaveDetermination))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TerminalCapabilitySet(dec, &(val)->u.terminalCapabilitySet))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_OpenLogicalChannel(dec, &(val)->u.openLogicalChannel))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_CloseLogicalChannel(dec, &(val)->u.closeLogicalChannel))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelClose(dec, &(val)->u.requestChannelClose))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySend(dec, &(val)->u.multiplexEntrySend))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntry(dec, &(val)->u.requestMultiplexEntry))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestMode(dec, &(val)->u.requestMode))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RoundTripDelayRequest(dec, &(val)->u.roundTripDelayRequest))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_MaintenanceLoopRequest(dec, &(val)->u.maintenanceLoopRequest))
	    return 0;
	break;
    case 12:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeRequest(dd, &(val)->u.communicationModeRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 13:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceRequest(dd, &(val)->u.conferenceRequest))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 3:
	    ASN1Free_TerminalCapabilitySet(&(val)->u.terminalCapabilitySet);
	    break;
	case 4:
	    ASN1Free_OpenLogicalChannel(&(val)->u.openLogicalChannel);
	    break;
	case 6:
	    ASN1Free_RequestChannelClose(&(val)->u.requestChannelClose);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySend(&(val)->u.multiplexEntrySend);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntry(&(val)->u.requestMultiplexEntry);
	    break;
	case 9:
	    ASN1Free_RequestMode(&(val)->u.requestMode);
	    break;
	case 13:
	    ASN1Free_ConferenceRequest(&(val)->u.conferenceRequest);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 19))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MasterSlaveDeterminationAck(enc, &(val)->u.masterSlaveDeterminationAck))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationReject(enc, &(val)->u.masterSlaveDeterminationReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetAck(enc, &(val)->u.terminalCapabilitySetAck))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_TerminalCapabilitySetReject(enc, &(val)->u.terminalCapabilitySetReject))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_OpenLogicalChannelAck(enc, &(val)->u.openLogicalChannelAck))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_OpenLogicalChannelReject(enc, &(val)->u.openLogicalChannelReject))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_CloseLogicalChannelAck(enc, &(val)->u.closeLogicalChannelAck))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestChannelCloseAck(enc, &(val)->u.requestChannelCloseAck))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RequestChannelCloseReject(enc, &(val)->u.requestChannelCloseReject))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_MultiplexEntrySendAck(enc, &(val)->u.multiplexEntrySendAck))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_MultiplexEntrySendReject(enc, &(val)->u.multiplexEntrySendReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_RequestMultiplexEntryAck(enc, &(val)->u.requestMultiplexEntryAck))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_RequestMultiplexEntryReject(enc, &(val)->u.requestMultiplexEntryReject))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_RequestModeAck(enc, &(val)->u.requestModeAck))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_RequestModeReject(enc, &(val)->u.requestModeReject))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_RoundTripDelayResponse(enc, &(val)->u.roundTripDelayResponse))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_MaintenanceLoopAck(enc, &(val)->u.maintenanceLoopAck))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_MaintenanceLoopReject(enc, &(val)->u.maintenanceLoopReject))
	    return 0;
	break;
    case 20:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_CommunicationModeResponse(ee, &(val)->u.communicationModeResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 21:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceResponse(ee, &(val)->u.conferenceResponse))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 19))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_MasterSlaveDeterminationAck(dec, &(val)->u.masterSlaveDeterminationAck))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationReject(dec, &(val)->u.masterSlaveDeterminationReject))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetAck(dec, &(val)->u.terminalCapabilitySetAck))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_TerminalCapabilitySetReject(dec, &(val)->u.terminalCapabilitySetReject))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_OpenLogicalChannelAck(dec, &(val)->u.openLogicalChannelAck))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_OpenLogicalChannelReject(dec, &(val)->u.openLogicalChannelReject))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_CloseLogicalChannelAck(dec, &(val)->u.closeLogicalChannelAck))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestChannelCloseAck(dec, &(val)->u.requestChannelCloseAck))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RequestChannelCloseReject(dec, &(val)->u.requestChannelCloseReject))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_MultiplexEntrySendAck(dec, &(val)->u.multiplexEntrySendAck))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_MultiplexEntrySendReject(dec, &(val)->u.multiplexEntrySendReject))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_RequestMultiplexEntryAck(dec, &(val)->u.requestMultiplexEntryAck))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_RequestMultiplexEntryReject(dec, &(val)->u.requestMultiplexEntryReject))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_RequestModeAck(dec, &(val)->u.requestModeAck))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_RequestModeReject(dec, &(val)->u.requestModeReject))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_RoundTripDelayResponse(dec, &(val)->u.roundTripDelayResponse))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_MaintenanceLoopAck(dec, &(val)->u.maintenanceLoopAck))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_MaintenanceLoopReject(dec, &(val)->u.maintenanceLoopReject))
	    return 0;
	break;
    case 20:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_CommunicationModeResponse(dd, &(val)->u.communicationModeResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 21:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceResponse(dd, &(val)->u.conferenceResponse))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 6:
	    ASN1Free_OpenLogicalChannelAck(&(val)->u.openLogicalChannelAck);
	    break;
	case 11:
	    ASN1Free_MultiplexEntrySendAck(&(val)->u.multiplexEntrySendAck);
	    break;
	case 12:
	    ASN1Free_MultiplexEntrySendReject(&(val)->u.multiplexEntrySendReject);
	    break;
	case 13:
	    ASN1Free_RequestMultiplexEntryAck(&(val)->u.requestMultiplexEntryAck);
	    break;
	case 14:
	    ASN1Free_RequestMultiplexEntryReject(&(val)->u.requestMultiplexEntryReject);
	    break;
	case 20:
	    ASN1Free_CommunicationModeResponse(&(val)->u.communicationModeResponse);
	    break;
	case 21:
	    ASN1Free_ConferenceResponse(&(val)->u.conferenceResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val)
{
    if (!ASN1Enc_OpenLogicalChannel(enc, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val)
{
    if (!ASN1Dec_OpenLogicalChannel(dec, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val)
{
    if (val) {
	ASN1Free_OpenLogicalChannel(val);
    }
}

static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_FunctionNotUnderstood(enc, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MasterSlaveDeterminationRelease(enc, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TerminalCapabilitySetRelease(enc, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_OpenLogicalChannelConfirm(enc, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_RequestChannelCloseRelease(enc, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_MultiplexEntrySendRelease(enc, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RequestMultiplexEntryRelease(enc, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RequestModeRelease(enc, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_MiscellaneousIndication(enc, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_JitterIndication(enc, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_H223SkewIndication(enc, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_NewATMVCIndication(enc, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_UserInputIndication(enc, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_H2250MaximumSkewIndication(ee, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 16:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_MCLocationIndication(ee, &(val)->u.mcLocationIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 17:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_ConferenceIndication(ee, &(val)->u.conferenceIndication))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 18:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_VendorIdentification(ee, &(val)->u.vendorIdentification))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    case 19:
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if (!ASN1Enc_FunctionNotSupported(ee, &(val)->u.functionNotSupported))
	    return 0;
	if (!ASN1PEREncFlushFragmentedToParent(ee))
	    return 0;
	ASN1_CloseEncoder2(ee);
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_FunctionNotUnderstood(dec, &(val)->u.functionNotUnderstood))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_MasterSlaveDeterminationRelease(dec, &(val)->u.masterSlaveDeterminationRelease))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TerminalCapabilitySetRelease(dec, &(val)->u.terminalCapabilitySetRelease))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_OpenLogicalChannelConfirm(dec, &(val)->u.openLogicalChannelConfirm))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_RequestChannelCloseRelease(dec, &(val)->u.requestChannelCloseRelease))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_MultiplexEntrySendRelease(dec, &(val)->u.multiplexEntrySendRelease))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RequestMultiplexEntryRelease(dec, &(val)->u.requestMultiplexEntryRelease))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RequestModeRelease(dec, &(val)->u.requestModeRelease))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_MiscellaneousIndication(dec, &(val)->u.miscellaneousIndication))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_JitterIndication(dec, &(val)->u.jitterIndication))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_H223SkewIndication(dec, &(val)->u.h223SkewIndication))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_NewATMVCIndication(dec, &(val)->u.newATMVCIndication))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_UserInputIndication(dec, &(val)->u.userInput))
	    return 0;
	break;
    case 15:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_H2250MaximumSkewIndication(dd, &(val)->u.h2250MaximumSkewIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 16:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_MCLocationIndication(dd, &(val)->u.mcLocationIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 17:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_ConferenceIndication(dd, &(val)->u.conferenceIndication))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 18:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_VendorIdentification(dd, &(val)->u.vendorIdentification))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 19:
	if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
	    return 0;
	if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
	    return 0;
	if (!ASN1Dec_FunctionNotSupported(dd, &(val)->u.functionNotSupported))
	    return 0;
	ASN1_CloseDecoder(dd);
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
	    break;
	case 2:
	    ASN1Free_FunctionNotUnderstood(&(val)->u.functionNotUnderstood);
	    break;
	case 7:
	    ASN1Free_MultiplexEntrySendRelease(&(val)->u.multiplexEntrySendRelease);
	    break;
	case 8:
	    ASN1Free_RequestMultiplexEntryRelease(&(val)->u.requestMultiplexEntryRelease);
	    break;
	case 10:
	    ASN1Free_MiscellaneousIndication(&(val)->u.miscellaneousIndication);
	    break;
	case 14:
	    ASN1Free_UserInputIndication(&(val)->u.userInput);
	    break;
	case 16:
	    ASN1Free_MCLocationIndication(&(val)->u.mcLocationIndication);
	    break;
	case 18:
	    ASN1Free_VendorIdentification(&(val)->u.vendorIdentification);
	    break;
	case 19:
	    ASN1Free_FunctionNotSupported(&(val)->u.functionNotSupported);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_IndicationMessage(enc, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_IndicationMessage(dec, &(val)->u.indication))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestMessage(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponseMessage(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_CommandMessage(&(val)->u.command);
	    break;
	case 4:
	    ASN1Free_IndicationMessage(&(val)->u.indication);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h323aud.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confaud.h

Abstract:

    Definitions for audio streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFAUD_H_
#define __CONFAUD_H_

// the volume range for the API.
const long  MIN_VOLUME    = 0;      
const long  MAX_VOLUME    = 0xFFFF;

const long  BALANCE_LEFT  = -100;
const long  BALANCE_RIGHT = 100;

const long  BOOST_FACTOR = 100;

// the volume range of the IAMInputMixer
const double MIXER_MIN_VOLUME = 0.0;
const double MIXER_MAX_VOLUME = 1.0;

const long DEFUAT_AEC_STATUS = 0;
const long DEFUAT_AGC_STATUS = 1;

class CStreamAudioRecv : 
    public CH323MSPStream,
    public ITAudioSettings
{

BEGIN_COM_MAP(CStreamAudioRecv)
    COM_INTERFACE_ENTRY(ITAudioSettings)
    COM_INTERFACE_ENTRY_CHAIN(CH323MSPStream)
END_COM_MAP()

public:
    CStreamAudioRecv();
    ~CStreamAudioRecv();

    HRESULT ShutDown();

    // this method is called by the call object at init time.
    void SetFullDuplexController(
        IN IAudioDuplexController * pIAudioDuplexController
        );

    //
    // ITAudioSettings methods
    //
    STDMETHOD (GetRange) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioSettingsProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

protected:

    HRESULT SetUpInternalFilters(
        IN IPin * pTerminalInputPin
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );
    
    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT InitializeH245CapabilityTable();

protected:
    IBaseFilter *           m_pDecoderFilter;
    IAudioDuplexController *m_pIAudioDuplexController;
    IBitrateControl *       m_pRenderBitrateControl;
};

class CStreamAudioSend : 
    public CH323MSPStream,
    public ITAudioSettings,
    public ITAudioDeviceControl

{

BEGIN_COM_MAP(CStreamAudioSend)
    COM_INTERFACE_ENTRY(ITAudioSettings)
    COM_INTERFACE_ENTRY(ITAudioDeviceControl)
    COM_INTERFACE_ENTRY_CHAIN(CH323MSPStream)
END_COM_MAP()

public:
    CStreamAudioSend();
    ~CStreamAudioSend();

    HRESULT ShutDown();

    // this method is called by the call object at init time.
    void SetFullDuplexController(
        IN IAudioDuplexController *pIAudioDuplexController
        );

    //
    // ITAudioDeviceControl methods
    //
    STDMETHOD (GetRange) (
        IN   AudioDeviceProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioDeviceProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioDeviceProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITAudioSettings methods
    //
    STDMETHOD (GetRange) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioSettingsProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

protected:

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pPin
        );

    HRESULT GetAudioCapturePin(
        IN   ITTerminalControl *    pTerminal,
        OUT  IPin **                ppIPin
        );

    void CleanupCachedInterface();

    HRESULT CacheAdditionalInterfaces(
        IN  IPin *                 pIPin
        );

protected:
    ISilenceControl *       m_pSilenceControl;
    IAMAudioInputMixer  *   m_pAudioInputMixer;
    IAudioDeviceControl *   m_pAudioDeviceControl;
    IAudioDuplexController *m_pIAudioDuplexController;
    IBitrateControl *       m_pCaptureBitrateControl;
    IBaseFilter *           m_pEncoder;
    long                    m_lAutomaticGainControl;
    long                    m_lAcousticEchoCancellation;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h245asn.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#ifndef _H245ASN_Module_H_
#define _H245ASN_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct RedundancyEncodingCapability_secondaryEncoding * PRedundancyEncodingCapability_secondaryEncoding;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation * PRequestAllTerminalIDsResponse_terminalInformation;

typedef struct EncryptionSync_escrowentry * PEncryptionSync_escrowentry;

typedef struct H263Options_customPictureFormat * PH263Options_customPictureFormat;

typedef struct H263Options_customPictureClockFrequency * PH263Options_customPictureClockFrequency;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CertSelectionCriteria * PCertSelectionCriteria;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct H263Options_modeCombos * PH263Options_modeCombos;

typedef struct TransportCapability_qOSCapabilities * PTransportCapability_qOSCapabilities;

typedef struct EncryptionCapability * PEncryptionCapability;

typedef struct EnhancementLayerInfo_spatialEnhancement * PEnhancementLayerInfo_spatialEnhancement;

typedef struct EnhancementLayerInfo_snrEnhancement * PEnhancementLayerInfo_snrEnhancement;

typedef struct H2250Capability_redundancyEncodingCapability * PH2250Capability_redundancyEncodingCapability;

typedef struct EnhancementLayerInfo_bPictureEnhancement * PEnhancementLayerInfo_bPictureEnhancement;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set;

typedef ASN1uint16_t RTPH263VideoRedundancyEncoding_containedThreads_Seq;

typedef ASN1uint16_t RTPH263VideoRedundancyFrameMapping_frameSequence_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct H245Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} H245Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart_repeatCount {
    ASN1choice_t choice;
#   define doOneProgression_chosen 1
#   define doContinuousProgressions_chosen 2
#   define doOneIndependentProgression_chosen 3
#   define doContinuousIndependentProgressions_chosen 4
} MiscellaneousCommand_type_progressiveRefinementStart_repeatCount;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR_Set {
    ASN1uint16_t width;
    ASN1uint16_t height;
} CustomPictureFormat_pixelAspectInformation_extendedPAR_Set;

typedef struct CustomPictureFormat_mPI_customPCF_Set {
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
    ASN1uint16_t customMPI;
} CustomPictureFormat_mPI_customPCF_Set;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct CustomPictureFormat_mPI_customPCF {
    ASN1uint32_t count;
    CustomPictureFormat_mPI_customPCF_Set value[16];
} CustomPictureFormat_mPI_customPCF;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_Set value[256];
} CustomPictureFormat_pixelAspectInformation_extendedPAR;

typedef struct CustomPictureFormat_pixelAspectInformation_pixelAspectCode {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set value[14];
} CustomPictureFormat_pixelAspectInformation_pixelAspectCode;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart {
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount repeatCount;
} MiscellaneousCommand_type_progressiveRefinementStart;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_reverseParameters_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_reverseParameters_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_reverseParameters_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_reverseParameters_multiplex_programStream_chosen 3
} NewATMVCIndication_reverseParameters_multiplex;

typedef struct UserInputIndication_signal_rtp {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define timestamp_present 0x80
    ASN1uint32_t timestamp;
#   define expirationTime_present 0x40
    ASN1uint32_t expirationTime;
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signal_rtp;

typedef struct UserInputIndication_signalUpdate_rtp {
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signalUpdate_rtp;

typedef struct UserInputIndication_signalUpdate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t duration;
#   define UserInputIndication_signalUpdate_rtp_present 0x80
    UserInputIndication_signalUpdate_rtp rtp;
} UserInputIndication_signalUpdate;

typedef struct UserInputIndication_signal {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1char_t signalType[2];
#   define duration_present 0x80
    ASN1uint16_t duration;
#   define UserInputIndication_signal_rtp_present 0x40
    UserInputIndication_signal_rtp rtp;
} UserInputIndication_signal;

typedef struct NewATMVCIndication_reverseParameters {
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_reverseParameters_multiplex multiplex;
} NewATMVCIndication_reverseParameters;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_multiplex_programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct H223MultiplexReconfiguration_h223AnnexADoubleFlag {
    ASN1choice_t choice;
#   define start_chosen 1
#   define stop_chosen 2
} H223MultiplexReconfiguration_h223AnnexADoubleFlag;

typedef struct H223MultiplexReconfiguration_h223ModeChange {
    ASN1choice_t choice;
#   define toLevel0_chosen 1
#   define toLevel1_chosen 2
#   define toLevel2_chosen 3
#   define toLevel2withOptionalHeader_chosen 4
} H223MultiplexReconfiguration_h223ModeChange;

typedef struct EndSessionCommand_isdnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_isdnOptions_telephonyMode_chosen 1
#   define v140_chosen 2
#   define terminalOnHold_chosen 3
} EndSessionCommand_isdnOptions;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_gstnOptions_telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct RemoteMCResponse_reject {
    ASN1choice_t choice;
#   define RemoteMCResponse_reject_unspecified_chosen 1
#   define RemoteMCResponse_reject_functionNotSupported_chosen 2
} RemoteMCResponse_reject;

typedef struct ConferenceResponse_sendThisSourceResponse {
    ASN1choice_t choice;
#   define grantedSendThisSource_chosen 1
#   define deniedSendThisSource_chosen 2
} ConferenceResponse_sendThisSourceResponse;

typedef struct ConferenceResponse_makeTerminalBroadcasterResponse {
    ASN1choice_t choice;
#   define grantedMakeTerminalBroadcaster_chosen 1
#   define deniedMakeTerminalBroadcaster_chosen 2
} ConferenceResponse_makeTerminalBroadcasterResponse;

typedef struct ConferenceResponse_broadcastMyLogicalChannelResponse {
    ASN1choice_t choice;
#   define grantedBroadcastMyLogicalChannel_chosen 1
#   define deniedBroadcastMyLogicalChannel_chosen 2
} ConferenceResponse_broadcastMyLogicalChannelResponse;

typedef struct ConferenceResponse_extensionAddressResponse {
    TerminalID extensionAddress;
} ConferenceResponse_extensionAddressResponse;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct G7231AnnexCMode_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCMode_g723AnnexCAudioMode;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct RequestChannelClose_reason {
    ASN1choice_t choice;
#   define RequestChannelClose_reason_unknown_chosen 1
#   define normal_chosen 2
#   define RequestChannelClose_reason_reopen_chosen 3
#   define RequestChannelClose_reason_reservationFailure_chosen 4
} RequestChannelClose_reason;

typedef struct CloseLogicalChannel_reason {
    ASN1choice_t choice;
#   define CloseLogicalChannel_reason_unknown_chosen 1
#   define CloseLogicalChannel_reason_reopen_chosen 2
#   define CloseLogicalChannel_reason_reservationFailure_chosen 3
} CloseLogicalChannel_reason;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
#   define waitForCommunicationMode_chosen 12
#   define invalidDependentChannel_chosen 13
#   define replacementForRejected_chosen 14
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define noSuspendResume_chosen 1
#   define V76LogicalChannelParameters_suspendResume_suspendResumewAddress_chosen 2
#   define V76LogicalChannelParameters_suspendResume_suspendResumewoAddress_chosen 3
} V76LogicalChannelParameters_suspendResume;

typedef struct H223AnnexCArqParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define H223AnnexCArqParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} H223AnnexCArqParameters_numberOfRetransmissions;

typedef struct H223AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL3MParameters_crcLength_crc4bit_chosen 1
#   define H223AL3MParameters_crcLength_crc12bit_chosen 2
#   define H223AL3MParameters_crcLength_crc20bit_chosen 3
#   define H223AL3MParameters_crcLength_crc28bit_chosen 4
} H223AL3MParameters_crcLength;

typedef struct H223AL3MParameters_headerFormat {
    ASN1choice_t choice;
#   define H223AL3MParameters_headerFormat_sebch16_7_chosen 1
#   define H223AL3MParameters_headerFormat_golay24_12_chosen 2
} H223AL3MParameters_headerFormat;

typedef struct H223AL2MParameters_headerFEC {
    ASN1choice_t choice;
#   define sebch16_5_chosen 1
#   define H223AL2MParameters_headerFEC_golay24_12_chosen 2
} H223AL2MParameters_headerFEC;

typedef struct H223AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL1MParameters_crcLength_crc4bit_chosen 1
#   define H223AL1MParameters_crcLength_crc12bit_chosen 2
#   define H223AL1MParameters_crcLength_crc20bit_chosen 3
#   define H223AL1MParameters_crcLength_crc28bit_chosen 4
} H223AL1MParameters_crcLength;

typedef struct H223AL1MParameters_headerFEC {
    ASN1choice_t choice;
#   define H223AL1MParameters_headerFEC_sebch16_7_chosen 1
#   define H223AL1MParameters_headerFEC_golay24_12_chosen 2
} H223AL1MParameters_headerFEC;

typedef struct H223AL1MParameters_transferMode {
    ASN1choice_t choice;
#   define framed_chosen 1
#   define unframed_chosen 2
} H223AL1MParameters_transferMode;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_t120SetupProcedure {
    ASN1choice_t choice;
#   define originateCall_chosen 1
#   define waitForCall_chosen 2
#   define issueQuery_chosen 3
} NetworkAccessParameters_t120SetupProcedure;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct G7231AnnexCCapability_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCCapability_g723AnnexCAudioMode;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct CustomPictureFormat_pixelAspectInformation {
    ASN1choice_t choice;
    union {
#	define anyPixelAspectRatio_chosen 1
	ASN1bool_t anyPixelAspectRatio;
#	define pixelAspectCode_chosen 2
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode pixelAspectCode;
#	define extendedPAR_chosen 3
	CustomPictureFormat_pixelAspectInformation_extendedPAR extendedPAR;
    } u;
} CustomPictureFormat_pixelAspectInformation;

typedef struct CustomPictureFormat_mPI {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define standardMPI_present 0x80
    ASN1uint16_t standardMPI;
#   define customPCF_present 0x40
    CustomPictureFormat_mPI_customPCF customPCF;
} CustomPictureFormat_mPI;

typedef struct RefPictureSelection_videoBackChannelSend {
    ASN1choice_t choice;
#   define RefPictureSelection_videoBackChannelSend_none_chosen 1
#   define ackMessageOnly_chosen 2
#   define nackMessageOnly_chosen 3
#   define ackOrNackMessageOnly_chosen 4
#   define ackAndNackMessage_chosen 5
} RefPictureSelection_videoBackChannelSend;

typedef struct RefPictureSelection_additionalPictureMemory {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sqcifAdditionalPictureMemory_present 0x80
    ASN1uint16_t sqcifAdditionalPictureMemory;
#   define qcifAdditionalPictureMemory_present 0x40
    ASN1uint16_t qcifAdditionalPictureMemory;
#   define cifAdditionalPictureMemory_present 0x20
    ASN1uint16_t cifAdditionalPictureMemory;
#   define cif4AdditionalPictureMemory_present 0x10
    ASN1uint16_t cif4AdditionalPictureMemory;
#   define cif16AdditionalPictureMemory_present 0x8
    ASN1uint16_t cif16AdditionalPictureMemory;
#   define bigCpfAdditionalPictureMemory_present 0x4
    ASN1uint16_t bigCpfAdditionalPictureMemory;
} RefPictureSelection_additionalPictureMemory;

typedef struct RTPH263VideoRedundancyFrameMapping_frameSequence {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping_frameSequence_Seq value[256];
} RTPH263VideoRedundancyFrameMapping_frameSequence;

typedef struct RTPH263VideoRedundancyEncoding_containedThreads {
    ASN1uint32_t count;
    RTPH263VideoRedundancyEncoding_containedThreads_Seq value[256];
} RTPH263VideoRedundancyEncoding_containedThreads;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping {
    ASN1choice_t choice;
    union {
#	define roundrobin_chosen 1
#	define custom_chosen 2
	PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom custom;
    } u;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping;

typedef struct RedundancyEncodingCapability_secondaryEncoding {
    PRedundancyEncodingCapability_secondaryEncoding next;
    CapabilityTableEntryNumber value;
} RedundancyEncodingCapability_secondaryEncoding_Element;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_mobileOperationTransmitCapability {
    ASN1bool_t modeChangeCapability;
    ASN1bool_t h223AnnexA;
    ASN1bool_t h223AnnexADoubleFlag;
    ASN1bool_t h223AnnexB;
    ASN1bool_t h223AnnexBwithHeader;
} H223Capability_mobileOperationTransmitCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define basic_chosen 1
#	define enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223AnnexCCapability {
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1bool_t alpduInterleaving;
    ASN1uint16_t maximumAL1MPDUSize;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
} H223AnnexCCapability;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct QOSMode {
    ASN1choice_t choice;
#   define guaranteedQOS_chosen 1
#   define controlledLoad_chosen 2
} QOSMode;

typedef struct ATMParameters {
    ASN1uint16_t maxNTUSize;
    ASN1bool_t atmUBR;
    ASN1bool_t atmrtVBR;
    ASN1bool_t atmnrtVBR;
    ASN1bool_t atmABR;
    ASN1bool_t atmCBR;
} ATMParameters;

typedef struct MediaTransportType {
    ASN1choice_t choice;
#   define ip_UDP_chosen 1
#   define ip_TCP_chosen 2
#   define atm_AAL5_UNIDIR_chosen 3
#   define atm_AAL5_BIDIR_chosen 4
} MediaTransportType;

typedef struct MediaChannelCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define mediaTransport_present 0x80
    MediaTransportType mediaTransport;
} MediaChannelCapability;

typedef struct RTPH263VideoRedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t numberOfThreads;
    ASN1uint16_t framesBetweenSyncPoints;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping frameToThreadMapping;
#   define containedThreads_present 0x80
    RTPH263VideoRedundancyEncoding_containedThreads containedThreads;
} RTPH263VideoRedundancyEncoding;

typedef struct RTPH263VideoRedundancyFrameMapping {
    ASN1uint16_t threadNumber;
    RTPH263VideoRedundancyFrameMapping_frameSequence frameSequence;
} RTPH263VideoRedundancyFrameMapping;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct EnhancementLayerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t baseBitRateConstrained;
#   define snrEnhancement_present 0x80
    PEnhancementLayerInfo_snrEnhancement snrEnhancement;
#   define spatialEnhancement_present 0x40
    PEnhancementLayerInfo_spatialEnhancement spatialEnhancement;
#   define bPictureEnhancement_present 0x20
    PEnhancementLayerInfo_bPictureEnhancement bPictureEnhancement;
} EnhancementLayerInfo;

typedef struct TransparencyParameters {
    ASN1uint16_t presentationOrder;
    ASN1int32_t offset_x;
    ASN1int32_t offset_y;
    ASN1uint16_t scale_x;
    ASN1uint16_t scale_y;
} TransparencyParameters;

typedef struct RefPictureSelection {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define additionalPictureMemory_present 0x80
    RefPictureSelection_additionalPictureMemory additionalPictureMemory;
    ASN1bool_t videoMux;
    RefPictureSelection_videoBackChannelSend videoBackChannelSend;
} RefPictureSelection;

typedef struct CustomPictureClockFrequency {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
#   define CustomPictureClockFrequency_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define CustomPictureClockFrequency_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define CustomPictureClockFrequency_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define CustomPictureClockFrequency_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define CustomPictureClockFrequency_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
} CustomPictureClockFrequency;

typedef struct CustomPictureFormat {
    ASN1uint16_t maxCustomPictureWidth;
    ASN1uint16_t maxCustomPictureHeight;
    ASN1uint16_t minCustomPictureWidth;
    ASN1uint16_t minCustomPictureHeight;
    CustomPictureFormat_mPI mPI;
    CustomPictureFormat_pixelAspectInformation pixelAspectInformation;
} CustomPictureFormat;

typedef struct H263ModeComboFlags {
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t referencePicSelect;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t reducedResolutionUpdate;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
} H263ModeComboFlags;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct G7231AnnexCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
#   define g723AnnexCAudioMode_present 0x80
    G7231AnnexCCapability_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct GSMAudioCapability {
    ASN1uint16_t audioUnitSize;
    ASN1bool_t comfortNoise;
    ASN1bool_t scrambled;
} GSMAudioCapability;

typedef struct V42bis {
    ASN1uint32_t numberOfCodewords;
    ASN1uint16_t maximumStringLength;
} V42bis;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define ConferenceCapability_nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
#   define videoIndicateMixingCapability_present 0x8000
    ASN1bool_t videoIndicateMixingCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct H223AL2MParameters {
    H223AL2MParameters_headerFEC headerFEC;
    ASN1bool_t alpduInterleaving;
} H223AL2MParameters;

typedef struct H223AnnexCArqParameters {
    H223AnnexCArqParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} H223AnnexCArqParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct EscrowData {
    ASN1objectidentifier_t escrowID;
    ASN1bitstring_t escrowValue;
} EscrowData;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
#   define CloseLogicalChannel_reason_present 0x80
    CloseLogicalChannel_reason reason;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define V76ModeParameters_suspendResumewAddress_chosen 1
#   define V76ModeParameters_suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct G7231AnnexCMode {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
    G7231AnnexCMode_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct Criteria {
    ASN1objectidentifier_t field;
    struct Criteria_value_value {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } value;
} Criteria;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct RequestAllTerminalIDsResponse {
    PRequestAllTerminalIDsResponse_terminalInformation terminalInformation;
} RequestAllTerminalIDsResponse;

typedef struct TerminalInformation {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} TerminalInformation;

typedef struct RemoteMCRequest {
    ASN1choice_t choice;
#   define masterActivate_chosen 1
#   define slaveActivate_chosen 2
#   define deActivate_chosen 3
} RemoteMCRequest;

typedef struct RemoteMCResponse {
    ASN1choice_t choice;
    union {
#	define accept_chosen 1
#	define reject_chosen 2
	RemoteMCResponse_reject reject;
    } u;
} RemoteMCResponse;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct SubstituteConferenceIDCommand {
    struct SubstituteConferenceIDCommand_conferenceIdentifier_conferenceIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } conferenceIdentifier;
} SubstituteConferenceIDCommand;

typedef struct KeyProtectionMethod {
    ASN1bool_t secureChannel;
    ASN1bool_t sharedSecret;
    ASN1bool_t certProtectedKey;
} KeyProtectionMethod;

typedef struct EncryptionUpdateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define keyProtectionMethod_present 0x80
    KeyProtectionMethod keyProtectionMethod;
} EncryptionUpdateRequest;

typedef struct H223MultiplexReconfiguration {
    ASN1choice_t choice;
    union {
#	define h223ModeChange_chosen 1
	H223MultiplexReconfiguration_h223ModeChange h223ModeChange;
#	define h223AnnexADoubleFlag_chosen 2
	H223MultiplexReconfiguration_h223AnnexADoubleFlag h223AnnexADoubleFlag;
    } u;
} H223MultiplexReconfiguration;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct TerminalYouAreSeeingInSubPictureNumber {
    TerminalNumber terminalNumber;
    ASN1uint16_t subPictureNumber;
} TerminalYouAreSeeingInSubPictureNumber;

typedef struct VideoIndicateCompose {
    ASN1uint16_t compositionNumber;
} VideoIndicateCompose;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
#	define withdrawChairToken_chosen 11
#	define floorRequested_chosen 12
	TerminalLabel floorRequested;
#	define terminalYouAreSeeingInSubPictureNumber_chosen 13
	TerminalYouAreSeeingInSubPictureNumber terminalYouAreSeeingInSubPictureNumber;
#	define videoIndicateCompose_chosen 14
	VideoIndicateCompose videoIndicateCompose;
    } u;
} ConferenceIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
#   define reverseParameters_present 0x80
    NewATMVCIndication_reverseParameters reverseParameters;
} NewATMVCIndication;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom {
    PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom next;
    RTPH263VideoRedundancyFrameMapping value;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_Element;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation {
    PRequestAllTerminalIDsResponse_terminalInformation next;
    TerminalInformation value;
} RequestAllTerminalIDsResponse_terminalInformation_Element;

typedef struct ConferenceResponse_terminalCertificateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceResponse_terminalCertificateResponse_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certificateResponse_present 0x40
    struct ConferenceResponse_terminalCertificateResponse_certificateResponse_certificateResponse {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } certificateResponse;
} ConferenceResponse_terminalCertificateResponse;

typedef struct ConferenceResponse_chairTokenOwnerResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_chairTokenOwnerResponse;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    H245Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct ConferenceRequest_requestTerminalCertificate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceRequest_requestTerminalCertificate_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certSelectionCriteria_present 0x40
    PCertSelectionCriteria certSelectionCriteria;
#   define sRandom_present 0x20
    ASN1uint32_t sRandom;
} ConferenceRequest_requestTerminalCertificate;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct EncryptionSync_escrowentry {
    PEncryptionSync_escrowentry next;
    EscrowData value;
} EncryptionSync_escrowentry_Element;

typedef struct H223AL3MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL3MParameters_arqType_noArq_chosen 1
#	define H223AL3MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL3MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL3MParameters_arqType;

typedef struct H223AL1MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL1MParameters_arqType_noArq_chosen 1
#	define H223AL1MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL1MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL1MParameters_arqType;

typedef struct H263VideoModeCombos_h263VideoCoupledModes {
    ASN1uint32_t count;
    H263ModeComboFlags value[16];
} H263VideoModeCombos_h263VideoCoupledModes;

typedef struct H263Options_customPictureFormat {
    PH263Options_customPictureFormat next;
    CustomPictureFormat value;
} H263Options_customPictureFormat_Element;

typedef struct H263Options_customPictureClockFrequency {
    PH263Options_customPictureClockFrequency next;
    CustomPictureClockFrequency value;
} H263Options_customPictureClockFrequency_Element;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct TransportCapability_mediaChannelCapabilities {
    ASN1uint32_t count;
    MediaChannelCapability value[256];
} TransportCapability_mediaChannelCapabilities;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H223Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
#   define maxMUXPDUSizeCapability_present 0x80
    ASN1bool_t maxMUXPDUSizeCapability;
#   define nsrpSupport_present 0x40
    ASN1bool_t nsrpSupport;
#   define mobileOperationTransmitCapability_present 0x20
    H223Capability_mobileOperationTransmitCapability mobileOperationTransmitCapability;
#   define h223AnnexCCapability_present 0x10
    H223AnnexCCapability h223AnnexCCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct RSVPParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define qosMode_present 0x80
    QOSMode qosMode;
#   define tokenRate_present 0x40
    ASN1uint32_t tokenRate;
#   define bucketSize_present 0x20
    ASN1uint32_t bucketSize;
#   define peakRate_present 0x10
    ASN1uint32_t peakRate;
#   define minPoliced_present 0x8
    ASN1uint32_t minPoliced;
#   define maxPktSize_present 0x4
    ASN1uint32_t maxPktSize;
} RSVPParameters;

typedef struct QOSCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define QOSCapability_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define rsvpParameters_present 0x40
    RSVPParameters rsvpParameters;
#   define atmParameters_present 0x20
    ATMParameters atmParameters;
} QOSCapability;

typedef struct TransportCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TransportCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
#   define qOSCapabilities_present 0x40
    PTransportCapability_qOSCapabilities qOSCapabilities;
#   define mediaChannelCapabilities_present 0x20
    TransportCapability_mediaChannelCapabilities mediaChannelCapabilities;
} TransportCapability;

typedef struct RedundancyEncodingMethod {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMethod_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define rtpAudioRedundancyEncoding_chosen 2
#	define rtpH263VideoRedundancyEncoding_chosen 3
	RTPH263VideoRedundancyEncoding rtpH263VideoRedundancyEncoding;
    } u;
} RedundancyEncodingMethod;

typedef struct H263Options {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t fullPictureFreeze;
    ASN1bool_t partialPictureFreezeAndRelease;
    ASN1bool_t resizingPartPicFreezeAndRelease;
    ASN1bool_t fullPictureSnapshot;
    ASN1bool_t partialPictureSnapshot;
    ASN1bool_t videoSegmentTagging;
    ASN1bool_t progressiveRefinement;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
    ASN1bool_t reducedResolutionUpdate;
#   define transparencyParameters_present 0x80
    TransparencyParameters transparencyParameters;
    ASN1bool_t separateVideoBackChannel;
#   define refPictureSelection_present 0x40
    RefPictureSelection refPictureSelection;
#   define customPictureClockFrequency_present 0x20
    PH263Options_customPictureClockFrequency customPictureClockFrequency;
#   define customPictureFormat_present 0x10
    PH263Options_customPictureFormat customPictureFormat;
#   define modeCombos_present 0x8
    PH263Options_modeCombos modeCombos;
} H263Options;

typedef struct H263VideoModeCombos {
    H263ModeComboFlags h263VideoUncoupledModes;
    H263VideoModeCombos_h263VideoCoupledModes h263VideoCoupledModes;
} H263VideoModeCombos;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioCapability_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCCapability_chosen 17
	G7231AnnexCCapability g7231AnnexCCapability;
#	define AudioCapability_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioCapability_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioCapability_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioCapability;

typedef struct CompressionType {
    ASN1choice_t choice;
    union {
#	define v42bis_chosen 1
	V42bis v42bis;
    } u;
} CompressionType;

typedef struct MediaEncryptionAlgorithm {
    ASN1choice_t choice;
    union {
#	define MediaEncryptionAlgorithm_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define algorithm_chosen 2
	ASN1objectidentifier_t algorithm;
    } u;
} MediaEncryptionAlgorithm;

typedef struct AuthenticationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthenticationCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} AuthenticationCapability;

typedef struct IntegrityCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define IntegrityCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} IntegrityCapability;

typedef struct H223AL1MParameters {
    H223AL1MParameters_transferMode transferMode;
    H223AL1MParameters_headerFEC headerFEC;
    H223AL1MParameters_crcLength crcLength;
    ASN1uint16_t rcpcCodeRate;
    H223AL1MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
    ASN1bool_t alsduSplitting;
} H223AL1MParameters;

typedef struct H223AL3MParameters {
    H223AL3MParameters_headerFormat headerFormat;
    H223AL3MParameters_crcLength crcLength;
    ASN1uint16_t rcpcCodeRate;
    H223AL3MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
} H223AL3MParameters;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct EncryptionSync {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EncryptionSync_nonStandard_present 0x80
    NonStandardParameter nonStandard;
    ASN1uint16_t synchFlag;
    struct EncryptionSync_h235Key_h235Key {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } h235Key;
#   define escrowentry_present 0x40
    PEncryptionSync_escrowentry escrowentry;
} EncryptionSync;

typedef struct RequestChannelClose {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define qosCapability_present 0x80
    QOSCapability qosCapability;
#   define RequestChannelClose_reason_present 0x40
    RequestChannelClose_reason reason;
} RequestChannelClose;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
#   define H263VideoMode_enhancementLayerInfo_present 0x40
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoMode_h263Options_present 0x20
    H263Options h263Options;
} H263VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioMode_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCMode_chosen 17
	G7231AnnexCMode g7231AnnexCMode;
#	define AudioMode_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioMode_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioMode_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
#	define enterExtensionAddress_chosen 9
#	define requestChairTokenOwner_chosen 10
#	define requestTerminalCertificate_chosen 11
	ConferenceRequest_requestTerminalCertificate requestTerminalCertificate;
#	define ConferenceRequest_broadcastMyLogicalChannel_chosen 12
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define ConferenceRequest_makeTerminalBroadcaster_chosen 13
	TerminalLabel makeTerminalBroadcaster;
#	define ConferenceRequest_sendThisSource_chosen 14
	TerminalLabel sendThisSource;
#	define requestAllTerminalIDs_chosen 15
#	define remoteMCRequest_chosen 16
	RemoteMCRequest remoteMCRequest;
    } u;
} ConferenceRequest;

typedef struct CertSelectionCriteria {
    PCertSelectionCriteria next;
    Criteria value;
} CertSelectionCriteria_Element;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
#	define extensionAddressResponse_chosen 9
	ConferenceResponse_extensionAddressResponse extensionAddressResponse;
#	define chairTokenOwnerResponse_chosen 10
	ConferenceResponse_chairTokenOwnerResponse chairTokenOwnerResponse;
#	define terminalCertificateResponse_chosen 11
	ConferenceResponse_terminalCertificateResponse terminalCertificateResponse;
#	define broadcastMyLogicalChannelResponse_chosen 12
	ConferenceResponse_broadcastMyLogicalChannelResponse broadcastMyLogicalChannelResponse;
#	define makeTerminalBroadcasterResponse_chosen 13
	ConferenceResponse_makeTerminalBroadcasterResponse makeTerminalBroadcasterResponse;
#	define sendThisSourceResponse_chosen 14
	ConferenceResponse_sendThisSourceResponse sendThisSourceResponse;
#	define requestAllTerminalIDsResponse_chosen 15
	RequestAllTerminalIDsResponse requestAllTerminalIDsResponse;
#	define remoteMCResponse_chosen 16
	RemoteMCResponse remoteMCResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
#	define isdnOptions_chosen 4
	EndSessionCommand_isdnOptions isdnOptions;
    } u;
} EndSessionCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define ConferenceCommand_broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define ConferenceCommand_makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define ConferenceCommand_sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
#	define substituteConferenceIDCommand_chosen 8
	SubstituteConferenceIDCommand substituteConferenceIDCommand;
    } u;
} ConferenceCommand;

typedef struct UserInputIndication_userInputSupportIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_userInputSupportIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define UserInputIndication_userInputSupportIndication_basicString_chosen 2
#	define UserInputIndication_userInputSupportIndication_iA5String_chosen 3
#	define UserInputIndication_userInputSupportIndication_generalString_chosen 4
    } u;
} UserInputIndication_userInputSupportIndication;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
#	define transportCapability_chosen 12
	TransportCapability transportCapability;
    } u;
} MiscellaneousIndication_type;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
#	define maxH223MUXPDUsize_chosen 12
	ASN1uint16_t maxH223MUXPDUsize;
#	define encryptionUpdate_chosen 13
	EncryptionSync encryptionUpdate;
#	define encryptionUpdateRequest_chosen 14
	EncryptionUpdateRequest encryptionUpdateRequest;
#	define switchReceiveMediaOff_chosen 15
#	define switchReceiveMediaOn_chosen 16
#	define progressiveRefinementStart_chosen 17
	MiscellaneousCommand_type_progressiveRefinementStart progressiveRefinementStart;
#	define progressiveRefinementAbortOne_chosen 18
#	define progressiveRefinementAbortContinuous_chosen 19
    } u;
} MiscellaneousCommand_type;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct RedundancyEncodingMode_secondaryEncoding {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMode_secondaryEncoding_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define RedundancyEncodingMode_secondaryEncoding_audioData_chosen 2
	AudioMode audioData;
    } u;
} RedundancyEncodingMode_secondaryEncoding;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
#	define H223ModeParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223ModeParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223ModeParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct RTPPayloadType_payloadDescriptor {
    ASN1choice_t choice;
    union {
#	define nonStandardIdentifier_chosen 1
	NonStandardParameter nonStandardIdentifier;
#	define rfc_number_chosen 2
	ASN1uint16_t rfc_number;
#	define oid_chosen 3
	ASN1objectidentifier_t oid;
    } u;
} RTPPayloadType_payloadDescriptor;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
#	define H223LogicalChannelParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223LogicalChannelParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223LogicalChannelParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct UserInputCapability_nonStandard {
    ASN1uint32_t count;
    NonStandardParameter value[16];
} UserInputCapability_nonStandard;

typedef struct DataProtocolCapability_v76wCompression {
    ASN1choice_t choice;
    union {
#	define transmitCompression_chosen 1
	CompressionType transmitCompression;
#	define receiveCompression_chosen 2
	CompressionType receiveCompression;
#	define transmitAndReceiveCompression_chosen 3
	CompressionType transmitAndReceiveCompression;
    } u;
} DataProtocolCapability_v76wCompression;

typedef struct H263Options_modeCombos {
    PH263Options_modeCombos next;
    H263VideoModeCombos value;
} H263Options_modeCombos_Element;

typedef struct TransportCapability_qOSCapabilities {
    PTransportCapability_qOSCapabilities next;
    QOSCapability value;
} TransportCapability_qOSCapabilities_Element;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct RedundancyEncodingCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
    CapabilityTableEntryNumber primaryEncoding;
#   define RedundancyEncodingCapability_secondaryEncoding_present 0x80
    PRedundancyEncodingCapability_secondaryEncoding secondaryEncoding;
} RedundancyEncodingCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H263VideoCapability_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define H263VideoCapability_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define H263VideoCapability_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define H263VideoCapability_slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define H263VideoCapability_slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define H263VideoCapability_slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define H263VideoCapability_slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define H263VideoCapability_slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
#   define H263VideoCapability_enhancementLayerInfo_present 0x200
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoCapability_h263Options_present 0x100
    H263Options h263Options;
} H263VideoCapability;

typedef struct EnhancementOptions {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define EnhancementOptions_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define EnhancementOptions_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define EnhancementOptions_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define EnhancementOptions_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define EnhancementOptions_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define EnhancementOptions_slowSqcifMPI_present 0x4
    ASN1uint16_t slowSqcifMPI;
#   define EnhancementOptions_slowQcifMPI_present 0x2
    ASN1uint16_t slowQcifMPI;
#   define EnhancementOptions_slowCifMPI_present 0x1
    ASN1uint16_t slowCifMPI;
#   define EnhancementOptions_slowCif4MPI_present 0x8000
    ASN1uint16_t slowCif4MPI;
#   define EnhancementOptions_slowCif16MPI_present 0x4000
    ASN1uint16_t slowCif16MPI;
    ASN1bool_t errorCompensation;
#   define EnhancementOptions_h263Options_present 0x2000
    H263Options h263Options;
} EnhancementOptions;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
#	define v76wCompression_chosen 12
	DataProtocolCapability_v76wCompression v76wCompression;
    } u;
} DataProtocolCapability;

typedef struct EncryptionAuthenticationAndIntegrity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define encryptionCapability_present 0x80
    PEncryptionCapability encryptionCapability;
#   define authenticationCapability_present 0x40
    AuthenticationCapability authenticationCapability;
#   define integrityCapability_present 0x20
    IntegrityCapability integrityCapability;
} EncryptionAuthenticationAndIntegrity;

typedef struct EncryptionCapability {
    PEncryptionCapability next;
    MediaEncryptionAlgorithm value;
} EncryptionCapability_Element;

typedef struct UserInputCapability {
    ASN1choice_t choice;
    union {
#	define UserInputCapability_nonStandard_chosen 1
	UserInputCapability_nonStandard nonStandard;
#	define UserInputCapability_basicString_chosen 2
#	define UserInputCapability_iA5String_chosen 3
#	define UserInputCapability_generalString_chosen 4
#	define dtmf_chosen 5
#	define hookflash_chosen 6
    } u;
} UserInputCapability;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct RTPPayloadType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RTPPayloadType_payloadDescriptor payloadDescriptor;
#   define payloadType_present 0x80
    ASN1uint16_t payloadType;
} RTPPayloadType;

typedef struct H245TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} H245TransportAddress;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
#   define flowControlToZero_present 0x8000
    ASN1bool_t flowControlToZero;
#   define H2250LogicalChannelAckParameters_portNumber_present 0x4000
    ASN1uint16_t portNumber;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct RedundancyEncodingMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncodingMode_secondaryEncoding_present 0x80
    RedundancyEncodingMode_secondaryEncoding secondaryEncoding;
} RedundancyEncodingMode;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct MCLocationIndication {
    H245TransportAddress signalAddress;
} MCLocationIndication;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
#	define userInputSupportIndication_chosen 3
	UserInputIndication_userInputSupportIndication userInputSupportIndication;
#	define signal_chosen 4
	UserInputIndication_signal signal;
#	define signalUpdate_chosen 5
	UserInputIndication_signalUpdate signalUpdate;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataMode_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataMode_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataMode_application;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
    union {
#	define h261aVideoPacketization_chosen 1
#	define rtpPayloadType_chosen 2
	RTPPayloadType rtpPayloadType;
    } u;
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	H245TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataApplicationCapability_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataApplicationCapability_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataApplicationCapability_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataApplicationCapability_application;

typedef struct EnhancementLayerInfo_spatialEnhancement {
    PEnhancementLayerInfo_spatialEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_spatialEnhancement_Element;

typedef struct EnhancementLayerInfo_snrEnhancement {
    PEnhancementLayerInfo_snrEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_snrEnhancement_Element;

typedef struct MediaPacketizationCapability_rtpPayloadType {
    ASN1uint32_t count;
    RTPPayloadType value[256];
} MediaPacketizationCapability_rtpPayloadType;

typedef struct H2250Capability_redundancyEncodingCapability {
    PH2250Capability_redundancyEncodingCapability next;
    RedundancyEncodingCapability value;
} H2250Capability_redundancyEncodingCapability_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
#	define h223MultiplexReconfiguration_chosen 10
	H223MultiplexReconfiguration h223MultiplexReconfiguration;
    } u;
} CommandMessage;

typedef struct H235SecurityCapability {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    CapabilityTableEntryNumber mediaCapability;
} H235SecurityCapability;

typedef struct MediaPacketizationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t h261aVideoPacketization;
#   define rtpPayloadType_present 0x80
    MediaPacketizationCapability_rtpPayloadType rtpPayloadType;
} MediaPacketizationCapability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct BEnhancementParameters {
    EnhancementOptions enhancementOptions;
    ASN1uint16_t numberOfBPictures;
} BEnhancementParameters;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
#   define t120SetupProcedure_present 0x8000
    NetworkAccessParameters_t120SetupProcedure t120SetupProcedure;
} NetworkAccessParameters;

typedef struct H2250ModeParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define redundancyEncodingMode_present 0x80
    RedundancyEncodingMode redundancyEncodingMode;
} H2250ModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct H235Mode_mediaMode {
    ASN1choice_t choice;
    union {
#	define H235Mode_mediaMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Mode_mediaMode_videoMode_chosen 2
	VideoMode videoMode;
#	define H235Mode_mediaMode_audioMode_chosen 3
	AudioMode audioMode;
#	define H235Mode_mediaMode_dataMode_chosen 4
	DataMode dataMode;
    } u;
} H235Mode_mediaMode;

typedef struct H235Media_mediaType {
    ASN1choice_t choice;
    union {
#	define H235Media_mediaType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Media_mediaType_videoData_chosen 2
	VideoCapability videoData;
#	define H235Media_mediaType_audioData_chosen 3
	AudioCapability audioData;
#	define H235Media_mediaType_data_chosen 4
	DataApplicationCapability data;
    } u;
} H235Media_mediaType;

typedef struct EnhancementLayerInfo_bPictureEnhancement {
    PEnhancementLayerInfo_bPictureEnhancement next;
    BEnhancementParameters value;
} EnhancementLayerInfo_bPictureEnhancement_Element;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
#	define h235SecurityCapability_chosen 14
	H235SecurityCapability h235SecurityCapability;
#	define maxPendingReplacementFor_chosen 15
	ASN1uint16_t maxPendingReplacementFor;
#	define receiveUserInputCapability_chosen 16
	UserInputCapability receiveUserInputCapability;
#	define transmitUserInputCapability_chosen 17
	UserInputCapability transmitUserInputCapability;
#	define receiveAndTransmitUserInputCapability_chosen 18
	UserInputCapability receiveAndTransmitUserInputCapability;
    } u;
} Capability;

typedef struct H2250Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
#   define H2250Capability_transportCapability_present 0x80
    TransportCapability transportCapability;
#   define redundancyEncodingCapability_present 0x40
    PH2250Capability_redundancyEncodingCapability redundancyEncodingCapability;
#   define logicalChannelSwitchingCapability_present 0x20
    ASN1bool_t logicalChannelSwitchingCapability;
#   define t120DynamicPortCapability_present 0x10
    ASN1bool_t t120DynamicPortCapability;
} H2250Capability;

typedef struct H235Media {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Media_mediaType mediaType;
} H235Media;

typedef struct H235Mode {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Mode_mediaMode mediaMode;
} H235Mode;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define ModeElement_type_videoMode_chosen 2
	VideoMode videoMode;
#	define ModeElement_type_audioMode_chosen 3
	AudioMode audioMode;
#	define ModeElement_type_dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
#	define h235Mode_chosen 6
	H235Mode h235Mode;
    } u;
} ModeElement_type;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
    } u;
} MultiplexCapability;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
#	define h235Control_chosen 7
	NonStandardParameter h235Control;
#	define h235Media_chosen 8
	H235Media h235Media;
    } u;
} DataType;

typedef struct RedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncoding_secondaryEncoding_present 0x80
    DataType secondaryEncoding;
} RedundancyEncoding;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h2250ModeParameters_present 0x4000
    H2250ModeParameters h2250ModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define CommunicationModeTableEntry_terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    H245TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    H245TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define CommunicationModeTableEntry_redundancyEncoding_present 0x8000
    RedundancyEncoding redundancyEncoding;
#   define sessionDependency_present 0x4000
    ASN1uint16_t sessionDependency;
#   define CommunicationModeTableEntry_destination_present 0x2000
    TerminalLabel destination;
} CommunicationModeTableEntry;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define H2250LogicalChannelParameters_destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
#   define H2250LogicalChannelParameters_transportCapability_present 0x800000
    TransportCapability transportCapability;
#   define H2250LogicalChannelParameters_redundancyEncoding_present 0x400000
    RedundancyEncoding redundancyEncoding;
#   define source_present 0x200000
    TerminalLabel source;
} H2250LogicalChannelParameters;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none_chosen 5
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor_present 0x8000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define reverseLogicalChannelDependency_present 0x8000
    LogicalChannelNumber reverseLogicalChannelDependency;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define forwardLogicalChannelDependency_present 0x8000
    LogicalChannelNumber forwardLogicalChannelDependency;
#   define OpenLogicalChannel_forwardLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define OpenLogicalChannel_encryptionSync_present 0x4000
    EncryptionSync encryptionSync;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
#   define OpenLogicalChannelAck_encryptionSync_present 0x2000
    EncryptionSync encryptionSync;
} OpenLogicalChannelAck;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
    } u;
} ResponseMessage;

typedef OpenLogicalChannel FastConnectOLC;
#define FastConnectOLC_PDU 0
#define SIZE_H245ASN_Module_PDU_0 sizeof(FastConnectOLC)

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define IndicationMessage_functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 1
#define SIZE_H245ASN_Module_PDU_1 sizeof(MultimediaSystemControlMessage)


extern ASN1module_t H245ASN_Module;
extern void ASN1CALL H245ASN_Module_Startup(void);
extern void ASN1CALL H245ASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
	extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
	extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val);
	extern void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
	extern void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val);
	extern void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val);
	extern void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
	extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
	extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
	extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val);
	extern void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
	extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
	extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
	extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val);
	extern void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val);
	extern void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val);
    extern int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val);
	extern void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val);
	extern void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
	extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
	extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h323audt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//        Name: H323audt.h
//
// Description: Definition of the CH323AudioCaptureTerminal class and 
//     CH323AudioRenderTerminal class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _H323AUDT_H_
#define _H323AUDT_H_

#include "h323term.h"

/////////////////////////////////////////////////////////////////////////////
// CH323AudioCaptureTerminal
/////////////////////////////////////////////////////////////////////////////
const DWORD AUDIO_CAPTURE_FILTER_NUMPINS = 1;

class CH323AudioCaptureTerminal : 
    public IDispatchImpl<ITBasicAudioTerminal, &IID_ITBasicAudioTerminal, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITStaticAudioTerminal, &IID_ITStaticAudioTerminal, &LIBID_TAPI3Lib>, 
    public CH323BaseTerminal
{

BEGIN_COM_MAP(CH323AudioCaptureTerminal)
    COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITStaticAudioTerminal)
    COM_INTERFACE_ENTRY_CHAIN(CH323BaseTerminal)
END_COM_MAP()

public:
    CH323AudioCaptureTerminal();

    virtual ~CH323AudioCaptureTerminal();

    static HRESULT CreateTerminal(
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHODIMP DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

// ITBasicAudioTerminal
    STDMETHOD(get_Balance)(OUT  long *pVal);
    STDMETHOD(put_Balance)(IN   long newVal);
    STDMETHOD(get_Volume) (OUT  long *pVal);
    STDMETHOD(put_Volume) (IN   long newVal);

// ITStaticAudioTerminal
    STDMETHOD(get_WaveId) (OUT  long * plWaveId);

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return AUDIO_CAPTURE_FILTER_NUMPINS;
    }
    
    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );

protected:
    UINT                    m_WaveID;
    GUID                    m_DSoundGuid;

    IAMAudioInputMixer *    m_pIAMAudioInputMixer;
};

/////////////////////////////////////////////////////////////////////////////
// CH323AudioRenderTerminal
/////////////////////////////////////////////////////////////////////////////

const DWORD AUDIO_RENDER_FILTER_NUMPINS = 1;

class CH323AudioRenderTerminal : 
    public IDispatchImpl<ITBasicAudioTerminal, &IID_ITBasicAudioTerminal, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITStaticAudioTerminal, &IID_ITStaticAudioTerminal, &LIBID_TAPI3Lib>, 
    public CH323BaseTerminal
{

BEGIN_COM_MAP(CH323AudioRenderTerminal)
    COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITStaticAudioTerminal)
    COM_INTERFACE_ENTRY_CHAIN(CH323BaseTerminal)
END_COM_MAP()

public:
    CH323AudioRenderTerminal();

    virtual ~CH323AudioRenderTerminal();

    static HRESULT CreateTerminal(
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHODIMP DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

// ITBasicAudioTerminal
    STDMETHOD(get_Balance)(OUT  long *pVal);
    STDMETHOD(put_Balance)(IN   long newVal);
    STDMETHOD(get_Volume) (OUT  long *pVal);
    STDMETHOD(put_Volume) (IN   long newVal);

// ITStaticAudioTerminal
    STDMETHOD(get_WaveId) (OUT  long * plWaveId);

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return AUDIO_RENDER_FILTER_NUMPINS;
    }

    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );
protected:
    UINT                    m_WaveID;
    GUID                    m_DSoundGuid;

    IBasicAudio *           m_pIBasicAudio;
};

#endif // _H323AUDT_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h323err.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    H323err.h

Abstract:

    Error definitions for H.32X MSP

Author:
    Michael VanBuskirk (mikev) 06/25/99
--*/

#ifndef _H323ERR_H_
#define _H323ERR_H_

#include <winerror.h>



#define H323MSP_FACILITY		        0x100		// facility code for audio/video communications
#define MAKE_H323MSP_ERROR(z,e)	        MAKE_HRESULT(1,H323MSP_FACILITY,(((z)&0xF000)|(e)))
#define MAKE_H323MSP_WARNING(z,w)	    MAKE_HRESULT(0,H323MSP_FACILITY,(((z)&0xF000)|(w)))

#define H323MSP_ZONE		            0x0000		
#define H323MSP_WINSOCK_ZONE		    0x1000		
#define H323MSP_TAPI_ZONE		        0x2000		// error caused by unexpected TAPI error 
#define H323H245_ZONE		            0x3000		
#define H323ASN1_ZONE		            0x4000	

#define H323MSP_WIN32_ZONE			    0xF000		// Win32 error code

#define MAKE_WIN32_ERROR(e)		        MAKE_H323MSP_ERROR (H323MSP_WIN32_ZONE, e)
#define MAKE_WINSOCK_ERROR(e)	        MAKE_H323MSP_ERROR (H323MSP_WINSOCK_ZONE, e)
#define MAKE_ASN1_ERROR(e)	            MAKE_H323MSP_ERROR (H323ASN1_ZONE, e)
#define MAKE_H245_ERROR(e)	            MAKE_H323MSP_ERROR (H323H245_ZONE, e)


// warnings
#define W_ENUMERATION_REQUIRED          MAKE_H323MSP_WARNING(H323MSP_ZONE, 0x0001)
#define W_NO_CAPABILITY_INTERSECTION    MAKE_H323MSP_WARNING(H323MSP_ZONE, 0x0002)
#define W_NO_FASTCONNECT_CAPABILITY     MAKE_H323MSP_WARNING(H323MSP_ZONE, 0x0003)
#define W_NOINTERFACE                   MAKE_H323MSP_WARNING(H323MSP_ZONE, 0x0004)

// general MSP errors
#define H323MSP_NOMEM 	                MAKE_H323MSP_ERROR(H323MSP_ZONE, 0x0001)
#define H323MSP_E_CAP_ENUMERATION_REQUIRED      MAKE_H323MSP_ERROR(H323MSP_ZONE, 0x0002)

// H.245 session errors
#define H245_ERROR_OK                   S_OK
#define H245_INVALID_STATE              MAKE_H323MSP_ERROR(H323H245_ZONE, 0x0001)   

#endif // _H323ERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h323strm.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    h323Strm.h

Abstract:

    Definitions for CH323MSPStream class.

Author:

    Mu Han (muhan) 1-November-1997

--*/
#ifndef __CONFSTRM_H
#define __CONFSTRM_H


/////////////////////////////////////////////////////////////////////////////
// CH323MSPStream
/////////////////////////////////////////////////////////////////////////////

// We support at most one codec filters per stream for now.
const DWORD MAX_CODECS = 1;

#ifdef DEBUG_REFCOUNT
extern LONG g_lStreamObjects;
#endif

class CH323MSPStream :
    public ISubstreamControl,
    public ITFormatControl,
    public ITStreamQualityControl,
    public IH245SubstreamControl,
    public IInnerStreamQualityControl,
    public CMSPObjectSafetyImpl,
    public CMSPStream
{

BEGIN_COM_MAP(CH323MSPStream)
    COM_INTERFACE_ENTRY(ISubstreamControl)
    COM_INTERFACE_ENTRY(ITFormatControl)
    COM_INTERFACE_ENTRY(ITStreamQualityControl)
    COM_INTERFACE_ENTRY(IH245SubstreamControl)
    COM_INTERFACE_ENTRY(IInnerStreamQualityControl)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
END_COM_MAP()

public:

    //
    // ITFormatControl methods
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    STDMETHOD (ReleaseFormat) (
        IN AM_MEDIA_TYPE *pMediaType
        );

    STDMETHOD (GetNumberOfCapabilities) (
        OUT DWORD *pdwCount
        );

    STDMETHOD (GetStreamCaps) (
        IN DWORD dwIndex, 
        OUT AM_MEDIA_TYPE **ppMediaType, 
        OUT TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT BOOL *pfEnabled
        );

    STDMETHOD (ReOrderCapabilities) (
        IN DWORD *pdwIndices, 
        IN BOOL *pfEnabled, 
        IN BOOL *pfPublicize, 
        IN DWORD dwNumIndices
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   StreamQualityProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   StreamQualityProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ISubstreamControl methods.
    //
    STDMETHOD (SC_SetFormat) ( 
        IN   AM_MEDIA_TYPE *pMediaType,
        IN   DWORD dwFormatID,
        IN   DWORD dwPayloadType  
        );
        
    STDMETHOD (SC_Start) (BOOL fRequestedByApplication);
    
    STDMETHOD (SC_Stop) (BOOL fRequestedByApplication);
    
    STDMETHOD (SC_Pause) (VOID);

    STDMETHOD (SC_SetBitrate) ( 
        IN   DWORD dwBitsPerSecond
        );
        
    STDMETHOD (SC_RemoteTemporalSpatialTradeoff) ( 
        IN   USHORT uTSRemoteValue
        );
    
    STDMETHOD (SC_CreateSubstream) ( 
        OUT  ISubstreamControl *pSubStream
        );

    STDMETHOD (SC_SetRemoteAddress) ( 
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pRemoteMediaAddr,
        IN   PSOCKADDR_IN pRemoteControlAddr
        );
        
    STDMETHOD (SC_SetSource) (  
        // indicates the low 8 bits of the local SSRC (if this is a send substream)  
        // or the low 8 bits of the senders SSRC (if this is a receive substream)
        IN   BYTE bSource
        );

    STDMETHOD (SC_SelectLocalAddress) ( 
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pLocalAddress,            // local IP address (same as H.245)
        OUT  PSOCKADDR_IN pLocalMediaAddress, // NULL if opening TX channel, else we want to know the local RTP receive address
        OUT  PSOCKADDR_IN pLocalControlAddress    // We want to know the local RTCP address
        );

    STDMETHOD (SC_SetLocalReceiveAddress) (             // only called when the receive address is non-negotiable (e.g. multicast case)
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pLocalMediaAddr,  // local IP address (same as H.245)
        IN   PSOCKADDR_IN pLocalControlAddress, 
        IN   PSOCKADDR_IN pRemoteControlAddress
        );
        
    STDMETHOD (SC_SendDTMF) ( 
        IN   LPWSTR pwstrDialChars
        );
        
    STDMETHOD (SC_SetDESKey52) ( 
        IN   BYTE *pKey
        );

    STDMETHOD (SC_SelectTerminal) ( 
        IN   ITTerminal *pTerminal
        );
        
    STDMETHOD (SC_UnselectTerminal) (  
        IN   ITTerminal *pTerminal
        );

    //
    // IH245SubstreamControl
    //
    STDMETHOD (H245SC_BeginControlSession) (
        IN   IH245ChannelControl *pIChannelControl
        );
    
    STDMETHOD (H245SC_EndControlSession) (VOID);   
    
    STDMETHOD (H245SC_GetNumberOfCapabilities) ( 
        OUT DWORD *pdwTemplateCount, 
        OUT DWORD *pdwFormatCount
        );

    STDMETHOD (H245SC_GetStreamCaps) ( 
        IN   DWORD dwIndex, 
        OUT  const H245MediaCapability** pph245Capability, 
        OUT  AM_MEDIA_TYPE **ppMediaType, 
        OUT  TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT  DWORD *pdwUniqueID,
        OUT  UINT *puResourceBoundArrayEntries,
        OUT  const FormatResourceBounds **ppResourceBoundArray    
        );

    STDMETHOD (H245SC_RefineStreamCap) ( 
        IN   DWORD dwUniqueID,
        IN   DWORD dwResourceBoundIndex,
        IN OUT H245MediaCapability* ph245Capability
        );
     
    STDMETHOD (H245SC_SetIDBase) ( 
        IN   UINT uNewBase
        );
    
    STDMETHOD (H245SC_FindIDByRange) ( 
        IN   AM_MEDIA_TYPE *pAMMediaType,
        OUT  DWORD *pdwUniqueID
        );     

    STDMETHOD (H245SC_FindIDByMode) ( 
        IN   H245_MODE_ELEMENT *pModeElement,
        OUT  DWORD *pdwUniqueID
        );

    STDMETHOD (H245SC_IntersectFormats) ( 
        IN   const H245MediaCapability *pLocalCapability, 
        IN   DWORD dwUniqueID,
        IN   const H245MediaCapability *pRemoteCapability, 
        OUT  const H245MediaCapability **pIntersectedCapability,
        OUT  DWORD *pdwPayloadType
        );

	STDMETHOD (H245SC_GetLocalFormat) (
        IN  DWORD dwUniqueID,
        IN  const H245MediaCapability *pIntersectedCapability, 
		OUT AM_MEDIA_TYPE **ppAMMediaType
		);
		
    STDMETHOD (H245SC_ReleaseNegotiatedCapability) ( 
        IN  DWORD dwUniqueID,
        IN  const H245MediaCapability *pIntersectedCapability 
        );

    //
    // IInnerStreamQualityControl
    //
    STDMETHOD (LinkInnerCallQC) (
        IN  IInnerCallQualityControl *pIInnerCallQC
        );

    STDMETHOD (UnlinkInnerCallQC) (
        IN  BOOL fByStream
        );

    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN  InnerStreamQualityProperty property,
        IN  LONG  lValue1,
        IN  TAPIControlFlags lFlags
        );

    STDMETHOD (Get) (
        IN  InnerStreamQualityProperty property,
        OUT LONG *plValue,
        OUT TAPIControlFlags *plFlags
        );

    STDMETHOD (TryLockStream)() { return m_lock.TryLock()?S_OK:S_FALSE; }

    STDMETHOD (UnlockStream)() { m_lock.Unlock(); return S_OK; }

    STDMETHOD (IsAccessingQC)() { return m_fAccessingQC?S_OK:S_FALSE; }


public:

    CH323MSPStream();

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    // CMSPStream methods.
    HRESULT ShutDown ();

     // ITStream
    STDMETHOD (get_Name) (
        OUT     BSTR *      ppName
        );

    STDMETHOD (StartStream) ();
    STDMETHOD (PauseStream) ();
    STDMETHOD (StopStream) ();

    STDMETHOD (SelectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal)(
        IN      ITTerminal *            pTerminal
        );

protected:
    virtual HRESULT CheckTerminalTypeAndDirection(
        IN      ITTerminal *    pTerminal
        );

    virtual HRESULT SendStreamEvent(
        IN      MSP_CALL_EVENT          Event,
        IN      MSP_CALL_EVENT_CAUSE    Cause,
        IN      HRESULT                 hrError,
        IN      ITTerminal *            pTerminal
        );

    virtual HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        ) = 0;

    virtual HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    virtual HRESULT CleanUpFilters();
    
    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    HRESULT EnableQOS(
        IN   AM_MEDIA_TYPE *pMediaType
        );

    virtual HRESULT ProcessQOSEvent(
        IN  long lEventCode
        );

    virtual HRESULT InitializeH245CapabilityTable();
    virtual HRESULT CleanupH245CapabilityTable();
    virtual HRESULT AddCodecToTable(IPin *pIPin);

protected:
    const WCHAR *   m_szName;

    // the filter before the terminal.
    IBaseFilter *   m_pEdgeFilter;

    // the RTP filter.
    IBaseFilter *   m_pRTPFilter;

    // used to remember the shared RTP session.
    HANDLE          m_hRTPSession;

    // additional state for the stream
    BOOL            m_fTimeout;

    // Callback interface to the H.245 module.
    IH245ChannelControl * m_pChannelControl;

    // Callback interface to the quality controller.
    CStreamQualityControlRelay * m_pStreamQCRelay;
    
    // capability related members.
    DWORD               m_dwCapabilityIDBase;
    DWORD               m_dwNumCodecs;
    DWORD               m_dwNumH245Caps;
    DWORD               m_dwTotalVariations;
    IStreamConfig *     m_StreamConfigInterfaces[MAX_CODECS];
    IH245Capability *   m_H245Interfaces[MAX_CODECS];
    H245MediaCapabilityTable m_H245CapabilityTables[MAX_CODECS];

    // flag will be set when stream is accessing quality control methods
    // that will in turn lock the stream list lock inside quality control.
    BOOL                m_fAccessingQC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h323term.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    H323term.h

Abstract:

    Definitions for the CH323BaseTerminal

Author:

    Zoltan Szilagyi (zoltans) September 6,1998

--*/

#ifndef _H323TERM_H_
#define _H323TERM_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// CH323BaseTerminal                                                           
//                                                                         
//                                                                         
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#if 0
// {e309dcd8-1ed6-11d3-a576-00c04f8ef6e3}
DEFINE_GUID(IID_IH323PrivateTerminal,
0xe309dcd8, 0x1ed6, 0x11d3, 0xa5, 0x76, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

DECLARE_INTERFACE_(IH323PrivateTerminal, IUnknown)
{
    STDMETHOD (GetFilter) (THIS_
        IBaseFilter *
        ) PURE;
};
#endif 

class CH323BaseTerminal : 
    virtual public CComObjectRootEx<CComMultiThreadModelNoCS>, // we have our own CS implementation
    public IDispatchImpl<ITTerminal, &IID_ITTerminal, &LIBID_TAPI3Lib>,
    public ITTerminalControl,
    public CMSPObjectSafetyImpl
{

BEGIN_COM_MAP(CH323BaseTerminal)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITTerminal)
    COM_INTERFACE_ENTRY(ITTerminalControl)
    COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

public:

    CH323BaseTerminal();
    HRESULT FinalConstruct();
    virtual ~CH323BaseTerminal();

public:
// ITTerminal -- COM interface for use by MSP or application
    STDMETHOD(get_TerminalClass)(OUT  BSTR *pVal);
    STDMETHOD(get_TerminalType) (OUT  TERMINAL_TYPE *pVal);
    STDMETHOD(get_State)        (OUT  TERMINAL_STATE *pVal);
    STDMETHOD(get_Name)         (OUT  BSTR *pVal);
    STDMETHOD(get_MediaType)    (OUT  long * plMediaType);
    STDMETHOD(get_Direction)    (OUT  TERMINAL_DIRECTION *pDirection);

// ITTerminalControl -- COM interface for use by MSP only

    STDMETHOD (get_AddressHandle) (
            OUT     MSP_HANDLE    * phtAddress
            );

    STDMETHOD (ConnectTerminal) (
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved,
            IN OUT  DWORD          * pdwNumPins,
            OUT     IPin          ** ppPins
            );

    STDMETHOD (CompleteConnectTerminal) (void);

    STDMETHOD (DisconnectTerminal) (
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

    STDMETHOD (RunRenderFilter) (void);

    STDMETHOD (StopRenderFilter) (void);

public:
    HRESULT Initialize(
            IN  WCHAR *             strName,
            IN  MSP_HANDLE          htAddress
            );

    HRESULT Initialize(
            IN  char *              strName,
            IN  MSP_HANDLE          htAddress
            );

protected:
    void Lock()     { EnterCriticalSection(&m_CritSec); }
    void Unlock()   { LeaveCriticalSection(&m_CritSec); }

    virtual DWORD GetNumExposedPins() const = 0;

    virtual HRESULT CreateFilter() = 0;

    virtual HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        ) = 0;

    virtual HRESULT AddFilterToGraph(
        IN  IGraphBuilder *pGraph
        );

    virtual HRESULT RemoveFilterFromGraph(
        IN  IGraphBuilder *pGraph
        );

protected:
    // The lock that protects the data members.
    CRITICAL_SECTION    m_CritSec;
    BOOL                m_fCritSecValid;

    // these five numbers need to be set by the derived class.
    GUID                m_TerminalClassID;
    TERMINAL_DIRECTION  m_TerminalDirection;
    TERMINAL_TYPE       m_TerminalType;
    TERMINAL_STATE      m_TerminalState;
    DWORD               m_dwMediaType;

    WCHAR               m_szName[MAX_PATH + 1];
    MSP_HANDLE          m_htAddress;

    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;

    // stores the filter graph builder (derives from IFilterGraph)
    IGraphBuilder *     m_pGraph;
    IBaseFilter *       m_pFilter;
};


#endif // _H323TERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h323vid.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confvid.h

Abstract:

    Definitions for video streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFVID_H_
#define __CONFVID_H_

const DWORD LAYERID = 0;

const int IFRAMEINTERVAL = 15;  // in seconds.
const int MINIFRAMEINTERVAL = 1; // in seconds

typedef enum _PERIODICIFRAMEMODE
{
    PIF_ON,
    PIF_HOLD,
    PIF_OFF
} PERIODICIFRAMEMODE;

// assert IFrame related variable being in valid state
#define AssertPeriodicIFrameMode _ASSERT (\
    /* enabled and running */ \
    (PIF_ON == m_PeriodicIFrameMode && \
     NULL != m_hTimerQueue && \
     NULL != m_hIFrameTimer && \
     MINIFRAMEINTERVAL <= m_dwIFrameInterval && \
     (STRM_RUNNING & m_dwState)) || \
    /* enabled but not running */ \
    (PIF_HOLD == m_PeriodicIFrameMode && \
     NULL != m_hTimerQueue && \
     NULL == m_hIFrameTimer && \
     MINIFRAMEINTERVAL <= m_dwIFrameInterval && \
     (STRM_RUNNING & m_dwState)) || \
    /* diabled */ \
    (PIF_OFF == m_PeriodicIFrameMode && \
     NULL == m_hTimerQueue && \
     NULL == m_hIFrameTimer))


class CStreamVideoRecv : 
    public CH323MSPStream,
    public IKeyFrameControl
{
BEGIN_COM_MAP(CStreamVideoRecv)
    COM_INTERFACE_ENTRY(IKeyFrameControl)
    COM_INTERFACE_ENTRY_CHAIN(CH323MSPStream)
END_COM_MAP()

public:
    CStreamVideoRecv();
    ~CStreamVideoRecv();

    STDMETHOD (SC_Start) (BOOL fRequestedByApplication);
    STDMETHOD (SC_Pause) ();
    STDMETHOD (SC_Stop) (BOOL fRequestedByApplication);

    HRESULT ShutDown();

    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    //
    // IKeyFrameControl methods
    //
    STDMETHOD (UpdatePicture)();

    STDMETHOD (PeriodicUpdatePicture) (
        IN BOOL fEnable, 
        IN DWORD dwInterval
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

protected:
    HRESULT SetUpInternalFilters(
        IN IPin * pVideoInputPin,
        IN BOOL fDirectRTP
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT InitializeH245CapabilityTable();

    HRESULT ReCreateIFrameTimer(
        IN PERIODICIFRAMEMODE mode,
        IN DWORD dwInterval
        );

    static VOID CALLBACK TimerCallback(
        IN PVOID lpContext,
        IN BOOLEAN TimerOrWaitFired
        );

    static DWORD CALLBACK IFrameCallback(
        IN PVOID lpContext
        );

protected:
    IBaseFilter *       m_pDecoderFilter;
    IBitrateControl *   m_pRenderBitrateControl;
    IFrameRateControl * m_pRenderFrameRateControl;

    // members for IKeyFrameControl interface.
    PERIODICIFRAMEMODE  m_PeriodicIFrameMode;
    DWORD               m_dwIFrameInterval;
    DWORD               m_dwLastIFrameRequestedTime;
    DWORD               m_dwIFramePending;

    HANDLE              m_hTimerQueue;
    HANDLE              m_hIFrameTimer;
};


class ATL_NO_VTABLE CSubStreamVideoPreview;

class CStreamVideoSend : 
    public CH323MSPStream,
    public IVidEncChannelControl,
    public IDispatchImpl<ITSubStreamControl, &IID_ITSubStreamControl, &LIBID_TAPI3Lib>
{

BEGIN_COM_MAP(CStreamVideoSend)
    COM_INTERFACE_ENTRY(ITSubStreamControl)
    COM_INTERFACE_ENTRY(IVidEncChannelControl)
    COM_INTERFACE_ENTRY_CHAIN(CH323MSPStream)
END_COM_MAP()

public:
    CStreamVideoSend();
    ~CStreamVideoSend();

    HRESULT ShutDown ();

    STDMETHOD (SC_Start) (BOOL fRequestedByApplication);

    //
    // ITSubStreamControl methods
    //
    STDMETHOD (CreateSubStream) (
        IN OUT  ITSubStream **         ppSubStream
        );

    STDMETHOD (RemoveSubStream) (
        IN      ITSubStream *          pSubStream
        );

    STDMETHOD (EnumerateSubStreams) (
        OUT     IEnumSubStream **      ppEnumSubStream
        );

    STDMETHOD (get_SubStreams) (
        OUT     VARIANT *              pSubStreams
        );
    
    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   InnerStreamQualityProperty property,
        IN   LONG lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IVidEncChannelControl methods
    //
	STDMETHOD (VideoFastUpdatePicture)(VOID);

	STDMETHOD (VideoFastUpdateGOB)(
		IN  DWORD dwFirstGOB, 
		IN  DWORD dwNumberOfGOBs
		);

	STDMETHOD (VideoFastUpdateMB)(
		IN  DWORD dwFirstGOB, 
		IN  DWORD dwFirstMB, 
		IN  DWORD dwNumberOfMBs
		);

	STDMETHOD (VideoSendSyncEveryGOB)(
		IN  BOOL fEnable
		);

	STDMETHOD (VideoNotDecodedMBs)(
		IN  DWORD dwFirstMB, 
		IN  DWORD dwNumberOfMBs, 
		IN  DWORD dwTemporalReference
		);

	STDMETHOD (VideoEncTemporalSpatialTradeoff)(
		IN  USHORT uTSValue
		);
public:
    HRESULT GetPreviewTerminal(
        OUT ITTerminal ** ppTerminal
        );

    HRESULT GetPreviewPin(
        OUT IPin ** ppPin
        );

protected:
    HRESULT CheckTerminalTypeAndDirection(
        IN  ITTerminal *            pTerminal
        );

    HRESULT GetVideoCapturePins(
        IN  ITTerminalControl*  pTerminal,
        OUT BOOL *pfDirectRTP
        );

    HRESULT ConnectCaptureTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConnectPreviewTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pCapturePin,
        IN   IPin          *pRTPPin,
        IN   BOOL           fDirectRTP
        );

    HRESULT ConnectRTPFilter(
        IN  IGraphBuilder *pIGraphBuilder,
        IN  IPin          *pCapturePin,
        IN  IPin          *pRTPPin,
        IN  IBaseFilter   *pRTPFilter
        );

    HRESULT ConnectPreview(
        IN    IPin          *pPreviewInputPin
        );

    HRESULT FindPreviewInputPin(
        IN  ITTerminalControl*  pTerminal,
        OUT IPin **             ppIpin
        );

    HRESULT GetPreviewSubStream(
        OUT ITSubStream ** ppITSubStream
        );

    void CleanupCachedInterface();

protected:

    ITSubStream *       m_pPreviewSubStream;
                        
    ITTerminal *        m_pCaptureTerminal;
    ITTerminal *        m_pPreviewTerminal;
    BOOL                m_fPreviewConnected;

    IBaseFilter *       m_pCaptureFilter;

    IPin *              m_pCapturePin;
    IFrameRateControl * m_pCaptureFrameRateControl;
    IBitrateControl *   m_pCaptureBitrateControl;

    IPin *              m_pPreviewPin;
    IFrameRateControl * m_pPreviewFrameRateControl;

    IPin *              m_pRTPPin;

    // this filter is used to answer the H245 questions when the terminal
    // can't answer them. This is a hack to support legacy terminals. The
    // app needs to select the right format to make it work.
    IBaseFilter *       m_pEncoder;
};

class ATL_NO_VTABLE CSubStreamVideoPreview : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public ITFormatControl,
    public IDispatchImpl<ITSubStream, &IID_ITSubStream, &LIBID_TAPI3Lib>
{
public:

BEGIN_COM_MAP(CSubStreamVideoPreview)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITSubStream)
    COM_INTERFACE_ENTRY(ITFormatControl)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

    CSubStreamVideoPreview(); 

// methods of the CComObject
    void FinalRelease();

// ITSubStream methods, called by the app.
    STDMETHOD (SelectTerminal) (
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal) (
        IN     ITTerminal *             pTerminal
        );

    STDMETHOD (EnumerateTerminals) (
        OUT     IEnumTerminal **        ppEnumTerminal
        );

    STDMETHOD (get_Terminals) (
        OUT     VARIANT *               pTerminals
        );

    STDMETHOD (get_Stream) (
        OUT     ITStream **             ppITStream
        );

    STDMETHOD (StartSubStream) ();

    STDMETHOD (PauseSubStream) ();

    STDMETHOD (StopSubStream) ();

    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    STDMETHOD (ReleaseFormat) (
        IN AM_MEDIA_TYPE *pMediaType
        );

    STDMETHOD (GetNumberOfCapabilities) (
        OUT DWORD *pdwCount
        );

    STDMETHOD (GetStreamCaps) (
        IN DWORD dwIndex, 
        OUT AM_MEDIA_TYPE **ppMediaType, 
        OUT TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT BOOL *pfEnabled
        );

    STDMETHOD (ReOrderCapabilities) (
        IN DWORD *pdwIndices, 
        IN BOOL *pfEnabled, 
        IN BOOL *pfPublicize, 
        IN DWORD dwNumIndices
        );

// methods called by the stream object.
    virtual HRESULT Init(
        IN  CStreamVideoSend *  pStream
        );

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *                  m_pFTM;

    CStreamVideoSend *          m_pStream;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h323vidt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//        Name: H323vidt.h
//
// Description: Definition of the CH323VideoCaptureTerminal class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _H323VIDT_H_
#define _H323VIDT_H_

#include "h323term.h"

/////////////////////////////////////////////////////////////////////////////
// CH323VideoCaptureTerminal
/////////////////////////////////////////////////////////////////////////////
const DWORD VIDEO_CAPTURE_FILTER_NUMPINS = 3;

interface DECLSPEC_UUID("b44aca09-e746-4d58-ad97-8890ba2286e5") DECLSPEC_NOVTABLE
IH323VideoDummy : public IUnknown
{
};

#define IID_IH323VideoDummy __uuidof(IH323VideoDummy)

    // COM_INTERFACE_ENTRY_CHAIN is not allowed to the 1st one is a MAP
    // entry IConfVideoDummy is to make BEGIN_COM_MAP happy

class CH323VideoCaptureTerminal : 
    public IH323VideoDummy,
    public CH323BaseTerminal
{
BEGIN_COM_MAP(CH323VideoCaptureTerminal)
    COM_INTERFACE_ENTRY(IH323VideoDummy)
    COM_INTERFACE_ENTRY_CHAIN(CH323BaseTerminal)
END_COM_MAP()

public:
    CH323VideoCaptureTerminal();

    virtual ~CH323VideoCaptureTerminal();

    static HRESULT CreateTerminal(
        IN  char *          strDeviceName,
        IN  UINT            VideoCaptureID,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  char *          strName,
        IN  UINT            VideoCaptureID,
        IN  MSP_HANDLE      htAddress
        );

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return VIDEO_CAPTURE_FILTER_NUMPINS;
    }
    
    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );

protected:
    UINT    m_VideoCaptureID;
};


#endif // _H323VIDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h4503pp.h ===
#ifndef _H4503PP_Module_H_
#define _H4503PP_Module_H_

#include "msper.h"
#include "h225asn.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct ExtensionSeq * PExtensionSeq;

typedef struct CpickupNotifyArg_extensionArg * PCpickupNotifyArg_extensionArg;

typedef struct CpNotifyArg_extensionArg * PCpNotifyArg_extensionArg;

typedef struct PickExeRes_extensionRes * PPickExeRes_extensionRes;

typedef struct PickExeArg_extensionArg * PPickExeArg_extensionArg;

typedef struct PickupRes_extensionRes * PPickupRes_extensionRes;

typedef struct PickupArg_extensionArg * PPickupArg_extensionArg;

typedef struct PickrequRes_extensionRes * PPickrequRes_extensionRes;

typedef struct PickrequArg_extensionArg * PPickrequArg_extensionArg;

typedef struct GroupIndicationOffRes_extensionRes * PGroupIndicationOffRes_extensionRes;

typedef struct GroupIndicationOffArg_extensionArg * PGroupIndicationOffArg_extensionArg;

typedef struct GroupIndicationOnRes_extensionRes * PGroupIndicationOnRes_extensionRes;

typedef struct GroupIndicationOnArg_extensionArg * PGroupIndicationOnArg_extensionArg;

typedef struct CpSetupRes_extensionRes * PCpSetupRes_extensionRes;

typedef struct CpSetupArg_extensionArg * PCpSetupArg_extensionArg;

typedef struct CpRequestRes_extensionRes * PCpRequestRes_extensionRes;

typedef struct CpRequestArg_extensionArg * PCpRequestArg_extensionArg;

typedef struct ServiceApdus_rosApdus * PServiceApdus_rosApdus;

typedef struct EndpointAddress_destinationAddress * PEndpointAddress_destinationAddress;
/*
typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;
*/
typedef ASN1int32_t GeneralProblem;
#define GeneralProblem_unrecognizedComponent 0
#define GeneralProblem_mistypedComponent 1
#define GeneralProblem_badlyStructuredComponent 2

typedef ASN1int32_t InvokeProblem;
#define InvokeProblem_duplicateInvocation 0
#define InvokeProblem_unrecognizedOperation 1
#define InvokeProblem_mistypedArgument 2
#define InvokeProblem_resourceLimitation 3
#define InvokeProblem_releaseInProgress 4
#define InvokeProblem_unrecognizedLinkedId 5
#define InvokeProblem_linkedResponseUnexpected 6
#define InvokeProblem_unexpectedLinkedOperation 7

typedef ASN1int32_t ReturnResultProblem;
#define ReturnResultProblem_unrecognizedInvocation 0
#define ReturnResultProblem_resultResponseUnexpected 1
#define ReturnResultProblem_mistypedResult 2

typedef ASN1int32_t ReturnErrorProblem;
#define ReturnErrorProblem_unrecognizedInvocation 0
#define ReturnErrorProblem_errorResponseUnexpected 1
#define ReturnErrorProblem_unrecognizedError 2
#define ReturnErrorProblem_unexpectedError 3
#define ReturnErrorProblem_mistypedParameter 4

typedef ASN1int32_t RejectProblem;
#define RejectProblem_general_unrecognizedPDU 0
#define RejectProblem_general_mistypedPDU 1
#define RejectProblem_general_badlyStructuredPDU 2
#define RejectProblem_invoke_duplicateInvocation 10
#define RejectProblem_invoke_unrecognizedOperation 11
#define RejectProblem_invoke_mistypedArgument 12
#define RejectProblem_invoke_resourceLimitation 13
#define RejectProblem_invoke_releaseInProgress 14
#define RejectProblem_invoke_unrecognizedLinkedId 15
#define RejectProblem_invoke_linkedResponseUnexpected 16
#define RejectProblem_invoke_unexpectedLinkedOperation 17
#define RejectProblem_returnResult_unrecognizedInvocation 20
#define RejectProblem_returnResult_resultResponseUnexpected 21
#define RejectProblem_returnResult_mistypedResult 22
#define RejectProblem_returnError_unrecognizedInvocation 30
#define RejectProblem_returnError_errorResponseUnexpected 31
#define RejectProblem_returnError_unrecognizedError 32
#define RejectProblem_returnError_unexpectedError 33
#define RejectProblem_returnError_mistypedParameter 34

typedef ASN1int32_t InvokeId;

typedef ASN1bool_t PresentationAllowedIndicator;

typedef enum DiversionReason {
    unknown = 0,
    DiversionReason_cfu = 1,
    DiversionReason_cfb = 2,
    DiversionReason_cfnr = 3,
} DiversionReason;

typedef enum Procedure {
    Procedure_cfu = 0,
    Procedure_cfb = 1,
    Procedure_cfnr = 2,
} Procedure;

typedef enum SubscriptionOption {
    noNotification = 0,
    notificationWithoutDivertedToNr = 1,
    notificationWithDivertedToNr = 2,
} SubscriptionOption;

typedef enum BasicService {
    allServices = 0,
    speech = 1,
    unrestrictedDigitalInformation = 2,
    audio31KHz = 3,
    telephony = 32,
    teletex = 33,
    telefaxGroup4Class1 = 34,
    videotexSyntaxBased = 35,
    videotelephony = 36,
} BasicService;

typedef enum EndDesignation {
    primaryEnd = 0,
    secondaryEnd = 1,
} EndDesignation;

typedef enum CallStatus {
    answered = 0,
    alerting = 1,
} CallStatus;

typedef ASN1char_t CallIdentity[5];

typedef ASN1uint16_t ParkedToPosition;

typedef enum ParkCondition {
    unspecified = 0,
    parkedToUserIdle = 1,
    parkedToUserBusy = 2,
    parkedToGroup = 3,
} ParkCondition;

typedef enum H4505CallType {
    parkedCall = 0,
    alertingCall = 1,
} H4505CallType;

typedef struct NSAPSubaddress {
    ASN1uint32_t length;
    ASN1octet_t value[20];
} NSAPSubaddress;

typedef struct SubaddressInformation {
    ASN1uint32_t length;
    ASN1octet_t value[20];
} SubaddressInformation;

typedef ASN1octetstring_t H225InformationElement;

typedef ASN1uint32_t Priority;

typedef ASN1char_t NumberDigits[129];
/*
typedef struct GloballyUniqueID {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} GloballyUniqueID;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;
*/
typedef struct Reject_problem {
    ASN1choice_t choice;
    union {
#	define general_chosen 1
	GeneralProblem general;
#	define Reject_problem_invoke_chosen 2
	InvokeProblem invoke;
#	define Reject_problem_returnResult_chosen 3
	ReturnResultProblem returnResult;
#	define Reject_problem_returnError_chosen 4
	ReturnErrorProblem returnError;
    } u;
} Reject_problem;

typedef struct EntityType {
    ASN1choice_t choice;
#   define endpoint_chosen 1
#   define anyEntity_chosen 2
} EntityType;

typedef struct InterpretationApdu {
    ASN1choice_t choice;
#   define discardAnyUnrecognizedInvokePdu_chosen 1
#   define clearCallIfAnyInvokePduNotRecognized_chosen 2
#   define rejectAnyUnrecognizedInvokePdu_chosen 3
} InterpretationApdu;

typedef struct ServiceApdus {
    ASN1choice_t choice;
    union {
#	define rosApdus_chosen 1
	PServiceApdus_rosApdus rosApdus;
    } u;
} ServiceApdus;

typedef struct Reject {
    InvokeId invokeId;
    Reject_problem problem;
} Reject;

typedef struct EXTENSION {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define argumentType_present 0x80
    ASN1uint16_t argumentType;
    ASN1objectidentifier_t extensionID;
} EXTENSION;

typedef struct GroupIndicationOnRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GroupIndicationOnRes_extensionRes_present 0x80
    PGroupIndicationOnRes_extensionRes extensionRes;
} GroupIndicationOnRes;
#define GroupIndicationOnRes_PDU 0
#define SIZE_H4503PP_Module_PDU_0 sizeof(GroupIndicationOnRes)

typedef struct GroupIndicationOffRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GroupIndicationOffRes_extensionRes_present 0x80
    PGroupIndicationOffRes_extensionRes extensionRes;
} GroupIndicationOffRes;
#define GroupIndicationOffRes_PDU 1
#define SIZE_H4503PP_Module_PDU_1 sizeof(GroupIndicationOffRes)

typedef struct PickupRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define PickupRes_extensionRes_present 0x80
    PPickupRes_extensionRes extensionRes;
} PickupRes;
#define PickupRes_PDU 2
#define SIZE_H4503PP_Module_PDU_2 sizeof(PickupRes)

typedef struct PickExeRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define PickExeRes_extensionRes_present 0x80
    PPickExeRes_extensionRes extensionRes;
} PickExeRes;
#define PickExeRes_PDU 3
#define SIZE_H4503PP_Module_PDU_3 sizeof(PickExeRes)

typedef struct UserSpecifiedSubaddress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubaddressInformation subaddressInformation;
#   define oddCountIndicator_present 0x80
    ASN1bool_t oddCountIndicator;
} UserSpecifiedSubaddress;

typedef struct CODE {
    ASN1choice_t choice;
    union {
#	define local_chosen 1
	ASN1int32_t local;
#	define global_chosen 2
	ASN1objectidentifier_t global;
    } u;
} CODE;
/*
typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct H225NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} H225NonStandardIdentifier;

typedef struct PublicTypeOfNumber {
    ASN1choice_t choice;
#   define PublicTypeOfNumber_unknown_chosen 1
#   define internationalNumber_chosen 2
#   define nationalNumber_chosen 3
#   define networkSpecificNumber_chosen 4
#   define subscriberNumber_chosen 5
#   define PublicTypeOfNumber_abbreviatedNumber_chosen 6
} PublicTypeOfNumber;

typedef struct PrivateTypeOfNumber {
    ASN1choice_t choice;
#   define PrivateTypeOfNumber_unknown_chosen 1
#   define level2RegionalNumber_chosen 2
#   define level1RegionalNumber_chosen 3
#   define pISNSpecificNumber_chosen 4
#   define localNumber_chosen 5
#   define PrivateTypeOfNumber_abbreviatedNumber_chosen 6
} PrivateTypeOfNumber;

typedef struct CallIdentifier {
    GloballyUniqueID guid;
} CallIdentifier;
*/
typedef struct ReturnResult_result {
    CODE opcode;
    ASN1octetstring_t result;
} ReturnResult_result;

typedef struct Invoke {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    InvokeId invokeId;
#   define linkedId_present 0x80
    InvokeId linkedId;
    CODE opcode;
#   define argument_present 0x40
    ASN1octetstring_t argument;
} Invoke;

typedef struct ReturnResult {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    InvokeId invokeId;
#   define result_present 0x80
    ReturnResult_result result;
} ReturnResult;

typedef struct ReturnError {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    InvokeId invokeId;
    CODE errcode;
#   define parameter_present 0x80
    ASN1octetstring_t parameter;
} ReturnError;

typedef struct ExtensionSeq {
    PExtensionSeq next;
    EXTENSION value;
} ExtensionSeq_Element;

typedef struct PickrequRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
#   define PickrequRes_extensionRes_present 0x80
    PPickrequRes_extensionRes extensionRes;
} PickrequRes;
#define PickrequRes_PDU 4
#define SIZE_H4503PP_Module_PDU_4 sizeof(PickrequRes)

typedef struct PartySubaddress {
    ASN1choice_t choice;
    union {
#	define userSpecifiedSubaddress_chosen 1
	UserSpecifiedSubaddress userSpecifiedSubaddress;
#	define nsapSubaddress_chosen 2
	NSAPSubaddress nsapSubaddress;
    } u;
} PartySubaddress;
/*
typedef struct H225NonStandardParameter {
    H225NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} H225NonStandardParameter;

typedef struct PublicPartyNumber {
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
} PublicPartyNumber;

typedef struct PrivatePartyNumber {
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
} PrivatePartyNumber;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define nonStandardAddress_chosen 7
	H225NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;
*/
typedef struct CTActiveArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTActiveArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTActiveArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTActiveArg_argumentExtension;

typedef struct CTCompleteArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTCompleteArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTCompleteArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTCompleteArg_argumentExtension;

typedef struct SubaddressTransferArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define SubaddressTransferArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define SubaddressTransferArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} SubaddressTransferArg_argumentExtension;

typedef struct CTUpdateArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTUpdateArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTUpdateArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTUpdateArg_argumentExtension;

typedef struct CTIdentifyRes_resultExtension {
    ASN1choice_t choice;
    union {
#	define CTIdentifyRes_resultExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTIdentifyRes_resultExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTIdentifyRes_resultExtension;

typedef struct CTSetupArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTSetupArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTSetupArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTSetupArg_argumentExtension;

typedef struct CTInitiateArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTInitiateArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTInitiateArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTInitiateArg_argumentExtension;

typedef struct IntResult_extension {
    ASN1choice_t choice;
    union {
#	define IntResult_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define IntResult_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} IntResult_extension;

typedef struct DivertingLegInformation4Argument_extension {
    ASN1choice_t choice;
    union {
#	define DivertingLegInformation4Argument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DivertingLegInformation4Argument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DivertingLegInformation4Argument_extension;

typedef struct DivertingLegInformation3Argument_extension {
    ASN1choice_t choice;
    union {
#	define DivertingLegInformation3Argument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DivertingLegInformation3Argument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DivertingLegInformation3Argument_extension;

typedef struct DivertingLegInformation2Argument_extension {
    ASN1choice_t choice;
    union {
#	define DivertingLegInformation2Argument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DivertingLegInformation2Argument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DivertingLegInformation2Argument_extension;

typedef struct DivertingLegInformation1Argument_extension {
    ASN1choice_t choice;
    union {
#	define DivertingLegInformation1Argument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DivertingLegInformation1Argument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DivertingLegInformation1Argument_extension;

typedef struct CallReroutingArgument_extension {
    ASN1choice_t choice;
    union {
#	define CallReroutingArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CallReroutingArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CallReroutingArgument_extension;

typedef struct CheckRestrictionArgument_extension {
    ASN1choice_t choice;
    union {
#	define CheckRestrictionArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CheckRestrictionArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CheckRestrictionArgument_extension;

typedef struct InterrogateDiversionQArgument_extension {
    ASN1choice_t choice;
    union {
#	define InterrogateDiversionQArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define InterrogateDiversionQArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} InterrogateDiversionQArgument_extension;

typedef struct DeactivateDiversionQArgument_extension {
    ASN1choice_t choice;
    union {
#	define DeactivateDiversionQArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DeactivateDiversionQArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DeactivateDiversionQArgument_extension;

typedef struct ActivateDiversionQArgument_extension {
    ASN1choice_t choice;
    union {
#	define ActivateDiversionQArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define ActivateDiversionQArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} ActivateDiversionQArgument_extension;

typedef struct H4503ROS {
    ASN1choice_t choice;
    union {
#	define H4503ROS_invoke_chosen 1
	Invoke invoke;
#	define H4503ROS_returnResult_chosen 2
	ReturnResult returnResult;
#	define H4503ROS_returnError_chosen 3
	ReturnError returnError;
#	define reject_chosen 4
	Reject reject;
    } u;
} H4503ROS;

typedef struct DummyArg {
    ASN1choice_t choice;
    union {
#	define DummyArg_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DummyArg_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DummyArg;
#define DummyArg_PDU 5
#define SIZE_H4503PP_Module_PDU_5 sizeof(DummyArg)

typedef struct DummyRes {
    ASN1choice_t choice;
    union {
#	define DummyRes_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DummyRes_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DummyRes;
#define DummyRes_PDU 6
#define SIZE_H4503PP_Module_PDU_6 sizeof(DummyRes)

typedef struct SubaddressTransferArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PartySubaddress redirectionSubaddress;
#   define SubaddressTransferArg_argumentExtension_present 0x80
    SubaddressTransferArg_argumentExtension argumentExtension;
} SubaddressTransferArg;
#define SubaddressTransferArg_PDU 7
#define SIZE_H4503PP_Module_PDU_7 sizeof(SubaddressTransferArg)

typedef struct MixedExtension {
    ASN1choice_t choice;
    union {
#	define MixedExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define MixedExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} MixedExtension;
/*
typedef struct PartyNumber {
    ASN1choice_t choice;
    union {
#	define publicNumber_chosen 1
	PublicPartyNumber publicNumber;
#	define dataPartyNumber_chosen 2
	NumberDigits dataPartyNumber;
#	define telexPartyNumber_chosen 3
	NumberDigits telexPartyNumber;
#	define privateNumber_chosen 4
	PrivatePartyNumber privateNumber;
#	define nationalStandardPartyNumber_chosen 5
	NumberDigits nationalStandardPartyNumber;
    } u;
} PartyNumber;
*/
typedef struct CpickupNotifyArg_extensionArg {
    PCpickupNotifyArg_extensionArg next;
    MixedExtension value;
} CpickupNotifyArg_extensionArg_Element;

typedef struct CpNotifyArg_extensionArg {
    PCpNotifyArg_extensionArg next;
    MixedExtension value;
} CpNotifyArg_extensionArg_Element;

typedef struct PickExeRes_extensionRes {
    PPickExeRes_extensionRes next;
    MixedExtension value;
} PickExeRes_extensionRes_Element;

typedef struct PickExeArg_extensionArg {
    PPickExeArg_extensionArg next;
    MixedExtension value;
} PickExeArg_extensionArg_Element;

typedef struct PickupRes_extensionRes {
    PPickupRes_extensionRes next;
    MixedExtension value;
} PickupRes_extensionRes_Element;

typedef struct PickupArg_extensionArg {
    PPickupArg_extensionArg next;
    MixedExtension value;
} PickupArg_extensionArg_Element;

typedef struct PickrequRes_extensionRes {
    PPickrequRes_extensionRes next;
    MixedExtension value;
} PickrequRes_extensionRes_Element;

typedef struct PickrequArg_extensionArg {
    PPickrequArg_extensionArg next;
    MixedExtension value;
} PickrequArg_extensionArg_Element;

typedef struct GroupIndicationOffRes_extensionRes {
    PGroupIndicationOffRes_extensionRes next;
    MixedExtension value;
} GroupIndicationOffRes_extensionRes_Element;

typedef struct GroupIndicationOffArg_extensionArg {
    PGroupIndicationOffArg_extensionArg next;
    MixedExtension value;
} GroupIndicationOffArg_extensionArg_Element;

typedef struct GroupIndicationOnRes_extensionRes {
    PGroupIndicationOnRes_extensionRes next;
    MixedExtension value;
} GroupIndicationOnRes_extensionRes_Element;

typedef struct GroupIndicationOnArg_extensionArg {
    PGroupIndicationOnArg_extensionArg next;
    MixedExtension value;
} GroupIndicationOnArg_extensionArg_Element;

typedef struct CpSetupRes_extensionRes {
    PCpSetupRes_extensionRes next;
    MixedExtension value;
} CpSetupRes_extensionRes_Element;

typedef struct CpSetupArg_extensionArg {
    PCpSetupArg_extensionArg next;
    MixedExtension value;
} CpSetupArg_extensionArg_Element;

typedef struct CpRequestRes_extensionRes {
    PCpRequestRes_extensionRes next;
    MixedExtension value;
} CpRequestRes_extensionRes_Element;

typedef struct CpRequestArg_extensionArg {
    PCpRequestArg_extensionArg next;
    MixedExtension value;
} CpRequestArg_extensionArg_Element;

typedef struct ServiceApdus_rosApdus {
    PServiceApdus_rosApdus next;
    H4503ROS value;
} ServiceApdus_rosApdus_Element;
/*
typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
#	define url_ID_chosen 3
	ASN1char_t url_ID[513];
#	define transportID_chosen 4
	TransportAddress transportID;
#	define email_ID_chosen 5
	ASN1char_t email_ID[513];
#	define partyNumber_chosen 6
	PartyNumber partyNumber;
    } u;
} AliasAddress;
*/
typedef struct EndpointAddress_destinationAddress {
    PEndpointAddress_destinationAddress next;
    AliasAddress value;
} EndpointAddress_destinationAddress_Element;

typedef AliasAddress AddressInformation;

typedef struct EndpointAddress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PEndpointAddress_destinationAddress destinationAddress;
#   define remoteExtensionAddress_present 0x80
    AliasAddress remoteExtensionAddress;
} EndpointAddress;

typedef struct NetworkFacilityExtension {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityType sourceEntity;
#   define sourceEntityAddress_present 0x80
    AddressInformation sourceEntityAddress;
    EntityType destinationEntity;
#   define destinationEntityAddress_present 0x40
    AddressInformation destinationEntityAddress;
} NetworkFacilityExtension;

typedef struct ActivateDiversionQArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Procedure procedure;
    BasicService basicService;
    EndpointAddress divertedToAddress;
    EndpointAddress servedUserNr;
    EndpointAddress activatingUserNr;
#   define ActivateDiversionQArgument_extension_present 0x80
    ActivateDiversionQArgument_extension extension;
} ActivateDiversionQArgument;
#define ActivateDiversionQArgument_PDU 8
#define SIZE_H4503PP_Module_PDU_8 sizeof(ActivateDiversionQArgument)

typedef struct DeactivateDiversionQArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Procedure procedure;
    BasicService basicService;
    EndpointAddress servedUserNr;
    EndpointAddress deactivatingUserNr;
#   define DeactivateDiversionQArgument_extension_present 0x80
    DeactivateDiversionQArgument_extension extension;
} DeactivateDiversionQArgument;
#define DeactivateDiversionQArgument_PDU 9
#define SIZE_H4503PP_Module_PDU_9 sizeof(DeactivateDiversionQArgument)

typedef struct InterrogateDiversionQArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Procedure procedure;
#   define basicService_present 0x80
    BasicService basicService;
    EndpointAddress servedUserNr;
    EndpointAddress interrogatingUserNr;
#   define InterrogateDiversionQArgument_extension_present 0x40
    InterrogateDiversionQArgument_extension extension;
} InterrogateDiversionQArgument;
#define InterrogateDiversionQArgument_PDU 10
#define SIZE_H4503PP_Module_PDU_10 sizeof(InterrogateDiversionQArgument)

typedef struct CheckRestrictionArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress servedUserNr;
    BasicService basicService;
    EndpointAddress divertedToNr;
#   define CheckRestrictionArgument_extension_present 0x80
    CheckRestrictionArgument_extension extension;
} CheckRestrictionArgument;
#define CheckRestrictionArgument_PDU 11
#define SIZE_H4503PP_Module_PDU_11 sizeof(CheckRestrictionArgument)

typedef struct CallReroutingArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DiversionReason reroutingReason;
#   define originalReroutingReason_present 0x80
    DiversionReason originalReroutingReason;
    EndpointAddress calledAddress;
    ASN1uint16_t diversionCounter;
    H225InformationElement h225InfoElement;
    EndpointAddress lastReroutingNr;
    SubscriptionOption subscriptionOption;
#   define callingPartySubaddress_present 0x40
    PartySubaddress callingPartySubaddress;
    EndpointAddress callingNumber;
#   define CallReroutingArgument_callingInfo_present 0x20
    ASN1char16string_t callingInfo;
#   define CallReroutingArgument_originalCalledNr_present 0x10
    EndpointAddress originalCalledNr;
#   define CallReroutingArgument_redirectingInfo_present 0x8
    ASN1char16string_t redirectingInfo;
#   define CallReroutingArgument_originalCalledInfo_present 0x4
    ASN1char16string_t originalCalledInfo;
#   define CallReroutingArgument_extension_present 0x2
    CallReroutingArgument_extension extension;
} CallReroutingArgument;
#define CallReroutingArgument_PDU 12
#define SIZE_H4503PP_Module_PDU_12 sizeof(CallReroutingArgument)

typedef struct DivertingLegInformation1Argument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DiversionReason diversionReason;
    SubscriptionOption subscriptionOption;
    EndpointAddress nominatedNr;
#   define DivertingLegInformation1Argument_nominatedInfo_present 0x80
    ASN1char16string_t nominatedInfo;
#   define redirectingNr_present 0x40
    EndpointAddress redirectingNr;
#   define DivertingLegInformation1Argument_redirectingInfo_present 0x20
    ASN1char16string_t redirectingInfo;
#   define DivertingLegInformation1Argument_extension_present 0x10
    DivertingLegInformation1Argument_extension extension;
} DivertingLegInformation1Argument;
#define DivertingLegInformation1Argument_PDU 13
#define SIZE_H4503PP_Module_PDU_13 sizeof(DivertingLegInformation1Argument)

typedef struct DivertingLegInformation2Argument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t diversionCounter;
    DiversionReason diversionReason;
#   define originalDiversionReason_present 0x80
    DiversionReason originalDiversionReason;
#   define divertingNr_present 0x40
    EndpointAddress divertingNr;
#   define DivertingLegInformation2Argument_originalCalledNr_present 0x20
    EndpointAddress originalCalledNr;
#   define DivertingLegInformation2Argument_redirectingInfo_present 0x10
    ASN1char16string_t redirectingInfo;
#   define DivertingLegInformation2Argument_originalCalledInfo_present 0x8
    ASN1char16string_t originalCalledInfo;
#   define DivertingLegInformation2Argument_extension_present 0x4
    DivertingLegInformation2Argument_extension extension;
} DivertingLegInformation2Argument;
#define DivertingLegInformation2Argument_PDU 14
#define SIZE_H4503PP_Module_PDU_14 sizeof(DivertingLegInformation2Argument)

typedef struct DivertingLegInformation3Argument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PresentationAllowedIndicator presentationAllowedIndicator;
#   define redirectionNr_present 0x80
    EndpointAddress redirectionNr;
#   define DivertingLegInformation3Argument_redirectionInfo_present 0x40
    ASN1char16string_t redirectionInfo;
#   define DivertingLegInformation3Argument_extension_present 0x20
    DivertingLegInformation3Argument_extension extension;
} DivertingLegInformation3Argument;
#define DivertingLegInformation3Argument_PDU 15
#define SIZE_H4503PP_Module_PDU_15 sizeof(DivertingLegInformation3Argument)

typedef struct DivertingLegInformation4Argument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DiversionReason diversionReason;
    SubscriptionOption subscriptionOption;
    EndpointAddress callingNr;
#   define DivertingLegInformation4Argument_callingInfo_present 0x80
    ASN1char16string_t callingInfo;
    EndpointAddress nominatedNr;
#   define DivertingLegInformation4Argument_nominatedInfo_present 0x40
    ASN1char16string_t nominatedInfo;
#   define DivertingLegInformation4Argument_extension_present 0x20
    DivertingLegInformation4Argument_extension extension;
} DivertingLegInformation4Argument;
#define DivertingLegInformation4Argument_PDU 16
#define SIZE_H4503PP_Module_PDU_16 sizeof(DivertingLegInformation4Argument)

typedef struct IntResult {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress servedUserNr;
    BasicService basicService;
    Procedure procedure;
    EndpointAddress divertedToAddress;
#   define remoteEnabled_present 0x80
    ASN1bool_t remoteEnabled;
#   define IntResult_extension_present 0x40
    IntResult_extension extension;
} IntResult;

typedef struct CTInitiateArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentity callIdentity;
    EndpointAddress reroutingNumber;
#   define CTInitiateArg_argumentExtension_present 0x80
    CTInitiateArg_argumentExtension argumentExtension;
} CTInitiateArg;
#define CTInitiateArg_PDU 17
#define SIZE_H4503PP_Module_PDU_17 sizeof(CTInitiateArg)

typedef struct CTSetupArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentity callIdentity;
#   define transferringNumber_present 0x80
    EndpointAddress transferringNumber;
#   define CTSetupArg_argumentExtension_present 0x40
    CTSetupArg_argumentExtension argumentExtension;
} CTSetupArg;
#define CTSetupArg_PDU 18
#define SIZE_H4503PP_Module_PDU_18 sizeof(CTSetupArg)

typedef struct CTIdentifyRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentity callIdentity;
    EndpointAddress reroutingNumber;
#   define resultExtension_present 0x80
    CTIdentifyRes_resultExtension resultExtension;
} CTIdentifyRes;
#define CTIdentifyRes_PDU 19
#define SIZE_H4503PP_Module_PDU_19 sizeof(CTIdentifyRes)

typedef struct CTUpdateArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress redirectionNumber;
#   define CTUpdateArg_redirectionInfo_present 0x80
    ASN1char16string_t redirectionInfo;
#   define CTUpdateArg_basicCallInfoElements_present 0x40
    H225InformationElement basicCallInfoElements;
#   define CTUpdateArg_argumentExtension_present 0x20
    CTUpdateArg_argumentExtension argumentExtension;
} CTUpdateArg;
#define CTUpdateArg_PDU 20
#define SIZE_H4503PP_Module_PDU_20 sizeof(CTUpdateArg)

typedef struct CTCompleteArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndDesignation endDesignation;
    EndpointAddress redirectionNumber;
#   define CTCompleteArg_basicCallInfoElements_present 0x80
    H225InformationElement basicCallInfoElements;
#   define CTCompleteArg_redirectionInfo_present 0x40
    ASN1char16string_t redirectionInfo;
#   define callStatus_present 0x20
    CallStatus callStatus;
#   define CTCompleteArg_argumentExtension_present 0x10
    CTCompleteArg_argumentExtension argumentExtension;
} CTCompleteArg;
#define CTCompleteArg_PDU 21
#define SIZE_H4503PP_Module_PDU_21 sizeof(CTCompleteArg)

typedef struct CTActiveArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress connectedAddress;
#   define CTActiveArg_basicCallInfoElements_present 0x80
    H225InformationElement basicCallInfoElements;
#   define connectedInfo_present 0x40
    ASN1char16string_t connectedInfo;
#   define CTActiveArg_argumentExtension_present 0x20
    CTActiveArg_argumentExtension argumentExtension;
} CTActiveArg;
#define CTActiveArg_PDU 22
#define SIZE_H4503PP_Module_PDU_22 sizeof(CTActiveArg)

typedef struct CpRequestArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress parkingNumber;
    EndpointAddress parkedNumber;
    EndpointAddress parkedToNumber;
#   define CpRequestArg_parkedToPosition_present 0x80
    ParkedToPosition parkedToPosition;
#   define CpRequestArg_extensionArg_present 0x40
    PCpRequestArg_extensionArg extensionArg;
} CpRequestArg;
#define CpRequestArg_PDU 23
#define SIZE_H4503PP_Module_PDU_23 sizeof(CpRequestArg)

typedef struct CpRequestRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress parkedToNumber;
#   define CpRequestRes_parkedToPosition_present 0x80
    ParkedToPosition parkedToPosition;
    ParkCondition parkCondition;
#   define CpRequestRes_extensionRes_present 0x40
    PCpRequestRes_extensionRes extensionRes;
} CpRequestRes;
#define CpRequestRes_PDU 24
#define SIZE_H4503PP_Module_PDU_24 sizeof(CpRequestRes)

typedef struct CpSetupArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress parkingNumber;
    EndpointAddress parkedNumber;
    EndpointAddress parkedToNumber;
#   define CpSetupArg_parkedToPosition_present 0x80
    ParkedToPosition parkedToPosition;
#   define CpSetupArg_extensionArg_present 0x40
    PCpSetupArg_extensionArg extensionArg;
} CpSetupArg;
#define CpSetupArg_PDU 25
#define SIZE_H4503PP_Module_PDU_25 sizeof(CpSetupArg)

typedef struct CpSetupRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress parkedToNumber;
#   define CpSetupRes_parkedToPosition_present 0x80
    ParkedToPosition parkedToPosition;
    ParkCondition parkCondition;
#   define CpSetupRes_extensionRes_present 0x40
    PCpSetupRes_extensionRes extensionRes;
} CpSetupRes;
#define CpSetupRes_PDU 26
#define SIZE_H4503PP_Module_PDU_26 sizeof(CpSetupRes)

typedef struct GroupIndicationOnArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
    EndpointAddress groupMemberUserNr;
    H4505CallType retrieveCallType;
    EndpointAddress partyToRetrieve;
    EndpointAddress retrieveAddress;
#   define GroupIndicationOnArg_parkPosition_present 0x80
    ParkedToPosition parkPosition;
#   define GroupIndicationOnArg_extensionArg_present 0x40
    PGroupIndicationOnArg_extensionArg extensionArg;
} GroupIndicationOnArg;
#define GroupIndicationOnArg_PDU 27
#define SIZE_H4503PP_Module_PDU_27 sizeof(GroupIndicationOnArg)

typedef struct GroupIndicationOffArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
    EndpointAddress groupMemberUserNr;
#   define GroupIndicationOffArg_extensionArg_present 0x80
    PGroupIndicationOffArg_extensionArg extensionArg;
} GroupIndicationOffArg;
#define GroupIndicationOffArg_PDU 28
#define SIZE_H4503PP_Module_PDU_28 sizeof(GroupIndicationOffArg)

typedef struct PickrequArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress picking_upNumber;
#   define callPickupId_present 0x80
    CallIdentifier callPickupId;
#   define partyToRetrieve_present 0x40
    EndpointAddress partyToRetrieve;
    EndpointAddress retrieveAddress;
#   define PickrequArg_parkPosition_present 0x20
    ParkedToPosition parkPosition;
#   define PickrequArg_extensionArg_present 0x10
    PPickrequArg_extensionArg extensionArg;
} PickrequArg;
#define PickrequArg_PDU 29
#define SIZE_H4503PP_Module_PDU_29 sizeof(PickrequArg)

typedef struct PickupArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
    EndpointAddress picking_upNumber;
#   define PickupArg_extensionArg_present 0x80
    PPickupArg_extensionArg extensionArg;
} PickupArg;
#define PickupArg_PDU 30
#define SIZE_H4503PP_Module_PDU_30 sizeof(PickupArg)

typedef struct PickExeArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
    EndpointAddress picking_upNumber;
    EndpointAddress partyToRetrieve;
#   define PickExeArg_extensionArg_present 0x80
    PPickExeArg_extensionArg extensionArg;
} PickExeArg;
#define PickExeArg_PDU 31
#define SIZE_H4503PP_Module_PDU_31 sizeof(PickExeArg)

typedef struct CpNotifyArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define parkingNumber_present 0x80
    EndpointAddress parkingNumber;
#   define CpNotifyArg_extensionArg_present 0x40
    PCpNotifyArg_extensionArg extensionArg;
} CpNotifyArg;
#define CpNotifyArg_PDU 32
#define SIZE_H4503PP_Module_PDU_32 sizeof(CpNotifyArg)

typedef struct CpickupNotifyArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define picking_upNumber_present 0x80
    EndpointAddress picking_upNumber;
#   define CpickupNotifyArg_extensionArg_present 0x40
    PCpickupNotifyArg_extensionArg extensionArg;
} CpickupNotifyArg;
#define CpickupNotifyArg_PDU 33
#define SIZE_H4503PP_Module_PDU_33 sizeof(CpickupNotifyArg)

typedef struct H4501SupplementaryService {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define networkFacilityExtension_present 0x80
    NetworkFacilityExtension networkFacilityExtension;
#   define interpretationApdu_present 0x40
    InterpretationApdu interpretationApdu;
    ServiceApdus serviceApdu;
} H4501SupplementaryService;
#define H4501SupplementaryService_PDU 34
#define SIZE_H4503PP_Module_PDU_34 sizeof(H4501SupplementaryService)

typedef struct IntResultList {
    ASN1uint32_t count;
    IntResult value[29];
} IntResultList;
#define IntResultList_PDU 35
#define SIZE_H4503PP_Module_PDU_35 sizeof(IntResultList)

extern CallStatus CTCompleteArg_callStatus_default;
extern ASN1bool_t IntResult_remoteEnabled_default;
extern BasicService InterrogateDiversionQArgument_basicService_default;

extern ASN1module_t H4503PP_Module;
extern void ASN1CALL H4503PP_Module_Startup(void);
extern void ASN1CALL H4503PP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_ExtensionSeq_ElmFn(ASN1encoding_t enc, PExtensionSeq val);
    extern int ASN1CALL ASN1Dec_ExtensionSeq_ElmFn(ASN1decoding_t dec, PExtensionSeq val);
	extern void ASN1CALL ASN1Free_ExtensionSeq_ElmFn(PExtensionSeq val);
    extern int ASN1CALL ASN1Enc_CpickupNotifyArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpickupNotifyArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_CpickupNotifyArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpickupNotifyArg_extensionArg val);
	extern void ASN1CALL ASN1Free_CpickupNotifyArg_extensionArg_ElmFn(PCpickupNotifyArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_CpNotifyArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpNotifyArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_CpNotifyArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpNotifyArg_extensionArg val);
	extern void ASN1CALL ASN1Free_CpNotifyArg_extensionArg_ElmFn(PCpNotifyArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_PickExeRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickExeRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_PickExeRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickExeRes_extensionRes val);
	extern void ASN1CALL ASN1Free_PickExeRes_extensionRes_ElmFn(PPickExeRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_PickExeArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickExeArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_PickExeArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickExeArg_extensionArg val);
	extern void ASN1CALL ASN1Free_PickExeArg_extensionArg_ElmFn(PPickExeArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_PickupRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickupRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_PickupRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickupRes_extensionRes val);
	extern void ASN1CALL ASN1Free_PickupRes_extensionRes_ElmFn(PPickupRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_PickupArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickupArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_PickupArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickupArg_extensionArg val);
	extern void ASN1CALL ASN1Free_PickupArg_extensionArg_ElmFn(PPickupArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_PickrequRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickrequRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_PickrequRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickrequRes_extensionRes val);
	extern void ASN1CALL ASN1Free_PickrequRes_extensionRes_ElmFn(PPickrequRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_PickrequArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickrequArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_PickrequArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickrequArg_extensionArg val);
	extern void ASN1CALL ASN1Free_PickrequArg_extensionArg_ElmFn(PPickrequArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_GroupIndicationOffRes_extensionRes_ElmFn(ASN1encoding_t enc, PGroupIndicationOffRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_GroupIndicationOffRes_extensionRes_ElmFn(ASN1decoding_t dec, PGroupIndicationOffRes_extensionRes val);
	extern void ASN1CALL ASN1Free_GroupIndicationOffRes_extensionRes_ElmFn(PGroupIndicationOffRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_GroupIndicationOffArg_extensionArg_ElmFn(ASN1encoding_t enc, PGroupIndicationOffArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_GroupIndicationOffArg_extensionArg_ElmFn(ASN1decoding_t dec, PGroupIndicationOffArg_extensionArg val);
	extern void ASN1CALL ASN1Free_GroupIndicationOffArg_extensionArg_ElmFn(PGroupIndicationOffArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_GroupIndicationOnRes_extensionRes_ElmFn(ASN1encoding_t enc, PGroupIndicationOnRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_GroupIndicationOnRes_extensionRes_ElmFn(ASN1decoding_t dec, PGroupIndicationOnRes_extensionRes val);
	extern void ASN1CALL ASN1Free_GroupIndicationOnRes_extensionRes_ElmFn(PGroupIndicationOnRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_GroupIndicationOnArg_extensionArg_ElmFn(ASN1encoding_t enc, PGroupIndicationOnArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_GroupIndicationOnArg_extensionArg_ElmFn(ASN1decoding_t dec, PGroupIndicationOnArg_extensionArg val);
	extern void ASN1CALL ASN1Free_GroupIndicationOnArg_extensionArg_ElmFn(PGroupIndicationOnArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_CpSetupRes_extensionRes_ElmFn(ASN1encoding_t enc, PCpSetupRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_CpSetupRes_extensionRes_ElmFn(ASN1decoding_t dec, PCpSetupRes_extensionRes val);
	extern void ASN1CALL ASN1Free_CpSetupRes_extensionRes_ElmFn(PCpSetupRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_CpSetupArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpSetupArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_CpSetupArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpSetupArg_extensionArg val);
	extern void ASN1CALL ASN1Free_CpSetupArg_extensionArg_ElmFn(PCpSetupArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_CpRequestRes_extensionRes_ElmFn(ASN1encoding_t enc, PCpRequestRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_CpRequestRes_extensionRes_ElmFn(ASN1decoding_t dec, PCpRequestRes_extensionRes val);
	extern void ASN1CALL ASN1Free_CpRequestRes_extensionRes_ElmFn(PCpRequestRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_CpRequestArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpRequestArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_CpRequestArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpRequestArg_extensionArg val);
	extern void ASN1CALL ASN1Free_CpRequestArg_extensionArg_ElmFn(PCpRequestArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_ServiceApdus_rosApdus_ElmFn(ASN1encoding_t enc, PServiceApdus_rosApdus val);
    extern int ASN1CALL ASN1Dec_ServiceApdus_rosApdus_ElmFn(ASN1decoding_t dec, PServiceApdus_rosApdus val);
	extern void ASN1CALL ASN1Free_ServiceApdus_rosApdus_ElmFn(PServiceApdus_rosApdus val);
    extern int ASN1CALL ASN1Enc_EndpointAddress_destinationAddress_ElmFn(ASN1encoding_t enc, PEndpointAddress_destinationAddress val);
    extern int ASN1CALL ASN1Dec_EndpointAddress_destinationAddress_ElmFn(ASN1decoding_t dec, PEndpointAddress_destinationAddress val);
	extern void ASN1CALL ASN1Free_EndpointAddress_destinationAddress_ElmFn(PEndpointAddress_destinationAddress val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H4503PP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\h323util.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    MSPCall.h

Abstract:

    Definitions for MSP utililty functions. There are all related to 
    active movie filter manipulation.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __MSPUTIL_H
#define __MSPUTIL_H

const DWORD PAYLOAD_G711U   = 0;
const DWORD PAYLOAD_G723    = 4;
const DWORD PAYLOAD_G711A   = 8;
const DWORD PAYLOAD_H261    = 31;
const DWORD PAYLOAD_H263    = 34;

const TCHAR gszMSPKey[]   =
   L"Software\\Microsoft\\Windows\\CurrentVersion\\H323MSP\\";

const TCHAR gszAEC[]   = L"AEC";

HRESULT
FindPin(
    IN  IBaseFilter *   pInterfaceilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE
    );

HRESULT
PinSupportsMediaType(
    IN IPin *           pIPin,
    IN const GUID &     MediaType
    );

HRESULT
AddFilter(
    IN  IGraphBuilder *     pIGraph,
    IN  const CLSID &       Clsid,
    IN  LPCWSTR             pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    );

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBandwidth,
    IN BOOL             bReceive,
    IN BOOL             bCIF = FALSE
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pInterfaceilter1, 
    IN IBaseFilter *    pInterfaceilter2,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pInterfaceilter,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pInterfaceilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter,
    IN  BOOL        fDirectRTP
    );

void WINAPI H323DeleteMediaType(AM_MEDIA_TYPE *pmt);


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    );

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    );

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    );

HRESULT GetFormatHelper(
    IN  IPin *pPin,
    OUT AM_MEDIA_TYPE **ppMediaType
    );

HRESULT SetFormatHelper(
    IN  IPin *pPin,
    IN AM_MEDIA_TYPE *pMediaType
    );

HRESULT GetNumberOfCapabilitiesHelper(
    IN  IPin *pPin,
    OUT DWORD *pdwCount
    );

HRESULT GetStreamCapsHelper(
    IN  IPin *pPin,
    IN DWORD dwIndex, 
    OUT AM_MEDIA_TYPE **ppMediaType, 
    OUT TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
    OUT BOOL *pfEnabled
    );

template <class TInterface, class TEnum, class Flag>
HRESULT GetRangeHelper(
    IN  TInterface * pInterface,
    IN  TEnum Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT Flag *plFlags
    )
{
    ENTER_FUNCTION("GetRangeHelper");

    if (IsBadWritePtr(plMin, sizeof(long)) || 
        IsBadWritePtr(plMax, sizeof(long)) ||
        IsBadWritePtr(plSteppingDelta, sizeof(long)) ||
        IsBadWritePtr(plDefault, sizeof(long)) ||
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr = pInterface->GetRange(
            Property,
            plMin, 
            plMax, 
            plSteppingDelta, 
            plDefault, 
            plFlags
            );

    return hr;
}

template <class T>
HRESULT CreateCComObjectInstance (
    CComObject<T> **ppObject
    )
/*++

Create a new CComObject instance. Use try/except to catch exception.

--*/
{
    HRESULT hr;

    __try
    {
        hr = CComObject<T>::CreateInstance(ppObject);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        *ppObject = NULL;
        return E_OUTOFMEMORY;
    }

    return hr;
}

template <class TInterface, class TEnum, class Flag>
HRESULT GetHelper(
    IN  TInterface * pInterface,
    IN  TEnum Property, 
    OUT long *plValue, 
    OUT Flag *plFlags
    )
{
    ENTER_FUNCTION("GetHelper");

    if (IsBadWritePtr(plValue, sizeof(long)) || 
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr = pInterface->Get(
        Property,
        plValue, 
        plFlags
        );

    return hr;
}

inline DWORD FindSampleRate(AM_MEDIA_TYPE *pMediaType)
{
    _ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (pMediaType->majortype == MEDIATYPE_Audio &&
            pMediaType->formattype == FORMAT_WaveFormatEx &&
            pMediaType->pbFormat != NULL &&
            pMediaType->cbFormat != 0)
    {
        WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;
        return pWaveFormatEx->nSamplesPerSec;
    }

    return 90000;      // default media clock rate, including video.
}

HRESULT ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    );

HRESULT
H323DetermineLinkSpeed(
    IN  DWORD  dwHostAddr,  
    OUT DWORD *dwInterfaceLinkSpeed
    );

class ATL_NO_VTABLE CMSPStreamClock : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IReferenceClock
{
private:
    LONGLONG         m_lPerfFrequency;
    union {
        LONGLONG         m_lRtpRefTime;
        DWORD            m_dwRtpRefTime;
    };

public:

BEGIN_COM_MAP(CMSPStreamClock)
    COM_INTERFACE_ENTRY(IReferenceClock)
END_COM_MAP()

    void InitReferenceTime(void);

    HRESULT GetTimeOfDay(OUT REFERENCE_TIME *pTime);

    CMSPStreamClock()
    {
        InitReferenceTime();
    }

    STDMETHOD (GetTime) (
            OUT REFERENCE_TIME *pTime
        )
    {
        return(GetTimeOfDay(pTime));
    }

    STDMETHOD (AdviseTime) (
        IN REFERENCE_TIME baseTime,        // base reference time
        IN REFERENCE_TIME streamTime,      // stream offset time
        IN HEVENT hEvent,                  // advise via this event
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdviseTime is called");
        return E_NOTIMPL;
    }

    STDMETHOD (AdvisePeriodic) (
        IN REFERENCE_TIME StartTime,       // starting at this time
        IN REFERENCE_TIME PeriodTime,      // time between notifications
        IN HSEMAPHORE hSemaphore,          // advise via a semaphore
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdvisePeriodic is called");
        return E_NOTIMPL;
    }

    STDMETHOD (Unadvise) (
        IN DWORD_PTR dwAdviseCookie
        )
    {
        _ASSERT(!"Unadvise is called");
        return E_NOTIMPL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\mspdebug.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    common.h

Abstract:

    commonly used headers.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/
#ifndef __COMMON_H_
#define __COMMON_H_

#include "msplog.h"


#ifdef MSPLOG
#define ENTER_FUNCTION(s) \
    static const CHAR * const __fxName = s
#else
#define ENTER_FUNCTION(s)
#endif // MSPLOG

#ifdef DEBUG
//  DEBUG **********************************
int WINAPI MSPDbgPrintf ( LPTSTR lpszFormat, ... );
// fake GETMASK
#define GETMASK(m) 0

// extern HDBGZONE  ghDbgZoneMsp;  // MSP debug zone control registration
// fake registration temporarily
#define ghDbgZoneMsp 0

#define ZONE_INIT       (GETMASK(ghDbgZoneMSP) & 0x0001)
#define ZONE_TERMINAL   (GETMASK(ghDbgZoneMSP) & 0x0002)
#define ZONE_STREAM     (GETMASK(ghDbgZoneMSP) & 0x0004)
#define ZONE_H245       (GETMASK(ghDbgZoneMSP) & 0x0008)
#define ZONE_MCCOMMANDS (GETMASK(ghDbgZoneMSP) & 0x0010)
#define ZONE_TSPCOMM    (GETMASK(ghDbgZoneMSP) & 0x0020)
#define ZONE_CHANNEL    (GETMASK(ghDbgZoneMSP) & 0x0040)
#define ZONE_REFCOUNT   (GETMASK(ghDbgZoneMSP) & 0x0080)
#define ZONE_U4         (GETMASK(ghDbgZoneMSP) & 0x0100)
#define ZONE_PROFILE    (GETMASK(ghDbgZoneMSP) & 0x0200)

//extern HDBGZONE  ghDbgZoneStream;   // stream debug zone control registration
// fake registration temporarily
#define ghDbgZoneStream 0

#define ZONE_S1 (GETMASK(ghDbgZoneStream) & 0x0001)
#define ZONE_S2 (GETMASK(ghDbgZoneStream) & 0x0002)

#ifndef DEBUGMSG 
//    #define DEBUGMSG(z,s)	( (z) ? (MSPDbgPrintf s ) : 0)
//    #define DEBUGMSG(z,s)	( (z) ? (LOG(s)) : 0)
// ignore the zone temporarily
    #define DEBUGMSG(z,s)	LOG(s)

#endif // DEBUGMSG

#ifndef FX_ENTRY 
    #define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
    #define _fx_		((LPTSTR) _this_fx_)
#endif // FX_ENTRY

// #define ERRORMESSAGE(m) (MSPDbgPrintf m)
 #define ERRORMESSAGE(m) LOG(m)
 
#else // not DEBUG *******************************

#ifndef FX_ENTRY 
    #define FX_ENTRY(s)	
#endif // FX_ENTRY

#ifndef DEBUGMSG 
    #define DEBUGMSG(z,s)
    #define ERRORMESSAGE(m)
#endif  // DEBUGMSG

#define _fx_		
#define ERRORMESSAGE(m)

#endif // not DEBUG ***********************

#endif // __COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\stats.h ===
//  STATS.H
//
//      Headers for STATS.DLL: a library to accumulate high performance
//      statistics and allow them to be tabulated in a different
//      process.
//
//  Created 24-Oct-96 [JonT]

#ifndef _STATS_H
#define _STATS_H

#ifdef __cplusplus
extern "C" {
#endif

//#if defined(_BUILD_STATS_) || defined(__midl)
#ifdef _BUILD_STATS_
#define STATSAPI
#else
#define STATSAPI __declspec(dllimport)
#endif

// Equates
#define MAX_COUNTER_NAME    64
#define STATS_COUNTER_ADDDEL_EVENT  "StatsNewCounter"
#define COUNTER_FLAG_NO_STATISTICS  1   // Flag to CreateCounter. No statistics accumulated
                                        // for this counter even if StartStatistics called.
                                        // (StartStatistics fails)
#define COUNTER_FLAG_ACCUMULATE     2   // UpdateCounter adds to the counter value rather
                                        // than replacing it.
#define COUNTER_CLEAR               1   // Flag to GetCounter. Specifies the counter should
                                        // be cleared after being read

// Types

#ifdef __midl
typedef DWORD HCOUNTER;
#else
typedef HANDLE HCOUNTER;
#endif

typedef struct _FINDCOUNTER
{
    DWORD dwSize;
    char szName[MAX_COUNTER_NAME];      // Human-readable counter name
    HCOUNTER hcounter;                  // Handle to use with all stats functions
    int nValue;                         // Current value of counter
    WORD wFlags;                        // COUNTER_FLAG_* values
    WORD wRefCount;                     // Number of times StartStatistics has been called.
    DWORD dwReserved;                   // Must be preserved: used for FindNextCounter
} FINDCOUNTER;

typedef struct _COUNTERSTAT
{
    DWORD dwSize;                       // Size of structure. Allows for future growth...
    int nValue;
    int nLow;                           // Lowest value seen since clear
    int nHigh;                          // Highest value seen since clear
    int nAverage;                       // Average value seen since clear
    DWORD dwNumSamples;                 // Number of samples accumulated
    DWORD dwmsAtClear;                  // GetTickCount at last Clear/StartStatistics call
} COUNTERSTAT;

typedef HCOUNTER HREPORT;
#define MAX_REPORT_NAME    64

typedef struct _FINDREPORT
{
    DWORD dwSize;
    char szName[MAX_REPORT_NAME];       // Human-readable report name
    HREPORT hreport;                    // Handle to use with all functions
    WORD wFlags;                        // COUNTER_FLAG_* values
    WORD wRefCount;                     // Number of times StartStatistics has been called.
    DWORD dwReserved;                   // Must be preserved: used for FindNextCounter
} FINDREPORT;

// Nothing further needed by MIDL
#ifndef __midl

// Functions

    // Called by updater of counter to make new counter
    // Sets the event named in the equate STATS_NEW_COUNTER_EVENT
    STATSAPI HCOUNTER WINAPI    CreateCounter(char* szName, WORD wFlags);

    // Called by updater of counter when counter is going away
    STATSAPI BOOL WINAPI DeleteCounter(HCOUNTER hc);

    // Used by reader app to locate specific named counters or walk entire list.
    // Pass NULL in for name to walk entire list. Pass NULL to FINDCOUNTER if
    // just an HCOUNTER is desired. FindNext returns FALSE when there are no more.
    STATSAPI HCOUNTER WINAPI    FindFirstCounter(char* szName, FINDCOUNTER* pfc);
    STATSAPI BOOL WINAPI        FindNextCounter(FINDCOUNTER* pfc);

    // Called by updater of counter. Makes the value current in the counter.
    STATSAPI void WINAPI        UpdateCounter(HCOUNTER hcounter, int value);

    // Called by user of counter and just returns value with no statistics
    STATSAPI int WINAPI         GetCounter(HCOUNTER hcounter, DWORD dwFlags);

    // Begins collecting statistics on a counter
    STATSAPI BOOL WINAPI        StartStatistics(HCOUNTER hcounter);

    // Done collecting statistics on a counter
    STATSAPI void WINAPI        StopStatistics(HCOUNTER hcounter);

    // Get statistics on a counter
    STATSAPI BOOL WINAPI        ReadStatistics(HCOUNTER hcounter, COUNTERSTAT* pcs);

    // Clear statistics on a counter
    STATSAPI void WINAPI        ClearStatistics(HCOUNTER hcounter);

#endif // #ifndef __midl

#ifdef __cplusplus
}
#endif

#endif // #ifndef _STATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\tspmspif.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    tspmspif.h

Abstract:

    Message interface between H.32X MSP and TSP

Author:
    Michael Vanbuskirk (mikev) 05/12/99

--*/

#ifndef __TSPMSPIF_H_
#define __TSPMSPIF_H_


#include <winsock2.h>

typedef enum tag_TspMspMessageType
{
	SP_MSG_InitiateCall,
	SP_MSG_AnswerCall,	
	SP_MSG_PrepareToAnswer,	
	SP_MSG_ProceedWithAnswer,	
	SP_MSG_ReadyToInitiate,	
	SP_MSG_ReadyToAnswer,	
	SP_MSG_FastConnectResponse,
	SP_MSG_StartH245,	
	SP_MSG_ConnectComplete,	
	SP_MSG_H245PDU,	
	SP_MSG_MCLocationIdentify,	
	SP_MSG_Hold,	
	SP_MSG_H245Hold,	
	SP_MSG_ConferenceList,	
	SP_MSG_SendDTMFDigits,	
	SP_MSG_ReleaseCall,	
	SP_MSG_CallShutdown,
	SP_MSG_H245Terminated,	
	SP_MSG_LegacyDefaultAlias,
	SP_MSG_RASRegistration,	
	SP_MSG_RASRegistrationEvent,	
	SP_MSG_RASLocationRequest,	
	SP_MSG_RASLocationConfirm,	
	SP_MSG_RASBandwidthRequest,	
	SP_MSG_RASBandwidthConfirm	
}TspMspMessageType;


/* 
InitiateCall
    - Handle of TSP's replacement call (if applicable)
    - Handle of conference call (if applicable)
*/
typedef struct 
{
	HANDLE hTSPReplacementCall;		/* replacement call handle of the 
									entity sending the message (MSP's or TSP's handle) */
	HANDLE hTSPConferenceCall;
	SOCKADDR_IN saLocalQ931Addr;
} TSPMSP_InitiateCallMessage;


// AnswerCall (TSP to MSP).  // no parameters

/*
PrepareToAnswer (TSP to MSP).
    - Received fastConnect parameters
    - Received h245Tunneling capability
    - WaitForConnect flag
    - Q.931 setup parameters 
    - Handle of replacement call (if applicable)

*/

typedef struct 
{
	HANDLE hReplacementCall;		/* replacement call handle of the 
									entity sending the message (either the MSP TSP) */
	SOCKADDR_IN saLocalQ931Addr;
} TSPMSP_PrepareToAnswerMessage;

/*
ProceedWithAnswer (MSP to TSP)
    - Address of MC to deflect the call to
*/
typedef struct 
{
	BOOL fMCAddressPresent;		// true if AddrMC contains the MC address
	                            // FALSE if simply proceeding
	SOCKADDR_IN	saAddrMC;		// address of MC to route call to
	HANDLE hMSPReplacementCall;		/* MSP's replacement call handle (if applicable) */
} TSPMSP_ProceedWithAnswerMessage;


/*
ReadyToInitiate 
    - Additional callee addresses, callee alias(es) 
    - FastConnect proposal
    - WaitForConnect flag
    - Security profile ID(s)
    - Security token(s)
    - Handle of MSP's replacement call (if applicable)

*/

typedef struct 
{
	HANDLE hMSPReplacementCall;		/* MSP's replacement call handle (if applicable) */
} TSPMSP_ReadyToInitiateMessage;


/*
ReadyToAnswer (MSP to TSP)	
    - Fast Connect response 	
    - Security profile ID(s)
    - Security token(s)
    - Handle of MSP's replacement call (if applicable)
*/

typedef struct 
{
	HANDLE hMSPReplacementCall;		/* MSP's replacement call handle (if applicable) */
} TSPMSP_ReadyToAnswerMessage;

/*
FastConnectResponse (TSP to MSP)	
    - Fast Connect response 	
    - Security profile ID(s)
    - Security token(s)
    - Handle of MSP's replacement call (if applicable)
*/

typedef struct 
{
	HANDLE hTSPReplacementCall;		/* MSP's replacement call handle */
	BOOL    fH245TunnelCapability;
	SOCKADDR_IN saH245Addr;
} TSPMSP_FastConnectResponseMessage;


/*
StartH245 (TSP->MSP)
    - Call handle of call to replace (used in the "call transfer" case only)
    - Handle of TSP's replacement call (if applicable)
    - H.245 address
    - Received h245Tunneling capability
    - Conference call identifier (local MC case only)
    
optional (ASN.1):
    - Security token(s) received via Q.931
    - Security profile identifier(s) received via Q.931
    - Received fastConnect response (outgoing call case)
   
*/
typedef struct 
{
	HANDLE hMSPReplaceCall;		    /* handle of MSP's call being replaced */
	HANDLE hTSPReplacementCall;		/* TSP's replacement call handle */
    BYTE    ConferenceID[16];
	BOOL    fH245TunnelCapability;
	BOOL    fH245AddressPresent;
	SOCKADDR_IN saH245Addr;
	SOCKADDR_IN saQ931Addr;	    // always present
} TSPMSP_StartH245Message;


/*
ConnectComplete (TSP->MSP)	// no parameters
*/

/*
H245PDU (MSP->TSP, TSP->MSP)	// tunneled, encoded, pure ASN.1
*/

typedef struct 
{
} TSPMSP_H245PDUMessage;

/*
MCLocationIdentify (MSP->TSP)
*/

typedef struct 
{
	BOOL fMCIsLocal;		// true if the MC is  on the local machine
	SOCKADDR_IN	AddrMC;		// address of MC to route call to
} TSPMSP_MCLocationIdentifyMessage;

/*
Hold (TSP->MSP)
*/

typedef struct 
{
	BOOL fHold;			
} TSPMSP_HoldMessage;


/*
H245Hold (MSP->TSP) 
*/
typedef struct 
{
	BOOL fHold;			
} TSPMSP_H245HoldMessage;

/*
ConferenceList(MSP->TSP, TSP->MSP)
*/
typedef struct 
{
	HANDLE hTSPReplacementCall;		/* MSP's replacement call handle */
} TSPMSP_ConferenceListMessage;


/*
SendDTMFDigits (TSP->MSP) 
*/

typedef struct 
{
	WORD 	wNumDigits;  // number of  characters in TspMspMessage.u.WideChars
} TSPMSP_SendDTMFDigitsMessage;

/*
ReleaseCall(MSP->TSP)	// no parameters
*/

/*
CallShutdown (TSP->MSP)	// no parameters
*/

/*
H245Terminated (MSP->TSP)	// no parameters
*/

typedef struct 
{
	WORD 	wNumChars;  // number of  characters in TspMspMessage.u.WideChars
} TSPMSP_LegacyDefaultAliasMessage;

/*
RASRegistration (MSP->TSP)
    - The list of aliases to register or unregister
*/
typedef struct 
{
    SOCKADDR_IN saGateKeeperAddr; 
} TSPMSP_RegistrationRequestMessage;


/*
RASRegistrationEvent (TSP->MSP)	// in encoded ASN.1 form
    - The event (URQ, DRQ, UCF, RCF)
    - The list of aliases that are affected by the event

*/

typedef struct 
{
} TSPMSP_RASEventMessage;


/*
RASLocationRequest (MSP->TSP)	// in encoded ASN.1 form
*/
typedef struct 
{
} TSPMSP_LocationRequestMessage;

/*
RASLocationConfirm (TSP->MSP)	// in encoded ASN.1 form
*/
typedef struct 
{
} TSPMSP_LocationConfirmMessage;

/*
RASBandwidthRequest (MSP->TSP)	// in encoded ASN.1 form
*/
typedef struct 
{
} TSPMSP_BandwidthRequestMessage;

/*
RASBandwidthConfirm (TSP->MSP)	// in encoded ASN.1 form
*/
typedef struct 
{
} TSPMSP_BandwidthConfirmMessage;


typedef struct tag_TspMspMessage
{
	TspMspMessageType MessageType;
	DWORD dwMessageSize;            // total size of the block, including this 
	                                // structure
	union
	{
		TSPMSP_InitiateCallMessage          InitiateCallMessage;
		TSPMSP_PrepareToAnswerMessage       PrepareToAnswerMessage;		
		TSPMSP_ProceedWithAnswerMessage     ProceedWithAnswerMessage;
		TSPMSP_ReadyToInitiateMessage       ReadyToInitiateMessage;
		TSPMSP_ReadyToAnswerMessage         ReadyToAnswerMessage;
        TSPMSP_FastConnectResponseMessage   FastConnectResponseMessage;
		TSPMSP_StartH245Message             StartH245Message;
		TSPMSP_H245PDUMessage               H245PDUMessage;
		TSPMSP_MCLocationIdentifyMessage    MCLocationIdentifyMessage;
		TSPMSP_HoldMessage                  HoldMessage;
		TSPMSP_H245HoldMessage              H245HoldMessage;
		TSPMSP_ConferenceListMessage        ConferenceListMessage;
		TSPMSP_SendDTMFDigitsMessage        SendDTMFDigitsMessage;
		TSPMSP_LegacyDefaultAliasMessage    LegacyDefaultAliasMessage;
		TSPMSP_RegistrationRequestMessage   RegistrationRequestMessage;
		TSPMSP_RASEventMessage              RASEventMessage; 
		TSPMSP_LocationRequestMessage       LocationRequestMessage;
		TSPMSP_LocationConfirmMessage       LocationConfirmMessage;
		TSPMSP_BandwidthRequestMessage      BandwidthRequestMessage;
		TSPMSP_BandwidthConfirmMessage      BandwidthConfirmMessage;
		
	}MsgBody;
	
	DWORD 	dwEncodedASNSize;
	union
	{
        BYTE	EncodedASN[1];	
        WORD    WideChars[1];
	}u;
	#define pEncodedASNBuf u.EncodedASN
	#define pWideChars u.WideChars
}TspMspMessage, *PTspMspMessage;

// The true total size of the message is: 
//  sizeof(TspMspMessage) + (the size of variable parts, e.g. #of encoded ASN.1 bytes)
//  - 1 byte.  

 #endif //__TSPMSPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\address.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    address.cpp

Abstract:

    TAPI Service Provider functions related to manipulating addresses.

        TSPI_lineGetAddressCaps
        TSPI_lineGetAddressStatus

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 
//                                                                           
// Include files                                                             
//                                                                           

#include "globals.h"
#include "line.h"


//                                                                           
// TSPI procedures                                                           
//                                                                           

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD             dwDeviceID,
    DWORD             dwAddressID,
    DWORD             dwTSPIVersion,
    DWORD             dwExtVersion,
    LPLINEADDRESSCAPS pAddressCaps
    )
    
/*++

Routine Description:

    This function queries the specified address on the specified line device 
    to determine its telephony capabilities.

    The line device IDs supported by a particular driver are numbered 
    sequentially starting at a value set by the TAPI DLL using the 
    TSPI_lineSetDeviceIDBase function.

    The version number supplied has been negotiated by the TAPI DLL using 
    TSPI_lineNegotiateTSPIVersion.

Arguments:

    dwDeviceID - Specifies the line device containing the address to be 
        queried.

    dwAddressID - Specifies the address on the given line device whose 
        capabilities are to be queried.

    dwTSPIVersion - Specifies the version number of the Telephony SPI to be 
        used. The high order word contains the major version number; the low 
        order word contains the minor version number.

    dwExtVersion - Specifies the version number of the service 
        provider-specific extensions to be used. This number can be left 
        zero if no device specific extensions are to be used. Otherwise, 
        the high order word contains the major version number; the low 
        order word contain the minor version number.

    pAddressCaps - Specifies a far pointer to a variable sized structure 
        of type LINEADDRESSCAPS. Upon successful completion of the request, 
        this structure is filled with address capabilities information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of the range 
            of line devices IDs supported by this driver.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_INCOMPATIBLEVERSION - The specified TSPI and/or extension 
            version number is not supported by the Service Provider for the 
            specified line device.

        LINEERR_INVALEXTVERSION - The app requested an invalid extension 
            version number.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    LONG retVal;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetAddressCaps - Entered." ));

    if( g_pH323Line -> GetDeviceID() != dwDeviceID )
    {
        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // make sure this is a version we support    
    if (!H323ValidateTSPIVersion(dwTSPIVersion))
    {
        // do not support tspi version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // make sure this is a version we support    
    if (!H323ValidateExtVersion(dwExtVersion))
    {
        // do not support extensions 
        retVal = LINEERR_INVALEXTVERSION;
        goto exit;

    }

    // make sure address id is supported
    if( g_pH323Line -> IsValidAddressID(dwAddressID) == FALSE )
    {
        // invalid address id
        retVal = LINEERR_INVALADDRESSID;
        goto exit;
    }
    
    retVal = g_pH323Line -> CopyLineInfo( dwDeviceID, pAddressCaps );
exit:
    return retVal;
}

/*++

Routine Description:

    This operation allows the TAPI DLL to query the specified address for its 
    current status.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        containing the address to be queried.

    dwAddressID - Specifies an address on the given open line device. 
        This is the address to be queried.

    pAddressStatus - Specifies a far pointer to a variable sized data 
        structure of type LINEADDRESSSTATUS.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified device handle is invalid.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/

LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS pAddressStatus
    )
{
    LONG retVal = NOERROR;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetAddressStatus - Entered." ));
    
    // make sure address id is supported
    if( g_pH323Line -> IsValidAddressID(dwAddressID) == FALSE )
    {
        // invalid address id
        return LINEERR_INVALADDRESSID;
    }

    //lock the line device
    g_pH323Line -> Lock();

    // calculate the number of bytes required
    pAddressStatus->dwNeededSize = sizeof(LINEADDRESSSTATUS);

    // see if lineaddressstatus structure is of correct size
    if (pAddressStatus->dwTotalSize < pAddressStatus->dwNeededSize) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "lineaddressstatus structure too small."
            ));

        //unlock the line device
        g_pH323Line -> Unlock();
        
        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    // record amount of memory used
    pAddressStatus->dwUsedSize = pAddressStatus->dwNeededSize;

    // transfer number of active calls from line device structure
    pAddressStatus->dwNumActiveCalls = g_pH323Line -> GetNoOfCalls();
    
    // specify that outbound call is possible on the address
    pAddressStatus->dwAddressFeatures = H323_ADDR_ADDRFEATURES;

    if( g_pH323Line->GetCallForwardParams() &&
        (g_pH323Line->GetCallForwardParams()->fForwardingEnabled) )
    {
        pAddressStatus->dwNumRingsNoAnswer = g_pH323Line->m_dwNumRingsNoAnswer;
        pAddressStatus->dwForwardOffset = pAddressStatus->dwUsedSize;
        retVal = g_pH323Line->CopyAddressForwardInfo( pAddressStatus );
    }

    //unlock the line device
    g_pH323Line -> Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetAddressStatus - Exited." ));
    
    // success
    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\inc\icounter.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sun Apr 19 17:22:14 1998
 */
/* Compiler settings for icounter.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __icounter_h__
#define __icounter_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICounter_FWD_DEFINED__
#define __ICounter_FWD_DEFINED__
typedef interface ICounter ICounter;
#endif 	/* __ICounter_FWD_DEFINED__ */


#ifndef __IReport_FWD_DEFINED__
#define __IReport_FWD_DEFINED__
typedef interface IReport IReport;
#endif 	/* __IReport_FWD_DEFINED__ */


#ifndef __ICounterMgr_FWD_DEFINED__
#define __ICounterMgr_FWD_DEFINED__
typedef interface ICounterMgr ICounterMgr;
#endif 	/* __ICounterMgr_FWD_DEFINED__ */


#ifndef __Counter_FWD_DEFINED__
#define __Counter_FWD_DEFINED__

#ifdef __cplusplus
typedef class Counter Counter;
#else
typedef struct Counter Counter;
#endif /* __cplusplus */

#endif 	/* __Counter_FWD_DEFINED__ */


#ifndef __Report_FWD_DEFINED__
#define __Report_FWD_DEFINED__

#ifdef __cplusplus
typedef class Report Report;
#else
typedef struct Report Report;
#endif /* __cplusplus */

#endif 	/* __Report_FWD_DEFINED__ */


#ifndef __CounterMgr_FWD_DEFINED__
#define __CounterMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterMgr CounterMgr;
#else
typedef struct CounterMgr CounterMgr;
#endif /* __cplusplus */

#endif 	/* __CounterMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "stats.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICounter_INTERFACE_DEFINED__
#define __ICounter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICounter
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICounter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7BC77801-3830-11d0-B143-00C04FC2A118")
    ICounter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ int nValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMax( 
            /* [in] */ int nMaxValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartStatistics( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopStatistics( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadStatistics( 
            /* [out] */ COUNTERSTAT __RPC_FAR *lpcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearStatistics( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICounter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICounter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ICounter __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            ICounter __RPC_FAR * This,
            /* [in] */ int nValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitMax )( 
            ICounter __RPC_FAR * This,
            /* [in] */ int nMaxValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            ICounter __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartStatistics )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopStatistics )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadStatistics )( 
            ICounter __RPC_FAR * This,
            /* [out] */ COUNTERSTAT __RPC_FAR *lpcs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearStatistics )( 
            ICounter __RPC_FAR * This);
        
        END_INTERFACE
    } ICounterVtbl;

    interface ICounter
    {
        CONST_VTBL struct ICounterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICounter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICounter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICounter_Initialize(This,szName,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,szName,dwFlags)

#define ICounter_Update(This,nValue)	\
    (This)->lpVtbl -> Update(This,nValue)

#define ICounter_InitMax(This,nMaxValue)	\
    (This)->lpVtbl -> InitMax(This,nMaxValue)

#define ICounter_GetValue(This,dwFlags,pnValue)	\
    (This)->lpVtbl -> GetValue(This,dwFlags,pnValue)

#define ICounter_StartStatistics(This)	\
    (This)->lpVtbl -> StartStatistics(This)

#define ICounter_StopStatistics(This)	\
    (This)->lpVtbl -> StopStatistics(This)

#define ICounter_ReadStatistics(This,lpcs)	\
    (This)->lpVtbl -> ReadStatistics(This,lpcs)

#define ICounter_ClearStatistics(This)	\
    (This)->lpVtbl -> ClearStatistics(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICounter_Initialize_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICounter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_Update_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ int nValue);


void __RPC_STUB ICounter_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_InitMax_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ int nMaxValue);


void __RPC_STUB ICounter_InitMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_GetValue_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ int __RPC_FAR *pnValue);


void __RPC_STUB ICounter_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_StartStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_StartStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_StopStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_StopStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_ReadStatistics_Proxy( 
    ICounter __RPC_FAR * This,
    /* [out] */ COUNTERSTAT __RPC_FAR *lpcs);


void __RPC_STUB ICounter_ReadStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_ClearStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_ClearStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICounter_INTERFACE_DEFINED__ */


#ifndef __IReport_INTERFACE_DEFINED__
#define __IReport_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReport
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7BC77802-3830-11d0-B143-00C04FC2A118")
    IReport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ int nValue,
            /* [in] */ DWORD dwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReport __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            IReport __RPC_FAR * This,
            /* [in] */ int nValue,
            /* [in] */ DWORD dwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEntry )( 
            IReport __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IReport __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue);
        
        END_INTERFACE
    } IReportVtbl;

    interface IReport
    {
        CONST_VTBL struct IReportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReport_Initialize(This,szName,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,szName,dwFlags)

#define IReport_Update(This,nValue,dwIndex)	\
    (This)->lpVtbl -> Update(This,nValue,dwIndex)

#define IReport_CreateEntry(This,szName,dwIndex)	\
    (This)->lpVtbl -> CreateEntry(This,szName,dwIndex)

#define IReport_GetValue(This,dwFlags,pnValue)	\
    (This)->lpVtbl -> GetValue(This,dwFlags,pnValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReport_Initialize_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IReport_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_Update_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ int nValue,
    /* [in] */ DWORD dwIndex);


void __RPC_STUB IReport_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_CreateEntry_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwIndex);


void __RPC_STUB IReport_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_GetValue_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ int __RPC_FAR *pnValue);


void __RPC_STUB IReport_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReport_INTERFACE_DEFINED__ */


#ifndef __ICounterMgr_INTERFACE_DEFINED__
#define __ICounterMgr_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICounterMgr
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICounterMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9CB7FE5B-3444-11D0-B143-00C04FC2A118")
    ICounterMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateCounter( 
            /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstC( 
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextC( 
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReport( 
            /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstR( 
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextR( 
            /* [out] */ FINDREPORT __RPC_FAR *lpfr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICounterMgr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICounterMgr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateCounter )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstC )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextC )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateReport )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstR )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextR )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr);
        
        END_INTERFACE
    } ICounterMgrVtbl;

    interface ICounterMgr
    {
        CONST_VTBL struct ICounterMgrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounterMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICounterMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICounterMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICounterMgr_CreateCounter(This,lplpCounter)	\
    (This)->lpVtbl -> CreateCounter(This,lplpCounter)

#define ICounterMgr_FindFirstC(This,szName,lpfc)	\
    (This)->lpVtbl -> FindFirstC(This,szName,lpfc)

#define ICounterMgr_FindNextC(This,lpfc)	\
    (This)->lpVtbl -> FindNextC(This,lpfc)

#define ICounterMgr_CreateReport(This,lplpReport)	\
    (This)->lpVtbl -> CreateReport(This,lplpReport)

#define ICounterMgr_FindFirstR(This,szName,lpfr)	\
    (This)->lpVtbl -> FindFirstR(This,szName,lpfr)

#define ICounterMgr_FindNextR(This,lpfr)	\
    (This)->lpVtbl -> FindNextR(This,lpfr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICounterMgr_CreateCounter_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter);


void __RPC_STUB ICounterMgr_CreateCounter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindFirstC_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);


void __RPC_STUB ICounterMgr_FindFirstC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindNextC_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);


void __RPC_STUB ICounterMgr_FindNextC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_CreateReport_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport);


void __RPC_STUB ICounterMgr_CreateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindFirstR_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [out] */ FINDREPORT __RPC_FAR *lpfr);


void __RPC_STUB ICounterMgr_FindFirstR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindNextR_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ FINDREPORT __RPC_FAR *lpfr);


void __RPC_STUB ICounterMgr_FindNextR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICounterMgr_INTERFACE_DEFINED__ */



#ifndef __Counter_LIBRARY_DEFINED__
#define __Counter_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: Counter
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_Counter;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Counter;

class DECLSPEC_UUID("9CB7FE5F-3444-11D0-B143-00C04FC2A118")
Counter;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Report;

class DECLSPEC_UUID("9CB7FE5E-3444-11D0-B143-00C04FC2A118")
Report;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CounterMgr;

class DECLSPEC_UUID("65DDC229-38FE-11d0-B143-00C04FC2A118")
CounterMgr;
#endif
#endif /* __Counter_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\call.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    call.h

Abstract:

    Definitions for H.323 TAPI Service Provider call objects.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#ifndef _INC_CALL
#define _INC_CALL
 

//                                                                           
// Header files                                                              
//                                                                           

#include "q931pdu.h"
#include "q931obj.h"


#define H323_CALL_FEATURES  (LINECALLFEATURE_DROP               | \
                            LINECALLFEATURE_SETUPTRANSFER       | \
                            LINECALLFEATURE_COMPLETETRANSF      | \
                            LINECALLFEATURE_DIAL                | \
                            LINECALLFEATURE_HOLD                | \
                            LINECALLFEATURE_ANSWER              | \
                            LINECALLFEATURE_REDIRECT            | \
                            LINECALLFEATURE_RELEASEUSERUSERINFO | \
                            LINECALLFEATURE_SENDUSERUSER        | \
                            LINECALLFEATURE_UNHOLD              | \
                            LINECALLFEATURE_GENERATEDIGITS      | \
                            LINECALLFEATURE_MONITORDIGITS)


#define IsValidDTMFDigit(wDigit)   (                                            \
                                    ((wDigit >= L'0') && (wDigit <= L'9')) ||   \
                                    ((wDigit >= L'A') && (wDigit <= L'D')) ||   \
                                    (wDigit == L'*') ||                         \
                                    (wDigit == L'#') ||                         \
                                    (wDigit == L'!') ||                         \
                                    (wDigit == L',')                            \
                                   )


//                                                                           
// Type definitions                                                          
//                                                                           
struct  EXPIRE_CONTEXT;

#define CHECKRESTRICTION_EXPIRE_TIME    15000
#define CALLREROUTING_EXPIRE_TIME       10000
#define CTIDENTIFY_SENT_TIMEOUT         30000
#define CTIDENTIFYRR_SENT_TIMEOUT       45000
#define CTINITIATE_SENT_TIMEOUT         60000


enum U2U_DIRECTION
{
    U2U_OUTBOUND                    = 0x00000001,
    U2U_INBOUND                     = 0x00000002,

};


enum CALLOBJECT_STATE
{
    CALLOBJECT_INITIALIZED          = 0x00000001,
    CALLOBJECT_SHUTDOWN             = 0x00000002,
    H245_START_MSG_SENT             = 0x00000004,
    TSPI_CALL_LOCAL_HOLD            = 0x00000008,

};


enum FAST_START_STATE
{

    FAST_START_UNDECIDED            = 0x00000001,
    FAST_START_NOTAVAIL             = 0x00000002,
    FAST_START_AVAIL                = 0x00000004,
    FAST_START_SELF_AVAIL           = 0x00000008,
    FAST_START_PEER_AVAIL           = 0x000000010,

};


enum RASCALL_STATE
{

    RASCALL_STATE_IDLE              = 0x00000001,
    RASCALL_STATE_ARQSENT           = 0x00000002,
    RASCALL_STATE_ARQEXPIRED        = 0x00000004,
    RASCALL_STATE_DRQSENT           = 0x00000008,
    RASCALL_STATE_DRQEXPIRED        = 0x000000010,
    RASCALL_STATE_REGISTERED        = 0x000000020,
    RASCALL_STATE_UNREGISTERED      = 0x000000040,
    RASCALL_STATE_ARJRECVD          = 0x000000080,

};


enum H323_CALLTYPE
{
    CALLTYPE_NORMAL                 = 0x00000000,

    CALLTYPE_FORWARDCONSULT         = 0x00000001,
    CALLTYPE_DIVERTEDDEST           = 0x00000002,
    CALLTYPE_DIVERTEDSRC            = 0x00000004,    
    CALLTYPE_DIVERTEDSRC_NOROUTING  = 0x00000008,
    CALLTYPE_DIVERTED_SERVED        = 0x00000010,

    CALLTYPE_TRANSFEREDSRC          = 0x00000020,
    CALLTYPE_TRANSFERING_PRIMARY    = 0x00000040,
    CALLTYPE_TRANSFERING_CONSULT    = 0x00000080,
    CALLTYPE_TRANSFEREDDEST         = 0x00000100,
    CALLTYPE_TRANSFERED_PRIMARY     = 0x00000200,
    CALLTYPE_TRANSFERED2_CONSULT    = 0x00000400,
    CALLTYPE_DIVERTEDTRANSFERED     = 0x00000800,

};


enum SUPP_CALLSTATE
{
    H4503_CALLSTATE_IDLE            = 0x00000000,
    H4503_CHECKRESTRICTION_SENT     = 0x00000001,
    H4503_DIVERSIONLEG1_SENT        = 0x00000002,
    H4503_DIVERSIONLEG2_SENT        = 0x00000004,
    H4503_DIVERSIONLEG3_SENT        = 0x00000008,
    H4503_DIVERSIONLEG1_RECVD       = 0x00000010,
    H4503_DIVERSIONLEG2_RECVD       = 0x00000020,
    H4503_DIVERSIONLEG3_RECVD       = 0x00000040,
    H4503_CALLREROUTING_SENT        = 0x00000080,
    H4503_CALLREROUTING_RECVD       = 0x00000100,
    H4503_CHECKRESTRICTION_RECV     = 0x00000200,
    H4503_CHECKRESTRICTION_SUCC     = 0x00000400,
    H4503_CALLREROUTING_RRSUCC      = 0x00000800,
    H4502_CTINITIATE_SENT           = 0x00001000,
    H4502_CTINITIATE_RECV           = 0x00002000,
    H4502_CTSETUP_SENT              = 0x00004000,
    H4502_CTSETUP_RECV              = 0x00008000,
    H4502_CTIDENTIFY_SENT           = 0x00010000,
    H4502_CTIDENTIFY_RECV           = 0x00020000,
    H4502_CIIDENTIFY_RRSUCC         = 0x00040000,
    H4502_CONSULTCALL_INITIATED     = 0x00080000,

};


// CH323Call::m_dwQ931Flags
enum Q931_STATE
{
    Q931_CALL_CONNECTING        = 0x00010000,   //connect has been issued on the socket
    Q931_CALL_CONNECTED         = 0x00100000,   //FD_CONNECT received
    Q931_CALL_DISCONNECTED      = 0x01000000,   //FD_CLOSE received from peer

};


enum TunnelingCap
{
    REMOTE_H245_TUNNELING   =0x01,
    LOCAL_H245_TUNNELING    =0x10,
};


// CH323Call::m_dwStateMachine
//Q931 state machine
enum Q931_CALL_STATE
{
    Q931_CALL_STATE_NONE = 0,

    //outbound
    Q931_ORIGINATE_ADMISSION_PENDING,
    Q931_SETUP_SENT,
    Q931_ALERT_RECVD,
    Q931_PROCEED_RECVD,
    Q931_CONNECT_RECVD,
    Q931_RELEASE_RECVD,

    //inbound
    Q931_ANSWER_ADMISSION_PENDING,
    Q931_SETUP_RECVD,
    Q931_ALERT_SENT,
    Q931_PROCEED_SENT,
    Q931_CONNECT_SENT,
    Q931_RELEASE_SENT

};


typedef struct _TAPI_CALLREQUEST_DATA
{
    DWORD EventID;
    PH323_CALL pCall;
    union
    {
        PVOID           pCallforwardParams;
        PBUFFERDESCR    pBuf;
    };

}TAPI_CALLREQUEST_DATA;


typedef struct _SUPP_REQUEST_DATA
{
    DWORD EventID;
    HDRVCALL hdCall;
    union{
    PH323_ALIASNAMES pAliasNames;
    HDRVCALL hdReplacementCall;
    CTIdentifyRes* pCTIdentifyRes;
    ULONG_PTR dwParam1;
    };

} SUPP_REQUEST_DATA;


typedef struct _MSPMessageData
{
    HDRVCALL            hdCall;
    TspMspMessageType   messageType;
    BYTE*               pbEncodedBuf;
    WORD                wLength;
    HDRVCALL            hReplacementCall;

}MSPMessageData;


enum
{
    TSPI_NO_EVENT = 0,

    TSPI_MAKE_CALL,
    TSPI_ANSWER_CALL,
    TSPI_DROP_CALL,
    TSPI_CLOSE_CALL,
    TSPI_RELEASE_U2U,
    TSPI_SEND_U2U,
    TSPI_COMPLETE_TRANSFER,
    TSPI_LINEFORWARD_SPECIFIC,
    TSPI_LINEFORWARD_NOSPECIFIC,
    TSPI_DIAL_TRNASFEREDCALL,
    TSPI_CALL_UNHOLD,
    TSPI_CALL_HOLD,

    TSPI_DELETE_CALL,
    
    TSPI_CALL_DIVERT,
    H450_PLACE_DIVERTEDCALL,
    SWAP_REPLACEMENT_CALL,
    DROP_PRIMARY_CALL,
    STOP_CTIDENTIFYRR_TIMER,
    SEND_CTINITIATE_MESSAGE,

};


BOOL
AddAliasItem( PH323_ALIASNAMES pAliasNames, BYTE* pbAliasName,
    DWORD dwAliasSize, WORD wType );

static __inline BOOL AddAliasItem (
    IN  H323_ALIASNAMES *       AliasNames,
    IN  LPWSTR                  AliasValue,
    IN  WORD                    Type)
{
    return AddAliasItem(
        AliasNames, 
        (LPBYTE) AliasValue, 
        (wcslen (AliasValue) + 1) * sizeof (TCHAR), 
        Type );
}


typedef struct _UserToUserLE
{
    LIST_ENTRY Link;
    DWORD dwU2USize;
    PBYTE pU2U;

} UserToUserLE, *PUserToUserLE;


typedef enum _FORWARDING_TYPE
{
    CALLFORWARD_UNCOND = 1,
    CALLFORWARD_BUSY,
    CALLFORWARD_NA
} FORWARDING_TYPE;



typedef struct _ForwardAddress
{
    DWORD           dwForwardType;
    H323_ALIASITEM  callerAlias;
    SOCKADDR_IN     saCallerAddr;    
    H323_ALIASITEM  divertedToAlias;
    //SOCKADDR_IN     saDivertedToAddr;
    struct _ForwardAddress* next;

} FORWARDADDRESS, *LPFORWARDADDRESS;


typedef struct _CallForwardParams
{
    BOOLEAN         fForwardingEnabled;
    //specifeis if forwarding is enabled for all calls irrespective of their origin
    BOOLEAN         fForwardForAllOrigins;
    DWORD           dwForwardTypeForAllOrigins;
    //address to which all the calls are diverted
    H323_ALIASITEM  divertedToAlias;
    //SOCKADDR_IN     saDivertedToAddr;

    //this filed is NULL if fForwardForAllOrigins is TRUE
    //list of addresses forwarded selectively
    LPFORWARDADDRESS  pForwardedAddresses;

}CALLFORWARDPARAMS, *PCALLFORWARDPARAMS;


struct  CALLREROUTINGINFO
{
    int                 diversionCounter;
    DiversionReason     diversionReason;
    DiversionReason     originalDiversionReason;

    PH323_ALIASNAMES    divertingNrAlias;
    PH323_ALIASNAMES    originalCalledNr;
    PH323_ALIASNAMES    divertedToNrAlias;
    PH323_ALIASNAMES    diversionNrAlias;
    
    BOOLEAN             fPresentAllow;

};


typedef struct tag_TspMspMessageWithEncodedBuf
{
    TspMspMessage   message;
    BYTE            pEncodedASN[4095];
} TspMspMessageEx;


static __inline int MakeCallIndex (
    IN  HDRVCALL    DriverHandleCall)
{
    return (int) LOWORD (HandleToUlong (DriverHandleCall));
}





//                                                                           
// Call capabilites                                                          
//                                                                           


#define H323_CALL_INBOUNDSTATES        (LINECALLSTATE_ACCEPTED      | \
                                        LINECALLSTATE_CONNECTED     | \
                                        LINECALLSTATE_DISCONNECTED  | \
                                        LINECALLSTATE_IDLE          | \
                                        LINECALLSTATE_OFFERING      | \
                                        LINECALLSTATE_RINGBACK      | \
                                        LINECALLSTATE_ONHOLD )

#define H323_CALL_OUTBOUNDSTATES       (LINECALLSTATE_CONNECTED     | \
                                        LINECALLSTATE_DIALING       | \
                                        LINECALLSTATE_DISCONNECTED  | \
                                        LINECALLSTATE_IDLE          | \
                                        LINECALLSTATE_RINGBACK      | \
                                        LINECALLSTATE_ONHOLD )

//
// CH323Call class.
//

class CH323Call
{

private:

    HDRVCALL                m_hdCall;           // tspi call handle
    DWORD                   m_dwFlags;
    CRITICAL_SECTION        m_CriticalSection;
    H323_CONFERENCE*        m_hdConf;           // conf handle

    DWORD                   m_dwCallState;      // tspi call state
    DWORD                   m_dwCallStateMode;  // tspi call state mode

    DWORD                   m_dwOrigin;         // inbound or outbound
    H323_OCTETSTRING        m_CallData;         // call data stored by the app for this call.
    DWORD                   m_dwAddressType;    // type of dst address
    DWORD                   m_dwAppSpecific;
    DWORD                   m_dwIncomingModes;  // available media modes
    DWORD                   m_dwOutgoingModes;  // available media modes
    DWORD                   m_dwRequestedModes; // requested media modes
    HDRVMSPLINE             m_hdMSPLine;
    HTAPIMSPLINE            m_htMSPLine;

    LIST_ENTRY              m_IncomingU2U;      // incoming user user messages
    LIST_ENTRY              m_OutgoingU2U;      // outgoing user user messages
    GUID                    m_callIdentifier;

    H323_ADDR               m_CalleeAddr;        // src address
    H323_ADDR               m_CallerAddr;        // dst address
    SOCKADDR_IN             m_LocalAddr;         // THIS END of the Q.931 connection
    PH323_ALIASNAMES        m_pCalleeAliasNames; // src alias
    PH323_ALIASNAMES        m_pCallerAliasNames; // dst alias
    H323NonStandardData     m_NonStandardData;
    GUID                    m_ConferenceID;
    PWSTR                   m_pwszDisplay;
    BOOLEAN                 m_fReadyToAnswer;
    BOOLEAN                 m_fCallAccepted;

    //peer information
    H323_ADDR               m_peerH245Addr;
    H323_ADDR               m_selfH245Addr;
    PWSTR                   m_pPeerDisplay;
    H323NonStandardData     m_peerNonStandardData;
    PH323_ALIASNAMES        m_pPeerExtraAliasNames;
    H323_VENDORINFO         m_peerVendorInfo;
    H323_ENDPOINTTYPE       m_peerEndPointType;
    PH323_FASTSTART         m_pFastStart;
    PH323_FASTSTART         m_pPeerFastStart;
    FAST_START_STATE        m_dwFastStart;

    //CQ931Call data objects
    HANDLE                  m_hTransport;//event signalled by winsock for
                            //CONNECT| CLOSE event for incoming connections and
                            //CLOSE event for outgoing connections
    SOCKET                  m_callSocket;
    HANDLE                  m_hTransportWait;//the event to unregister from thread pool
    BOOLEAN                 m_bStartOfPDU;
    HANDLE                  m_hSetupSentTimer;
    Q931_CALL_STATE         m_dwStateMachine;
    DWORD                   m_dwQ931Flags;
    BOOLEAN                 m_fActiveMC;
    ASN1_CODER_INFO         m_ASNCoderInfo;
    WORD                    m_wCallReference;
    WORD                    m_wQ931CallRef;
    LIST_ENTRY              m_sendBufList;
    DWORD                   m_IoRefCount;
    HANDLE                  m_hCallEstablishmentTimer;
    BOOLEAN                 m_fh245Tunneling;

    //RAS call data 
    RASCALL_STATE           m_dwRASCallState;
    WORD                    m_wARQSeqNum;
    WORD                    m_wDRQSeqNum;
    HANDLE                  m_hARQTimer;
    HANDLE                  m_hDRQTimer;
    DWORD                   m_dwDRQRetryCount;
    DWORD                   m_dwARQRetryCount;    
    BUFFERDESCR             m_prepareToAnswerMsgData;
    EXPIRE_CONTEXT*         m_pARQExpireContext;
    EXPIRE_CONTEXT*         m_pDRQExpireContext;

    //data related to supplementary services
    DWORD                   m_dwCallType;
    SUPP_CALLSTATE          m_dwCallDiversionState;
    ASN1_CODER_INFO         m_H450ASNCoderInfo;
    DWORD                   m_dwInvokeID;
    BOOLEAN                 m_fCallInTrnasition;

    //data related to call forwarding
    CALLREROUTINGINFO*      m_pCallReroutingInfo;
    HANDLE                  m_hCheckRestrictionTimer;
    HANDLE                  m_hCallReroutingTimer;
    HANDLE                  m_hCallDivertOnNATimer;

    //forwardconsult params
    CALLFORWARDPARAMS*      m_pCallForwardParams;
    LPFORWARDADDRESS        m_pForwardAddress;

    //data related to call transfer
    HANDLE                  m_hCTIdentifyTimer;
    HANDLE                  m_hCTIdentifyRRTimer;
    HANDLE                  m_hCTInitiateTimer;
    BYTE                    m_pCTCallIdentity[5];
    PH323_ALIASNAMES        m_pTransferedToAlias;
    HDRVCALL                m_hdRelatedCall;

    //data related to call Hold/Unhold
    BOOLEAN                 m_fRemoteHoldInitiated;
    BOOLEAN                 m_fRemoteRetrieveInitiated;



    //Call Object functionality
    BOOL SendProceeding(void);
    void CopyU2UAsNonStandard( DWORD dwDirection );
    BOOL AddU2UNoAlloc( IN DWORD dwDirection, IN DWORD dwDataSize,
        IN PBYTE pData );
    BOOL RemoveU2U( DWORD dwDirection, PUserToUserLE * ppU2ULE );
    BOOL FreeU2U( DWORD dwDirection );
    BOOL ResolveCallerAddress();
    BOOL ResolveE164Address( LPCWSTR pwszDialableAddr );
    BOOL ResolveIPAddress( LPSTR pszDialableAddr );
    BOOL ResolveEmailAddress( LPCWSTR pwszDialableAddr,
        PSTR pszUser, LPSTR pszDomain);
    BOOL PlaceCall();
    BOOL HandleConnectMessage( Q931_CONNECT_ASN *pConnectASN );
    void HandleAlertingMessage( Q931_ALERTING_ASN * pAlertingASN );
    void HandleProceedingMessage( Q931_ALERTING_ASN * pProceedingAS );
    BOOL HandleReleaseMessage( Q931_RELEASE_COMPLETE_ASN *pReleaseASN );
    BOOL InitializeIncomingCall( IN Q931_SETUP_ASN* pSetupASN,
        IN DWORD dwCallType, IN WORD wCallRef );
    BOOL SetupCall();
    void SetNonStandardData( H323_UserInformation & UserInfo );
    BOOL SendQ931Message( DWORD dwInvokeID, ULONG_PTR dwParam1,
        ULONG_PTR dwParam2, DWORD dwMessageType, DWORD APDUType );
    BOOL OnReceiveAlerting( Q931MESSAGE* pMessage );
    BOOL OnReceiveProceeding( Q931MESSAGE* pMessage );
    BOOL OnReceiveFacility( Q931MESSAGE* pMessage );
    BOOL OnReceiveRelease( Q931MESSAGE* pMessage );
    BOOL OnReceiveConnect( Q931MESSAGE* pMessage );
    BOOL OnReceiveSetup( Q931MESSAGE* pMessage );
    BOOL EncodeConnectMessage( DWORD dwInvokeID, BYTE **ppEncodedBuf,
        WORD *pdwEncodedLength, DWORD dwAPDUType );
    BOOL EncodeReleaseCompleteMessage( DWORD dwInvokeID, BYTE *pbReason,
        BYTE **ppEncodedBuf, WORD *pdwEncodedLength, DWORD dwAPDUType );
    BOOL EncodeProceedingMessage( DWORD dwInvokeID, BYTE **ppEncodedBuf,
        WORD *pdwEncodedLength, IN DWORD dwAPDUType );
    BOOL EncodeAlertMessage( DWORD dwInvokeID, BYTE **ppEncodedBuf, 
        WORD *pdwEncodedLength, IN DWORD dwAPDUType );
    BOOL EncodeFacilityMessage( IN DWORD dwInvokeID, IN BYTE  bReason,
        IN ASN1octetstring_t* pH245PDU, OUT BYTE **ppEncodedBuf,
        OUT WORD *pdwEncodedLength, IN DWORD dwAPDUType );
    BOOL EncodeSetupMessage( DWORD dwInvokeID, WORD wGoal, WORD wCallType,
        BYTE **ppEncodedBuf, WORD *pdwEncodedLength, IN DWORD dwAPDUType );
    BOOL EncodeMessage( PQ931MESSAGE pMessage, BYTE **pbCodedBuffer,
        DWORD *pdwCodedBufferLength, DWORD dwMessageLength);
    void WriteQ931Fields( PBUFFERDESCR pBuf, PQ931MESSAGE pMessage, 
        DWORD * pdwPDULength );
    BOOL EncodeH450APDU( DWORD dwInvokeID, IN DWORD dwAPDUType,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    void RecvBuffer( BOOL *fDelete );
    void ReadEvent( DWORD cbTransfer );
    BOOL ProcessQ931PDU( CALL_RECV_CONTEXT* pRecvBuf );
    void OnConnectComplete();
    BOOL SendBuffer( BYTE* pbBuffer, DWORD dwLength );
    BOOL AcceptH323Call();
    BOOL GetPeerAddress( H323_ADDR *pAddr);
    BOOL GetHostAddress( H323_ADDR *pAddr );
    BOOL EncodePDU( BINARY_STRING *pUserUserData, BYTE ** ppbCodedBuffer,
        DWORD * pdwCodedBufferLength, DWORD dwMessageType, 
        WCHAR* pszCalledPartyNumber );
    int EncodeASN( void *pStruct, int nPDU, 
        BYTE **ppEncoded, WORD *pcbEncodedSize );
    int EncodeH450ASN( void *pStruct, int nPDU, 
        BYTE **ppEncoded, WORD *pcbEncodedSize );
    BOOL ParseSetupASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_SETUP_ASN *pSetupASN,
        OUT DWORD* pdwH450APDUType );
    BOOL ParseReleaseCompleteASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_RELEASE_COMPLETE_ASN *pReleaseASN,
        DWORD* pdwH450APDUType );
    BOOL ParseConnectASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_CONNECT_ASN *pConnectASN,
        DWORD* pdwH450APDUType );
    BOOL ParseAlertingASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_ALERTING_ASN *pAlertingASN,
        DWORD* pdwH450APDUType );
    BOOL ParseProceedingASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_CALL_PROCEEDING_ASN *pProceedingASN,
        DWORD* pdwH450APDUType );
    BOOL ParseFacilityASN( IN BYTE * pEncodedBuf, IN DWORD dwEncodedLength,
        OUT Q931_FACILITY_ASN * pFacilityASN );
    int DecodeASN( void **ppStruct, int nPDU, 
        BYTE *pEncoded, DWORD cbEncodedSize );
    int InitASNCoder(); 
    int TermASNCoder();
    int InitH450ASNCoder(); 
    int TermH450ASNCoder();
    BOOL SendSetupMessage();
    HRESULT Q931ParseMessage( BYTE *CodedBufferPtr, DWORD CodedBufferLength,
        PQ931MESSAGE Message );
    BOOL HandleSetupMessage( IN Q931MESSAGE* pMessage );


    //GK RAS functions
    BOOL SendDCF( WORD seqNumber );
    BOOL SendARQ( long seqNumber );
    BOOL SendDRQ( IN USHORT usDisengageReason, long seqNumber, 
        BOOL fResendOnExpire );

    
    //supplementary services functions
    void FreeCallForwardData();
    void HandleFacilityMessage( IN DWORD dwInvokeID,
        IN Q931_FACILITY_ASN * pFacilityASN );
    void FreeCallReroutingInfo(void);
    BOOL InitiateCallDiversion( IN PH323_ALIASITEM pwszDivertedToAlias,
        IN DiversionReason  eDiversionMode );
    BOOL EncodeDivertingLeg3APDU(
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeCallReroutingAPDU( 
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeDivertingLeg2APDU(
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeCheckRestrictionAPDU( 
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeDummyReturnResultAPDU( IN DWORD dwInvokeID, IN DWORD dwOpCode,
        IN H4501SupplementaryService *pH450APDU, OUT BYTE**  ppEncodedAPDU,
        OUT DWORD* pdwAPDULen );
    BOOL EncodeReturnErrorAPDU( IN DWORD dwInvokeID,
        IN DWORD dwErrorCode,IN H4501SupplementaryService *pH450APDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeRejectAPDU( IN H4501SupplementaryService* SupplementaryServiceAPDU,
        IN DWORD dwInvokeID, OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL HandleCallRerouting( IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen );
    BOOL HandleDiversionLegInfo3( 
        IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen );
    BOOL HandleDiversionLegInfo2(IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen );
    BOOL HandleDiversionLegInfo1(IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen );
    BOOL HandleCheckRestriction( IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen,
        IN Q931_SETUP_ASN* pSetupASN );
    BOOL HandleReturnResultDummyType( 
        H4501SupplementaryService * pH450APDUStruct );
    BOOL HandleReject( IN H4501SupplementaryService * pH450APDUStruct );
    BOOL HandleReturnError( IN H4501SupplementaryService * pH450APDUStruct );
    BOOL HandleH450APDU( IN PH323_UU_PDU_h4501SupplementaryService pH450APDU,
        IN DWORD* pdwH450APDUType, DWORD* pdwInvokeID, 
        IN Q931_SETUP_ASN* pSetupASN );
    int DecodeH450ASN( OUT void ** ppStruct, IN int nPDU, 
        IN BYTE * pEncoded, IN DWORD cbEncodedSize );
    BOOL ResolveToIPAddress( IN WCHAR* pwszAddr, IN SOCKADDR_IN* psaAddr );
    void DropSupplementaryServicesCalls();
    BOOL IsValidInvokeID( DWORD dwInvokeId );
    void OnCallReroutingReceive( IN DWORD dwInvokeID );
    BOOL StartTimerForCallDiversionOnNA( IN PH323_ALIASITEM pwszDivertedToAlias );
    BOOL HandleCTIdentifyReturnResult( IN BYTE * pEncodeArg, 
        IN DWORD dwEncodedArgLen );
    BOOL HandleCTInitiate( IN BYTE * pEncodeArg, IN DWORD dwEncodedArgLen );
    BOOL HandleCTSetup( IN BYTE * pEncodeArg, IN DWORD dwEncodedArgLen );
    BOOL EncodeH450APDUNoArgument( IN  DWORD   dwOpcode, 
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD*  pdwAPDULen );
    BOOL EncodeCTInitiateAPDU( OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeCTSetupAPDU( OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeCTIdentifyReturnResult( ServiceApdus_rosApdus *pROSAPDU );
    BOOL HandleCTIdentify( IN DWORD dwInvokeID );
    BOOL EncodeFastStartProposal( PH323_FASTSTART pFastStart,
        BYTE** ppEncodedBuf, WORD* pwEncodedLength );
    BOOL EnableCallForwarding();
    BOOL EncodeDummyResult( OUT ServiceApdus_rosApdus *pROSAPDU );
    void FreeCallReroutingArg( CallReroutingArgument* pCallReroutingArg );
    BOOL HandleCallDiversionFacility( PH323_ADDR pAlternateAddress );
    BOOL HandleCallDiversionFacility( PH323_ALIASNAMES pAliasList );
    BOOL HandleTransferFacility( PH323_ADDR pAlternateAddress );
    BOOL HandleTransferFacility( PH323_ALIASNAMES pAliasList );


public:

    BOOLEAN                 m_fMonitoringDigits;   // listening for dtmf flag    
    HTAPICALL               m_htCall;              // tapi call handle
    CALL_RECV_CONTEXT       m_RecvBuf;

    BOOL IsEqualConferenceID( 
                        GUID* pConferenceID 
                        )
    {
        return IsEqualGUID (m_ConferenceID, *pConferenceID);
    }

    INT GetCallIndex (void) const { return MakeCallIndex (m_hdCall); }

    void SetAppSpecific( 
            DWORD dwAppSpecific
            )
    {
        m_dwAppSpecific = dwAppSpecific;
        PostLineEvent( LINE_CALLINFO, LINECALLINFOSTATE_APPSPECIFIC, 0, 0 );
    }

    BOOL SetCallData( LPVOID lpCallData, DWORD dwSize );

    void SetCallDiversionState(     
        IN  SUPP_CALLSTATE dwCallDiversionState
        )
    {
        m_dwCallDiversionState = dwCallDiversionState;
    }

    SUPP_CALLSTATE GetCallDiversionState(void)
    {
        return m_dwCallDiversionState;
    }

    void SetAddressType( DWORD dwAddressType )
    {
        m_dwAddressType = dwAddressType;
    }
    
    inline BOOL IsCallOnHold()
    {
        return ( m_dwCallState == LINECALLSTATE_ONHOLD );
    }

    inline BOOL IsCallOnLocalHold()
    {
        return ((m_dwCallState == LINECALLSTATE_ONHOLD) && 
                (m_dwFlags & TSPI_CALL_LOCAL_HOLD) );
    }

    void SetCallState( DWORD dwCallState )
    {
        m_dwCallState = dwCallState;
    }

    void Lock()
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 call:%p waiting on lock.", this ));
        EnterCriticalSection( &m_CriticalSection );
                
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 call:%p locked.", this ));
    }

    PWSTR GetDialableAddress()
    {
        _ASSERTE( m_dwOrigin == LINECALLORIGIN_OUTBOUND );
        _ASSERTE( m_pCalleeAliasNames );
        return m_pCalleeAliasNames->pItems[0].pData;
    }

    PH323_ADDR GetPeerH245Addr()
    {
        return &m_peerH245Addr;
    }

    PH323_FASTSTART GetPeerFastStart()
    {
        return m_pPeerFastStart;
    }

    WCHAR* GetTransferedToAddress()
    {
        return m_pTransferedToAlias->pItems[0].pData;
    }
    void Unlock()
    {
        LeaveCriticalSection(&m_CriticalSection );
                
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 call:%p unlocked.", this ));
    }
    
    //!!must be always called in a lock
    BOOL IsCallShutdown()
    {
        return (m_dwFlags & CALLOBJECT_SHUTDOWN);
    }

    HDRVCALL GetCallHandle()
    {
        return m_hdCall;
    }

    WORD GetARQSeqNumber()
    {
        return m_wARQSeqNum;
    }

    WORD GetDRQSeqNumber()
    {
        return m_wDRQSeqNum;
    }

    WORD GetCallRef()
    {
        return m_wCallReference;
    }

    DWORD GetCallState()
    {
        return m_dwCallState;
    }

    DWORD GetStateMachine()
    {
        return m_dwStateMachine;
    }

    //!!must be always called in a lock
    void SetCallType( DWORD dwCallType )
    {
        m_dwCallType |= dwCallType;
    }

    //!!must be always called in a lock
    BOOL SetCalleeAlias(
                        IN WCHAR* pwszDialableAddr,
                        IN WORD wType
                       )
    {
        return AddAliasItem( m_pCalleeAliasNames, pwszDialableAddr, wType );
    }

    BOOL SetCallerAlias(
                        IN WCHAR* pwszDialableAddr,
                        IN WORD wType
                       )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

        BOOL    retVal = AddAliasItem( m_pCallerAliasNames, pwszDialableAddr, wType );

        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

        return retVal;
    }

    void InitializeRecvBuf();
    CH323Call();
    ~CH323Call();

    BOOL HandleProceedWithAnswer( IN PTspMspMessage  pMessage );
    void CompleteTransfer( PH323_CALL pConsultCall );
    BOOL AddU2U( DWORD dwDirection, DWORD dwDataSize, PBYTE pData );
    LONG SetDivertedToAlias( WCHAR* pwszDivertedToAddr, WORD wAliasType );
    BOOL ResolveAddress( LPCWSTR    pwszDialableAddr );
    PH323_CONFERENCE CreateConference( GUID* pConferenceId );
    BOOL DropCall( DWORD dwDisconnectMode );
    LONG CopyCallInfo( LPLINECALLINFO  pCallInfo );
    void CopyCallStatus( LPLINECALLSTATUS pCallStatus );
    BOOL ChangeCallState( DWORD dwCallState, DWORD dwCallStateMode );
    void AcceptCall();
    BOOL HandleMSPMessage( PTspMspMessage  pMessage, HDRVMSPLINE hdMSPLine, 
        HTAPIMSPLINE htMSPLine );
    void SendMSPMessage( IN TspMspMessageType messageType, IN BYTE* pbEncodedBuf,
        IN DWORD dwLength, IN HDRVCALL hReplacementCall );
    void SendMSPStartH245( PH323_ADDR pPeerH245Addr, 
        PH323_FASTSTART pPeerFastStart );
    BOOL HandleReadyToInitiate( PTspMspMessage  pMessage );
    void WriteComplete( BOOL* fDelete );
    BOOL HandleReadyToAnswer( PTspMspMessage  pMessage );
    void ReleaseU2U();
    void SendU2U( BYTE*  pUserUserInfo, DWORD  dwSize );
    void OnRequestInProgress( IN RequestInProgress* RIP );
    BOOL QueueTAPICallRequest( IN DWORD EventID, IN PVOID pBuf );
    void SetNewCallInfo( HANDLE hConnWait, HANDLE hWSAEvent, DWORD dwState );
    void SetQ931CallState( DWORD dwState );
    BOOL InitializeQ931( SOCKET callSocket );
    void HandleTransportEvent();
    void SetupSentTimerExpired();
    BOOL PostReadBuffer();
    void CloseCall( IN DWORD dwDisconnectMOde );
    BOOL ValidateCallParams( LPLINECALLPARAMS pCallParams,
        LPCWSTR pwszDialableAddr, PDWORD pdwStatus );
    BOOL Initialize( HTAPICALL htCall, DWORD dwOrigin, DWORD dwCallType );
    void Shutdown( BOOL* fDelete );
    
    static void NTAPI SetupSentTimerCallback( PVOID dwParam1, BOOLEAN bTimer );

    //GK RAS functions
    void OnDisengageReject(IN DisengageReject* DRJ);
    void OnDisengageConfirm(IN DisengageConfirm* DCF);
    void OnAdmissionConfirm( IN AdmissionConfirm * ACF );
    void OnAdmissionReject( IN AdmissionReject *ARJ );
    static void NTAPI DRQExpiredCallback( PVOID dwParam1, BOOLEAN bTimer );
    static void NTAPI ARQExpiredCallback( PVOID dwParam1, BOOLEAN bTimer );
    static void NTAPI CallEstablishmentExpiredCallback( PVOID dwParam1, 
        BOOLEAN bTimer );
    void ARQExpired( WORD seqNumber );
    void DRQExpired( WORD seqNumber );
    void OnDisengageRequest( DisengageRequest * DRQ );
   

    //supplementary services functions
    void Forward( DWORD event, PVOID dwParam1 );
    LONG ValidateForwardParams( IN  LPLINEFORWARDLIST lpLineForwardList,
         OUT PVOID* ppForwardParams, OUT DWORD* pEvent );

    static void NTAPI CheckRestrictionTimerCallback( IN PVOID dwParam1,
        IN BOOLEAN bTimer );
    static void NTAPI CallReroutingTimerCallback( IN PVOID dwParam1,
        IN BOOLEAN bTimer );
    static void NTAPI CTIdentifyExpiredCallback( IN PVOID   dwParam1,
        IN BOOLEAN bTimer );
    static void NTAPI CTInitiateExpiredCallback( IN PVOID   dwParam1,
        IN BOOLEAN bTimer );
    
    void SetDivertedCallInfo( 
        HDRVCALL            hdCall,
        CALLREROUTINGINFO*  pCallReroutingInfo,
        SUPP_CALLSTATE      dwCallDiversionState,
        HDRVMSPLINE         hdMSPLine,
        PH323_ALIASNAMES    pCallerAliasNames,
        HTAPIMSPLINE        htMSPLine,
        PH323_FASTSTART     pFastStart,
        HDRVCALL            hdRelatedCall,
        DWORD               dwCallType,
        DWORD               dwAppSpecific,
        PH323_OCTETSTRING   pCallData
    );


    PH323_CALL CreateNewDivertedCall( IN PH323_ALIASNAMES pwszCalleeAddr );
    void TransferInfoToDivertedCall( IN PH323_CALL pDivertedCall );
    BOOL TransferInfoToTransferedCall( IN PH323_CALL pTransferedCall );
    BOOL SetTransferedCallInfo( HDRVCALL hdCall, 
        PH323_ALIASNAMES pCallerAliasNames, BYTE * pCTCallIdentity );
    void TransferInfoToReplacementCall( PH323_CALL pReplacementCall );
    void DialCall();
    void MakeCall();
    void DropUserInitiated( IN DWORD dwDisconnectMode );

    void CallDivertOnNoAnswer();
    static void NTAPI CallDivertOnNACallback( IN PVOID   dwParam1, 
        IN BOOLEAN bTimer );

    void SetReplacementCallInfo(
        HDRVCALL hdCall,
        HDRVMSPLINE hdMSPLine,
        HTAPICALL htCall,
        HTAPIMSPLINE htMSPLine,
        DWORD dwAppSpecific,
        PH323_OCTETSTRING pCallData
        );

    BOOL SendCTInitiateMessagee( IN CTIdentifyRes * pCTIdentifyRes );
    LONG InitiateBlindTransfer( IN LPCWSTR lpszDestAddress );
    void CTIdentifyExpired();
    void CTIdentifyRRExpired();
    static void NTAPI CTIdentifyRRExpiredCallback( IN PVOID   dwParam1, 
        IN BOOLEAN bTimer );
    void CTInitiateExpired();
    BOOL InitiateCallReplacement( PH323_FASTSTART pFastStart, 
        PH323_ADDR pH245Addr );
    void Hold();
    void UnHold();
    HRESULT GetCallInfo( OUT GUID* ReturnCallID, OUT GUID *ReturnConferenceID );

    void DecrementIoRefCount( BOOL * pfDelete );
    void StopCTIdentifyRRTimer( HDRVCALL hdRelatedCall );
    void PostLineEvent( IN DWORD MessageID, IN DWORD_PTR Parameter1,
        IN DWORD_PTR Parameter2, IN DWORD_PTR Parameter3 );

    void OnReadComplete( IN DWORD dwStatus, 
        IN CALL_RECV_CONTEXT *pRecvContext );
    void OnWriteComplete( IN DWORD dwStatus,
        IN CALL_SEND_CONTEXT * pSendContext );
    static void  NTAPI IoCompletionCallback(
    IN  DWORD           dwStatus,
    IN  DWORD           dwBytesTransferred,
    IN  OVERLAPPED *    pOverlapped
    );


};

class H323_CONFERENCE
{
private:
    ULONG_PTR   m_hdConference;    
    PH323_CALL m_pCall;

public:

    H323_CONFERENCE( PH323_CALL pCall )
    {
        m_hdConference = (ULONG_PTR) this;
        m_pCall = pCall;
    }
};



void FreeCallForwardParams( IN PCALLFORWARDPARAMS pCallForwardParams );
void FreeForwardAddress( IN LPFORWARDADDRESS pForwardAddress );

typedef TSPTable<PH323_CALL>   H323_CALL_TABLE;
typedef CTSPArray<H323_CONFERENCE*>   H323_CONF_TABLE;

#define IsTransferredCall( dwCallType )  ( (dwCallType & CALLTYPE_TRANSFEREDSRC) || (dwCallType & CALLTYPE_TRANSFERED_PRIMARY) )

//                                                                           
// TSPI procedures                                                           
//                                                                           


LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID     dwRequestID,  
    HDRVCALL          hdCall,
    LPCSTR            pUserUserInfo,
    DWORD             dwSize
    );
LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL hdCall
    );
LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall,
    LPCSTR        pUserUserInfo,
    DWORD         dwSize
    );
LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL hdCall,
    LPDWORD  pdwAddressID
    );

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  pCallInfo
    );

LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL         hdCall,
    LPLINECALLSTATUS pCallStatus
    );

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          phdCall,
    LPCWSTR             pwszDialableAddr,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const pCallParams
    );
LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              pUserUserInfo,
    DWORD               dwSize
    );
LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL hdCall,
    DWORD    dwDigitModes
    );

LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL hdCall,
    DWORD    dwEndToEndID,
    DWORD    dwDigitMode,
    LPCWSTR  pwszDigits,
    DWORD    dwDuration
    );

BOOL IsPhoneNumber( char * szAddr );

// called by Q.931 listener when a new connection is received
void    CallProcessIncomingCall (
    IN  SOCKET          Socket,
    IN  SOCKADDR_IN *   LocalAddress,
    IN  SOCKADDR_IN *   RemoteAddress);


void NTAPI Q931TransportEventHandler (
    IN  PVOID   Parameter,
    IN  BOOLEAN TimerFired);

BOOL
IsValidE164String( 
                  IN WCHAR* wszDigits
                 );

DWORD
ValidateE164Address(
                   LPCWSTR pwszDialableAddr,
                   WCHAR*  wszAddr
                   );

BOOL
QueueSuppServiceWorkItem(
    IN  DWORD   EventID,
    IN  HDRVCALL    hdCall,
    IN  ULONG_PTR   dwParam1
    );
#if 0
BOOL
CH323Call::QueueTAPICallRequest(
    IN  DWORD   EventID,
    IN  PVOID   pBuf );
#endif

DWORD
ProcessSuppServiceWorkItemFre(
	IN PVOID ContextParameter
    );

DWORD
SendMSPMessageOnRelatedCallFre(
    IN PVOID ContextParameter
    );

DWORD 
ProcessTAPICallRequestFre(
    IN  PVOID   ContextParameter
    );

#endif // _INC_CALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\confcall.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    confcall.cpp

Abstract:

    TAPI Service Provider functions related to conference calls.

        TSPI_lineAddToConference        
        TSPI_lineCompleteTransfer
        TSPI_linePrepareAddToConference
        TSPI_lineRemoveFromConference
        TSPI_lineSetupConference
        TSPI_lineSetupTransfer
        TSPI_lineDial
        TSPI_lineCompleteTransfer
        TSPI_lineForward
        TSPI_lineSetStatusMessage
        TSPI_lineRedirect
        TSPI_lineHold
        TSPI_lineUnhold

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 

//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "q931obj.h"
#include "ras.h"
#include "call.h"

#define CALL_DIVERTNA_NUM_RINGS 8000
extern DWORD g_dwTSPIVersion;


//Queues a supplementary service work item to the thread pool
BOOL
QueueSuppServiceWorkItem(
	IN	DWORD	EventID,
	IN	HDRVCALL	hdCall,
	IN	ULONG_PTR	dwParam1
    )
{
	SUPP_REQUEST_DATA *	pCallRequestData = new SUPP_REQUEST_DATA;
	BOOL fResult = TRUE;

    if( pCallRequestData != NULL )
    {
        pCallRequestData -> EventID = EventID;
        pCallRequestData -> hdCall = hdCall;
        pCallRequestData -> dwParam1 = dwParam1;

        if( !QueueUserWorkItem( ProcessSuppServiceWorkItem,
                pCallRequestData, WT_EXECUTEDEFAULT) )
        {
	        delete pCallRequestData;
	        fResult = FALSE;
        }
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}


#if   DBG

DWORD
ProcessSuppServiceWorkItem(
	IN PVOID ContextParameter
    )
{
    __try
    {
        return ProcessSuppServiceWorkItemFre( ContextParameter );
    }
    __except( 1 )
    {
        SUPP_REQUEST_DATA*  pRequestData = (SUPP_REQUEST_DATA*)ContextParameter;
        
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event threw exception: %p, %p.", 
            EventIDToString(pRequestData -> EventID),
            pRequestData -> hdCall,
            pRequestData -> dwParam1 ));
        
        _ASSERTE( FALSE );

        return 0;
    }
}

#endif


DWORD
ProcessSuppServiceWorkItemFre(
	IN PVOID ContextParameter
    )
{
    _ASSERTE( ContextParameter );

    PH323_CALL          pCall = NULL;
    SUPP_REQUEST_DATA*  pRequestData = (SUPP_REQUEST_DATA*)ContextParameter;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event recvd.",
        EventIDToString(pRequestData -> EventID) ));
    
    switch( pRequestData -> EventID )
    {
    case H450_PLACE_DIVERTEDCALL:

        g_pH323Line -> PlaceDivertedCall( pRequestData->hdCall, 
            pRequestData->pAliasNames );
        
        break;

    case TSPI_DIAL_TRNASFEREDCALL:
        
        g_pH323Line -> PlaceTransferedCall( pRequestData->hdCall,
            pRequestData->pAliasNames );
        
        break;

    case SWAP_REPLACEMENT_CALL:
        
        g_pH323Line -> SwapReplacementCall( pRequestData->hdCall,
            pRequestData->hdReplacementCall, TRUE );
        break;

    case DROP_PRIMARY_CALL:

        g_pH323Line -> SwapReplacementCall( pRequestData->hdCall,
            pRequestData->hdReplacementCall, FALSE );
        break;
    
    case STOP_CTIDENTIFYRR_TIMER:

        pCall=g_pH323Line -> FindH323CallAndLock( pRequestData->hdCall );
        if( pCall != NULL )
        {
            pCall -> StopCTIdentifyRRTimer( pRequestData->hdReplacementCall );
            pCall -> Unlock();
        }
        else
        {
            //set the m_hdRelatedCall of dwParam1 to NULL
        }
        break;

    case SEND_CTINITIATE_MESSAGE:

        pCall=g_pH323Line -> FindH323CallAndLock(pRequestData->hdCall);
        if( pCall != NULL )
        {
            pCall -> SendCTInitiateMessagee( pRequestData->pCTIdentifyRes );
            pCall -> Unlock();
        }
        break;
    }

    delete ContextParameter;

    return EXIT_SUCCESS;
}


//!!must be always called in a lock
void
CH323Call::TransferInfoToDivertedCall(
    IN PH323_CALL pDivertedCall
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TransferInfoToDivertedCall entered." ));
        
    pDivertedCall -> SetDivertedCallInfo(
        m_hdCall, 
        m_pCallReroutingInfo,
        m_dwCallDiversionState, 
        m_hdMSPLine, 
        m_pCallerAliasNames, 
        m_htMSPLine, 
        m_pFastStart, 
        m_hdRelatedCall, 
        m_dwCallType,
        m_dwAppSpecific,
        &m_CallData );

    //reset the reference to this struct
    m_pCallReroutingInfo = NULL;
    m_pCallerAliasNames = NULL;
    m_dwCallDiversionState = H4503_CALLSTATE_IDLE;
    m_dwCallType = CALLTYPE_NORMAL;
    m_dwCallState = LINECALLSTATE_IDLE;
    m_pFastStart = NULL;

    ZeroMemory( (PVOID)&m_CallData, sizeof(H323_OCTETSTRING) );
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TransferInfoToDivertedCall exited." ));
}


//!!always called in a lock
BOOL
CH323Call::TransferInfoToTransferedCall(
    IN PH323_CALL pTransferedCall
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TransferInfoToTransferedCall entered." ));

    if( !pTransferedCall -> SetTransferedCallInfo( 
        m_hdCall, m_pCallerAliasNames, m_pCTCallIdentity ) )
    {
        pTransferedCall -> Unlock();
        return FALSE;
    }

    m_hdRelatedCall = pTransferedCall -> GetCallHandle();

    H323DBG(( DEBUG_LEVEL_TRACE, "TransferInfoToTransferedCall exited." ));
    return TRUE;
}


void
CH323Call::SetDivertedCallInfo( 
    HDRVCALL            hdCall,
    CALLREROUTINGINFO*  pCallReroutingInfo,
    SUPP_CALLSTATE      dwCallDiversionState,
    HDRVMSPLINE         hdMSPLine,
    PH323_ALIASNAMES    pCallerAliasNames,
    HTAPIMSPLINE        htMSPLine,
    PH323_FASTSTART     pFastStart,
    HDRVCALL            hdRelatedCall,
    DWORD               dwCallType,
    DWORD               dwAppSpecific,
    PH323_OCTETSTRING   pCallData
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SetDivertedCallInfo entered:%p.", this ));
    Lock();

    m_hdCall = hdCall;
    m_pCallReroutingInfo = pCallReroutingInfo;
    m_dwCallDiversionState = dwCallDiversionState;
    m_hdMSPLine = hdMSPLine;
    m_htMSPLine = htMSPLine;
    
    FreeAliasNames( m_pCallerAliasNames );
    
    m_pCallerAliasNames = pCallerAliasNames;

    H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

    m_dwCallState =  LINECALLSTATE_DIALING;
    m_pFastStart = pFastStart;
    m_CallData = *pCallData;
    m_dwAppSpecific = dwAppSpecific;

    //If the original call had any call type apart from being a diverted call
    //copy it.
    if( (dwCallType & CALLTYPE_TRANSFEREDSRC) ||
        (dwCallType & CALLTYPE_DIVERTEDTRANSFERED) )
    {
        m_dwCallType |= CALLTYPE_DIVERTEDTRANSFERED;
        m_hdRelatedCall = hdRelatedCall;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "SetDivertedCallInfo exited:%p.", this ));
}


//!!must be always called in a lock
BOOL
CH323Call::SetTransferedCallInfo(
                               HDRVCALL hdCall,
                               PH323_ALIASNAMES pCallerAliasNames,
                               BYTE * pCTCallIdentity
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SetTransferedCallInfo entered:%p.", this ));

    m_hdRelatedCall = hdCall;

    m_pCallerAliasNames = NULL;

    if( (pCallerAliasNames != NULL) && (pCallerAliasNames->wCount != 0) )
    {
        m_pCallerAliasNames = new H323_ALIASNAMES;
        if( m_pCallerAliasNames == NULL )
        {
            return FALSE;
        }
        ZeroMemory( (PVOID)m_pCallerAliasNames, sizeof(H323_ALIASNAMES) );

        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
        if( !AddAliasItem( m_pCallerAliasNames,
            pCallerAliasNames->pItems[0].pData,
            pCallerAliasNames->pItems[0].wType ) )
        {
            return FALSE;
        }
        
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }

    CopyMemory( (PVOID)m_pCTCallIdentity, pCTCallIdentity, 
        sizeof(m_pCTCallIdentity) );
    
    m_dwCallState =  LINECALLSTATE_DIALING;   
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SetTransferedCallInfo exited:%p.", this ));
    return TRUE;
}


void
CH323Line::PlaceDivertedCall( 
    IN HDRVCALL hdCall,
    IN PH323_ALIASNAMES divertedToAlias
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "PlaceDivertedCall entered:%p.", this ));

    int         iIndex = MakeCallIndex( hdCall );
    int         iDivertedCallIndex;
    PH323_CALL  pCall;
    BOOL        fDelete = FALSE;
    PH323_CALL  pDivertedCall = NULL;

    Lock();

    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    if( (pCall=m_H323CallTable[iIndex]) != NULL )
    {
        pCall -> Lock();

        if( pCall->GetCallHandle() == hdCall )
        {
                
            pDivertedCall = pCall-> CreateNewDivertedCall( divertedToAlias );
        
            if( pDivertedCall == NULL )
            {
                pCall -> Unlock();
                UnlockCallTable();
                pCall->CloseCall( 0 );
                Unlock();
                return;
            }

            //remove the diverted call from the table
            iDivertedCallIndex = pDivertedCall -> GetCallIndex();

            m_H323CallTable[iDivertedCallIndex] = NULL;

            //transfer the required information to the diverted call.
            //put the original call in IDLE mode
            pCall -> TransferInfoToDivertedCall( pDivertedCall );

            //This DropCall is supposed to send only the DRQ if required
            pCall->DropCall( 0 );

            //close the original call
            pCall -> Shutdown( &fDelete );

            H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx closed.", pCall ));
            pCall -> Unlock();

            //release the original call object
            if( fDelete == TRUE )
            {
                H323DBG(( DEBUG_LEVEL_VERBOSE, "call delete:0x%08lx.", pCall ));
                delete pCall;
            }

            //place the diverted call in the place of the original call
            m_H323CallTable[iIndex] = pDivertedCall;
        }
        else
        {
            pCall -> Unlock();
        }
    }
    
    UnlockCallTable();

    //dial the diverted call
    if( pDivertedCall )
    {
        pDivertedCall -> DialCall();
    }
    
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "PlaceDivertedCall exited:%p.", this ));
}


//!!always called in a lock
PH323_CALL
CH323Call::CreateNewDivertedCall(
    IN PH323_ALIASNAMES pwszCalleeAlias
    )
{
    PH323_CONFERENCE pConf = NULL;
    BOOL fDelete = FALSE;
    PH323_CALL pCall = new CH323Call();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CreateNewDivertedCall entered:%p.", this ));

    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate diverted call." ));

        return NULL;
    }

    // save tapi handle and specify outgoing call direction
    if( !pCall -> Initialize( m_htCall, LINECALLORIGIN_OUTBOUND,
        CALLTYPE_DIVERTEDSRC ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call." ));

        goto cleanup;
    }

    // bind outgoing call
    pConf = pCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not create conference." ));

        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        goto cleanup;
    }

    if( pwszCalleeAlias->pItems[0].wType == e164_chosen )
    {
        pCall->SetAddressType( e164_chosen );
    }

    if (!RasIsRegistered())
    {
        if( !pCall->ResolveAddress( pwszCalleeAlias->pItems[0].pData ) )
        {
            goto cleanup;
        }
    }

    if( !pCall->SetCalleeAlias( pwszCalleeAlias->pItems[0].pData, 
        pwszCalleeAlias->pItems[0].wType ) )
    {
        goto cleanup;
    }
    
    //send the informarion to the user that call has been diverted
    PostLineEvent(
        LINE_CALLINFO,
        LINECALLINFOSTATE_REDIRECTIONID,
        0, 0 );

    H323DBG(( DEBUG_LEVEL_TRACE, "diverted call created:%p.", pCall ));
    H323DBG(( DEBUG_LEVEL_TRACE, "CreateNewDivertedCall exited.\n:%p", this ));
    return pCall;

cleanup:

    if( pCall != NULL )
    {
        pCall -> Shutdown( &fDelete );
        delete pCall;
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
    }

    return NULL;
}


//!!always called in a lock
void
CH323Call::Hold()
{
    //1.Send MSP call hold message 
    //2.Send hold H450 APDU
    if( m_dwCallState == LINECALLSTATE_ONHOLD )
    {
        return;
    }

    if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
        HOLDNOTIFIC_OPCODE | H450_INVOKE ) )
    {
        CloseCall( 0 );
        return;
    }
        
    SendMSPMessage( SP_MSG_Hold, 0, 1, NULL );
    
    //Call put on hold by local endpoint
    m_dwFlags |= TSPI_CALL_LOCAL_HOLD;
    
    ChangeCallState( LINECALLSTATE_ONHOLD, 0 );
    return;
}


//!!always called in a lock
void
CH323Call::UnHold()
{
    //1.Send MSP call unhold message 
    //2.Send unhold H450 APDU
    if( (m_dwCallState == LINECALLSTATE_ONHOLD) &&
        (m_dwFlags & TSPI_CALL_LOCAL_HOLD) )
    {
        if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
            RETRIEVENOTIFIC_OPCODE | H450_INVOKE ) )
        {
            CloseCall( 0 );
            return;
        }
    
        SendMSPMessage( SP_MSG_Hold, 0, 0, NULL );
        m_dwFlags &= (~TSPI_CALL_LOCAL_HOLD);
        ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
    }

    return;
}


//!!always called in a lock
void
CH323Call::OnCallReroutingReceive(
                                    IN DWORD dwInvokeID
                                 )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnCallReroutingReceive entered:%p.", this ));

    if( (m_dwOrigin != LINECALLORIGIN_OUTBOUND) ||
        ( (m_dwStateMachine != Q931_SETUP_SENT) &&
          (m_dwStateMachine != Q931_PROCEED_RECVD) &&
          (m_dwStateMachine != Q931_ALERT_RECVD)
        )
      )
    {
        goto error;
    }
    
    //If setupsent timer is still alive stop it.
    if( m_hSetupSentTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
        m_hSetupSentTimer = NULL;
    }

    if( dwInvokeID != NO_INVOKEID )
    {
        if(!SendQ931Message( dwInvokeID,
                                 0,
                                 0,
                                 FACILITYMESSAGETYPE,
                                 CALLREROUTING_OPCODE | H450_RETURNRESULT ))
        {
            //goto error;
        }
    }
    
    m_fCallInTrnasition = TRUE;
    if( !SendQ931Message( NO_INVOKEID,
                         0,
                         0,
                         RELEASECOMPLMESSAGETYPE,
                         NO_H450_APDU) )
    {
        //goto error;
    }

    if( !QueueSuppServiceWorkItem( H450_PLACE_DIVERTEDCALL, m_hdCall,
        (ULONG_PTR)m_pCallReroutingInfo->divertedToNrAlias ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post place diverted event." ));
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnCallReroutingReceive exited:%p.", this ));
    return;

error:
    CloseCall( 0 );
}


//!!always called in a lock
BOOL
CH323Call::IsValidInvokeID(
    IN DWORD dwInvokeId
    )
{
    if( m_dwCallType != CALLTYPE_NORMAL )
    {
        if( m_dwInvokeID == dwInvokeId )
        {
            return TRUE;
        }
        
        H323DBG(( DEBUG_LEVEL_ERROR, "invoke id not matched:%d:%d.", 
            m_dwInvokeID, dwInvokeId ));
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "IsValidinvokeID called on wrong call." ));
    return FALSE;
}


BOOL
CH323Call::StartTimerForCallDiversionOnNA(
    IN PH323_ALIASITEM pwszDivertedToAlias
    )
{
    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;
        
        if( m_pCallReroutingInfo == NULL )
        {
            goto cleanup;
        }
        
        ZeroMemory( m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }

    m_pCallReroutingInfo->divertedToNrAlias = new H323_ALIASNAMES;
    
    if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
    {
        goto cleanup;
    }

    ZeroMemory( m_pCallReroutingInfo->divertedToNrAlias, 
        sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( m_pCallReroutingInfo->divertedToNrAlias, 
        (BYTE*)pwszDivertedToAlias->pData, 
        sizeof(WCHAR) * (wcslen(pwszDivertedToAlias->pData) +1),
        pwszDivertedToAlias->wType ) )
    {
        goto cleanup;
    }

    if( !CreateTimerQueueTimer(
		    &m_hCallDivertOnNATimer,
		    H323TimerQueue,
		    CH323Call::CallDivertOnNACallback,
		    (PVOID)m_hdCall,
		    (g_pH323Line->m_dwNumRingsNoAnswer * 1000), 0,
		    WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE) )
    {
        goto cleanup;
    }

    return TRUE;

cleanup:

    FreeCallReroutingInfo();
    return FALSE;
}


LONG 
CH323Call::SetDivertedToAlias( 
    WCHAR* pwszDivertedToAddr,
    WORD   wAliasType
    )
{
    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;
        
        if( m_pCallReroutingInfo == NULL )
        {
            return LINEERR_NOMEM;
        }
        
        ZeroMemory( m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }

    m_pCallReroutingInfo->divertedToNrAlias = new H323_ALIASNAMES;
    
    if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
    {
        delete m_pCallReroutingInfo;
        
        m_pCallReroutingInfo = NULL;
        return LINEERR_NOMEM;
    }
    
    ZeroMemory( m_pCallReroutingInfo->divertedToNrAlias, sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( m_pCallReroutingInfo->divertedToNrAlias, 
        (BYTE*)pwszDivertedToAddr, 
        sizeof(WCHAR) * (wcslen(pwszDivertedToAddr) +1),
        wAliasType ) )
    {
        delete m_pCallReroutingInfo->divertedToNrAlias;
        delete m_pCallReroutingInfo;
        m_pCallReroutingInfo = NULL;
    
        return LINEERR_NOMEM;
    }

    return NOERROR;
}


//!!always called in a lock
//this function is called to replace a TRANSFERD_PRIMARY call with a connected
//TRANSFEREDSRC call or to preplace a TRANSFERED2_PRIMARY call with a connected
//TRANSFEREDDEST call
BOOL
CH323Call::InitiateCallReplacement(
    PH323_FASTSTART  pFastStart,
    PH323_ADDR       pH245Addr
    )
{
    H323DBG(( DEBUG_LEVEL_ERROR, "InitiateCallReplacement entered:%p.",this ));

    SendMSPStartH245( pH245Addr, pFastStart );
    SendMSPMessage( SP_MSG_ConnectComplete, 0, 0, m_hdRelatedCall );

    m_fCallInTrnasition = TRUE;

    if( (m_dwRASCallState == RASCALL_STATE_REGISTERED ) ||
        (m_dwRASCallState == RASCALL_STATE_ARQSENT ) )
    {
        //disengage from the GK
        SendDRQ( forcedDrop_chosen, NOT_RESEND_SEQ_NUM, FALSE );
    }

    if( !SendQ931Message( m_dwInvokeID,
         0,
         0,
         RELEASECOMPLMESSAGETYPE,
         CTINITIATE_OPCODE | H450_RETURNRESULT) )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "InitiateCallReplacement exited:%p.",this ));
    return TRUE;

cleanup:
    CloseCall( 0 );
    return FALSE;
}


//this function is called to replace a TRANSFERD_PRIMARY call with TRANSFEREDSRC
//call or to replace a TRANSFERD2_CONSULT call with a TRANSFEREDDEST call
void
CH323Line::SwapReplacementCall(
    HDRVCALL hdReplacementCall,
    HDRVCALL hdPrimaryCall,
    BOOL     fChangeCallSate
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SwapReplacementCall entered:%p.", this ));

    int         iReplacementCallIndex = (int)LOWORD(hdReplacementCall);
    int         iPrimaryCallIndex = (int)LOWORD(hdPrimaryCall);
    PH323_CALL  pReplacementCall;
    BOOL        fDelete = FALSE;
    PH323_CALL  pPrimaryCall;

    Lock();
    LockCallTable();
    
    //lock the replacement call before primary call to avoid deadlock
    if( (pReplacementCall=m_H323CallTable[iReplacementCallIndex]) != NULL )
    {
        pReplacementCall -> Lock();

        if( pReplacementCall -> GetCallHandle() == hdReplacementCall )
        {
            if( (pPrimaryCall=m_H323CallTable[iPrimaryCallIndex]) != NULL )
            {
                pPrimaryCall -> Lock();

                if( pPrimaryCall -> GetCallHandle() == hdPrimaryCall )
                {
                    pPrimaryCall -> InitiateCallReplacement(
                        pReplacementCall->GetPeerFastStart(),
                        pReplacementCall->GetPeerH245Addr() );

                    //remove the replacement call from the table
                    m_H323CallTable[iReplacementCallIndex] = NULL;

                    //Transfer the required information to the replacement call.
                    //put the primary call in IDLE mode
                    pPrimaryCall -> TransferInfoToReplacementCall( pReplacementCall );

                    //close the original call
                    pPrimaryCall -> Shutdown( &fDelete );

                    H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx closed.", 
                        pPrimaryCall ));
                    pPrimaryCall -> Unlock();

                    //release the primary call object
                    if( fDelete == TRUE )
                    {
                        H323DBG(( DEBUG_LEVEL_VERBOSE, "call delete:0x%08lx.", 
                            pPrimaryCall ));
                        delete pPrimaryCall;
                    }

                    //Place the replacement call in the place of primary call.
                    m_H323CallTable[iPrimaryCallIndex] = pReplacementCall;
                }
                else
                {
                    pPrimaryCall -> Unlock();
                }
            }
            else
            {
                pReplacementCall-> CloseCall( 0 );
            }

            //inform TAPI that the transfered call is in connected state
            if( fChangeCallSate == TRUE )
            {
                pReplacementCall->ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
            }
        }
        
        pReplacementCall -> Unlock();
    }
    
    UnlockCallTable();
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "SwapReplacementCall exited:%p.", this ));
}


//!!both the calls are locked when this function is called
void
CH323Call::TransferInfoToReplacementCall( 
    PH323_CALL pReplacementCall
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, 
        "TransferInfoToReplacementCall entered:%p.", this ));
    
    m_dwCallDiversionState = H4503_CALLSTATE_IDLE;
    m_dwCallType = CALLTYPE_NORMAL;
    m_dwCallState = LINECALLSTATE_IDLE;
    
    pReplacementCall->SetReplacementCallInfo(
        m_hdCall,
        m_hdMSPLine, 
        m_htCall, 
        m_htMSPLine, 
        m_dwAppSpecific, 
        &m_CallData );

    //don't release this octet string while releasing tis call.
    ZeroMemory( (PVOID)&m_CallData, sizeof(H323_OCTETSTRING) );

    H323DBG(( DEBUG_LEVEL_TRACE, 
        "TransferInfoToReplacementCall exited:%p.", this ));
}


//!!always called in a lock
void
CH323Call::SetReplacementCallInfo(
    HDRVCALL hdCall,
    HDRVMSPLINE hdMSPLine,
    HTAPICALL htCall,
    HTAPIMSPLINE htMSPLine,
    DWORD dwAppSpecific,
    PH323_OCTETSTRING pCallData
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, 
        "SetReplacementCallInfo entered:%p.", this ));

    m_hdCall = hdCall;
    m_hdMSPLine = hdMSPLine;
    m_htMSPLine = htMSPLine;
    m_htCall = htCall;
    m_hdRelatedCall = NULL;
    m_dwCallType = CALLTYPE_NORMAL;
    m_dwAppSpecific = dwAppSpecific; 
    m_CallData = *pCallData;

    H323DBG(( DEBUG_LEVEL_TRACE, 
        "SetReplacementCallInfo exited:%p.", this ));
}



//!!always called in a lock
void
CH323Call::CompleteTransfer(
                            PH323_CALL pCall
                           )
{
    BOOL retVal;

    //set the call type of both the calls
    pCall -> SetCallType( CALLTYPE_TRANSFERING_PRIMARY );
    m_dwCallType |= CALLTYPE_TRANSFERING_CONSULT;
    m_hdRelatedCall = pCall -> GetCallHandle();

    //send CallTransferIdentify message to the transferredTo endpoint over the
    //consultation call
    retVal = SendQ931Message( NO_INVOKEID, 0, 0/*undefinedReason*/,
        FACILITYMESSAGETYPE, CTIDENTIFY_OPCODE | H450_INVOKE );

    m_dwCallDiversionState = H4502_CTIDENTIFY_SENT;

    //start the timer for CTIdenity message
    if( retVal )
    {
        retVal = CreateTimerQueueTimer(
	        &m_hCTIdentifyTimer,
	        H323TimerQueue,
	        CH323Call::CTIdentifyExpiredCallback,
	        (PVOID)m_hdCall,
	        CTIDENTIFY_SENT_TIMEOUT, 0,
	        WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE );
    }

    if( retVal == FALSE )
    {
        CloseCall( 0 );
    }
}


void
CH323Line::PlaceTransferedCall( 
                   IN HDRVCALL hdCall,
                   IN PH323_ALIASNAMES pTransferedToAlias
                  )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "PlaceTransferedCall entered:%p.", this ));

    PH323_CALL  pCall = NULL;
    PH323_CALL  pTransferedCall = NULL;
    BOOL        fDelete = FALSE;

    Lock();
    
    LockCallTable();

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);

    if( pCall == NULL )
    {
        goto cleanup;
    }

    pTransferedCall = CreateNewTransferedCall( pTransferedToAlias );

    if( pTransferedCall == NULL )
    {
        goto cleanup;
    }

    //transfer the required information to the transfered call
    if( !pCall -> TransferInfoToTransferedCall( pTransferedCall ) )
    {
        goto cleanup;
    }

    pCall -> SetCallState( LINECALLSTATE_ONHOLD );
    pCall -> SendMSPMessage( SP_MSG_Hold, 0, 1, NULL );
    
    pCall -> Unlock();
    
    //dial the transfered call
    pTransferedCall -> DialCall();
        
    UnlockCallTable();
    Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "PlaceTransferedCall exited:%p.", this ));
    
    return;

cleanup:

    if( pCall != NULL )
    {
        //close the primary call
        QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            hdCall, 
            NULL,
            LINEDISCONNECTMODE_NORMAL,
            NULL);

        pCall -> Unlock();
    }

    if( pTransferedCall )
    {
        pTransferedCall -> Shutdown( &fDelete );
        delete pTransferedCall;
    }
    
    UnlockCallTable();
    
    Unlock();
}


//!!always called in a lock
PH323_CALL
CH323Line::CreateNewTransferedCall(
                         IN PH323_ALIASNAMES pwszCalleeAlias
                       )
{
    PH323_CONFERENCE pConf = NULL;
    BOOL fDelete = FALSE;
    PH323_CALL pCall = new CH323Call();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CreateNewTransferedCall entered:%p.", this ));

    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate Transfered call." ));

        return NULL;
    }

    // no tapi handle for this call
    if( !pCall -> Initialize( NULL, LINECALLORIGIN_OUTBOUND,
        CALLTYPE_TRANSFEREDSRC ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call." ));

        goto cleanup;
    }

    // bind outgoing call
    pConf = pCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not create conference." ));

        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        goto cleanup;
    }

    if( pwszCalleeAlias->pItems[0].wType == e164_chosen )
    {
        pCall->SetAddressType( e164_chosen );
    }
    
    if (!RasIsRegistered())
    {
        if( !pCall->ResolveAddress( pwszCalleeAlias->pItems[0].pData ) )
        {
            goto cleanup;
        }
    }

    if( !pCall->SetCalleeAlias( pwszCalleeAlias->pItems[0].pData, 
        pwszCalleeAlias->pItems[0].wType ) )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "Transfered call created:%p.", pCall ));
    H323DBG(( DEBUG_LEVEL_TRACE, "CreateNewTransferedCall exited:%p.", this ));
    return pCall;

cleanup:
    if( pCall != NULL )
    {
        pCall -> Shutdown( &fDelete );
        delete pCall;
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
    }

    return NULL;
}



//                                                                           
// TSPI procedures                                                           
//                                                                           



LONG
TSPIAPI
TSPI_lineAddToConference(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdConfCall,
    HDRVCALL      hdConsultCall
    )
    
/*++

Routine Description:

    This function adds the call specified by hdConsultCall to the conference 
    call specified by hdConfCall.

    Note that the call handle of the added party remains valid after adding 
    the call to a conference; its state will typically change to conferenced 
    while the state of the conference call will typically become connected.  
    The handle to an individual participating call can be used later to remove 
    that party from the conference call using TSPI_lineRemoveFromConference. 

    The call states of the calls participating in a conference are not 
    independent. For example, when dropping a conference call, all 
    participating calls may automatically become idle. The TAPI DLL may consult
    the line's device capabilities to determine what form of conference removal 
    is available. The TAPI DLL or its client applications should track the 
    LINE_CALLSTATE messages to determine what really happened to the calls 
    involved.
    
    The conference call is established either via TSPI_lineSetupConference or 
    TSPI_lineCompleteTransfer. The call added to a conference will typically be
    established using TSPI_lineSetupConference or 
    TSPI_linePrepareAddToConference. Some switches may allow adding of an 
    arbitrary calls to conference, and such a call may have been set up using 
    TSPI_lineMakeCall and be on (hard) hold.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdConfCall - Specifies the Service Provider's opaque handle to the 
        conference call.  Valid call states: onHoldPendingConference, onHold.

    hdAddCall - Specifies the Service Provider's opaque handle to the call to 
        be added to the conference call.  Valid call states: connected, onHold.        

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred.  Possible error returns are: 
    
        LINEERR_INVALCONFCALLHANDLE - The specified call handle for the 
            conference call is invalid or is not a handle for a conference 
            call.

        LINEERR_INVALCALLHANDLE - The specified call handle for the added 
            call is invalid.

        LINEERR_INVALCALLSTATE - One or both of the specified calls are not 
            in a valid state for the requested operation.

        LINEERR_CONFERENCEFULL - The maximum number of parties for a 
            conference has been reached.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG 
TSPIAPI 
TSPI_lineBlindTransfer(
    DRV_REQUESTID dwRequestID,
    HDRVCALL hdCall,
    LPCWSTR lpszDestAddress,
    DWORD dwCountryCode
    )
{
    PH323_CALL  pCall = NULL;
    LONG        retVal = ERROR_SUCCESS;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineBlindTransfer - Entered." ));

    if( lpszDestAddress == NULL ) 
    {
        return LINEERR_INVALPARAM;
    }

    // retrieve call pointer from handle
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    retVal = pCall -> InitiateBlindTransfer( lpszDestAddress );
    pCall -> Unlock();

    if( retVal == ERROR_SUCCESS )
    {
        // complete the async accept operation now
		H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

        retVal = dwRequestID;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineBlindTransfer - Exited." ));
    return retVal;
}



//!!always called in a lock
LONG
CH323Call::InitiateBlindTransfer(
    IN LPCWSTR lpszDestAddress
    )
{
    WORD    wAliasType = h323_ID_chosen;
    DWORD   dwMaxAddrSize = MAX_H323_ADDR_LEN;
    DWORD   dwAddrLen;

    H323DBG(( DEBUG_LEVEL_TRACE, "InitiateBlindTransfer - Entered." ));
    
    if( m_dwCallState != LINECALLSTATE_CONNECTED )
    {
        return LINEERR_INVALCALLSTATE;
    }

    if( (*lpszDestAddress==L'T') &&
        IsValidE164String((WCHAR*)lpszDestAddress+1) )
    {
        wAliasType = e164_chosen;
        //strip off the leading 'T'
        lpszDestAddress++;
        dwMaxAddrSize = MAX_E164_ADDR_LEN;
    }
    else if( IsValidE164String( (WCHAR*)lpszDestAddress) )
    {
        wAliasType = e164_chosen;
        dwMaxAddrSize = MAX_E164_ADDR_LEN;
    }

    dwAddrLen = wcslen( lpszDestAddress );
    
    if( (dwAddrLen > dwMaxAddrSize) || (dwAddrLen == 0) ) 
    {
        return LINEERR_INVALPARAM;
    }
    
    if( m_pTransferedToAlias )
    {
        FreeAliasNames( m_pTransferedToAlias );
        m_pTransferedToAlias = NULL;
    }

    m_pTransferedToAlias = new H323_ALIASNAMES;
    
    if( m_pTransferedToAlias == NULL )
    {
        return LINEERR_OPERATIONFAILED;
    }

    ZeroMemory( (PVOID)m_pTransferedToAlias, sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( m_pTransferedToAlias,
        (BYTE*)lpszDestAddress,
        sizeof(WCHAR) * (wcslen(lpszDestAddress) +1),
        wAliasType ) )
    {
        return LINEERR_OPERATIONFAILED;
    }

    if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
        CTINITIATE_OPCODE | H450_INVOKE ) )
    {
        return LINEERR_OPERATIONFAILED;
    }

    m_dwCallDiversionState = H4502_CTINITIATE_SENT;
    m_dwCallType |= CALLTYPE_TRANSFERING_PRIMARY;

    H323DBG(( DEBUG_LEVEL_TRACE, "InitiateBlindTransfer - Exited." ));
    return ERROR_SUCCESS;
}


/*++

Routine Description:

    This function completes the transfer of the specified call to the party 
    connected in the consultation call.
    
    This operation completes the transfer of the original call, hdCall, to 
    the party currently connected via hdConsultCall. The consultation call 
    will typically have been dialed on the consultation call allocated as 
    part of TSPI_lineSetupTransfer, but it may be any call to which the 
    switch is capable of transferring hdCall.

    The transfer request can be resolved either as a transfer or as a 
    three-way conference call. When resolved as a transfer, the parties 
    connected via hdCall and hdConsultCall will be connected to each other, 
    and both hdCall and hdConsultCall will typically be removed from the line 
    they were on and both will transition to the idle state. Note that the 
    Service Provider's opaque handles for these calls must remain valid after 
    the transfer has completed.  The TAPI DLL causes these handles to be 
    invalidated when it is no longer interested in them using 
    TSPI_lineCloseCall.

    When resolved as a conference, all three parties will enter in a 
    conference call. Both existing call handles remain valid, but will 
    transition to the conferenced state. A conference call handle will created
    and returned, and it will transition to the connected state.
    
    It may also be possible to perform a blind transfer of a call using 
    TSPI_lineBlindTransfer.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        transferred.  Valid call states: onHoldPendingTransfer.

    hdConsultCall - Specifies a handle to the call that represents a connection
        with the destination of the transfer.  Valid call states: connected, 
        ringback, busy.

    htConfCall - Specifies the TAPI DLL's opaque handle to the new call.  If 
        dwTransferMode is specified as LINETRANSFERMODE_CONFERENCE then the 
        Service Provider must save this and use it in all subsequent calls to 
        the LINEEVENT procedure reporting events on the call.  Otherwise this 
        parameter is ignored.

    lphdConfCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the call.   If dwTransferMode is 
        specified as LINETRANSFERMODE_CONFERENCE then the Service Provider must
        fill this location with its opaque handle for the new conference call 
        before this procedure returns, whether it decides to execute the 
        request sychronously or asynchronously.  This handle is invalid if the
        function results in an error (either synchronously or asynchronously).  
        If dwTransferMode is some other value this parameter is ignored.

    dwTransferMode - Specifies how the initiated transfer request is to be 
        resolved, of type LINETRANSFERMODE. Values are:

        LINETRANSFERMODE_TRANSFER - Resolve the initiated transfer by 
            transferring the initial call to the consultation call.

        LINETRANSFERMODE_CONFERENCE - Resolve the initiated transfer by 
            conferencing all three parties into a three-way conference call. 
            A conference call is created and returned to the TAPI DLL.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred.  Possible error returns are:
    
        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALCONSULTCALLHANDLE - The specified consultation call 
            handle is invalid.

        LINEERR_INVALCALLSTATE - One or both calls are not in a valid state 
            for the requested operation.

        LINEERR_INVALTRANSFERMODE - The specified transfer mode parameter is 
            invalid.

        LINEERR_INVALPOINTER - The specified pointer parameter is invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

LONG
TSPIAPI
TSPI_lineCompleteTransfer(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall,
    HDRVCALL      hdConsultCall,
    HTAPICALL     htConfCall,
    LPHDRVCALL    lphdConfCall,
    DWORD         dwTransferMode
    )
{
    LONG        retVal = (DWORD)dwRequestID;
    PH323_CALL  pCall = NULL;
    PH323_CALL  pConsultCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCompleteTransfer - Entered." ));

    if( dwTransferMode != LINETRANSFERMODE_TRANSFER )
    {
        return LINEERR_INVALTRANSFERMODE; // CODEWORK...    
    }

    // retrieve call pointer from handle
    pCall=g_pH323Line -> Find2H323CallsAndLock( 
        hdCall, hdConsultCall, &pConsultCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( (pCall -> GetCallState() != LINECALLSTATE_CONNECTED) &&
        !pCall -> IsCallOnHold() )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not connected.", pCall ));
        retVal = LINEERR_INVALCALLSTATE;
        goto cleanup;
    }
    
    if( (pConsultCall -> GetCallState() != LINECALLSTATE_CONNECTED) &&
        !pConsultCall -> IsCallOnHold() )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not connected.", pCall ));
        retVal = LINEERR_INVALCALLSTATE;
        goto cleanup;
    }

    if( !QueueTAPILineRequest( 
            TSPI_COMPLETE_TRANSFER, 
            hdCall, 
            hdConsultCall,
            0,
            NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post transfer complete event." ));
        retVal = LINEERR_OPERATIONFAILED;
        goto cleanup;
    }

    // complete the async accept operation now
	H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCompleteTransfer - Exited." ));

cleanup:
    if( pCall != NULL )
    {
        pCall -> Unlock();
    }
    
    if( pConsultCall )
    {
        pConsultCall -> Unlock();
    }

    return retVal;
}


    
/*++

Parameters:

    dwRequestID - The identifier of the asynchronous request.

    hdCall - The handle to the call to be transferred. The call state of hdCall
        can be connected.

    htConsultCall - The TAPI handle to the new, temporary consultation call.
        The service provider must save this and use it in all subsequent calls
        to the LINEEVENT procedure reporting events on the new consultation call.

    lphdConsultCall - A pointer to an HDRVCALL representing the service 
        provider's identifier for the new consultation call. The service 
        provider must fill this location with its handle for the new 
        consultation call before this procedure returns. This handle is ignored
        by TAPI if the function results in an error. The call state of 
        hdConsultCall is not applicable.
        
        When setting a call up for transfer, another call (a consultation call)
        is automatically allocated to enable the application (through TAPI) to 
        dial the address (using TSPI_lineDial) of the party to where the call
        is to be transferred. The originating party can carry on a conversation
        over this consultation call prior to completing the transfer. 

        This transfer procedure may not be valid for some line devices. Instead
        of calling this procedure, TAPI may need to unhold an existing held
        call (using TSPI_lineUnhold) to identify the destination of the transfer.
        On switches that support cross-address call transfer, the consultation
        call can exist on a different address than the call to be transferred.
        It may also be necessary to set up the consultation call as an entirely
        new call using TSPI_lineMakeCall, to the destination of the transfer.

        The transferHeld and transferMake flags in the LINEADDRESSCAPS data 
        structure report what model the service provider uses.

    lpCallParams - A pointer to call parameters to be used when establishing
        the consultation call. This parameter can be set to NULL if no special
        call setup parameters are desired (the service provider uses defaults).

Return Values:

    Returns dwRequestID, or an error number if an error occurs. The lResult
    actual parameter of the corresponding ASYNC_COMPLETION is zero if the
    function succeeds, or an error number if an error occurs. Possible return
    values are as follows:

        LINEERR_INVALCALLHANDLE, 
        LINEERR_INVALBEARERMODE, 
        LINEERR_INVALCALLSTATE, 
        LINEERR_INVALRATE, 
        LINEERR_CALLUNAVAIL, 
        LINEERR_INVALCALLPARAMS, 
        LINEERR_NOMEM, 
        LINEERR_INVALLINESTATE, 
        LINEERR_OPERATIONUNAVAIL, 
        LINEERR_INVALMEDIAMODE, 
        LINEERR_OPERATIONFAILED, 
        LINEERR_INUSE, 
        LINEERR_RESOURCEUNAVAIL, 
        LINEERR_NOMEM, 
        LINEERR_BEARERMODEUNAVAIL, 
        LINEERR_RATEUNAVAIL, 
        LINEERR_INVALADDRESSMODE, 
        LINEERR_USERUSERINFOTOOBIG. 

--*/

LONG
TSPIAPI
TSPI_lineSetupTransfer(
    DRV_REQUESTID dwRequestID,           
    HDRVCALL hdCall,                     
    HTAPICALL htConsultCall,             
    LPHDRVCALL phdConsultCall,          
    LPLINECALLPARAMS const lpCallParams  
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;
    PH323_CALL          pConsultCall = NULL;
    H323_CONFERENCE *   pConf = NULL;
    BOOL                fDelete = FALSE;
    DWORD               dwCallState;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetupTransfer - Entered." ));

    // Acquire the call table lock.
    g_pH323Line -> LockCallTable();

    pCall = g_pH323Line -> FindH323CallAndLock( hdCall );
    if( pCall == NULL )
    {
        retVal = LINEERR_INVALCALLHANDLE;
        goto cleanup;
    }

    dwCallState = pCall -> GetCallState();

    if( (dwCallState != LINECALLSTATE_CONNECTED) &&
        !pCall -> IsCallOnLocalHold() )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not connected.", pCall ));
        retVal = LINEERR_INVALCALLSTATE;
        
        goto cleanup;
    }
    
    dwCallState = pCall -> GetCallDiversionState();
    if( dwCallState == H4502_CONSULTCALL_INITIATED )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx already is consulting.",
            pCall ));
        retVal = LINEERR_INVALCALLSTATE;
        
        goto cleanup;
    }

    // allocate outgoing call
    pConsultCall = new CH323Call();

    if( pConsultCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate outgoing call." ));

        // no memory available
        retVal = LINEERR_NOMEM;
        
        goto cleanup;
    }

    // save tapi handle and specify outgoing call direction
    if( !pConsultCall -> Initialize( htConsultCall, LINECALLORIGIN_OUTBOUND,
        CALLTYPE_TRANSFERING_CONSULT ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate outgoing call." ));

        // no memory available
        retVal = LINEERR_NOMEM;
        goto cleanup;
    }

    // transfer handle
    *phdConsultCall = pConsultCall -> GetCallHandle();

    // bind outgoing call
    pConf = pConsultCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not create conference." ));

        // no memory available
        retVal = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        // no memory available
        retVal = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    // complete the async accept operation now
	H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pConsultCall -> ChangeCallState( LINECALLSTATE_DIALTONE, 0 );

    // Put the primary call on hold
    pCall-> Hold();

    pCall -> SetCallDiversionState( H4502_CONSULTCALL_INITIATED );

    pCall -> Unlock();

    // Release the call table lock
    g_pH323Line -> UnlockCallTable();

    // Create a new call. put it in DIALTONE mode and return its handle
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetupTransfer - Exited." ));
    return retVal;

cleanup:

    if( pCall != NULL )
    {
        pCall -> Unlock();
    }

    if( pConf != NULL )
    {
        g_pH323Line -> GetH323ConfTable() -> Remove( pConf );
        delete pConf;
        pConf = NULL;
    }

    if( pConsultCall != NULL )
    {
        pConsultCall -> Shutdown( &fDelete );
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
        delete pConsultCall;
        pCall = NULL;
    }
        
    // Release the call table lock
    g_pH323Line -> UnlockCallTable();
    return retVal;
}


/*
 
Parameters:
    dwRequestID - The identifier of the asynchronous request. 
    
    hdCall - The service provider's handle to the call to be dialed. The call
        state of hdCall can be any state except idle and disconnected. 
    
    lpszDestAddress - The destination to be dialed using the standard dialable
        number format. 

    dwCountryCode - The country code of the destination. This is used by the
        implementation to select the call progress protocols for the destination
        address. If a value of 0 is specified, a default call-progress protocol
        defined by the service provider is used. This parameter is not validated
        by TAPI when this function is called. 

    Return Values - 
        Returns dwRequestID or an error number if an error occurs. The lResult
        actual parameter of the corresponding ASYNC_COMPLETION is zero if the
        function succeeds or an error number if an error occurs. Possible return
        values are as follows: 

        LINEERR_INVALCALLHANDLE, 
        LINEERR_OPERATIONFAILED, 
        LINEERR_INVALADDRESS, 
        LINEERR_RESOURCEUNAVAIL, 
        LINEERR_INVALCOUNTRYCODE, 
        LINEERR_DIALBILLING, 
        LINEERR_INVALCALLSTATE, 
        LINEERR_DIALQUIET, 
        LINEERR_ADDRESSBLOCKED, 
        LINEERR_DIALDIALTONE, 
        LINEERR_NOMEM, 
        LINEERR_DIALPROMPT, 
        LINEERR_OPERATIONUNAVAIL. 

    Remarks -
        The service provider returns LINEERR_INVALCALLSTATE if the current state
        of the call does not allow dialing.
        The service provider carries out no dialing if it returns 
        LINEERR_INVALADDRESS.
        If the service provider returns LINEERR_DIALBILLING, LINEERR_DIALQUIET,
        LINEERR_DIALDIALTONE, or LINEERR_DIALPROMPT, it should perform none of
        the actions otherwise performed by TSPI_lineDial (for example, no 
        partial dialing, and no going offhook). This is because the service 
        provider should pre-scan the number for unsupported characters first.
        TSPI_lineDial is used for dialing on an existing call appearance; for 
        example, call handles returned from TSPI_lineMakeCall with NULL as the
        lpszDestAddress or ending in ';', call handles returned from 
        TSPI_lineSetupTransfer or TSPI_lineSetupConference. TSPI_lineDial can 
        be invoked multiple times in the course of dialing in the case of 
        multistage dialing, if the line's device capabilities permit it.
        If the string pointed to by the lpszDestAddress parameter in the 
        previous call to the TSPI_lineMakeCall or TSPI_lineDial function is 
        terminated with a semicolon, an empty string in the current call to 
        TSPI_lineDial indicates that dialing is complete.
        Multiple addresses can be provided in a single dial string separated by
        CRLF. Service providers that provide inverse multiplexing can establish
        individual physical calls with each of the addresses, and return a 
        single call handle to the aggregate of all calls to the application. 
        All addresses would use the same country code.
        Dialing is considered complete after the address has been accepted by
        the service provider, not after the call is finally connected. Service
        providers that provide inverse multiplexing may allow multiple addresses
        to be provided at once. The service provider must send LINE_CALLSTATE
        messages to TAPI to inform it about the progress of the call.

*/

LONG 
TSPIAPI 
TSPI_lineDial(
    DRV_REQUESTID dwRequestID,  
    HDRVCALL hdCall,          
    LPCWSTR lpszDestAddress,  
    DWORD dwCountryCode       
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;
    WORD                wAliasType = h323_ID_chosen;
    DWORD               dwCallState;
    WCHAR*              wszMachineName;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineDial - Entered." ));

    if( lpszDestAddress == NULL ) 
    {
        return LINEERR_INVALPARAM;
    }

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    
    {
        return LINEERR_INVALCALLHANDLE;
    }

    dwCallState = pCall -> GetCallState();

    if( dwCallState == LINECALLSTATE_CONNECTED )
    {
        //no need to dial the call. Inform TAPI3 about it once again.
        pCall -> ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
        goto func_exit;
    }
    
    if( dwCallState != LINECALLSTATE_DIALTONE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx no dialtone.", pCall ));
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    if( (*lpszDestAddress==L'T') &&
        IsValidE164String((WCHAR*)lpszDestAddress+1) )
    {
        wAliasType = e164_chosen;
        //strip off the leading 'T'
        lpszDestAddress++;
    }
    else if( IsValidE164String( (WCHAR*)lpszDestAddress) )
    {
        wAliasType = e164_chosen;
    }

    pCall->SetAddressType( wAliasType );

    if( !pCall->SetCalleeAlias( (WCHAR*)lpszDestAddress, wAliasType ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not set callee alias." ));
        pCall -> Unlock();
        // invalid destination addr
        return LINEERR_NOMEM;
    }
    
    //set the caller alias name
    if( RasIsRegistered() )
    {
        //ARQ message must have a caller alias
        PH323_ALIASNAMES pAliasList = RASGetRegisteredAliasList();

        wszMachineName = pAliasList -> pItems[0].pData;
        wAliasType = pAliasList -> pItems[0].wType;
    }
    else
    {
        wszMachineName = g_pH323Line->GetMachineName();
        wAliasType = h323_ID_chosen;
    }

    //set the value for m_pCallerAliasNames
    if( !pCall->SetCallerAlias( wszMachineName, wAliasType ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not set caller alias." ));
        pCall -> Unlock();
        
        // invalid destination addr
        return LINEERR_NOMEM;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_MAKE_CALL, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post transfer complete event." ));
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }

func_exit:

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    //create a new call. put it in DIALTONE mode and return its handle
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineDial - Exited." ));
    
    pCall -> Unlock();
    return retVal;
}


LONG
TSPIAPI
TSPI_linePrepareAddToConference(
    DRV_REQUESTID    dwRequestID,
    HDRVCALL         hdConfCall,
    HTAPICALL        htConsultCall,
    LPHDRVCALL       lphdConsultCall,
    LPLINECALLPARAMS const lpCallParams
    )
    
/*++

Routine Description:

    This function prepares an existing conference call for the addition of 
    another party.  It creates a new, temporary consultation call.  The new 
    consulatation call can be subsequently added to the conference call.

    A conference call handle can be obtained via TSPI_lineSetupConference or 
    via TSPI_lineCompleteTransfer that is resolved as a three-way conference 
    call. The function TSPI_linePrepareAddToConference typically places the 
    existing conference call in the onHoldPendingConference state and creates 
    a consultation call that can be added later to the existing conference 
    call via TSPI_lineAddToConference. 
    
    The consultation call can be canceled using TSPI_lineDrop. It may also 
    be possible for the TAPI DLL to swap between the consultation call and 
    the held conference call via TSPI_lineSwapHold.
    
    The Service Provider initially does media monitoring on the new call for
    at least the set of media modes that were monitored for on the line.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdConfCall - Specifies the Service Provider's opaque handle to a 
        conference call.  Valid call states: connected.

    htAddCall - Specifies the TAPI DLL's opaque handle to the new, temporary 
        consultation call.  The Service Provider must save this and use it in 
        all subsequent calls to the LINEEVENT procedure reporting events on 
        the new call.

    lphdAddCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the new, temporary consultation 
        call.  The Service Provider must fill this location with its opaque 
        handle for the new call before this procedure returns, whether it 
        decides to execute the request sychronously or asynchronously.  This 
        handle is invalid if the function results in an error (either 
        synchronously or asynchronously).

    lpCallParams - Specifies a far pointer to call parameters to be used when 
        establishing the consultation call. This parameter may be set to NULL 
        if no special call setup parameters are desired.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCONFCALLHANDLE - The specified call handle for the 
            conference call is invalid.

        LINEERR_INVALPOINTER - One or more of the specified pointer 
            parameters are invalid.

        LINEERR_INVALCALLSTATE - The conference call is not in a valid state 
            for the requested operation.

        LINEERR_CALLUNAVAIL - All call appearances on the specified address 
            are currently allocated.

        LINEERR_CONFERENCEFULL - The maximum number of parties for a 
            conference has been reached.

        LINEERR_INVALCALLPARAMS - The specified call parameters are invalid.
    
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG
TSPIAPI
TSPI_lineSetupConference(
    DRV_REQUESTID    dwRequestID,
    HDRVCALL         hdCall,
    HDRVLINE         hdLine,
    HTAPICALL        htConfCall,
    LPHDRVCALL       lphdConfCall,
    HTAPICALL        htConsultCall,
    LPHDRVCALL       lphdConsultCall,
    DWORD            dwNumParties,
    LPLINECALLPARAMS const lpCallParams
    )
    
/*++

Routine Description:

    This function sets up a conference call for the addition of the third 
    party. 

    TSPI_lineSetupConference provides two ways for establishing a new 
    conference call, depending on whether a normal two-party call is required 
    to pre-exist or not. When setting up a conference call from an existing 
    two-party call, the hdCall parameter is a valid call handle that is 
    initially added to the conference call by the TSPI_lineSetupConference 
    request and hdLine is ignored. On switches where conference call setup 
    does not start with an existing call, hdCall must be NULL and hdLine 
    must be specified to identify the line device on which to initiate the 
    conference call.  In either case, a consultation call is allocated for 
    connecting to the party that is to be added to the call. The TAPI DLL 
    can use TSPI_lineDial to dial the address of the other party.
    
    The conference call will typically transition into the 
    onHoldPendingConference state, the consultation call dialtone state and 
    the initial call (if one) into the conferenced state.
    
    A conference call can also be set up via a TSPI_lineCompleteTransfer that 
    is resolved into a three-way conference.
    
    The TAPI DLL may be able to toggle between the consultation call and the 
    conference call by using TSPI_lineSwapHold.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the initial 
        call that identifies the first party of a conference call. In some 
        environments, a call must exist in order to start a conference call. 
        In other telephony environments, no call initially exists and hdCall 
        is left NULL.  Valid call states: connected.

    hdLine - Specifies the Service Provider's opaque handle to the line device 
        on which to originate the conference call if hdCall is NULL.  The 
        hdLine parameter is ignored if hdCall is non-NULL.  The Service 
        Provider reports which model it supports through the setupConfNull 
        flag of the LINEADDRESSCAPS data structure.

    htConfCall - Specifies the TAPI DLL's opaque handle to the new conference 
        call.  The Service Provider must save this and use it in all subsequent 
        calls to the LINEEVENT procedure reporting events on the new call.

    lphdConfCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the newly created conference 
        call.  The Service Provider must fill this location with its opaque 
        handle for the new call before this procedure returns, whether it 
        decides to execute the request sychronously or asynchronously.  This 
        handle is invalid if the function results in an error (either 
        synchronously or asynchronously).

    htAddCall - Specifies the TAPI DLL's opaque handle to a new call.  When 
        setting up a call for the addition of a new party, a new temporary call
        (consultation call) is automatically allocated.  The Service Provider 
        must save the htAddCall and use it in all subsequent calls to the 
        LINEEVENT procedure reporting events on the new consultation call.

    lphdAddCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for a call.  When setting up a call 
        for the addition of a new party, a new temporary call (consultation 
        call) is automatically allocated. The Service Provider must fill this 
        location with its opaque handle for the new consultation call before 
        this procedure returns, whether it decides to execute the request 
        sychronously or asynchronously.  This handle is invalid if the 
        function results in an error (either synchronously or asynchronously).

    dwNumParties - Specifies the expected number of parties in the conference 
        call.  The service provider is free to do with this number as it 
        pleases; ignore it, use it a hint to allocate the right size 
        conference bridge inside the switch, etc.

    lpCallParams - Specifies a far pointer to call parameters to be used when 
        establishing the consultation call. This parameter may be set to NULL 
        if no special call setup parameters are desired.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle for the conference 
            call is invalid.  This error may also indicate that the telephony 
            environment requires an initial call to set up a conference but a 
            NULL call handle was supplied.

        LINEERR_INVALLINEHANDLE - The specified line handle for the line 
            containing the conference call is invalid.  This error may also 
            indicate that the telephony environment requires an initial line 
            to set up a conference but a non-NULL call handle was supplied 
            instead.

        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.

        LINEERR_CALLUNAVAIL - All call appearances on the specified address 
            are currently allocated.

        LINEERR_CONFERENCEFULL - The requested number of parties cannot be 
            satisfied.

        LINEERR_INVALPOINTER - One or more of the specified pointer 
            parameters are invalid.
    
        LINEERR_INVALCALLPARAMS - The specified call parameters are invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG
TSPIAPI
TSPI_lineRemoveFromConference(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall
    )
    
/*++

Routine Description:

    This function removes the specified call from the conference call to 
    which it currently belongs. The remaining calls in the conference 
    call are unaffected.

    This operation removes a party that currently belongs to a conference 
    call. After the call has been successfully removed, it may be possible 
    to further manipulate it using its handle. The availability of this 
    operation and its result are likely to be limited in many 
    implementations. For example, in many implementations, only the most 
    recently added party may be removed from a conference, and the removed 
    call may be automatically dropped (becomes idle). Consult the line's 
    device capabilities to determine the available effects of removing a 
    call from a conference.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be removed from the conference.  Valid call states: conferenced.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.
        
        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.
    
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}

/* 
Parameters:
    dwRequestID - The identifier of the asynchronous request. 
    hdLine - The service provider's handle to the line to be forwarded. 

    bAllAddresses - Specifies whether all originating addresses on the line or
        just the one specified is to be forwarded. If TRUE, all addresses on 
        the line are forwarded and dwAddressID is ignored; if FALSE, only the
        address specified as dwAddressID is forwarded. This parameter is not
        validated by TAPI when this function is called. 

    dwAddressID - The address on the specified line whose incoming calls are to
        be forwarded. This parameter is ignored if bAllAddresses is TRUE. This 
        parameter is not validated by TAPI when this function is called. 

    lpForwardList - A pointer to a variably sized data structure of type 
        LINEFORWARDLIST that describes the specific forwarding instructions.

    dwNumRingsNoAnswer - Specifies the number of rings before an incoming call
        is considered a "no answer." If dwNumRingsNoAnswer is out of range, the
        actual value is set to the nearest value in the allowable range. This 
        parameter is not validated by TAPI when this function is called. 

    htConsultCall - The TAPI handle to a new call, if such a call must be created
        by the service provider. In some telephony environments, forwarding a
        call has the side effect of creating a consultation call used to consult
        the party that is being forwarded to. In such an environment, the service
        provider creates the new consutation call and must save this value and
        use it in all subsequent calls to the LINEEVENT procedure reporting
        events on the call. If no consultation call is created, this value can
        be ignored by the service provider. 

    lphdConsultCall - A pointer to an HDRVCALL representing the service 
        provider's identifier for the call. In telephony environments where 
        forwarding a call has the side effect of creating a consultation call
        used to consult the party that is being forwarded to, the service 
        provider must fill this location with its handle for the call before 
        this procedure returns. The service provider is permitted to do callbacks
        regarding the new call before it returns from this procedure. If no 
        consultation call is created, the HDRVCALL must be left NULL. 

    lpCallParams - A pointer to a structure of type LINECALLPARAMS. This pointer
        is ignored by the service provider unless lineForward requires the 
        establishment of a call to the forwarding destination (and 
        lphdConsultCall is returned, in which case lpCallParams is optional). 
        If NULL, default call parameters are used. Otherwise, the specified call
        parameters are used for establishing htConsultCall. 

Return Values:
        Returns dwRequestID or an error number if an error occurs. The lResult 
        actual parameter of the corresponding ASYNC_COMPLETION is zero if the 
        function succeeds or an error number if an error occurs. Possible return
        values are as follows: 

                LINEERR_INVALLINEHANDLE, 
                LINEERR_NOMEM, 
                LINEERR_INVALADDRESS, 
                LINEERR_OPERATIONUNAVAIL, 
                LINEERR_INVALADDRESSID, 
                LINEERR_OPERATIONFAILED, 
                LINEERR_INVALCOUNTRYCODE,
                LINEERR_RESOURCEUNAVAIL, 
                LINEERR_INVALPARAM, 
                LINEERR_STRUCTURETOOSMALL. 

Remarks
*/

LONG 
TSPIAPI TSPI_lineForward(
    DRV_REQUESTID dwRequestID,           
    HDRVLINE hdLine,                     
    DWORD bAllAddresses,                 
    DWORD dwAddressID,                   
    LPLINEFORWARDLIST const lpForwardList,  
    DWORD dwNumRingsNoAnswer,            
    HTAPICALL htConsultCall,             
    LPHDRVCALL lphdConsultCall,          
    LPLINECALLPARAMS const lpCallParams  
    )
{
    DWORD               dwStatus = dwRequestID;
    PH323_CALL         pCall = NULL;
    H323_CONFERENCE *   pConf = NULL;
    BOOL                fDelete = FALSE;
    DWORD               dwState;
    PVOID               pForwardParams = NULL;
    DWORD               event = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineForward - Entered." ));
    
    //lock the line device    
    g_pH323Line -> Lock();

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        g_pH323Line ->Unlock();
        return LINEERR_RESOURCEUNAVAIL;
    }

    // validate line state
    dwState = g_pH323Line -> GetState();
    if( ( dwState != H323_LINESTATE_OPENED) &&
        ( dwState != H323_LINESTATE_LISTENING) ) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "H323 line is not currently opened:%d.",
            dwState ));

        // release line device
        g_pH323Line ->Unlock();

        // line needs to be opened
        return LINEERR_INVALLINESTATE;
    }
    
    if( lpForwardList == NULL )
    {
        //forwarding is disabled
        g_pH323Line -> DisableCallForwarding();
        g_pH323Line ->Unlock();

        *lphdConsultCall = NULL;

        //inform the user about change in line forward state
        (*g_pfnLineEventProc)(
                g_pH323Line->m_htLine,
                (HTAPICALL)NULL,
                (DWORD)LINE_ADDRESSSTATE,
                (DWORD)LINEADDRESSSTATE_FORWARD,
                (DWORD)LINEADDRESSSTATE_FORWARD,
                (DWORD)0
                );


        // complete the async accept operation now
        H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

        return dwRequestID;
    }

    // allocate outgoing call
    pCall = new CH323Call();

    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate outgoing call." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;
        goto cleanup;
    }

    // save tapi handle and specify outgoing call direction
    if( !pCall -> Initialize( htConsultCall, LINECALLORIGIN_OUTBOUND,
        CALLTYPE_FORWARDCONSULT ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate outgoing call." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;
        goto cleanup;
    }

    dwStatus = pCall -> ValidateForwardParams(
        lpForwardList, &pForwardParams, &event );
    if( dwStatus != ERROR_SUCCESS )
    {
        // failure
        goto cleanup;
    }

    _ASSERTE( event );

    // transfer handle
    *lphdConsultCall = (HDRVCALL)NULL /*pCall -> GetCallHandle()*/;

    // bind outgoing call
    pConf = pCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not create conference." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    pCall -> Lock();

    // post line forward request to callback thread
    if( !pCall->QueueTAPICallRequest( event, (PVOID)pForwardParams ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post forward message." ));

        // could not complete operation
        dwStatus = LINEERR_OPERATIONFAILED;

        pCall-> Unlock();

        // failure
        goto cleanup;
    }
    
    g_pH323Line -> m_fForwardConsultInProgress = TRUE;
    
    if( (dwNumRingsNoAnswer >= H323_NUMRINGS_LO) &&
        (dwNumRingsNoAnswer <= H323_NUMRINGS_HI) )
    {
        g_pH323Line -> m_dwNumRingsNoAnswer = dwNumRingsNoAnswer;
    }

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    //unlock the call object.
    pCall-> Unlock();

    // release line device
    g_pH323Line -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineForward - Exited." ));
    
    // success
    return dwRequestID;

cleanup:
    if( pCall != NULL )
    {
        pCall -> Shutdown( &fDelete );
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
        delete pCall;
        pCall = NULL;
    }

    *lphdConsultCall = NULL;

    if( pForwardParams != NULL )
    {
        delete pForwardParams;
        pForwardParams = NULL;
    }

    // release line device
    g_pH323Line -> Unlock();

    // failure
    return dwStatus;
}


LONG 
TSPIAPI TSPI_lineRedirect(
    DRV_REQUESTID dwRequestID,
    HDRVCALL hdCall,
    LPCWSTR lpszDestAddress,
    DWORD dwCountryCode
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;
    CALLREROUTINGINFO*  pCallReroutingInfo = NULL;
    WORD                wAliasType = h323_ID_chosen;
    DWORD               dwMaxAddrSize = MAX_H323_ADDR_LEN;
    DWORD               dwAddrLen;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineRedirect - Entered." ));

    if( lpszDestAddress == NULL ) 
        return LINEERR_INVALPARAM;

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( pCall -> GetCallState() != LINECALLSTATE_OFFERING )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not ringback.", pCall ));
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    if( (*lpszDestAddress==L'T') &&
        IsValidE164String((WCHAR*)lpszDestAddress+1) )
    {
        wAliasType = e164_chosen;
        //strip off the leading 'T'
        lpszDestAddress++;
        dwMaxAddrSize = MAX_E164_ADDR_LEN;
    }
    else if( IsValidE164String( (WCHAR*)lpszDestAddress) )
    {
        wAliasType = e164_chosen;
        dwMaxAddrSize = MAX_E164_ADDR_LEN;
    }

    dwAddrLen = wcslen(lpszDestAddress);
    if( (dwAddrLen > dwMaxAddrSize) || (dwAddrLen == 0) )
    {
        return LINEERR_INVALPARAM;
    }

    retVal = pCall -> SetDivertedToAlias( (WCHAR*)lpszDestAddress, wAliasType );
    if(  retVal != NOERROR )
    {
        pCall->Unlock();
        return retVal;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_CALL_DIVERT, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post call divert event." ));
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall -> Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineRedirect - Exited." ));
    return dwRequestID;
}



LONG TSPIAPI TSPI_lineUnhold (
    DRV_REQUESTID dwRequestID,  
    HDRVCALL hdCall             
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineUnHold - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( pCall -> IsCallOnHold() == FALSE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not ringback.", pCall ));
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_CALL_UNHOLD, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post transfer complete event." ));
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall -> Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineUnHold - Exited." ));
    return dwRequestID;
}


LONG TSPIAPI TSPI_lineHold(
    DRV_REQUESTID dwRequestID,  
    HDRVCALL hdCall             
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineHold - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( (pCall -> GetCallState() != LINECALLSTATE_CONNECTED) ||
        (pCall -> IsCallOnHold()) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not ringback.", pCall ));
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_CALL_HOLD, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post transfer complete event." ));
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall -> Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineHold - Exited." ));
    return retVal;
}


BOOL
CH323Call::ResolveToIPAddress( 
                    IN WCHAR* pwszAddr,
                    IN SOCKADDR_IN* psaAddr
                  )
{
    CHAR szDelimiters[] = "@ \t\n";
    CHAR szAddr[H323_MAXDESTNAMELEN+1];
    LPSTR pszUser = NULL;
    LPSTR pszDomain = NULL;
    DWORD           dwIPAddr;
    struct hostent* pHost;
    
    H323DBG(( DEBUG_LEVEL_ERROR, "ResolveToIPAddress entered:%p.",this ));

    ZeroMemory( psaAddr, sizeof(SOCKADDR) );

    // validate pointerr
    if (pwszAddr == NULL)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "null destination address." ));

        // failure
        return FALSE;
    }


    // convert address from unicode
    if (WideCharToMultiByte(
            CP_ACP,
            0,
            pwszAddr,
            -1,
            szAddr,
            sizeof(szAddr),
            NULL,
            NULL
            ) == 0)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not convert address from unicode." ));

        // failure
        return FALSE;
    }

    // check whether phone number has been specified
    if( IsPhoneNumber( szAddr ) )
    {
        // need to direct call to pstn gateway
        
        if ((g_RegistrySettings.fIsGatewayEnabled == FALSE) ||
        (g_RegistrySettings.gatewayAddr.nAddrType == 0))
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "pstn gateway not specified." ));

            // failure
            return FALSE;
        }

        psaAddr->sin_family = AF_INET;
        psaAddr->sin_addr.S_un.S_addr =
            htonl( g_RegistrySettings.gatewayAddr.Addr.IP_Binary.dwAddr );
        psaAddr->sin_port = g_RegistrySettings.gatewayAddr.Addr.IP_Binary.wPort;
        return TRUE;
    }

    // parse user name
    pszUser = strtok(szAddr, szDelimiters);

    // parse domain name
    pszDomain = strtok(NULL, szDelimiters);

    // validate pointer
    if (pszUser == NULL)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not parse destination address." ));

        // failure
        return FALSE;
    }

    // validate pointer
    if (pszDomain == NULL)
    {
        // switch pointers
        pszDomain = pszUser;

        // re-initialize
        pszUser = NULL;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE,
        "resolving user %s domain %s.",
        pszUser, pszDomain ));
    
    // attempt to convert ip address
    dwIPAddr = inet_addr(szAddr);

    // see if address converted
    if( dwIPAddr == INADDR_NONE )
    {
        // attempt to lookup hostname
        pHost = gethostbyname(szAddr);

        // validate pointer
        if( pHost != NULL )
        {
            // retrieve host address from structure
            dwIPAddr = *(unsigned long *)pHost->h_addr;
        }
    }

    // see if address converted
    if( dwIPAddr == INADDR_NONE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
                  "error 0x%08lx resolving IP address.",
                  WSAGetLastError() ));

        // make sure proxy has been specified
        if ((g_RegistrySettings.fIsProxyEnabled == FALSE) ||
            (g_RegistrySettings.proxyAddr.nAddrType == 0))
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "proxy not specified." ));

            // failure
            return FALSE;
        }

        psaAddr->sin_family = AF_INET;
        psaAddr->sin_addr.S_un.S_addr = 
            htonl( g_RegistrySettings.proxyAddr.Addr.IP_Binary.dwAddr );
        psaAddr->sin_port = g_RegistrySettings.proxyAddr.Addr.IP_Binary.wPort;

        return TRUE;
    }

    // save converted address
    psaAddr->sin_family = AF_INET;
    psaAddr->sin_addr.S_un.S_addr = dwIPAddr;

    H323DBG(( DEBUG_LEVEL_TRACE,
        "callee address resolved to %s:%d.",
        H323AddrToString(dwIPAddr),
        m_CalleeAddr.Addr.IP_Binary.wPort ));

    return TRUE;
}


//!!always called in a lock
LONG
CH323Line::CopyAddressForwardInfo(
                                  IN LPLINEADDRESSSTATUS lpAddressStatus
                                 )
{
    LINEFORWARD * lineForwardStructArray;
    LPFORWARDADDRESS pForwardedAddress;

    if( m_pCallForwardParams-> fForwardForAllOrigins == TRUE )
    {
        lpAddressStatus->dwForwardNumEntries = 1;
        lpAddressStatus->dwForwardSize = sizeof(LINEFORWARD) + 
            sizeof(WCHAR) * (m_pCallForwardParams->divertedToAlias.wDataLength+1);
    }
    else
    {
        lpAddressStatus->dwForwardNumEntries = 0;

        pForwardedAddress = m_pCallForwardParams->pForwardedAddresses;

        while( pForwardedAddress )
        {
            lpAddressStatus->dwForwardNumEntries++;
            lpAddressStatus->dwForwardSize += sizeof(LINEFORWARD) + 
                sizeof(WCHAR) * (pForwardedAddress->callerAlias.wDataLength+1) +
                sizeof(WCHAR) * (pForwardedAddress->divertedToAlias.wDataLength+1);

            pForwardedAddress = pForwardedAddress->next;
        }
    }

    lpAddressStatus->dwNeededSize += lpAddressStatus->dwForwardSize;
    if( lpAddressStatus->dwTotalSize < lpAddressStatus->dwNeededSize )
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    lineForwardStructArray = (LINEFORWARD*)
        ((BYTE*)lpAddressStatus + lpAddressStatus->dwUsedSize);
    
    lpAddressStatus->dwUsedSize += lpAddressStatus->dwForwardNumEntries * 
        sizeof(LINEFORWARD);

    if( m_pCallForwardParams-> fForwardForAllOrigins == TRUE )
    {
        //copy the first structure
        lineForwardStructArray[0].dwForwardMode = 
            m_pCallForwardParams->dwForwardTypeForAllOrigins;

        //copy dest address alias
        lineForwardStructArray[0].dwDestAddressOffset =
            lpAddressStatus->dwUsedSize;

        lineForwardStructArray[0].dwDestAddressSize =
            sizeof(WCHAR)* (m_pCallForwardParams->divertedToAlias.wDataLength + 1);
        
        CopyMemory(
            (PVOID)((BYTE*)lpAddressStatus+lpAddressStatus->dwUsedSize),
            m_pCallForwardParams->divertedToAlias.pData,
            lineForwardStructArray[0].dwDestAddressSize );

        lpAddressStatus->dwUsedSize +=
            lineForwardStructArray[0].dwDestAddressSize;

        lineForwardStructArray[0].dwDestCountryCode = 0;
    }
    else
    {
        pForwardedAddress = m_pCallForwardParams->pForwardedAddresses;

        for( DWORD indexI = 0; indexI < lpAddressStatus->dwForwardNumEntries; indexI++ )
        {
            _ASSERTE( pForwardedAddress );

            lineForwardStructArray[indexI].dwForwardMode =
                pForwardedAddress->dwForwardType;

            //copy caller address alias
            lineForwardStructArray[indexI].dwCallerAddressOffset = 
                lpAddressStatus->dwUsedSize;

            lineForwardStructArray[indexI].dwCallerAddressSize = 
                sizeof(WCHAR)* (pForwardedAddress->callerAlias.wDataLength + 1);
        
            CopyMemory( 
                (PVOID)((BYTE*)lpAddressStatus+lpAddressStatus->dwUsedSize),
                (PVOID)pForwardedAddress->callerAlias.pData,
                lineForwardStructArray[indexI].dwCallerAddressSize );

            lpAddressStatus->dwUsedSize +=
                lineForwardStructArray[indexI].dwCallerAddressSize;
        
            //copy dest address alias
            lineForwardStructArray[indexI].dwDestAddressOffset = 
                lpAddressStatus->dwUsedSize;

            lineForwardStructArray[indexI].dwDestAddressSize = 
                sizeof(WCHAR)* (pForwardedAddress->divertedToAlias.wDataLength + 1);
        
            CopyMemory( 
                (PVOID)((BYTE*)lpAddressStatus+lpAddressStatus->dwUsedSize),
                pForwardedAddress->divertedToAlias.pData,
                lineForwardStructArray[indexI].dwDestAddressSize);

            lpAddressStatus->dwUsedSize +=
                lineForwardStructArray[indexI].dwDestAddressSize;

            lineForwardStructArray[indexI].dwDestCountryCode = 0;

            pForwardedAddress = pForwardedAddress->next;
        }
    }

    _ASSERTE( lpAddressStatus->dwUsedSize == lpAddressStatus->dwNeededSize);
    return NOERROR;
}


//!!always called in a lock
LONG
CH323Call::ValidateForwardParams(
    IN  LPLINEFORWARDLIST lpLineForwardList,
    OUT PVOID*            ppForwardParams,
    OUT DWORD*            pEvent
    )
{
    LPLINEFORWARD       pLineForwardStruct;
    LPWSTR              pwszDestAddr = NULL;
    LPWSTR              pAllocAddrBuffer = NULL;
    DWORD               dwStatus = ERROR_SUCCESS;
    CALLFORWARDPARAMS * pCallForwardParams = NULL;
    FORWARDADDRESS *    pForwardAddress = NULL;
    WORD                wAliasType = h323_ID_chosen;
    DWORD               dwMaxAddrSize = MAX_H323_ADDR_LEN;
    DWORD               dwAddrLen;

    *pEvent = 0;

    if( (lpLineForwardList->dwNumEntries == 0) || 
        (lpLineForwardList->dwTotalSize == 0) )
    {
        return LINEERR_INVALPARAM;
    }

    pLineForwardStruct = &(lpLineForwardList->ForwardList[0]);

	if( pLineForwardStruct->dwDestAddressSize == 0 )
	{
		return LINEERR_INVALPARAM;
	}

    //resolve the diverted-to address
    pAllocAddrBuffer = pwszDestAddr =
        (WCHAR*)new BYTE[pLineForwardStruct->dwDestAddressSize];

    if( pwszDestAddr == NULL )
    {
        return LINEERR_NOMEM;
    }

    CopyMemory( pwszDestAddr, 
        (BYTE*)lpLineForwardList + pLineForwardStruct->dwDestAddressOffset,
        pLineForwardStruct->dwDestAddressSize );
                            
    //If negotiated version is 3.1 get the alias type
    if( g_dwTSPIVersion >= 0x00030001 )
    {
        switch( pLineForwardStruct->dwDestAddressType )
        {
        case LINEADDRESSTYPE_PHONENUMBER:

            wAliasType = e164_chosen;
            if( *pwszDestAddr == L'T' )
            {
                //strip off the leading 'T'
                pwszDestAddr++;
            }
            
            if( IsValidE164String( (WCHAR*)pwszDestAddr) == FALSE )
            {
                delete pAllocAddrBuffer;
                return LINEERR_INVALPARAM;
            }
                            
            dwMaxAddrSize = MAX_E164_ADDR_LEN;
            break;

        case LINEADDRESSTYPE_DOMAINNAME: 
        case LINEADDRESSTYPE_IPADDRESS:
            wAliasType = h323_ID_chosen;
            break;

        default:
            H323DBG(( DEBUG_LEVEL_VERBOSE, "Wrong address type:.",
                 pLineForwardStruct->dwDestAddressType ));

            delete pAllocAddrBuffer;
            return LINEERR_INVALPARAM;
        }
    }
    else
    {
        if( (*pwszDestAddr==L'T') &&
            IsValidE164String((WCHAR*)pwszDestAddr+1) )
        {
            wAliasType = e164_chosen;
            //strip off the leading 'T'
            pwszDestAddr++;
            dwMaxAddrSize = MAX_E164_ADDR_LEN;
        }
        else if( IsValidE164String( (WCHAR*)pwszDestAddr) )
        {
            wAliasType = e164_chosen;
            dwMaxAddrSize = MAX_E164_ADDR_LEN;
        }
    }

    dwAddrLen = wcslen( pwszDestAddr );
    if( (dwAddrLen > dwMaxAddrSize) || (dwAddrLen == 0) )
    {
        delete pAllocAddrBuffer;       
        return LINEERR_INVALPARAM;
    }

    m_dwAddressType = wAliasType;
    
    //don't resolve the address if GK enabled
    if( !ResolveAddress( pwszDestAddr ) )
    {
        if( !RasIsRegistered())
        {
            delete pAllocAddrBuffer;
            return LINEERR_INVALPARAM;
        }
    }
    else if(m_CallerAddr.Addr.IP_Binary.dwAddr == HOST_LOCAL_IP_ADDR_INTERFACE )
    {
        delete pAllocAddrBuffer;
        return LINEERR_INVALPARAM;
    }

    if( !SetCalleeAlias( (WCHAR*)pwszDestAddr, wAliasType ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not set callee alias." ));
        delete pAllocAddrBuffer;
        return LINEERR_NOMEM;
    }

    switch( pLineForwardStruct->dwForwardMode )
    {
    case LINEFORWARDMODE_UNCOND:
    case LINEFORWARDMODE_BUSY:
    case LINEFORWARDMODE_NOANSW:
    case LINEFORWARDMODE_BUSYNA:

        pCallForwardParams = new CALLFORWARDPARAMS;
        if( pCallForwardParams == NULL )
        {
            delete pAllocAddrBuffer;
            return LINEERR_NOMEM;
        }

        ZeroMemory( pCallForwardParams, sizeof(CALLFORWARDPARAMS) );

        //Forward all calls unconditionally, irrespective of their origin.
        pCallForwardParams->fForwardForAllOrigins = TRUE;
        pCallForwardParams->dwForwardTypeForAllOrigins =
            pLineForwardStruct->dwForwardMode;

        //set the diverted-to alias
        pCallForwardParams->divertedToAlias.wType = wAliasType;
        pCallForwardParams->divertedToAlias.wPrefixLength = 0;
        pCallForwardParams->divertedToAlias.pPrefix = NULL;
        pCallForwardParams->divertedToAlias.wDataLength = 
            (WORD)wcslen(pwszDestAddr);// UNICODE character count
        pCallForwardParams->divertedToAlias.pData =  pwszDestAddr;

        //enable forwarding
        pCallForwardParams->fForwardingEnabled = TRUE;

        *ppForwardParams = (PVOID)pCallForwardParams;
        *pEvent = TSPI_LINEFORWARD_NOSPECIFIC;
        
        break;

    case LINEFORWARDMODE_BUSYNASPECIFIC:
    case LINEFORWARDMODE_UNCONDSPECIFIC:
    case LINEFORWARDMODE_BUSYSPECIFIC:
    case LINEFORWARDMODE_NOANSWSPECIFIC:

        if( pLineForwardStruct-> dwCallerAddressSize == 0 )
        {
            delete pAllocAddrBuffer;
            return LINEERR_INVALPARAM;
        }

        /*if( g_pH323Line->ForwardEnabledForAllOrigins() )
        {
            //specific forward can't be enabled when non-specific forward for
            //all caller addresses is enabled
            delete pAllocAddrBuffer;
            return LINEERR_INVALPARAM;
        }*/

        pForwardAddress = new FORWARDADDRESS;
        if( pForwardAddress == NULL )
        {
            delete pAllocAddrBuffer;
            return LINEERR_NOMEM;
        }

        ZeroMemory( pForwardAddress, sizeof(FORWARDADDRESS) );
        pForwardAddress->dwForwardType = pLineForwardStruct->dwForwardMode;

        //set the caller alias(alias to be forward).
        pForwardAddress->callerAlias.wType = h323_ID_chosen;
        
		pForwardAddress->callerAlias.pData = 
			(WCHAR*)new BYTE[pLineForwardStruct-> dwCallerAddressSize];
		if( pForwardAddress->callerAlias.pData == NULL )
		{
			delete pForwardAddress;
            delete pAllocAddrBuffer;
            return LINEERR_NOMEM;
		}

        CopyMemory( pForwardAddress->callerAlias.pData,
            (BYTE*)lpLineForwardList + pLineForwardStruct->dwCallerAddressOffset,
            pLineForwardStruct-> dwCallerAddressSize );

        pForwardAddress->callerAlias.wDataLength = 
            (WORD)wcslen( pForwardAddress->callerAlias.pData );

        //set the diverted-to alias.
        pForwardAddress->divertedToAlias.wType = wAliasType;
        pForwardAddress->divertedToAlias.wDataLength = 
            (WORD)wcslen( pwszDestAddr );
        pForwardAddress->divertedToAlias.pData =  pwszDestAddr;

        //set the diverted-to address
        /*pForwardAddress->saDivertedToAddr.sin_family = AF_INET;
        pForwardAddress->saDivertedToAddr.sin_addr.S_un.S_addr
            = htonl( m_CalleeAddr.Addr.IP_Binary.dwAddr );
        pForwardAddress->saDivertedToAddr.sin_port = 
            htons( m_CalleeAddr.Addr.IP_Binary.wPort );*/

        //here we could have a for loop and process multiple pLineForwardStructs
        
        //post the event for line forward
        *ppForwardParams = (PVOID)pForwardAddress;
        *pEvent = TSPI_LINEFORWARD_SPECIFIC;

        break;

    case LINEFORWARDMODE_UNCONDINTERNAL:
    case LINEFORWARDMODE_UNCONDEXTERNAL:
    case LINEFORWARDMODE_BUSYINTERNAL:
    case LINEFORWARDMODE_BUSYEXTERNAL:
    case LINEFORWARDMODE_NOANSWINTERNAL:
    case LINEFORWARDMODE_NOANSWEXTERNAL:
    case LINEFORWARDMODE_BUSYNAINTERNAL:
    case LINEFORWARDMODE_BUSYNAEXTERNAL:
        delete pAllocAddrBuffer;
        return LINEERR_INVALPARAM;

    default:
        delete pAllocAddrBuffer;
        return LINEERR_INVALPARAM;
    }

    return ERROR_SUCCESS;
}


void
CH323Call::Forward( 
    DWORD    event, 
    PVOID    pForwardInfo
    )
{
    WCHAR * pwszDialableAddr;
    WCHAR * wszMachineName;
    WORD    wAliasType = h323_ID_chosen;

    if( event == TSPI_LINEFORWARD_SPECIFIC )
    {
        m_pForwardAddress = (LPFORWARDADDRESS)pForwardInfo;
        pwszDialableAddr = m_pForwardAddress->divertedToAlias.pData;
        wAliasType = m_pForwardAddress->divertedToAlias.wType;
    }
    else if( event == TSPI_LINEFORWARD_NOSPECIFIC )
    {
        m_pCallForwardParams = (CALLFORWARDPARAMS*)pForwardInfo;
        pwszDialableAddr = m_pCallForwardParams->divertedToAlias.pData;
        wAliasType = m_pCallForwardParams->divertedToAlias.wType;
    }
    else
    {
        // Wrong event, shouldn't get
        // here at all...
        return;
    }

    _ASSERTE( pwszDialableAddr );
    //set the values for m_pCalleeAliasNames
    if( !AddAliasItem( m_pCalleeAliasNames,
            (BYTE*)(pwszDialableAddr),
            sizeof(WCHAR) * (wcslen(pwszDialableAddr) + 1 ),
            wAliasType ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate callee name." ));

        DropCall( 0 );
    }
        
    if( RasIsRegistered() )
    {
        PH323_ALIASNAMES pAliasList = RASGetRegisteredAliasList();
    
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
        if( !AddAliasItem( m_pCallerAliasNames,
            pAliasList->pItems[0].pData,
            pAliasList->pItems[0].wType ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));

            DropCall( 0 );
        }
        //set the value of m_pCalleeAddr
        else if( !SendARQ( NOT_RESEND_SEQ_NUM ) )
        {
            // drop call using disconnect mode
            DropCall( 0 );
        }
            
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }
    else
    {
        wszMachineName = g_pH323Line->GetMachineName();
    
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
        //set the value for m_pCallerAliasNames
        if( !AddAliasItem( m_pCallerAliasNames,
            (BYTE*)(wszMachineName),
            sizeof(WCHAR) * (wcslen(wszMachineName) + 1 ),
            h323_ID_chosen ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));

            DropCall( 0 );
        }
        else if( !PlaceCall() )
        {
            // drop call using disconnect mode
            DropCall( LINEDISCONNECTMODE_UNREACHABLE );
        }
            
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }
}


//returns the alias of the divertedTo endpoint
PH323_ALIASITEM
CH323Line::CallToBeDiverted(
    IN WCHAR* pwszCallerName,
    IN DWORD  dwCallerNameSize,
    IN DWORD dwForwardMode
    )
{
    LPFORWARDADDRESS    pForwardAddress;
    DWORD               dwForwardCallerLength;

    H323DBG(( DEBUG_LEVEL_TRACE, "CallToBeDiverted entered:%p.", this ));
    
    if( (m_pCallForwardParams == NULL) || 
        (!m_pCallForwardParams->fForwardingEnabled) )
    {
        return NULL;
    }

    if( m_pCallForwardParams->fForwardForAllOrigins == TRUE )
    {
        if( m_pCallForwardParams->dwForwardTypeForAllOrigins & dwForwardMode )
        {
            return &(m_pCallForwardParams->divertedToAlias);
        }
        
        if( m_pCallForwardParams->dwForwardTypeForAllOrigins == 
            LINEFORWARDMODE_BUSYNA )
        {
            if( (dwForwardMode == LINEFORWARDMODE_BUSY) ||
                (dwForwardMode == LINEFORWARDMODE_NOANSW) )
            {
                return &(m_pCallForwardParams->divertedToAlias);
            }
        }
    }

    if( pwszCallerName == NULL )
    {
        return NULL;
    }

    pForwardAddress = m_pCallForwardParams->pForwardedAddresses;

    while( pForwardAddress )
    {
        dwForwardCallerLength = (pForwardAddress->callerAlias.wDataLength +1)*sizeof(WCHAR);

        if( (dwForwardCallerLength == dwCallerNameSize) && 
            (memcmp( pwszCallerName, (PVOID)(pForwardAddress->callerAlias.pData), 
                dwCallerNameSize) == 0 ) )
        {
            if( pForwardAddress->dwForwardType & dwForwardMode )
                return &(pForwardAddress->divertedToAlias);

            if( pForwardAddress->dwForwardType == LINEFORWARDMODE_BUSYNA )
            {
                if( (dwForwardMode == LINEFORWARDMODE_BUSY) ||
                    (dwForwardMode == LINEFORWARDMODE_NOANSW) )
                {
                    return &(pForwardAddress->divertedToAlias);
                }
            }

            return NULL;
        }

        pForwardAddress = pForwardAddress->next;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CallToBeDiverted exited:%p.", this ));
    return NULL;
}

LONG 
TSPIAPI 
TSPI_lineSetStatusMessages(
                            HDRVLINE hdLine,    
                            DWORD dwLineStates,
                            DWORD dwAddressStates  
                          )
{

    return NOERROR;
}


#if   DBG

DWORD
SendMSPMessageOnRelatedCall(
	IN PVOID ContextParameter
    )
{
    __try
    {
        return SendMSPMessageOnRelatedCallFre( ContextParameter );
    }
    __except( 1 )
    {
        MSPMessageData* pMSPMessageData = (MSPMessageData*)ContextParameter;
        
        H323DBG(( DEBUG_LEVEL_TRACE, 
            "TSPI event threw exception: %p, %d, %p, %d, %p.",
            pMSPMessageData -> hdCall,
            pMSPMessageData -> messageType,
            pMSPMessageData -> pbEncodedBuf,
            pMSPMessageData -> wLength,
            pMSPMessageData -> hReplacementCall ));
        
        _ASSERTE( FALSE );
                
        return 0;
    }
}

#endif


DWORD
SendMSPMessageOnRelatedCallFre(
    IN PVOID ContextParameter
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SendMSPMessageOnRelatedCall entered." ));

    _ASSERTE( ContextParameter );
    MSPMessageData* pMSPMessageData = (MSPMessageData*)ContextParameter;

    PH323_CALL pCall = NULL;

    pCall = g_pH323Line->FindH323CallAndLock(pMSPMessageData -> hdCall);
    if( pCall != NULL )
    {
        pCall -> SendMSPMessage( pMSPMessageData->messageType, 
            pMSPMessageData->pbEncodedBuf, pMSPMessageData->wLength,
            pMSPMessageData->hReplacementCall );

        pCall -> Unlock();
    }

    if( pMSPMessageData->pbEncodedBuf != NULL )
    {
        delete pMSPMessageData->pbEncodedBuf;
    }
    
    delete pMSPMessageData;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SendMSPMessageOnRelatedCall exited." ));
    return EXIT_SUCCESS;
}

        
// static
void
NTAPI CH323Call::CTIdentifyExpiredCallback(
    IN PVOID	DriverCallHandle,		// HDRVCALL
    IN BOOLEAN bTimer
    )
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentifyExpiredCallback entered." ));
    
    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentity expired event recvd." ));
    pCall=g_pH323Line -> FindH323CallAndLock((HDRVCALL) DriverCallHandle);
    if( pCall != NULL )
    {
        pCall -> CTIdentifyExpired();           
        pCall -> Unlock();
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentifyExpiredCallback exited." ));
}


// static
void
NTAPI CH323Call::CTIdentifyRRExpiredCallback(
    IN PVOID	DriverCallHandle,		// HDRVCALL
    IN BOOLEAN bTimer
    )
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentifyRRExpiredCallback entered." ));
    
    //if the timer expired
    _ASSERTE( bTimer );
    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentity expired event recvd." ));
    
    pCall=g_pH323Line -> FindH323CallAndLock((HDRVCALL) DriverCallHandle);
    
    if( pCall != NULL )
    {
        pCall -> CTIdentifyRRExpired();           
        pCall -> Unlock();
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentifyRRExpiredCallback exited." ));
}


// static
void
NTAPI CH323Call::CTInitiateExpiredCallback(
    IN PVOID	DriverCallHandle,		// HDRVCALL
    IN BOOLEAN bTimer
    )
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CTInitiateExpiredCallback entered." ));
    
    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "CTInitiate expired event recvd." ));
    
    if( !QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            (HDRVCALL)DriverCallHandle,
            NULL,
            LINEDISCONNECTMODE_NOANSWER,
            NULL) )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "could not post close call event." ));
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CTInitiateExpiredCallback exited." ));
}


void
CH323Call::CTIdentifyExpired()
{
    if( m_hCTIdentifyTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyTimer, NULL );
        m_hCTIdentifyTimer = NULL;
    }

    if( m_dwCallDiversionState !=  H4502_CIIDENTIFY_RRSUCC )
    {
        CloseCall( 0 );
    }
}


void
CH323Call::CTIdentifyRRExpired()
{
    if( m_hCTIdentifyRRTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyRRTimer, NULL );
        m_hCTIdentifyRRTimer = NULL;
    }

    if( m_dwCallDiversionState !=  H4502_CTSETUP_RECV )
    {
        CloseCall( 0 );
    }
}


void
NTAPI CH323Call::CallDivertOnNACallback(
                                        IN PVOID   Parameter1,
                                        IN BOOLEAN bTimer
                                       )
{
    PH323_CALL pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CallDivertOnNACallback entered." ));

    //if the timer expired
    _ASSERTE( bTimer );

    pCall=g_pH323Line -> FindH323CallAndLock( (HDRVCALL)Parameter1 );
    
    if( pCall != NULL )
    {
        pCall -> CallDivertOnNoAnswer();
    }
    pCall -> Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CallDivertOnNACallback exited." ));
}


//!!always called in a lock
void
CH323Call::CallDivertOnNoAnswer()
{
    //stop the timer that caused this event
    if( m_hCallDivertOnNATimer != NULL )
    {
        DeleteTimerQueueTimer(H323TimerQueue, m_hCallDivertOnNATimer, NULL);
        m_hCallDivertOnNATimer = NULL;
    }

    //Make sure that the call is still alerting, it has not ben accepted and
    //it has not been transfered in the mean time
    if( (m_dwCallState != LINECALLSTATE_OFFERING) ||
        (m_fCallAccepted == TRUE) ||
        (m_dwCallType & CALLTYPE_TRANSFERED2_CONSULT)
      )
    {
        return;
    }

    //divert the call. divertedToAlias is already set, so pass NULL
    if( !InitiateCallDiversion( NULL, DiversionReason_cfnr) )
    {
        //shutdown the Q931 call
        CloseCall( 0 );
    }
}


BOOL
CH323Call::SendCTInitiateMessagee(
    IN CTIdentifyRes * pCTIdentifyRes
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SendCTInitiateMessagee entered:%p.", this ));
    
    //get the cookie for transferred call
    CopyMemory( (PVOID)m_pCTCallIdentity, (PVOID)pCTIdentifyRes->callIdentity,
        sizeof(pCTIdentifyRes->callIdentity) );

    if( m_pTransferedToAlias != NULL )
    {
        FreeAliasNames( m_pTransferedToAlias );
        m_pTransferedToAlias = NULL;
    }

    //argument.reroutingNr
    if( !AliasAddrToAliasNames( &m_pTransferedToAlias,
        (PSetup_UUIE_sourceAddress)
        (pCTIdentifyRes->reroutingNumber.destinationAddress) ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "couldn't allocate for T-2 alias:%p.", this ));
        return FALSE;
    }

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCTIdentifyRes,
        CTIdentifyRes_PDU );

    if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
            CTINITIATE_OPCODE | H450_INVOKE ) )
    {
        return FALSE;
    }

    m_dwCallDiversionState = H4502_CTINITIATE_SENT;
        
    //start the timer for CTIdenity message
    if( !CreateTimerQueueTimer(
	        &m_hCTInitiateTimer,
	        H323TimerQueue,
	        CH323Call::CTInitiateExpiredCallback,
	        (PVOID)m_hdCall,
	        CTINITIATE_SENT_TIMEOUT, 0,
	        WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE) )
    {
        CloseCall( 0 );
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendCTInitiateMessagee exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::InitiateCallDiversion(
    IN PH323_ALIASITEM pwszDivertedToAlias,
    IN DiversionReason eDiversionMode
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "InitiateCallDiversion entered:%p.", this ));
    
    m_dwCallType |= CALLTYPE_DIVERTED_SERVED;

    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;
        if( m_pCallReroutingInfo == NULL )
        {
            return FALSE;
        }
        ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }

    m_pCallReroutingInfo ->diversionReason = eDiversionMode;
    
    m_pCallReroutingInfo->divertingNrAlias = new H323_ALIASNAMES;
    if( m_pCallReroutingInfo->divertingNrAlias == NULL )
    {
        goto cleanup;
    }
    
    ZeroMemory( (PVOID)m_pCallReroutingInfo->divertingNrAlias, 
        sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( m_pCallReroutingInfo->divertingNrAlias, 
        (BYTE*)m_pCalleeAliasNames->pItems[0].pData, 
        sizeof(WCHAR) * (m_pCalleeAliasNames->pItems[0].wDataLength+1),
        m_pCalleeAliasNames->pItems[0].wType ) )
    {
        goto cleanup;
    }
    
    if( m_pCallReroutingInfo->originalCalledNr == NULL )
    {
        m_pCallReroutingInfo->originalCalledNr = new H323_ALIASNAMES;
        if( m_pCallReroutingInfo->originalCalledNr == NULL )
        {
            goto cleanup;
        }
        ZeroMemory( (PVOID)m_pCallReroutingInfo->originalCalledNr, 
            sizeof(H323_ALIASNAMES) );

        if( !AddAliasItem( 
                m_pCallReroutingInfo->originalCalledNr, 
                (BYTE*)m_pCalleeAliasNames->pItems[0].pData, 
                sizeof(WCHAR) * (m_pCalleeAliasNames->pItems[0].wDataLength+1),
                m_pCalleeAliasNames->pItems[0].wType )
          )
        {
            goto cleanup;
        }
    }

    if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
    {
        _ASSERTE( pwszDivertedToAlias );

        m_pCallReroutingInfo->divertedToNrAlias = new H323_ALIASNAMES;
        
        if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
        {
            goto cleanup;
        }
        ZeroMemory( (PVOID)m_pCallReroutingInfo->divertedToNrAlias, 
            sizeof(H323_ALIASNAMES) );

        if( !AddAliasItem( m_pCallReroutingInfo->divertedToNrAlias, 
            (BYTE*)pwszDivertedToAlias->pData, 
            sizeof(WCHAR) * (wcslen(pwszDivertedToAlias->pData) +1),
            pwszDivertedToAlias->wType
            ) )
        {
            goto cleanup;
        }
    }

    if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
        CALLREROUTING_OPCODE | H450_INVOKE ) )
    {
        goto cleanup;
    }

    m_dwCallDiversionState = H4503_CALLREROUTING_SENT;

    if( !CreateTimerQueueTimer(
	        &m_hCallReroutingTimer,
	        H323TimerQueue,
            CH323Call::CallReroutingTimerCallback,
	        (PVOID)m_hdCall,
	        CALLREROUTING_EXPIRE_TIME, 0,
	        WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE) )
    {
        goto cleanup;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "InitiateCallDiversion exited:%p.", this ));
    return TRUE;

cleanup:
    
    FreeCallReroutingInfo();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\config.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    TAPI Service Provider functions related to tsp config.

        TSPI_providerConfig

        TUISPI_providerConfig

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "config.h"
#include "ras.h"
#include "q931obj.h"

extern RAS_CLIENT           g_RasClient;
extern Q931_LISTENER		Q931Listener;

TUISPIDLLCALLBACK    g_pfnUIDLLCallback = NULL;

typedef struct _H323_DIALOG_DATA
{
    DWORD   dwRegState;
    WORD    wListenPort;

} H323_DIALOG_DATA, *PH323_DIALOG_DATA;

//                                                                           
// Public procedures                                                         
//                                                                           


INT_PTR
CALLBACK
ProviderConfigDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HKEY hKey;
    LONG lStatus;
    DWORD dwValue;
    DWORD dwValueSize;
    DWORD dwValueType;
    DWORD dwGKEnabled;
    LPTSTR pszValue;
    TCHAR szAddr[H323_MAXPATHNAMELEN+1];
    char  szValue[H323_MAXPATHNAMELEN+1];
    TCHAR szErrorMsg[H323_MAXPATHNAMELEN];
    H323_DIALOG_DATA DialogData;
    DWORD dwTimeoutValue;
    DWORD dwPortValue;

   static const DWORD IDD_GATEWAY_HelpIDs[]=
   {
        IDC_GATEWAY_GROUP,      IDH_H323SP_USE_GATEWAY,                         // group
        IDC_USEGATEWAY,         IDH_H323SP_USE_GATEWAY,                         // checkbox
        IDC_H323_GATEWAY,       IDH_H323SP_USE_GATEWAY_COMPUTER,    // edit box
        IDC_PROXY_GROUP,        IDH_H323SP_USE_PROXY,                           // group
        IDC_USEPROXY,           IDH_H323SP_USE_PROXY,                           // checkbox
        IDC_H323_PROXY,         IDH_H323SP_USE_PROXY_COMPUTER,      // edit box

        IDC_GK_GROUP,           IDH_H323SP_GK_GROUP,           

        IDC_H323_GK,            IDH_H323SP_GK,            
        IDC_H323_GK_PHONE,      IDH_H323SP_GK_PHONE,      
        IDC_H323_GK_ACCT,       IDH_H323SP_GK_ACCT,       

        IDC_USEGK,              IDH_H323SP_USEGK,              
        IDC_USEGK_PHONE,        IDH_H323SP_USEGK_PHONE,        
        IDC_USEGK_ACCT,         IDH_H323SP_USEGK_ACCT,         
        IDC_REGSTATE,           IDH_H323SP_REGSTATE,           
        IDUPDATE,               IDH_H323SP_UPDATE_REGISTRATION_STATE,             

        IDC_CC_GROUP,           IDH_H323SP_CC_GROUP,           
        IDC_H323_CALL_TIMEOUT,  IDH_H323SP_CALL_TIMEOUT,  
        IDC_STATIC1,            IDH_H323SP_CALL_TIMEOUT,  
        IDC_H323_CALL_PORT,     IDH_H323SP_CALL_PORT,     
        IDC_STATIC2,            IDH_H323SP_CALL_PORT,     
        IDC_LISTENPORT,         IDH_H323SP_CURRENT_LISTENPORT,         
        IDC_STATIC3,            IDH_H323SP_CURRENT_LISTENPORT,         
        IDUPDATE_PORT,          IDH_H323SP_UPDATE_PORT,        

        IDC_STATIC,             IDH_NOHELP,                                                     // graphic(s)
        0,                      0
    };

    // decode
    switch (uMsg)
    {
    case WM_HELP:

        // F1 key or the "?" button is pressed
        (void) WinHelp(
                    (HWND)(((LPHELPINFO) lParam)->hItemHandle),
                    H323SP_HELP_FILE,
                    HELP_WM_HELP,
                    (DWORD_PTR) (LPVOID)IDD_GATEWAY_HelpIDs
                    );

        break;

    case WM_CONTEXTMENU:

        // Right-mouse click on a dialog control
        (void) WinHelp(
                    (HWND) wParam,
                    H323SP_HELP_FILE,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR) (LPVOID) IDD_GATEWAY_HelpIDs
                    );

        break;

    case WM_INITDIALOG:

        lStatus = (*g_pfnUIDLLCallback)(
            g_dwPermanentProviderID,
            TUISPIDLL_OBJECT_PROVIDERID,
            (LPVOID)&DialogData,
            sizeof(DialogData) );

        // validate status
        if( lStatus == NOERROR )
        {
            if( DialogData.dwRegState == RAS_REGISTER_STATE_REGISTERED )
            {
                // load status string
                LoadString(g_hInstance,
                        IDS_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

                SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            }
            else if( DialogData.dwRegState == RAS_REGISTER_STATE_RRQSENT )
            {
                // load status string
                LoadString(g_hInstance,
                        IDS_REGISTRATION_INPROGRESS,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

                SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            }
            else
            {
                // load status string
                LoadString(g_hInstance,
                        IDS_NOT_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

                SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            }
        
            if( DialogData.wListenPort != 0 )
            {
                SetDlgItemInt( hDlg, IDC_LISTENPORT,  DialogData.wListenPort,
                    FALSE );
            }
            else
            {
                // load status string
                LoadString( g_hInstance,
                            IDS_NONE,
                            szErrorMsg,
                            H323_MAXPATHNAMELEN
                          );

                SetDlgItemText( hDlg, IDC_LISTENPORT, szErrorMsg );

            }
        }
        else
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "error 0x%08lx reading dialog data.\n", lStatus ));

            // load status string
            LoadString( g_hInstance,
                        IDS_NOT_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                      );

            SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            
            // load status string
            LoadString( g_hInstance,
                        IDS_NONE,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                      );

            SetDlgItemText( hDlg, IDC_LISTENPORT, szErrorMsg );
        }

        // open registry subkey
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    H323_REGKEY_ROOT,
                    0,
                    KEY_READ,
                    &hKey
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            H323DBG(( DEBUG_LEVEL_WARNING,
                "error 0x%08lx opening tsp registry key.", lStatus ));

            // load error string
            LoadString(g_hInstance,
                        IDS_REGOPENKEY,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

            // pop up error dialog
            MessageBox(hDlg,szErrorMsg,NULL,MB_OK);

            // stop dialog
            EndDialog(hDlg, 0);

            break;
        }

        // initialize value name
        pszValue = H323_REGVAL_Q931ALERTINGTIMEOUT;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if( lStatus == ERROR_SUCCESS )
        {
            if( (dwValue >= 30000) && (dwValue <= CALL_ALERTING_TIMEOUT) )
            {
                SetDlgItemInt( hDlg, IDC_H323_CALL_TIMEOUT, dwValue, FALSE );
            }
        }
        else
        {
            SetDlgItemInt( hDlg, IDC_H323_CALL_TIMEOUT, CALL_ALERTING_TIMEOUT,
                FALSE );
        }

        // initialize value name
        pszValue = H323_REGVAL_Q931LISTENPORT;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if( lStatus == ERROR_SUCCESS )
        {
            if( (dwValue >= 1000) && (dwValue <= 32000) )
            {
                SetDlgItemInt( hDlg, IDC_H323_CALL_PORT, dwValue, FALSE );
            }
        }
        else
        {
            SetDlgItemInt( hDlg, IDC_H323_CALL_PORT, Q931_CALL_PORT, FALSE );
        }

        // initialize value name
        pszValue = H323_REGVAL_GATEWAYADDR;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize
                    );

        // validate return code
        if( lStatus == ERROR_SUCCESS )
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GATEWAY,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GATEWAYENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGATEWAY,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GATEWAY), (dwValue != 0) );

        // initialize value name
        pszValue = H323_REGVAL_PROXYADDR;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_PROXY,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_PROXYENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEPROXY,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string
        EnableWindow(
            GetDlgItem(hDlg,IDC_H323_PROXY),
            (dwValue != 0) );


        /////////////////////////////////////////////////////////////////////
                //GK log on phone number
        /////////////////////////////////////////////////////////////////////

        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_PHONE;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GK_PHONE,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_PHONEENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize );

        // validate return code
        if( lStatus != ERROR_SUCCESS )
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGK_PHONE,
            BM_SETCHECK,
            (dwValue != 0),
            0 );

        // display string
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_PHONE), (dwValue != 0) );

        /////////////////////////////////////////////////////////////////////
                //GK log on account name
        /////////////////////////////////////////////////////////////////////

        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_ACCOUNT;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GK_ACCT,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_ACCOUNTENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGK_ACCT,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string
        EnableWindow(
            GetDlgItem(hDlg,IDC_H323_GK_ACCT),
            (dwValue != 0)
            );

        /////////////////////////////////////////////////////////////////////
                //GK address
        /////////////////////////////////////////////////////////////////////

        // initialize value name
        pszValue = H323_REGVAL_GKADDR;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GK,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GKENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGK,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string if check box enabled
        EnableWindow(GetDlgItem(hDlg,IDC_H323_GK), (dwValue != 0) );

        // display log on info
        EnableWindow( GetDlgItem(hDlg,IDC_GK_LOGONGROUP), (dwValue != 0) );
                    
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_PHONE), 
            (dwValue != 0) && SendDlgItemMessage(hDlg,
                                                IDC_USEGK_PHONE,
                                                BM_GETCHECK,
                                                (WPARAM)0,
                                                (LPARAM)0 ) );
        
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_ACCT), 
            (dwValue != 0) && SendDlgItemMessage(hDlg,
                                                IDC_USEGK_ACCT,
                                                BM_GETCHECK,
                                                (WPARAM)0,
                                                (LPARAM)0 ) );

        EnableWindow( GetDlgItem(hDlg,IDC_USEGK_PHONE), (dwValue != 0) );
        
        EnableWindow( GetDlgItem(hDlg,IDC_USEGK_ACCT), (dwValue != 0) );

        //disable the GW if GK enabled and vice versa
        EnableWindow( GetDlgItem(hDlg,IDC_PROXY_GROUP), (dwValue == 0) );
        EnableWindow( GetDlgItem(hDlg,IDC_USEPROXY), (dwValue == 0) );
        EnableWindow( GetDlgItem(hDlg,IDC_H323_PROXY),
            (dwValue == 0) && SendDlgItemMessage(hDlg,
                                                IDC_USEPROXY,
                                                BM_GETCHECK,
                                                (WPARAM)0,
                                                (LPARAM)0 ) );

        //disable the proxy if GK enabled and vice versa
        EnableWindow( GetDlgItem(hDlg,IDC_GATEWAY_GROUP), (dwValue == 0) );
        EnableWindow( GetDlgItem(hDlg,IDC_USEGATEWAY), (dwValue == 0) );
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GATEWAY), 
            (dwValue == 0) && SendDlgItemMessage(hDlg,
                                                IDC_USEGATEWAY,
                                                BM_GETCHECK,
                                                (WPARAM)0,
                                                (LPARAM)0 ) );

        // close registry
        RegCloseKey(hKey);

        break;

    case WM_COMMAND:

        // decode command
        switch (LOWORD(wParam))
        {
        case IDAPPLY:
        case IDOK:

            //if GK is enabled at least one of the log on options should be enabled
            dwGKEnabled = !!SendDlgItemMessage(
                             hDlg,
                             IDC_USEGK,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0 );

            if( dwGKEnabled != 0 )
            {
                if(
                    !SendDlgItemMessage(hDlg, IDC_USEGK_PHONE, BM_GETCHECK, (WPARAM)0, (LPARAM)0 ) &&
                    !SendDlgItemMessage(hDlg, IDC_USEGK_ACCT, BM_GETCHECK, (WPARAM)0, (LPARAM)0 )
                  )
                {
                    //load error string
                    LoadString(g_hInstance,
                               IDS_GKLOGON_ERROR,
                               szErrorMsg,
                               H323_MAXPATHNAMELEN );

                    MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                    //return failure
                    return TRUE;
                }
            }
            
            dwTimeoutValue = GetDlgItemInt( hDlg,
                IDC_H323_CALL_TIMEOUT,
                NULL,
                FALSE );

            if( (dwTimeoutValue < 30000) || (dwTimeoutValue > CALL_ALERTING_TIMEOUT) )
            {
                //load error string
                LoadString(g_hInstance,
                           IDS_ALERTTIMEOUT_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }
            
            dwPortValue = GetDlgItemInt( hDlg,
                IDC_H323_CALL_PORT,
                NULL,
                FALSE );

            if( (dwPortValue < 1000) || (dwPortValue > 32000) )
            {
                //load error string
                LoadString(g_hInstance,
                           IDS_LISTENPORT_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }
            
            // open registry subkey
            lStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        H323_REGKEY_ROOT,
                        0,
                        KEY_WRITE,
                        &hKey
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_WARNING,
                    "error 0x%08lx opening tsp registry key.",
                    lStatus ));

                // load error string
                LoadString(g_hInstance,
                           IDS_REGOPENKEY,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                // pop up error dialog
                MessageBox(hDlg,szErrorMsg,NULL,MB_OK);

                // stop dialog
                EndDialog(hDlg, 0);

                break;
            }

            // initialize value name
            pszValue = H323_REGVAL_Q931ALERTINGTIMEOUT;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);
            
            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwTimeoutValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG(( DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing alerting timeout.",
                    lStatus ));
            }
            
            // initialize value name
            pszValue = H323_REGVAL_Q931LISTENPORT;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);
            
            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwPortValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG(( DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing alerting timeout.",
                    lStatus ));
            }
            
            // initialize value name
            pszValue = H323_REGVAL_GATEWAYADDR;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GATEWAY,szAddr, H323_MAXDESTNAMELEN );

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gateway address.",
                    lStatus
                    ));
            }
            
            // initialize value name
            pszValue = H323_REGVAL_GATEWAYENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEGATEWAY,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            if( (dwValue!=0) && (wcslen(szAddr)==0) && 
                !SendDlgItemMessage(hDlg,IDC_USEGK,BM_GETCHECK,0,0) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_GWALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gateway flag.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_PROXYADDR;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_PROXY,szAddr, H323_MAXDESTNAMELEN );

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing proxy address.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_PROXYENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEPROXY,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            if( (dwValue!=0) && (wcslen(szAddr)==0) &&
                !SendDlgItemMessage(hDlg,IDC_USEGK,BM_GETCHECK,0,0) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_PROXYALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing proxy flag.",
                    lStatus
                    ));
            }

            /////////////////////////////////////////////////////////////////////
                    //GK address
            /////////////////////////////////////////////////////////////////////

            // initialize value name
            pszValue = H323_REGVAL_GKADDR;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GK,szAddr, H323_MAXDESTNAMELEN);

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper address.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_GKENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            if( dwGKEnabled && (wcslen(szAddr)==0) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_GKALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwGKEnabled,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper flag.",
                    lStatus
                    ));
            }

                        /////////////////////////////////////////////////////////////////////
                    //GK log on phone
            /////////////////////////////////////////////////////////////////////

            // initialize value name
            pszValue = H323_REGVAL_GKLOGON_PHONEENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEGK_PHONE,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper flag.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_GKLOGON_PHONE;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GK_PHONE,szAddr, H323_MAXDESTNAMELEN);

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            //check if logon-phone option is enabled and logon-phone alias is empty
            if( dwGKEnabled && dwValue && (dwValueSize == sizeof(WCHAR)) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_GKLOGON_PHONEALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            //validate e164
            if( IsValidE164String(szAddr) == FALSE )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_PHONEALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }
            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper address.",
                    lStatus
                    ));
            }


            /////////////////////////////////////////////////////////////////////
                    //GK log on account
            /////////////////////////////////////////////////////////////////////

            // initialize value name
            pszValue = H323_REGVAL_GKLOGON_ACCOUNTENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEGK_ACCT,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper flag.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_GKLOGON_ACCOUNT;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GK_ACCT,szAddr, H323_MAXDESTNAMELEN );

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            //check if logon-acct option is enabled and logon-acct alias in empty
            if( dwGKEnabled && dwValue && (dwValueSize==sizeof(WCHAR)) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_GKLOGON_ACCTALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper address.",
                    lStatus
                    ));
            }

            // close registry
            RegCloseKey(hKey);

            if( LOWORD(wParam) == IDOK )
            {
                // close dialog
                EndDialog(hDlg, 0);
            }
            break;

        case IDCANCEL:

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDUPDATE:

            lStatus = (*g_pfnUIDLLCallback)(
                g_dwPermanentProviderID,
                TUISPIDLL_OBJECT_PROVIDERID,
                (LPVOID)&DialogData,
                sizeof(DialogData) );

            // validate status
            if( lStatus == NOERROR )
            {
                if( DialogData.dwRegState == RAS_REGISTER_STATE_REGISTERED )
                {
                    LoadString( g_hInstance,
                        IDS_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

                    SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
                }
                else if( DialogData.dwRegState == RAS_REGISTER_STATE_RRQSENT )
                {
                    LoadString( g_hInstance,
                        IDS_REGISTRATION_INPROGRESS,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                      );

                    SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
                }
                else
                {
                    LoadString( g_hInstance,
                        IDS_NOT_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                      );

                    SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
                }
            }
            else
            {
                H323DBG(( DEBUG_LEVEL_ERROR,
                    "error 0x%08lx reading dialog data.\n", lStatus ));

                LoadString( g_hInstance,
                    IDS_NOT_REGISTERED,
                    szErrorMsg,
                    H323_MAXPATHNAMELEN
                  );

                SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            }
            break;

        case IDUPDATE_PORT:
            
            lStatus = (*g_pfnUIDLLCallback)(
                g_dwPermanentProviderID,
                TUISPIDLL_OBJECT_PROVIDERID,
                (LPVOID)&DialogData,
                sizeof(DialogData) );

            // validate status
            if( (lStatus == NOERROR) && (DialogData.wListenPort != 0) )
            {
                SetDlgItemInt( hDlg, IDC_LISTENPORT,  DialogData.wListenPort,
                    FALSE );
            }
            else
            {
                H323DBG(( DEBUG_LEVEL_FORCE,
                    "error 0x%08lx reading dialog data.\n", lStatus ));

                LoadString( g_hInstance,
                     IDS_NONE,
                     szErrorMsg,
                     H323_MAXPATHNAMELEN
                   );

                SetDlgItemText( hDlg, IDC_LISTENPORT, szErrorMsg );
            }

            break;

        case IDC_USEGATEWAY:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_GATEWAY),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEGATEWAY,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));
            break;

        case IDC_USEPROXY:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_PROXY),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEPROXY,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));
            break;

        case IDC_USEGK:

            dwValue= !!SendDlgItemMessage(
                             hDlg,
                             IDC_USEGK,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0 );

            // display string if check box enabled
            EnableWindow( GetDlgItem( hDlg, IDC_H323_GK ), (dwValue != 0) );

            // display log on info
            EnableWindow( GetDlgItem(hDlg,IDC_GK_LOGONGROUP), (dwValue != 0) );
                        
            EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_PHONE), 
                (dwValue != 0) && SendDlgItemMessage(hDlg,
                                                    IDC_USEGK_PHONE,
                                                    BM_GETCHECK,
                                                    (WPARAM)0,
                                                    (LPARAM)0 ) );
            
            EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_ACCT), 
                (dwValue != 0) && SendDlgItemMessage(hDlg,
                                                    IDC_USEGK_ACCT,
                                                    BM_GETCHECK,
                                                    (WPARAM)0,
                                                    (LPARAM)0 ) );

            EnableWindow( GetDlgItem(hDlg,IDC_USEGK_PHONE), (dwValue != 0) );
            
            EnableWindow( GetDlgItem(hDlg,IDC_USEGK_ACCT), (dwValue != 0) );

            //disable the GW if GK enabled and vice versa
            EnableWindow( GetDlgItem(hDlg,IDC_PROXY_GROUP), (dwValue == 0) );
            EnableWindow( GetDlgItem(hDlg,IDC_USEPROXY), (dwValue == 0) );
            EnableWindow( GetDlgItem(hDlg,IDC_H323_PROXY),
                (dwValue == 0) && SendDlgItemMessage(hDlg,
                                                    IDC_USEPROXY,
                                                    BM_GETCHECK,
                                                    (WPARAM)0,
                                                    (LPARAM)0 ) );

            //disable the proxy if GK enabled and vice versa
            EnableWindow( GetDlgItem(hDlg,IDC_GATEWAY_GROUP), (dwValue == 0) );
            EnableWindow( GetDlgItem(hDlg,IDC_USEGATEWAY), (dwValue == 0) );
            EnableWindow( GetDlgItem(hDlg,IDC_H323_GATEWAY), 
                (dwValue == 0) && SendDlgItemMessage(hDlg,
                                                    IDC_USEGATEWAY,
                                                    BM_GETCHECK,
                                                    (WPARAM)0,
                                                    (LPARAM)0 ) );

            break;

        case IDC_USEGK_PHONE:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_GK_PHONE),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEGK_PHONE,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));
            break;

        case IDC_USEGK_ACCT:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_GK_ACCT),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEGK_ACCT,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));
            break;
        }

        break;
    }

    // success
    return FALSE;
}



//                                                                           //
// TSPI procedures                                                           //
//                                                                           //


LONG
TSPIAPI
TSPI_providerConfig(
    HWND  hwndOwner,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    The original TSPI UI-generating functions (TSPI_lineConfigDialog,
    TSPI_lineConfigDialogEdit, TSPI_phoneConfigDialog, TSPI_providerConfig,
    TSPI_providerInstall, and TSPI_providerRemove) are obsolete and will
    never be called by TAPISRV.EXE.  However, if the service provider desires
    to be listed as one that can be added by the Telephony control panel,
    it must export TSPI_providerInstall; if it wants to have the Remove
    button enabled in the Telephony CPL when it is selected, it must export
    TSPI_providerRemove, and it if wants the Setup button to be enabled
    in the Telephony CPL when it is selected, it must export
    TSPI_providerConfig.

    The Telephony CPL checks for the presence of these functions in the
    service provider TSP file in order to adjust its user interface to
    reflect which operations can be performed.

    See TUISPI_lineConfigDialog for dialog code.

Arguments:

    hwndOwner - Specifies the handle of the parent window in which the function
        may create any dialog windows required during the configuration.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        configured.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);              // no dialog here
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // not needed anymore

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineProviderConfig - Entered." ));
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineProviderConfig - Exited." ));
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND              hwndOwner,
    DWORD             dwPermanentProviderID
    )
{
    INT_PTR nResult;

    g_pfnUIDLLCallback = pfnUIDLLCallback;
    g_dwPermanentProviderID = dwPermanentProviderID;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerConfig - Entered." ));
    
    // invoke dialog box
    nResult = DialogBoxW(
                g_hInstance,
                MAKEINTRESOURCE(IDD_TSPCONFIG),
                hwndOwner,
                ProviderConfigDlgProc,
                );
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerConfig - Exited." ));

    // status based on whether dialog executed properly
    return ((DWORD)nResult == 0) ? NOERROR : LINEERR_OPERATIONFAILED;
}



/*++

Routine Description:
    
    The TSPI_providerGenericDialogData function delivers to the service
    provider data that was sent from the UI DLL running in an application
    context through the TUISPIDLLCALLBACK function. The contents of the
    memory block pointed to by lpParams is defined by the service provider
    and UI DLL. The service provider can modify the contents of the
    parameter block; when this function returns, TAPI copies the modified
    data back into the original UI DLL parameter block.

    Implementation is mandatory if the UI DLL associated with the service
    provider calls TUISPIDLLCALLBACK.

Arguments:

    dwObjectID - An object identifer of the type specified by dwObjectType

    dwObjectType - One of the TUISPIDLL_OBJECT_ constants, specifying the
    type of object identified by dwObjectID

        TUISPIDLL_OBJECT_LINEID - dwObjectID is a line device identifier
        (dwDeviceID).

        TUISPIDLL_OBJECT_PHONEID - dwObjectID is a phone device identifier
        (dwDeviceID)

        TUISPIDLL_OBJECT_PROVIDERID - dwObjectID is a permament provider
        identifier.

        TUISPIDLL_OBJECT_DIALOGINSTANCE - dwObjectID is an HDRVDIALOGINSTANCE,
        as returned to the service provider when it sent a
        LINE_CREATEDIALOGINSTANCE message.

    lpParams - Pointer to a memory area used to hold a parameter block. The
    contents of this parameter block are specific to the service provider
    and its associated UI DLL.

    dwSize - The size in bytes of the parameter block.

Return Values:

    Returns zero if successful, or one of these negative error values:

        LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED

--*/

LONG
TSPIAPI
TSPI_providerGenericDialogData(
    DWORD_PTR  dwObjectID,
    DWORD      dwObjectType,
    LPVOID     lpParams,
    DWORD      dwSize
    )
{
    PH323_DIALOG_DATA pDialogData = (PH323_DIALOG_DATA)lpParams;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerGenericDialogData Entered" ));

    if( (dwObjectType != TUISPIDLL_OBJECT_PROVIDERID) ||
        (dwSize != sizeof(H323_DIALOG_DATA))
      )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "Invalid message from dwObjectID 0x%08lx\n", dwObjectID ));

        // failure
        return LINEERR_INVALPARAM;
    }

    //
    // NOTE: if we want to make sure this message is from our UI DLL
    // then we cannot rely on the provider ID since this function may
    // be called before TSPI_providerInit.
    //

    // process command
    pDialogData->dwRegState = g_RasClient.GetRegState();
    pDialogData->wListenPort = Q931Listener.GetListenPort();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerGenericDialogData Exited: reg state:%d, listen port:%d",
        pDialogData->dwRegState, 
        pDialogData->wListenPort ));

    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\config.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    config.h

Abstract:

    Definitions for H.323 TAPI Service Provider UI.


Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#ifndef _INC_CONFIG
#define _INC_CONFIG


//                                                                           
// Function prototype                                                        
//                                                                           


INT_PTR
CALLBACK
ProviderConfigDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );


//                                                                           
// String definitions                                                        
//                                                                           


#define IDC_STATIC              (-1)

#define IDS_LINENAME            1
#define IDS_PROVIDERNAME        2
#define IDS_REGOPENKEY          3

#define IDS_GKLOGON_PHONEALIAS_ERROR    4
#define IDS_GKLOGON_ACCTALIAS_ERROR     5
#define IDS_GKLOGON_ERROR               6
#define IDS_PHONEALIAS_ERROR            7
#define IDS_GKALIAS_ERROR               8
#define IDS_PROXYALIAS_ERROR            9
#define IDS_GWALIAS_ERROR               20
#define IDS_ALERTTIMEOUT_ERROR          30
#define IDS_LISTENPORT_ERROR            40
#define IDS_REGISTERED                  50
#define IDS_NOT_REGISTERED              51
#define IDS_NONE                        52
#define IDS_REGISTRATION_INPROGRESS     53
#define IDS_UNKNOWN                     54


#define IDD_TSPCONFIG           10
#define IDC_GATEWAY_GROUP       11
#define IDI_PHONE               12
#define IDC_USEGATEWAY          13
#define IDC_H323_GATEWAY        14

#define IDC_PROXY_GROUP         15
#define IDI_PROXY               16
#define IDC_USEPROXY            17
#define IDC_H323_PROXY          18
#define IDI_GATEKEEPER          19

#define IDUPDATE                        1005
#define IDC_REGSTATE                    1006

#define IDUPDATE_PORT                   1010
#define IDC_LISTENPORT                  1011
#define IDC_STATIC3                     1012

#define IDAPPLY                         6
//GK related resource ids
#define IDC_H323_GK_ACCT        25


#define IDC_H323_GK_PHONE2              23

#define IDC_H323_CALL_TIMEOUT           23
#define IDC_CC_GROUP                    1007
#define IDC_STATIC1                     1008

#define IDC_H323_CALL_PORT              24
#define IDI_ICON2                       102
#define IDC_STATIC2                     1009



//                                                                           
// Help Support                                                              
//                                                                           


#define H323SP_HELP_FILE                    TEXT("tapi.hlp")

#define IDH_NOHELP                          ((DWORD) -1)
#define IDH_H323SP_USE_GATEWAY              10001
#define IDH_H323SP_USE_PROXY                10002
#define IDH_H323SP_USE_GATEWAY_COMPUTER     10003
#define IDH_H323SP_USE_PROXY_COMPUTER       10004
#define IDH_H323SP_GK_GROUP                 10035   //Set of options that control the use of Gatekeeper by this H.323 endpoint.

#define IDH_H323SP_GK                       10036   //Provides a space for you to type the IP address or the computer name of the H.323 Gatekeeper this endpoint will use.
#define IDH_H323SP_GK_PHONE                 10037   //Provides a space for you to type the phone number to be registered with the H.323 Gatekeeper.
#define IDH_H323SP_GK_ACCT                  10038   //Provides a space for you to type the account name to be registered with the H.323 Gatekeeper.

#define IDH_H323SP_USEGK                    10039   //Specifies that all the outgoing calls go through the specified Gatekeeper. If a Gatekeeper is enabled, all the H.323 Gateway and H.323 Proxy setting will be ignored.
#define IDH_H323SP_USEGK_PHONE              10040   //Specifies that a phone number should be registered with the H.323 Gatekkeper for the incoming calls.
#define IDH_H323SP_USEGK_ACCT                 10041   //Specifies that an account name should be registered with the H.323 Gatekkeper for the incoming calls.
#define IDH_H323SP_REGSTATE                   10042   //Specifies the H.323 Gatekeeper registration state of this endpoint. The possible values are: 'Registered', 'Unregisterd' and 'Registration In Progress'
#define IDH_H323SP_UPDATE_REGISTRATION_STATE  10043   //Updates the H.323 Gatekeeper registration state of this endpoint.

#define IDH_H323SP_CC_GROUP                   10044   //Set of options that control the incoming call setup behaviour for this endpoint.
#define IDH_H323SP_CALL_TIMEOUT               10045   //Provides a space for you to type the value in milliseconds for which an incoming call will ring before it is dropped.
#define IDH_H323SP_CALL_PORT                  10046   //Provides a space for you to type the port number on which the endpoint will listen for incoming calls.
#define IDH_H323SP_CURRENT_LISTENPORT         10047   //Specifies the port on which this endpoint is listening for incoming H.323 calls.
#define IDH_H323SP_UPDATE_PORT                10048   //Updates the port on which this endpoint is listening for incoming H.323 calls.


#define IDC_GK_GROUP                    12
#define IDC_H323_GK                     20
#define IDC_H323_GK_PHONE               22
#define IDC_H323_GK_ACCT                25
#define IDC_USEGK                       1000
#define IDC_USEGK_PHONE                 1001
#define IDC_GK_LOGONGROUP               1002
#define IDC_USEGK_ACCT                  1003
#define IDC_USEGK_MACHINE               1004


#endif // _INC_CONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\debug.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    Routines for displaying debug messages.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"

#define DEBUG_FORMAT_HEADER     "H323 "
#define DEBUG_FORMAT_TIMESTAMP  "[%02u:%02u:%02u.%03u"
#define DEBUG_FORMAT_THREADID   ",tid=%x] "
#define DEBUG_FORMAT_END        "\r\n"


HANDLE 
H323CreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
    BOOL bManualReset,                       // reset type
    BOOL bInitialState,                      // initial state
    LPCTSTR lpName                           // object name
)
{

#if DBG
    return CreateEvent( lpEventAttributes, bManualReset, bInitialState, lpName );
#else
    return CreateEvent( lpEventAttributes, bManualReset, bInitialState, NULL );
#endif

}

#if DBG

DWORD           g_dwTraceID = INVALID_TRACEID;
static TCHAR    g_szTraceName[100];   // saves name of dll

//                                                                           
// Private definitions                                                       
//                                                                           



#define MAX_DEBUG_STRLEN        800

#define STATUS_MASK_ERROR       0x0000FFFF
#define STATUS_MASK_FACILITY    0x0FFF0000


void H323DUMPBUFFER( IN BYTE * pEncoded, IN DWORD cbEncodedSize )
{
    DWORD indexI, indexJ=0;
    char ch;
    char szDebugMessage[MAX_DEBUG_STRLEN];
    szDebugMessage[0] = '\0';

    H323DBG(( DEBUG_LEVEL_ERROR, "ASN buffer start." ));
    
    for( indexI=0; indexI<cbEncodedSize; indexI++ )
    {
        ch = (pEncoded[indexI]>>4);
        if( (ch>=0)&&(ch<=9) )
        {
            ch+='0';
        }
        else
        {
            ch=ch+'A'-10;
        }
        
        szDebugMessage[indexJ++]=ch;

        ch = (pEncoded[indexI]& 0x0F);
        if( (ch>=0)&&(ch<=9) )
        {
            ch+='0';
        }
        else
        {
            ch= ch+'A'-10;
        }
        
        szDebugMessage[indexJ++]=ch;

        if( indexJ >= 700 )
        {
            szDebugMessage[indexJ]= '\0';
            H323DBG((DEBUG_LEVEL_ERROR, szDebugMessage ));
            indexJ = 0;
        }
    }

    szDebugMessage[indexJ]= '\0';
    H323DBG((DEBUG_LEVEL_ERROR, szDebugMessage ));

    H323DBG(( DEBUG_LEVEL_ERROR, "ASN buffer end." ));
    return;
}


//                                                                           
// Public procedures                                                         
//                                                                           


/*++

Routine Description:

    Debug output routine for service provider.

Arguments:

    Same as printf.

Return Values:

    None.   
    
--*/
VOID
H323DbgPrint(
    DWORD dwLevel,
    LPSTR szFormat,
    ...
    )
{
    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[MAX_DEBUG_STRLEN+1];
    int nLengthRemaining;
    int nLength = 0;

    // point at first argument
    va_start(Args, szFormat);

    // see if level enabled
    if( dwLevel <= g_RegistrySettings.dwLogLevel )
    {    
        // always emit messages at DEBUG_LEVEL_FORCE

        // retrieve local time
        GetLocalTime(&SystemTime);    

        // add component header to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_HEADER
                           );

        // add timestamp to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_TIMESTAMP,
                           SystemTime.wHour,
                           SystemTime.wMinute,
                           SystemTime.wSecond,
                           SystemTime.wMilliseconds
                           ); 

        // add thread id to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_THREADID,
                           GetCurrentThreadId()
                           );

        // determine number of bytes left in buffer
        nLengthRemaining = sizeof(szDebugMessage) - nLength -
            strlen(DEBUG_FORMAT_END);

        // add user specified debug message
        nLength += _vsnprintf(&szDebugMessage[nLength], 
                   nLengthRemaining, 
                   szFormat, 
                   Args
                   );
    
        nLength += sprintf(&szDebugMessage[nLength], DEBUG_FORMAT_END );

        // output message to specified sink
        OutputDebugStringA(szDebugMessage);
        
    }

    TraceVprintfExA( g_dwTraceID, (dwLevel | TRACE_USE_MASK), szFormat, Args );

    // release pointer
    va_end(Args);
}



void DumpError(
    IN DWORD ErrorCode )
{
    CHAR    ErrorText   [0x100];
    DWORD   Length;

    Length = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM, NULL, 
        ErrorCode, LANG_NEUTRAL, ErrorText, 0x100, NULL );

    if( Length == 0 )
    {
        _snprintf( ErrorText, 0x100, "<unknown error %08XH %d>",
            ErrorCode, ErrorCode);
    }

    H323DBG ((DEBUG_LEVEL_ERROR, "\t%s", ErrorText));
}


BOOL TRACELogRegister(LPCTSTR szName)
{
#ifdef UNICODE
    wsprintf(g_szTraceName, _T("%ls"), szName);
#else
    wsprintfA(g_szTraceName, "%s", szName);
#endif

    g_dwTraceID = TraceRegister(g_szTraceName);

    return( g_dwTraceID != INVALID_TRACEID );
}


void TRACELogDeRegister()
{
    if( g_dwTraceID != INVALID_TRACEID )
    {
        TraceDeregister(g_dwTraceID);
        g_dwTraceID = INVALID_TRACEID;
    }
}


#else

HANDLE g_hLogFile;

VOID
OpenLogFile()
{
    g_hLogFile = INVALID_HANDLE_VALUE;

    g_hLogFile = CreateFile( _T("h323log.txt"), 
        GENERIC_READ|GENERIC_WRITE, 
        FILE_SHARE_READ, 
        NULL, 
        OPEN_ALWAYS, 
        FILE_ATTRIBUTE_NORMAL, 
        NULL ); 
}

VOID
CloseLogFile()
{
    if( g_hLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle(g_hLogFile);
    }
}

VOID
H323DbgPrintFre(
    DWORD dwLevel,
    LPSTR szFormat,
    ...
    )
{
    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[800];
    DWORD NumberOfBytesWritten=0;
    int nLengthRemaining;
    int nLength = 0;

    // see if level enabled
    if( dwLevel <= g_RegistrySettings.dwLogLevel )
    {    
        // point at first argument
        va_start(Args, szFormat);

        // always emit messages at DEBUG_LEVEL_FORCE

        // retrieve local time
        GetLocalTime(&SystemTime);    

        // add component header to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_HEADER
                           );

        // add timestamp to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_TIMESTAMP,
                           SystemTime.wHour,
                           SystemTime.wMinute,
                           SystemTime.wSecond,
                           SystemTime.wMilliseconds
                           ); 

        // add thread id to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_THREADID,
                           GetCurrentThreadId()
                           );

        // determine number of bytes left in buffer
        nLengthRemaining = sizeof(szDebugMessage) - nLength -
            strlen(DEBUG_FORMAT_END);

        // add user specified debug message
        nLength += _vsnprintf(&szDebugMessage[nLength], 
                   nLengthRemaining, 
                   szFormat, 
                   Args
                   );
    
        nLength += sprintf(&szDebugMessage[nLength], DEBUG_FORMAT_END );

        // output message to specified sink
        //OutputDebugStringA(szDebugMessage);
        if( g_hLogFile != INVALID_HANDLE_VALUE )
        {
            WriteFile(  g_hLogFile, 
                        szDebugMessage, 
                        nLength,
                        &NumberOfBytesWritten, 
                        NULL ); 
        }

        // release pointer
        va_end(Args);
    }
}



#endif // DBG

PSTR
EventIDToString(
    DWORD eventID
    )
{
    static PSTR apszEventNameStrings[] = {
        "TSPI_NO_EVENT",
        "TSPI_MAKE_CALL",
        "TSPI_ANSWER_CALL",
        "TSPI_DROP_CALL",
        "TSPI_CLOSE_CALL",
        "TSPI_RELEASE_U2U",
        "TSPI_SEND_U2U",
        "TSPI_COMPLETE_TRANSFER",
        "TSPI_LINEFORWARD_SPECIFIC",
        "TSPI_LINEFORWARD_NOSPECIFIC",
        "TSPI_DIAL_TRNASFEREDCALL",
        "TSPI_CALL_UNHOLD",
        "TSPI_CALL_HOLD",
        "TSPI_DELETE_CALL",
        "TSPI_CALL_DIVERT",
        "H450_PLACE_DIVERTEDCALL",
        "SWAP_REPLACEMENT_CALL",
        "DELETE_PRIMARY_CALL",
        "STOP_CTIDENTIFYRR_TIMER",
        "SEND_CTINITIATE_MESSAGE"

        };

    // return corresponding string
    return apszEventNameStrings[eventID];
}


PSTR
H323TSPMessageToString(
    DWORD dwMessageType
    )
{

    static PSTR msgstrings[] =
    {
        "SP_MSG_InitiateCall",
        "SP_MSG_AnswerCall",    
        "SP_MSG_PrepareToAnswer",   
        "SP_MSG_ProceedWithAnswer", 
        "SP_MSG_ReadyToInitiate",   
        "SP_MSG_ReadyToAnswer", 
        "SP_MSG_FastConnectResponse",
        "SP_MSG_StartH245", 
        "SP_MSG_ConnectComplete",   
        "SP_MSG_H245PDU",   
        "SP_MSG_MCLocationIdentify",    
        "SP_MSG_Hold",  
        "SP_MSG_H245Hold",  
        "SP_MSG_ConferenceList",    
        "SP_MSG_SendDTMFDigits",    
        "SP_MSG_ReleaseCall",   
        "SP_MSG_CallShutdown",
        "SP_MSG_H245Terminated",    
        "SP_MSG_RASRegistration",   
        "SP_MSG_RASRegistrationEvent",  
        "SP_MSG_RASLocationRequest",    
        "SP_MSG_RASLocationConfirm",    
        "SP_MSG_RASBandwidthRequest",   
        "SP_MSG_RASBandwidthConfirm"
    };

    return msgstrings[dwMessageType];
}


/*++

Routine Description:

    Converts tapi call state to string.

Arguments:

    dwCallState - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/
PSTR
H323CallStateToString(
    DWORD dwCallState
    )
{
    DWORD i;
    DWORD dwBitMask;

    static PSTR apszCallStateStrings[] = {
                    "IDLE",
                    "OFFERING",
                    "ACCEPTED",
                    "DIALTONE",
                    "DIALING",
                    "RINGBACK",
                    "BUSY",
                    "SPECIALINFO",
                    "CONNECTED",
                    "PROCEEDING",
                    "ONHOLD",
                    "CONFERENCED",
                    "ONHOLDPENDCONF",
                    "ONHOLDPENDTRANSFER",
                    "DISCONNECTED",
                    "UNKNOWN"
                    };

    // keep shifting bit until the call state matchs the one specified
    for(i = 0, dwBitMask = 1; dwCallState != dwBitMask; i++, dwBitMask <<= 1)
        ;

    // return corresponding string
    return apszCallStateStrings[i];
}



PSTR
H323AddressTypeToString(
    DWORD dwAddressType
    )

/*++

Routine Description:

    Converts TAPI address type to string.

Arguments:

    dwAddressType - TAPI address type.

Return Values:

    Returns string describing value.
    
--*/

{
    switch (dwAddressType) {

    case LINEADDRESSTYPE_PHONENUMBER:
        return "PHONENUMBER";
    case LINEADDRESSTYPE_SDP:
        return "SDP";
    case LINEADDRESSTYPE_EMAILNAME:
        return "EMAILNAME";
    case LINEADDRESSTYPE_DOMAINNAME:
        return "DOMAINNAME";
    case LINEADDRESSTYPE_IPADDRESS:
        return "IPADDRESS";
    default:
        return "unknown";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\io.cpp ===
#include "globals.h"

#if H323_USE_PRIVATE_IO_THREAD
#define FINITE_WAIT_TIME    3000

static  HANDLE      H323IoCompletionPort = NULL;
static  HANDLE      H323IoThread = NULL;
static  DWORD       H323IoThreadID = 0;

static DWORD WINAPI H323IoThreadProc (
    IN  PVOID   ThreadParameter)
{
    LPOVERLAPPED    Overlapped;
    ULONG_PTR       CompletionKey;
    DWORD           Status;
    DWORD           BytesTransferred;

    for (;;)
    {
        if( GetQueuedCompletionStatus( H323IoCompletionPort, 
            &BytesTransferred, 
            &CompletionKey, 
            &Overlapped, 
            INFINITE) == TRUE ) 
        {
            Status = ERROR_SUCCESS;
        }
        else 
        {
            if( Overlapped )
            {
                Status = GetLastError();
            }
            else 
            {
                H323DBG((DEBUG_LEVEL_ERROR, "failed to dequeue i/o completion "
                         "packet: %d, quitting...", GetLastError() ));

                ExitThread (GetLastError());
            }
        }

        _ASSERTE( CompletionKey);

        ((LPOVERLAPPED_COMPLETION_ROUTINE) CompletionKey)(  Status, 
                                                            BytesTransferred,
                                                            Overlapped );
    }

    // never reached
    return EXIT_SUCCESS;
}

static void CALLBACK H323IoThreadExitCallback (
    IN  DWORD   Status,
    IN  DWORD   BytesTransferred,
    IN  LPOVERLAPPED    Overlapped)
{
    H323DBG ((DEBUG_LEVEL_TRACE, "i/o completion thread is stopping"));
    ExitThread (EXIT_SUCCESS);
}

HRESULT H323IoThreadStart (void)
{
    if( H323IoCompletionPort == NULL )
    {
        H323IoCompletionPort = 
            CreateIoCompletionPort(  INVALID_HANDLE_VALUE, 
                                     NULL, 
                                     0, 
                                     0 );
        if( H323IoCompletionPort == NULL )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "failed to create i/o completion port: %d", GetLastError() ));

            return GetLastResult();
        }
    }


    H323IoThread = CreateThread(NULL, 
                                0, 
                                H323IoThreadProc, 
                                NULL, 
                                0, 
                                &H323IoThreadID );

    if( H323IoThread == NULL )
    {
        H323DBG((   DEBUG_LEVEL_ERROR, 
                    "failed to create i/o completion worker thread: %d",
                    GetLastError() ));

        CloseHandle (H323IoCompletionPort);
        H323IoCompletionPort = NULL;

        return GetLastResult();
    }

    return S_OK;
}

void H323IoThreadStop (void)
{
    DWORD dwWaitTime = INFINITE;
    H323DBG ((DEBUG_LEVEL_WARNING, "H323IoThreadStop entered."));

    if( H323IoThread != NULL )
    {
        _ASSERTE( H323IoCompletionPort != NULL );

        if( !PostQueuedCompletionStatus( H323IoCompletionPort, 0,
            (ULONG_PTR) H323IoThreadExitCallback, (LPOVERLAPPED) -1) )
        {
            H323DBG(( DEBUG_LEVEL_WARNING, "PostQueuedCompletionStatus failed" ));
            dwWaitTime = FINITE_WAIT_TIME;
        }

        H323DBG(( DEBUG_LEVEL_WARNING, 
            "waiting for i/o completion port thread to finish..." ));

        WaitForSingleObject( H323IoThread, dwWaitTime );

        H323DBG(( DEBUG_LEVEL_WARNING, 
            "i/o completion port thread is finished." ));

        CloseHandle (H323IoThread);
        H323IoThread = NULL;
    }

    if( H323IoCompletionPort != NULL )
    {
        CloseHandle( H323IoCompletionPort );
        
        H323IoCompletionPort = NULL;
    }

    H323DBG ((DEBUG_LEVEL_WARNING, "H323IoThreadStop exited"));
}

BOOL H323BindIoCompletionCallback (
    IN  HANDLE  ObjectHandle,
    IN  LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    IN  ULONG   Flags)
{
    if( H323IoCompletionPort != NULL )
    {
        if (!CompletionRoutine) 
        {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        return CreateIoCompletionPort(  ObjectHandle, 
                                        H323IoCompletionPort,
                                        (ULONG_PTR) CompletionRoutine, 
                                        0 ) != NULL;
    }
    else
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "i/o completion port is not yet created" ));

        SetLastError( ERROR_GEN_FAILURE );
        return FALSE;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\globals.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    Global definitions for H.323 TAPI Service Provider.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


// build control defines
#define	STRICT
#define	UNICODE
#define	_UNICODE
#define	VC_EXTRALEAN
#define	H323_USE_PRIVATE_IO_THREAD	1

//                                                                           
// Include files:SDK
//                                                                           

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>
#include <mswsock.h>
#include <tapi3.h>
#include <tspi.h>
#include <crtdbg.h>
#include <stdio.h>
#include <tchar.h>
#include <rtutils.h>


// Project
#include <h225asn.h>
#include <tspmspif.h>


typedef class CH323Call*  PH323_CALL;
typedef class H323_CONFERENCE*  PH323_CONFERENCE; 

#define CALL_ALERTING_TIMEOUT  180000
#define Q931_CALL_PORT		1720 // Endpoint TCP Call Signalling Port

//                                                                           
// String definitions                                                        
//                                                                           
#define H323_MAXCALLSPERLINE    32768 //limited by 15 bit CRV sent to the Gatekeeper


#define H323_MAXLINENAMELEN     16
#define H323_MAXPORTNAMELEN     16
#define H323_MAXADDRNAMELEN     (H323_MAXLINENAMELEN + H323_MAXPORTNAMELEN)
#define H323_MAXPATHNAMELEN     256
#define H323_MAXDESTNAMELEN     256
#define MAX_E164_ADDR_LEN       127
#define MAX_H323_ADDR_LEN       255

#define H323_UIDLL              _T("H323.TSP")
#define H323_TSPDLL             _T("H323.TSP")
#define H323_WINSOCKVERSION     MAKEWORD(2,0)

#define H221_COUNTRY_CODE_USA   0xB5
#define H221_COUNTRY_EXT_USA    0x00
#define H221_MFG_CODE_MICROSOFT 0x534C

#define H323_PRODUCT_ID         "Microsoft TAPI\0"
#define H323_PRODUCT_VERSION    "Version 3.1\0"

#define MSP_HANDLE_UNKNOWN      0



//                                                                           
// Registry key definitions                                                  
//                                                                           

#define	REGSTR_PATH_WINDOWS_CURRENTVERSION		TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define TAPI_REGKEY_ROOT						REGSTR_PATH_WINDOWS_CURRENTVERSION TEXT("\\Telephony")
#define TAPI_REGKEY_PROVIDERS					TAPI_REGKEY_ROOT TEXT("\\Providers")
#define TAPI_REGVAL_NUMPROVIDERS				TEXT("NumProviders")

#define H323_SUBKEY								TEXT("H323TSP")
#define H323_REGKEY_ROOT						REGSTR_PATH_WINDOWS_CURRENTVERSION TEXT("\\") H323_SUBKEY

#define H323_REGVAL_Q931ALERTINGTIMEOUT			TEXT("Q931AlertingTimeout")
#define H323_REGVAL_Q931LISTENPORT              TEXT("Q931ListenPort")

#define H323_REGVAL_GATEWAYENABLED				TEXT("H323GatewayEnabled")
#define H323_REGVAL_GATEWAYADDR					TEXT("H323GatewayAddress")

#define H323_REGVAL_PROXYENABLED				TEXT("H323ProxyEnabled")
#define H323_REGVAL_PROXYADDR					TEXT("H323ProxyAddress")

#define H323_REGVAL_GKENABLED					TEXT("H323GatekeeperEnabled")
#define H323_REGVAL_GKLOGON_PHONEENABLED		TEXT("H323GKLogOnPhoneNumberEnabled")
#define H323_REGVAL_GKLOGON_ACCOUNTENABLED		TEXT("H323GKLogOnAccountNameEnabled")
#define H323_REGVAL_GKADDR						TEXT("H323GatekeeperAddress")
#define H323_REGVAL_GKLOGON_PHONE				TEXT("H323GatekeeperLogOnPhoneNumber")
#define H323_REGVAL_GKLOGON_ACCOUNT				TEXT("H323GatekeeperLogOnAccountName")


#define H323_REGVAL_DEBUGLEVEL					TEXT("DebugLevel")


//                                                                           
// Global Definitions                                                        
//                                                                           

// CCRC_CALL_REJECTED reason codes (includes cause values)
#define H323_REJECT_NO_BANDWIDTH              1
#define H323_REJECT_GATEKEEPER_RESOURCES      2
#define H323_REJECT_UNREACHABLE_DESTINATION   3
#define H323_REJECT_DESTINATION_REJECTION     4
#define H323_REJECT_INVALID_REVISION          5
#define H323_REJECT_NO_PERMISSION             6
#define H323_REJECT_UNREACHABLE_GATEKEEPER    7
#define H323_REJECT_GATEWAY_RESOURCES         8
#define H323_REJECT_BAD_FORMAT_ADDRESS        9
#define H323_REJECT_ADAPTIVE_BUSY             10
#define H323_REJECT_IN_CONF                   11
#define H323_REJECT_ROUTE_TO_GATEKEEPER       12
#define H323_REJECT_CALL_FORWARDED            13
#define H323_REJECT_ROUTE_TO_MC               14
#define H323_REJECT_UNDEFINED_REASON          15
#define H323_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
#define H323_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
#define H323_REJECT_USER_BUSY                 18    // User is busy with another call
#define H323_REJECT_NO_ANSWER                 19    // Callee does not answer
#define H323_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
#define H323_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
#define H323_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
#define H323_REJECT_TIMER_EXPIRED             23    // Own timer expired
#define H323_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
#define H323_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call


// unicode character mask contants
#define H323_ALIAS_H323_PHONE_CHARS           L"0123456789#*,"
#define H323_ODOTTO_CHARS                     L".0123456789"

//
//H450 Operation types
//

enum H450_OPERATION_TYPE
{
    H450_INVOKE         = 0x00000100,
    H450_RETURNRESULT   = 0x00000200,
    H450_RETURNERROR    = 0x00000400,
    H450_REJECT         = 0x00000800,

};


//
//H450 APDU types
//

enum H450_OPCODE
{
    NO_H450_APDU                        = 0,

    H4503_DUMMYTYPERETURNRESULT_APDU    = 50,
    H4503_RETURNERROR_APDU              = 51,
    H4503_REJECT_APDU                   = 52,

    CHECKRESTRICTION_OPCODE             = 18,
    CALLREROUTING_OPCODE                = 19,
    DIVERTINGLEGINFO1_OPCODE            = 20,
    DIVERTINGLEGINFO2_OPCODE            = 21,
    DIVERTINGLEGINFO3_OPCODE            = 22,

    CTIDENTIFY_OPCODE                   = 7,
    CTINITIATE_OPCODE                   = 9,
    CTSETUP_OPCODE                      = 10,

    HOLDNOTIFIC_OPCODE                  = 101,
    RETRIEVENOTIFIC_OPCODE              = 102,
    REMOTEHOLD_OPCODE                   = 103,
    REMOTERETRIEVE_OPCODE               = 104,

    CPREQUEST_OPCODE                    = 106,
    CPSETUP_OPCODE                      = 107,
    GROUPINDON_OPCODE                   = 108,
    GROUPINDOFF_OPCODE                  = 109,
    PICKREQU_OPCODE                     = 110,
    PICKUP_OPCODE                       = 111,
    PICKEXE_OPCODE                      = 112,
    CPNOTIFY_OPCODE                     = 113,
    CPICKUPNOTIFY_OPCODE                = 114,

};


#define NO_INVOKEID                     0x00000000



//                                                                           
// Global Data Structures                                                    
//                                                                           

// IP address in conventional 'dot' notation
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[16];      // UNICODE zstring
} H323_IP_Dot_t;

// IP address in binary format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    DWORD        dwAddr;         // binary address (host byte order)
} H323_IP_Binary_t;

typedef enum
{
    H323_ADDR_NOT_DEFINED = 0,
    H323_IP_DOMAIN_NAME ,
    H323_IP_DOT ,
    H323_IP_BINARY 
} H323_ADDRTYPE;

typedef struct _ADDR
{
    H323_ADDRTYPE nAddrType;
    BOOL        bMulticast;
    union 
    {
        H323_IP_Dot_t          IP_Dot;
        H323_IP_Binary_t       IP_Binary;
    } Addr;
} H323_ADDR, *PH323_ADDR;

typedef struct
{
    BYTE *pOctetString;
    WORD wOctetStringLength;

} H323_OCTETSTRING, *PH323_OCTETSTRING;


typedef struct ENDPOINT_ID
{
    ASN1uint32_t length;
    ASN1char16_t value[H323_MAXPATHNAMELEN+ 1];

} ENDPOINT_ID;


typedef struct
{
    H323_OCTETSTRING        sData;            // pointer to Octet data.
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
} H323NonStandardData;

#define H323_MAX_PRODUCT_LENGTH 256
#define H323_MAX_VERSION_LENGTH 256
#define H323_MAX_DISPLAY_LENGTH 82

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    PH323_OCTETSTRING       pProductNumber;
    PH323_OCTETSTRING       pVersionNumber;
} H323_VENDORINFO, *PH323_VENDORINFO;

typedef struct
{
    PH323_VENDORINFO        pVendorInfo;
    BOOL                    bIsTerminal;
    BOOL                    bIsGateway;    // for now, the H323 capability will be hard-coded.
} H323_ENDPOINTTYPE, *PH323_ENDPOINTTYPE;


typedef struct
{
    WORD    wType;
    WORD    wPrefixLength;
    LPWSTR  pPrefix;
    WORD    wDataLength;   // UNICODE character count
    LPWSTR  pData;         // UNICODE data.
} H323_ALIASITEM, *PH323_ALIASITEM;


typedef struct
{
    WORD            wCount;
    PH323_ALIASITEM pItems;

} H323_ALIASNAMES, *PH323_ALIASNAMES;

typedef struct _H323_FASTSTART
{
    struct _H323_FASTSTART* next;
    DWORD                   length;
    BYTE*                   value;

} H323_FASTSTART, *PH323_FASTSTART;


struct	H323_REGISTRY_SETTINGS
{
    DWORD       dwQ931AlertingTimeout;          // q931 alerting timeout
    DWORD       dwQ931ListenPort;       // port to listen for incoming calls

    BOOL        fIsGatewayEnabled;              // if true, gateway enabled
    BOOL        fIsProxyEnabled;                // if true, proxy enabled
    BOOL        fIsGKEnabled;                   // if true, GK enabled

    H323_ADDR   gatewayAddr;                    // H.323 gateway address
    H323_ADDR   proxyAddr;                      // H.323 proxy address

    SOCKADDR_IN saGKAddr;                       // H.323 gatekeeper address
    WCHAR       wszGKLogOnPhone[H323_MAXDESTNAMELEN+1];   // phone number to register with the gatekeeper
    WCHAR       wszGKLogOnAccount[H323_MAXDESTNAMELEN+1]; // account name to register with the gatekeeper
    BOOL        fIsGKLogOnPhoneEnabled;         // if true, gateway enabled
    BOOL        fIsGKLogOnAccountEnabled;      // if true, proxy enabled
    

    DWORD       dwLogLevel;               // debug log level
    //TCHAR       szLogFile[MAX_PATH+1];
};


//                                                                           
// Global Variables                                                          
//                                                                           
extern	WCHAR 				g_pwszProviderInfo[];
extern	WCHAR 				g_pwszLineName[];
extern	LINEEVENT			g_pfnLineEventProc;
extern	HINSTANCE			g_hInstance;
extern	HANDLE				g_hCanUnloadDll;
extern  HANDLE              g_hEventLogSource;
extern	DWORD				g_dwLineDeviceIDBase;
extern	DWORD				g_dwPermanentProviderID;
extern	H323_REGISTRY_SETTINGS	g_RegistrySettings;

#define	H323TimerQueue		NULL		// use default process timer queue


//
// I/O callback threaddeclarations.
//


#if	H323_USE_PRIVATE_IO_THREAD

BOOL	H323BindIoCompletionCallback (
	IN	HANDLE	ObjectHandle,
	IN	LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine,
	IN	ULONG	Flags);

HRESULT H323IoThreadStart(void);
void H323IoThreadStop(void);

#else

#define	H323BindIoCompletionCallback 	BindIoCompletionCallback

#endif

enum
{
	DEBUG_LEVEL_FORCE   = 0x00000000,	// always emit, no matter what
	DEBUG_LEVEL_ERROR   = 0x00020000,	// significant errors only
	DEBUG_LEVEL_INFO    = 0x00040000,	// general information, but not too detailed
	DEBUG_LEVEL_TRACE   = 0x00080000,   // lotsa lotsa trace output
};

#define	DEBUG_LEVEL_WARNING		DEBUG_LEVEL_INFO
#define	DEBUG_LEVEL_FATAL		DEBUG_LEVEL_FORCE	// big, bad errors, always output
#define	DEBUG_LEVEL_VERBOSE		DEBUG_LEVEL_INFO

PSTR EventIDToString( DWORD eventID );
PSTR H323CallStateToString( DWORD dwCallState );
PSTR H323AddressTypeToString( DWORD dwAddressType );
PSTR H323TSPMessageToString( DWORD dwMessageType );

#define	SOCKADDR_IN_PRINTF(SocketAddress) \
	ntohl ((SocketAddress) -> sin_addr.s_addr), \
	ntohs ((SocketAddress) -> sin_port)

//
//Debug Output declarations
//


#if	DBG

#define H323DBG(_x_)            H323DbgPrint _x_
void H323DUMPBUFFER( IN BYTE * pEncoded, IN DWORD cbEncodedSize );

//                                                                           
// Public prototypes                                                         
//                                                                           

VOID H323DbgPrint( DWORD dwLevel, LPSTR szFormat, ... );
void DumpError( IN DWORD ErrorCode );
BOOL TRACELogRegister(LPCTSTR szName);
void TRACELogDeRegister();


static __inline void DumpLastError (void) {
	DumpError (GetLastError());
}

static DWORD
ProcessTAPICallRequest(
        IN  PVOID   ContextParameter
        );

static DWORD
ProcessSuppServiceWorkItem(
    IN PVOID ContextParameter
    );

DWORD
SendMSPMessageOnRelatedCall(
    IN PVOID ContextParameter
    );


static DWORD
ProcessTAPILineRequest(
    IN PVOID ContextParam
    );


#else

// retail build

#define	DumpError(ErrorCode)		0
#define	DumpLastError()				0

#define H323DBG(_x_)    if( 0 != g_RegistrySettings.dwLogLevel ) H323DbgPrintFre _x_
#define H323DUMPBUFFER( x, y)

VOID OpenLogFile();
VOID CloseLogFile();
VOID H323DbgPrintFre(DWORD dwLevel, LPSTR szFormat, ... );

#define ProcessTAPICallRequest          ProcessTAPICallRequestFre
#define ProcessSuppServiceWorkItem      ProcessSuppServiceWorkItemFre
#define ProcessTAPILineRequest          ProcessTAPILineRequestFre
#define SendMSPMessageOnRelatedCall     SendMSPMessageOnRelatedCallFre

#endif	// DBG



//                                                                           
// Global Function Declarations                                              
//                                                                           

void ReportTSPEvent( LPCTSTR wszErrorMessage );
#define H323TSP_EVENT_SOURCE_NAME _T("Microsoft H.323 Telephony Service Provider")

static __inline BOOL IsGuidSet (
	IN	const GUID *	Guid)
{
	return Guid -> Data1 || Guid -> Data2 || Guid -> Data3 || Guid -> Data4;
}

static __inline void CopyConferenceID (
	OUT	GloballyUniqueID *	Target,
	IN	const GUID *		Value)
{
    CopyMemory (Target -> value, Value, sizeof (GUID));
    Target -> length = sizeof (GUID);
}

static __inline void CopyConferenceID (
	OUT	GUID *		Target,
	IN	const GloballyUniqueID *	Value)
{
    if (Value -> length == sizeof (GUID))
	    CopyMemory (Target, Value -> value, sizeof (GUID));
    else
    {
	    H323DBG ((DEBUG_LEVEL_ERROR, "GloballyUniqueID was wrong length (%d)\n",
		    Value -> length));

	    ZeroMemory (Target, sizeof (GUID));
    }
}


extern ASYNC_COMPLETION	g_pfnCompletionProc;
#define H323CompleteRequest (*g_pfnCompletionProc)


// notify TAPI of a line event.
void	H323PostLineEvent (
	IN	HTAPILINE	TapiLine,
	IN	HTAPICALL	TapiCall,
	IN	DWORD		MessageID,
	IN	ULONG_PTR	Parameter1,
	IN	ULONG_PTR	Parameter2,
	IN	ULONG_PTR	Parameter3);


static __inline HRESULT GetLastResult (void) { return HRESULT_FROM_WIN32 (GetLastError()); }

BOOL H323ValidateTSPIVersion( IN	DWORD dwTSPIVersion );
BOOL H323ValidateExtVersion ( IN	DWORD dwExtVersion);

HRESULT	RegistryStart	(void);
void	RegistryStop	(void);


HANDLE 
H323CreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
    BOOL bManualReset,                       // reset type
    BOOL bInitialState,                      // initial state
    LPCTSTR lpName                           // object name
);

//                                                                           
// Macros                                                                    
//                                                                           

#define H323AddrToString(_dwAddr_) \
    (inet_ntoa(H323AddrToAddrIn(_dwAddr_)))

#define H323AddrToAddrIn(_dwAddr_) \
    (*((struct in_addr *)&(_dwAddr_)))

#define H323SizeOfWSZ(wsz) \
    (((wsz) == NULL) ? 0 : ((wcslen(wsz) + 1) * sizeof(WCHAR)))



//                                                                           
// Table Class                                                               
//                                                                           

template <class T, DWORD INITIAL = 8, DWORD DELTA = 8>
class TSPTable
{
protected:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;
    CRITICAL_SECTION m_CriticalSection;

public:

    // Construction/destruction
    TSPTable() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    {
            
        // No need to check the result of this one since this object is
        // always allocated on static memory, right when the DLL is loaded.

		InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 0x80000000 );
	}

    ~TSPTable()
    {
        if(m_nAllocSize > 0)
        {
            free(m_aT);
            m_aT = NULL;
            m_nSize = 0;
            m_nAllocSize = 0;
        }

        DeleteCriticalSection(&m_CriticalSection);
    }
    void Lock()
    {
        EnterCriticalSection( &m_CriticalSection );
    }
    void Unlock()
    {
        LeaveCriticalSection( &m_CriticalSection );
    }
    // Operations
    int GetSize() const
    {
        return m_nSize;
    }
    int GetAllocSize()
    {
        return m_nAllocSize;
    }
    int Add(T& t)
    {
        Lock();
        if(m_nSize == m_nAllocSize)
        {
            if (!Grow()) return -1;
            SetAtIndex(m_nSize, t);
            m_nSize++;
            Unlock();
            return m_nSize - 1;
        }
        else
        {
            for(int i=0; i<m_nAllocSize; i++)
                if(m_aT[i] == NULL )
                    break;
            SetAtIndex(i, t);
            m_nSize++;
            Unlock();
            return i;
        }
    }
    void RemoveAt(int nIndex)
    {
        Lock();
        _ASSERTE( m_aT[nIndex] );
        m_aT[nIndex] = NULL;
        m_nSize--;
        Unlock();
    }
    T& operator[] (int nIndex) const
    {
        static T t1 = (T)NULL;
        _ASSERTE( (nIndex >= 0) && (nIndex < m_nAllocSize) );
        if( (nIndex >= 0) && (nIndex < m_nAllocSize) )
            return m_aT[nIndex];
        return t1;
    }        

// Implementation
private:
    void SetAtIndex(int nIndex, T& t)
    {
        _ASSERTE(nIndex >= 0 && nIndex < m_nAllocSize);
        if( (nIndex >= 0) && (nIndex < m_nAllocSize) )
            m_aT[nIndex] = t;
    }
    BOOL Grow()
    {
        T* aT;
        int nNewAllocSize = 
            (m_nAllocSize == 0) ? INITIAL : (m_nSize + DELTA);

        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
        if(aT == NULL)
            return FALSE;
        ZeroMemory( (PVOID)&aT[m_nAllocSize], sizeof(T)*(nNewAllocSize-m_nAllocSize));
        m_nAllocSize = nNewAllocSize;
        m_aT = aT;

        return TRUE;
    }
};




/*++

CTSPArray template Description:

    This array should only be used to store simple types. It doesn't call the
    constructor nor the destructor for each element in the array.

--*/

template <class T, DWORD INITIAL_SIZE = 8, DWORD DELTA_SIZE = 8>
class CTSPArray
{

protected:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

public:

    // Construction/destruction
    CTSPArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CTSPArray()
    {
        RemoveAll();
    }


    // Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Grow()
    {
        T* aT;
        int nNewAllocSize = 
            (m_nAllocSize == 0) ? INITIAL_SIZE : (m_nSize + DELTA_SIZE);

        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
        if(aT == NULL)
            return FALSE;
        m_nAllocSize = nNewAllocSize;
        m_aT = aT;
        return TRUE;
    }

    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            if (!Grow()) return FALSE;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    BOOL Remove(T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    BOOL RemoveAt(int nIndex)
    {
        if(nIndex != (m_nSize - 1))
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], 
                (m_nSize - (nIndex + 1)) * sizeof(T));
        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_nAllocSize > 0)
        {
            free(m_aT);
            m_aT = NULL;
            m_nSize = 0;
            m_nAllocSize = 0;
        }
    }
    T& operator[] (int nIndex) const
    {
        _ASSERTE(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }

    
    // Implementation
    void SetAtIndex(int nIndex, T& t)
    {
        _ASSERTE(nIndex >= 0 && nIndex < m_nSize);
        m_aT[nIndex] = t;
    }
    int Find(T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
};


//
//Asynchronous I/O definitions.
//

class RAS_CLIENT;
class CH323Call;

#define  IO_BUFFER_SIZE                     0x2000

enum OVERLAPPED_TYPE
{
	OVERLAPPED_TYPE_SEND = 0,
	OVERLAPPED_TYPE_RECV,
};

typedef struct O_OVERLAPPED
{
    LIST_ENTRY			ListEntry;
	OVERLAPPED			Overlapped;
	OVERLAPPED_TYPE	    Type;
    union {
	RAS_CLIENT*		    RasClient;
    CH323Call*          pCall;
    };
	DWORD				BytesTransferred;
	SOCKADDR_IN			Address;

} RAS_OVERLAPPED, CALL_OVERLAPPED;

struct CALL_SEND_CONTEXT :
public CALL_OVERLAPPED
{
    WSABUF  WSABuf;
};

struct RAS_SEND_CONTEXT :
public RAS_OVERLAPPED
{
    UCHAR arBuf[IO_BUFFER_SIZE];
};


struct	RAS_RECV_CONTEXT :
public	RAS_OVERLAPPED
{
    UCHAR   arBuf[IO_BUFFER_SIZE];
	DWORD   Flags;
    BOOL    IsPending;
    INT     AddressLength;
};
 
struct CALL_RECV_CONTEXT :
public	CALL_OVERLAPPED
{
    char    arBuf[IO_BUFFER_SIZE];
    WSABUF  WSABuf;
    DWORD   dwBytesCopied;
    DWORD   dwPDULen;
    DWORD   dwFlags;
};



//                                                                           
// Component Includes                                                        
//                                                                           

#include "h4503pp.h"
#include "q931pdu.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\call.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    call.cpp

Abstract:

    TAPI Service Provider functions related to manipulating calls.

        TSPI_lineAnswer
        TSPI_lineCloseCall
        TSPI_lineDrop
        TSPI_lineGetCallAddressID
        TSPI_lineGetCallInfo
        TSPI_lineGetCallStatus
        TSPI_lineMakeCall
        TSPI_lineMonitorDigits
        TSPI_lineSendUserUserInfo
        TSPI_lineReleaseUserUserInfo


Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 
//                                                                           
// Include files                                                             
//                                                                           

#include "globals.h"
#include "line.h"
#include "q931pdu.h"
#include "q931obj.h"
#include "ras.h"
#include "config.h"

#define SETUP_SENT_TIMEOUT      8000
#define H450_ENCODED_ARG_LEN    0x4000
#define MAX_DIVERSION_COUNTER   14

static  LONG    g_H323CallID;
static  LONG    g_lNumberOfcalls;
        LONG    g_lCallReference;

//
// Public functions
//


//
//The function that handles a network event(CONNECT|CLOSE) on any of the
//Q931 calls. This function needs to find out the exact event 
// that took place and the socket on which it took place
//
        
void NTAPI Q931TransportEventHandler ( 
    IN  PVOID   Parameter,
    IN  BOOLEAN TimerFired)
{
    PH323_CALL      pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "Q931 transport event recvd." ));

    pCall = g_pH323Line -> FindH323CallAndLock ((HDRVCALL) Parameter);

    if( pCall != NULL )
    {
        pCall  -> HandleTransportEvent();
        pCall -> Unlock();
    }
}


//
// returns S_OK if socket was consumed
// returns E_FAIL if socket should be destroyed by caller
//

static HRESULT CallCreateIncomingCall (
    IN  SOCKET          Socket,
    IN  SOCKADDR_IN *   LocalAddress,
    IN  SOCKADDR_IN *   RemoteAddress)
{
    PH323_CALL  pCall;
    HANDLE      SelectEvent;
    HANDLE      SelectWaitHandle;
    BOOL        fSuccess = TRUE;
    BOOL        DeleteCall = FALSE;
    TCHAR       ptstrEventName[100]; 
    BOOL        retVal;

    pCall = new CH323Call;
    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "failed to allocate memory for CH323Call." ));
        
        return E_OUTOFMEMORY;
    }

    _stprintf( ptstrEventName, _T("%s-%p"),
        _T( "H323TSP_Incoming_TransportHandlerEvent" ), pCall );

    // create the wait event
    SelectEvent = H323CreateEvent (NULL, FALSE,
        FALSE, ptstrEventName );

    if( SelectEvent == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "CALL: failed to create select event." ));
        delete pCall;
        return GetLastResult();
    }

    retVal = pCall -> Initialize(   NULL, 
                                    LINECALLORIGIN_INBOUND, 
                                    CALLTYPE_NORMAL );

    if( retVal == FALSE )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "failed to initialize CH323Call."));
        CloseHandle (SelectEvent);
        delete pCall;
        return E_FAIL;
    }

    //add it to the call context array
    if (!pCall -> InitializeQ931 (Socket))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Failed to initialize incoming call Q.931 state." ));

        DeleteCall = FALSE;
        pCall -> Shutdown (&DeleteCall);
        delete pCall;

        if (SelectEvent)
        {
            CloseHandle (SelectEvent);
        }

        return E_FAIL;
    }

    pCall -> SetQ931CallState (Q931_CALL_CONNECTED);

    pCall -> Lock();

    if (!RegisterWaitForSingleObject(
        &SelectWaitHandle,              // pointer to the returned handle.
        SelectEvent,                    // the event handle to wait for.
        Q931TransportEventHandler,      // the callback function.
        (PVOID)pCall -> GetCallHandle(),// the context for the callback.
        INFINITE,                       // wait forever.
        WT_EXECUTEDEFAULT))             // use the wait thread to call the callback.
    {
        goto cleanup;
    }

    _ASSERTE( SelectWaitHandle );
    if( SelectWaitHandle == NULL )
    {
        goto cleanup;
    }

    //store this in the call context 
    pCall -> SetNewCallInfo (SelectWaitHandle, SelectEvent, 
        Q931_CALL_CONNECTED);
    SelectEvent = NULL;

    pCall -> InitializeRecvBuf();

    //post a buffer to winsock to accept messages from the peer
    if(!pCall -> PostReadBuffer())
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "failed to post read buffer on call." ));
        goto cleanup;
    }

    pCall -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "successfully created incoming Q.931 call." ));

    //success
    return S_OK;

cleanup:

    if (pCall)
    {
        pCall -> Unlock();
        pCall -> Shutdown (&DeleteCall);
        delete pCall;
    }

    if (SelectEvent)
    {
        CloseHandle (SelectEvent);
    }

    return E_OUTOFMEMORY;
}


void CallProcessIncomingCall (
    IN  SOCKET          Socket,
    IN  SOCKADDR_IN *   LocalAddress,
    IN  SOCKADDR_IN *   RemoteAddress)
{
    HRESULT     hr;

    hr = CallCreateIncomingCall (Socket, LocalAddress, RemoteAddress);

    if (hr != S_OK)
    {
        closesocket (Socket);
    }
}

#if DBG

DWORD
ProcessTAPICallRequest(
    IN PVOID ContextParameter
    )
{
    __try
    {
        return ProcessTAPICallRequestFre( ContextParameter );
    }
    __except( 1 )
    {
        TAPI_CALLREQUEST_DATA*  pRequestData = 
            (TAPI_CALLREQUEST_DATA*)ContextParameter;
        
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event threw exception: %p, %p.", 
            EventIDToString(pRequestData -> EventID),
            pRequestData -> pCall,
            pRequestData -> pCallforwardParams ));
        
        _ASSERTE( FALSE );

        return 0;
    }
}

#endif


DWORD 
ProcessTAPICallRequestFre(
    IN  PVOID   ContextParameter)
{
    _ASSERTE( ContextParameter );

    TAPI_CALLREQUEST_DATA*  pCallRequestData = (TAPI_CALLREQUEST_DATA*)ContextParameter;
    PH323_CALL              pCall = pCallRequestData->pCall;
    BOOL                    fDelete = FALSE;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event recvd.", 
        EventIDToString(pCallRequestData -> EventID) ));

    pCall -> Lock();

    if( pCallRequestData -> EventID == TSPI_DELETE_CALL )
    {
        pCall -> Unlock();
                
        delete pCallRequestData;        
        delete pCall;
        return EXIT_SUCCESS;
    }

    if( pCall -> IsCallShutdown() == FALSE )
    {
        switch( pCallRequestData -> EventID )
        {
        case TSPI_MAKE_CALL:

            pCall -> MakeCall();
            break;

        case TSPI_ANSWER_CALL:
            
            pCall -> AcceptCall();
            break;
    
        case TSPI_DROP_CALL:
            
            pCall -> DropUserInitiated( 0 );
            //pCall -> DropCall(0);
            break;

        case TSPI_RELEASE_U2U:
            
            pCall -> ReleaseU2U();
            break;

        case TSPI_CALL_HOLD:
            
            pCall -> Hold();
            break;

        case TSPI_CALL_UNHOLD:
            
            pCall -> UnHold();
            break;

        case TSPI_CALL_DIVERT:
            
            pCall -> CallDivertOnNoAnswer();
            break;

        case TSPI_LINEFORWARD_NOSPECIFIC:
        case TSPI_LINEFORWARD_SPECIFIC:

            pCall -> Forward( pCallRequestData -> EventID,
                pCallRequestData -> pCallforwardParams );

            break;

        case TSPI_SEND_U2U:

            pCall -> SendU2U( pCallRequestData -> pBuf->pbBuffer,
                pCallRequestData->pBuf->dwLength );

            delete pCallRequestData -> pBuf;
            
            break;

        default:
            _ASSERTE(0);
            break;
        }
    }
    
    pCall -> DecrementIoRefCount( &fDelete );
    pCall -> Unlock();
    delete pCallRequestData;
    
    if( fDelete == TRUE )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
        delete pCall;
    }

    return EXIT_SUCCESS;
}


//
// CH323Call Methods
//


CH323Call::CH323Call(void)
{
    ZeroMemory( (PVOID)this, sizeof(CH323Call) );

    /*m_dwFlags = 0;
    m_pwszDisplay = NULL;
    m_fMonitoringDigits = FALSE;
    m_hdCall = NULL;
    m_htCall = NULL;
    m_dwCallState = NULL;
    m_dwOrigin = NULL;
    m_dwAddressType = NULL;
    m_dwIncomingModes = NULL;     
    m_dwOutgoingModes = NULL;
    m_dwRequestedModes = NULL;    // requested media modes
    m_hdMSPLine = NULL;
    m_htMSPLine = NULL;
    //m_fGateKeeperPresent = FALSE;
    m_fReadyToAnswer = FALSE;
    m_fCallAccepted = FALSE;

    // reset addresses
    memset((PVOID)&m_CalleeAddr,0,sizeof(H323_ADDR));
    memset((PVOID)&m_CallerAddr,0,sizeof(H323_ADDR));

    // reset addresses
    m_pCalleeAliasNames = NULL;
    m_pCallerAliasNames = NULL;
    
    //reset non standard data
    memset( (PVOID)&m_NonStandardData, 0, sizeof(H323NonStandardData ) );

    //reset the conference ID
    ZeroMemory (&m_ConferenceID, sizeof m_ConferenceID);
   
    pFastStart = NULL;

    //redet the peer information
    memset( (PVOID)&m_peerH245Addr, 0, sizeof(H323_ADDR) );
    memset( (PVOID)&m_selfH245Addr, 0, sizeof(H323_ADDR) );
    memset( (PVOID)&m_peerNonStandardData, 0, sizeof(H323NonStandardData ) );
    memset( (PVOID)&m_peerVendorInfo, 0, sizeof(H323_VENDORINFO) );
    memset( (PVOID)&m_peerEndPointType, 0, sizeof(H323_ENDPOINTTYPE) );
    m_pPeerFastStart = NULL;
    m_pPeerExtraAliasNames = NULL;
    m_pPeerDisplay = NULL;

    m_hCallEstablishmentTimer = NULL;
    m_hCallDivertOnNATimer = NULL;

    //Q931call data
    m_hTransport = NULL;  
    
    m_hTransportWait = NULL; 
    
    pRecvBuf = NULL;      
    m_hSetupSentTimer = NULL;
    m_dwStateMachine = 0;   
    m_dwQ931Flags = 0;
    //

    fActiveMC = FALSE;  
    memset( (PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));
    m_wCallReference = NULL;
    m_wQ931CallRef = NULL;
    m_IoRefCount = 0;
    
    //RAS call data
    wARQSeqNum = 0;
    m_wDRQSeqNum = 0;

    m_pARQExpireContext = NULL;
    m_pDRQExpireContext= NULL;
    m_hARQTimer = NULL;
    m_hDRQTimer = NULL;
    m_dwDRQRetryCount = 0;
    m_dwARQRetryCount = 0;
    m_fCallInTrnasition = FALSE
    m_dwAppSpecific = 0;*/


    m_dwFastStart = FAST_START_UNDECIDED;
    m_callSocket = INVALID_SOCKET;
    m_bStartOfPDU = TRUE;

    H323DBG(( DEBUG_LEVEL_TRACE,
        "Initialize:m_IoRefCount:%d:%p.", m_IoRefCount, this ));
    m_dwRASCallState = RASCALL_STATE_IDLE;

    if( InterlockedIncrement( &g_lNumberOfcalls ) == 1 )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, 
            "pCall no goes from 0 to 1:g_hCanUnloadDll set.", this ));

        ResetEvent( g_hCanUnloadDll );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "New pCall object created:%p.", this ));

}


CH323Call::~CH323Call()
{
    CALL_SEND_CONTEXT*  pSendBuf;
    PLIST_ENTRY         pLE;

    H323DBG(( DEBUG_LEVEL_ERROR, "pCall object deleted:%p.", this ));

    if( m_dwFlags & CALLOBJECT_INITIALIZED )
    {
        while( IsListEmpty( &m_sendBufList ) == FALSE )
        {
            pLE = RemoveHeadList( &m_sendBufList );
            pSendBuf = CONTAINING_RECORD( pLE, CALL_SEND_CONTEXT, ListEntry);
            delete pSendBuf->WSABuf.buf;
            delete pSendBuf;
        }

        if( m_hTransportWait != NULL )
        {
            if( UnregisterWaitEx( m_hTransportWait, NULL ) == FALSE )
            {
                GetLastError();
            }

            m_hTransportWait = NULL;
        }

        if( m_hTransport != NULL )
        {
            if(!CloseHandle(m_hTransport))
            {
                WSAGetLastError();
            }

            m_hTransport = NULL;
        }
            
        if( m_callSocket != INVALID_SOCKET )
        {
            closesocket( m_callSocket );
            m_callSocket = INVALID_SOCKET;
        }

        TermASNCoder();

        DeleteCriticalSection( &m_CriticalSection );
    }

    if( InterlockedDecrement( &g_lNumberOfcalls ) == 0 )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "Unload dll event set.%p.", this ));
        SetEvent( g_hCanUnloadDll );
    }
}

    
//!!no need to lock
BOOL
CH323Call::Initialize( 
    IN HTAPICALL    htCall,
    IN DWORD        dwOrigin,
    IN DWORD        dwCallType
    )
{
    int     index;
    int     rc;

    H323DBG(( DEBUG_LEVEL_ERROR, "call init entered:%p.",this ));

    m_pCallerAliasNames = new H323_ALIASNAMES;

    if( m_pCallerAliasNames == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));
        return FALSE;
    }
    memset( (PVOID)m_pCallerAliasNames, 0, sizeof(H323_ALIASNAMES) );
    //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

    m_pCalleeAliasNames = new H323_ALIASNAMES;

    if( m_pCalleeAliasNames == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate callee name." ));
        goto error1;
    }
    memset( (PVOID)m_pCalleeAliasNames, 0, sizeof(H323_ALIASNAMES) );

            
    __try
    {
        if( !InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 
                                                    0x80000000 ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "couldn't alloc critsec for call." ));
            goto error2;
        }
    }
    __except( 1 )
    {
        goto error2;        
    }

    if( dwOrigin == LINECALLORIGIN_OUTBOUND )
    {
        int iresult = UuidCreate( &m_callIdentifier );

        if( (iresult != RPC_S_OK) && (iresult !=RPC_S_UUID_LOCAL_ONLY) )
        {
            goto error3;
        }
    }

    rc = InitASNCoder();

    if( rc != ASN1_SUCCESS )
    {
        H323DBG((DEBUG_LEVEL_ERROR, "Q931_InitCoder() returned: %d ", rc));
        goto error3;
    }

    rc = InitH450ASNCoder();

    if( rc != ASN1_SUCCESS )
    {
        H323DBG((DEBUG_LEVEL_ERROR, "Q931_InitCoder() returned: %d ", rc));
        goto error4;
    }

    //Create the CRV for this call.
    do 
    {
        m_wCallReference = ((WORD)InterlockedIncrement( &g_lCallReference ))
            & 0x7fff;

    } while( (m_wCallReference == 0) ||
        g_pH323Line->CallReferenceDuped( m_wCallReference ) );

    //add the call to the call table
    index = g_pH323Line -> AddCallToTable((PH323_CALL)this);
    if( index == -1 )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not add call to call table." ));
        goto error5;
    }
    
    //By incrementing the g_H323CallID and taking lower 16 bits we get 65536
    //unique values and then same values are repeated. Thus we can have only
    //65535 simultaneous calls. By using the call table index we make sure that
    //no two existing calls have same call handle.
    do
    {
        m_hdCall = (HDRVCALL)( ((BYTE*)NULL) + 
            MAKELONG( LOWORD((DWORD)index),
            (WORD)InterlockedIncrement(&g_H323CallID) ));

    } while ( m_hdCall == NULL );
    
    ZeroMemory( (PVOID)&m_prepareToAnswerMsgData, sizeof(BUFFERDESCR) );

    m_dwFlags |= CALLOBJECT_INITIALIZED;
    m_htCall = htCall;
    m_dwCallState = LINECALLSTATE_IDLE;
    m_dwOrigin = dwOrigin;
    m_hdConf = NULL;
    
    m_wQ931CallRef = m_wCallReference;
    m_dwCallType = dwCallType;

    // initialize user user information
    InitializeListHead( &m_IncomingU2U );
    InitializeListHead( &m_OutgoingU2U );
    InitializeListHead( &m_sendBufList );

    H323DBG(( DEBUG_LEVEL_TRACE, 
        "m_hdCall:%lx m_htCall:%lx m_wCallReference:%lx : %p .", 
        m_hdCall, m_htCall, m_wCallReference, this ));

    H323DBG(( DEBUG_LEVEL_TRACE, "call init exited:%p.",this ));
    return TRUE;

error5:
    TermH450ASNCoder();
error4:
    TermASNCoder();
error3:
    DeleteCriticalSection( &m_CriticalSection );
error2:
    delete m_pCalleeAliasNames;
    m_pCalleeAliasNames = NULL;
error1:
    delete m_pCallerAliasNames;
    m_pCallerAliasNames = NULL;
    return FALSE;
}


//
//!!must be always called in a lock
//Queues a request made by TAPI to the thread pool
//

BOOL
CH323Call::QueueTAPICallRequest(
    IN  DWORD   EventID,
    IN  PVOID   pBuf
    )
{
    TAPI_CALLREQUEST_DATA * pCallRequestData = new TAPI_CALLREQUEST_DATA;
    BOOL fResult = TRUE;

    if( pCallRequestData != NULL )
    {
        pCallRequestData -> EventID = EventID;
        pCallRequestData -> pCall = this;
        pCallRequestData -> pBuf = (PBUFFERDESCR)pBuf;
        
        if( !QueueUserWorkItem( ProcessTAPICallRequest, pCallRequestData,
            WT_EXECUTEDEFAULT ) )
        {
            delete pCallRequestData;
            fResult = FALSE;
        }
        
        m_IoRefCount++;
        H323DBG(( DEBUG_LEVEL_TRACE, "TAPICallRequest:m_IoRefCount:%d:%p.",
            m_IoRefCount, this ));
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}


//always called in lock
void
CH323Call::CopyCallStatus( 
                           IN LPLINECALLSTATUS pCallStatus 
                         )
{
    H323DBG(( DEBUG_LEVEL_ERROR, "CopyCallStatus entered:%p.",this ));
    
    // transer call state information    
    pCallStatus->dwCallState     = m_dwCallState;
    pCallStatus->dwCallStateMode = m_dwCallStateMode;

    // determine call feature based on state
    pCallStatus->dwCallFeatures = ( m_dwCallState != LINECALLSTATE_IDLE)?
        (H323_CALL_FEATURES) : 0;

    H323DBG(( DEBUG_LEVEL_ERROR, "CopyCallStatus exited:%p.",this ));
}


//always called in lock
LONG
CH323Call::CopyCallInfo( 
    IN LPLINECALLINFO  pCallInfo
    )
{
    DWORD dwCalleeNameSize = 0;
    DWORD dwCallerNameSize = 0;
    DWORD dwCallerAddressSize = 0;
    WCHAR wszIPAddress[20];
    DWORD dwNextOffset = sizeof(LINECALLINFO);
    DWORD dwU2USize = 0;
    PBYTE pU2U = NULL;
    LONG  retVal = NOERROR;
    DWORD dwDivertingNameSize = 0;
    DWORD dwDiversionNameSize = 0;
    DWORD dwDivertedToNameSize = 0;
    DWORD dwCallDataSize = 0;

    H323DBG(( DEBUG_LEVEL_ERROR, "CopyCallInfo entered:%p.",this ));

    // see if user user info available
    if( IsListEmpty( &m_IncomingU2U) == FALSE )
    {
        PLIST_ENTRY pLE;
        PUserToUserLE pU2ULE;

        // get first list entry
        pLE = m_IncomingU2U.Flink;

        // convert to user user structure
        pU2ULE = CONTAINING_RECORD(pLE, UserToUserLE, Link);

        // transfer info
        dwU2USize = pU2ULE->dwU2USize;
        pU2U = pU2ULE->pU2U;
    }

    // initialize caller and callee id flags now
    pCallInfo->dwCalledIDFlags = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwCallerIDFlags = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;


    // calculate memory necessary for strings
    if( m_pCalleeAliasNames && m_pCalleeAliasNames -> wCount !=0 )
    {
        dwCalleeNameSize = 
            H323SizeOfWSZ( m_pCalleeAliasNames -> pItems[0].pData );
    }
    
    if( m_pCallerAliasNames && (m_pCallerAliasNames->wCount) )
    {
        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

        dwCallerNameSize =
            sizeof(WCHAR) * (m_pCallerAliasNames->pItems[0].wDataLength + 1);
    }

    if( m_CallerAddr.Addr.IP_Binary.dwAddr != 0 )
    {
        wsprintfW(wszIPAddress, L"%d.%d.%d.%d", 
            (m_CallerAddr.Addr.IP_Binary.dwAddr >> 24) & 0xff,
            (m_CallerAddr.Addr.IP_Binary.dwAddr >> 16) & 0xff,
            (m_CallerAddr.Addr.IP_Binary.dwAddr >> 8) & 0xff,
            (m_CallerAddr.Addr.IP_Binary.dwAddr) & 0xff
            );

        dwCallerAddressSize = (wcslen(wszIPAddress) + 1) * sizeof(WCHAR);
            
    }
    
    if( m_dwCallType & CALLTYPE_DIVERTEDDEST )
    {    
        if( m_pCallReroutingInfo->divertingNrAlias && 
            (m_pCallReroutingInfo->divertingNrAlias->wCount !=0) )
        {
            dwDivertingNameSize = H323SizeOfWSZ( 
                m_pCallReroutingInfo->divertingNrAlias-> pItems[0].pData );
        }
    
        if( m_pCallReroutingInfo->divertedToNrAlias && 
            (m_pCallReroutingInfo->divertedToNrAlias->wCount != 0) )
        {
            dwDivertedToNameSize = sizeof(WCHAR) * 
                m_pCallReroutingInfo->divertedToNrAlias->pItems[0].wDataLength;
        }
    }

    if( m_dwCallType & CALLTYPE_DIVERTEDSRC_NOROUTING )
    {    
        if( m_pCallReroutingInfo->divertedToNrAlias && 
            (m_pCallReroutingInfo->divertedToNrAlias->wCount != 0) )
        {
            dwDivertedToNameSize = sizeof(WCHAR) * 
                m_pCallReroutingInfo->divertedToNrAlias->pItems[0].wDataLength;
        }
    }

    if( m_dwCallType & CALLTYPE_DIVERTEDSRC)
    {    
        if( m_pCallReroutingInfo->divertedToNrAlias && 
            (m_pCallReroutingInfo->divertedToNrAlias->wCount != 0) )
        {
            dwDivertedToNameSize = sizeof(WCHAR) * 
                m_pCallReroutingInfo->divertedToNrAlias->pItems[0].wDataLength;
        }

        if( m_pCallReroutingInfo->divertingNrAlias && 
            (m_pCallReroutingInfo->divertingNrAlias->wCount !=0) )
        {
            dwDivertingNameSize = H323SizeOfWSZ( 
                m_pCallReroutingInfo->divertingNrAlias-> pItems[0].pData );
        }

    }
    
    if( m_CallData.wOctetStringLength != 0 )
    {
        dwCallDataSize = m_CallData.wOctetStringLength;
    }

    // determine number of bytes needed
    pCallInfo->dwNeededSize = sizeof(LINECALLINFO) +
                              dwCalleeNameSize +
                              dwCallerNameSize +
                              dwCallerAddressSize +
                              dwDivertingNameSize +
                              dwDiversionNameSize +
                              dwDivertedToNameSize +
                              dwU2USize +
                              dwCallDataSize
                              ;

    // see if structure size is large enough
    if (pCallInfo->dwTotalSize >= pCallInfo->dwNeededSize)
    {
        // record number of bytes used
        pCallInfo->dwUsedSize = pCallInfo->dwNeededSize;

        // validate string size
        if (dwCalleeNameSize > 0)
        {
            if( m_pCalleeAliasNames -> pItems[0].wType == e164_chosen )
            {
                // callee number was specified
                pCallInfo->dwCalledIDFlags = LINECALLPARTYID_ADDRESS;

                // determine size and offset for callee number
                pCallInfo->dwCalledIDSize = dwCalleeNameSize;
                pCallInfo->dwCalledIDOffset = dwNextOffset;

                // copy call info after fixed portion
                CopyMemory( 
                    (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwCalledIDOffset),
                    (LPBYTE)m_pCalleeAliasNames -> pItems[0].pData,
                    pCallInfo->dwCalledIDSize );
            }
            else
            {
                // callee name was specified
                pCallInfo->dwCalledIDFlags = LINECALLPARTYID_NAME;

                // determine size and offset for callee name
                pCallInfo->dwCalledIDNameSize = dwCalleeNameSize;
                pCallInfo->dwCalledIDNameOffset = dwNextOffset;

                // copy call info after fixed portion
                CopyMemory( 
                    (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwCalledIDNameOffset),
                    (LPBYTE)m_pCalleeAliasNames -> pItems[0].pData,
                    pCallInfo->dwCalledIDNameSize );
            }

            // adjust offset to include string
            dwNextOffset += dwCalleeNameSize;
            
            H323DBG(( DEBUG_LEVEL_TRACE,
                "callee name: %S.", m_pCalleeAliasNames -> pItems[0].pData ));
        }

        // validate string size
        if (dwCallerNameSize > 0)
        {
            // caller name was specified
            pCallInfo->dwCallerIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwCallerIDNameSize = dwCallerNameSize;
            pCallInfo->dwCallerIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwCallerIDNameOffset),
                (LPBYTE)m_pCallerAliasNames -> pItems[0].pData,
                pCallInfo->dwCallerIDNameSize );

            //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
            // adjust offset to include string
            dwNextOffset += dwCallerNameSize;

            H323DBG(( DEBUG_LEVEL_TRACE,
                "caller name: %S.", m_pCallerAliasNames -> pItems[0].pData ));
        }

        if( dwCallerAddressSize > 0 )
        {
            // caller number was specified
            pCallInfo->dwCallerIDFlags |= LINECALLPARTYID_ADDRESS;

            // determine size and offset for caller number
            pCallInfo->dwCallerIDSize = dwCallerAddressSize;
            pCallInfo->dwCallerIDOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwCallerIDOffset),
                (LPBYTE)wszIPAddress,
                pCallInfo->dwCallerIDSize );
            
            // adjust offset to include string
            dwNextOffset += dwCallerAddressSize;
        }

        // validate buffer
        if (dwU2USize > 0)
        {
            // determine size and offset of info
            pCallInfo->dwUserUserInfoSize = dwU2USize;
            pCallInfo->dwUserUserInfoOffset = dwNextOffset;

            // copy user user info after fixed portion
            CopyMemory(
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwUserUserInfoOffset),
                (LPBYTE)pU2U,
                pCallInfo->dwUserUserInfoSize );

            // adjust offset to include string
            dwNextOffset += pCallInfo->dwUserUserInfoSize;
        }

        if( dwDivertingNameSize > 0 )
        {
            // caller name was specified
            pCallInfo->dwRedirectingIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwRedirectingIDNameSize = dwDivertingNameSize;
            pCallInfo->dwRedirectingIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwRedirectingIDNameOffset),
                (LPBYTE)(m_pCallReroutingInfo->divertingNrAlias->pItems[0].pData),
                pCallInfo->dwRedirectingIDNameSize );

            // adjust offset to include string
            dwNextOffset += dwDivertingNameSize;
            
            H323DBG(( DEBUG_LEVEL_TRACE, "diverting name: %S.",
                m_pCallReroutingInfo->divertingNrAlias->pItems[0].pData ));
        }

        if( dwDiversionNameSize > 0 )
        {
            // caller name was specified
            pCallInfo->dwRedirectionIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwRedirectionIDNameSize = dwDiversionNameSize;
            pCallInfo->dwRedirectionIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwRedirectionIDNameOffset),
                (LPBYTE)(m_pCallReroutingInfo->diversionNrAlias->pItems[0].pData),
                pCallInfo->dwRedirectionIDNameSize );

            // adjust offset to include string
            dwNextOffset += dwDiversionNameSize;

            H323DBG(( DEBUG_LEVEL_TRACE, "redirection name: %S.",
                m_pCallReroutingInfo->diversionNrAlias->pItems[0].pData ));
        }
        
        if( dwDivertedToNameSize > 0 )
        {
            pCallInfo->dwRedirectionIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwRedirectionIDNameSize = dwDivertedToNameSize;
            pCallInfo->dwRedirectionIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory(
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwRedirectionIDNameOffset),
                (LPBYTE)(m_pCallReroutingInfo->divertedToNrAlias->pItems[0].pData),
                pCallInfo->dwRedirectionIDNameSize );

            // adjust offset to include string
            dwNextOffset += pCallInfo->dwRedirectionIDNameSize;
            
            // adjust offset to include string
            dwNextOffset += dwDivertedToNameSize;

            H323DBG(( DEBUG_LEVEL_TRACE, "redirection name: %S.",
                m_pCallReroutingInfo->divertedToNrAlias->pItems[0].pData ));

        }

        //pass on the call data
        if( dwCallDataSize > 0 )
        {
            pCallInfo -> dwCallDataSize = dwCallDataSize;
            pCallInfo -> dwCallDataOffset = dwNextOffset;

            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo -> dwCallDataOffset),
                (LPBYTE)m_CallData.pOctetString,
                pCallInfo -> dwCallDataSize );

            dwNextOffset += dwCallDataSize;
        }

    }
    else if (pCallInfo->dwTotalSize >= sizeof(LINECALLINFO))
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "linecallinfo structure too small for strings." ));

        // structure only contains fixed portion
        pCallInfo->dwUsedSize = sizeof(LINECALLINFO);

    }
    else 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "linecallinfo structure too small." ));

        // structure is too small
        return LINEERR_STRUCTURETOOSMALL;
    }

    // initialize call line device and address info
    pCallInfo->dwLineDeviceID = g_pH323Line->GetDeviceID();
    pCallInfo->dwAddressID    = 0;

    // initialize variable call parameters
    pCallInfo->dwOrigin     = m_dwOrigin;
    pCallInfo->dwMediaMode  = m_dwIncomingModes | m_dwOutgoingModes;

    if( m_dwCallType & CALLTYPE_DIVERTEDDEST )
    {
        if(m_pCallReroutingInfo->diversionReason==DiversionReason_cfu)
        {
            pCallInfo->dwReason = LINECALLREASON_FWDUNCOND;
        }
        else if(m_pCallReroutingInfo->diversionReason==DiversionReason_cfnr)
        {
            pCallInfo->dwReason = LINECALLREASON_FWDNOANSWER;
        }
        else
        {
            pCallInfo->dwReason = LINECALLREASON_FWDBUSY;
        }
    }
    if( m_dwCallType & CALLTYPE_TRANSFEREDDEST )
    {
        pCallInfo->dwReason = LINECALLREASON_TRANSFER;
    }
    else
    {
        pCallInfo->dwReason = LINECALLREASON_DIRECT;
    }

    pCallInfo->dwCallStates = (m_dwOrigin==LINECALLORIGIN_INBOUND)
                                ? H323_CALL_INBOUNDSTATES
                                : H323_CALL_OUTBOUNDSTATES
                                ;

    // initialize constant call parameters
    pCallInfo->dwBearerMode = H323_LINE_BEARERMODES;
    pCallInfo->dwRate       = H323_LINE_MAXRATE;

    // initialize unsupported call capabilities
    pCallInfo->dwConnectedIDFlags = LINECALLPARTYID_UNAVAIL;
    
    //pass on the dwAppSpecific info
    pCallInfo -> dwAppSpecific = m_dwAppSpecific;

    H323DBG(( DEBUG_LEVEL_ERROR, "CopyCallInfo exited:%p.",this ));
    
    return retVal;
}


//!!always called in lock
BOOL
CH323Call::HandleReadyToInitiate(
    IN PTspMspMessage  pMessage
    )
{
    Q931_SETUP_ASN  setupASN;
    WORD            wCount;
    DWORD           dwAPDUType = 0;
    
    H323DBG(( DEBUG_LEVEL_ERROR, "HandleReadyToInitiate entered:%p.", this ));

    //set the additional callee addresses and callee aliases
    //see if there is a fast-connect proposal
    if( pMessage->dwEncodedASNSize != 0 )
    {
        if( !ParseSetupASN( pMessage ->pEncodedASNBuf,
                            pMessage->dwEncodedASNSize, 
                            &setupASN,
                            &dwAPDUType ))
        {
            goto cleanup;
        }

        if( setupASN.fFastStartPresent )
        {
            _ASSERTE( !m_pFastStart );
            m_pFastStart = setupASN.pFastStart;
            setupASN.pFastStart = NULL;
            m_dwFastStart = FAST_START_SELF_AVAIL;
        }
        else
        {
            m_dwFastStart = FAST_START_NOTAVAIL;
        }

        if( setupASN.pCallerAliasList && !RasIsRegistered() )
        {
            //_ASSERTE(0);

            if( m_pCallerAliasNames == NULL )
            {
                m_pCallerAliasNames = setupASN.pCallerAliasList;

                //dont release this alias list
                setupASN.pCallerAliasList = NULL;
            }
            else
            {
                wCount = m_pCallerAliasNames->wCount +
                    setupASN.pCallerAliasList->wCount;
                
                PH323_ALIASITEM tempPtr = setupASN.pCallerAliasList->pItems;
                
                setupASN.pCallerAliasList->pItems = (PH323_ALIASITEM)realloc( 
                    (PVOID)setupASN.pCallerAliasList->pItems, 
                    wCount * sizeof(H323_ALIASITEM) );

                if( setupASN.pCallerAliasList->pItems == NULL )
                {
                    //restore the old pointer in case enough memory was not
                    //available to expand the memory block
                    setupASN.pCallerAliasList->pItems = tempPtr;
                }
                else
                {
                    CopyMemory(
                        (PVOID)&(setupASN.pCallerAliasList->pItems[setupASN.pCallerAliasList->wCount]),
                        (PVOID)m_pCallerAliasNames->pItems,
                        m_pCallerAliasNames->wCount * sizeof(H323_ALIASITEM) );
                
                    setupASN.pCallerAliasList->wCount = wCount;

                    delete m_pCallerAliasNames->pItems;
                    delete m_pCallerAliasNames;
                    m_pCallerAliasNames = setupASN.pCallerAliasList;
                    setupASN.pCallerAliasList = NULL;
                }
            }
        }

        //add the callee aliases sent by the MSP
        if( setupASN.pCalleeAliasList != NULL )
        {
            //_ASSERTE(0);
            
            if( m_pCalleeAliasNames == NULL )
            {
                m_pCalleeAliasNames = setupASN.pCalleeAliasList;

                //dont release this alias list
                setupASN.pCalleeAliasList = NULL;
            }
            else
            {
                wCount = m_pCalleeAliasNames->wCount +
                    setupASN.pCalleeAliasList->wCount;
                
                PH323_ALIASITEM tempPtr = m_pCalleeAliasNames->pItems;
                
                m_pCalleeAliasNames->pItems = (PH323_ALIASITEM)realloc( 
                    (PVOID)m_pCalleeAliasNames->pItems, 
                    wCount * sizeof(H323_ALIASITEM) );

                if( m_pCalleeAliasNames->pItems == NULL )
                {
                    //restore the old pointer in case enough memory was not
                    //available to expand the memory block
                    m_pCalleeAliasNames->pItems = tempPtr;
                    goto cleanup;
                }

                CopyMemory( 
                    (PVOID)&(m_pCalleeAliasNames->pItems[m_pCalleeAliasNames->wCount]),
                    (PVOID)setupASN.pCalleeAliasList->pItems,
                    setupASN.pCalleeAliasList->wCount * sizeof(H323_ALIASITEM) );

                m_pCalleeAliasNames->wCount = wCount;

                delete setupASN.pCalleeAliasList->pItems;
                delete setupASN.pCalleeAliasList;
                setupASN.pCalleeAliasList = NULL;
            }
        }

        FreeSetupASN( &setupASN );
    }
    else
    {
        m_dwFastStart = FAST_START_NOTAVAIL;
    }
            
    //send the setup message
    if( !SendSetupMessage() )
    {
        DropCall( 0 );
    }
    
  
    H323DBG(( DEBUG_LEVEL_ERROR, "HandleReadyToInitiate exited:%p.", this ));
    return TRUE;    

cleanup:

    CloseCall( 0 );        
    FreeSetupASN( &setupASN );
    return FALSE;
}


//!!always called in lock
BOOL
CH323Call::HandleProceedWithAnswer(
    IN PTspMspMessage  pMessage
    )
{
    Q931_CALL_PROCEEDING_ASN    proceedingASN;
    DWORD                       dwAPDUType = 0;
    PH323_ALIASITEM             pwszDivertedToAlias = NULL;
    WCHAR                       *pwszAliasName = NULL;
    WORD                        wAliasLength = 0;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleProceedWithAnswer entered:%p.", this ));

    if( m_dwCallType & CALLTYPE_DIVERTED_SERVED )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, 
            "Call already diverted. ignore the message:%p.", this ));
        return TRUE;
    }
        
    //see if there is a fast-connect proposal
    if( pMessage->dwEncodedASNSize != 0 )
    {
        if( !ParseProceedingASN(pMessage ->pEncodedASNBuf,
                pMessage->dwEncodedASNSize, 
                &proceedingASN,
                &dwAPDUType ) )
        {
            goto cleanup;
        }

        if( proceedingASN.fH245AddrPresent )
        {
            m_selfH245Addr = proceedingASN.h245Addr;
        }

        if( proceedingASN.fFastStartPresent && 
            (m_dwFastStart!=FAST_START_NOTAVAIL) )
        {
            _ASSERTE( m_pFastStart == NULL );
            
            m_pFastStart = proceedingASN.pFastStart;
            m_dwFastStart = FAST_START_AVAIL;

            //we keep a reference to the fast start list so don't release it 
            proceedingASN.pFastStart = NULL;
            proceedingASN.fFastStartPresent = FALSE;
        }
        /*else
        {
            m_dwFastStart = FAST_START_NOTAVAIL;
        }*/
        
        FreeProceedingASN( &proceedingASN );
    }
    /*else
    {
        m_dwFastStart = FAST_START_NOTAVAIL;
    }*/
    
    //send proceeding message to the peer
    if(!SendProceeding() )
    {
        goto cleanup;
    }

    //send alerting message to the peer
    if( !SendQ931Message(NO_INVOKEID, 0, 0, ALERTINGMESSAGETYPE, NO_H450_APDU) )
    {
        goto cleanup;
    }

    m_dwStateMachine = Q931_ALERT_SENT;

    //for TRANSFEREDDEST call directly accept the call wihtout the user 
    //answering the call
    if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
    {
        AcceptCall();
    }

    if( m_pCallerAliasNames && (m_pCallerAliasNames -> wCount > 0) )
    {
        pwszAliasName = m_pCallerAliasNames->pItems[0].pData;
        wAliasLength = (m_pCallerAliasNames->pItems[0].wDataLength+1) 
            * sizeof(WCHAR);
                
        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }

    pwszDivertedToAlias = g_pH323Line->CallToBeDiverted( 
            pwszAliasName, 
            wAliasLength,
            LINEFORWARDMODE_NOANSW | LINEFORWARDMODE_NOANSWSPECIFIC |
            LINEFORWARDMODE_BUSYNA | LINEFORWARDMODE_BUSYNASPECIFIC );

    //if call is to be diverted for no answer, start the timer
    if( pwszDivertedToAlias != NULL )
    {
        if( !StartTimerForCallDiversionOnNA( pwszDivertedToAlias ) )
        {
            goto cleanup;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleProceedWithAnswer exited:%p.",this ));
    return TRUE;

cleanup:

    CloseCall( 0 );
    return FALSE;
}


//!!always called in lock
BOOL
CH323Call::HandleReadyToAnswer(
    IN PTspMspMessage  pMessage
    )
{
    Q931_CALL_PROCEEDING_ASN    proceedingASN;
    DWORD                       dwAPDUType = 0;
    PH323_CALL                  pConsultCall = NULL;
    
    H323DBG(( DEBUG_LEVEL_ERROR, "HandleReadyToAnswer entered:%p.",this ));

    m_fReadyToAnswer = TRUE;

    //see if there is a fast-connect proposal
    if( pMessage->dwEncodedASNSize != 0 )
    {
        if( !ParseProceedingASN(pMessage ->pEncodedASNBuf,
                                pMessage->dwEncodedASNSize, 
                                &proceedingASN,
                                &dwAPDUType) )
        {
            goto cleanup;
        }

        if( proceedingASN.fH245AddrPresent )
        {
            m_selfH245Addr =  proceedingASN.h245Addr;
        }

        if( proceedingASN.fFastStartPresent && 
            (m_dwFastStart!=FAST_START_NOTAVAIL) )
        {
            _ASSERTE( m_pFastStart == NULL );
            
            m_pFastStart = proceedingASN.pFastStart;
            m_dwFastStart = FAST_START_AVAIL;

            //we keep a reference to the fast start list so don't release it 
            proceedingASN.pFastStart = NULL;
            proceedingASN.fFastStartPresent = FALSE;
        }
        else
        {
            m_dwFastStart = FAST_START_NOTAVAIL;
        }
        
        FreeProceedingASN( &proceedingASN );
    }
    else
    {
        m_dwFastStart = FAST_START_NOTAVAIL;
    }

    if( m_fCallAccepted )
    {
        // validate status
        if( !AcceptH323Call() )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "error answering call 0x%08lx.", this ));

            // failure
            goto cleanup;
        }

        //lock the primary call after replacement call to avoid deadlock
        if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
        {
            QueueSuppServiceWorkItem( SWAP_REPLACEMENT_CALL, 
                m_hdCall, (ULONG_PTR)m_hdRelatedCall );
        }
        else
        {
            //send MSP start H245
            SendMSPStartH245( NULL, NULL );

            //tell MSP about connect state
            SendMSPMessage( SP_MSG_ConnectComplete, 0, 0, NULL );
        }

        //change call state to accepted from offering
        ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "HandleReadyToAnswer exited:%p.",this ));
    return TRUE;

cleanup:

    CloseCall( 0 );
    return FALSE;

}


//!!This function must be always called in a lock. The calling function should
//not unlock the call object as this function itself unlocks the call object
BOOL
CH323Call::HandleMSPMessage(
    IN PTspMspMessage  pMessage,
    IN HDRVMSPLINE     hdMSPLine,
    IN HTAPIMSPLINE    htMSPLine
    )
{
    BOOL                fResult = TRUE;
    PH323_CALL          pCall = NULL;
    ASN1octetstring_t   pH245PDU;

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleMSPMessage entered:%p.",this ));
    
    H323DBG(( DEBUG_LEVEL_TRACE, "MSP message:%s recvd.", 
        H323TSPMessageToString(pMessage->MessageType) ));

    switch( pMessage -> MessageType )
    {
    case SP_MSG_ReadyToInitiate:

        // The Q.931 connection should be in the connected state by now
        if( pMessage -> MsgBody.ReadyToInitiateMessage.hMSPReplacementCall != NULL )
        {
            //unlock the primary call before locking the related call
            Unlock();

            pCall=g_pH323Line -> FindH323CallAndLock(m_hdRelatedCall);
            if( pCall == NULL )
            {
                //transfered call is not around so close the primary call
                CloseCall( 0 );
                return TRUE;
            }

            fResult = pCall -> HandleReadyToInitiate( pMessage );
            pCall -> Unlock();
        }
        else
        {
            m_hdMSPLine = hdMSPLine;
            m_htMSPLine = htMSPLine;
            fResult = HandleReadyToInitiate( pMessage );
            Unlock();
        }
        
        break;

    case SP_MSG_ProceedWithAnswer:
    
        if( pMessage -> MsgBody.ProceedWithAnswerMessage.hMSPReplacementCall != NULL )
        {
            //unlock the primary call before locking the related call
            Unlock();

            pCall=g_pH323Line -> FindH323CallAndLock(m_hdRelatedCall);
            if( pCall == NULL )
            {
                //transfered call is not around so close the primary call
                CloseCall( 0 );
                return FALSE;
            }

            fResult = pCall -> HandleProceedWithAnswer( pMessage );
            pCall -> Unlock();
        }
        else
        {
            m_hdMSPLine = hdMSPLine;
            m_htMSPLine = htMSPLine;
            fResult = HandleProceedWithAnswer( pMessage );
            Unlock();
        }
        
        break;

    case SP_MSG_ReadyToAnswer:

        if( pMessage -> MsgBody.ReadyToAnswerMessage.hMSPReplacementCall != NULL )
        {
            //unlock the primary call before locking the related call
            Unlock();

            pCall=g_pH323Line -> FindH323CallAndLock(m_hdRelatedCall);
            if( pCall== NULL )
            {
                //transfered call is not around so close the primary call
                CloseCall( 0 );
                return FALSE;
            }

            fResult = pCall -> HandleReadyToAnswer( pMessage );
            pCall -> Unlock();
        }
        else
        {
            //decode call_proceding message and extract local fast
            //start inforamtion and local H245 address
            fResult = HandleReadyToAnswer( pMessage );
            Unlock();
        }

        break;
    
    case SP_MSG_ReleaseCall:
        
        //shutdown the H323 call
        CloseCall( LINEDISCONNECTMODE_CANCELLED );
        
        Unlock();
        break;
        
    case SP_MSG_H245Terminated:
        
        //shutdown the H323 call
        CloseCall( LINEDISCONNECTMODE_NORMAL );
        
        Unlock();
        break;
        
    case SP_MSG_SendDTMFDigits:

        if( m_fMonitoringDigits == TRUE )
        {
            WCHAR * pwch = pMessage->pWideChars;

            H323DBG(( DEBUG_LEVEL_VERBOSE, "dtmf digits recvd:%S.", pwch));

            // process each digit
            WORD indexI=0; 
            while( indexI < pMessage->MsgBody.SendDTMFDigitsMessage.wNumDigits )
            {
                // signal incoming
                PostLineEvent(
                    LINE_MONITORDIGITS,
                    (DWORD_PTR)*pwch,
                    LINEDIGITMODE_DTMF,
                    GetTickCount()
                    );

                ++pwch;
                indexI++;
            }
        }
        Unlock();
        break;

    case SP_MSG_LegacyDefaultAlias:

        if( pMessage -> MsgBody.LegacyDefaultAliasMessage.wNumChars > 0 )
        {
            if( !RasIsRegistered() )
            {
                _ASSERTE( m_pwszDisplay == NULL );
                
                m_pwszDisplay = new WCHAR[
                    pMessage -> MsgBody.LegacyDefaultAliasMessage.wNumChars ];
            
                if( m_pwszDisplay != NULL )
                {
                    CopyMemory( 
                        (PVOID)m_pwszDisplay,
                        pMessage->pWideChars,
                        sizeof(WCHAR) * pMessage -> MsgBody.LegacyDefaultAliasMessage.wNumChars
                        );
                }
            }
        }

        Unlock();
        break;

    case SP_MSG_H245PDU:

        if( (pMessage ->pEncodedASNBuf) && (pMessage->dwEncodedASNSize != 0) )
        {
            pH245PDU.value = pMessage ->pEncodedASNBuf;
            pH245PDU.length = pMessage->dwEncodedASNSize;
            fResult = SendQ931Message( NO_INVOKEID, 0, (ULONG_PTR)&pH245PDU,
                FACILITYMESSAGETYPE, NO_H450_APDU );
        }
        Unlock();
        break;

    case SP_MSG_RASRegistrationEvent:   
    default:

        _ASSERTE(0);
        Unlock();
        break;
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "HandleMSPMessage exited:%p.",this ));
    return fResult;
}


//!!always called in a lock
void
CH323Call::SendMSPMessage(
                          IN TspMspMessageType messageType,
                          IN BYTE* pbEncodedBuf,
                          IN DWORD dwLength,
                          IN HDRVCALL hReplacementCall
                         )
{
    TspMspMessageEx messageEx;
    HTAPIMSPLINE    hMSP = MSP_HANDLE_UNKNOWN;
    int             iError = 0;
    int             iLen = sizeof(SOCKADDR_IN);
    SOCKADDR_IN*    psaLocalQ931Addr = NULL;

    H323DBG(( DEBUG_LEVEL_ERROR, "SendMSPMessage:%s entered:%p.",
        H323TSPMessageToString(messageType), this ));

    messageEx.message.MessageType = messageType;

    switch( messageType )
    {
    case SP_MSG_InitiateCall:

        messageEx.message.MsgBody.InitiateCallMessage.hTSPReplacementCall = 
            (HANDLE)hReplacementCall;
        messageEx.message.MsgBody.InitiateCallMessage.hTSPConferenceCall = 
            m_hdConf;

        psaLocalQ931Addr = 
            &messageEx.message.MsgBody.InitiateCallMessage.saLocalQ931Addr;
        ZeroMemory( (PVOID)psaLocalQ931Addr, sizeof(SOCKADDR_IN) );

        *psaLocalQ931Addr = m_LocalAddr;
        psaLocalQ931Addr->sin_family = AF_INET;

        break;

    case SP_MSG_PrepareToAnswer:

        if( (dwLength<=0) || (dwLength > sizeof(messageEx.pEncodedASN)) || 
            (!pbEncodedBuf) )
        {
            CloseCall( 0 );
            return;
        }

        messageEx.message.MsgBody.PrepareToAnswerMessage.hReplacementCall = 
            (HANDLE)hReplacementCall;
        
        psaLocalQ931Addr = 
            &messageEx.message.MsgBody.PrepareToAnswerMessage.saLocalQ931Addr;
        ZeroMemory( (PVOID)psaLocalQ931Addr, sizeof(SOCKADDR_IN) );

        *psaLocalQ931Addr = m_LocalAddr;
        psaLocalQ931Addr->sin_family = AF_INET;
        
        //send the received Setup message. This should have the information
        //about m_pPeerFastStart param as wel
        CopyMemory( (PVOID)messageEx.message.pEncodedASNBuf,
                (PVOID)pbEncodedBuf, dwLength );
        break;

    case SP_MSG_SendDTMFDigits:

        if( (dwLength<=0) || (dwLength > sizeof(messageEx.pEncodedASN)) || 
            (!pbEncodedBuf) )
        {
            CloseCall( 0 );
			return;
		}

		hMSP = m_htMSPLine;
		messageEx.message.MsgBody.SendDTMFDigitsMessage.wNumDigits = 
			(WORD)dwLength;

		dwLength = (dwLength+1) * sizeof(WCHAR);
		CopyMemory( (PVOID)messageEx.message.pEncodedASNBuf,
			(PVOID)pbEncodedBuf, dwLength );

		break;

	case SP_MSG_ConnectComplete:
	case SP_MSG_CallShutdown:

		//dont set anything
		hMSP = m_htMSPLine;
		break;

	case SP_MSG_H245PDU:
	case SP_MSG_AnswerCall:

		hMSP = m_htMSPLine;
		break;

	case SP_MSG_Hold:

		hMSP = m_htMSPLine;
		messageEx.message.MsgBody.HoldMessage.fHold = (BOOL)dwLength;
		dwLength = 0;
		break;
	}

	messageEx.message.dwMessageSize = sizeof(TspMspMessage) + dwLength
							- ((dwLength)?sizeof(WORD):0);
		
	if( messageType == SP_MSG_SendDTMFDigits )
	{
		messageEx.message.dwEncodedASNSize = 0;
	}
	else
	{
		messageEx.message.dwEncodedASNSize = dwLength;
	}
	
	//send msp message
	PostLineEvent (
		LINE_SENDMSPDATA,
		(DWORD_PTR)hMSP, //This handle should be NULL when htCall param is a valid value
		(DWORD_PTR)&(messageEx.message),
		messageEx.message.dwMessageSize);

	H323DBG(( DEBUG_LEVEL_ERROR, "SendMSPMessage exited:%p.",this ));
	return;
}


//always called in lock
void
CH323Call::SendMSPStartH245(
	PH323_ADDR pPeerH245Addr,
	PH323_FASTSTART pPeerFastStart
	)
{
	TspMspMessageEx messageEx;
	WORD			wEncodedLength;
	BYTE*			pEncodedASNBuffer;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "SendMSPStartH245 entered:%p.", this ));

	wEncodedLength = 0;

	messageEx.message.MessageType = SP_MSG_StartH245;
	messageEx.message.MsgBody.StartH245Message.hMSPReplaceCall = NULL;
	messageEx.message.MsgBody.StartH245Message.hTSPReplacementCall = 
		(HANDLE)pPeerH245Addr;
	ZeroMemory( messageEx.message.MsgBody.StartH245Message.ConferenceID,
		sizeof(GUID) );

	messageEx.message.MsgBody.StartH245Message.fH245TunnelCapability = FALSE;
	messageEx.message.MsgBody.StartH245Message.fH245AddressPresent = FALSE;

	memset( (PVOID)&messageEx.message.MsgBody.StartH245Message.saH245Addr,
			0, sizeof(SOCKADDR_IN) );

	//for outgoing call send the fast start proposal.
	if( (m_dwOrigin==LINECALLORIGIN_OUTBOUND) || pPeerH245Addr )
	{
		if( pPeerH245Addr == NULL )
		{
			pPeerFastStart = m_pPeerFastStart;
		}

		if( pPeerFastStart != NULL )
		{
			if( !EncodeFastStartProposal( pPeerFastStart, &pEncodedASNBuffer,
				&wEncodedLength ) )
			{
				CloseCall( 0 );
				return;
			}

			CopyMemory( (PVOID)messageEx.message.pEncodedASNBuf,
				(PVOID)pEncodedASNBuffer, wEncodedLength );
			
			ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedASNBuffer );
		}
	}

	//If outgoing call send peer's H245 address
	if( (m_dwOrigin == LINECALLORIGIN_OUTBOUND) || pPeerH245Addr )
	{
		if( pPeerH245Addr == NULL )
		{
			pPeerH245Addr = &m_peerH245Addr;
		}

		messageEx.message.MsgBody.StartH245Message.fH245AddressPresent = FALSE;
		if( pPeerH245Addr->Addr.IP_Binary.dwAddr != 0 )
		{
			messageEx.message.MsgBody.StartH245Message.saH245Addr.sin_family = AF_INET;
			messageEx.message.MsgBody.StartH245Message.saH245Addr.sin_port = 
				htons(pPeerH245Addr->Addr.IP_Binary.wPort);
			messageEx.message.MsgBody.StartH245Message.saH245Addr.sin_addr.s_addr = 
				htonl(pPeerH245Addr->Addr.IP_Binary.dwAddr);

			messageEx.message.MsgBody.StartH245Message.fH245AddressPresent = TRUE;
		}
	}

	//set the Q931 address
	ZeroMemory( (PVOID)&messageEx.message.MsgBody.StartH245Message.saQ931Addr, 
			sizeof(SOCKADDR_IN) );

	messageEx.message.MsgBody.StartH245Message.saQ931Addr.sin_family = AF_INET;
	messageEx.message.MsgBody.StartH245Message.saQ931Addr.sin_port = 
		htons( m_CalleeAddr.Addr.IP_Binary.wPort );
	messageEx.message.MsgBody.StartH245Message.saQ931Addr.sin_addr.s_addr = 
		htonl( m_CalleeAddr.Addr.IP_Binary.dwAddr );

	messageEx.message.MsgBody.StartH245Message.fH245TunnelCapability = 
		(m_fh245Tunneling & REMOTE_H245_TUNNELING) &&
		(m_fh245Tunneling & LOCAL_H245_TUNNELING);

	messageEx.message.dwMessageSize = sizeof(messageEx.message) + 
		wEncodedLength - ((wEncodedLength)?1:0);

	messageEx.message.dwEncodedASNSize = wEncodedLength; 

	// send msp message
	PostLineEvent (
		LINE_SENDMSPDATA,
		//this handle should be NULL when htCall is a valid handle.
		(DWORD_PTR)NULL, 
		(DWORD_PTR)&(messageEx.message),
		messageEx.message.dwMessageSize);
		
	m_dwFlags |= H245_START_MSG_SENT;

	H323DBG(( DEBUG_LEVEL_ERROR, "SendMSPStartH245 exited:%p.",this ));
	return;
}


//always called in lock
BOOL
CH323Call::AddU2U(
					IN DWORD dwDirection,
					IN DWORD dwDataSize,
					IN PBYTE pData
				 )
		
/*++

Routine Description:

	Create user user structure and adds to list.

Arguments:

	pLftHead - Pointer to list in which to add user user info.

	dwDataSize - Size of buffer pointed to by pData.

	pData - Pointer to user user info.

Return Values:

	Returns true if successful.
	
--*/

{
	PLIST_ENTRY 	pListHead = NULL;
	PUserToUserLE	pU2ULE;
		
	H323DBG(( DEBUG_LEVEL_ERROR, "AddU2U entered:%p.",this ));

	if( dwDirection == U2U_OUTBOUND )
	{
		pListHead = &m_OutgoingU2U;
	}
	else
	{
		pListHead = &m_IncomingU2U;
	}

	// validate data buffer pointer and size
	if( (pData != NULL) && (dwDataSize > 0) )
	{
		// allocate memory for user user info
		pU2ULE = (PUserToUserLE)new char[ dwDataSize + sizeof(UserToUserLE) ];

		// validate pointer
		if (pU2ULE == NULL)
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"could not allocate user user info." ));

			// failure
			return FALSE;
		}

		// aim pointer at the end of the buffer by default
		pU2ULE->pU2U = (LPBYTE)pU2ULE + sizeof(UserToUserLE);
		pU2ULE->dwU2USize = dwDataSize;

		// transfer user user info into list entry
		CopyMemory( (PVOID)pU2ULE->pU2U, (PVOID)pData, pU2ULE->dwU2USize);

		// add list entry to back of list
		InsertTailList(pListHead, &pU2ULE->Link);

		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"added user user info 0x%08lx (%d bytes).",
			pU2ULE->pU2U,
			pU2ULE->dwU2USize
			));
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "AddU2U exited:%p.",this ));
	// success
	return TRUE;
}


		
/*++

Routine Description:

	Create user user structure and adds to list.
	!!always called in lock.

Arguments:

	pLftHead - Pointer to list in which to add user user info.

	dwDataSize - Size of buffer pointed to by pData.

	pData - Pointer to user user info.

Return Values:

	Returns true if successful.
	
--*/

BOOL
CH323Call::AddU2UNoAlloc(
	IN DWORD dwDirection,
	IN DWORD dwDataSize,
	IN PBYTE pData
	)
{
	PLIST_ENTRY 	pListHead = NULL;
	PUserToUserLE	pU2ULE;
		
	H323DBG(( DEBUG_LEVEL_ERROR, "AddU2U entered:%p.",this ));

	if( dwDirection == U2U_OUTBOUND )
	{
		pListHead = &m_OutgoingU2U;
	}
	else
	{
		pListHead = &m_IncomingU2U;
	}

	// validate data buffer pointer and size
	if( (pData != NULL) && (dwDataSize > 0) )
	{
		// allocate memory for user user info
		pU2ULE = new UserToUserLE;

		// validate pointer
		if (pU2ULE == NULL)
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"could not allocate user user info." ));

			// failure
			return FALSE;
		}

		// aim pointer at the end of the buffer by default
		pU2ULE->pU2U = pData;
		pU2ULE->dwU2USize = dwDataSize;

		
		// add list entry to back of list
		InsertTailList(pListHead, &pU2ULE->Link);

		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"added user user info 0x%08lx (%d bytes).",
			pU2ULE->pU2U,
			pU2ULE->dwU2USize
			));
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "AddU2U exited:%p.",this ));
	// success
	return TRUE;
}


//!!must be always called in a lock.
BOOL
CH323Call::RemoveU2U(
					IN DWORD dwDirection,
					IN PUserToUserLE * ppU2ULE
					)
		
/*++

Routine Description:

	Removes user user info structure from list.

Arguments:

	pListHead - Pointer to list in which to remove user user info.

	ppU2ULE - Pointer to pointer to list entry.

Return Values:

	Returns true if successful.
	
--*/

{
	PLIST_ENTRY pListHead = NULL;
	PLIST_ENTRY pLE;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "RemoveU2U entered:%p.",this ));

	if( dwDirection == U2U_OUTBOUND )
	{
		pListHead = &m_OutgoingU2U;
	}
	else
	{
		pListHead = &m_IncomingU2U;
	}

	// process list until empty
	if( IsListEmpty(pListHead) == FALSE )
	{
		// retrieve first entry
		pLE = RemoveHeadList(pListHead);

		// convert list entry to structure pointer
		*ppU2ULE = CONTAINING_RECORD(pLE, UserToUserLE, Link);

		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"removed user user info 0x%08lx (%d bytes).",
			(*ppU2ULE)->pU2U, (*ppU2ULE)->dwU2USize ));
	
		H323DBG(( DEBUG_LEVEL_ERROR, "RemoveU2U exited:%p.",this ));
		// success
		return TRUE;
	}
			
	// failure
	return FALSE;
}


BOOL
CH323Call::FreeU2U(
					IN DWORD dwDirection
				  )
		
/*++

Routine Description:

	Releases memory for user user list.
	!!must be always called in a lock.

Arguments

	pListHead - Pointer to list in which to free user user info.

Return Values:

	Returns true if successful.
	
--*/

{
	PLIST_ENTRY 	pLE;
	PUserToUserLE	pU2ULE;
	PLIST_ENTRY 	pListHead = NULL;
		
	H323DBG(( DEBUG_LEVEL_ERROR, "FreeU2U entered:%p.",this ));

	if( dwDirection == U2U_OUTBOUND )
    {
        pListHead = &m_OutgoingU2U;
    }
	else
    {
		pListHead = &m_IncomingU2U;
    }

	// process list until empty
	while( IsListEmpty(pListHead) == FALSE ) 
	{
		// retrieve first entry
		pLE = RemoveHeadList(pListHead);

		// convert list entry to structure pointer
		pU2ULE = CONTAINING_RECORD(pLE, UserToUserLE, Link);

		//	release memory
		if( pU2ULE )
		{
			delete pU2ULE;
			pU2ULE = NULL;
		}
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "FreeU2U exited:%p.",this ));
	// success
	return TRUE;
}


/*++

Routine Description:

	Resets call object to original state for re-use.

Arguments:

Return Values:

	Returns true if successful.
	
--*/

void
CH323Call::Shutdown(
					OUT BOOL * fDelete
				   )
{	 
	H323DBG(( DEBUG_LEVEL_ERROR, "Shutdown entered:%p.",this ));

	if( !(m_dwFlags & CALLOBJECT_INITIALIZED) )
	{
		return;
	}

	//acquire the lock on call table before acquiring the lock on call object
	g_pH323Line -> LockCallTable();
	Lock();

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		Unlock();
		g_pH323Line -> UnlockCallTable();

		return;
	}

	// reset tapi info
	m_dwCallState		= LINECALLSTATE_UNKNOWN;
	m_dwCallStateMode	= 0;
	m_dwOrigin			= LINECALLORIGIN_UNKNOWN;
	m_dwAddressType 	= 0;
	m_dwIncomingModes	= 0;
	m_dwOutgoingModes	= 0;
	m_dwRequestedModes	= 0;
	m_fMonitoringDigits = FALSE;

	// reset tapi handles
	m_htCall	= (HTAPICALL)NULL;

	// reset addresses
	memset( (PVOID)&m_CalleeAddr,0,sizeof(H323_ADDR));
	memset( (PVOID)&m_CallerAddr,0,sizeof(H323_ADDR));

	H323DBG(( DEBUG_LEVEL_ERROR, "deleting calleealias:%p.",this ));
	FreeAliasNames( m_pCalleeAliasNames );
	m_pCalleeAliasNames = NULL;

	if( m_pCallerAliasNames != NULL )
	{
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	
		FreeAliasNames( m_pCallerAliasNames );
		m_pCallerAliasNames = NULL;
	}

	//reset non standard data
	memset( (PVOID)&m_NonStandardData, 0, sizeof(H323NonStandardData) );

	// release user user information
	FreeU2U( U2U_OUTBOUND );
	FreeU2U( U2U_INBOUND );

	//shutdown the Q931 call if not shutdown yet
	if( m_hSetupSentTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
		m_hSetupSentTimer = NULL;
	}

	if( m_hCallEstablishmentTimer )
	{
		DeleteTimerQueueTimer(H323TimerQueue, m_hCallEstablishmentTimer, NULL);
		m_hCallEstablishmentTimer = NULL;
	}
	
	if( m_hCallDivertOnNATimer )
	{
		DeleteTimerQueueTimer(H323TimerQueue, m_hCallDivertOnNATimer, NULL);
		m_hCallDivertOnNATimer = NULL;
	}
	
	*fDelete = FALSE;
	if( m_IoRefCount == 0 )
	{
		*fDelete = TRUE;
	}

	m_dwStateMachine = Q931_CALL_STATE_NONE;
	if( m_callSocket != INVALID_SOCKET )
	{
		if(shutdown( m_callSocket, SD_BOTH ) == SOCKET_ERROR)
		{
			H323DBG((DEBUG_LEVEL_TRACE, "couldn't shutdown the socket:%d, %p.",
				WSAGetLastError(), this ));
		}

		closesocket( m_callSocket );
		m_callSocket = INVALID_SOCKET;
	}

	m_pwszDisplay = NULL;

	FreeVendorInfo( &m_peerVendorInfo );

	if( m_peerNonStandardData.sData.pOctetString )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "deleting nonstd:%p.",this ));
		delete m_peerNonStandardData.sData.pOctetString;
		m_peerNonStandardData.sData.pOctetString = NULL;
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "deleting xtraalias:%p.",this ));
	FreeAliasNames( m_pPeerExtraAliasNames );
	m_pPeerExtraAliasNames = NULL;

		
	H323DBG(( DEBUG_LEVEL_ERROR, "deleting display:%p.",this ));
	if( m_pPeerDisplay )
	{
		delete m_pPeerDisplay;
		m_pPeerDisplay = NULL;
	}

	if( m_CallData.pOctetString != NULL )
	{
		delete m_CallData.pOctetString;
	}
		
	H323DBG(( DEBUG_LEVEL_ERROR, "deleting hdconf:%p.",this ));
	// delete conference 
	if( m_hdConf != NULL )
	{
		g_pH323Line -> GetH323ConfTable() -> Remove( m_hdConf );
		delete m_hdConf;
		m_hdConf = NULL;
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "deleting preparetoans:%p.",this ));
	if( m_prepareToAnswerMsgData.pbBuffer )
    {
		delete m_prepareToAnswerMsgData.pbBuffer;
    }

	ZeroMemory( (PVOID)&m_prepareToAnswerMsgData, sizeof(BUFFERDESCR) );

		
	H323DBG(( DEBUG_LEVEL_ERROR, "deleting drq timer:%p.",this ));
	//ras related data structures
	if( m_hDRQTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hDRQTimer, NULL );
		m_hDRQTimer = NULL;
	}
		
	H323DBG(( DEBUG_LEVEL_ERROR, "deleting arq timer:%p.",this ));
	if( m_hARQTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, NULL );
		m_hARQTimer = NULL;
	}

	if( m_pPeerFastStart != NULL )
	{
		FreeFastStart( m_pPeerFastStart );
		m_pPeerFastStart = NULL;
	}

	if( m_pFastStart != NULL )
	{
		FreeFastStart( m_pFastStart );
		m_pFastStart = NULL;
	}

	if( m_pARQExpireContext != NULL )
	{
		delete m_pARQExpireContext;
		m_pARQExpireContext = NULL;
	}

	if( m_pDRQExpireContext != NULL )
	{
		delete m_pDRQExpireContext;
		m_pDRQExpireContext = NULL;
	}

	FreeCallForwardData();

	g_pH323Line -> RemoveCallFromTable (m_hdCall);

	m_dwFlags |= CALLOBJECT_SHUTDOWN;

	Unlock();
	g_pH323Line -> UnlockCallTable();
		
	H323DBG(( DEBUG_LEVEL_ERROR, "Shutdown exited:%p.",this ));
	return;
}


void
CH323Call::FreeCallForwardData()
{
	if( m_pCallReroutingInfo )
	{
		FreeCallReroutingInfo();
	}

	if( m_hCheckRestrictionTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCheckRestrictionTimer, 
			NULL );
		m_hCheckRestrictionTimer = NULL;
	}

	if( m_hCallReroutingTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCallReroutingTimer, NULL );
		m_hCallReroutingTimer = NULL;
	}

	if( m_hCTIdentifyTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyTimer, NULL );
		m_hCTIdentifyTimer = NULL;
	}

	if( m_hCTIdentifyRRTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyRRTimer, NULL );
		m_hCTIdentifyRRTimer = NULL;
	}

	if( m_hCTInitiateTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCTInitiateTimer, NULL );
		m_hCTInitiateTimer = NULL;
	}

	if( m_pTransferedToAlias )
	{
		FreeAliasNames( m_pTransferedToAlias );
		m_pTransferedToAlias = NULL;
	}

	if( m_dwCallType & CALLTYPE_TRANSFERED2_CONSULT )
	{
		g_pH323Line -> RemoveFromCTCallIdentityTable( m_hdCall );
	}

	if( m_H450ASNCoderInfo.pEncInfo )
	{
		TermH450ASNCoder();
	}

	if( m_pCallForwardParams )
	{
		FreeCallForwardParams( m_pCallForwardParams );
		m_pCallForwardParams = NULL;
	}

	if( m_pForwardAddress )
	{
		FreeForwardAddress( m_pForwardAddress );
		m_pForwardAddress = NULL;
	}
}


BOOL
CH323Call::ResolveCallerAddress(void)
		
/*++

Routine Description:

	Resolves caller address from callee address.
	!!must be always called in a lock.

Arguments:

Return Values:

	Returns true if successful.
	
--*/

{
	INT 	 nStatus;
	SOCKET	 hCtrlSocket = INVALID_SOCKET;
	SOCKADDR CalleeSockAddr;
	SOCKADDR CallerSockAddr;
	DWORD	 dwNumBytesReturned = 0;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveCallerAddress entered:%p.",this ));

	// allocate control socket
	hCtrlSocket = WSASocket(
					AF_INET,			// af
					SOCK_DGRAM, 		// type
					IPPROTO_IP, 		// protocol
					NULL,				// lpProtocolInfo
					0,					// g
					WSA_FLAG_OVERLAPPED // dwFlags
					);

	// validate control socket
	if (hCtrlSocket == INVALID_SOCKET)
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error %d creating control socket.", WSAGetLastError() ));

		// failure
		return FALSE;
	}

	// initialize ioctl parameters
	memset( (PVOID)&CalleeSockAddr,0,sizeof(SOCKADDR));
	memset( (PVOID)&CallerSockAddr,0,sizeof(SOCKADDR));

	// initialize address family
	CalleeSockAddr.sa_family = AF_INET;

	// transfer callee information
	((SOCKADDR_IN*)&CalleeSockAddr)->sin_addr.s_addr =
		htonl(m_CalleeAddr.Addr.IP_Binary.dwAddr);

	// query stack
	nStatus = WSAIoctl(
				hCtrlSocket,
				SIO_ROUTING_INTERFACE_QUERY,
				&CalleeSockAddr,
				sizeof(SOCKADDR),
				&CallerSockAddr,
				sizeof(SOCKADDR),
				&dwNumBytesReturned,
				NULL,
				NULL
				);

	// release handle
	closesocket(hCtrlSocket);

	// validate return code
	if (nStatus == SOCKET_ERROR)
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error 0x%08lx calling SIO_ROUTING_INTERFACE_QUERY.",
			WSAGetLastError() ));

		// failure
		return FALSE;
	}

	// save interface address of best route
	m_CallerAddr.nAddrType = H323_IP_BINARY;
	m_CallerAddr.Addr.IP_Binary.dwAddr =
		ntohl(((SOCKADDR_IN*)&CallerSockAddr)->sin_addr.s_addr);
	m_CallerAddr.Addr.IP_Binary.wPort =
		LOWORD(g_RegistrySettings.dwQ931ListenPort);
	m_CallerAddr.bMulticast =
		IN_MULTICAST(m_CallerAddr.Addr.IP_Binary.dwAddr);

	H323DBG(( DEBUG_LEVEL_TRACE,
		"caller address resolved to %s.",
		H323AddrToString(((SOCKADDR_IN*)&CallerSockAddr)->sin_addr.s_addr) ));

	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveCallerAddress exited:%p.",this ));
	// success
	return TRUE;
}


BOOL
CH323Call::ResolveE164Address(
								IN LPCWSTR pwszDialableAddr
							 )
		
/*++

Routine Description:

	Resolves E.164 address ("4259367111").
	!!must be always called in a lock.

Arguments:

	pwszDialableAddr - Specifies a pointer to the dialable address specified
		by the TAPI application.

Return Values:

	Returns true if successful.
	
--*/

{
	WCHAR wszAddr[H323_MAXDESTNAMELEN+1];
	DWORD dwE164AddrSize;
   
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveE164Address entered:%p.",this ));

	// make sure pstn gateway has been specified
	if ((g_RegistrySettings.fIsGatewayEnabled == FALSE) ||
		(g_RegistrySettings.gatewayAddr.nAddrType == 0))
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"pstn gateway not specified."
			));

		// failure
		return FALSE;
	}

	// save gateway address as callee address
	m_CalleeAddr = g_RegistrySettings.gatewayAddr;

	dwE164AddrSize = ValidateE164Address( pwszDialableAddr, wszAddr );
	if( dwE164AddrSize == 0 )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"invlid e164 callee alias ."));

		return FALSE;
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE,
			"callee alias resolved to E.164 number." ));

	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveE164Address exited:%p.",this ));
	
	//determine caller address
	return ResolveCallerAddress();
}


DWORD
ValidateE164Address(
				   LPCWSTR pwszDialableAddr,
				   WCHAR*  wszAddr
				   )
{
	DWORD dwE164AddrSize = 0;
	WCHAR * pwszValidE164Chars;
	WCHAR wszValidE164Chars[] = { H323_ALIAS_H323_PHONE_CHARS L"\0" };

	// process until termination char
	while (*pwszDialableAddr != L'\0')
	{
		// reset pointer to valid characters
		pwszValidE164Chars = wszValidE164Chars;

		// process until termination char
		while (*pwszValidE164Chars != L'\0')
		{
			// see if valid E.164 character specified
			if (*pwszDialableAddr == *pwszValidE164Chars)
			{
				// save valid character in temp buffer
				wszAddr[dwE164AddrSize++] = *pwszDialableAddr;

				break;
			}

			// next valid char
			++pwszValidE164Chars;
		}

		// next input char
		++pwszDialableAddr;
	}

	// terminate string
	wszAddr[dwE164AddrSize++] = L'\0';

	// validate string
	if (dwE164AddrSize == 0)
	{
		H323DBG(( DEBUG_LEVEL_TRACE,
			"no valid E.164 characters in string." ));
	}

	return dwE164AddrSize;
}


		
/*++

Routine Description:

	Resolves IP address ("172.31.255.231") or DNS entry ("NIKHILB1").
	!!must be always called in a lock.

Arguments:

	pszDialableAddr - Specifies a pointer to the dialable address specified
		by the TAPI application.

Return Values:

	Returns true if successful.
	
--*/

BOOL
CH323Call::ResolveIPAddress(
	IN LPSTR pszDialableAddr
	)
{
	DWORD			dwIPAddr;
	struct hostent* pHost;

	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveIPAddress entered:%p.",this ));
	
	// attempt to convert ip address
	dwIPAddr = inet_addr(pszDialableAddr);

	// see if address converted
	if( dwIPAddr == INADDR_NONE )
	{
		// attempt to lookup hostname
		pHost = gethostbyname(pszDialableAddr);

		// validate pointer
		if( pHost != NULL )
		{
			// retrieve host address from structure
			dwIPAddr = *(unsigned long *)pHost->h_addr;
		}
	}

	// see if address converted
	if( dwIPAddr == INADDR_NONE )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
				  "error 0x%08lx resolving IP address.",
				  WSAGetLastError() ));

		// failure
		return FALSE;
	}

	// save converted address
	m_CalleeAddr.nAddrType = H323_IP_BINARY;
	m_CalleeAddr.Addr.IP_Binary.dwAddr = ntohl(dwIPAddr);
	m_CalleeAddr.Addr.IP_Binary.wPort =
		LOWORD(g_RegistrySettings.dwQ931ListenPort);
	m_CalleeAddr.bMulticast =
		IN_MULTICAST(m_CalleeAddr.Addr.IP_Binary.dwAddr);

	H323DBG(( DEBUG_LEVEL_TRACE,
		"callee address resolved to %s:%d.",
		H323AddrToString(dwIPAddr),
		m_CalleeAddr.Addr.IP_Binary.wPort ));
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveIPAddress exited:%p.",this ));

	// determine caller address
	return ResolveCallerAddress();
}


BOOL
CH323Call::ResolveEmailAddress(
	IN LPCWSTR	  pwszDialableAddr,
	IN LPSTR	  pszUser,
	IN LPSTR	  pszDomain
	)
		
/*++

Routine Description:

	Resolves e-mail address ("nikhilb@microsoft.com").
	!!must be always called in a lock.

Arguments:

	pwszDialableAddr - Specifies a pointer to the dialable address specified
		by the TAPI application.

	pszUser - Specifies a pointer to the user component of e-mail name.

	pszDomain - Specified a pointer to the domain component of e-mail name.

Return Values:

	Returns true if successful.
	
--*/

{
	DWORD dwAddrSize;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveEmailAddress entered:%p.",this ));

	// size destination address string
	dwAddrSize = wcslen(pwszDialableAddr) + 1;

	// attempt to resolve domain locally
	if( ResolveIPAddress( pszDomain) ) 
	{
		// success
		return TRUE;
	}

	// make sure proxy has been specified
	if( (g_RegistrySettings.fIsProxyEnabled == FALSE) ||
		(g_RegistrySettings.proxyAddr.nAddrType == 0) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "proxy not specified." ));

		// failure
		return FALSE;
	}

	// save proxy address as callee address
	m_CalleeAddr = g_RegistrySettings.proxyAddr;

	H323DBG(( DEBUG_LEVEL_TRACE,
		"callee alias resolved to H.323 alias."));
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveEmailAddress exited:%p.",this ));

	// determine caller address
	return ResolveCallerAddress();
}


		
/*++

Routine Description:

	Resolves remote address and determines the correct local address
	to use in order to reach remote address.
	!!must be always called in a lock.

Arguments:

	pwszDialableAddr - Specifies a pointer to the dialable address specified
		by the TAPI application.

Return Values:

	Returns true if successful.
	
--*/

BOOL
CH323Call::ResolveAddress(
	IN LPCWSTR pwszDialableAddr
	)
{
	CHAR szDelimiters[] = "@ \t\n";
	CHAR szAddr[H323_MAXDESTNAMELEN+1];
	LPSTR pszUser = NULL;
	LPSTR pszDomain = NULL;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveAddress entered:%p.",this ));

	// validate pointerr
	if (pwszDialableAddr == NULL)
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "null destination address." ));

		// failure
		return FALSE;
	}

	H323DBG(( DEBUG_LEVEL_TRACE,
		"resolving %s %S.",
		H323AddressTypeToString( m_dwAddressType),
		pwszDialableAddr ));

	// check whether phone number has been specified
	if( m_dwAddressType == LINEADDRESSTYPE_PHONENUMBER )
	{
		// need to direct call to pstn gateway
		return ResolveE164Address( pwszDialableAddr);
	}

	// convert address from unicode
	if (WideCharToMultiByte(
			CP_ACP,
			0,
			pwszDialableAddr,
			-1,
			szAddr,
			sizeof(szAddr),
			NULL,
			NULL
			) == 0)
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"could not convert address from unicode." ));

		// failure
		return FALSE;
	}

	// parse user name
	pszUser = strtok(szAddr, szDelimiters);

	// parse domain name
	pszDomain = strtok(NULL, szDelimiters);

	// validate pointer
	if (pszUser == NULL)
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "could not parse destination address." ));

		// failure
		return FALSE;
	}

	// validate pointer
	if (pszDomain == NULL)
	{
		// switch pointers
		pszDomain = pszUser;

		// re-initialize
		pszUser = NULL;
	}

	H323DBG(( DEBUG_LEVEL_VERBOSE,
		"resolving user %s domain %s.",
		pszUser,
		pszDomain
		));
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveAddress exited:%p.",this ));

	// process e-mail and domain names
	return ResolveEmailAddress(
				pwszDialableAddr,
				pszUser,
				pszDomain
				);
}


BOOL
/*++

Routine Description:

	Validate optional call parameters specified by user.
	
	!!no need to call in a lock because not added to the call table yet
	
Arguments:

	pCallParams - Pointer to specified call parameters to be
		validated.

	pwszDialableAddr - Pointer to the dialable address specified
		by the TAPI application.

	pdwStatus - Pointer to DWORD containing error code if this
		routine fails for any reason.

Return Values:

	Returns true if successful.
	
--*/

CH323Call::ValidateCallParams(
	IN LPLINECALLPARAMS pCallParams,
	IN LPCWSTR			pwszDialableAddr,
	IN PDWORD			pdwStatus
	)
{
	DWORD dwMediaModes = H323_LINE_DEFMEDIAMODES;
	DWORD dwAddrSize;
	WCHAR wszAddr[H323_MAXDESTNAMELEN+1];

	PH323_ALIASNAMES pAliasList;
	WCHAR* wszMachineName;

	H323DBG(( DEBUG_LEVEL_TRACE, "ValidateCallParams entered:%p.", this ));

	H323DBG(( DEBUG_LEVEL_VERBOSE, "clearing unknown media mode." ));
	
	// validate pointer
	if( (pCallParams == NULL) || (pwszDialableAddr == NULL) )
    {
		return FALSE;
    }

	// retrieve media modes specified
	dwMediaModes = pCallParams->dwMediaMode;

	// retrieve address type specified
	m_dwAddressType = pCallParams->dwAddressType;

	// see if we support call parameters
	if( pCallParams->dwCallParamFlags != 0 )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"do not support call parameters 0x%08lx.",
			pCallParams->dwCallParamFlags ));

		// do not support param flags
		*pdwStatus = LINEERR_INVALCALLPARAMS;
		
		// failure
		return FALSE;
	}

	// see if unknown bit is specified
	if( dwMediaModes & LINEMEDIAMODE_UNKNOWN )
	{
		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"clearing unknown media mode." ));

		// clear unknown bit from modes
		dwMediaModes &= ~LINEMEDIAMODE_UNKNOWN;
	}

	// see if both audio bits are specified 
	if( (dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) &&
		(dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE) )
	{
		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"clearing automated voice media mode." ));

		// clear extra audio bit from modes
		dwMediaModes &= ~LINEMEDIAMODE_INTERACTIVEVOICE;
	}

	// see if we support media modes specified
	if( dwMediaModes & ~H323_LINE_MEDIAMODES )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"do not support media modes 0x%08lx.", 
			pCallParams->dwMediaMode ));

		// do not support media mode
		*pdwStatus = LINEERR_INVALMEDIAMODE;

		// failure
		return FALSE;
	}

	// see if we support bearer modes
	if( pCallParams->dwBearerMode & ~H323_LINE_BEARERMODES )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"do not support bearer mode 0x%08lx.",
			pCallParams->dwBearerMode ));

		// do not support bearer mode
		*pdwStatus = LINEERR_INVALBEARERMODE;

		// failure
		return FALSE;
	}

	// see if we support address modes
	if( pCallParams->dwAddressMode & ~H323_LINE_ADDRESSMODES )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"do not support address mode 0x%08lx.",
			pCallParams->dwAddressMode ));

		// do not support address mode
		*pdwStatus = LINEERR_INVALADDRESSMODE;

		// failure
		return FALSE;
	}

	// validate address id specified
	if (pCallParams->dwAddressID != 0 )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "address id 0x%08lx invalid.",
			pCallParams->dwAddressID ));

		// invalid address id
		*pdwStatus = LINEERR_INVALADDRESSID;
		
		// failure
		return FALSE;
	}

	// validate destination address type specified
	if( m_dwAddressType & ~H323_LINE_ADDRESSTYPES )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "address type 0x%08lx invalid.",
			pCallParams->dwAddressType ));

		// invalid address type
		*pdwStatus = LINEERR_INVALADDRESSTYPE;

		//failure
		return FALSE;
	}

	if( m_dwAddressType == LINEADDRESSTYPE_PHONENUMBER )
	{
		dwAddrSize = ValidateE164Address( pwszDialableAddr, wszAddr );

		//add the callee alias
		if( dwAddrSize==0 )
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"invlid e164 callee alias ."));

			return FALSE;
		}
		
		if( (dwAddrSize > MAX_E164_ADDR_LEN) || (dwAddrSize == 0) )
			return FALSE;
		
		if(!AddAliasItem( m_pCalleeAliasNames,
			  (BYTE*)wszAddr,
			  dwAddrSize * sizeof(WCHAR),
			  e164_chosen ))
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"could not allocate for callee alias ."));
			// invalid destination addr
			*pdwStatus = LINEERR_INVALADDRESS;

			return FALSE;
		}
		
		H323DBG(( DEBUG_LEVEL_ERROR, "callee alias added:%S.", wszAddr ));
	}
	else
	{
		dwAddrSize = (wcslen(pwszDialableAddr)+1);

		if( (dwAddrSize > MAX_H323_ADDR_LEN) || (dwAddrSize == 0) )
			return FALSE;
		
		if(!AddAliasItem( m_pCalleeAliasNames,
			  (BYTE*)pwszDialableAddr,
			  dwAddrSize * sizeof(WCHAR),
			  h323_ID_chosen ))
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"could not allocate for callee alias ."));
			// invalid destination addr
			*pdwStatus = LINEERR_INVALADDRESS;

			return FALSE;
		}

		H323DBG(( DEBUG_LEVEL_ERROR, "callee alias added:%S.", pwszDialableAddr ));
	}

	// see if callee alias specified
	if( pCallParams->dwCalledPartySize > 0 ) 
	{
		//avoid duplicate aliases
		dwAddrSize *= sizeof(WCHAR);

		if( ( (m_dwAddressType != LINEADDRESSTYPE_PHONENUMBER) ||
			  (memcmp(
					(PVOID)((BYTE*)pCallParams + pCallParams->dwCalledPartyOffset),
					wszAddr,
					pCallParams->dwCalledPartySize ) != 0 ) 
			) &&
			( memcmp(
				(PVOID)((BYTE*)pCallParams + pCallParams->dwCalledPartyOffset),
				pwszDialableAddr,
				pCallParams->dwCalledPartySize ) != 0 
			)
		  )
		{
			// allocate memory for callee string
			if( !AddAliasItem( m_pCalleeAliasNames,
				  (BYTE*)pCallParams + pCallParams->dwCalledPartyOffset,
				  pCallParams->dwCalledPartySize,
				  (m_dwAddressType != LINEADDRESSTYPE_PHONENUMBER)?
				  h323_ID_chosen : e164_chosen) )
			{
				H323DBG(( DEBUG_LEVEL_ERROR,
						"could not allocate caller name." ));

				// invalid address id
				*pdwStatus = LINEERR_NOMEM;

				// failure
				return FALSE;
			}

			H323DBG(( DEBUG_LEVEL_ERROR, "callee alias added:%S.", 
				((BYTE*)pCallParams + pCallParams->dwCalledPartyOffset) ));
		}
	}

	// see if caller name specified
	if( pCallParams->dwCallingPartyIDSize > 0 )
	{
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
		// allocate memory for callee string
		if(!AddAliasItem( m_pCallerAliasNames,
			(BYTE*)pCallParams + pCallParams->dwCallingPartyIDOffset,
			pCallParams->dwCallingPartyIDSize,
			h323_ID_chosen ) )
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
					"could not allocate caller name." ));

			// invalid address id
			*pdwStatus = LINEERR_NOMEM;

			// failure
			return FALSE;
		}
			
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	}
	else if( RasIsRegistered() )
	{
		//ARQ message must have a caller alias
		pAliasList = RASGetRegisteredAliasList();
		wszMachineName = pAliasList -> pItems[0].pData;
		
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
		
		//set the value for m_pCallerAliasNames
		if( !AddAliasItem( m_pCallerAliasNames,
			(BYTE*)(wszMachineName),
			sizeof(WCHAR) * (wcslen(wszMachineName) + 1 ),
			pAliasList -> pItems[0].wType ) )
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
					"could not allocate caller name." ));

			// invalid address id
			*pdwStatus = LINEERR_NOMEM;

			// failure
			return FALSE;
		}
		
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	}
		
	// check for user user information
	if( pCallParams->dwUserUserInfoSize > 0 )
	{
		// save user user info
		if (AddU2U( U2U_OUTBOUND, pCallParams->dwUserUserInfoSize,
			(LPBYTE)pCallParams + pCallParams->dwUserUserInfoOffset ) == FALSE )
		{
			//no need to free above aloocated memory for m_CalleeAlias and
			//m_CallerAlias

			// invalid address id
			*pdwStatus = LINEERR_NOMEM;

			// failure
			return FALSE;
		}
	}

	// save call data buffer.
	if( SetCallData( (LPBYTE)pCallParams + pCallParams->dwCallDataOffset,
			pCallParams->dwCallDataSize ) == FALSE )
	{
		//no need to free above aloocated memory for m_CalleeAlias and
		//m_CallerAlias

		// invalid address id
		*pdwStatus = LINEERR_NOMEM;

		// failure
		return FALSE;
	}
		
	// clear incoming modes
	m_dwIncomingModes = 0;
	
	// outgoing modes will be finalized after H.245 stage
	m_dwOutgoingModes = dwMediaModes | LINEMEDIAMODE_UNKNOWN;
	
	// save media modes specified
	m_dwRequestedModes = dwMediaModes;

	H323DBG(( DEBUG_LEVEL_TRACE, "ValidateCallParams exited:%p.", this ));
	// success
	return TRUE;
}

		
/*++

Routine Description:

	Associates call object with the specified conference id.

Arguments:

Return Values:

	Returns true if successful.
	
--*/

PH323_CONFERENCE
CH323Call::CreateConference (
	IN GUID* pConferenceId	OPTIONAL)

{
	int iresult;
	
	H323DBG(( DEBUG_LEVEL_TRACE, "CreateConference entered:%p.", this ));

	Lock();

	_ASSERTE( m_hdConf == NULL );

	// create conference 
	m_hdConf = new H323_CONFERENCE( this );
		
	// validate 
	if ( m_hdConf == NULL )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"could no allocate the conference object."));

		Unlock();
		return NULL;
	}

	if (pConferenceId)
	{
		m_ConferenceID = *pConferenceId;
	}
	else
	{
		iresult = UuidCreate (&m_ConferenceID);
  
		if ((iresult == RPC_S_OK) || (iresult ==RPC_S_UUID_LOCAL_ONLY))
		{
			H323DBG ((DEBUG_LEVEL_INFO, "generated new conference id (GUID)."));
		}
		else
		{
			H323DBG(( DEBUG_LEVEL_ERROR, 
				"failed to generate GUID for conference id: %d.", iresult ));
			ZeroMemory (&m_ConferenceID, sizeof m_ConferenceID);
		}
	}
	
	Unlock();

	H323DBG(( DEBUG_LEVEL_TRACE, "CreateConference exited:%p.", this ));
	return m_hdConf;
}


/*++

Routine Description:

	Initiates outbound call to specified destination.
	!!always called in a lock

Arguments:

	none

Return Values:

	Returns true if successful.
	
--*/

BOOL
CH323Call::PlaceCall(void)
{
	H323DBG(( DEBUG_LEVEL_TRACE, "PlaceCall entered:%p.", this ));

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return FALSE;
	}

	// see if user user information specified
	CopyU2UAsNonStandard( U2U_OUTBOUND );

	if( m_pwszDisplay == NULL )
	{
		// see if caller alias specified
		if( m_pCallerAliasNames && m_pCallerAliasNames -> wCount )
		{
			 if((m_pCallerAliasNames ->pItems[0].wType == h323_ID_chosen) ||
				(m_pCallerAliasNames ->pItems[0].wType == e164_chosen) )
			 {
				// send caller name as display
				m_pwszDisplay = m_pCallerAliasNames -> pItems[0].pData;
	
				//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
			 }
			
			 //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
		}
	}

	// validate
	if( !SetupCall() )
	{
		H323DBG(( DEBUG_LEVEL_VERBOSE, "Q931 call: failed." ));
		return FALSE;
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "PlaceCall exited:%p.", this ));

	// return status
	return TRUE;
}


void
CH323Call::DropUserInitiated(
	IN DWORD dwDisconnectMode
	)
{
	//since this is a user initiated drop, the transfered call should also
	//be dropped for a primary call and vice versa
	if( IsTransferredCall( m_dwCallType ) && m_hdRelatedCall )
	{
		QueueTAPILineRequest( 
			TSPI_CLOSE_CALL, 
			m_hdRelatedCall, 
			NULL, 
			dwDisconnectMode,
			m_wCallReference );
	}

	DropCall(dwDisconnectMode);
}


//always called in lock
BOOL
/*++

Routine Description:

	Hangs up call (if necessary) and changes state to idle.

Arguments:

	dwDisconnectMode - Status code for disconnect.

Return Values:

	Returns true if successful.
	
--*/

CH323Call::DropCall(
					IN DWORD dwDisconnectMode
				   )
{
	PUserToUserLE pU2ULE = NULL;

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return FALSE;
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE, "DropCall entered:%p.", this ));

	if( (m_dwRASCallState == RASCALL_STATE_REGISTERED ) ||
		(m_dwRASCallState == RASCALL_STATE_ARQSENT ) )
	{
		//disengage from the GK
		SendDRQ( forcedDrop_chosen, NOT_RESEND_SEQ_NUM, TRUE );
	}

	// determine call state
	switch (m_dwCallState)
	{
	case LINECALLSTATE_CONNECTED:

		// hangup call (this will invoke async indication)
		// validate
		//encode ASN.1 and send Q931release message to the peer
		if(!SendQ931Message( NO_INVOKEID,
							 0,
							 0,
							 RELEASECOMPLMESSAGETYPE,
							 NO_H450_APDU ))
		{
			 //post a message to the callback thread to shutdown the H323 call
			 H323DBG(( DEBUG_LEVEL_ERROR,
				"error hanging up call 0x%08lx.", this ));
		}
		else
		{
			m_dwStateMachine = Q931_RELEASE_SENT;
	
			H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx hung up.", this ));
		}

		// change call state to disconnected
		ChangeCallState(LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

		break;

	case LINECALLSTATE_OFFERING:

		// see if user user information specified
		CopyU2UAsNonStandard( U2U_OUTBOUND );

		// reject call
		//encode ASN.1 and send Q931Setup message to the peer
		if( SendQ931Message( NO_INVOKEID,
							 0,
							 0,
							 RELEASECOMPLMESSAGETYPE,
							 NO_H450_APDU ))
		{
			m_dwStateMachine = Q931_RELEASE_SENT;
			H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx rejected.", this ));
		}
		else
		{
			H323DBG(( DEBUG_LEVEL_ERROR, "error reject call 0x%08lx.",this));
		}

		// change call state to disconnected
		ChangeCallState(LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

		break;

	case LINECALLSTATE_RINGBACK:
	case LINECALLSTATE_ACCEPTED:

		// cancel outbound call
		if( SendQ931Message( NO_INVOKEID,
							 0,
							 0,
							 RELEASECOMPLMESSAGETYPE,
							 NO_H450_APDU ))
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"error cancelling call 0x%08lx.", this ));
		}
		else
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"error reject call 0x%08lx.", this ));
		}

		// change call state to disconnected
		ChangeCallState(LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

		break;

	case LINECALLSTATE_DIALING:
		
		// change call state to disconnected
		ChangeCallState(LINECALLSTATE_DISCONNECTED, dwDisconnectMode);
		
		break;

	case LINECALLSTATE_DISCONNECTED:

		//
		// disconnected but still need to clean up
		//
		break;

	case LINECALLSTATE_IDLE:

		//
		// call object already idle
		//

		if( (m_dwCallType == CALLTYPE_NORMAL) &&
			(m_dwStateMachine == Q931_SETUP_RECVD) )
		{
			if( SendQ931Message( NO_INVOKEID,
							 0,
							 0,
							 RELEASECOMPLMESSAGETYPE,
							 NO_H450_APDU ))
			{
				H323DBG(( DEBUG_LEVEL_ERROR,
					"error cancelling call 0x%08lx.", this ));
			}
			else
			{
				H323DBG(( DEBUG_LEVEL_ERROR,
					"error reject call 0x%08lx.", this ));
			}
		}

		DropSupplementaryServicesCalls();

		return TRUE;
	}

	if( ( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall ) ||
		( (m_dwCallType & CALLTYPE_TRANSFEREDSRC ) && m_hdRelatedCall ) )
	{
		m_dwCallState = LINECALLSTATE_IDLE;
	}
	else
	{
		// Tell the MSP to stop streaming.
		SendMSPMessage( SP_MSG_CallShutdown, 0, 0, NULL );

		// change call state to idle
		ChangeCallState( LINECALLSTATE_IDLE, 0 );
	}

	if( (m_dwCallType & CALLTYPE_TRANSFEREDSRC ) && m_hdRelatedCall )
	{
		//drop the primary call
		if( !QueueTAPILineRequest( 
			TSPI_CLOSE_CALL,
			m_hdRelatedCall,
			NULL,
			LINEDISCONNECTMODE_NORMAL,
			NULL ) )
		{
			H323DBG((DEBUG_LEVEL_ERROR, "could not post H323 close event"));
		}		 
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "DropCall exited:%p.", this ));	
	// success
	return TRUE;
}


void
CH323Call::DropSupplementaryServicesCalls()
{
	if( (m_dwCallType & CALLTYPE_FORWARDCONSULT) ||
		(m_dwCallType & CALLTYPE_DIVERTED_SERVED) ||
		(m_dwCallType & CALLTYPE_DIVERTEDSRC) ||
		(m_dwCallType & CALLTYPE_DIVERTEDSRC_NOROUTING) )
	{
		if( m_dwQ931Flags & Q931_CALL_CONNECTED )
		{
			if( SendQ931Message( NO_INVOKEID,
						 0,
						 0,
						 RELEASECOMPLMESSAGETYPE,
						 NO_H450_APDU ))
			{
				m_dwStateMachine = Q931_RELEASE_SENT;
				H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx rejected.", this ));
			}
		}

		g_pH323Line->m_fForwardConsultInProgress = FALSE;
	}

	if( (m_dwCallType & CALLTYPE_FORWARDCONSULT) &&
		(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
	{
		//inform the user about failure of line forward operation
		if( m_dwCallDiversionState != H4503_CHECKRESTRICTION_SUCC )
		{
			(*g_pfnLineEventProc)(
				g_pH323Line->m_htLine,
				(HTAPICALL)NULL,
				(DWORD)LINE_ADDRESSSTATE,
				(DWORD)LINEADDRESSSTATE_FORWARD,
				(DWORD)LINEADDRESSSTATE_FORWARD,
				(DWORD)0
				);
		}
	}

	if( m_dwCallType & CALLTYPE_DIVERTEDSRC )
	{
		ChangeCallState( LINECALLSTATE_IDLE, 0 );
	}
}


//!!always called in a lock
BOOL
CH323Call::HandleConnectMessage(
							   IN Q931_CONNECT_ASN *pConnectASN
							   )
{
	PH323_CALL	pPrimaryCall = NULL;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleConnectMessage entered:%p.", this ));

	if( pConnectASN->fNonStandardDataPresent )
	{
		//add user user info
		if( AddU2UNoAlloc( U2U_INBOUND,
				pConnectASN->nonStandardData.sData.wOctetStringLength,
				pConnectASN->nonStandardData.sData.pOctetString ) == TRUE )
		{
			H323DBG(( DEBUG_LEVEL_VERBOSE,
				"user user info available in CONNECT PDU." ));
					
			if( !(m_dwCallType & CALLTYPE_TRANSFEREDSRC) )
			{
				// signal incoming
				PostLineEvent (
				   LINE_CALLINFO,
				   LINECALLINFOSTATE_USERUSERINFO, 0, 0 );
			}

			//don't release the data buffer
			pConnectASN->fNonStandardDataPresent = FALSE;
		}
		else 
		{
			H323DBG(( DEBUG_LEVEL_WARNING,
				"could not save incoming user user info." ));

			//memory failure : shutdown the H323 call
			CloseCall( 0 );

			goto cleanup;
		}
	}

	//get the vendor info
	if( pConnectASN->EndpointType.pVendorInfo )
	{
		FreeVendorInfo( &m_peerVendorInfo );

		m_peerVendorInfo = pConnectASN->VendorInfo;
		pConnectASN->EndpointType.pVendorInfo = NULL;
	}

	if( pConnectASN->h245AddrPresent )
	{
		m_peerH245Addr = pConnectASN->h245Addr;
	}

	//copy the fast start proposal
	if( pConnectASN->fFastStartPresent &&
		(m_dwFastStart!=FAST_START_NOTAVAIL) )
	{
		if( m_pPeerFastStart )
		{
			//we had received fast start params in previous proceeding
			//or alerting message
			FreeFastStart( m_pPeerFastStart );
		}

		m_pPeerFastStart = pConnectASN->pFastStart;
		m_dwFastStart = FAST_START_AVAIL;

		//we are keeping a reference to the fast start list so don't release it 
		pConnectASN->pFastStart = NULL;
	}
	else
	{
		m_dwFastStart = FAST_START_NOTAVAIL;
	}

	if( ( (m_dwCallType & CALLTYPE_TRANSFEREDSRC)|| 
		  (m_dwCallType & CALLTYPE_DIVERTEDTRANSFERED) ) && m_hdRelatedCall )
	{
		QueueSuppServiceWorkItem( SWAP_REPLACEMENT_CALL,
			m_hdCall, (ULONG_PTR)m_hdRelatedCall );
	}
	else
	{
		//start H245
		SendMSPStartH245( NULL, NULL );

		SendMSPMessage( SP_MSG_ConnectComplete, 0, 0, NULL );
	}
	
	//If we join MCU we get the conference ID of the conference we
	//joined and not the one that we sent in Setup message.
	if( IsEqualConferenceID( &pConnectASN->ConferenceID ) == FALSE )
	{
		H323DBG ((DEBUG_LEVEL_ERROR,
			"OnReceiveConnect: We received different conference id." ));

		m_ConferenceID = pConnectASN->ConferenceID;
	}

	//tell TAPI about state change
	ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
	
	FreeConnectASN( pConnectASN );

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleConnectMessage exited:%p.", this ));
	return TRUE;

cleanup:

	FreeConnectASN( pConnectASN );
	return FALSE;
}


//!!always called in a lock
void 
CH323Call::HandleAlertingMessage(
								IN Q931_ALERTING_ASN * pAlertingASN
								)
{
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleAlertingMessage entered:%p.", this ));

	if( pAlertingASN->fNonStandardDataPresent )
	{
		// add user user info
		if( AddU2UNoAlloc( U2U_INBOUND, 	
			pAlertingASN->nonStandardData.sData.wOctetStringLength,
			pAlertingASN->nonStandardData.sData.pOctetString ) == TRUE )
		{
			H323DBG(( DEBUG_LEVEL_VERBOSE,
				"user user info available in ALERT PDU." ));
					// signal incoming

			if( !(m_dwCallType & CALLTYPE_TRANSFEREDSRC) )
			{
				PostLineEvent (
					LINE_CALLINFO,
					LINECALLINFOSTATE_USERUSERINFO, 0, 0 );
			}
			
			//don't release the data buffer
			pAlertingASN->fNonStandardDataPresent = FALSE;
		}
		else
		{
			H323DBG(( DEBUG_LEVEL_WARNING,
				"could not save incoming user user info." ));

			//memory failure : shutdown the H323 call
			CloseCall( 0 );
			return;
		}
	}

	if( pAlertingASN->fH245AddrPresent )
	{
		m_peerH245Addr = pAlertingASN->h245Addr;
	}

	if( pAlertingASN->fFastStartPresent && 
		(m_dwFastStart!=FAST_START_NOTAVAIL) )
	{
		if( m_pPeerFastStart )
		{
			//we had received fast start params in previous proceeding
			//or alerting message
			FreeFastStart( m_pPeerFastStart );
		}

		m_pPeerFastStart = pAlertingASN->pFastStart;
		m_dwFastStart = FAST_START_AVAIL;

		//we are keeping a reference to the fast start list so don't release it 
		pAlertingASN->pFastStart = NULL;
		pAlertingASN->fFastStartPresent = FALSE;
	}

	//for DIVERTEDSRC, call its ok to tell TAPI about this state
	ChangeCallState( LINECALLSTATE_RINGBACK, 0 );

	/*if( pAlertingASN->fH245AddrPresent && !(m_dwFlags & H245_START_MSG_SENT) )
	{
		//start early H245
		SendMSPStartH245( NULL, NULL);
	}*/

	FreeAlertingASN( pAlertingASN );
		
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleAlertingMessage exited:%p.", this ));
	return;
}


//!!must be always called in a lock
BOOL
CH323Call::HandleSetupMessage( 
	IN Q931MESSAGE* pMessage
	)
{
	PH323_ALIASITEM pwszDivertedToAlias = NULL;
	WCHAR * 		pwszAliasName = NULL;
	WORD			wAliasLength = 0;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleSetupMessage entered:%p.", this ));

	if( m_pCallerAliasNames && (m_pCallerAliasNames -> wCount > 0) )
	{
		pwszAliasName = m_pCallerAliasNames->pItems[0].pData;
		wAliasLength = (m_pCallerAliasNames->pItems[0].wDataLength+1) 
			* sizeof(WCHAR);
	
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	}

	pwszDivertedToAlias = g_pH323Line->CallToBeDiverted( 
		pwszAliasName,
		wAliasLength,
		LINEFORWARDMODE_UNCOND | LINEFORWARDMODE_UNCONDSPECIFIC );

	if( pwszDivertedToAlias )
	{
		if( !InitiateCallDiversion( pwszDivertedToAlias, DiversionReason_cfu ) )
		{
			return FALSE;
		}
		return TRUE;
	}
	
	//send the proceeding message to the peer if not already sent by the GK
	//SendProceeding();
	
	if(RasIsRegistered())
	{
		if( !SendARQ( NOT_RESEND_SEQ_NUM ) )
		{
			return FALSE;
		}

		//copy the data to be sent in preparetoanswer message
		if( m_prepareToAnswerMsgData.pbBuffer )
			delete m_prepareToAnswerMsgData.pbBuffer;
		ZeroMemory( (PVOID)&m_prepareToAnswerMsgData, sizeof(BUFFERDESCR) );

			
		m_prepareToAnswerMsgData.pbBuffer = 
			(BYTE*)new char[pMessage->UserToUser.wUserInfoLen];
		if( m_prepareToAnswerMsgData.pbBuffer == NULL )
		{
			return FALSE;
		}

		CopyMemory( (PVOID)m_prepareToAnswerMsgData.pbBuffer, 
					(PVOID)pMessage->UserToUser.pbUserInfo,
					pMessage->UserToUser.wUserInfoLen );

		m_prepareToAnswerMsgData.dwLength = pMessage->UserToUser.wUserInfoLen;
	}
	else
	{
		if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
		{
			MSPMessageData* pMSPMessageData = new MSPMessageData;
			if( pMSPMessageData == NULL )
			{
				return FALSE;
			}

			pMSPMessageData->hdCall = m_hdRelatedCall;
			pMSPMessageData->messageType = SP_MSG_PrepareToAnswer;
			
			pMSPMessageData->pbEncodedBuf = 
				new BYTE[pMessage->UserToUser.wUserInfoLen];
			if( pMSPMessageData->pbEncodedBuf == NULL )
			{
				delete pMSPMessageData;
				return FALSE;
			}

			CopyMemory( pMSPMessageData->pbEncodedBuf, 
				(PVOID)pMessage->UserToUser.pbUserInfo,
				pMessage->UserToUser.wUserInfoLen );

			pMSPMessageData->wLength = pMessage->UserToUser.wUserInfoLen;
			pMSPMessageData->hReplacementCall = m_hdCall;

			if( !QueueUserWorkItem( SendMSPMessageOnRelatedCall, 
				pMSPMessageData, WT_EXECUTEDEFAULT ) )
			{
				delete pMSPMessageData->pbEncodedBuf;
				delete pMSPMessageData;
				return FALSE;
			}
		}
		else
		{
			// signal incoming call
			_ASSERTE(!m_htCall);

			PostLineEvent (
				LINE_NEWCALL,
				(DWORD_PTR)m_hdCall,
				(DWORD_PTR)&m_htCall, 0);

			_ASSERTE( m_htCall );
			if( m_htCall == NULL )
				return FALSE;

			if( IsListEmpty(&m_IncomingU2U) == FALSE )
			{
				// signal incoming
				PostLineEvent (
				   LINE_CALLINFO,
				   LINECALLINFOSTATE_USERUSERINFO, 0, 0);
			}
		
			ChangeCallState( LINECALLSTATE_OFFERING, 0 );
			
			//Send the new call message to the unspecified MSP
			SendMSPMessage( SP_MSG_PrepareToAnswer,
				pMessage->UserToUser.pbUserInfo,
				pMessage->UserToUser.wUserInfoLen, NULL );
		}
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleSetupMessage exited:%p.", this ));
	return TRUE;
}


BOOL
CH323Call::HandleCallDiversionFacility( 
	PH323_ADDR pAlternateAddress )
{
	PSTR pszAlias;
	WCHAR pwszAliasName[H323_MAXDESTNAMELEN];
	in_addr addr;

	if( m_pCallReroutingInfo == NULL )
	{
		m_pCallReroutingInfo = new CALLREROUTINGINFO;
		if( m_pCallReroutingInfo == NULL )
		{
			return FALSE;
		}

		ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
	}

	m_pCallReroutingInfo->diversionCounter = 1;
	m_pCallReroutingInfo->diversionReason = DiversionReason_cfu;

	//free any previous divertedTo alias
	if( m_pCallReroutingInfo->divertedToNrAlias )
	{
		FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
		m_pCallReroutingInfo->divertedToNrAlias = NULL;
	}

	addr.S_un.S_addr = htonl( pAlternateAddress->Addr.IP_Binary.dwAddr );
	pszAlias = inet_ntoa( addr );
	if( pszAlias == NULL )
		return FALSE;

	m_pCallReroutingInfo->divertedToNrAlias = new H323_ALIASNAMES;
	if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
	{
		return FALSE;
	}
	ZeroMemory( m_pCallReroutingInfo->divertedToNrAlias, 
		sizeof(H323_ALIASNAMES) );

	MultiByteToWideChar(
			GetACP(),
			MB_PRECOMPOSED,
			pszAlias,
			strlen(pszAlias)+1,
			pwszAliasName,
			H323_MAXDESTNAMELEN
		   );

	if( !AddAliasItem( m_pCallReroutingInfo->divertedToNrAlias,
		pwszAliasName, h323_ID_chosen ) )
	{
		delete m_pCallReroutingInfo->divertedToNrAlias;
		m_pCallReroutingInfo->divertedToNrAlias = NULL;
		return FALSE;
	}

	m_CalleeAddr = *pAlternateAddress;
 
	if( m_pCalleeAliasNames && m_pCalleeAliasNames->wCount )
	{
		m_pCallReroutingInfo->divertingNrAlias = new H323_ALIASNAMES;

		if( m_pCallReroutingInfo->divertingNrAlias != NULL )
		{
			ZeroMemory( (PVOID)m_pCallReroutingInfo->divertingNrAlias, 
				sizeof(H323_ALIASNAMES) );

			if( !AddAliasItem( m_pCallReroutingInfo->divertingNrAlias,
					m_pCalleeAliasNames->pItems[0].pData,
					m_pCalleeAliasNames->pItems[0].wType ) )
			{
				delete m_pCallReroutingInfo->divertingNrAlias;
				m_pCallReroutingInfo->divertingNrAlias = NULL;
			}
		}
	}
	
	m_dwCallType |= CALLTYPE_DIVERTEDSRC;
	m_dwCallDiversionState = H4503_CALLREROUTING_RECVD;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCallDiversionFacility exited:%p.", 
		this ));
	return TRUE;
}


BOOL
CH323Call::HandleCallDiversionFacility( 
	PH323_ALIASNAMES pAliasList )
{
	if( !m_pCallReroutingInfo )
	{
		m_pCallReroutingInfo = new CALLREROUTINGINFO;
		if( m_pCallReroutingInfo  == NULL )
		{
			return FALSE;
		}

		ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
	}

	m_pCallReroutingInfo->diversionCounter = 1;
	m_pCallReroutingInfo->diversionReason = DiversionReason_cfu;

	if( m_pCallReroutingInfo->divertedToNrAlias )
	{
		FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
		m_pCallReroutingInfo->divertedToNrAlias = NULL;
	}

	m_pCallReroutingInfo->divertedToNrAlias = pAliasList;
 
	if( m_pCalleeAliasNames && m_pCalleeAliasNames->wCount )
	{
		m_pCallReroutingInfo->divertingNrAlias = new H323_ALIASNAMES;

		if( m_pCallReroutingInfo->divertingNrAlias != NULL )
		{
			ZeroMemory( (PVOID)m_pCallReroutingInfo->divertingNrAlias, 
				sizeof(H323_ALIASNAMES) );

			if( !AddAliasItem( m_pCallReroutingInfo->divertingNrAlias,
					m_pCalleeAliasNames->pItems[0].pData,
					m_pCalleeAliasNames->pItems[0].wType ) )
			{
				delete m_pCallReroutingInfo->divertingNrAlias;
				m_pCallReroutingInfo->divertingNrAlias = NULL;
			}
		}
	}

	m_dwCallType |= CALLTYPE_DIVERTEDSRC;
	m_dwCallDiversionState = H4503_CALLREROUTING_RECVD;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCallDiversionFacility exited:%p.", 
        this ));
	return TRUE;
}


BOOL
CH323Call::HandleTransferFacility( 
	PH323_ALIASNAMES pAliasList )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransferFacility entered:%p.", this ));

	//argument.callIdentity
	ZeroMemory( (PVOID)m_pCTCallIdentity, sizeof(m_pCTCallIdentity) );

	//argument.reroutingNumber
	FreeAliasNames( m_pTransferedToAlias );
	m_pTransferedToAlias = pAliasList;

	m_dwCallType |= CALLTYPE_TRANSFERED_PRIMARY;
	m_dwCallDiversionState = H4502_CTINITIATE_RECV;

	//queue an event for creating a new call
	if( !QueueSuppServiceWorkItem( TSPI_DIAL_TRNASFEREDCALL, m_hdCall,
		(ULONG_PTR)m_pTransferedToAlias ))
	{
		H323DBG(( DEBUG_LEVEL_TRACE, "could not post dial transfer event." ));
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransferFacility entered:%p.", this ));
	return TRUE;
}


BOOL
CH323Call::HandleTransferFacility( 
	PH323_ADDR pAlternateAddress )
{
	PSTR pszAlias;
	WCHAR pwszAliasName[H323_MAXDESTNAMELEN];
	in_addr addr;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransferFacility entered:%p.", this ));

	//argument.callIdentity
	ZeroMemory( (PVOID)m_pCTCallIdentity, sizeof(m_pCTCallIdentity) );

	//argument.reroutingNumber
	//free any previous divertedTo alias
	FreeAliasNames( m_pTransferedToAlias );

	addr.S_un.S_addr = htonl( pAlternateAddress->Addr.IP_Binary.dwAddr );
	pszAlias = inet_ntoa( addr );
	
    if( pszAlias == NULL )
    {
		return FALSE;
    }

	m_pTransferedToAlias = new H323_ALIASNAMES;
	if( m_pTransferedToAlias == NULL )
	{
		return FALSE;
	}
	ZeroMemory( m_pTransferedToAlias, sizeof(H323_ALIASNAMES) );

	MultiByteToWideChar(
			GetACP(),
			MB_PRECOMPOSED,
			pszAlias,
			strlen(pszAlias)+1,
			pwszAliasName,
			H323_MAXDESTNAMELEN
		   );

	if( !AddAliasItem( m_pTransferedToAlias, pwszAliasName, h323_ID_chosen ) )
	{
		delete m_pTransferedToAlias;
		m_pTransferedToAlias = NULL;
		return FALSE;
	}

	m_CalleeAddr = *pAlternateAddress;

	m_dwCallType |= CALLTYPE_TRANSFERED_PRIMARY;
	m_dwCallDiversionState = H4502_CTINITIATE_RECV;

	//queue an event for creating a new call
	if( !QueueSuppServiceWorkItem( TSPI_DIAL_TRNASFEREDCALL, m_hdCall,
		(ULONG_PTR)m_pTransferedToAlias ))
	{
		H323DBG(( DEBUG_LEVEL_TRACE, "could not post dial transfer event." ));
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransferFacility entered:%p.", this ));
	return TRUE;
}


//!!always called in a lock
void 
CH323Call::HandleFacilityMessage( 
    IN DWORD dwInvokeID,
    IN Q931_FACILITY_ASN * pFacilityASN
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleFacilityMessage entered:%p.", this ));

    if( pFacilityASN->fNonStandardDataPresent )
    {
        // add user user info
        if( AddU2UNoAlloc( U2U_INBOUND,
            pFacilityASN->nonStandardData.sData.wOctetStringLength,
            pFacilityASN->nonStandardData.sData.pOctetString ) == TRUE )
        {
            H323DBG(( DEBUG_LEVEL_VERBOSE,
                "user user info available in ALERT PDU." ));
                    // signal incoming

            if( !(m_dwCallType & CALLTYPE_TRANSFEREDSRC) )
            {
                PostLineEvent (
                       LINE_CALLINFO,
                       LINECALLINFOSTATE_USERUSERINFO, 0, 0);
            }
            
            //don't release the data buffer
            pFacilityASN->fNonStandardDataPresent = FALSE;
        }
        else 
        {
            H323DBG(( DEBUG_LEVEL_WARNING,
                "could not save incoming user user info." ));

            //memory failure : shutdown the H323 call
            CloseCall( 0 );
            return;
        }
    }

    if( (pFacilityASN->bReason == callForwarded_chosen) ||
        (pFacilityASN->bReason == FacilityReason_routeCallToGatekeeper_chosen) ||
        (pFacilityASN->bReason == routeCallToMC_chosen) )
    {
        if( pFacilityASN->pAlternativeAliasList != NULL )
        {
            if( m_dwCallState == LINECALLSTATE_CONNECTED )
            {
                HandleTransferFacility( pFacilityASN->pAlternativeAliasList );
                
                //don't free the alias list
                pFacilityASN->pAlternativeAliasList = NULL;
            }
            else if( m_dwCallState != LINECALLSTATE_DISCONNECTED )
            {
                //redirect the call if not yet connected
                if( HandleCallDiversionFacility( 
                    pFacilityASN->pAlternativeAliasList ) )
                {
                    OnCallReroutingReceive( NO_INVOKEID );
                    
                    //don't free the alias list
                    pFacilityASN->pAlternativeAliasList = NULL;
                }
            }
        }
        else if( pFacilityASN->fAlternativeAddressPresent )
        {
            if( m_dwCallState == LINECALLSTATE_CONNECTED )
            {
                HandleTransferFacility( &pFacilityASN->AlternativeAddr );
            }
            else if( m_dwCallState != LINECALLSTATE_DISCONNECTED )
            {
                //redirect the call if not yet connected
                if( HandleCallDiversionFacility( &pFacilityASN->AlternativeAddr ) )
                {
                    OnCallReroutingReceive( NO_INVOKEID );
                }
            }
        }
    }

    //Handle H.450 APDU
    if( pFacilityASN->dwH450APDUType == DIVERTINGLEGINFO1_OPCODE )
    {
       if( m_dwOrigin != LINECALLORIGIN_OUTBOUND )
       {
           return;
       }

       if( m_pCallReroutingInfo->fPresentAllow )
       {
           PostLineEvent (
               LINE_CALLINFO,
               LINECALLINFOSTATE_REDIRECTINGID, 0, 0);
       }
    }
    else if( pFacilityASN->dwH450APDUType == CALLREROUTING_OPCODE )
    {
        OnCallReroutingReceive( dwInvokeID );
    }
    else if( pFacilityASN->dwH450APDUType == REMOTEHOLD_OPCODE )
    {
        if( m_fRemoteHoldInitiated )
        {
            //Hold();
            m_fRemoteHoldInitiated = FALSE;
        }
    }
    else if( pFacilityASN->dwH450APDUType == REMOTERETRIEVE_OPCODE )
    {
        if( m_fRemoteRetrieveInitiated )
        {
            //UnHold();
            m_fRemoteRetrieveInitiated = FALSE;
        }
    }
    else if( pFacilityASN->fH245AddrPresent )
    {
        m_peerH245Addr = pFacilityASN->h245Addr;
        
        H323DBG(( DEBUG_LEVEL_TRACE, "H245 address received in facility." ));
        
        //If Q931 call already connected then send another StartH245.
        if( m_dwCallState == LINECALLSTATE_CONNECTED )
        {
            SendMSPStartH245( NULL, NULL );
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleFacilityMessage exited:%p.", this ));
    return;
}


void 
CH323Call::SetNewCallInfo(
				HANDLE hConnWait, 
				HANDLE hWSAEvent, 
				DWORD dwState
			  )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "SetNewCallInfo entered." ));
	
	Lock();
	
	m_hTransportWait = hConnWait;
	m_hTransport = hWSAEvent;
	SetQ931CallState( dwState );

	Unlock();
		
	H323DBG(( DEBUG_LEVEL_TRACE, "SetNewCallInfo exited." ));
}


//!!no need to call in a lock
void 
CH323Call::SetQ931CallState( DWORD dwState )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "SetQ931CallState entered." ));
	
	//turn off the current state
	m_dwQ931Flags &= ~(Q931_CALL_CONNECTING | 
				   Q931_CALL_CONNECTED	|
				   Q931_CALL_DISCONNECTED );

	//set the new state
	m_dwQ931Flags |= dwState;
		
	H323DBG(( DEBUG_LEVEL_TRACE, "SetQ931CallState exited." ));
}


void
CH323Call::DialCall()
{
	H323DBG(( DEBUG_LEVEL_TRACE, "DialCall entered:%p.", this ));
	Lock();

	ChangeCallState( LINECALLSTATE_DIALING, 0);

	if( RasIsRegistered() )
	{
		if( !SendARQ( NOT_RESEND_SEQ_NUM ) )
		{
			//If a forward consult call then enable theforwarding anyway.
			if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
				(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
			{
				//Success of forwarding
				EnableCallForwarding();
			}

			CloseCall( 0 );
		}
	}
	else
	{
		if( !PlaceCall() )
		{
			//If a forward consult call then enable theforwarding anyway.
			if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
				(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
			{
				//Success of forwarding
				EnableCallForwarding();
			}		  

			CloseCall( LINEDISCONNECTMODE_UNREACHABLE );
		}
	}
		
	Unlock();
	H323DBG(( DEBUG_LEVEL_TRACE, "DialCall exited:%p.", this ));
}


//!!always called in a lock
void
CH323Call::MakeCall()
{
	H323DBG(( DEBUG_LEVEL_TRACE, "MakeCall entered:%p.", this ));

	ChangeCallState( LINECALLSTATE_DIALING, 0 );
	
	// resolve dialable into local and remote address
	if( !RasIsRegistered() && 
		!ResolveAddress( GetDialableAddress() ) )
	{
		CloseCall( LINEDISCONNECTMODE_BADADDRESS );
	}
	else
	{
		if( RasIsRegistered() )
		{
			if( !SendARQ( NOT_RESEND_SEQ_NUM ) )
			{
				//If a forward consult call then enable theforwarding anyway.
				if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
					(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
				{
					//Success of forwarding
					EnableCallForwarding();
				}

				CloseCall( 0 );
			}
		}
		else
		{
			if( !PlaceCall() )
			{
				//If a forward consult call then enable theforwarding anyway.
				if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
					(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
				{
					//Success of forwarding
					EnableCallForwarding();
				}		  

				CloseCall( LINEDISCONNECTMODE_UNREACHABLE );
			}
		}
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE, "MakeCall exited:%p.", this ));
}


//!!always called in a lock
void 
CH323Call::HandleProceedingMessage( 
									IN Q931_ALERTING_ASN * pProceedingASN
								  )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleProceedingMessage entered:%p.", this ));

	if( pProceedingASN->fNonStandardDataPresent )
	{
		// add user user info
		if( AddU2UNoAlloc( U2U_INBOUND, 	
				pProceedingASN->nonStandardData.sData.wOctetStringLength,
				pProceedingASN->nonStandardData.sData.pOctetString ) == TRUE )
		{
			H323DBG(( DEBUG_LEVEL_VERBOSE,
				"user user info available in ALERT PDU." ));
					// signal incoming
			if( !(m_dwCallType & CALLTYPE_TRANSFEREDSRC) )
			{
				PostLineEvent (
				   LINE_CALLINFO,
				   LINECALLINFOSTATE_USERUSERINFO, 0, 0);
			}
			
			//don't release the data buffer
			pProceedingASN->fNonStandardDataPresent = FALSE;
		}
		else 
		{
			H323DBG(( DEBUG_LEVEL_WARNING,
				"could not save incoming user user info." ));

			//memory failure : shutdown the H323 call
			CloseCall( 0 );
			return;
		}
	}

	if( pProceedingASN->fH245AddrPresent )
	{
		m_peerH245Addr = pProceedingASN->h245Addr;
	}

	if( pProceedingASN->fFastStartPresent && 
		(m_dwFastStart!=FAST_START_NOTAVAIL) )
	{
		if( m_pPeerFastStart )
		{
			//we had received fast start params in previous proceeding
			//or alerting message
			FreeFastStart( m_pPeerFastStart );
		}

		m_pPeerFastStart = pProceedingASN->pFastStart;
		m_dwFastStart = FAST_START_AVAIL;

		//we are keeping a reference to the fast start list so don't release it
		pProceedingASN->pFastStart = NULL;
		pProceedingASN->fFastStartPresent = FALSE;
	}

	/*
	if( pProceedingASN->fH245AddrPresent && !(m_dwFlags & H245_START_MSG_SENT) )
	{
		//start early H245
		SendMSPStartH245( NULL, NULL );
	}*/
	FreeProceedingASN( pProceedingASN );
		
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleProceedingMessage exited:%p.", this ));
	return;
}


//!!always called in a lock
BOOL 
CH323Call::HandleReleaseMessage( 
	IN Q931_RELEASE_COMPLETE_ASN *pReleaseASN
	)
{
	DWORD dwDisconnectMode = LINEDISCONNECTMODE_NORMAL;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleReleaseMessage entered:%p.", this ));

	if( (m_dwCallType & CALLTYPE_TRANSFERED_PRIMARY) &&
		(m_hdRelatedCall != NULL) )
	{
		return QueueSuppServiceWorkItem( DROP_PRIMARY_CALL,
				m_hdRelatedCall, (ULONG_PTR)m_hdCall );
	}
		
	//change the state to disconnected before callong drop call.
	//This will ensure that release message is not sent to the peer
	ChangeCallState( LINECALLSTATE_DISCONNECTED, 0 );
	
	//release non standard data
	if( pReleaseASN->fNonStandardDataPresent )
	{
		delete pReleaseASN->nonStandardData.sData.pOctetString;
		pReleaseASN->nonStandardData.sData.pOctetString = NULL;
	}

	//Should we drop the primary call if the transfered call in rejected?
	if( (m_dwCallType == CALLTYPE_TRANSFEREDSRC) && m_hdRelatedCall )
	{
		if( !QueueTAPILineRequest( 
			TSPI_CLOSE_CALL, 
			m_hdRelatedCall, 
			NULL,
			LINEDISCONNECTMODE_NORMAL,
			NULL ) )
		{
			H323DBG((DEBUG_LEVEL_ERROR, "could not post H323 close event"));
		}
	}

	//close call
	if( m_dwCallState != LINECALLSTATE_CONNECTED )
	{
		dwDisconnectMode = LINEDISCONNECTMODE_REJECT;
	}
	
	CloseCall( dwDisconnectMode );

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleReleaseMessage exited:%p.", this ));
	return TRUE;
}


//never call in lock
BOOL
CH323Call::InitializeIncomingCall( 
	IN Q931_SETUP_ASN* pSetupASN,
	IN DWORD dwCallType,
	IN WORD wCallRef
	)
{
	PH323_CONFERENCE	pConf;
	WCHAR*				wszMachineName;

	H323DBG((DEBUG_LEVEL_TRACE, "InitializeIncomingCall entered:%p.",this));

	//bind outgoing call
	pConf = CreateConference( &(pSetupASN->ConferenceID) );
	if( pConf == NULL )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "could not create conference." ));
		
		goto cleanup;
	}
	
	if( !g_pH323Line -> GetH323ConfTable() -> Add( pConf ) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"could not add conf to conf table." ));

		// failure
		goto cleanup;
	}

	// save caller transport address
	if( !GetPeerAddress(&m_CallerAddr) )
    {
		goto cleanup;
    }

	if( !GetHostAddress(&m_CalleeAddr) )
    {
		goto cleanup;
    }

	//get endpoint info
	m_peerEndPointType = pSetupASN->EndpointType;

	//get the vendor info
	if( pSetupASN->EndpointType.pVendorInfo )
	{
		m_peerVendorInfo = pSetupASN->VendorInfo;
		
		//we have copied the vendor info pointers. So dont release 
		//the pointers in the ASN's vendor info struct
		pSetupASN->EndpointType.pVendorInfo = NULL;
	}

	if( pSetupASN -> fCallIdentifierPresent )
	{
		m_callIdentifier = pSetupASN->callIdentifier;
	}
	else
	{
		int iresult = UuidCreate( &m_callIdentifier );
		if( (iresult != RPC_S_OK) && (iresult !=RPC_S_UUID_LOCAL_ONLY) )
        {
			goto cleanup;
        }
	}

	_ASSERTE( !m_pPeerFastStart );
	if( pSetupASN->fFastStartPresent &&
		(m_dwFastStart!=FAST_START_NOTAVAIL) )
	{
		m_pPeerFastStart = pSetupASN->pFastStart;

		m_dwFastStart = FAST_START_PEER_AVAIL;
		
		//we are keeping a reference to the fast start list so don't release it 
		pSetupASN->pFastStart = NULL;
		pSetupASN->fFastStartPresent = FALSE;
	}
	else
	{
		m_dwFastStart = FAST_START_NOTAVAIL;
	}
	
	//get the alias names
	if( pSetupASN->pCalleeAliasList )
	{
		_ASSERTE( m_pCalleeAliasNames );
		delete m_pCalleeAliasNames;

		m_pCalleeAliasNames = pSetupASN->pCalleeAliasList;
		pSetupASN->pCalleeAliasList = NULL;
	}
	else
	{
		if( RasIsRegistered() )
		{
			PH323_ALIASNAMES pAliasList = RASGetRegisteredAliasList();

			AddAliasItem( m_pCalleeAliasNames,
				pAliasList->pItems[0].pData,
				pAliasList->pItems[0].wType );
		}
		else
		{
			wszMachineName = g_pH323Line->GetMachineName();
		
			//set the value for m_pCalleeAliasNames
			AddAliasItem( m_pCalleeAliasNames,
				(BYTE*)(wszMachineName),
				sizeof(WCHAR) * (wcslen(wszMachineName) + 1 ),
				h323_ID_chosen );
		}
	}

	_ASSERTE( m_pCallerAliasNames );
	delete m_pCallerAliasNames;
	m_pCallerAliasNames = NULL;

	if( pSetupASN->pCallerAliasList )
	{
		m_pCallerAliasNames = pSetupASN->pCallerAliasList;
		pSetupASN->pCallerAliasList = NULL;

		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	}

	if( pSetupASN->pExtraAliasList )
	{
		m_pPeerExtraAliasNames = pSetupASN->pExtraAliasList;
		pSetupASN->pExtraAliasList = NULL;
	}
	
	//non -standard info
	if( pSetupASN->fNonStandardDataPresent )
	{
		// add user user info
		if( AddU2UNoAlloc( U2U_INBOUND, 	
				pSetupASN->nonStandardData.sData.wOctetStringLength,
				pSetupASN->nonStandardData.sData.pOctetString ) == TRUE )
		{
			H323DBG(( DEBUG_LEVEL_VERBOSE,
				"user user info available in Setup PDU." ));
			
			//don't release the data buffer
			pSetupASN->fNonStandardDataPresent = FALSE;
		}
		else 
		{
			H323DBG(( DEBUG_LEVEL_WARNING,
				"could not save incoming user user info." ));
			goto cleanup;
		}
	}

	if( pSetupASN->fSourceAddrPresent )
	{
		m_CallerAddr = pSetupASN->sourceAddr;
	}

	m_dwCallType = dwCallType;
	if( wCallRef )
	{
		m_wQ931CallRef = (wCallRef | 0x8000);
	}

	//clear incoming modes
	m_dwIncomingModes = 0;

	//outgoing modes will be finalized during H.245 phase
	m_dwOutgoingModes = g_pH323Line->GetMediaModes() | LINEMEDIAMODE_UNKNOWN;

	//save media modes specified
	m_dwRequestedModes = g_pH323Line->GetMediaModes();

	H323DBG(( DEBUG_LEVEL_TRACE, "InitializeIncomingCall exited:%p.", this ));
	return TRUE;

cleanup:
	return FALSE;
}


//!!always called in a lock
BOOL
CH323Call::ChangeCallState(
							IN DWORD	dwCallState,
							IN DWORD	dwCallStateMode
						  )
		
/*++

Routine Description:

	Reports call state of specified call object.

Arguments:

	dwCallState - Specifies new state of call object.
	
	dwCallStateMode - Specifies new state mode of call object.

Return Values:

	Returns true if successful.
	
--*/

{	
	H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx %s. state mode: 0x%08lx.",
		this, H323CallStateToString(dwCallState), dwCallStateMode ));	 
	
	// save new call state
	m_dwCallState = dwCallState;
	m_dwCallStateMode = dwCallStateMode;
	
	if( 
		((m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall ) ||
		((m_dwCallType & CALLTYPE_TRANSFEREDSRC ) && m_hdRelatedCall ) ||
		(m_dwCallType & CALLTYPE_FORWARDCONSULT )
	  )
	{
		return TRUE;
	}

	// report call status
	PostLineEvent (
		LINE_CALLSTATE,
		m_dwCallState,
		m_dwCallStateMode,
		m_dwIncomingModes | m_dwOutgoingModes);

	// success
	return TRUE;
}


//always called in a lock
void
CH323Call::CopyU2UAsNonStandard( 
								IN DWORD dwDirection
							   )
{
	PUserToUserLE pU2ULE = NULL;
		
	H323DBG(( DEBUG_LEVEL_TRACE, "CopyU2UAsNonStandard entered:%p.", this ));
	
	if( RemoveU2U( dwDirection, &pU2ULE ) )
	{
		// transfer header information
		m_NonStandardData.bCountryCode		= H221_COUNTRY_CODE_USA;
		m_NonStandardData.bExtension		= H221_COUNTRY_EXT_USA;
		m_NonStandardData.wManufacturerCode = H221_MFG_CODE_MICROSOFT;

		// initialize octet string containing data
		m_NonStandardData.sData.wOctetStringLength = LOWORD(pU2ULE->dwU2USize);

		if( m_NonStandardData.sData.pOctetString )
		{
			delete m_NonStandardData.sData.pOctetString;
			m_NonStandardData.sData.pOctetString = NULL;
		}

		m_NonStandardData.sData.pOctetString = pU2ULE->pU2U;
	}
	else
	{
		//reset non standard data
		memset( (PVOID)&m_NonStandardData,0,sizeof(H323NonStandardData ));
	}
		
	H323DBG(( DEBUG_LEVEL_TRACE, "CopyU2UAsNonStandard exited:%p.", this ));
}


void
CH323Call::AcceptCall(void)
		
/*++

Routine Description:

	Accepts incoming call.
	!!always called in lock

Arguments:

Return Values:

	Returns true if successful.
	
--*/

{
	PH323_CALL		pCall = NULL;

	H323DBG(( DEBUG_LEVEL_TRACE, "AcceptCall entered:%p.", this ));
	
	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return;
	}

	// see if user user information specified
	CopyU2UAsNonStandard( U2U_OUTBOUND );

	if( m_pwszDisplay == NULL )
	{
		// see if callee alias specified
		if( m_pCalleeAliasNames && m_pCalleeAliasNames -> wCount )
		{
			 if((m_pCalleeAliasNames->pItems[0].wType == h323_ID_chosen) ||
				(m_pCalleeAliasNames ->pItems[0].wType == e164_chosen) )
			 {
				// send callee name as display
				m_pwszDisplay = m_pCalleeAliasNames -> pItems[0].pData;
			 }
		}
	}

	//send answer call message to the MSP instance

	if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
	{
		MSPMessageData* pMSPMessageData = new MSPMessageData;
		if( pMSPMessageData == NULL )
		{
			CloseCall( 0 );
			return;
		}

		pMSPMessageData->hdCall = m_hdRelatedCall;
		pMSPMessageData->messageType = SP_MSG_AnswerCall;
		pMSPMessageData->pbEncodedBuf = NULL;
		pMSPMessageData->wLength = 0;
		pMSPMessageData->hReplacementCall = m_hdCall;

		if( !QueueUserWorkItem( SendMSPMessageOnRelatedCall, pMSPMessageData, 
			WT_EXECUTEDEFAULT ) )
		{
			delete pMSPMessageData;
			CloseCall( 0 );
			return;
		}
	}
	else
	{
		SendMSPMessage( SP_MSG_AnswerCall, 0, 0, NULL );
	}

	m_fCallAccepted = TRUE;

	if( m_fReadyToAnswer )
	{
		// validate status
		if( !AcceptH323Call() )
		{
			H323DBG(( DEBUG_LEVEL_ERROR, "error answering call 0x%08lx.", 
				this ));

			// drop call using disconnect mode
			DropCall( LINEDISCONNECTMODE_TEMPFAILURE );

			// failure
			return;
		}

		if( !(m_dwFlags & H245_START_MSG_SENT) )
		{
			//start H245
			SendMSPStartH245( NULL, NULL );
		}

		//tell MSP about connect state
		SendMSPMessage( SP_MSG_ConnectComplete, 0, 0, NULL );

		//change call state to accepted from offering
		ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE, "AcceptCall exited:%p.", this ));
	// success
	return;
}


//always called in lock
void
CH323Call::ReleaseU2U(void)
{
	PUserToUserLE pU2ULE = NULL;
	PLIST_ENTRY pLE;
	
	H323DBG(( DEBUG_LEVEL_TRACE, "ReleaseU2U entered:%p.", this ));

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return;
	}

	// see if list is empty
	if( IsListEmpty( &m_IncomingU2U ) == FALSE )
	{
		// remove first entry from list
		pLE = RemoveHeadList( &m_IncomingU2U );

		// convert to user user structure
		pU2ULE = CONTAINING_RECORD(pLE, UserToUserLE, Link);

		// release memory
		if(pU2ULE)
		{
			delete pU2ULE;
			pU2ULE = NULL;
		}
	}

	// see if list contains pending data
	if( IsListEmpty( &m_IncomingU2U ) == FALSE )
	{
		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"more user user info available." ));

		// signal incoming
		PostLineEvent (
			LINE_CALLINFO,
			LINECALLINFOSTATE_USERUSERINFO, 0, 0);
	}
		
	H323DBG(( DEBUG_LEVEL_TRACE, "ReleaseU2U exited:%p.", this ));
}


//always called in lock
void
CH323Call::SendU2U(
	IN BYTE*  pUserUserInfo,
	IN DWORD  dwSize
	)
{
	H323DBG(( DEBUG_LEVEL_TRACE, "SendU2U entered:%p.", this ));

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return;
	}

	// check for user user info
	if( pUserUserInfo != NULL )
	{
		// transfer header information
		m_NonStandardData.bCountryCode		= H221_COUNTRY_CODE_USA;
		m_NonStandardData.bExtension		= H221_COUNTRY_EXT_USA;
		m_NonStandardData.wManufacturerCode = H221_MFG_CODE_MICROSOFT;

		// initialize octet string containing data
		m_NonStandardData.sData.wOctetStringLength = (WORD)dwSize;

		if( m_NonStandardData.sData.pOctetString != NULL )
		{
			delete m_NonStandardData.sData.pOctetString;
			m_NonStandardData.sData.pOctetString = NULL;
		}

		m_NonStandardData.sData.pOctetString = pUserUserInfo;
	}

	// send user user data
	if( !SendQ931Message( 0, 0, 0, FACILITYMESSAGETYPE, NO_H450_APDU ) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error sending non-standard message."));
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE, "SendU2U exited:%p.", this ));
	return;
}


BOOL
CH323Call::InitializeQ931(
							IN SOCKET callSocket
						 )
{
	BOOL	fSuccess;

	H323DBG((DEBUG_LEVEL_ERROR, "q931 call initialize entered:%p.", this ));

	if( !BindIoCompletionCallback(
		(HANDLE)callSocket,
		CH323Call::IoCompletionCallback, 
		0) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, 
			"couldn't bind i/o completion callabck:%d:%p.", 
			GetLastError(), this ));

		return FALSE;
	}

	//initilize the member variables
	m_callSocket = callSocket;
		
	H323DBG((DEBUG_LEVEL_ERROR, "q931 call initialize exited:%lx, %p.", 
		m_callSocket, this ));
	return TRUE;
}

//no need to lock
BOOL
CH323Call::GetPeerAddress(
	IN H323_ADDR *pAddr
	)
{
	SOCKADDR_IN sockaddr;
	int len = sizeof(sockaddr);

	H323DBG((DEBUG_LEVEL_ERROR, "GetPeerAddress entered:%p.", this ));
	
	if( getpeername( m_callSocket, (SOCKADDR*)&sockaddr, &len) 
		== SOCKET_ERROR )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error 0x%08lx calling getpeername.", WSAGetLastError() ));

		return FALSE;
	}

	pAddr->nAddrType = H323_IP_BINARY;
	pAddr->bMulticast = FALSE;
	pAddr->Addr.IP_Binary.wPort = ntohs(sockaddr.sin_port);
	pAddr->Addr.IP_Binary.dwAddr = ntohl(sockaddr.sin_addr.S_un.S_addr);

	H323DBG(( DEBUG_LEVEL_ERROR, "GetPeerAddress exited:%p.", this ));
	return TRUE;
}


//no need to lock
BOOL CH323Call::GetHostAddress( 
	IN H323_ADDR *pAddr
	)
{
	int len = sizeof(m_LocalAddr);
	
	H323DBG((DEBUG_LEVEL_ERROR, "GetHostAddress entered:%p.", this ));
	
	if( getsockname( m_callSocket, (SOCKADDR *)&m_LocalAddr, &len) == 
			SOCKET_ERROR)
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error 0x%08lx calling getockname.", WSAGetLastError() ));
		
		return FALSE;
	}

	pAddr->nAddrType = H323_IP_BINARY;
	pAddr->bMulticast = FALSE;
	pAddr->Addr.IP_Binary.wPort = ntohs(m_LocalAddr.sin_port);
	pAddr->Addr.IP_Binary.dwAddr = ntohl(m_LocalAddr.sin_addr.S_un.S_addr);

	H323DBG((DEBUG_LEVEL_ERROR, "GetHostAddress exited:%p.", this ));
	return TRUE;
}

//!!always called in a lock
BOOL 
CH323Call::OnReceiveFacility(
							IN Q931MESSAGE* pMessage
							)
{
	Q931_FACILITY_ASN	facilityASN;
	
	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveFacility entered: %p.", this ));

	//decode the U2U information
	if( !pMessage ->UserToUser.fPresent ||
		pMessage ->UserToUser.wUserInfoLen == 0 )
	{
		//Ignore this message. Don't shutdown the call.
		return FALSE;
	}

	if( !ParseFacilityASN( pMessage->UserToUser.pbUserInfo,
			pMessage->UserToUser.wUserInfoLen, &facilityASN ))
	{
		//memory failure : shutdown the H323 call
		CloseCall( 0 );

		return FALSE;
	}

	if( (facilityASN.pH245PDU.length != 0) && facilityASN.pH245PDU.value )
	{
		SendMSPMessage( SP_MSG_H245PDU, facilityASN.pH245PDU.value, 
			facilityASN.pH245PDU.length, NULL );
		delete facilityASN.pH245PDU.value;
	}

	HandleFacilityMessage( facilityASN.dwInvokeID, &facilityASN );

	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveFacility exited: %p.", this ));
	return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::OnReceiveProceeding(
								IN Q931MESSAGE* pMessage
							  )
{
	Q931_CALL_PROCEEDING_ASN proceedingASN;
	DWORD dwAPDUType = 0;
			
	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveProceeding entered: %p.", this ));
	
	//decode the U2U information
	if( (pMessage ->UserToUser.fPresent == FALSE) || 
		(pMessage ->UserToUser.wUserInfoLen == 0) )
	{
		//ignore this message. don't shutdown the call.
		return FALSE;
	}

	if( (m_dwOrigin!=LINECALLORIGIN_OUTBOUND) ||
		( (m_dwStateMachine != Q931_SETUP_SENT) &&
		  (m_dwStateMachine != Q931_PROCEED_RECVD) )
	  )
	{
		//ignore this message. don't shutdown the Q931 call.
		return FALSE;
	}

	if( !ParseProceedingASN(
			pMessage->UserToUser.pbUserInfo,
			pMessage->UserToUser.wUserInfoLen,
			&proceedingASN,
			&dwAPDUType ))
	{
		//Ignore the wrong proceeding message.
		H323DBG(( DEBUG_LEVEL_ERROR, "wrong proceeding PDU:%p.", this ));
		H323DUMPBUFFER( pMessage->UserToUser.pbUserInfo, 
			(DWORD)pMessage->UserToUser.wUserInfoLen );

		return TRUE;
	}

	if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
		(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
	{
		//success of forwarding
		EnableCallForwarding();

		CloseCall( 0 );
		return TRUE;
	}

	HandleProceedingMessage( &proceedingASN );

	//reset the timeout for setup sent
	if( m_hSetupSentTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
		m_hSetupSentTimer = NULL;
	}

	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveProceeding exited: %p.", this ));
	m_dwStateMachine = Q931_PROCEED_RECVD;
	return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::OnReceiveAlerting(
							IN Q931MESSAGE* pMessage
							)
{
	Q931_ALERTING_ASN alertingASN;
	DWORD dwAPDUType = 0;

	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveAlerting entered: %p.", this ));
	
	//decode the U2U information
	if( (pMessage ->UserToUser.fPresent == FALSE) || 
		(pMessage ->UserToUser.wUserInfoLen == 0) )
	{
		//ignore this message. don't shutdown the call.
		return FALSE;
	}

	if(  (m_dwOrigin!=LINECALLORIGIN_OUTBOUND) ||
		!( (m_dwStateMachine==Q931_SETUP_SENT) || 
		   (m_dwStateMachine==Q931_PROCEED_RECVD)
		 ) 
	  )
	{
		//ignore this message. don't shutdown the Q931 call.
		return FALSE;
	}

	if( !ParseAlertingASN( pMessage->UserToUser.pbUserInfo,
							  pMessage->UserToUser.wUserInfoLen,
							  &alertingASN,
							  &dwAPDUType ))
	{
		//memory failure : shutdown the H323 call
		CloseCall( 0 );

		return FALSE;
	}

	if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
		(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
	{
		//success of forwarding
		EnableCallForwarding();

		CloseCall( 0 );
		return FALSE;
	}

	//reset the timeout for setup sent
	if( m_hSetupSentTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
		m_hSetupSentTimer = NULL;
	}

	if( !CreateTimerQueueTimer(
			&m_hCallEstablishmentTimer,
			H323TimerQueue,
			CH323Call::CallEstablishmentExpiredCallback,
			(PVOID)m_hdCall,
			g_RegistrySettings.dwQ931AlertingTimeout, 0,
			WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ))
	{
		CloseCall( 0 );
		return FALSE;
	}
			
	HandleAlertingMessage( &alertingASN );
	m_dwStateMachine = Q931_ALERT_RECVD;
		
	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveAlerting exited: %p.", this ));
	return TRUE;
}


//!!always called in lock
void
CH323Call::SetupSentTimerExpired(void)
{
	DWORD dwState;

	H323DBG((DEBUG_LEVEL_TRACE, "SetupSentTimerExpired entered."));
	
	dwState = m_dwStateMachine;
	
	if( m_hSetupSentTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
		m_hSetupSentTimer = NULL;
	}

	if( (dwState!= Q931_CONNECT_RECVD) &&
		(dwState != Q931_ALERT_RECVD) &&
		(dwState != Q931_PROCEED_RECVD) &&
		(dwState != Q931_RELEASE_RECVD)
	  )
	{
		//time out has occured
		CloseCall( 0 );
	}
		
	H323DBG((DEBUG_LEVEL_TRACE, "SetupSentTimerExpired exited." ));
}


//!!always called in a lock
BOOL
CH323Call::OnReceiveRelease(
	IN Q931MESSAGE* pMessage
	)
{
	DWORD dwAPDUType = 0;
	Q931_RELEASE_COMPLETE_ASN releaseASN;
		
	//decode the U2U information
	if( (pMessage ->UserToUser.fPresent == FALSE) || 
		(pMessage ->UserToUser.wUserInfoLen == 0) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "ReleaseComplete PDU did not contain "
				  "user-to-user information, ignoring message." ));

		//ignore this message. don't shutdown the call.
		return FALSE;
	}

	if( !ParseReleaseCompleteASN( 
			pMessage->UserToUser.pbUserInfo,
			pMessage->UserToUser.wUserInfoLen,
			&releaseASN,
			&dwAPDUType ))
	{
		H323DBG(( DEBUG_LEVEL_ERROR, 
            "ReleaseComplete PDU could not be parsed, terminating call." ));

		//memory failure : shutdown the H323 call
		CloseCall( 0 );

		return FALSE;
	}

	H323DBG ((DEBUG_LEVEL_INFO, "Received ReleaseComplete PDU."));

	HandleReleaseMessage( &releaseASN );
	m_dwStateMachine = Q931_RELEASE_RECVD;
	
	return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::OnReceiveConnect( 
	IN Q931MESSAGE* pMessage
	)
{
	Q931_CONNECT_ASN connectASN;
	DWORD dwH450APDUType = 0;

	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveConnect entered: %p.", this ));

	//decode the U2U information
	if( (pMessage ->UserToUser.fPresent == FALSE) || 
		(pMessage ->UserToUser.wUserInfoLen == 0) )
	{
		//ignore this message. don't shutdown the call.
		return FALSE;
	}

	if( m_dwOrigin!=LINECALLORIGIN_OUTBOUND )
	{
		//ignore this message. don't shutdown the Q931 call.
		return FALSE;
	}

	if( (m_dwStateMachine != Q931_SETUP_SENT) &&
		(m_dwStateMachine != Q931_ALERT_RECVD) &&
		(m_dwStateMachine != Q931_PROCEED_RECVD)
	  )
	{
		//ignore this message. don't shutdown the Q931 call.
		return FALSE;
	}

	if( ParseConnectASN( pMessage->UserToUser.pbUserInfo,
				   pMessage->UserToUser.wUserInfoLen,
				   &connectASN,
				   &dwH450APDUType) == FALSE )
	{
		//memory failure : shutdown the H323 call
		CloseCall( 0 );
		return FALSE;
	}

	if( m_dwCallType & CALLTYPE_FORWARDCONSULT )
	{
		FreeConnectASN( &connectASN );

		if( dwH450APDUType == H4503_DUMMYTYPERETURNRESULT_APDU)
		{
			//assuming this return result is for check restriction operation
			return TRUE;
		}
		else
		{
			//success of forwarding
			EnableCallForwarding();

			CloseCall( 0 );
			return FALSE;
		}
	}

    if( !HandleConnectMessage( &connectASN ) )
    {
        return FALSE;
    }
    
    //reset the timeout for setup sent
    if( m_hSetupSentTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
        m_hSetupSentTimer = NULL;
    }

    if( m_hCallEstablishmentTimer )
    {
        DeleteTimerQueueTimer(H323TimerQueue, m_hCallEstablishmentTimer, NULL);
        m_hCallEstablishmentTimer = NULL;
    }

    m_dwStateMachine = Q931_CONNECT_RECVD;
        
    H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveConnect exited: %p.", this ));
    return TRUE;
}

//!!always called in a lock
BOOL 
CH323Call::OnReceiveSetup( 
                           IN Q931MESSAGE* pMessage
                         )
{
    Q931_SETUP_ASN      setupASN;
    DWORD               dwH450APDUType = 0;
    PH323_CALL          pCall = NULL;
    WCHAR               pwszCallingPartyNr[H323_MAXPATHNAMELEN];
    WCHAR               pwszCalledPartyNr[H323_MAXPATHNAMELEN];
    BYTE*               pstrTemp;

    //decode the U2U information
    if( (pMessage ->UserToUser.fPresent == FALSE) || 
        (pMessage ->UserToUser.wUserInfoLen == 0) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Setup message did not contain H.323 UUIE, ignoring."));

        //ignore this message. don't shutdown the call.
        return FALSE;
    }

    if( m_dwOrigin != LINECALLORIGIN_INBOUND )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Received Setup message on outbound call, ignoring."));

        //ignore this message. don't shutdown the call.
        return FALSE;
    }

    if( m_dwStateMachine != Q931_CALL_STATE_NONE )
    {
        H323DBG( (DEBUG_LEVEL_ERROR, 
            "Received Setup message on a call that is already in progress." ));

        //This Q931 call has already received a setup!!!!
        CloseCall( 0 );
        
        return FALSE;
    }

    if( !ParseSetupASN( pMessage->UserToUser.pbUserInfo,
                        pMessage->UserToUser.wUserInfoLen, 
                        &setupASN,
                        &dwH450APDUType ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Failed to parse Setup UUIE, closing call." ));

        //shutdown the Q931 call
        CloseCall( 0 );
        return FALSE;
    }

    if( dwH450APDUType )
    {
        if( m_dwCallType & CALLTYPE_FORWARDCONSULT )
        {
            return TRUE;
        }
    }

    if( (pMessage->CallingPartyNumber.fPresent == TRUE) && 
        (pMessage->CallingPartyNumber.dwLength > 1) &&
        (setupASN.pCallerAliasList == NULL ) )
    {
        // Always skip 1st byte in the contents.
        // Skip the 2nd byte if its not an e.164 char (could be the screening indicator byte)

        pstrTemp = pMessage->CallingPartyNumber.pbContents + 
                ((pMessage->CallingPartyNumber.pbContents[1] & 0x80)? 2 : 1);

        MultiByteToWideChar( CP_ACP, 
            0,
            (const char *)(pstrTemp),
            -1,
            pwszCallingPartyNr,
            sizeof(pwszCallingPartyNr)/sizeof(WCHAR));
         
        setupASN.pCallerAliasList = new H323_ALIASNAMES;
        
        if( setupASN.pCallerAliasList != NULL )
        {
            ZeroMemory( setupASN.pCallerAliasList, sizeof(H323_ALIASNAMES) );
            
            AddAliasItem( setupASN.pCallerAliasList,
                pwszCallingPartyNr,
                e164_chosen );
        }
    }

    if( (pMessage->CalledPartyNumber.fPresent == TRUE) && 
        (pMessage->CalledPartyNumber.PartyNumberLength > 0) &&
        (setupASN.pCalleeAliasList == NULL ) )
    {
        // Always skip 1st byte in the contents.
        // Skip the 2nd byte if its not an e.164 char (could be the screening indicator byte)

        MultiByteToWideChar(CP_ACP, 
            0, 
            (const char *)(pMessage->CalledPartyNumber.PartyNumbers), 
            -1,
            pwszCalledPartyNr,
            sizeof(pwszCalledPartyNr) / sizeof(WCHAR) );
                 
        setupASN.pCalleeAliasList = new H323_ALIASNAMES;
        
        if( setupASN.pCalleeAliasList != NULL )
        {
            ZeroMemory( setupASN.pCalleeAliasList, sizeof(H323_ALIASNAMES) );
            
            AddAliasItem( setupASN.pCalleeAliasList,
                pwszCalledPartyNr,
                e164_chosen );
        }
    }
        
    //don't change the call type here
    if( !InitializeIncomingCall( &setupASN, m_dwCallType, pMessage->wCallRef ) )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "Failed to initialize incoming call, closing call."));

        //shutdown the Q931 call
        FreeSetupASN( &setupASN );        
        CloseCall( 0 );
        return FALSE;
    }
    
    FreeSetupASN( &setupASN );
    m_dwStateMachine = Q931_SETUP_RECVD;

    if( !HandleSetupMessage( pMessage ) )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "Failed to process Setup message, closing call."));

        CloseCall( 0 );
        return FALSE;
    }

    return TRUE;
}


//!!always called in a lock
void
CH323Call::CloseCall( 
    IN DWORD dwDisconnectMode )
{
    H323DBG((DEBUG_LEVEL_INFO, "[%08XH] Terminating call.", this ));

    if (!QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            m_hdCall, 
            NULL,
            dwDisconnectMode,
            m_wCallReference ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post H323 close event." ));
    }
}


//!!always called in a lock
void
CH323Call::ReadEvent(
    IN DWORD cbTransfer
    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "ReadEvent entered: %p.", this ));
    H323DBG((DEBUG_LEVEL_TRACE, "bytes received: %d.", cbTransfer));

    m_RecvBuf.dwBytesCopied += cbTransfer;

    //update the recv buffer
    if( m_bStartOfPDU )
    {
        if( m_RecvBuf.dwBytesCopied < sizeof(TPKT_HEADER_SIZE) )
        {
            //set the buffer to get the remainig TPKT_HEADER
            m_RecvBuf.WSABuf.buf = 
                m_RecvBuf.arBuf + m_RecvBuf.dwBytesCopied;

            m_RecvBuf.WSABuf.len =
                TPKT_HEADER_SIZE - m_RecvBuf.dwBytesCopied;
        }
        else
        {
            m_RecvBuf.dwPDULen = GetTpktLength( m_RecvBuf.arBuf );

            if( (m_RecvBuf.dwPDULen < TPKT_HEADER_SIZE) ||
                (m_RecvBuf.dwPDULen  > Q931_RECV_BUFFER_LENGTH) )
            {
                //messed up peer. close the call.
                H323DBG(( DEBUG_LEVEL_ERROR, "error:PDULen:%d.", 
                    m_RecvBuf.dwPDULen ));

                //close the call
                CloseCall( 0 );
                return;
            }
            else if( m_RecvBuf.dwPDULen == TPKT_HEADER_SIZE )
            {
                InitializeRecvBuf();
            }
            else
            {
                //set the buffer to get the remaining PDU
                m_bStartOfPDU = FALSE;
                m_RecvBuf.WSABuf.buf = m_RecvBuf.arBuf + 
                    m_RecvBuf.dwBytesCopied;
                m_RecvBuf.WSABuf.len = m_RecvBuf.dwPDULen - 
                    m_RecvBuf.dwBytesCopied;
            }
        }
    }
    else
    {
        _ASSERTE( m_RecvBuf.dwBytesCopied <= m_RecvBuf.dwPDULen );

        if( m_RecvBuf.dwBytesCopied == m_RecvBuf.dwPDULen )
        {
            //we got the whole PDU
            if( !ProcessQ931PDU( &m_RecvBuf ) )
            {
                H323DBG(( DEBUG_LEVEL_ERROR, 
                    "error in processing PDU:%p.", this ));

                H323DUMPBUFFER( (BYTE*)m_RecvBuf.arBuf, m_RecvBuf.dwPDULen );
            }

            //if the call has been already shutdown due to
            //a fatal error while processing the PDU or because of receiveing
            //release complete message then dont post any more read buffers
            if( (m_dwFlags & CALLOBJECT_SHUTDOWN) || 
                (m_dwQ931Flags & Q931_CALL_DISCONNECTED) )
            {
                return;
            }

            InitializeRecvBuf();
        }
        else
        {
            //set the buffer to get the remainig PDU
            m_RecvBuf.WSABuf. buf = 
                m_RecvBuf.arBuf + m_RecvBuf.dwBytesCopied;
            m_RecvBuf.WSABuf. len = 
                m_RecvBuf.dwPDULen - m_RecvBuf.dwBytesCopied;
        }
    }

    //post a read for the remaining PDU
    if(!PostReadBuffer())
    {
        //post a message to the callback thread to shutdown the H323 call
        CloseCall( 0 );
    }
    
    H323DBG((DEBUG_LEVEL_TRACE, "ReadEvent exited: %p.", this ));
}


/*
	Parse a generic Q931 message and place the fields of the buffer
	into the appropriate structure fields.

	Parameters:
		pBuf  Pointer to buffer descriptor of an
                       input packet containing the 931 message.
		pMessage           Pointer to space for parsed output information.
*/

//!!always called in a lock
HRESULT
CH323Call::Q931ParseMessage(
    IN BYTE *          pbCodedBuffer,
    IN DWORD           dwCodedBufferLength,
    OUT PQ931MESSAGE    pMessage
    )
{
    HRESULT hr;
    BUFFERDESCR pBuf;

    pBuf.dwLength = dwCodedBufferLength;
    pBuf.pbBuffer = pbCodedBuffer;
    
    H323DBG((DEBUG_LEVEL_TRACE, "Q931ParseMessage entered: %p.", this ));
    
    memset( (PVOID)pMessage, 0, sizeof(Q931MESSAGE));

    hr = ParseProtocolDiscriminator(&pBuf, &pMessage->ProtocolDiscriminator);

    if( hr != S_OK )
    {
        return hr;
    }

    hr = ParseCallReference( &pBuf, &pMessage->wCallRef);
    if( hr != S_OK )
    {
        return hr;
    }

    hr = ParseMessageType( &pBuf, &pMessage->MessageType );
    if( hr != S_OK )
    {
        return hr;
    }

    while (pBuf.dwLength)
    {
        hr = ParseQ931Field(&pBuf, pMessage);
        if (hr != S_OK)
        {
            return hr;
        }
    }
    
    H323DBG((DEBUG_LEVEL_TRACE, "Q931ParseMessage exited: %p.", this ));
    return S_OK;
}


//decode the PDU and release the buffer
//!!always called in a lock
BOOL 
CH323Call::ProcessQ931PDU( 
    IN CALL_RECV_CONTEXT* pRecvBuf
    )
{
    PQ931MESSAGE    pMessage;
    BOOL            retVal;
    HRESULT         hr;
        
    H323DBG((DEBUG_LEVEL_TRACE, "ProcessQ931PDU entered: %p.", this ));
    
    pMessage = new Q931MESSAGE;
    if( pMessage  == NULL )
    {
        return FALSE;
    }

    hr = Q931ParseMessage( (BYTE*)(pRecvBuf->arBuf + sizeof(TPKT_HEADER_SIZE)),
                           pRecvBuf->dwPDULen - 4, 
                           pMessage );

    if( !SUCCEEDED( hr) )
    {
        delete pMessage;
        return FALSE;
    }

    if( (m_dwCallType & CALLTYPE_TRANSFERED_PRIMARY )      &&
        (m_dwCallDiversionState == H4502_CTINITIATE_RECV)   &&
        (pMessage->MessageType != RELEASECOMPLMESSAGETYPE) )
    {
        // If this endpoint has already been transferred then
        // ignore any further messages on the primary call.
        delete pMessage;
        return FALSE;
    }

    switch( pMessage->MessageType )
    {
    case ALERTINGMESSAGETYPE:
        
        retVal = OnReceiveAlerting( pMessage );
        break;

    case PROCEEDINGMESSAGETYPE:
        
        retVal = OnReceiveProceeding( pMessage );
        break;

    case CONNECTMESSAGETYPE:

        retVal = OnReceiveConnect( pMessage );
        break;

    case RELEASECOMPLMESSAGETYPE:
        
        retVal = OnReceiveRelease( pMessage );
        break;

    case SETUPMESSAGETYPE:

        retVal = OnReceiveSetup( pMessage );
        break;

    case FACILITYMESSAGETYPE:

        retVal = OnReceiveFacility( pMessage );
        break;

    default:

        H323DBG(( DEBUG_LEVEL_TRACE, "unrecognised PDU recvd:%d,%p.",
            pMessage->MessageType, this ));
        retVal = FALSE;
    }

    delete pMessage;

    H323DBG((DEBUG_LEVEL_TRACE, "ProcessQ931PDU exited: %p.", this ));
    return retVal;
}



//!!always called in a lock
void 
CH323Call::OnConnectComplete(void)
{
    BOOL        fSuccess = TRUE;
    PH323_CALL  pCall = NULL;
    
    H323DBG((DEBUG_LEVEL_TRACE, "OnConnectComplete entered: %p.", this ));
    
    _ASSERTE( m_dwOrigin==LINECALLORIGIN_OUTBOUND );

    if( !GetHostAddress( &m_CallerAddr) )
    {
        //memory failure : shutdown the H323 call
        CloseCall( 0 );
        return;
    }

    InitializeRecvBuf();

    //post a buffer to winsock to accept messages from the peer
    if( !PostReadBuffer() )
    {
        //memory failure : shutdown the H323 call
        CloseCall( 0 );
        return;
    }

    //set the state to connected
    SetQ931CallState( Q931_CALL_CONNECTED );

    if( (m_dwCallType == CALLTYPE_NORMAL) || 
        (m_dwCallType & CALLTYPE_TRANSFERING_CONSULT) )
    {
        SendMSPMessage( SP_MSG_InitiateCall, 0, 0, NULL );
    }
    else if( m_dwCallType & CALLTYPE_TRANSFEREDSRC )
    {
        _ASSERTE( m_hdRelatedCall );
        MSPMessageData* pMSPMessageData = new MSPMessageData;
        if( pMSPMessageData == NULL )
        {
            CloseCall( 0 );
            return;
        }

        pMSPMessageData->hdCall = m_hdRelatedCall;
        pMSPMessageData->messageType = SP_MSG_InitiateCall;
        pMSPMessageData->pbEncodedBuf = NULL;
        pMSPMessageData->wLength = 0;
        pMSPMessageData->hReplacementCall = m_hdCall;

        if( !QueueUserWorkItem( SendMSPMessageOnRelatedCall, pMSPMessageData,
            WT_EXECUTEDEFAULT ) )
        {
            delete pMSPMessageData;
            CloseCall( 0 );
            return;
        }
    }
    else
    {
        //send the setup message
        if( !SendSetupMessage() )
        {
            DropCall( 0 );
        }
    }
    
    H323DBG((DEBUG_LEVEL_TRACE, "OnConnectComplete exited: %p.", this ));
}


//!!aleways called in a lock
BOOL
CH323Call::SendSetupMessage(void)
{
    BOOL retVal = TRUE;
    DWORD dwAPDUType = NO_H450_APDU;

    H323DBG((DEBUG_LEVEL_TRACE, "SendSetupMessage entered: %p.", this ));

    //encode ASN.1 and send Q931Setup message to the peer
    if( m_dwCallType & CALLTYPE_FORWARDCONSULT )
    {
        //send the callRerouitng.invoke APDU  if this is a forwardconsult call
        retVal = SendQ931Message( NO_INVOKEID,
                         (DWORD)create_chosen, 
                         (DWORD)pointToPoint_chosen,
                         SETUPMESSAGETYPE,
                         CHECKRESTRICTION_OPCODE| H450_INVOKE );

        if( retVal )
        {
            m_dwStateMachine = Q931_SETUP_SENT;
            m_dwCallDiversionState = H4503_CHECKRESTRICTION_SENT;

            retVal = CreateTimerQueueTimer(
                        &m_hCheckRestrictionTimer,
                        H323TimerQueue,
                        CH323Call::CheckRestrictionTimerCallback,
                        (PVOID)m_hdCall,
                        CHECKRESTRICTION_EXPIRE_TIME, 0,
                        WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE );
        }
    }
    else
    {
        if( ( m_dwCallType & CALLTYPE_DIVERTEDSRC ) ||
            ( m_dwCallType & CALLTYPE_DIVERTEDSRC_NOROUTING ) )
        {
            dwAPDUType = DIVERTINGLEGINFO2_OPCODE | H450_INVOKE;
        }
        else if( m_dwCallType & CALLTYPE_TRANSFEREDSRC )
        {
            dwAPDUType = CTSETUP_OPCODE | H450_INVOKE;
        }
        
        retVal = SendQ931Message( NO_INVOKEID,
                         (DWORD)create_chosen,
                         (DWORD)pointToPoint_chosen,
                         SETUPMESSAGETYPE,
                         dwAPDUType );
        
        if( retVal )
        {
            m_dwStateMachine = Q931_SETUP_SENT;
            
            retVal = CreateTimerQueueTimer(
                &m_hSetupSentTimer,
                H323TimerQueue,
                CH323Call::SetupSentTimerCallback,
                (PVOID)m_hdCall,
                SETUP_SENT_TIMEOUT, 0,
                WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE );
        }
    }
    
    if( retVal == FALSE )
    {
        CloseCall( 0 );
        return FALSE;
    }

    H323DBG((DEBUG_LEVEL_TRACE, "SendSetupMessage exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
BOOL
CH323Call::SendProceeding(void)
{
    H323DBG((DEBUG_LEVEL_TRACE, "SendProceeding entered: %p.", this ));
    
    _ASSERTE( m_dwOrigin == LINECALLORIGIN_INBOUND );

    //encode ASN.1 and send Q931Setup message to the peer
    if(!SendQ931Message( NO_INVOKEID, 0, 0, PROCEEDINGMESSAGETYPE, NO_H450_APDU ))
    {
        return FALSE;
    }

    m_dwStateMachine = Q931_PROCEED_SENT;
        
    H323DBG((DEBUG_LEVEL_TRACE, "SendProceeding exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::PostReadBuffer(void)
{
    int     iError;
    DWORD   dwByteReceived = 0;
    BOOL    fDelete = FALSE;

    H323DBG((DEBUG_LEVEL_TRACE, "PostReadBuffer entered: %p.", this ));
    
    m_RecvBuf.Type = OVERLAPPED_TYPE_RECV;
    m_RecvBuf.pCall = this;
    m_RecvBuf.dwFlags = 0;
    m_RecvBuf.BytesTransferred = 0;
    ZeroMemory( (PVOID)&m_RecvBuf.Overlapped, sizeof(OVERLAPPED) );

    //register with winsock for overlappped I/O
    if( WSARecv( m_callSocket,
             &(m_RecvBuf.WSABuf),
             1,
             &(m_RecvBuf.BytesTransferred),
             &(m_RecvBuf.dwFlags),
             &(m_RecvBuf.Overlapped),
             NULL ) == SOCKET_ERROR )
    {
        iError = WSAGetLastError();

        if( iError != WSA_IO_PENDING )
        {
            //take care of error conditions here
            H323DBG((DEBUG_LEVEL_ERROR, "error while recving buf: %d.",
                iError ));
            return FALSE;
        }
    }
    else
    {
        //There is some data to read!!!!!
        H323DBG(( DEBUG_LEVEL_TRACE, "bytes received immediately: %d.",
            m_RecvBuf.BytesTransferred ));
    }

    m_IoRefCount++;
    H323DBG((DEBUG_LEVEL_TRACE, 
        "PostReadBuffer:m_IoRefCount: %d:%p.", m_IoRefCount, this ));
    
    H323DBG((DEBUG_LEVEL_TRACE, "PostReadBuffer exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::SendBuffer( 
                     IN BYTE* pbBuffer,
                     IN DWORD dwLength
                     )
{
    int                 iError;
    CALL_SEND_CONTEXT*  pSendBuf = NULL;
    DWORD               cbTransfer;
    BOOL                fDelete = FALSE;

    H323DBG((DEBUG_LEVEL_TRACE, "SendBuffer entered: %p.", this ));
    
    if( !(m_dwQ931Flags & Q931_CALL_CONNECTED) )
    {
        goto cleanup;    
    }
    
    pSendBuf = new CALL_SEND_CONTEXT;
    if( pSendBuf == NULL )
    {
        goto cleanup;
    }
    
    ZeroMemory( (PVOID)pSendBuf, sizeof(CALL_SEND_CONTEXT) );
    pSendBuf->WSABuf.buf = (char*)pbBuffer;
    pSendBuf->WSABuf.len = dwLength;
    pSendBuf->BytesTransferred = 0;
    pSendBuf->pCall = this;
    pSendBuf->Type = OVERLAPPED_TYPE_SEND;
    
    InsertTailList( &m_sendBufList, &(pSendBuf ->ListEntry) );

    if( WSASend(m_callSocket,
                &(pSendBuf->WSABuf),
                1,
                &(pSendBuf->BytesTransferred),
                0,
                &(pSendBuf->Overlapped),
                NULL) == SOCKET_ERROR )
    {
        iError = WSAGetLastError();
        
        if( iError != WSA_IO_PENDING )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "error sending the buf: %lx.", iError));

            RemoveEntryList( &pSendBuf->ListEntry );
            goto cleanup;
        }
    }
    else
    {
        //data was sent immediately!!!
        H323DBG((DEBUG_LEVEL_TRACE, "data sent immediately!!." ));
    }

    m_IoRefCount++;
    H323DBG((DEBUG_LEVEL_TRACE, "SendBuffer:m_IoRefCount11: %d:%p.", 
        m_IoRefCount, this ));

    H323DBG((DEBUG_LEVEL_TRACE, "SendBuffer exited: %p.", this ));
    return TRUE;

cleanup:
    if(pSendBuf)
    {
        delete pSendBuf;
    }

    delete pbBuffer;
    return FALSE;
}


//!!aleways called in a lock
BOOL
CH323Call::SetupCall(void)
{
    SOCKET              Q931CallSocket = INVALID_SOCKET;
    SOCKADDR_IN         sin;
    HANDLE              hWSAEvent;
    HANDLE              hConnWait;
    BOOL                fSuccess = TRUE;
    int                 iError;
    BOOL                fDelete;
    DWORD               dwEnable = 1;
    TCHAR               ptstrEventName[100];

    H323DBG((DEBUG_LEVEL_TRACE, "SetupCall entered."));

    //create a socket
    Q931CallSocket = WSASocket(
                    AF_INET,
                    SOCK_STREAM,
                    IPPROTO_IP, 
                    NULL,
                    NULL,
                    WSA_FLAG_OVERLAPPED );
    
    if( Q931CallSocket == INVALID_SOCKET )
    {
        H323DBG((DEBUG_LEVEL_ERROR, "error while creating socket: %lx.",
            WSAGetLastError() ));
        goto error1;
    }

    //create a new Q931 call object
    if( InitializeQ931(Q931CallSocket) == NULL )
    {
        goto error2;
    }

    _stprintf( ptstrEventName, _T("%s-%p") , 
        _T( "H323TSP_OutgoingCall_TransportHandlerEvent" ), this );

    //create the wait event
    hWSAEvent = H323CreateEvent( NULL, FALSE, 
        FALSE, ptstrEventName );

    if( hWSAEvent == NULL )
    {
        H323DBG((DEBUG_LEVEL_ERROR, "couldn't create wsaevent" ));
        goto error3;
    }

    //register with thread pool the event handle and handler proc
    fSuccess = RegisterWaitForSingleObject(
        &hConnWait,             // pointer to the returned handle
        hWSAEvent,              // the event handle to wait for.
        Q931TransportEventHandler,      // the callback function.
        (PVOID)m_hdCall,        // the context for the callback.
        INFINITE,               // wait forever.
                                // probably don't need this flag set        
        WT_EXECUTEDEFAULT   // use the wait thread to call the callback.
        );

    if ( ( !fSuccess ) || (hConnWait== NULL) )
    {
        GetLastError();
        if( !CloseHandle( hWSAEvent ) )
        {
            H323DBG((DEBUG_LEVEL_ERROR, "couldn't close wsaevent" ));
        }

        goto error3;
    }
        
    //store this in the call context 
    SetNewCallInfo( hConnWait, hWSAEvent, Q931_CALL_CONNECTING );

    //register with Winsock the event handle and the events 
    if( WSAEventSelect( Q931CallSocket,
                        hWSAEvent,
                        FD_CONNECT | FD_CLOSE
                        ) == SOCKET_ERROR )
    {
        H323DBG((DEBUG_LEVEL_ERROR, 
            "error selecting event outgoing call: %lx.", WSAGetLastError()));
        goto error3;
    }

    if( setsockopt( Q931CallSocket,
        IPPROTO_TCP, 
        TCP_NODELAY, 
        (char*)&dwEnable, 
        sizeof(DWORD) 
        ) == SOCKET_ERROR )
    {
        H323DBG(( DEBUG_LEVEL_WARNING, 
            "Couldn't set NODELAY option on outgoing call socket:%d, %p",
            WSAGetLastError(), this ));
    }

    //set the address structure
    memset( (PVOID)&sin, 0, sizeof(SOCKADDR_IN) );
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl( m_CalleeAddr.Addr.IP_Binary.dwAddr );
    sin.sin_port = htons( m_CalleeAddr.Addr.IP_Binary.wPort );

    //make the winsock connection
    if( WSAConnect( Q931CallSocket,
                    (sockaddr*)&sin,
                    sizeof(SOCKADDR_IN),
                    NULL, NULL, NULL, NULL
                  )
                  == SOCKET_ERROR )
    {
        iError = WSAGetLastError();

        if(iError != WSAEWOULDBLOCK )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "error while connecting socket: %lx.", iError ));

            goto error3;
        }
    }
    else
    {   //connection went through immediately!!!
        OnConnectComplete();    
    }

    //success
    H323DBG((DEBUG_LEVEL_TRACE, "SetupCall exited."));
    return TRUE;

error3:
    Unlock();
    Shutdown( &fDelete );    
    Lock();
error2:
    closesocket( Q931CallSocket );
error1:
    return FALSE;
}


//!!aleways called in a lock
BOOL 
CH323Call::AcceptH323Call(void)
{
    DWORD dwAPDUType = NO_H450_APDU;
    DWORD dwInvokeID = NO_INVOKEID;

    H323DBG((DEBUG_LEVEL_TRACE, "AcceptH323Call entered: %p.", this ));
    
    if( m_dwCallType & CALLTYPE_DIVERTEDDEST )
    {
        dwAPDUType = (DIVERTINGLEGINFO3_OPCODE | H450_INVOKE);
    }
    else if( m_dwCallType & CALLTYPE_TRANSFEREDDEST )
    {
        dwAPDUType = (CTSETUP_OPCODE | H450_RETURNRESULT);
        dwInvokeID = m_dwInvokeID;
    }

    ChangeCallState( LINECALLSTATE_ACCEPTED, 0 );
    
    //if pCall Divert On No Answer is enabled, then stop the timer    
    if( m_hCallDivertOnNATimer )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCallDivertOnNATimer, NULL );
        m_hCallDivertOnNATimer = NULL;
    }

        //encode and send Q931Connect message to the peer
    if( !SendQ931Message( dwInvokeID, 0, 0, CONNECTMESSAGETYPE, dwAPDUType ) )
    {
        //post a message to the callback thread to shutdown the H323 call
        CloseCall( 0 );
        return FALSE;
    }

    m_dwStateMachine = Q931_CONNECT_SENT;

    H323DBG((DEBUG_LEVEL_TRACE, "AcceptH323Call exited: %p.", this ));    
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::SendQ931Message( 
    IN DWORD dwInvokeID,
    IN ULONG_PTR dwParam1,
    IN ULONG_PTR dwParam2,
    IN DWORD dwMessageType,
    IN DWORD dwAPDUType
    )
{
    BINARY_STRING userUserData;
    DWORD dwCodedLengthPDU;
    BYTE *pbCodedPDU;
    BOOL retVal = FALSE;
    WCHAR * pwszCalledPartyNumber = NULL;

    H323DBG((DEBUG_LEVEL_TRACE, "SendQ931Message entered: %p.", this ));

    //check if socket is connected
    if( !(m_dwQ931Flags & Q931_CALL_CONNECTED) )
    {
        return FALSE;
    }
    
    switch ( dwMessageType )
    {
    //encode the UU message
    case SETUPMESSAGETYPE:
        retVal = EncodeSetupMessage( dwInvokeID, (WORD)dwParam1, //dwGoal
                                    (WORD)dwParam2, //dwCalType
                                    &userUserData.pbBuffer,
                                    &userUserData.length,
                                    dwAPDUType );
        break;

    case ALERTINGMESSAGETYPE:
        retVal = EncodeAlertMessage( dwInvokeID,
                                     &userUserData.pbBuffer,
                                     &userUserData.length,
                                     dwAPDUType );
        break;

    case PROCEEDINGMESSAGETYPE:
        retVal = EncodeProceedingMessage(   dwInvokeID,
                                            &userUserData.pbBuffer,
                                            &userUserData.length,
                                            dwAPDUType );
        break;
    
    case RELEASECOMPLMESSAGETYPE:
        retVal = EncodeReleaseCompleteMessage(  dwInvokeID,
                                                (BYTE*)dwParam1, //pbReason
                                                &userUserData.pbBuffer,
                                                &userUserData.length,
                                                dwAPDUType );
        break;

    case CONNECTMESSAGETYPE:
        retVal = EncodeConnectMessage(  dwInvokeID,
                                        &userUserData.pbBuffer,
                                        &userUserData.length,
                                        dwAPDUType );
        break;

    case FACILITYMESSAGETYPE:
        retVal = EncodeFacilityMessage( dwInvokeID,
                                        (BYTE)dwParam1,
                                        (ASN1octetstring_t*)dwParam2,
                                        &userUserData.pbBuffer,
                                        &userUserData.length,
                                        dwAPDUType );
        break;
    }

    if( retVal == FALSE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not encode message:%d.", dwMessageType));
        
        if( userUserData.pbBuffer )
        {
            ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, userUserData.pbBuffer );
        }

        return FALSE;
    }


    if (m_dwAddressType == LINEADDRESSTYPE_PHONENUMBER)
    {
        _ASSERTE( m_pCalleeAliasNames->pItems[0].wType == e164_chosen );
        pwszCalledPartyNumber = m_pCalleeAliasNames ->pItems[0].pData;
    }

    //encode the PDU
    retVal = EncodePDU( &userUserData,
                &pbCodedPDU,
                &dwCodedLengthPDU,
                dwMessageType,
                pwszCalledPartyNumber );
                    
    if( retVal == FALSE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not encode PDU: %d.", dwMessageType ));
    }
    else if(!SendBuffer( pbCodedPDU, dwCodedLengthPDU ))
    {
        retVal = FALSE;
    }

    if( userUserData.pbBuffer )
    {
        ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, userUserData.pbBuffer );
    }

    H323DBG((DEBUG_LEVEL_TRACE, "SendQ931Message exited: %p.", this ));
    
    return retVal;
}


//!!always called in a lock
BOOL
CH323Call::EncodeFastStartProposal(
    PH323_FASTSTART pFastStart,
    BYTE**      ppEncodedBuf,
    WORD*       pwEncodedLength
    )
{
    int rc;
    H323_UserInformation UserInfo;

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeFastStartProposal entered: %p.", this ));
    
    CallProceeding_UUIE & proceedingMessage = 
    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding;

    *ppEncodedBuf = NULL;
    *pwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;


    //copy the call identifier
    proceedingMessage.bit_mask |= CallProceeding_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&proceedingMessage.callIdentifier.guid.value,
            (PVOID)&m_callIdentifier,
            sizeof(GUID) );
    proceedingMessage.callIdentifier.guid.length = sizeof(GUID);

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);
    UserInfo.h323_uu_pdu.bit_mask = 0;

    UserInfo.h323_uu_pdu.h323_message_body.choice = callProceeding_chosen;
    proceedingMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;
    
    proceedingMessage.bit_mask |= CallProceeding_UUIE_fastStart_present;
    proceedingMessage.fastStart = (PCallProceeding_UUIE_fastStart)pFastStart;

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pwEncodedLength == 0) )
    {
        return FALSE;
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeFastStartProposal exited: %p.", this ));
    //success
    return TRUE;                
}

                     
//!!always called in a lock
BOOL
CH323Call::EncodeFacilityMessage(
    IN DWORD dwInvokeID,
    IN BYTE  bReason,
    IN ASN1octetstring_t* pH245PDU,
    OUT BYTE **ppEncodedBuf,
    OUT WORD *pdwEncodedLength,
    IN DWORD dwAPDUType
    )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int                     rc;
    H323_UserInformation    UserInfo;
    DWORD                   dwAPDULen = 0;
    BYTE*                   pEncodedAPDU = NULL;

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeFacilityMessage entered: %p.", this ));
    
    Facility_UUIE & facilityMessage = 
        UserInfo.h323_uu_pdu.h323_message_body.u.facility;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    //send the appropriate ADPDUS
    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU(dwInvokeID, dwAPDUType, 
                            &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;
        
        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = facility_chosen;

    facilityMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;
    facilityMessage.bit_mask = 0;

    TransportAddress& transportAddress = facilityMessage.alternativeAddress;
    
    if( IsGuidSet( &m_ConferenceID ) )
    {
        CopyConferenceID(&facilityMessage.conferenceID, &m_ConferenceID);
        facilityMessage.bit_mask |= Facility_UUIE_conferenceID_present;
    }

    switch (bReason)
    {
    case H323_REJECT_ROUTE_TO_GATEKEEPER:
        facilityMessage.reason.choice = 
            FacilityReason_routeCallToGatekeeper_chosen;
        break;

    case H323_REJECT_CALL_FORWARDED:
        facilityMessage.reason.choice = callForwarded_chosen;
        break;
    
    case H323_REJECT_ROUTE_TO_MC:
        facilityMessage.reason.choice = routeCallToMC_chosen;
        break;
    
    default:
        facilityMessage.reason.choice = FacilityReason_undefinedReason_chosen;
    }

    facilityMessage.bit_mask |= Facility_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&facilityMessage.callIdentifier.guid.value,
            (PVOID)"abcdabcdabcdabcdabcd",
            sizeof(GUID) );
    facilityMessage.callIdentifier.guid.length = sizeof(GUID);

    if( pH245PDU && (pH245PDU->value != NULL) )
    {
        //h245 PDU to be sent
        UserInfo.h323_uu_pdu.h245Control->next = NULL;
        UserInfo.h323_uu_pdu.h245Control->value.length = pH245PDU->length;
        UserInfo.h323_uu_pdu.h245Control->value.value = pH245PDU->value;
    }

    rc = EncodeASN((void *) &UserInfo,
                 H323_UserInformation_PDU,
                 ppEncodedBuf,
                 pdwEncodedLength);

    if( ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }
        return FALSE;
    }

    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeFacilityMessage exited: %p.", this ));    
    //success
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::EncodeAlertMessage(
                                IN DWORD dwInvokeID,
                                OUT BYTE **ppEncodedBuf,
                                OUT WORD *pdwEncodedLength,
                                IN DWORD dwAPDUType
                             )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int rc;
    H323_UserInformation UserInfo;
    DWORD                dwAPDULen = 0;
    BYTE*                pEncodedAPDU = NULL;

    
    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeAlertMessage entered: %p.", this ));

    Alerting_UUIE & alertingMessage = 
    UserInfo.h323_uu_pdu.h323_message_body.u.alerting;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;
    
    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;

        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = alerting_chosen;

    alertingMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;
    alertingMessage.destinationInfo.bit_mask = 0;
    
    //copy the vendor info
    alertingMessage.destinationInfo.bit_mask |= vendor_present;
    CopyVendorInfo( &alertingMessage.destinationInfo.vendor );

    //its a terminal
    alertingMessage.destinationInfo.bit_mask = terminal_present;
    alertingMessage.destinationInfo.terminal.bit_mask = 0;
    
    //not na MC
    alertingMessage.destinationInfo.mc = 0;
    alertingMessage.destinationInfo.undefinedNode = 0;
        
    TransportAddress& transportAddress = alertingMessage.h245Address;

    //send H245 address only if the caller hasn't proposed FasrStart
    //or the fast start proposal has been accepeted
    if( (m_pPeerFastStart == NULL) || m_pFastStart )
    {
        if( m_selfH245Addr.Addr.IP_Binary.dwAddr != 0 )
        {
            CopyTransportAddress( transportAddress, &m_selfH245Addr );
            alertingMessage.bit_mask |= (Alerting_UUIE_h245Address_present);
        }
        else
        {
            alertingMessage.bit_mask &= (~Alerting_UUIE_h245Address_present);
        }
    }

    if( m_pFastStart != NULL )
    {
        _ASSERTE( m_pPeerFastStart );
        alertingMessage.bit_mask |= Alerting_UUIE_fastStart_present;
        alertingMessage.fastStart = (PAlerting_UUIE_fastStart)m_pFastStart;
    }
    else
    {
        alertingMessage.bit_mask &= ~Alerting_UUIE_fastStart_present;
    }

    //copy the call identifier
    alertingMessage.bit_mask |= Alerting_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&alertingMessage.callIdentifier.guid.value,
            (PVOID)&m_callIdentifier,
            sizeof(GUID) );
    alertingMessage.callIdentifier.guid.length = sizeof(GUID);


    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }
        return FALSE;
    }

    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeAlertMessage exited: %p.", this ));    
    //success
    return TRUE;                
}


//!!always called in a lock
BOOL
CH323Call::EncodeProceedingMessage(
                                    IN DWORD dwInvokeID,
                                    OUT BYTE **ppEncodedBuf,
                                    OUT WORD *pdwEncodedLength,
                                    IN DWORD dwAPDUType
                                  )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int rc;
    H323_UserInformation UserInfo;
    DWORD                dwAPDULen = 0;
    BYTE*               pEncodedAPDU = NULL;


    H323DBG((DEBUG_LEVEL_TRACE, "EncodeProceedingMessage entered: %p.", this ));
    
    CallProceeding_UUIE & proceedingMessage = 
    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;

        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = callProceeding_chosen;
    proceedingMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;

    TransportAddress& transportAddress = proceedingMessage.h245Address;
    
    //send H245 address only if the caller hasn't proposed FasrStart
    //or the fast start proposal has been accepeted
    if( (m_pPeerFastStart == NULL) || m_pFastStart )
    {
        if( m_selfH245Addr.Addr.IP_Binary.dwAddr != 0 )
        {
            CopyTransportAddress( transportAddress, &m_selfH245Addr );
            proceedingMessage.bit_mask |= CallProceeding_UUIE_h245Address_present;
        }
        else
        {
            proceedingMessage.bit_mask &= ~CallProceeding_UUIE_h245Address_present;
        }
    }

    proceedingMessage.destinationInfo.bit_mask = 0;

    //copy the vendor info
    proceedingMessage.destinationInfo.bit_mask |= vendor_present;
    CopyVendorInfo( &proceedingMessage.destinationInfo.vendor );

    proceedingMessage.destinationInfo.mc = 0;
    proceedingMessage.destinationInfo.undefinedNode = 0;

    if( m_pFastStart != NULL )
    {
        _ASSERTE( m_pPeerFastStart );
        proceedingMessage.bit_mask |= Alerting_UUIE_fastStart_present;
        proceedingMessage.fastStart = 
            (PCallProceeding_UUIE_fastStart)m_pFastStart;
    }
    else
    {
        proceedingMessage.bit_mask &= ~Alerting_UUIE_fastStart_present;
    }

    //copy the call identifier
    proceedingMessage.bit_mask |= CallProceeding_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&proceedingMessage.callIdentifier.guid.value,
            (PVOID)&m_callIdentifier,
            sizeof(GUID) );
    proceedingMessage.callIdentifier.guid.length = sizeof(GUID);

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }        

        return FALSE;
    }
        
    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeProceedingMessage exited: %p.", this ));
    //success
    return TRUE;                
}


//!!always called in a lock
BOOL 
CH323Call::EncodeReleaseCompleteMessage(
    IN DWORD dwInvokeID,
    IN BYTE *pbReason,
    OUT BYTE **ppEncodedBuf,
    OUT WORD *pdwEncodedLength,
    IN DWORD dwAPDUType
    )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int rc;
    H323_UserInformation UserInfo;
    DWORD                dwAPDULen = 0;
    BYTE*               pEncodedAPDU = NULL;


    H323DBG((DEBUG_LEVEL_TRACE, "EncodeReleaseCompleteMessage entered: %p.", this ));
    
    ReleaseComplete_UUIE & releaseMessage = 
    UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;
        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    SetNonStandardData( UserInfo );
    
    UserInfo.h323_uu_pdu.h323_message_body.choice = releaseComplete_chosen;

    releaseMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;

    if( pbReason )
    {
        releaseMessage.reason.choice = 0;
        releaseMessage.bit_mask |= (ReleaseComplete_UUIE_reason_present);

        switch (*pbReason)
        {
        case H323_REJECT_NO_BANDWIDTH:
            releaseMessage.reason.choice = noBandwidth_chosen;
            break;

        case H323_REJECT_GATEKEEPER_RESOURCES:
            releaseMessage.reason.choice = gatekeeperResources_chosen;
            break;
        
        case H323_REJECT_UNREACHABLE_DESTINATION:
            releaseMessage.reason.choice = unreachableDestination_chosen;
            break;
        
        case H323_REJECT_DESTINATION_REJECTION:
            releaseMessage.reason.choice = destinationRejection_chosen;
            break;
        
        case H323_REJECT_INVALID_REVISION:
            releaseMessage.reason.choice 
                = ReleaseCompleteReason_invalidRevision_chosen;
            break;
        
        case H323_REJECT_NO_PERMISSION:
            releaseMessage.reason.choice = noPermission_chosen;
            break;
        
        case H323_REJECT_UNREACHABLE_GATEKEEPER:
            releaseMessage.reason.choice = unreachableGatekeeper_chosen;
            break;
        
        case H323_REJECT_GATEWAY_RESOURCES:
            releaseMessage.reason.choice = gatewayResources_chosen;
            break;
        
        case H323_REJECT_BAD_FORMAT_ADDRESS:
            releaseMessage.reason.choice = badFormatAddress_chosen;
            break;
        
        case H323_REJECT_ADAPTIVE_BUSY:
            releaseMessage.reason.choice = adaptiveBusy_chosen;
            break;
        
        case H323_REJECT_IN_CONF:
            releaseMessage.reason.choice = inConf_chosen;
            break;
        
        case H323_REJECT_CALL_DEFLECTION:
            releaseMessage.reason.choice = 
                ReleaseCompleteReason_undefinedReason_chosen ;
            break;
        
        case H323_REJECT_UNDEFINED_REASON:
            releaseMessage.reason.choice = ReleaseCompleteReason_undefinedReason_chosen ;
            break;
        
        case H323_REJECT_USER_BUSY:
            releaseMessage.reason.choice = inConf_chosen;
            break;
        
        default:
            //log

            if( pEncodedAPDU != NULL )
            {
                ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
            }        
            return FALSE;
        }
    }

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }        
        return FALSE;
    }
    
    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeReleaseCompleteMessage exited: %p.", this ));
    //success
    return TRUE;                
}


//!!always called in a lock
BOOL 
CH323Call::EncodeConnectMessage( 
    IN DWORD dwInvokeID,
    OUT BYTE **ppEncodedBuf,
    OUT WORD *pdwEncodedLength,
    IN DWORD dwAPDUType
    )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int rc;
    H323_UserInformation UserInfo;
    DWORD                dwAPDULen = 0;
    BYTE*               pEncodedAPDU = NULL;


    H323DBG((DEBUG_LEVEL_TRACE, "EncodeConnectMessage entered: %p.", this ));
    
    Connect_UUIE & connectMessage = 
        UserInfo.h323_uu_pdu.h323_message_body.u.connect;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;
    
    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    //send the appropriate ADPDUS
    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, 
                &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;
        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = connect_chosen;

    connectMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;

    TransportAddress& transportAddress = connectMessage.h245Address;
    CopyTransportAddress( transportAddress, &m_selfH245Addr );
    connectMessage.bit_mask |= (Connect_UUIE_h245Address_present);

    connectMessage.destinationInfo.bit_mask = 0;

    //copy the vendor info
    connectMessage.destinationInfo.bit_mask |= vendor_present;
    CopyVendorInfo( &connectMessage.destinationInfo.vendor );

    //terminal is present
    connectMessage.destinationInfo.bit_mask |= terminal_present;
    connectMessage.destinationInfo.terminal.bit_mask = 0;

    connectMessage.destinationInfo.mc = 0;
    connectMessage.destinationInfo.undefinedNode = 0;

    //copy the 16 byte conference ID
    CopyConferenceID (&connectMessage.conferenceID, &m_ConferenceID);

    if( m_pFastStart != NULL )
    {
        _ASSERTE( m_pPeerFastStart );
        connectMessage.bit_mask |= Connect_UUIE_fastStart_present;
        connectMessage.fastStart = (PConnect_UUIE_fastStart)m_pFastStart;
    }
    else
    {
        connectMessage.bit_mask &= ~Alerting_UUIE_fastStart_present;
    }

    //copy the call identifier
    connectMessage.bit_mask |= Connect_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&connectMessage.callIdentifier.guid.value,
            (PVOID)&m_callIdentifier,
            sizeof(GUID) );
    connectMessage.callIdentifier.guid.length = sizeof(GUID);

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }        

        return FALSE;
    }
        
    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeConnectMessage exited: %p.", this ));
    //success
    return TRUE;                
}


//!!always called in a lock
void CH323Call::SetNonStandardData(
    OUT H323_UserInformation & UserInfo 
    )
{
    if( m_NonStandardData.sData.pOctetString )
    {
          H221NonStandard & nonStd =
              UserInfo.h323_uu_pdu.nonStandardData.nonStandardIdentifier.u.h221NonStandard;

        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nonStandardData_present;
    
        UserInfo.h323_uu_pdu.nonStandardData.nonStandardIdentifier.choice
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        
        nonStd.t35CountryCode = m_NonStandardData.bCountryCode;
        nonStd.t35Extension = m_NonStandardData.bExtension;
        nonStd.manufacturerCode = m_NonStandardData.wManufacturerCode;
        
        UserInfo.h323_uu_pdu.nonStandardData.data.length =
            m_NonStandardData.sData.wOctetStringLength;
        
        UserInfo.h323_uu_pdu.nonStandardData.data.value =
            m_NonStandardData.sData.pOctetString;

        // Maintain only one reference to the buffer.
        m_NonStandardData.sData.pOctetString = NULL;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nonStandardData_present);
    }
}


//!!always called in a lock
BOOL
CH323Call::EncodeSetupMessage( 
    IN DWORD dwInvokeID,
    IN WORD wGoal,
    IN WORD wCallType,
    OUT BYTE **ppEncodedBuf,
    OUT WORD *pdwEncodedLength,
    IN DWORD dwAPDUType
    )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    H323_UserInformation UserInfo;
    int                 rc = 0;
    BOOL                retVal = TRUE;
    DWORD               dwAPDULen = 0;
    BYTE*              pEncodedAPDU = NULL;
        
    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;
    
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeSetupMessage entered: %p.", this ));

    Setup_UUIE & setupMessage = UserInfo.h323_uu_pdu.h323_message_body.u.setup;
    TransportAddress& calleeAddr = setupMessage.destCallSignalAddress;
    TransportAddress& callerAddr = setupMessage.sourceCallSignalAddress;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    //send the appropriate ADPDUS
    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;
        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = setup_chosen;
    setupMessage.bit_mask = 0;

    setupMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;

    if( m_pCallerAliasNames && m_pCallerAliasNames -> wCount )
    {
        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
        setupMessage.sourceAddress = SetMsgAddressAlias(m_pCallerAliasNames);

        if( setupMessage.sourceAddress != NULL )
        {
            setupMessage.bit_mask |= (sourceAddress_present);
        }
        else
        {
            setupMessage.bit_mask &= (~sourceAddress_present);
        }
    }
    else
    {
        setupMessage.bit_mask &= (~sourceAddress_present);
    }

    setupMessage.sourceInfo.bit_mask = 0;

    //pass the vendor info
    setupMessage.sourceInfo.bit_mask |= vendor_present;
    CopyVendorInfo( &setupMessage.sourceInfo.vendor );

    //terminal is present
    setupMessage.sourceInfo.bit_mask |= terminal_present;
    setupMessage.sourceInfo.terminal.bit_mask = 0;

    //not an MC
    setupMessage.sourceInfo.mc = FALSE;
    setupMessage.sourceInfo.undefinedNode = 0;

    if( m_pCalleeAliasNames && m_pCalleeAliasNames -> wCount )
    {
        setupMessage.destinationAddress = (PSetup_UUIE_destinationAddress)
            SetMsgAddressAlias( m_pCalleeAliasNames );

        if( setupMessage.destinationAddress != NULL )
        {
            setupMessage.bit_mask |= (destinationAddress_present);
        }
        else
        {
            setupMessage.bit_mask &= (~destinationAddress_present);
        }
    }
    else
    {
        setupMessage.bit_mask &= (~destinationAddress_present);
    }

    //extra alias not present
    setupMessage.bit_mask &= (~Setup_UUIE_destExtraCallInfo_present );

    //If talking to gateway then don't pass on destn call signal address
    if( m_dwAddressType != LINEADDRESSTYPE_PHONENUMBER )
    {
        CopyTransportAddress( calleeAddr, &m_CalleeAddr );
        setupMessage.bit_mask |= Setup_UUIE_destCallSignalAddress_present;
    }

    //not an MC
    setupMessage.activeMC = m_fActiveMC;

    //copy the 16 byte conference ID
    CopyConferenceID (&setupMessage.conferenceID, &m_ConferenceID);

    //copy the call identifier
    setupMessage.bit_mask |= Setup_UUIE_callIdentifier_present;
    CopyConferenceID (&setupMessage.callIdentifier.guid, &m_callIdentifier);

    //fast start params
    if( m_pFastStart != NULL )
    {
        setupMessage.bit_mask |= Setup_UUIE_fastStart_present;
        setupMessage.fastStart = (PSetup_UUIE_fastStart)m_pFastStart;
    }
    else
    {
        setupMessage.bit_mask &= ~Setup_UUIE_fastStart_present;
    }

    //copy media wait for connect
    setupMessage.mediaWaitForConnect = FALSE;

    setupMessage.conferenceGoal.choice = (BYTE)wGoal;
    setupMessage.callType.choice = (BYTE)wCallType;

    CopyTransportAddress( callerAddr, &m_CallerAddr );
    setupMessage.bit_mask |= sourceCallSignalAddress_present;

    //no extension alias
    setupMessage.bit_mask &= (~Setup_UUIE_remoteExtensionAddress_present);

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if( ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {

        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }        

        retVal = FALSE;
    }

    // Free the alias name structures from the UserInfo area.
    if( setupMessage.bit_mask & sourceAddress_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            setupMessage.sourceAddress );
    }
    
    if( setupMessage.bit_mask & destinationAddress_present )
    {
        FreeAddressAliases( setupMessage.destinationAddress );
    }
    
    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeSetupMessage exited: %p.", this ));    
    //success/failure
    return retVal;                
}


//!!always called in a lock
BOOL
CH323Call::EncodeH450APDU(
    IN DWORD dwInvokeID,
    IN DWORD dwAPDUType,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
    )
{
    H4501SupplementaryService SupplementaryServiceAPDU;
    ServiceApdus_rosApdus rosAPDU;
    DWORD dwErrorCode = 0;
    DWORD dwOperationType = (dwAPDUType & 0x0000FF00);
    dwAPDUType &= 0x000000FF;
    
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeH450APDU entered: %p.", this ));

    ZeroMemory( (PVOID)&SupplementaryServiceAPDU, 
        sizeof(H4501SupplementaryService) );

    //interpretationAPDU
    SupplementaryServiceAPDU.interpretationApdu.choice =
        rejectAnyUnrecognizedInvokePdu_chosen;
    SupplementaryServiceAPDU.bit_mask |= interpretationApdu_present;
    
    //NFE
    SupplementaryServiceAPDU.networkFacilityExtension.bit_mask = 0;
    SupplementaryServiceAPDU.networkFacilityExtension.destinationEntity.choice
        = endpoint_chosen;
    SupplementaryServiceAPDU.networkFacilityExtension.sourceEntity.choice
        = endpoint_chosen;
    SupplementaryServiceAPDU.bit_mask |= networkFacilityExtension_present;

    //serviceAPDUS
    SupplementaryServiceAPDU.serviceApdu.choice = rosApdus_chosen;
    SupplementaryServiceAPDU.serviceApdu.u.rosApdus = &rosAPDU;
    SupplementaryServiceAPDU.serviceApdu.u.rosApdus->next = NULL;

    if( dwOperationType == H450_REJECT )
    {
        if( !EncodeRejectAPDU( &SupplementaryServiceAPDU, dwInvokeID,
            ppEncodedAPDU, pdwAPDULen ) )
        {
            return FALSE;
        }
    }
    else if( dwOperationType == H450_RETURNERROR )
    {
        EncodeReturnErrorAPDU( dwInvokeID, dwErrorCode, 
            &SupplementaryServiceAPDU, ppEncodedAPDU, pdwAPDULen );
    }
    else if( dwOperationType == H450_RETURNRESULT )
    {
        if( !EncodeDummyReturnResultAPDU( dwInvokeID,
            dwAPDUType, &SupplementaryServiceAPDU,
            ppEncodedAPDU, pdwAPDULen ) )
        {
            return FALSE;
        }
    }
    else //H450_INVOKE
    {
        switch( dwAPDUType )
        {
        case CHECKRESTRICTION_OPCODE:
    
            if( !EncodeCheckRestrictionAPDU( &SupplementaryServiceAPDU,
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }
           
            break;
        
        case CALLREROUTING_OPCODE:

            if( !EncodeCallReroutingAPDU( &SupplementaryServiceAPDU, 
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }
    
            break;

        case DIVERTINGLEGINFO2_OPCODE:

            if( !EncodeDivertingLeg2APDU( &SupplementaryServiceAPDU, 
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }
        
            break;

        case DIVERTINGLEGINFO3_OPCODE:

            if( !EncodeDivertingLeg3APDU( &SupplementaryServiceAPDU, 
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }

            break;

        case HOLDNOTIFIC_OPCODE:
        case REMOTEHOLD_OPCODE:
        case RETRIEVENOTIFIC_OPCODE:
        case REMOTERETRIEVE_OPCODE:
        case CTIDENTIFY_OPCODE:

            if( !EncodeH450APDUNoArgument( dwAPDUType, &SupplementaryServiceAPDU,
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }
            break;

        case CTSETUP_OPCODE:

            if( !EncodeCTSetupAPDU( &SupplementaryServiceAPDU, 
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }

            break;
   
        case CTINITIATE_OPCODE:

            if( !EncodeCTInitiateAPDU( &SupplementaryServiceAPDU,
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }

            break;

        default:
            _ASSERTE( 0 );
            return FALSE;
        }
    }

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeH450APDU exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::EncodePDU(
    IN BINARY_STRING *pUserUserData,
    OUT BYTE ** ppbCodedBuffer,
    OUT DWORD * pdwCodedBufferLength,
    IN DWORD dwMessageType,
    WCHAR * pwszCalledPartyNumber
    )
{
    PQ931MESSAGE    pMessage;
    BYTE            bBandwidth;
    char            pszDisplay[131] = "";
    DWORD           dwMessageLength = 0;
    BYTE            indexI;
    BOOL            retVal;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodePDU entered: %p.", this ));

    pMessage = new Q931MESSAGE;
    if( pMessage == NULL )
    {
        return FALSE;
    }

    // fill in the required fields for the Q931 message.
    memset( (PVOID)pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->wCallRef = m_wQ931CallRef;
    pMessage->MessageType = (BYTE)dwMessageType;

    dwMessageLength += 
        ( 1 + sizeof(PDTYPE) + sizeof(CRTYPE) + sizeof(MESSAGEIDTYPE) );

    if( (dwMessageType == SETUPMESSAGETYPE) || 
        (dwMessageType == CONNECTMESSAGETYPE) )
    {
        if( m_pwszDisplay && 
            WideCharToMultiByte(CP_ACP, 
                                0, 
                                m_pwszDisplay, 
                                -1, 
                                pszDisplay,
                                sizeof(pszDisplay), 
                                NULL, 
                                NULL) == 0)
        {
            delete pMessage;
            return FALSE;
        }

        if( *pszDisplay )
        {
            pMessage->Display.fPresent = TRUE;
            pMessage->Display.dwLength = (BYTE)(strlen(pszDisplay) + 1);
            strcpy((char *)pMessage->Display.pbContents, pszDisplay);
            dwMessageLength += (2 + pMessage->Display.dwLength);
        }

        pMessage->BearerCapability.fPresent = TRUE;
        pMessage->BearerCapability.dwLength = 3;
        pMessage->BearerCapability.pbContents[0] =
            (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
        pMessage->BearerCapability.pbContents[1] =
            (BYTE)(BEAR_EXT_BIT | 0x17);  //64kbps
        pMessage->BearerCapability.pbContents[2] = (BYTE)
            (BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | BEAR_LAYER1_H221_H242);

        dwMessageLength += (2+pMessage->BearerCapability.dwLength);
    }

    //if talking to gateway encode the called party number
    if( m_dwAddressType == LINEADDRESSTYPE_PHONENUMBER )
    {
        BYTE bLen = (BYTE)(wcslen(pwszCalledPartyNumber)+1);
        pMessage->CalledPartyNumber.fPresent = TRUE;

        pMessage->CalledPartyNumber.NumberType =
            (BYTE)(CALLED_PARTY_EXT_BIT | CALLED_PARTY_TYPE_UNKNOWN);
        pMessage->CalledPartyNumber.NumberingPlan =
            (BYTE)(CALLED_PARTY_PLAN_E164);
        pMessage->CalledPartyNumber.PartyNumberLength = bLen;

        for( indexI =0; indexI < bLen; indexI++ )
        {
            pMessage->CalledPartyNumber.PartyNumbers[indexI] = 
                (BYTE)pwszCalledPartyNumber[indexI];
        }

        dwMessageLength += (2 + pMessage->CalledPartyNumber.PartyNumberLength);
    }

    if( dwMessageType == FACILITYMESSAGETYPE )
    {
        // The facility ie is encoded as present, but empty...
        pMessage->Facility.fPresent = TRUE;
        pMessage->Facility.dwLength = 0;
        pMessage->Facility.pbContents[0] = 0;

        dwMessageLength += (2 + pMessage->Facility.dwLength);
    }

    if (pUserUserData && pUserUserData->pbBuffer)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.pbUserInfo))
        {
            delete pMessage;
            return FALSE;
        }
        pMessage->UserToUser.fPresent = TRUE;
        pMessage->UserToUser.wUserInfoLen = pUserUserData->length;
        
        //This CopyMemory should be avoided
        //may be we should do:pMessage->UserToUser.pbUserInfo = pUserUserData->pbBuffer;
        //change the definition of pMessage->UserToUser.pbUserInfo to BYTE* from BYTE[0x1000]
        CopyMemory( (PVOID)pMessage->UserToUser.pbUserInfo,
            (PVOID)pUserUserData->pbBuffer, pUserUserData->length );

        dwMessageLength += (4+pMessage->UserToUser.wUserInfoLen);
    }

    _ASSERTE( dwMessageLength );

    retVal = EncodeMessage( pMessage, ppbCodedBuffer, 
                          pdwCodedBufferLength, dwMessageLength );

    delete pMessage;

    return retVal;
}


//!!always called in a lock
BOOL 
CH323Call::EncodeMessage(
                        IN PQ931MESSAGE pMessage,
                        OUT BYTE **ppbCodedMessage,
                        OUT DWORD *pdwCodedMessageLength,
                        IN DWORD dwMessageLength
                        )
{
    BUFFERDESCR pBuf;
    DWORD dwPDULen = 0;

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeMessage entered: %p.", this ));
    
    *ppbCodedMessage = (BYTE *)new char[ dwMessageLength + 100 ];
    
    if( *ppbCodedMessage == NULL )
    {
        return FALSE;
    }

    pBuf.dwLength = dwMessageLength + 100;

    pBuf.pbBuffer = *ppbCodedMessage + TPKT_HEADER_SIZE;

    WriteQ931Fields(&pBuf, pMessage, &dwPDULen );

    _ASSERTE( dwPDULen == dwMessageLength );

    SetupTPKTHeader( *ppbCodedMessage , dwPDULen );

    *pdwCodedMessageLength = dwPDULen + 4;
    
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeMessage exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
void
CH323Call::WriteQ931Fields(
                            IN PBUFFERDESCR pBuf,
                            IN PQ931MESSAGE pMessage,
                            OUT DWORD * pdwPDULen
                          )
{
    H323DBG((DEBUG_LEVEL_TRACE, "WriteQ931Fields entered: %p.", this ));

    // write the required information elements...
    WriteProtocolDiscriminator( pBuf, pdwPDULen );

    WriteCallReference( pBuf, &pMessage->wCallRef,
        pdwPDULen );

    WriteMessageType(pBuf, &pMessage->MessageType,
        pdwPDULen);

    // try to write all other information elements...
    // don't write this message.
    if (pMessage->Facility.fPresent)
    {
        WriteVariableOctet(pBuf, IDENT_FACILITY,
            pMessage->Facility.dwLength,
            pMessage->Facility.pbContents,
            pdwPDULen);
    }

    if( pMessage->BearerCapability.fPresent 
        && pMessage->BearerCapability.dwLength )
    {
        WriteVariableOctet(pBuf, IDENT_BEARERCAP,
            pMessage->BearerCapability.dwLength,
            pMessage->BearerCapability.pbContents,
            pdwPDULen);
    }

    if (pMessage->Display.fPresent && pMessage->Display.dwLength)
    {
        WriteVariableOctet(pBuf, IDENT_DISPLAY,
            pMessage->Display.dwLength,
            pMessage->Display.pbContents,
            pdwPDULen);
    }
        
    if( pMessage->CalledPartyNumber.fPresent )
    {
        WritePartyNumber(pBuf,
            IDENT_CALLEDNUMBER,
            pMessage->CalledPartyNumber.NumberType,
            pMessage->CalledPartyNumber.NumberingPlan,
            pMessage->CalledPartyNumber.PartyNumberLength,
            pMessage->CalledPartyNumber.PartyNumbers,
            pdwPDULen);
    }

    if( pMessage->UserToUser.fPresent && 
        pMessage->UserToUser.wUserInfoLen )
    {
        WriteUserInformation(pBuf,
            IDENT_USERUSER,
            pMessage->UserToUser.wUserInfoLen,
            pMessage->UserToUser.pbUserInfo,
            pdwPDULen);
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "WriteQ931Fields exited: %p.", this ));
}


//!!always calld in a lock
void 
CH323Call::HandleTransportEvent(void)
{
    WSANETWORKEVENTS networkEvents;
    int iError;

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransportEvent entered: %p.", this ));
    
    if( (m_callSocket == INVALID_SOCKET) && 
        (m_dwCallType == CALLTYPE_DIVERTEDSRC) )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "The diverted call is not initialized yet."
            "This is probably an event for the primary call. Ignore it %p.", 
            this ));
        
        return;
    }

    //find out the event that took place
    if(WSAEnumNetworkEvents(m_callSocket,
                            m_hTransport,
                            &networkEvents ) == SOCKET_ERROR )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "WSAEnumNetworkEvents error:%d, %lx, %p.",
            WSAGetLastError(), m_callSocket, this ));
        return;
    }
                            
    if( networkEvents.lNetworkEvents & FD_CLOSE )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "socket close event: %p.", this ));


        //if the call is in transition then don't close the call when the
        //old socket gets closed
        if( m_fCallInTrnasition == TRUE ) 
        {
            //the call is noot in transition mode anymore
            m_fCallInTrnasition = FALSE;
            return;
        }
        //convey the Q931 close status to the TAPI call object
        //and the tapisrv
        iError = networkEvents.iErrorCode[FD_CLOSE_BIT];
        
        SetQ931CallState( Q931_CALL_DISCONNECTED );
        
        //clean up the Q931 call
        CloseCall( 0 );
        return;
    }
    
    //This can occur only for outbound calls
    if( (networkEvents.lNetworkEvents) & FD_CONNECT )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "socket connect event: %p.", this ));

        //FD_CONNECT event received
        //This func is called by the callback thread when m_hEventQ931Conn is
        //signalled. This function takes care of the outgoing Q931 calls only
        //call the member function
        iError = networkEvents.iErrorCode[FD_CONNECT_BIT];
        if(iError != ERROR_SUCCESS)
        {
            if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
                (m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
            {
                //Success of forwarding
                EnableCallForwarding();
            }
            
            H323DBG((DEBUG_LEVEL_ERROR, "FD_CONNECT returned error: %d.", 
                iError ));

            CloseCall( 0 );         
            return;
        }
        OnConnectComplete();
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "HandleTransportEvent exited: %p.", this ));
}


//!!always called in a lock
int 
CH323Call::InitASNCoder(void)
{
    int rc;
    H323DBG((DEBUG_LEVEL_TRACE, "InitASNCoder entered: %p.", this ));

    memset((PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    if( H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H225ASN_Module,         // ptr to mdule
                &(m_ASNCoderInfo.pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        _ASSERTE(m_ASNCoderInfo.pEncInfo );

        rc = ASN1_CreateDecoder(
                H225ASN_Module,         // ptr to mdule
                &(m_ASNCoderInfo.pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        _ASSERTE(m_ASNCoderInfo.pDecInfo );
    }

    if (rc != ASN1_SUCCESS)
    {
        TermASNCoder();
    }

    H323DBG((DEBUG_LEVEL_TRACE, "InitASNCoder exited: %p.", this ));
    return rc;
}

//!!always called in a lock
int 
CH323Call::TermASNCoder(void)
{
    if( H225ASN_Module == NULL )
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(m_ASNCoderInfo.pEncInfo);
    ASN1_CloseDecoder(m_ASNCoderInfo.pDecInfo);

    memset( (PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    return ASN1_SUCCESS;
}


//!!always called in a lock
int 
CH323Call::EncodeASN(
                    IN void *  pStruct, 
                    IN int     nPDU, 
                    OUT BYTE ** ppEncoded, 
                    OUT WORD *  pcbEncodedSize
                    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeASN entered: %p.", this ));

    ASN1encoding_t pEncInfo = m_ASNCoderInfo.pEncInfo;
    int rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    ASN1ENCODE_ALLOCATEBUFFER,  // flags
                    NULL,                       // do not provide buffer
                    0);                         // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if( rc != ASN1_SUCCESS )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "warning while encoding ASN:%d.", rc ));
        }
        *pcbEncodedSize = (WORD)pEncInfo->len;  // len of encoded data in buffer
        *ppEncoded = pEncInfo->buf;             // buffer to encode into
    }
    else
    {
        H323DBG((DEBUG_LEVEL_TRACE, "error while encoding ASN:%d.", rc ));
        *pcbEncodedSize = 0;
        *ppEncoded = NULL;
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeASN exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
CH323Call::DecodeASN(
                      OUT void **   ppStruct, 
                      IN int       nPDU, 
                      IN BYTE *    pEncoded, 
                      IN DWORD     cbEncodedSize
                    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "h323call DecodeASN entered: %p.", this ));
    ASN1decoding_t pDecInfo = m_ASNCoderInfo.pDecInfo;
    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided

    if (ASN1_SUCCEEDED(rc))
    {
        if( rc != ASN1_SUCCESS )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "warning while deciding ASN:%d.", rc ));
        }
    }
    else
    {
        H323DBG((DEBUG_LEVEL_TRACE, "error while deciding ASN:%d.", rc ));
        H323DUMPBUFFER( (BYTE*)pEncoded, cbEncodedSize);
        *ppStruct = NULL;
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "h323call DecodeASN exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
CH323Call::InitH450ASNCoder(void)
{
    int rc;
    H323DBG((DEBUG_LEVEL_TRACE, "InitH450ASNCoder entered: %p.", this ));

    memset((PVOID)&m_H450ASNCoderInfo, 0, sizeof(m_H450ASNCoderInfo));

    if( H4503PP_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H4503PP_Module,         // ptr to mdule
                &(m_H450ASNCoderInfo.pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        _ASSERTE(m_H450ASNCoderInfo.pEncInfo );

        rc = ASN1_CreateDecoder(
                H4503PP_Module,         // ptr to mdule
                &(m_H450ASNCoderInfo.pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL );                  // parent ptr
        _ASSERTE( m_H450ASNCoderInfo.pDecInfo );
    }

    if (rc != ASN1_SUCCESS)
    {
        TermH450ASNCoder();
    }

    H323DBG((DEBUG_LEVEL_TRACE, "InitH450ASNCoder exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
CH323Call::TermH450ASNCoder(void)
{
    if( H4503PP_Module == NULL )
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(m_H450ASNCoderInfo.pEncInfo);
    ASN1_CloseDecoder(m_H450ASNCoderInfo.pDecInfo);

    memset( (PVOID)&m_H450ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    return ASN1_SUCCESS;
}


//!!always called in a lock
int 
CH323Call::EncodeH450ASN(
                    IN void *  pStruct, 
                    IN int     nPDU, 
                    OUT BYTE ** ppEncoded, 
                    OUT WORD *  pcbEncodedSize
                    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeH450ASN entered: %p.", this ));

    ASN1encoding_t pEncInfo = m_H450ASNCoderInfo.pEncInfo;
    int rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    ASN1ENCODE_ALLOCATEBUFFER,  // flags
                    NULL,                       // do not provide buffer
                    0);                         // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if( rc != ASN1_SUCCESS )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "warning while encoding ASN:%d.", rc ));
        }
        *pcbEncodedSize = (WORD)pEncInfo->len;  // len of encoded data in buffer
        *ppEncoded = pEncInfo->buf;             // buffer to encode into
    }
    else
    {
        H323DBG((DEBUG_LEVEL_TRACE, "error while encoding ASN:%d.", rc ));
        *pcbEncodedSize = 0;
        *ppEncoded = NULL;
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeH450ASN exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
CH323Call::DecodeH450ASN(
                      OUT void **   ppStruct, 
                      IN int       nPDU, 
                      IN BYTE *    pEncoded, 
                      IN DWORD     cbEncodedSize
                    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "h323call DecodeH450ASN entered: %p.", this ));
    ASN1decoding_t pDecInfo = m_H450ASNCoderInfo.pDecInfo;
    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided

    if( ASN1_SUCCEEDED(rc) )
    {
        if( rc != ASN1_SUCCESS )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "warning while deciding ASN:%d.", rc ));
        }
    }
    else
    {
        H323DBG((DEBUG_LEVEL_TRACE, "error while deciding ASN:%d.", rc ));
        H323DUMPBUFFER( (BYTE*)pEncoded, cbEncodedSize);
        *ppStruct = NULL;
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "h323call DecodeH450ASN exited: %p.", this ));
    return rc;
}


//------------------------------------------------------------------------
//------------------------------------------------------------------------
//!!always called in a lock
BOOL 
CH323Call::ParseReleaseCompleteASN(
                                    IN BYTE *pEncodedBuf,
                                    IN DWORD dwEncodedLength,
                                    OUT Q931_RELEASE_COMPLETE_ASN *pReleaseASN,
                                    OUT DWORD* pdwH450APDUType
                                  )
{
    H323_UserInformation *pUserInfo;
    int iResult;
    DWORD dwInvokeID = 0;
    
    H323DBG((DEBUG_LEVEL_TRACE, "ParseReleaseCompleteASN entered: %p.", this ));

    memset( (PVOID)pReleaseASN, 0, sizeof(Q931_RELEASE_COMPLETE_ASN));

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    *pdwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, NULL ) )
        {
            goto cleanup;
        }
    }
    
    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        goto cleanup;
    }

    // validate that the PDU is H323 Release Complete information.
    if( pUserInfo->h323_uu_pdu.h323_message_body.choice != releaseComplete_chosen )
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.

    pReleaseASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pReleaseASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pReleaseASN->fNonStandardDataPresent = TRUE;
    }

    if (pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask &
        ReleaseComplete_UUIE_reason_present)
    {
        switch( pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice )
        {
        case noBandwidth_chosen:
            pReleaseASN->bReason = H323_REJECT_NO_BANDWIDTH;
            break;
        
        case gatekeeperResources_chosen:
            pReleaseASN->bReason = H323_REJECT_GATEKEEPER_RESOURCES;
            break;
        
        case unreachableDestination_chosen:
            pReleaseASN->bReason = H323_REJECT_UNREACHABLE_DESTINATION;
            break;
        
        case destinationRejection_chosen:
            pReleaseASN->bReason = H323_REJECT_DESTINATION_REJECTION;
            break;
        
        case ReleaseCompleteReason_invalidRevision_chosen:
            pReleaseASN->bReason = H323_REJECT_INVALID_REVISION;
            break;
        
        case noPermission_chosen:
            pReleaseASN->bReason = H323_REJECT_NO_PERMISSION;
            break;
        
        case unreachableGatekeeper_chosen:
            pReleaseASN->bReason = H323_REJECT_UNREACHABLE_GATEKEEPER;
            break;
        
        case gatewayResources_chosen:
            pReleaseASN->bReason = H323_REJECT_GATEWAY_RESOURCES;
            break;
        
        case badFormatAddress_chosen:
            pReleaseASN->bReason = H323_REJECT_BAD_FORMAT_ADDRESS;
            break;
        
        case adaptiveBusy_chosen:
            pReleaseASN->bReason = H323_REJECT_ADAPTIVE_BUSY;
            break;
        
        case inConf_chosen:
            pReleaseASN->bReason = H323_REJECT_IN_CONF;
            break;
        
        case facilityCallDeflection_chosen:
            pReleaseASN->bReason = H323_REJECT_CALL_DEFLECTION;
            break;
        
        default:
            pReleaseASN->bReason = H323_REJECT_UNDEFINED_REASON;
        } // switch
    }
    else
    {
        pReleaseASN->bReason = H323_REJECT_UNDEFINED_REASON;
    }

    H323DBG(( DEBUG_LEVEL_TRACE,
        "ParseReleaseCompleteASN error:%d, q931 error:%d, exit:%p.",
        pReleaseASN->bReason,
        pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice,
        this ));

    // Free the PDU data.
    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );
        
    return TRUE;

cleanup:

    if( pReleaseASN->fNonStandardDataPresent )
    {
        delete pReleaseASN -> nonStandardData.sData.pOctetString;
        pReleaseASN -> nonStandardData.sData.pOctetString = NULL;
        pReleaseASN->fNonStandardDataPresent = FALSE;
    }

    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU);
    return FALSE;
}


//------------------------------------------------------------------------
//------------------------------------------------------------------------
//!!always called in a lock
BOOL 
CH323Call::ParseConnectASN(
                            IN BYTE *pEncodedBuf,
                            IN DWORD dwEncodedLength,
                            OUT Q931_CONNECT_ASN *pConnectASN,
                            OUT DWORD* pdwH450APDUType
                          )
{
    H323_UserInformation *pUserInfo;
    int iResult;
    DWORD dwInvokeID = 0;

    H323DBG((DEBUG_LEVEL_TRACE, "ParseConnectASN entered: %p.", this ));
    
    memset( (PVOID) pConnectASN, 0, sizeof(Q931_CONNECT_ASN) );

    iResult = DecodeASN((void **) &pUserInfo ,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    Connect_UUIE & connectMessage = 
        pUserInfo->h323_uu_pdu.h323_message_body.u.connect;

    *pdwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, NULL ) )
        {
            goto cleanup;
        }
    }
    
    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        goto cleanup;
    }

    // validate that the PDU is H323 Connect information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != connect_chosen)
    {
        goto cleanup;
    }

    // make sure that the conference id is formed correctly.
    if (connectMessage.conferenceID.length >
            sizeof(connectMessage.conferenceID.value))
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.

    pConnectASN->h245Addr.bMulticast = FALSE;

    pConnectASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pConnectASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pConnectASN->fNonStandardDataPresent = TRUE;
    }

    pConnectASN->h245AddrPresent = FALSE;
    if( connectMessage.bit_mask & Connect_UUIE_h245Address_present )
    {
        if( connectMessage.h245Address.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pConnectASN->h245Addr.nAddrType = H323_IP_BINARY;
        pConnectASN->h245Addr.Addr.IP_Binary.wPort = 
            connectMessage.h245Address.u.ipAddress.port;

        pConnectASN->h245Addr.Addr.IP_Binary.dwAddr = 
            ntohl( *((DWORD*)connectMessage.h245Address.u.ipAddress.ip.value) );

        pConnectASN->h245AddrPresent = TRUE;
    }

    // no validation of destinationInfo needed.
    pConnectASN->EndpointType.pVendorInfo = NULL;
    if( connectMessage.destinationInfo.bit_mask & (vendor_present))
    {
        if( !ParseVendorInfo( &pConnectASN->VendorInfo, 
            &connectMessage.destinationInfo.vendor) )
        {
            goto cleanup;
        }
                
        pConnectASN->EndpointType.pVendorInfo = &(pConnectASN->VendorInfo);
    }

    pConnectASN->EndpointType.bIsTerminal = FALSE;
    if (connectMessage.destinationInfo.bit_mask & (terminal_present))
    {
        pConnectASN->EndpointType.bIsTerminal = TRUE;
    }

    pConnectASN->EndpointType.bIsGateway = FALSE;
    if (connectMessage.destinationInfo.bit_mask & (gateway_present))
    {
        pConnectASN->EndpointType.bIsGateway = TRUE;
    }

    pConnectASN -> fFastStartPresent = FALSE;
    if( (connectMessage.bit_mask & Connect_UUIE_fastStart_present) &&
        connectMessage.fastStart )
    {
        pConnectASN->pFastStart = CopyFastStart( 
            (PSetup_UUIE_fastStart)connectMessage.fastStart );

        if( pConnectASN->pFastStart != NULL )
        {
            pConnectASN -> fFastStartPresent = TRUE;
        }
    }

    CopyConferenceID( &pConnectASN -> ConferenceID, 
        &connectMessage.conferenceID );

    if( pUserInfo->h323_uu_pdu.h245Tunneling )
    {
        //the remote endpoint has sent a tunneling proposal
        m_fh245Tunneling |= REMOTE_H245_TUNNELING;
    }

    // Free the PDU data.
    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU);
        
    H323DBG((DEBUG_LEVEL_TRACE, "ParseConnectASN exited: %p.", this ));
    return TRUE;
cleanup:

    FreeConnectASN( pConnectASN );

    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );
    return FALSE;
}


//!!always called in a lock
BOOL 
CH323Call::ParseAlertingASN(
                            IN BYTE *pEncodedBuf,
                            IN DWORD dwEncodedLength,
                            OUT Q931_ALERTING_ASN *pAlertingASN,
                            OUT DWORD* pdwH450APDUType 
                           )
{
    H323_UserInformation *pUserInfo;
    int iResult;
    DWORD dwInvokeID = 0;
    
    H323DBG((DEBUG_LEVEL_TRACE, "ParseAlertingASN entered: %p.", this ));

    memset( (PVOID) pAlertingASN, 0, sizeof(Q931_ALERTING_ASN) );

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    Alerting_UUIE & alertingMessage = 
        pUserInfo->h323_uu_pdu.h323_message_body.u.alerting;

    *pdwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, NULL ) )
        {
            goto cleanup;
        }
    }
    
    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present ) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        goto cleanup;
    }

    // validate that the PDU is H323 Alerting information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != alerting_chosen)
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.
    pAlertingASN->h245Addr.bMulticast = FALSE;

    pAlertingASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pAlertingASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pAlertingASN->fNonStandardDataPresent = TRUE;
    }

    if( alertingMessage.bit_mask & Alerting_UUIE_h245Address_present )
    {
        if( alertingMessage.h245Address.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pAlertingASN->h245Addr.nAddrType = H323_IP_BINARY;
        pAlertingASN->h245Addr.Addr.IP_Binary.wPort = 
            alertingMessage.h245Address.u.ipAddress.port;

        AddressReverseAndCopy( 
            &(pAlertingASN->h245Addr.Addr.IP_Binary.dwAddr),
            alertingMessage.h245Address.u.ipAddress.ip.value );
    }

    pAlertingASN -> fFastStartPresent = FALSE;
    if( (alertingMessage.bit_mask & Alerting_UUIE_fastStart_present) &&
        alertingMessage.fastStart )
    {
        pAlertingASN->pFastStart = CopyFastStart(
            (PSetup_UUIE_fastStart)alertingMessage.fastStart);

        if( pAlertingASN->pFastStart != NULL )
            pAlertingASN-> fFastStartPresent = TRUE;
    }

    if( pUserInfo->h323_uu_pdu.h245Tunneling )
    {
        m_fh245Tunneling |= REMOTE_H245_TUNNELING;
    }
    
    // Free the PDU data.
    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU);
        
    H323DBG((DEBUG_LEVEL_TRACE, "ParseAlertingASN exited: %p.", this ));
    return TRUE;
cleanup:

    FreeAlertingASN( pAlertingASN );

    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );
    return FALSE;
}


//!!aleways called in a lock
BOOL 
CH323Call::ParseProceedingASN(
    IN BYTE *pEncodedBuf,
    IN DWORD dwEncodedLength,
    OUT Q931_CALL_PROCEEDING_ASN *pProceedingASN,
    OUT DWORD* pdwH450APDUType 
    )
{
    H323_UserInformation *  pUserInfo;
    int                     iResult;
    DWORD                   dwInvokeID = 0;
    
    H323DBG((DEBUG_LEVEL_TRACE, "ParseProceedingASN entered: %p.", this ));

    memset( (PVOID) pProceedingASN, 0, sizeof(Q931_CALL_PROCEEDING_ASN) );

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    CallProceeding_UUIE & proceedingMessage = 
        pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding;

    *pdwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, NULL ) )
            goto cleanup;
    }

    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        goto cleanup;
    }

    // validate that the PDU is H323 Proceeding information.
    // validate that the PDU is H323 pCall Proceeding information.
    if( pUserInfo->h323_uu_pdu.h323_message_body.choice != callProceeding_chosen )
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.

    pProceedingASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pProceedingASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pProceedingASN->fNonStandardDataPresent = TRUE;
    }

    //copy the H245 address information
    pProceedingASN->fH245AddrPresent = FALSE;
    if( proceedingMessage.bit_mask & CallProceeding_UUIE_h245Address_present )
    {
        if( proceedingMessage.h245Address.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pProceedingASN->h245Addr.nAddrType = H323_IP_BINARY;
        pProceedingASN->h245Addr.Addr.IP_Binary.wPort = 
            proceedingMessage.h245Address.u.ipAddress.port;

        AddressReverseAndCopy( 
            &(pProceedingASN->h245Addr.Addr.IP_Binary.dwAddr),
            proceedingMessage.h245Address.u.ipAddress.ip.value );

        pProceedingASN->h245Addr.bMulticast = FALSE;
        pProceedingASN->fH245AddrPresent = TRUE;
    }


    pProceedingASN -> fFastStartPresent = FALSE;
    if( (proceedingMessage.bit_mask & CallProceeding_UUIE_fastStart_present) &&
        proceedingMessage.fastStart )
    {
        pProceedingASN->pFastStart = CopyFastStart(
            (PSetup_UUIE_fastStart)proceedingMessage.fastStart);

        if( pProceedingASN->pFastStart != NULL )
            pProceedingASN-> fFastStartPresent = TRUE;
    }

    //ignore the destinationInfo field.

    if( pUserInfo->h323_uu_pdu.h245Tunneling )
    {
        if( m_dwOrigin == LINECALLORIGIN_INBOUND )
        {
            //the msp has enabled tunneling in ProceedWithAnswer messsage
            m_fh245Tunneling |= LOCAL_H245_TUNNELING;
        }
        else
            //the remote endpoint has sent a tunneling proposal
            m_fh245Tunneling |= REMOTE_H245_TUNNELING;
    }

    // Free the PDU data.
    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );

    H323DBG((DEBUG_LEVEL_TRACE, "ParseProceedingASN exited: %p.", this ));
    return TRUE;

cleanup:

    FreeProceedingASN( pProceedingASN );

    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );

    return FALSE;
}


//!!always called in a lock
BOOL
CH323Call::ParseFacilityASN(
    IN BYTE *               pEncodedBuf,
    IN DWORD                dwEncodedLength,
    OUT Q931_FACILITY_ASN * pFacilityASN
    )
{
    H323_UserInformation *pUserInfo;
    int iResult;
    
    H323DBG((DEBUG_LEVEL_TRACE, "ParseFacilityASN entered: %p.", this ));

    ZeroMemory( (PVOID) pFacilityASN, sizeof(Q931_FACILITY_ASN) );

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if( ASN1_FAILED(iResult) || (pUserInfo == NULL) )
    {
        return FALSE;
    }

    // validate that the PDU is H323 facility information.
    if( pUserInfo->h323_uu_pdu.h323_message_body.choice == facility_chosen )
    {
        Facility_UUIE & facilityMessage =
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility;

        // validate that the PDU user-data uses ASN encoding.
        if( (pUserInfo->bit_mask & user_data_present) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
        {
            goto cleanup;
        }

        // make sure that the conference id is formed correctly.
        if( facilityMessage.conferenceID.length >
            sizeof(facilityMessage.conferenceID.value) )
        {
            //goto cleanup;
        }

        // parse the message contained in pUserInfo.
        pFacilityASN->fNonStandardDataPresent = FALSE;
        if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
        {
            if( !ParseNonStandardData( &pFacilityASN -> nonStandardData,
                &pUserInfo->h323_uu_pdu.nonStandardData ) )
            {
                goto cleanup;
            }

            pFacilityASN->fNonStandardDataPresent = TRUE;
        }

        pFacilityASN->fAlternativeAddressPresent = FALSE;
        if( facilityMessage.bit_mask & alternativeAddress_present )
        {
            if( facilityMessage.alternativeAddress.choice == ipAddress_chosen )
            {
                pFacilityASN->AlternativeAddr.nAddrType = H323_IP_BINARY;
                pFacilityASN->AlternativeAddr.Addr.IP_Binary.wPort = 
                    facilityMessage.alternativeAddress.u.ipAddress.port;
        
                AddressReverseAndCopy( 
                    &(pFacilityASN->AlternativeAddr.Addr.IP_Binary.dwAddr),
                    facilityMessage.alternativeAddress.u.ipAddress.ip.value );

                pFacilityASN->fAlternativeAddressPresent = TRUE;
            }
        }

        if( facilityMessage.bit_mask & alternativeAliasAddress_present )
        {
            if( !AliasAddrToAliasNames( &(pFacilityASN->pAlternativeAliasList),
                (PSetup_UUIE_sourceAddress)
                &(facilityMessage.alternativeAliasAddress) ) )
            {
                pFacilityASN -> pAlternativeAliasList = NULL;
                //goto cleanup;
            }
        }

        if( facilityMessage.bit_mask & Facility_UUIE_conferenceID_present )
        {
            CopyConferenceID( &pFacilityASN -> ConferenceID, 
                &facilityMessage.conferenceID );
            pFacilityASN -> ConferenceIDPresent = TRUE;
        }

        pFacilityASN->bReason = facilityMessage.reason.choice;
        
        pFacilityASN->fH245AddrPresent = FALSE;
        
        if( facilityMessage.bit_mask & Facility_UUIE_h245Address_present )
        {
            if( facilityMessage.h245Address.choice == ipAddress_chosen )
            {
                pFacilityASN->h245Addr.nAddrType = H323_IP_BINARY;
                pFacilityASN->h245Addr.Addr.IP_Binary.wPort = 
                     facilityMessage.h245Address.u.ipAddress.port;

                pFacilityASN->h245Addr.Addr.IP_Binary.dwAddr = 
                    ntohl( *((DWORD*)facilityMessage.h245Address.u.ipAddress.ip.value) );

                pFacilityASN->fH245AddrPresent = TRUE;
            }
        }
    }

    pFacilityASN->dwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        pFacilityASN->dwInvokeID = 0;

        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            &pFacilityASN->dwH450APDUType, &pFacilityASN->dwInvokeID, NULL  ) )
        {
            goto cleanup;
        }
    }
    
    if( pUserInfo->h323_uu_pdu.bit_mask & h245Control_present )
    {
        if( pUserInfo->h323_uu_pdu.h245Control != NULL )
        {
            pFacilityASN->pH245PDU.value = 
                new BYTE[pUserInfo->h323_uu_pdu.h245Control->value.length];

            if( pFacilityASN->pH245PDU.value != NULL )
            {
                CopyMemory( (PVOID)pFacilityASN->pH245PDU.value,
                    (PVOID)pUserInfo->h323_uu_pdu.h245Control->value.value,
                    pUserInfo->h323_uu_pdu.h245Control->value.length );
            }

            pFacilityASN->pH245PDU.length =
                pUserInfo->h323_uu_pdu.h245Control->value.length;
        }
    }

    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pUserInfo,
        H323_UserInformation_PDU );
        
    H323DBG((DEBUG_LEVEL_TRACE, "ParseFacilityASN exited: %p.", this ));
    return TRUE;

cleanup:

    if( pFacilityASN -> pAlternativeAliasList != NULL )
    {
        FreeAliasNames( pFacilityASN -> pAlternativeAliasList );
        pFacilityASN -> pAlternativeAliasList = NULL;
    }

    if( pFacilityASN->fNonStandardDataPresent != NULL )
    {
        delete pFacilityASN->nonStandardData.sData.pOctetString;
        pFacilityASN->nonStandardData.sData.pOctetString = NULL;
        pFacilityASN->fNonStandardDataPresent = NULL;
    }

    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );
    return FALSE;
}


//!!aleways called in a lock
BOOL
CH323Call::ParseSetupASN(
    IN BYTE *pEncodedBuf,
    IN DWORD dwEncodedLength,
    OUT Q931_SETUP_ASN *pSetupASN,
    OUT DWORD* pdwH450APDUType
    )
{
    H323_UserInformation *pUserInfo;
    HRESULT hr;
    int     iResult;
    DWORD dwInvokeID = 0;

    H323DBG((DEBUG_LEVEL_TRACE, "ParseSetupASN entered: %p.", this ));

    memset( (PVOID)pSetupASN, 0, sizeof(Q931_SETUP_ASN));

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    Setup_UUIE & setupMessage = pUserInfo->h323_uu_pdu.h323_message_body.u.setup;
    
    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        //log
        goto cleanup;
    }

    // validate that the PDU is H323 Setup information.
    if( pUserInfo->h323_uu_pdu.h323_message_body.choice != setup_chosen )
    {
        //log
        goto cleanup;
    }

    // make sure that the conference id is formed correctly.
    if (setupMessage.conferenceID.length >
            sizeof(setupMessage.conferenceID.value))
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.
    pSetupASN->sourceAddr.bMulticast = FALSE;
    pSetupASN->callerAddr.bMulticast = FALSE;
    pSetupASN->calleeDestAddr.bMulticast = FALSE;
    pSetupASN->calleeAddr.bMulticast = FALSE;

    // no validation of sourceInfo needed.

    //copy thevendor info
    pSetupASN->EndpointType.pVendorInfo = NULL;
    if( setupMessage.sourceInfo.bit_mask & vendor_present )
    {
        if( !ParseVendorInfo( &pSetupASN->VendorInfo, 
            &setupMessage.sourceInfo.vendor) )
        {
            goto cleanup;
        }
                
        pSetupASN->EndpointType.pVendorInfo = &(pSetupASN->VendorInfo);
    }

    pSetupASN->EndpointType.bIsTerminal = FALSE;
    if( setupMessage.sourceInfo.bit_mask & terminal_present )
    {
        pSetupASN->EndpointType.bIsTerminal = TRUE;
    }

    pSetupASN->EndpointType.bIsGateway = FALSE;
    if( setupMessage.sourceInfo.bit_mask & gateway_present )
    {
        pSetupASN->EndpointType.bIsGateway = TRUE;
    }

    pSetupASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pSetupASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pSetupASN->fNonStandardDataPresent = TRUE;
    }

    // parse the sourceAddress aliases here...
    if( setupMessage.bit_mask & sourceAddress_present )
    {
        if( !AliasAddrToAliasNames( &(pSetupASN->pCallerAliasList),
            setupMessage.sourceAddress ) )
        {
            pSetupASN->pCallerAliasList = NULL;
            //goto cleanup;
        }
    }

    // parse the destinationAddress aliases here...
    if( (setupMessage.bit_mask & destinationAddress_present) && 
        setupMessage.destinationAddress )
    {
        if( !AliasAddrToAliasNames( &(pSetupASN->pCalleeAliasList),
            (PSetup_UUIE_sourceAddress)setupMessage.destinationAddress) )
        {
            pSetupASN->pCalleeAliasList = NULL;
            //goto cleanup;
        }
    }

    // parse the destExtraCallInfo aliases here...
    if( (setupMessage.bit_mask & Setup_UUIE_destExtraCallInfo_present) &&
        setupMessage.destExtraCallInfo )
    {
        if( !AliasAddrToAliasNames(&(pSetupASN->pExtraAliasList),
            (PSetup_UUIE_sourceAddress)setupMessage.destExtraCallInfo) )
        {
            pSetupASN->pExtraAliasList = NULL;
            //goto cleanup;
        }
    }

    // parse the remoteExtensionAddress aliases here...
    if( setupMessage.bit_mask & Setup_UUIE_remoteExtensionAddress_present )
    {
        pSetupASN->pExtensionAliasItem = new H323_ALIASITEM;

        if( pSetupASN->pExtensionAliasItem == NULL )
        {
            goto cleanup;
        }

        hr = AliasAddrToAliasItem(pSetupASN->pExtensionAliasItem,
            &(setupMessage.remoteExtensionAddress));

        if( hr == E_OUTOFMEMORY )
        {
            goto cleanup;
        }
    }

    pSetupASN -> fCalleeDestAddrPresent = FALSE;
    if( setupMessage.bit_mask & Setup_UUIE_destCallSignalAddress_present )
    {
        if( setupMessage.destCallSignalAddress.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pSetupASN->calleeDestAddr.nAddrType = H323_IP_BINARY;
        pSetupASN->calleeDestAddr.Addr.IP_Binary.wPort = 
            setupMessage.destCallSignalAddress.u.ipAddress.port;
        
        AddressReverseAndCopy( 
            &(pSetupASN->calleeDestAddr.Addr.IP_Binary.dwAddr),
            setupMessage.destCallSignalAddress.u.ipAddress.ip.value );
        
        pSetupASN -> fCalleeDestAddrPresent = TRUE;
    }

    pSetupASN->fSourceAddrPresent = FALSE;
    if( setupMessage.bit_mask & sourceCallSignalAddress_present )
    {
        if( setupMessage.sourceCallSignalAddress.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pSetupASN->sourceAddr.nAddrType = H323_IP_BINARY;
        pSetupASN->sourceAddr.Addr.IP_Binary.wPort = 
            setupMessage.sourceCallSignalAddress.u.ipAddress.port;

        pSetupASN->sourceAddr.Addr.IP_Binary.dwAddr = ntohl( *((DWORD*)
            setupMessage.sourceCallSignalAddress.u.ipAddress.ip.value) );

        pSetupASN->fSourceAddrPresent = TRUE;
    }

    pSetupASN->bCallerIsMC = setupMessage.activeMC;

    pSetupASN -> fFastStartPresent = FALSE;
    if( (setupMessage.bit_mask & Setup_UUIE_fastStart_present) &&
        setupMessage.fastStart )
    {
        pSetupASN->pFastStart = CopyFastStart( setupMessage.fastStart );

        if( pSetupASN->pFastStart != NULL )
        {
            pSetupASN -> fFastStartPresent = TRUE;
        }
    }

    CopyConferenceID (&pSetupASN -> ConferenceID, &setupMessage.conferenceID);

    //copy the call identifier
    pSetupASN -> fCallIdentifierPresent = FALSE;
    if( setupMessage.bit_mask & Setup_UUIE_callIdentifier_present )
    {
       pSetupASN -> fCallIdentifierPresent = TRUE;
       CopyMemory( (PVOID)&(pSetupASN->callIdentifier),
                   setupMessage.callIdentifier.guid.value,
                   sizeof(GUID) );
    }

    if( pUserInfo->h323_uu_pdu.h245Tunneling )
    {
        if( m_dwOrigin == LINECALLORIGIN_INBOUND )
        {
            //the remote endpoint has sent a tunneling proposal
            m_fh245Tunneling |= REMOTE_H245_TUNNELING;
        }
        else
        {
            //the msp has enabled tunneling in ReadyToInitiate messsage
            m_fh245Tunneling |= LOCAL_H245_TUNNELING;
        }
    }

    pSetupASN->wGoal = (WORD)setupMessage.conferenceGoal.choice;
    pSetupASN->wCallType = setupMessage.callType.choice;

    *pdwH450APDUType  = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, pSetupASN ) )
        {
            goto cleanup;
        }
    }

    // Free the PDU data.
    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pUserInfo, 
                      H323_UserInformation_PDU );
        
    H323DBG(( DEBUG_LEVEL_TRACE, "ParseSetupASN exited: %p.", this ));
    return TRUE;

cleanup:
    FreeSetupASN( pSetupASN );

    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU);

    return FALSE;
}


//-----------------------------------------------------------------------------
        //GLOBAL CALLBACK FUNCTIONS CALLED BY THREAD POOL
//-----------------------------------------------------------------------------

// static

void 
NTAPI CH323Call::IoCompletionCallback(
    IN  DWORD           dwStatus,
    IN  DWORD           dwBytesTransferred,
    IN  OVERLAPPED *    pOverlapped
    )
{
    CALL_OVERLAPPED *pCallOverlapped;
    CH323Call*      pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "CH323Call-IoCompletionCallback entered." ));

    _ASSERTE (pOverlapped);
    pCallOverlapped = CONTAINING_RECORD( pOverlapped, CALL_OVERLAPPED, 
        Overlapped );

    pCall = pCallOverlapped -> pCall;

    switch (pCallOverlapped -> Type)
    {
    case OVERLAPPED_TYPE_SEND:
        
        pCall -> OnWriteComplete( dwStatus,
            static_cast<CALL_SEND_CONTEXT *>(pCallOverlapped) );
        break;

    case OVERLAPPED_TYPE_RECV:

        pCallOverlapped -> BytesTransferred = dwBytesTransferred;
        pCall -> OnReadComplete( dwStatus, 
            static_cast<CALL_RECV_CONTEXT *>(pCallOverlapped) );
        break;

    default:
        _ASSERTE(FALSE);
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CH323Call-IoCompletionCallback exited." ));
}


void 
CH323Call::OnWriteComplete(
    IN DWORD dwStatus,
    IN CALL_SEND_CONTEXT * pSendContext
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnWriteComplete entered:%p.",this ));

    Lock();
    
    _ASSERTE( m_IoRefCount != 0 );            
    m_IoRefCount--;
    H323DBG((DEBUG_LEVEL_TRACE, "WriteComplete:m_IoRefCount: %d:%p.",
            m_IoRefCount, this ));
     
    if( m_dwFlags & CALLOBJECT_SHUTDOWN )
    {
        if( m_IoRefCount == 0 )
        {
            QueueTAPICallRequest( TSPI_DELETE_CALL, NULL );
            H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", this ));
        }
    }
    else if( dwStatus == ERROR_SUCCESS )
    {
        if( IsInList( &m_sendBufList, &pSendContext->ListEntry ) )
        {
            RemoveEntryList( &pSendContext->ListEntry );
            delete pSendContext->WSABuf.buf;
            delete pSendContext;
        }
    }
    
    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "OnWriteComplete exited:%p.",this ));
}


void
CH323Call::OnReadComplete(
    IN  DWORD dwStatus,
    IN  CALL_RECV_CONTEXT * pRecvContext )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnReadComplete entered:%p.",this ));

    Lock();

    _ASSERTE( m_IoRefCount != 0 );
    m_IoRefCount --;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "RecvBuffer:m_IoRefCount:%d:%p.",
        m_IoRefCount, this ));
    
    if( m_dwFlags & CALLOBJECT_SHUTDOWN )
    {
        if( m_IoRefCount == 0 )
        {
            QueueTAPICallRequest( TSPI_DELETE_CALL, NULL );
            H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", this ));
        }
    }
    else
    {
        if( dwStatus == ERROR_SUCCESS )
        {
            _ASSERTE( m_pRecvBuffer == pRecvContext );
    
            if( pRecvContext->BytesTransferred == 0 )
            {
                CloseCall( 0 );
                H323DBG((DEBUG_LEVEL_TRACE, "0 bytes recvd:%p.", this ));
            }
            else
            {
                ReadEvent( pRecvContext->BytesTransferred );
            }
        }
    }
    
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "OnReadComplete exited:%p.",this ));
}


// static
void
NTAPI CH323Call::SetupSentTimerCallback( 
    IN PVOID Parameter1, 
    IN BOOLEAN bTimer 
    )
{
    PH323_CALL pCall = NULL;

    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "Q931 setup expired event recvd." ));

    pCall=g_pH323Line -> FindH323CallAndLock((HDRVCALL) Parameter1);
    if( pCall != NULL )
    {
        pCall -> SetupSentTimerExpired();
        pCall -> Unlock();
    }
}


// static
void
NTAPI CH323Call::CheckRestrictionTimerCallback( 
                                                IN PVOID Parameter1,
                                                IN BOOLEAN bTimer 
                                              )
{
    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "CheckRestrictionTimerCallback entered." ));
    if(!QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            (HDRVCALL) Parameter1, 
            NULL,
            LINEDISCONNECTMODE_NOANSWER,
            NULL) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post H323 close event." ));
    }
            
    H323DBG(( DEBUG_LEVEL_TRACE, "CheckRestrictionTimerCallback exited." ));
}

// static
void
NTAPI CH323Call::CallReroutingTimerCallback( 
    IN PVOID Parameter1, 
    IN BOOLEAN bTimer 
    )
{
    //If the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "CallReroutingTimerCallback entered." ));

    if(!QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            (HDRVCALL) Parameter1, 
            NULL, 
            LINEDISCONNECTMODE_NOANSWER,
            NULL) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post H323 close event." ));
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "CallReroutingTimerCallback exited." ));
}



//-----------------------------------------------------------------------------
        //CALL DIVERSION (H450.3) ENCODE/DECODE ROUTINES
//-----------------------------------------------------------------------------

BOOL
CH323Call::HandleH450APDU(
    IN PH323_UU_PDU_h4501SupplementaryService pH450APDU,
    IN DWORD* pdwH450APDUType,
    OUT DWORD* pdwInvokeID,
    IN Q931_SETUP_ASN* pSetupASN
    )
{
    BOOL retVal = TRUE;
    H4501SupplementaryService * pH450APDUStruct = NULL;
    ServiceApdus_rosApdus * pROSApdu = NULL;
    int iResult;
    BYTE pEncodedArg[H450_ENCODED_ARG_LEN];
    DWORD  dwEncodedArgLen;
    DWORD  dwOpcode;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleH450APDU entered:%p.", this ));

    //right now assuming that only one APDU is passed at a time
    iResult = DecodeH450ASN( (void **) &pH450APDUStruct,
                         H4501SupplementaryService_PDU,
                         pH450APDU->value.value,
                         pH450APDU->value.length );

    if( ASN1_FAILED(iResult) || (pH450APDUStruct == NULL) )
    {
        return FALSE;
    }

    if( pH450APDUStruct->serviceApdu.choice != rosApdus_chosen )
    {
        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );

        return FALSE;
    }

    pROSApdu = pH450APDUStruct->serviceApdu.u.rosApdus;

    switch( pROSApdu->value.choice )
    {
    case H4503ROS_invoke_chosen:

        if( (pROSApdu->value.u.invoke.opcode.choice != local_chosen) ||
            (pROSApdu->value.u.invoke.argument.length > H450_ENCODED_ARG_LEN) )
        {
            ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
                H4501SupplementaryService_PDU );
            return FALSE;
        }

        *pdwInvokeID = pROSApdu->value.u.invoke.invokeId;
        dwEncodedArgLen = pROSApdu->value.u.invoke.argument.length;
        
        CopyMemory( (PVOID)pEncodedArg, 
            (PVOID)pROSApdu->value.u.invoke.argument.value,
            dwEncodedArgLen );
        dwOpcode = pROSApdu->value.u.invoke.opcode.u.local;

        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
                H4501SupplementaryService_PDU );

        *pdwH450APDUType = dwOpcode;
        switch( dwOpcode )
        {
        case CALLREROUTING_OPCODE:

            retVal = HandleCallRerouting( pEncodedArg, dwEncodedArgLen );
            break;

        case DIVERTINGLEGINFO1_OPCODE:
            
            retVal = HandleDiversionLegInfo1( pEncodedArg, dwEncodedArgLen );
            break;

        case DIVERTINGLEGINFO2_OPCODE:

            retVal = HandleDiversionLegInfo2( pEncodedArg, dwEncodedArgLen );
            break;

        case DIVERTINGLEGINFO3_OPCODE:
            
            //Don't bail out even if this function fails.
            HandleDiversionLegInfo3( pEncodedArg, dwEncodedArgLen );
            break;

        case CHECKRESTRICTION_OPCODE:

            if( pSetupASN == NULL )
            {
                retVal = FALSE;
            }
            else
            {
                retVal = HandleCheckRestriction( pEncodedArg, dwEncodedArgLen,
                    pSetupASN );
            }

            if( retVal )
            {
                retVal = SendQ931Message( *pdwInvokeID, 0, 0, 
                    CONNECTMESSAGETYPE,
                    H450_RETURNRESULT|CHECKRESTRICTION_OPCODE );
            }
            break;

        case CTIDENTIFY_OPCODE:

            retVal = HandleCTIdentify( *pdwInvokeID );            
            m_dwInvokeID = *pdwInvokeID;
            break;

        case CTINITIATE_OPCODE:

            retVal = HandleCTInitiate( pEncodedArg, dwEncodedArgLen );
            m_dwInvokeID = *pdwInvokeID;
            break;

        case CTSETUP_OPCODE:

            retVal = HandleCTSetup( pEncodedArg, dwEncodedArgLen );
            m_dwInvokeID = *pdwInvokeID;
            break;

        case HOLDNOTIFIC_OPCODE:

            //local hold request from the remote endpoint
            if( m_dwCallState != LINECALLSTATE_ONHOLD )
            {
                SendMSPMessage( SP_MSG_Hold, 0, 1, NULL );
                ChangeCallState( LINECALLSTATE_ONHOLD, 0 );
            }
            break;

        case RETRIEVENOTIFIC_OPCODE:

            //local retrieve request from the remote endpoint
            if( (m_dwCallState == LINECALLSTATE_ONHOLD) &&
                !(m_dwFlags & TSPI_CALL_LOCAL_HOLD) )
            {
                SendMSPMessage( SP_MSG_Hold, 0, 0, NULL );
                ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
            }
            break;

        case REMOTEHOLD_OPCODE:

            //remote hold request from remote endpoint
            if( m_dwCallState != LINECALLSTATE_ONHOLD )
            {
                SendMSPMessage( SP_MSG_Hold, 0, 1, NULL );
                ChangeCallState( LINECALLSTATE_ONHOLD, 0 );

                retVal = SendQ931Message( *pdwInvokeID, 0, 0,
                    FACILITYMESSAGETYPE,
                    REMOTEHOLD_OPCODE| H450_RETURNRESULT );
            }
            break;

        case REMOTERETRIEVE_OPCODE:

            //remote retrieve request from remote endpoint
            if( m_dwCallState == LINECALLSTATE_ONHOLD )
            {
                SendMSPMessage( SP_MSG_Hold, 0, 0, NULL );
                ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
    
                retVal = SendQ931Message( *pdwInvokeID, 0, 0, 
                    FACILITYMESSAGETYPE,
                    REMOTERETRIEVE_OPCODE| H450_RETURNRESULT );
            }
            break;

        default:
            _ASSERTE( 0 );
            return FALSE;
        }

        break;
    
    case H4503ROS_returnResult_chosen:
        
        *pdwH450APDUType = H4503_DUMMYTYPERETURNRESULT_APDU;
        *pdwInvokeID = 
            pH450APDUStruct->serviceApdu.u.rosApdus->value.u.returnResult.invokeId;
        retVal = HandleReturnResultDummyType( pH450APDUStruct );

        // Free the PDU data.
        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );

        break;

    case H4503ROS_returnError_chosen:
        
        *pdwH450APDUType = H4503_RETURNERROR_APDU;
        *pdwInvokeID = 
            pH450APDUStruct->serviceApdu.u.rosApdus->value.u.returnError.invokeId;
        retVal = HandleReturnError( pH450APDUStruct );
        
        // Free the PDU data.
        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );

        break;

    case reject_chosen:
        
        *pdwH450APDUType = H4503_REJECT_APDU;
        *pdwInvokeID = 
            pH450APDUStruct->serviceApdu.u.rosApdus->value.u.reject.invokeId;
        retVal = HandleReject( pH450APDUStruct );
        
        // Free the PDU data.
        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );
        break;

    default:
        _ASSERTE( 0 );

        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );
        return FALSE;
        break;
    }

    if( retVal == FALSE )
    {
        SendQ931Message( *pdwInvokeID,
                         0,
                         0,
                         RELEASECOMPLMESSAGETYPE,
                         H450_REJECT );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleH450APDU exited:%p.", this ));

    return retVal;
}


BOOL 
CH323Call::HandleReturnError(
                             IN H4501SupplementaryService * pH450APDUStruct
                            )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReturnError entered:%p.", this ));

    ReturnError * pReturnError = 
        &(pH450APDUStruct->serviceApdu.u.rosApdus->value.u.returnError);

    if( IsValidInvokeID( pReturnError->invokeId ) == FALSE )
    {
        //ignore APDU
        return TRUE;
    }

    CloseCall( 0 );
        
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReturnError exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::HandleReject( 
                        IN H4501SupplementaryService * pH450APDUStruct 
                       )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReject entered:%p.", this ));

    Reject * pReject = 
        &(pH450APDUStruct->serviceApdu.u.rosApdus->value.u.reject);
    
    if( IsValidInvokeID( pReject->invokeId ) == FALSE )
    {
        //ignore the APDU
        return TRUE;
    }
    
    CloseCall( 0 );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReject exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::HandleReturnResultDummyType( 
    IN H4501SupplementaryService * pH450APDUStruct
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReturnResultDummyType entered:%p.",
        this ));

    ReturnResult* dummyResult =
        &(pH450APDUStruct->serviceApdu.u.rosApdus->value.u.returnResult);

    if( dummyResult->bit_mask & result_present )
    {
        if( dummyResult->result.opcode.choice != local_chosen )
        {
            return FALSE;
        }

        switch( dummyResult->result.opcode.u.local )
        {
        case CHECKRESTRICTION_OPCODE:
        
            //forwarding has been enabled. inform the user
            if( !EnableCallForwarding() )
            {
                return FALSE;
            }

            //close the call
            CloseCall( 0 );

            break;

        case CALLREROUTING_OPCODE:

            //call has been rerouted. log the info or inform the user
            m_dwCallDiversionState = H4503_CALLREROUTING_RRSUCC;
            _ASSERTE( m_hCallReroutingTimer );
            if( m_hCallReroutingTimer != NULL )
            {
                DeleteTimerQueueTimer( H323TimerQueue, 
                    m_hCallReroutingTimer, NULL );
                
                m_hCallReroutingTimer = NULL;
            }

            break;

        case CTIDENTIFY_OPCODE:

            //call tranfer has been accepted by transfered-to endpoint
            m_dwCallDiversionState = H4502_CIIDENTIFY_RRSUCC;
        
            _ASSERTE( m_hCTIdentifyTimer );
            if( m_hCTIdentifyTimer != NULL )
            {
                DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyTimer, NULL );
                m_hCTIdentifyTimer = NULL;
            }

            return HandleCTIdentifyReturnResult( dummyResult->result.result.value,
                dummyResult->result.result.length );

            break;

        case CTINITIATE_OPCODE:

            _ASSERTE( m_hCTInitiateTimer );
            if( m_hCTInitiateTimer != NULL )
            {
                DeleteTimerQueueTimer( H323TimerQueue, m_hCTInitiateTimer, NULL );
                m_hCTInitiateTimer = NULL;
            }
            break;

        case CTSETUP_OPCODE:
        case REMOTEHOLD_OPCODE:
        case REMOTERETRIEVE_OPCODE:
            //no processing required
            break;

        default:
            
            H323DBG(( DEBUG_LEVEL_ERROR, "wrong opcode.",
                dummyResult->result.opcode.u.local ));
            break;
        }
    }
    else if( IsValidInvokeID( dummyResult->invokeId ) == FALSE )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReturnResultDummyType exited:%p.",
        this ));

    return TRUE;
}


BOOL
CH323Call::EnableCallForwarding()
{
    m_dwCallDiversionState = H4503_CHECKRESTRICTION_SUCC;

    if( m_pCallForwardParams != NULL )
    {
        g_pH323Line->SetCallForwardParams( m_pCallForwardParams );
        m_pCallForwardParams = NULL;
    }
    else if( m_pForwardAddress != NULL )
    {
        if( !g_pH323Line->SetCallForwardParams( m_pForwardAddress ) )
        {
            return FALSE;
        }

        m_pForwardAddress = NULL;
    }

    //_ASSERTE( m_hCheckRestrictionTimer );

    //stop the timer
    if( m_hCheckRestrictionTimer )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCheckRestrictionTimer, 
            NULL );
        m_hCheckRestrictionTimer = NULL;
    }

    //inform the user about change in line forward state
    (*g_pfnLineEventProc)(
        g_pH323Line->m_htLine,
        (HTAPICALL)NULL,
        (DWORD)LINE_ADDRESSSTATE,
        (DWORD)LINEADDRESSSTATE_FORWARD,
        (DWORD)LINEADDRESSSTATE_FORWARD,
        (DWORD)0
        );

    return TRUE;
}


BOOL
CH323Call::HandleCTIdentifyReturnResult(
                                 IN BYTE * pEncodeArg,
                                 IN DWORD dwEncodedArgLen
                                 )
{
    PH323_CALL  pCall = NULL;
    CTIdentifyRes * pCTIdentifyRes;
    int iResult;

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTIdentifyReturnResult entered:%p.", this ));

    if( (pEncodeArg == NULL) || (dwEncodedArgLen==0) )
    {
        return FALSE;
    }

    iResult = DecodeH450ASN( (void **) &pCTIdentifyRes,
        CTIdentifyRes_PDU, pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (pCTIdentifyRes == NULL) )
    {
        return FALSE;
    }

    //send a CTInitiate message on the primary call
    if( !QueueSuppServiceWorkItem( SEND_CTINITIATE_MESSAGE, m_hdRelatedCall,
        (ULONG_PTR)pCTIdentifyRes ))
    {
        //close the consultation call.
        CloseCall( 0 );
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTIdentifyReturnResult exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::HandleCTIdentify( 
                            IN DWORD dwInvokeID 
                           )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTIdentify entered:%p.", this ));
    
    BOOL retVal = TRUE;

    //send the return result for CTIdentify
    retVal = SendQ931Message( dwInvokeID, 0, 0, FACILITYMESSAGETYPE, 
            H450_RETURNRESULT|CTIDENTIFY_OPCODE );
    
    m_dwCallType |= CALLTYPE_TRANSFERED2_CONSULT;
        
    //start the timer for CTIdenity message
    if( retVal )
    {
        retVal = CreateTimerQueueTimer(
            &m_hCTIdentifyRRTimer,
            H323TimerQueue,
            CH323Call::CTIdentifyRRExpiredCallback,
            (PVOID)m_hdCall,
            CTIDENTIFYRR_SENT_TIMEOUT, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTIdentify exited:%p.", this ));
    return retVal;
}


BOOL
CH323Call::HandleCTInitiate(
                             IN BYTE * pEncodeArg,
                             IN DWORD dwEncodedArgLen
                           )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTInitiate entered:%p.", this ));

    CTInitiateArg * pCTInitiateArg;
    
    int iResult = DecodeH450ASN( (void **) &pCTInitiateArg,
                         CTInitiateArg_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (pCTInitiateArg == NULL) )
    {
        return FALSE;
    }

    //argument.callIdentity
    CopyMemory( (PVOID)m_pCTCallIdentity, pCTInitiateArg->callIdentity,
        sizeof(m_pCTCallIdentity) );

    //argument.reroutingNumber
    if( !AliasAddrToAliasNames( &m_pTransferedToAlias,
        (PSetup_UUIE_sourceAddress)
        pCTInitiateArg->reroutingNumber.destinationAddress ) )
    {
        goto cleanup;
    }

    m_dwCallType |= CALLTYPE_TRANSFERED_PRIMARY;
    m_dwCallDiversionState = H4502_CTINITIATE_RECV;

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCTInitiateArg,
        CTInitiateArg_PDU );

    //queue an event for creating a new call
    if( !QueueSuppServiceWorkItem( TSPI_DIAL_TRNASFEREDCALL, m_hdCall,
        (ULONG_PTR)m_pTransferedToAlias ))
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "could not post dial transfer event." ));
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTInitiate exited:%p.", this ));
    return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCTInitiateArg,
        CTInitiateArg_PDU );

    return FALSE;
}


//!!always called in a lock
BOOL
CH323Call::HandleCTSetup(
    IN BYTE * pEncodeArg,
	IN DWORD dwEncodedArgLen
	)
{
	PH323_CALL	pCall = NULL;
	WORD		wRelatedCallRef = 0;
	int 		iCTCallID;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTSetup entered:%p.", this ));

	CTSetupArg * pCTSetupArg;
	
	int iResult = DecodeH450ASN( (void **) &pCTSetupArg,
		CTSetupArg_PDU, pEncodeArg, dwEncodedArgLen );

	if( ASN1_FAILED(iResult) || (pCTSetupArg == NULL) )
	{
		return FALSE;
	}

	m_dwCallType |= CALLTYPE_TRANSFEREDDEST;
	m_dwCallDiversionState = H4502_CTSETUP_RECV;

	iCTCallID = atoi( pCTSetupArg->callIdentity );

	if( iCTCallID != 0 )
	{
		m_hdRelatedCall = g_pH323Line -> GetCallFromCTCallIdentity( iCTCallID );

		if( m_hdRelatedCall )
		{
			if( !QueueSuppServiceWorkItem( STOP_CTIDENTIFYRR_TIMER, 
				m_hdRelatedCall, (ULONG_PTR)m_hdCall ))
			{
				m_hdRelatedCall = NULL;
			}
		}
	}
	
	ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCTSetupArg,
		CTSetupArg_PDU );

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTSEtup exited:%p.", this ));
	return TRUE;
}


BOOL
CH323Call::HandleCheckRestriction(
								 IN BYTE * pEncodeArg,
								 IN DWORD dwEncodedArgLen,
								 IN Q931_SETUP_ASN* pSetupASN
								 )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCheckRestriction entered:%p.", this ));

	CheckRestrictionArgument * pCheckRestriction;
	
	int iResult = DecodeH450ASN( (void **) &pCheckRestriction,
						 CheckRestrictionArgument_PDU,
						 pEncodeArg, dwEncodedArgLen );

	if( ASN1_FAILED(iResult) || (pCheckRestriction == NULL) )
	{
		return FALSE;
	}

	if( pSetupASN->pCalleeAliasList != NULL )
	{
		FreeAliasNames( pSetupASN->pCalleeAliasList );
		pSetupASN->pCalleeAliasList = NULL;
	}

	if( !AliasAddrToAliasNames( &(pSetupASN->pCalleeAliasList),
		(PSetup_UUIE_sourceAddress)pCheckRestriction->divertedToNr.destinationAddress ) )
	{
		pSetupASN->pCalleeAliasList = NULL;
		goto cleanup;
	}

	if( pSetupASN->pCallerAliasList != NULL )
	{
		FreeAliasNames( pSetupASN->pCallerAliasList );
		pSetupASN->pCallerAliasList = NULL;
	}

	if( !AliasAddrToAliasNames( &(pSetupASN->pCallerAliasList),
		(PSetup_UUIE_sourceAddress)
		pCheckRestriction->servedUserNr.destinationAddress ) )
	{
		pSetupASN->pCallerAliasList = NULL;
		goto cleanup;
	}

	m_dwCallType |= CALLTYPE_FORWARDCONSULT;

	if( !InitializeIncomingCall( pSetupASN, CALLTYPE_FORWARDCONSULT, 0 ) )
	{
		goto cleanup;
	}

	FreeSetupASN( pSetupASN );
	m_dwStateMachine = Q931_SETUP_RECVD;
	m_dwCallDiversionState = H4503_CHECKRESTRICTION_RECV;

	ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCheckRestriction,
        CheckRestrictionArgument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCheckRestriction exited:%p.", this ));
        return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCheckRestriction,
        CheckRestrictionArgument_PDU );

    return FALSE;
}


BOOL
CH323Call::HandleDiversionLegInfo1(
                                IN BYTE * pEncodeArg,
                                IN DWORD dwEncodedArgLen
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo1 entered:%p.", this ));

    DivertingLegInformation1Argument * plegInfo1Invoke;
    
    int iResult = DecodeH450ASN( (void **) &plegInfo1Invoke,
                         DivertingLegInformation1Argument_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (plegInfo1Invoke == NULL) )
    {
        return FALSE;
    }

    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;

        if( m_pCallReroutingInfo == NULL )
        {
            return FALSE;
        }

        ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }
    
    m_pCallReroutingInfo->diversionReason = plegInfo1Invoke->diversionReason;

    m_pCallReroutingInfo->fPresentAllow = plegInfo1Invoke->subscriptionOption;
    
    //argument.divertedToNr
    if( m_pCallReroutingInfo->divertedToNrAlias != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
        m_pCallReroutingInfo->divertedToNrAlias = NULL;
    }

    if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->divertedToNrAlias),
        (PSetup_UUIE_sourceAddress)
        (plegInfo1Invoke->nominatedNr.destinationAddress) ) )
    {
        goto cleanup;
    }

    m_dwCallType |= CALLTYPE_DIVERTEDSRC_NOROUTING;
    m_dwCallDiversionState = H4503_DIVERSIONLEG1_RECVD;
        
    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo1Invoke,
        DivertingLegInformation1Argument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo1 exited:%p.", this ));
    return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo1Invoke,
        DivertingLegInformation1Argument_PDU );

    FreeCallReroutingInfo();
    return FALSE;
}


BOOL
CH323Call::HandleDiversionLegInfo2(
                                IN BYTE * pEncodeArg,
                                IN DWORD dwEncodedArgLen
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo2 entered:%p.", this ));

    DivertingLegInformation2Argument * plegInfo2Invoke;
    
    int iResult = DecodeH450ASN( (void **) &plegInfo2Invoke,
                         DivertingLegInformation2Argument_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (plegInfo2Invoke == NULL) )
    {
        return FALSE;
    }

    _ASSERTE(!m_pCallReroutingInfo);

    m_pCallReroutingInfo = new CALLREROUTINGINFO;
    if( m_pCallReroutingInfo == NULL )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "memory failure." ));
        goto cleanup;
    }
    ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    
    //argument.diversionCounter
    m_pCallReroutingInfo->diversionCounter = 
        plegInfo2Invoke->diversionCounter;
    
    //argument.diversionReason
    m_pCallReroutingInfo->diversionReason = plegInfo2Invoke->diversionReason;

    if( m_pCallReroutingInfo->divertingNrAlias != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertingNrAlias );
            m_pCallReroutingInfo->divertingNrAlias = NULL;
    }

    if( (plegInfo2Invoke->bit_mask & divertingNr_present ) &&
        plegInfo2Invoke->divertingNr.destinationAddress )
    {
        //argument.divertingNr
        if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->divertingNrAlias),
            (PSetup_UUIE_sourceAddress)
            (plegInfo2Invoke->divertingNr.destinationAddress) ) )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "no divertingnr alias." ));
            //goto cleanup;
        }
    }

    //argument.originalCalledNr
    if( (plegInfo2Invoke->bit_mask & 
        DivertingLegInformation2Argument_originalCalledNr_present ) &&
        plegInfo2Invoke->originalCalledNr.destinationAddress )
    {
        if( m_pCallReroutingInfo->originalCalledNr != NULL )
        {
            FreeAliasNames( m_pCallReroutingInfo->originalCalledNr );
            m_pCallReroutingInfo->originalCalledNr = NULL;
        }

        if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->originalCalledNr),
            (PSetup_UUIE_sourceAddress)
            (plegInfo2Invoke->originalCalledNr.destinationAddress)) )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "no originalcalled alias." ));
            //goto cleanup;
        }
    }

    m_dwCallType |= CALLTYPE_DIVERTEDDEST;
    m_dwCallDiversionState = H4503_DIVERSIONLEG2_RECVD;
        
    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo2Invoke,
        DivertingLegInformation2Argument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo2 exited:%p.", this ));
    return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo2Invoke,
        DivertingLegInformation2Argument_PDU );

    FreeCallReroutingInfo();
    return FALSE;

}


void 
CH323Call::FreeCallReroutingInfo(void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeCallReroutingInfo entered:%p.", this ));
    
    if( m_pCallReroutingInfo != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertingNrAlias ); 
        FreeAliasNames( m_pCallReroutingInfo->originalCalledNr );
        FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
        FreeAliasNames( m_pCallReroutingInfo->diversionNrAlias );

        delete m_pCallReroutingInfo;
        m_pCallReroutingInfo = NULL;
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeCallReroutingInfo exited:%p.", this ));
}
                                

BOOL
CH323Call::HandleDiversionLegInfo3(
                                IN BYTE * pEncodeArg,
                                IN DWORD dwEncodedArgLen
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo3 entered:%p.", this ));

    DivertingLegInformation3Argument * plegInfo3Invoke;
    
    int iResult = DecodeH450ASN( (void **) &plegInfo3Invoke,
                         DivertingLegInformation3Argument_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (plegInfo3Invoke == NULL) )
    {
        return FALSE;
    }

    _ASSERTE(m_pCallReroutingInfo);

    m_pCallReroutingInfo-> fPresentAllow = 
        plegInfo3Invoke->presentationAllowedIndicator;

    if( m_pCallReroutingInfo->diversionNrAlias )
    {
        FreeAliasNames( m_pCallReroutingInfo->diversionNrAlias );
        m_pCallReroutingInfo->diversionNrAlias = NULL;
    }

    //argument.redirectionNr
    if( (plegInfo3Invoke->bit_mask & redirectionNr_present ) &&
        plegInfo3Invoke->redirectionNr.destinationAddress )
    {
        if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->diversionNrAlias),
            (PSetup_UUIE_sourceAddress)
            (plegInfo3Invoke->redirectionNr.destinationAddress) ) )
        {
            //goto cleanup;
        }
    }

    _ASSERTE( (m_dwCallType & CALLTYPE_DIVERTEDSRC ) ||
              (m_dwCallType & CALLTYPE_DIVERTEDSRC_NOROUTING ) );
    m_dwCallDiversionState = H4503_DIVERSIONLEG3_RECVD;

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo3Invoke,
        DivertingLegInformation3Argument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo3 exited:%p.", this ));
    return TRUE;

/*cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo3Invoke,
        DivertingLegInformation3Argument_PDU );

    FreeCallReroutingInfo();
    return FALSE;
*/
}


BOOL
CH323Call::HandleCallRerouting(
                                IN BYTE * pEncodeArg,
                                IN DWORD dwEncodedArgLen
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCallRerouting entered:%p.", this ));

    CallReroutingArgument* pCallReroutingInv;
    
    int iResult = DecodeH450ASN( (void **) &pCallReroutingInv,
                         CallReroutingArgument_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (pCallReroutingInv == NULL) )
    {
        return FALSE;
    }

    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;
        if( m_pCallReroutingInfo == NULL )
        {
            goto cleanup;
        }
        ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }

    if( pCallReroutingInv->diversionCounter > MAX_DIVERSION_COUNTER )
        return FALSE;

    m_pCallReroutingInfo->diversionCounter = 
        pCallReroutingInv->diversionCounter;

    m_pCallReroutingInfo->diversionReason = pCallReroutingInv->reroutingReason;

    if( pCallReroutingInv->bit_mask & originalReroutingReason_present )
    {
        m_pCallReroutingInfo->originalDiversionReason = 
            pCallReroutingInv->originalReroutingReason;
    }
    else
    {
        m_pCallReroutingInfo->originalDiversionReason =
            pCallReroutingInv->reroutingReason;
    }

    if( ( pCallReroutingInv->bit_mask &
        CallReroutingArgument_originalCalledNr_present ) &&
        pCallReroutingInv->originalCalledNr.destinationAddress )
    {
            
        if( m_pCallReroutingInfo->originalCalledNr != NULL )
        {
            FreeAliasNames( m_pCallReroutingInfo->originalCalledNr );
            m_pCallReroutingInfo->originalCalledNr = NULL;
        }

        if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->originalCalledNr),
            (PSetup_UUIE_sourceAddress)
            (pCallReroutingInv->originalCalledNr.destinationAddress) ) )
        {
            //goto cleanup;
        }
    }
    
    if( m_pCallReroutingInfo->divertingNrAlias != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertingNrAlias );
        m_pCallReroutingInfo->divertingNrAlias = NULL;
    }

    if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->divertingNrAlias),
        (PSetup_UUIE_sourceAddress)
        (pCallReroutingInv->lastReroutingNr.destinationAddress) ) )
    {
        goto cleanup;
    }
 
    if( m_pCallReroutingInfo->divertedToNrAlias != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
        m_pCallReroutingInfo->divertedToNrAlias = NULL;
    }

    if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->divertedToNrAlias),
        (PSetup_UUIE_sourceAddress)
        (pCallReroutingInv->calledAddress.destinationAddress) ) )
    {
        goto cleanup;
    }
 
    m_dwCallType |= CALLTYPE_DIVERTEDSRC;
    m_dwCallDiversionState = H4503_CALLREROUTING_RECVD;

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCallReroutingInv,
                CallReroutingArgument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCallRerouting exited:%p.", this ));
    return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCallReroutingInv,
                CallReroutingArgument_PDU );

    FreeCallReroutingInfo();
    return FALSE;
}


BOOL
CH323Call::EncodeRejectAPDU( 
                 IN H4501SupplementaryService * pSupplementaryServiceAPDU,
                 IN DWORD dwInvokeID,
                 OUT BYTE**  ppEncodedAPDU,
                 OUT DWORD* pdwAPDULen
                )
{
    WORD wAPDULen;
    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeRejectAPDU entered:%p.", this ));

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;
    pROSAPDU->value.choice = reject_chosen;
    pROSAPDU->value.u.reject.invokeId = (WORD)dwInvokeID;
    pROSAPDU->value.u.reject.problem.choice = H4503ROS_invoke_chosen;
    pROSAPDU->value.u.reject.problem.u.invoke = InvokeProblem_mistypedArgument;
    
    //call ASN.1 encoding functions
    int rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wAPDULen );
    
    *pdwAPDULen = wAPDULen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeRejectAPDU exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeReturnErrorAPDU(
                      IN DWORD dwInvokeID,
                      IN DWORD dwErrorCode,
                      IN H4501SupplementaryService *pH450APDU,
                      OUT BYTE**  ppEncodedAPDU,
                      OUT DWORD* pdwAPDULen
                     )
{
    WORD wAPDULen;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeReturnErrorAPDU entered:%p.", this ));

    ServiceApdus_rosApdus *pROSAPDU = pH450APDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;
    pROSAPDU ->value.choice = H4503ROS_returnError_chosen;
    pROSAPDU ->value.u.returnError.invokeId = (WORD)dwInvokeID;

    pROSAPDU ->value.u.returnError.errcode.choice = local_chosen;
    pROSAPDU ->value.u.returnError.errcode.u.local = dwErrorCode;
    
    //call ASN.1 encoding functions
    int rc = EncodeH450ASN( (void *) pH450APDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wAPDULen );
    
    *pdwAPDULen = wAPDULen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeReturnErrorAPDU exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeDummyReturnResultAPDU(
    IN DWORD dwInvokeID,
    IN DWORD dwOpCode,
    IN H4501SupplementaryService *pH450APDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
    )
{
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    WORD    wEncodedLen = 0;
    int     rc;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDummyReturnResultAPDU entered:%p.",
        this ));

    ServiceApdus_rosApdus *pROSAPDU = pH450APDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;
    pROSAPDU ->value.choice = H4503ROS_returnResult_chosen;
    
    pROSAPDU ->value.u.returnResult.invokeId = (WORD)dwInvokeID;
    pROSAPDU ->value.u.returnResult.bit_mask = result_present;

    pROSAPDU ->value.u.returnResult.result.opcode.choice = local_chosen;
    pROSAPDU ->value.u.returnResult.result.opcode.u.local = dwOpCode;

    //dummy result not present
    pROSAPDU ->value.u.returnResult.result.result.length = 0;
    pROSAPDU ->value.u.returnResult.result.result.value = NULL;
    
    switch( dwOpCode )
    {
    case CTIDENTIFY_OPCODE:

        pROSAPDU ->value.u.returnResult.result.result.value = pBufEncodedArg;
        
        if( !EncodeCTIdentifyReturnResult( pROSAPDU ) )
        {
            return FALSE;
        }
        
        break;

    default:

        pROSAPDU ->value.u.returnResult.result.result.value = pBufEncodedArg;
        
        if( !EncodeDummyResult( pROSAPDU ) )
        {
            return FALSE;
        }

        break;
    }

    //call ASN.1 encoding functions
    rc = EncodeH450ASN( (void *) pH450APDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDummyReturnResultAPDU exited:%p.",
        this ));
    return TRUE;
}


BOOL
CH323Call::EncodeDummyResult(
    OUT ServiceApdus_rosApdus *pROSAPDU
    )
{
    DummyRes    dummyRes;
    BYTE        *pEncodedArg = NULL;
    WORD        wEncodedLen = 0;
    int         rc;
    UCHAR       sData[3] = "MS";

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDummyResult entered:%p.", this ));

    ZeroMemory( (PVOID)&dummyRes, sizeof(DummyRes) );
    
    dummyRes.choice = DummyRes_nonStandardData_chosen;
    dummyRes.u.nonStandardData.nonStandardIdentifier.choice
        = H225NonStandardIdentifier_h221NonStandard_chosen;
    dummyRes.u.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35CountryCode
        = H221_COUNTRY_CODE_USA;
    dummyRes.u.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35Extension
        = H221_COUNTRY_EXT_USA;
    dummyRes.u.nonStandardData.nonStandardIdentifier.u.h221NonStandard.manufacturerCode
        = H221_MFG_CODE_MICROSOFT;
        
    dummyRes.u.nonStandardData.data.length = 2;
    dummyRes.u.nonStandardData.data.value = sData;
        
    //encode the return result argument.
    rc = EncodeH450ASN( (void*) &dummyRes,
            DummyRes_PDU,
            &pEncodedArg,
            &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        return FALSE;
    }

    pROSAPDU ->value.u.returnResult.result.result.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU ->value.u.returnResult.result.result.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDummyResult exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeCTIdentifyReturnResult(
    OUT ServiceApdus_rosApdus *pROSAPDU
    )
{
    CTIdentifyRes cTIdentifyRes;
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    int     iCallID;
    int     rc;

    ZeroMemory( (PVOID)&cTIdentifyRes, sizeof(CTIdentifyRes) );
    
    iCallID = g_pH323Line -> GetCTCallIdentity(m_hdCall );

    if( iCallID == 0 )
    {
        return FALSE;
    }

    //argument.callIdentity
    _itoa( iCallID, (char*)m_pCTCallIdentity, 10 );

    CopyMemory( (PVOID)cTIdentifyRes.callIdentity, (PVOID)m_pCTCallIdentity,
        sizeof(m_pCTCallIdentity) );

    //argument.reroutingNumber
    cTIdentifyRes.reroutingNumber.bit_mask = 0;

    cTIdentifyRes.reroutingNumber.destinationAddress = 
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pCalleeAliasNames );
    
    if( cTIdentifyRes.reroutingNumber.destinationAddress == NULL )
    {
        return FALSE;
    }

    //encode the return result argument.
    rc = EncodeH450ASN( (void *) &cTIdentifyRes,
                CTIdentifyRes_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            cTIdentifyRes.reroutingNumber.destinationAddress );
        return FALSE;
    }

    pROSAPDU ->value.u.returnResult.result.result.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU ->value.u.returnResult.result.result.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    FreeAddressAliases( (PSetup_UUIE_destinationAddress)
        cTIdentifyRes.reroutingNumber.destinationAddress );

    return TRUE;
}


//supplemantary services functions
BOOL
CH323Call::EncodeCheckRestrictionAPDU( 
    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
   )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    BOOL    retVal = FALSE;
    int     rc = 0;
    TCHAR   szMsg[20];

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCheckRestrictionAPDU entered:%p.",
        this ));

    ServiceApdus_rosApdus *pROSAPDU =
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = CHECKRESTRICTION_OPCODE;

    //argument
    CheckRestrictionArgument checkRestrictionArgument;
    ZeroMemory( (PVOID)&checkRestrictionArgument, 
        sizeof(CheckRestrictionArgument) );
    
    //argument.divertedToNR
    checkRestrictionArgument.divertedToNr.bit_mask = 0;
    checkRestrictionArgument.divertedToNr.destinationAddress = 
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pCalleeAliasNames );
    if( checkRestrictionArgument.divertedToNr.destinationAddress == NULL )
    {
        goto cleanup;
    }


    if( m_pCallerAliasNames == NULL )
    {
        m_pCallerAliasNames = new H323_ALIASNAMES;

        if( m_pCallerAliasNames == NULL )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));
            goto cleanup;
        }
        memset( (PVOID)m_pCallerAliasNames, 0, sizeof(H323_ALIASNAMES) );

        LoadString( g_hInstance,
            IDS_UNKNOWN,
            szMsg,
            20
          );

        if( !AddAliasItem( m_pCallerAliasNames,
                szMsg,
                h323_ID_chosen ) )
        {
                goto cleanup;
        }
        
        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }

    //argument.servedUserNR
    checkRestrictionArgument.servedUserNr.bit_mask = 0;
    
    checkRestrictionArgument.servedUserNr.destinationAddress = 
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pCallerAliasNames );

    //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

    if( checkRestrictionArgument.servedUserNr.destinationAddress == NULL )
    {
        goto cleanup;
    }

    //argument.basicservice
    checkRestrictionArgument.basicService = allServices;

    //encode the checkrestriction argument.
    rc = EncodeH450ASN( (void *) &checkRestrictionArgument,
                CheckRestrictionArgument_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        goto cleanup;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    //call ASN.1 encoding functions
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        goto cleanup;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCheckRestrictionAPDU exited:%p.", 
        this ));
    retVal = TRUE;

cleanup:
    
    if( checkRestrictionArgument.servedUserNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            checkRestrictionArgument.servedUserNr.destinationAddress );
    }

    if( checkRestrictionArgument.divertedToNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            checkRestrictionArgument.divertedToNr.destinationAddress );
    }

    return retVal;
}


BOOL
CH323Call::EncodeDivertingLeg2APDU(
                    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
                    OUT BYTE**  ppEncodedAPDU,
                    OUT DWORD* pdwAPDULen
                    )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    BOOL    retVal = FALSE;
    int     rc = 0;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDivertingLeg2APDU entered:%p.", this ));

    pSupplementaryServiceAPDU->interpretationApdu.choice =
        discardAnyUnrecognizedInvokePdu_chosen;
    
    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = DIVERTINGLEGINFO2_OPCODE;

    //argument
    DivertingLegInformation2Argument divertLegInfo2Arg;

    ZeroMemory( (PVOID)&divertLegInfo2Arg, 
        sizeof(DivertingLegInformation2Argument) );

    //argument.diversionCounter
    divertLegInfo2Arg.diversionCounter
        = (WORD)m_pCallReroutingInfo->diversionCounter;
    
    //argument.diversionreason
    divertLegInfo2Arg.diversionReason = m_pCallReroutingInfo->diversionReason;

    //argument.originalDiversionReason
    if( m_pCallReroutingInfo->originalDiversionReason != 0 )
    {
        divertLegInfo2Arg.originalDiversionReason = 
            m_pCallReroutingInfo->originalDiversionReason;

        divertLegInfo2Arg.bit_mask |= originalDiversionReason_present;
    }

    //argument.divertingNr
    if( m_pCallReroutingInfo->divertingNrAlias != NULL )
    {
        divertLegInfo2Arg.bit_mask |= divertingNr_present;

        divertLegInfo2Arg.divertingNr.bit_mask = 0;
        divertLegInfo2Arg.divertingNr.destinationAddress
            = (PEndpointAddress_destinationAddress)
            SetMsgAddressAlias( m_pCallReroutingInfo->divertingNrAlias );

        if( divertLegInfo2Arg.divertingNr.destinationAddress == NULL )
        {
            return FALSE;
        }
    }

    //argument.originalCalledNr
    if( m_pCallReroutingInfo->originalCalledNr != NULL )
    {
        divertLegInfo2Arg.bit_mask |=
            DivertingLegInformation2Argument_originalCalledNr_present;

        divertLegInfo2Arg.originalCalledNr.bit_mask = 0;
        divertLegInfo2Arg.originalCalledNr.destinationAddress
            = (PEndpointAddress_destinationAddress)
            SetMsgAddressAlias( m_pCallReroutingInfo->originalCalledNr );

        if( divertLegInfo2Arg.originalCalledNr.destinationAddress == NULL )
        {
            goto cleanup;
        }
    }

    //encode the divertingleg2 argument.
    rc = EncodeH450ASN( (void *) &divertLegInfo2Arg,
                DivertingLegInformation2Argument_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        goto cleanup;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDivertingLeg2APDU exited:%p.", this ));
    retVal= TRUE;

cleanup:
    
    if( divertLegInfo2Arg.divertingNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            divertLegInfo2Arg.divertingNr.destinationAddress );
    }
        
    if( divertLegInfo2Arg.originalCalledNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            divertLegInfo2Arg.originalCalledNr.destinationAddress );
    }

    return retVal;
}


BOOL
CH323Call::EncodeDivertingLeg3APDU(
    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
    )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDivertingLeg3APDU entered:%p.", this ));

    pSupplementaryServiceAPDU->interpretationApdu.choice =
        discardAnyUnrecognizedInvokePdu_chosen;
    
    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = DIVERTINGLEGINFO3_OPCODE;

    //argument
    DivertingLegInformation3Argument divertLegInfo3Arg;
    ZeroMemory( (PVOID)&divertLegInfo3Arg, 
        sizeof(DivertingLegInformation3Argument) );

    //argument.presentationallowed
    divertLegInfo3Arg.presentationAllowedIndicator = TRUE;

    //argument.redirectionNr
    divertLegInfo3Arg.redirectionNr.bit_mask = 0;

    divertLegInfo3Arg.redirectionNr.destinationAddress =
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pCalleeAliasNames );

    if( divertLegInfo3Arg.redirectionNr.destinationAddress )
    {
        divertLegInfo3Arg.bit_mask |=  redirectionNr_present;
    }

    //encode the divertingleg3 argument.
    int rc = EncodeH450ASN( (void *) &divertLegInfo3Arg,
                DivertingLegInformation3Argument_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        if( divertLegInfo3Arg.redirectionNr.destinationAddress )
        {
            FreeAddressAliases( (PSetup_UUIE_destinationAddress)
                divertLegInfo3Arg.redirectionNr.destinationAddress );
        }
        return FALSE;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    if( divertLegInfo3Arg.redirectionNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            divertLegInfo3Arg.redirectionNr.destinationAddress );
    }
        
    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDivertingLeg3APDU exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeCallReroutingAPDU(
    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
    )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    BOOL    retVal = FALSE;
    int     rc = 0;
    UCHAR   bearerCap[5];
    TCHAR   szMsg[20];

    PH323_ALIASNAMES pCallerAliasNames = m_pCallerAliasNames;


    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCallReroutingAPDU entered:%p.", this ));

    _ASSERTE( m_pCallReroutingInfo );

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;
    
    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = CALLREROUTING_OPCODE;

    //argument
    CallReroutingArgument callReroutingArg;
    ZeroMemory( (PVOID)&callReroutingArg, sizeof(CallReroutingArgument) );
    
    //argument.reroutingReason
    callReroutingArg.reroutingReason = m_pCallReroutingInfo->diversionReason;

    //argument.originalReroutingReason
    if( m_pCallReroutingInfo->originalDiversionReason != 0 )
    {
        callReroutingArg.originalReroutingReason 
            = m_pCallReroutingInfo->originalDiversionReason;
    }
    else
    {
        callReroutingArg.originalReroutingReason 
        = m_pCallReroutingInfo->diversionReason;
    }

    //argument.diversionCounter
    callReroutingArg.diversionCounter = 
        ++(m_pCallReroutingInfo->diversionCounter);

    //argument.calledAddress
    callReroutingArg.calledAddress.bit_mask = 0;
    callReroutingArg.calledAddress.destinationAddress
        = (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias(m_pCallReroutingInfo->divertedToNrAlias);

    if( callReroutingArg.calledAddress.destinationAddress == NULL )
    {
        goto cleanup;
    }
    
    //argument.lastReroutingNr
    callReroutingArg.lastReroutingNr.bit_mask = 0;
        callReroutingArg.lastReroutingNr.destinationAddress
        = (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias(m_pCalleeAliasNames);
     
    if( callReroutingArg.lastReroutingNr.destinationAddress == NULL )
    {
        goto cleanup;
    }

    //argument.subscriptionoption
    callReroutingArg.subscriptionOption = notificationWithDivertedToNr;

    //argument.callingNumber
    callReroutingArg.callingNumber.bit_mask = 0;

    if( pCallerAliasNames == NULL )
    {
        pCallerAliasNames = new H323_ALIASNAMES;

        if( pCallerAliasNames == NULL )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));
            goto cleanup;
        }
        memset( (PVOID)pCallerAliasNames, 0, sizeof(H323_ALIASNAMES) );

        LoadString( g_hInstance,
            IDS_UNKNOWN,
            szMsg,
            20
          );

        if( !AddAliasItem( pCallerAliasNames,
                szMsg,
                h323_ID_chosen ) )
        {
                goto cleanup;
        }
    }

    callReroutingArg.callingNumber.destinationAddress
        = (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias(pCallerAliasNames);

    if( callReroutingArg.callingNumber.destinationAddress == NULL )
    {
        goto cleanup;
    }

    //argumnt.h225infoelement
    callReroutingArg.h225InfoElement.length = 5;
    callReroutingArg.h225InfoElement.value = bearerCap;
    
    bearerCap[0]= IDENT_BEARERCAP; 
    bearerCap[1]= 0x03; //length of the bearer capability
    bearerCap[2]= (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
    
    bearerCap[3]= BEAR_EXT_BIT | 0x17;
    bearerCap[4]= (BYTE)(BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | 
        BEAR_LAYER1_H221_H242);

    
    //argument.callingNumber
    if( m_pCallReroutingInfo->originalCalledNr != NULL )
    {
        callReroutingArg.originalCalledNr.bit_mask = 0;

        callReroutingArg.originalCalledNr.destinationAddress
            = (PEndpointAddress_destinationAddress)
            SetMsgAddressAlias( m_pCallReroutingInfo->originalCalledNr );

        if( callReroutingArg.originalCalledNr.destinationAddress != NULL )
        {
            callReroutingArg.bit_mask |= 
                CallReroutingArgument_originalCalledNr_present;
        }
    }

    //encode the callrerouting argument.
    rc = EncodeH450ASN( (void *) &callReroutingArg,
                CallReroutingArgument_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        goto cleanup;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCallReroutingAPDU exited:%p.", this ));
    retVal = TRUE;

cleanup:
    if( pCallerAliasNames != m_pCallerAliasNames )
    {
        FreeAliasNames( pCallerAliasNames );
    }

    FreeCallReroutingArg( &callReroutingArg );    
    return retVal;
}


//No need to call in a lock!!
void
CH323Call::FreeCallReroutingArg( 
    CallReroutingArgument* pCallReroutingArg
    )
{
    //free all the aliases
    if( pCallReroutingArg->calledAddress.destinationAddress != NULL )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            pCallReroutingArg->calledAddress.destinationAddress );
    }

    if( pCallReroutingArg->lastReroutingNr.destinationAddress != NULL )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            pCallReroutingArg->lastReroutingNr.destinationAddress );
    }

    if( pCallReroutingArg->callingNumber.destinationAddress != NULL )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            pCallReroutingArg->callingNumber.destinationAddress );
    }    
    
    if( pCallReroutingArg->originalCalledNr.destinationAddress != NULL )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            pCallReroutingArg->originalCalledNr.destinationAddress );
    }
}


// static
void
NTAPI CH323Call::CallEstablishmentExpiredCallback(
    IN PVOID   DriverCallHandle,        // HDRVCALL
    IN BOOLEAN bTimer)
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CallEstablishmentExpiredCallback entered." ));

    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "Q931 setup expired event recvd." ));
    pCall=g_pH323Line -> FindH323CallAndLock((HDRVCALL) DriverCallHandle);

    if( pCall != NULL )
    {
        if( pCall -> GetStateMachine() != Q931_CONNECT_RECVD )
        {
            //time out has occured
            pCall -> CloseCall( LINEDISCONNECTMODE_NOANSWER );
        }
        
        pCall -> Unlock();
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CallEstablishmentExpiredCallback exited." ));
}


//-----------------------------------------------------------------------------
        //CALL TRANSFER (H450.2) ENCODE/DECODE ROUTINES
//-----------------------------------------------------------------------------



BOOL
CH323Call::EncodeH450APDUNoArgument( 
    IN  DWORD   dwOpcode,
    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD*  pdwAPDULen
    )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    int     rc; 

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeH450APDUNoArgument entered:%p.", 
        this ));

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;
    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = 0;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = dwOpcode;

    //no argument passed
    
    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeH450APDUNoArgument exited:%p.", 
        this ));
    return TRUE;
}

BOOL
CH323Call::EncodeCTInitiateAPDU( 
            OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
            OUT BYTE**  ppEncodedAPDU,
            OUT DWORD* pdwAPDULen
            )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    int     rc = 0;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCTInitiateAPDU entered:%p.", this ));

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = CTINITIATE_OPCODE;

    //argument
    CTInitiateArg cTInitiateArg;
    ZeroMemory( (PVOID)&cTInitiateArg, sizeof(CTInitiateArg) );

    //argument.callIdentity
    CopyMemory( (PVOID)cTInitiateArg.callIdentity,
        (PVOID)m_pCTCallIdentity, sizeof(m_pCTCallIdentity) );

    //argument.reroutingNumber
    cTInitiateArg.reroutingNumber.bit_mask = 0;
    cTInitiateArg.reroutingNumber.destinationAddress =
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pTransferedToAlias );

    if( cTInitiateArg.reroutingNumber.destinationAddress == NULL )
    {
        return FALSE;
    }

    //encode the CTSetup argument.
    rc = EncodeH450ASN( (void *) &cTInitiateArg,
                CTInitiateArg_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            cTInitiateArg.reroutingNumber.destinationAddress );
        return FALSE;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    FreeAddressAliases( (PSetup_UUIE_destinationAddress)
        cTInitiateArg.reroutingNumber.destinationAddress );

    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCTInitiateAPDU exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeCTSetupAPDU(
            OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
            OUT BYTE**  ppEncodedAPDU,
            OUT DWORD* pdwAPDULen
            )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCTSetupAPDU entered:%p.", this ));

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = CTSETUP_OPCODE;

    //argument
    CTSetupArg cTSetupArg;
    ZeroMemory( (PVOID)&cTSetupArg, sizeof(CTSetupArg) );

    //argument.callIdentity
    CopyMemory( (PVOID)cTSetupArg.callIdentity, 
        (PVOID)m_pCTCallIdentity, sizeof(m_pCTCallIdentity) );

    //no argument.transferingNumber
 
    //encode the CTSetup argument.
    int rc = EncodeH450ASN( (void *) &cTSetupArg,
                CTSetupArg_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        return FALSE;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCTSetupAPDU exited:%p.", this ));
    return TRUE;
}


void CH323Call::PostLineEvent (
    IN  DWORD       MessageID,
    IN  DWORD_PTR   Parameter1,
    IN  DWORD_PTR   Parameter2,
    IN  DWORD_PTR   Parameter3)
{
    (*g_pfnLineEventProc) (
        g_pH323Line -> m_htLine,
        m_htCall,
        MessageID,
        Parameter1,
        Parameter2,
        Parameter3);
}


//!!must be always called in a lock
void
CH323Call::DecrementIoRefCount(
    OUT BOOL * pfDelete
    )
{
    _ASSERTE( m_IoRefCount != 0 );
    m_IoRefCount--;
    
    H323DBG((DEBUG_LEVEL_TRACE, "DecrementIoRefCount:m_IoRefCount:%d:%p.",
        m_IoRefCount, this ));
    
    *pfDelete = FALSE;

    if( m_dwFlags & CALLOBJECT_SHUTDOWN )
    {
        *pfDelete = (m_IoRefCount==0) ? TRUE : FALSE;
    }
}


//!!must be always called in a lock
void 
CH323Call::StopCTIdentifyRRTimer( 
    HDRVCALL hdRelatedCall
    )
{
    if( m_hCTIdentifyRRTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyRRTimer, NULL );
        m_hCTIdentifyRRTimer = NULL;
    }

    m_hdRelatedCall = hdRelatedCall;
}


void 
CH323Call::InitializeRecvBuf()
{
    m_RecvBuf.WSABuf.len = sizeof(TPKT_HEADER_SIZE);
    m_RecvBuf.WSABuf.buf = m_RecvBuf.arBuf;
    m_RecvBuf.dwPDULen = m_RecvBuf.dwBytesCopied = 0;
    m_bStartOfPDU = TRUE;
}


BOOL 
CH323Call::SetCallData( 
    LPVOID lpCallData, 
    DWORD dwSize )
{
    if( m_CallData.pOctetString != NULL )
    {
        delete m_CallData.pOctetString;
    }
    
    m_CallData.pOctetString = new BYTE[dwSize];
    
    if( m_CallData.pOctetString == NULL )
    {
        m_CallData.wOctetStringLength = 0;
        return FALSE;
    }

    CopyMemory( (PVOID)m_CallData.pOctetString, lpCallData, dwSize );

    m_CallData.wOctetStringLength = (WORD)dwSize;
    
    return TRUE;
}


// Global Functions

BOOL
IsPhoneNumber( 
              char * szAddr 
             )
{
    while( *szAddr )
    {
        if( !isdigit(*szAddr) && 
            ('#' != *szAddr) &&
            ('*' != *szAddr) &&
            ('+' != *szAddr)
          )
            return FALSE;
        szAddr++;
    }

    return TRUE;
}


BOOL
IsValidE164String( 
                  IN WCHAR* wszDigits
                 )
{
    for( ; (*wszDigits) != L'\0'; wszDigits++ )
    {
        if(!(                                            
            ((*wszDigits >= L'0') && (*wszDigits <= L'9')) ||   
            (*wszDigits == L'*') ||                         
            (*wszDigits == L'#') ||                         
            (*wszDigits == L'!') ||                         
            (*wszDigits == L',')                            
        ))
        {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\line.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    line.cpp

Abstract:

    TAPI Service Provider functions related to manipulating lines.

        TSPI_lineClose
        TSPI_lineGetDevCaps         
        TSPI_lineGetLineDevStatus
        TSPI_lineGetNumAddressIDs
        TSPI_lineOpen
        
Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 

//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "call.h"
#include "q931obj.h"
#include "ras.h"



static  LONG    g_CTCallIdentity;

CH323Line g_H323Line;

H323_OCTETSTRING g_ProductID =
{
    (BYTE*)H323_PRODUCT_ID,
    sizeof(H323_PRODUCT_ID)
};


H323_OCTETSTRING g_ProductVersion =
{
    (BYTE*)H323_PRODUCT_VERSION,
    sizeof(H323_PRODUCT_VERSION)
};


//Queues a request made by TAPI to the thread pool
BOOL
QueueTAPILineRequest(
    IN  DWORD       EventID,
    IN  HDRVCALL    hdCall1,
    IN  HDRVCALL    hdCall2,
    IN  DWORD       dwDisconnectMode,
    IN  WORD        wCallReference)
{
    BOOL fResult = TRUE;
    TAPI_LINEREQUEST_DATA * pLineRequestData = new TAPI_LINEREQUEST_DATA;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "QueueTAPILineRequest entered." ));

    if( pLineRequestData != NULL )
    {
        pLineRequestData -> EventID = EventID;
        pLineRequestData -> hdCall1 = hdCall1;

        if( hdCall2 != NULL )
        {
            pLineRequestData -> hdCall2 = hdCall2;
        }
        else
        {
            pLineRequestData -> dwDisconnectMode = dwDisconnectMode;
        }
                
        pLineRequestData -> wCallReference = wCallReference;
        
        if( !QueueUserWorkItem( ProcessTAPILineRequest, pLineRequestData,
                WT_EXECUTEDEFAULT) )
        {
            delete pLineRequestData;
            fResult = FALSE;
        }
    }
    else
    {
        fResult = FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "QueueTAPILineRequest exited." ));
    return fResult;
}


#if    DBG

DWORD
ProcessTAPILineRequest(
	IN PVOID ContextParameter
    )
{
    __try
    {
        return ProcessTAPILineRequestFre( ContextParameter );
    }
    __except( 1 )
    {
        TAPI_LINEREQUEST_DATA*  pRequestData = (TAPI_LINEREQUEST_DATA*)ContextParameter;
        
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event threw exception: %p, %p, %d.",
            EventIDToString(pRequestData -> EventID),
            pRequestData -> hdCall1,
            pRequestData -> hdCall2,
            pRequestData -> wCallReference ));
        
        _ASSERTE( FALSE );

        return 0;
    }
}

#endif

DWORD
ProcessTAPILineRequestFre(
    IN  PVOID   ContextParam
    )
{
    _ASSERTE( ContextParam );

    PH323_CALL              pCall = NULL;
    PH323_CALL              pConsultCall = NULL;
    TAPI_LINEREQUEST_DATA*  pLineRequestData = (TAPI_LINEREQUEST_DATA*)ContextParam;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event recvd.",
        EventIDToString(pLineRequestData -> EventID) ));

    switch( pLineRequestData -> EventID )
    {
    case TSPI_CLOSE_CALL:

        g_pH323Line -> H323ReleaseCall( 
            pLineRequestData->hdCall1, 
            pLineRequestData->dwDisconnectMode,
            pLineRequestData->wCallReference );
        break;

    case TSPI_COMPLETE_TRANSFER:

        pConsultCall = g_pH323Line -> Find2H323CallsAndLock( 
            pLineRequestData->hdCall2, pLineRequestData->hdCall1, &pCall );
        
        if( pConsultCall != NULL )
        {
            pConsultCall -> CompleteTransfer( pCall );

            pCall -> Unlock();
            pConsultCall -> Unlock();
        }
        break;
    }

    delete pLineRequestData;
    return EXIT_SUCCESS;
}



//                                                                           
// Private procedures                                                        
//                                                                           

CH323Line::CH323Line()
{
    m_nState = H323_LINESTATE_NONE;
    m_hdLine = NULL;
    m_htLine = NULL;
    m_dwDeviceID = -1;
    m_dwTSPIVersion = NULL;
    m_dwMediaModes = NULL;
    m_hdNextMSPHandle = NULL;
    m_wszAddr[0] = UNICODE_NULL;
    m_dwInitState = NULL;

    m_VendorInfo.bCountryCode = H221_COUNTRY_CODE_USA;
    m_VendorInfo.bExtension = H221_COUNTRY_EXT_USA;
    m_VendorInfo.wManufacturerCode = H221_MFG_CODE_MICROSOFT;
    m_VendorInfo.pProductNumber = &(g_ProductID);
    m_VendorInfo.pVersionNumber = &(g_ProductVersion); 

    m_pCallForwardParams = NULL;
    m_dwInvokeID = 256;
    m_fForwardConsultInProgress = FALSE;

}


PH323_CALL 
CH323Line::Find2H323CallsAndLock (
    IN  HDRVCALL hdCall1,
    IN  HDRVCALL hdCall2,
    OUT PH323_CALL * ppCall2
    )
{
    int iIndex1 = MakeCallIndex (hdCall1);
    int iIndex2 = MakeCallIndex (hdCall2);
    PH323_CALL  pCall1 = NULL, pCall2 = NULL;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "Find2H323CallsAndLock entered:%lx:%lx.",
        hdCall1, hdCall2 ));

    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    pCall1 = m_H323CallTable[iIndex1];
    if( pCall1 != NULL )
    {
        pCall1 -> Lock();
        if( pCall1->GetCallHandle() != hdCall1 )
        {
            pCall1 -> Unlock();
            pCall1 = NULL;
        }
        else 
        {
            if( pCall2=m_H323CallTable[iIndex2] )
            {
                pCall2 -> Lock();
                if( pCall2->GetCallHandle() != hdCall2 )
                {
                    pCall2 -> Unlock();
                    pCall2 = NULL;
                    pCall1 -> Unlock();
                    pCall1 = NULL;
                }
            }
            else
            {
                pCall1 -> Unlock();
                pCall1 = NULL;
            }
        }
    }

    UnlockCallTable();

    *ppCall2 = pCall2;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "Find2H323CallsAndLock exited:%lx:%lx.",
        hdCall1, hdCall2 ));
    return pCall1;
}


PH323_CALL 
CH323Line::FindH323CallAndLock (
    IN  HDRVCALL hdCall)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FindH323CallAndLock entered:%lx.", hdCall ));

    int iIndex = MakeCallIndex (hdCall);
    PH323_CALL  pCall = NULL;

    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    if( pCall=m_H323CallTable[iIndex] )
    {
        pCall -> Lock();
        if( pCall->GetCallHandle() != hdCall )
        {
            pCall -> Unlock();
            pCall = NULL;
        }
    }

    UnlockCallTable();

    H323DBG(( DEBUG_LEVEL_TRACE, "FindH323CallAndLock exited:%p.", pCall ));
    return pCall;
}


PH323_CALL 
CH323Line::FindCallByARQSeqNumAndLock( 
    WORD seqNumber
    )
{
    PH323_CALL  pCall = NULL;
    int         iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByARQSeqNumAndLock entered:%d.", 
        seqNumber ));
    
    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    for( iIndex=0; iIndex <  m_H323CallTable.GetAllocSize(); iIndex++ )
    {
        if( pCall=m_H323CallTable[iIndex] )
        {
            if( pCall->GetARQSeqNumber() == seqNumber )
            {
                pCall -> Lock();
                break;
            }
            pCall = NULL;
        }
    }

    UnlockCallTable();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByARQSeqNumAndLock exited." ));
    return pCall;
}


//the code is replicated for the purpose of effeciency
PH323_CALL 
CH323Line::FindCallByDRQSeqNumAndLock(
    WORD seqNumber
    )
{
    PH323_CALL  pCall = NULL;
    int         iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByDRQSeqNumAndLock entered:%d.",
        seqNumber ));
    
    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    for( iIndex=0; iIndex <  m_H323CallTable.GetAllocSize(); iIndex++ )
    {
        if( pCall=m_H323CallTable[iIndex] )
        {
            if( pCall->GetDRQSeqNumber() == seqNumber )
            {
                pCall -> Lock();
                break;
            }
            pCall = NULL;
        }
    }

    UnlockCallTable();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByDRQSeqNumAndLock exited:%d.",
        seqNumber ));
    return pCall;
}


//the code is replicated for the purpose of effeciency
PH323_CALL 
CH323Line::FindCallByCallRefAndLock( 
    WORD wCallRef
    )
{
    PH323_CALL  pCall = NULL;
    int         iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByCallRefAndLock entered:%d.",
        wCallRef ));
    
    wCallRef &= 0x7fff;
    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    for( iIndex=0; iIndex <  m_H323CallTable.GetAllocSize(); iIndex++ )
    {
        if( pCall=m_H323CallTable[iIndex] )
        {
            if( pCall->GetCallRef() == wCallRef )
            {
                pCall -> Lock();
                break;
            }
            pCall = NULL;
        }
    }

    UnlockCallTable();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByCallRefAndLock exited:%d.",
        wCallRef ));
    
    return pCall;
}


void 
CH323Line::RemoveFromCTCallIdentityTable( 
    HDRVCALL hdCall )
{
    int iIndex;
    PCTCALLID_CONTEXT pCTCallIDContext = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "RemoveFromCTCallIdentityTable entered:%lx.",
        hdCall ));
    
    m_CTCallIDTable.Lock();

    for( iIndex=0; iIndex <  m_CTCallIDTable.GetAllocSize(); iIndex++ )
    {
        pCTCallIDContext = m_CTCallIDTable[iIndex];

        if( pCTCallIDContext != NULL )
        {
            if( pCTCallIDContext -> hdCall == hdCall)
            {
                m_CTCallIDTable.RemoveAt(iIndex);
            }
        }
    }

    m_CTCallIDTable.Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "RemoveFromCTCallIdentityTable exited:%lx.",
        hdCall ));
}


void 
CH323Line::ShutdownCTCallIDTable()
{
    int iIndex;
    PCTCALLID_CONTEXT pCTCallIDContext = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "ShutdownCTCallIDTable entered." ));
    
    m_CTCallIDTable.Lock();

    for( iIndex=0; iIndex <  m_CTCallIDTable.GetAllocSize(); iIndex++ )
    {
        pCTCallIDContext = m_CTCallIDTable[iIndex];

        if( pCTCallIDContext != NULL )
        {
            delete pCTCallIDContext;
            m_CTCallIDTable[iIndex] = NULL;
        }
    }

    m_CTCallIDTable.Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "ShutdownCTCallIDTable exited." ));
}


BOOL
CH323Line::CallReferenceDuped(
    WORD wCallRef
    )
{
    PH323_CALL  pCall = NULL;
    int         iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "CallReferenceDuped entered:%d.", wCallRef ));
    
    wCallRef &= 0x7FFF;
    LockCallTable();

    for( iIndex=0; iIndex <  m_H323CallTable.GetAllocSize(); iIndex++ )
    {
        if( pCall=m_H323CallTable[iIndex] )
        {
            if( pCall->GetCallRef() == wCallRef )
            {
                UnlockCallTable();
                return TRUE;
            }
        }
    }

    UnlockCallTable();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CallReferenceDuped exited:%d.", wCallRef ));
    return FALSE;
}


HDRVCALL
CH323Line::GetCallFromCTCallIdentity( 
    int iCTCallID
    )
{
    int iIndex;
    PCTCALLID_CONTEXT pCTCallIDContext = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "GetCallFromCTCallIdentity entered:%d.", 
        iCTCallID ));
    
    m_CTCallIDTable.Lock();

    for( iIndex=0; iIndex <  m_CTCallIDTable.GetAllocSize(); iIndex++ )
    {
        pCTCallIDContext = m_CTCallIDTable[iIndex];

        if( pCTCallIDContext != NULL )
        {
            if( pCTCallIDContext -> iCTCallIdentity == iCTCallID )
            {
                m_CTCallIDTable.Unlock();
                return (HDRVCALL)(pCTCallIDContext -> hdCall);
            }
        }
    }

    m_CTCallIDTable.Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "GetCallFromCTCallIdentity exited:%d.",
        iCTCallID ));
    
    return NULL;
}


int
CH323Line::GetCTCallIdentity(
    IN  HDRVCALL    hdCall)
{
    int CTCallID = 0;
    int iIndex;
    PCTCALLID_CONTEXT pCTCallIDContext = NULL;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "GetCTCallIdentity entered:%lx.",  hdCall ));

    m_CTCallIDTable.Lock();

    do
    {
        g_CTCallIdentity++;
        if( g_CTCallIdentity == 10000 )
        {
            g_CTCallIdentity = 1;
        }
    
        //lock the call so that nobody else would be able to delete the call
        for( iIndex=0; iIndex <  m_CTCallIDTable.GetAllocSize(); iIndex++ )
        {
            pCTCallIDContext = m_CTCallIDTable[iIndex] ;

            if( pCTCallIDContext != NULL )
            {
                if( pCTCallIDContext -> iCTCallIdentity == g_CTCallIdentity )
                {
                    break;
                }
            }
        }

        if( iIndex == m_CTCallIDTable.GetAllocSize() )
        {
            CTCallID = g_CTCallIdentity;
        }

    }while( CTCallID == 0 );

    pCTCallIDContext = new CTCALLID_CONTEXT;

    if( pCTCallIDContext == NULL )
    {
        m_CTCallIDTable.Unlock();
        return 0;
    }

    pCTCallIDContext->iCTCallIdentity = CTCallID;
    pCTCallIDContext->hdCall = hdCall;

    if( m_CTCallIDTable.Add(pCTCallIDContext) == -1 )
    {
        m_CTCallIDTable.Unlock();
        delete pCTCallIDContext;
        return 0;
    }

    m_CTCallIDTable.Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "GetCTCallIdentity exited:%lx.",  hdCall ));
    
    return CTCallID;
}


void
CH323Line::SetCallForwardParams( 
    IN CALLFORWARDPARAMS* pCallForwardParams )
{
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SetCallForwardParams entered." ));
    
    if( m_pCallForwardParams != NULL )
    {
        FreeCallForwardParams( m_pCallForwardParams );
        m_pCallForwardParams = NULL;
    }
    m_pCallForwardParams = pCallForwardParams;

    H323DBG(( DEBUG_LEVEL_TRACE, "SetCallForwardParams exited." ));
}


BOOL
CH323Line::SetCallForwardParams(
    IN LPFORWARDADDRESS pForwardAddress
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SetCallForwardParams entered." ));
    
    if( m_pCallForwardParams != NULL )
    {
        pForwardAddress->next = m_pCallForwardParams->pForwardedAddresses;
        m_pCallForwardParams->pForwardedAddresses = pForwardAddress;
    }
    else
    {
        m_pCallForwardParams = new CALLFORWARDPARAMS;
        
        if( m_pCallForwardParams == NULL )
        {
            return FALSE;
        }

        ZeroMemory( m_pCallForwardParams, sizeof(CALLFORWARDPARAMS) );
        m_pCallForwardParams->fForwardingEnabled = TRUE;

        m_pCallForwardParams->pForwardedAddresses = pForwardAddress;
        pForwardAddress -> next = NULL;
    }


    //set unconditional forwarding
    m_pCallForwardParams->fForwardForAllOrigins = FALSE;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SetCallForwardParams exited." ));
    
    return TRUE;
}



CH323Line::~CH323Line()
{
    DeleteCriticalSection (&m_CriticalSection);
}


/*++

Routine Description:

    Hangs up call (if necessary) and closes call object.  

Arguments:

    Handle of the call.
Return Values:

    none.
    
--*/

void
CH323Line::H323ReleaseCall(
    IN HDRVCALL hdCall,
    IN DWORD dwDisconnectMode,
    IN WORD wCallReference
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "H323ReleaseCall entered:%lx.", hdCall ));

    int         iIndex = MakeCallIndex (hdCall);
    PH323_CALL  pCall;
    BOOL        fDelete = FALSE;

    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    if( (pCall=m_H323CallTable[iIndex]) && (hdCall==pCall->GetCallHandle()) )
    {
        pCall -> Lock();
        
        if( (wCallReference != 0) && 
            (wCallReference != pCall->GetCallRef()) )
        {
            //This message is for some other call. Ignore the message.
            H323DBG(( DEBUG_LEVEL_VERBOSE, "TSPI_CLOSE_CALL message ignored."));
        }
        else
        {
            // drop call using normal disconnect code
            pCall -> DropCall( dwDisconnectMode );
            pCall -> Shutdown( &fDelete );

            H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx closed.", pCall ));
        }

        pCall -> Unlock();

        //release the H323 call object
        if( fDelete == TRUE )
        {
            H323DBG(( DEBUG_LEVEL_VERBOSE, "call delete:0x%08lx.", pCall ));
            delete pCall;
        }
    }
    
    UnlockCallTable();
    H323DBG(( DEBUG_LEVEL_TRACE, "H323ReleaseCall exited: %p.", pCall ));
}


BOOL 
CH323Line::Initialize ( 
    IN  DWORD   dwLineDeviceIDBase)
{
    DWORD dwSize;
    H323DBG((DEBUG_LEVEL_TRACE, "line Initialize entered."));

    if( m_dwInitState & LINEOBJECT_INITIALIZED )
    {
        return TRUE;
    }

    __try
    {
        if( !InitializeCriticalSectionAndSpinCount( &m_CriticalSection,
            0x80000000 ) )
        {
            return FALSE;
        }
    }
    __except( 1 )
    {
        return FALSE;
    }

    m_dwDeviceID = dwLineDeviceIDBase;
    m_dwInitState = LINEOBJECT_INITIALIZED;
    //m_dwMediaModes = H323_LINE_MEDIAMODES;
    m_hdLine = (HDRVLINE__ *)this;
    m_dwNumRingsNoAnswer = H323_NUMRINGS_NOANSWER;

    dwSize = sizeof( m_wszAddr );

    //create displayable address
    GetComputerNameW( m_wszAddr, &dwSize );

    H323DBG(( DEBUG_LEVEL_TRACE, "line %d initialized (addr=%S)(hdLine=%d).",
        m_dwDeviceID, m_wszAddr, m_hdLine));

    // change line device state to closed
    m_nState = H323_LINESTATE_NONE;

    //init the mSP handles list
    m_MSPHandleList = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "line Initialize exited." ));
    // success
    return TRUE;
}


BOOL
CH323Line::AddMSPInstance( 
    HTAPIMSPLINE htMSPLine,
    HDRVMSPLINE  hdMSPLine )
{
    MSPHANDLEENTRY* pMSPHandleEntry;

    H323DBG(( DEBUG_LEVEL_TRACE, "AddMSPInstance entered." ));
    Lock();

    pMSPHandleEntry = new MSPHANDLEENTRY;

    if( pMSPHandleEntry == NULL )
    {
        Unlock();
        return FALSE;
    }

    pMSPHandleEntry->htMSPLine = htMSPLine;
    pMSPHandleEntry->hdMSPLine = hdMSPLine;
    pMSPHandleEntry->next = m_MSPHandleList;
    m_MSPHandleList = pMSPHandleEntry;

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "AddMSPInstance exited." ));
    return TRUE;
}


BOOL
CH323Line::IsValidMSPHandle( 
    HDRVMSPLINE hdMSPLine,
    HTAPIMSPLINE* phtMSPLine )
{
    Lock();

    MSPHANDLEENTRY* pMSPHandle = m_MSPHandleList;
    while( pMSPHandle )
    {
        if( pMSPHandle->hdMSPLine == hdMSPLine )
        {
            *phtMSPLine = pMSPHandle->htMSPLine;
            Unlock();
            return TRUE;
        }
        pMSPHandle = pMSPHandle->next;
    }

    Unlock();
    return FALSE;
}


BOOL
CH323Line::DeleteMSPInstance( 
    HTAPIMSPLINE*   phtMSPLine,
    HDRVMSPLINE     hdMSPLine )
{
    MSPHANDLEENTRY* pMSPHandle;
    MSPHANDLEENTRY* pMSPHandleDel;
    BOOL            fRetVal = TRUE;

    H323DBG(( DEBUG_LEVEL_TRACE, "DeleteMSPInstance entered." ));
    Lock();

    if( m_MSPHandleList == NULL )
    {
        fRetVal = FALSE;
        goto func_exit;
    }

    if( m_MSPHandleList->hdMSPLine == hdMSPLine )
    {
        *phtMSPLine = m_MSPHandleList->htMSPLine;
        
        pMSPHandleDel = m_MSPHandleList;
        m_MSPHandleList = m_MSPHandleList->next;

        delete pMSPHandleDel;
        fRetVal = TRUE;
        goto func_exit;
    }

    for( pMSPHandle=m_MSPHandleList; pMSPHandle->next; pMSPHandle=pMSPHandle->next )
    {
        if( pMSPHandle->next->hdMSPLine == hdMSPLine )
        {
            *phtMSPLine = pMSPHandle->next->htMSPLine;
            
            pMSPHandleDel = pMSPHandle->next;
            pMSPHandle->next = pMSPHandle->next->next;
        
            delete pMSPHandleDel;
            fRetVal = TRUE;
            goto func_exit;
        }
    }

func_exit:
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "DeleteMSPInstance exited." ));
    return fRetVal;
}


//!!always called in a lock
void 
CH323Line::ShutdownAllCalls(void)
{

    PH323_CALL pCall;
    H323_CONFERENCE* pConf;
    DWORD indexI;
    DWORD dwSize;
    BOOL fDelete = FALSE;

    if( !(m_dwInitState & LINEOBJECT_INITIALIZED) )
        return;

    H323DBG((DEBUG_LEVEL_TRACE, "ShutdownAllCalls entered."));
    
    if( m_dwInitState & LINEOBJECT_SHUTDOWN )
    {
        return;
    }

    //shutdown all calls, delete all calls
    LockCallTable();
    dwSize = m_H323CallTable.GetAllocSize();
    for( indexI=0; indexI <  dwSize; indexI++ )
    {
        pCall = m_H323CallTable[indexI];
        if( pCall != NULL )
        {
            pCall -> DropCall( 0 );
            pCall -> Shutdown(&fDelete);

            if(fDelete)
            {
                H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
                delete pCall;
            }
        }

    }
    UnlockCallTable();

    dwSize = m_H323ConfTable.GetSize();
    for( indexI=0; indexI < dwSize; indexI++ )
    {
        pConf = m_H323ConfTable[indexI];
        //m_H323ConfTable.RemoveAt( indexI );
        if( pConf != NULL )
        {
            delete pConf;
            m_H323ConfTable[indexI] = NULL;
        }
    }

    H323DBG((DEBUG_LEVEL_TRACE, "ShutdownAllCalls exited."));
}


void
CH323Line::Shutdown(void)
{
    BOOL            fDelete = FALSE;
    MSPHANDLEENTRY* pMSPHandle;

    if( !(m_dwInitState & LINEOBJECT_INITIALIZED) )
    {
        return;
    }

    H323DBG((DEBUG_LEVEL_TRACE, "line Shutdown entered."));
    
    Lock();
    if( m_dwInitState & LINEOBJECT_SHUTDOWN )
    {
        Unlock();
        return;
    }

    FreeCallForwardParams( m_pCallForwardParams );
    m_pCallForwardParams = NULL;

    Close();

    m_dwMediaModes = NULL;
    //m_hdLine = NULL;
    m_hdNextMSPHandle = NULL;
    m_htLine = NULL;

    //Free the MSP handles list
    while( m_MSPHandleList )
    {
        pMSPHandle = m_MSPHandleList;
        m_MSPHandleList = m_MSPHandleList->next;
        delete pMSPHandle;
    }

    m_dwInitState |= LINEOBJECT_SHUTDOWN;

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "line Shutdown exited." ));
}


LONG
CH323Line::CopyLineInfo(
    IN DWORD dwDeviceID,
    OUT LPLINEADDRESSCAPS pAddressCaps
    )
{
    DWORD dwAddressSize;
        
    H323DBG((DEBUG_LEVEL_TRACE, "line CopyLineInfo entered."));
    
    // determine size of address name
    dwAddressSize = H323SizeOfWSZ( m_wszAddr );

    // calculate number of bytes needed
    pAddressCaps->dwNeededSize = sizeof(LINEADDRESSCAPS) + 
                                 dwAddressSize
                                 ;

    // validate buffer allocated is large enough
    if (pAddressCaps->dwTotalSize >= pAddressCaps->dwNeededSize)
    {
        // record amount of memory used
        pAddressCaps->dwUsedSize = pAddressCaps->dwNeededSize;

        // position address name after fixed portion
        pAddressCaps->dwAddressSize = dwAddressSize;
        pAddressCaps->dwAddressOffset = sizeof(LINEADDRESSCAPS);
    
        // copy address name after fixed portion
        CopyMemory((LPBYTE)pAddressCaps + pAddressCaps->dwAddressOffset,
            (LPBYTE)m_wszAddr,
            pAddressCaps->dwAddressSize );
    }
    else if (pAddressCaps->dwTotalSize >= sizeof(LINEADDRESSCAPS))
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "lineaddresscaps structure too small for strings." ));

        // record amount of memory used
        pAddressCaps->dwUsedSize = sizeof(LINEADDRESSCAPS);

    } 
    else 
    {
        H323DBG((DEBUG_LEVEL_ERROR, "lineaddresscaps structure too small."));

        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE, "addr 0 capabilities requested." ));
    
    // transfer associated device id 
    pAddressCaps->dwLineDeviceID = dwDeviceID;

    // initialize number of calls allowed per address 
    pAddressCaps->dwMaxNumActiveCalls = H323_MAXCALLSPERADDR;

    // initialize supported address capabilities
    pAddressCaps->dwAddressSharing     = H323_ADDR_ADDRESSSHARING;
    pAddressCaps->dwCallInfoStates     = H323_ADDR_CALLINFOSTATES;
    pAddressCaps->dwCallStates         = H323_ADDR_CALLSTATES;
    pAddressCaps->dwDisconnectModes    = H323_ADDR_DISCONNECTMODES;
    pAddressCaps->dwAddrCapFlags       = H323_ADDR_CAPFLAGS;
    pAddressCaps->dwCallFeatures       = H323_ADDR_CALLFEATURES;
    pAddressCaps->dwAddressFeatures    = H323_ADDR_ADDRFEATURES;
    pAddressCaps->dwCallerIDFlags      = H323_ADDR_CALLPARTYIDFLAGS;
    pAddressCaps->dwCalledIDFlags      = H323_ADDR_CALLPARTYIDFLAGS;

    // initialize unsupported address capabilities
    pAddressCaps->dwConnectedIDFlags   = LINECALLPARTYID_UNAVAIL;
    pAddressCaps->dwRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    pAddressCaps->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
        
    H323DBG((DEBUG_LEVEL_TRACE, "line CopyLineInfo exited."));
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetAddressCaps - Exited." ));
    // success
    return NOERROR;
}

        
/*++

Routine Description:

    Initiate activities on line device and allocate resources.

Arguments:

    htLine - TAPI's handle describing line device to open.

    dwTSPIVersion - The TSPI version negotiated through 
        TSPI_lineNegotiateTSPIVersion under which the Service Provider is 
        willing to operate.

Return Values:

    Returns true if successful.
    
--*/

LONG CH323Line::Open(
    IN  DWORD       DeviceID,
    IN  HTAPILINE   TapiLine,
    IN  DWORD       TspiVersion,
    IN  HDRVLINE *  ReturnDriverLine)
{
    HRESULT     hr;
    LONG        dwStatus = ERROR_SUCCESS;

    H323DBG(( DEBUG_LEVEL_TRACE, "H323 line open entered." ));

    if (GetDeviceID() != DeviceID)
    {
        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // make sure this is a version we support    
    if (!H323ValidateTSPIVersion (TspiVersion))
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    Lock();

    switch (m_nState)
    {

    case H323_LINESTATE_OPENED:
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "H323 line is already open (H323_LINESTATE_OPENED), cannot reopen"));
        dwStatus = LINEERR_INUSE;
        break;

    case H323_LINESTATE_LISTENING:
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "H323 line is already open (H323_LINESTATE_LISTENING), cannot reopen"));
        dwStatus = LINEERR_INUSE;
        break;

    case H323_LINESTATE_CLOSING:
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "H323 line cannot be opened (H323_LINESTATE_CLOSING)"));
        dwStatus = LINEERR_INVALLINESTATE;
        break;

    case H323_LINESTATE_OPENING:
        H323DBG ((DEBUG_LEVEL_ERROR,
            "H323 line cannot be opened (H323_LINESTATE_OPENING)"));
        dwStatus = LINEERR_INVALLINESTATE;
        break;

    case H323_LINESTATE_NONE:
        // attempt to open line device

        H323DBG ((DEBUG_LEVEL_TRACE, "H323 line is opening"));

        // start listen if necessary
        if (IsMediaDetectionEnabled())
        {
            hr = Q931AcceptStart();
            if (hr == S_OK)
            {
                dwStatus = ERROR_SUCCESS;
                RasStart();
            }
            else
            {
                H323DBG ((DEBUG_LEVEL_ERROR, "failed to listen on Q.931"));
                dwStatus = LINEERR_OPERATIONFAILED;
            }
        }

        if (dwStatus == ERROR_SUCCESS)
        {
            H323DBG ((DEBUG_LEVEL_TRACE, "H323 line successfully opened"));

            // save line variables now
            m_nState = IsMediaDetectionEnabled()?
                H323_LINESTATE_LISTENING:H323_LINESTATE_OPENED;
            m_htLine = TapiLine;
            m_dwTSPIVersion = TspiVersion;
            *ReturnDriverLine = (HDRVLINE) this;
        }
        else
        {
            Q931AcceptStop();
        }
        break;

    default:
        _ASSERTE( FALSE );
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "H323 line open exited." ));
    return dwStatus;
}


/*++
Routine Description:

    Terminate activities on line device.

Arguments:

Return Values:

    Returns true if successful.

--*/
LONG
CH323Line::Close(void)
{
    LONG    dwStatus;

    H323DBG(( DEBUG_LEVEL_TRACE, "H323 line close entered." ));

    Lock();

    switch (m_nState)
    {
    case H323_LINESTATE_OPENED:
    case H323_LINESTATE_LISTENING: 

        if( m_fForwardConsultInProgress == TRUE )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "H323 line closed while forward is in progress." ));
            //Unlock();
            //return NOERROR;
        }

        // change line device state to closing
        m_nState = H323_LINESTATE_CLOSING;

        //shutdown all the calls
        ShutdownAllCalls();

        RasStop();

        if (IsMediaDetectionEnabled())
        {
            Q931AcceptStop();
        }
            
        ShutdownCTCallIDTable();

        // reset variables
        m_htLine = (HTAPILINE) NULL;
        m_dwTSPIVersion = 0;

        // change line device state to closed
        m_nState = H323_LINESTATE_NONE;
        dwStatus = ERROR_SUCCESS;
        break;

    default:
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "H323: lineclose called in bogus state:%d", m_nState ));
        dwStatus = LINEERR_OPERATIONFAILED;
        break;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "H323 line close exited." ));
    return dwStatus;
}


//                                                                           
// TSPI procedures                                                           
//                                                                           

        
/*++
Routine Description:

    This function closes the specified open line device after completing or 
    aborting all outstanding calls and asynchronous operations on the device.

    The Service Provider has the responsibility to (eventually) report 
    completion for every operation it decides to execute asynchronously.  
    If this procedure is called for a line on which there are outstanding 
    asynchronous operations, the operations should be reported complete with an
    appropriate result or error code before this procedure returns.  Generally
    the TAPI DLL would wait for these to complete in an orderly fashion.  
    However, the Service Provider should be prepared to handle an early call to
    TSPI_lineClose in "abort" or "emergency shutdown" situtations.

    A similar requirement exists for active calls on the line.  Such calls must 
    be dropped, with outstanding operations reported complete with appropriate 
    result or error codes.
    
    After this procedure returns the Service Provider must report no further 
    events on the line or calls that were on the line.  The Service Provider's 
    opaque handles for the line and calls on the line become "invalid".

    The Service Provider must relinquish non-sharable resources it reserves 
    while the line is open.  For example, closing a line accessed through a 
    comm port and modem should result in closing the comm port, making it once 
    available for use by other applications.

    This function is presumed to complete successfully and synchronously.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to be
        closed.  After the line has been successfully closed, this handle is 
        no longer valid.

Return Values:

    Returns zero if the function is successful, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified device handle is invalid.
        
        LINEERR_OPERATIONFAILED - The specified operation failed for unknown 
            reasons.

--*/
LONG
TSPIAPI
TSPI_lineClose (
    IN  HDRVLINE    DriverLine)
{
    _ASSERTE(DriverLine);
    _ASSERTE(DriverLine == (HDRVLINE) &g_H323Line);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineClose - Entered." ));
    return ((CH323Line *) DriverLine) -> Close();
}


/*++
Routine Description:

    This function queries a specified line device to determine its telephony 
    capabilities. The returned information is valid for all addresses on the 
    line device.

    Line device ID numbering for a Service Provider is sequential from the 
    value set by the function TSPI_lineSetDeviceIDBase.

    The dwExtVersion field of pLineDevCaps has already been filled in to 
    indicate the version number of the Extension information requested.  If 
    it is zero, no Extension information is requested.  If it is non-zero it 
    holds a value that has already been negotiated for this device with the 
    function TSPI_lineNegotiateExtVersion.  The Service Provider should fill 
    in Extension information according to the Extension version specified.

    One of the fields in the LINEDEVCAPS structure returned by this function 
    contains the number of addresses assigned to the specified line device. 
    The actual address IDs used to reference individual addresses vary from 
    zero to one less than the returned number. The capabilities of each 
    address may be different. Use TSPI_lineGetAddressCaps for each available 
    <dwDeviceID, dwAddressID> combination to determine the exact capabilities 
    of each address.

Arguments:

    dwDeviceID - Specifies the line device to be queried.

    dwTSPIVersion - Specifies the negotiated TSPI version number.  This value 
        has already been negotiated for this device through the 
        TSPI_lineNegotiateTSPIVersion function.

    pLineDevCaps - Specifies a far pointer to a variable sized structure of 
        type LINEDEVCAPS. Upon successful completion of the request, this 
        structure is filled with line device capabilities information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API 
            version or version range that is either incompatible or cannot 
            be supported by the Telephony API implementation and/or 
            corresponding service provider. 

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/
LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD         dwDeviceID,
    DWORD         dwTSPIVersion,
    DWORD         dwExtVersion,
    LPLINEDEVCAPS pLineDevCaps
    )
{
    DWORD dwLineNameSize;
    DWORD dwProviderInfoSize;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetDevCaps - Entered." ));

    if( g_pH323Line -> GetDeviceID() != dwDeviceID )
    {
        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion))
    {
        // do not support tspi version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // determine string lengths    
    dwProviderInfoSize  = H323SizeOfWSZ(g_pwszProviderInfo);
    dwLineNameSize      = H323SizeOfWSZ(g_pwszLineName);

    // calculate number of bytes required 
    pLineDevCaps->dwNeededSize = sizeof(LINEDEVCAPS) +
                                 dwProviderInfoSize  +
                                 dwLineNameSize     
                                 ;

    // make sure buffer is large enough for variable length data
    if (pLineDevCaps->dwTotalSize >= pLineDevCaps->dwNeededSize)
    {
        // record amount of memory used
        pLineDevCaps->dwUsedSize = pLineDevCaps->dwNeededSize;

        // position provider info after fixed portion
        pLineDevCaps->dwProviderInfoSize = dwProviderInfoSize;
        pLineDevCaps->dwProviderInfoOffset = sizeof(LINEDEVCAPS);

        // position line name after device class
        pLineDevCaps->dwLineNameSize = dwLineNameSize;
        pLineDevCaps->dwLineNameOffset = 
            pLineDevCaps->dwProviderInfoOffset +
            pLineDevCaps->dwProviderInfoSize
            ;

        // copy provider info after fixed portion
        CopyMemory((LPBYTE)pLineDevCaps + pLineDevCaps->dwProviderInfoOffset,
               (LPBYTE)g_pwszProviderInfo,
               pLineDevCaps->dwProviderInfoSize
               );
                
        // copy line name after device class
        CopyMemory((LPBYTE)pLineDevCaps + pLineDevCaps->dwLineNameOffset,
               (LPBYTE)g_pwszLineName,
               pLineDevCaps->dwLineNameSize
               );

    } 
    else if (pLineDevCaps->dwTotalSize >= sizeof(LINEDEVCAPS))
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "linedevcaps structure too small for strings." ));

        // structure only contains fixed portion
        pLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS);

    } 
    else 
    {
        H323DBG(( DEBUG_LEVEL_WARNING, "linedevcaps structure too small." ));

        // structure is too small
        return LINEERR_STRUCTURETOOSMALL;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE, "line capabilities requested."));
    
    // construct permanent line identifier
    pLineDevCaps->dwPermanentLineID = (DWORD)MAKELONG(
        dwDeviceID - g_dwLineDeviceIDBase,
        g_dwPermanentProviderID
        );

    // notify tapi that strings returned are in unicode
    pLineDevCaps->dwStringFormat = STRINGFORMAT_UNICODE;

    // initialize line device capabilities
    pLineDevCaps->dwNumAddresses      = H323_MAXADDRSPERLINE;
    pLineDevCaps->dwMaxNumActiveCalls = H323_MAXCALLSPERLINE;
    pLineDevCaps->dwAddressModes      = H323_LINE_ADDRESSMODES;
    pLineDevCaps->dwBearerModes       = H323_LINE_BEARERMODES;
    pLineDevCaps->dwDevCapFlags       = H323_LINE_DEVCAPFLAGS;
    pLineDevCaps->dwLineFeatures      = H323_LINE_LINEFEATURES;
    pLineDevCaps->dwMaxRate           = H323_LINE_MAXRATE;
    pLineDevCaps->dwMediaModes        = H323_LINE_MEDIAMODES;
    pLineDevCaps->dwRingModes         = 0;

    // initialize address types to include phone numbers
    pLineDevCaps->dwAddressTypes = H323_LINE_ADDRESSTYPES;

    // line guid
    pLineDevCaps->PermanentLineGuid = LINE_H323;

    // modify GUID to be unique for each line
    pLineDevCaps->PermanentLineGuid.Data1 +=
        dwDeviceID - g_dwLineDeviceIDBase;

    // protocol guid
    pLineDevCaps->ProtocolGuid = TAPIPROTOCOL_H323;

    // add dtmf support via H.245 user input messages
    pLineDevCaps->dwGenerateDigitModes = LINEDIGITMODE_DTMF;
    pLineDevCaps->dwMonitorDigitModes  = LINEDIGITMODE_DTMF;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetDevCaps - Exited." ));
    // success
    return NOERROR;
}

    
/*++
Routine Description:

    This operation enables the TAPI DLL to query the specified open line 
    device for its current status.

    The TAPI DLL uses TSPI_lineGetLineDevStatus to query the line device 
    for its current line status. This status information applies globally 
    to all addresses on the line device. Use TSPI_lineGetAddressStatus to 
    determine status information about a specific address on a line.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        to be queried.

    pLineDevStatus - Specifies a far pointer to a variable sized data 
        structure of type LINEDEVSTATUS. Upon successful completion of 
        the request, this structure is filled with the line's device status.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified line device handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/
LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS pLineDevStatus
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetDevStatus - Entered." ));

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_INVALLINEHANDLE;
    }

    // determine number of bytes needed
    pLineDevStatus->dwNeededSize = sizeof(LINEDEVSTATUS);
    
    // see if allocated structure is large enough
    if (pLineDevStatus->dwTotalSize < pLineDevStatus->dwNeededSize)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "linedevstatus structure too small." ));

        // structure too small
        return LINEERR_STRUCTURETOOSMALL;
    }
    
    // record number of bytes used
    pLineDevStatus->dwUsedSize = pLineDevStatus->dwNeededSize;
    
    // initialize supported line device status fields
    pLineDevStatus->dwLineFeatures   = H323_LINE_LINEFEATURES;
    pLineDevStatus->dwDevStatusFlags = H323_LINE_DEVSTATUSFLAGS;

    // determine number of active calls on the line device
    pLineDevStatus -> dwNumActiveCalls = g_pH323Line -> GetNoOfCalls();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetDevStatus - Exited." ));
    // success
    return NOERROR;
}


/*++
Routine Description:

    Retrieves the number of address IDs supported on the indicated line.

    This function is called by TAPI.DLL in response to an application calling
    lineSetNumRings, lineGetNumRings, or lineGetNewCalls. TAPI.DLL uses the 
    retrieved value to determine if the specified address ID is within the 
    range supported by the service provider.

Arguments:

    hdLine - Specifies the handle to the line for which the number of address 
        IDs is to be retrieved.

    pdwNumAddressIDs - Specifies a far pointer to a DWORD. The location is 
        filled with the number of address IDs supported on the indicated line. 
        The value should be one or larger.

Return Values:

    Returns zero if the function is successful, or a negative error number 
    if an error has occurred. Possible return values are as follows:

        LINEERR_INVALLINEHANDLE - The specified line device handle is invalid.

--*/
LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE hdLine,
    LPDWORD  pdwNumAddressIDs
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetNumAddressIDs - Entered." ));

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetNumAddressIDs - bad linehandle:%lx, %lx.",
            hdLine, g_pH323Line -> GetHDLine() ));
        return LINEERR_INVALLINEHANDLE ;
    }

    // transfer number of addresses
    *pdwNumAddressIDs = H323_MAXADDRSPERLINE;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetNumAddressIDs - Exited." ));
    // success
    return NOERROR;
}

    
/*++

Routine Description:

    This function opens the line device whose device ID is given, returning 
    the Service Provider's opaque handle for the device and retaining the TAPI
    DLL's opaque handle for the device for use in subsequent calls to the 
    LINEEVENT procedure.

    Opening a line entitles the TAPI DLL to make further requests on the line.
    The line becomes "active" in the sense that the TAPI DLL can initiate 
    outbound calls and the Service Provider can report inbound calls.  The 
    Service Provider reserves whatever non-sharable resources are required to 
    manage the line.  For example, opening a line accessed through a comm port 
    and modem should result in opening the comm port, making it no longer 
    available for use by other applications.
    
    If the function is successful, both the TAPI DLL and the Service Provider 
    become committed to operating under the specified interface version number 
    for this open device.  Subsquent operations and events identified using 
    the exchanged opaque line handles conform to that interface version.  This 
    commitment and the validity of the handles remain in effect until the TAPI
    DLL closes the line using the TSPI_lineClose operation or the Service 
    Provider reports the LINE_CLOSE event.  If the function is not successful,
    no such commitment is made and the handles are not valid.

Arguments:

    dwDeviceID - Identifies the line device to be opened.  The value 
        LINE_MAPPER for a device ID is not permitted.

    htLine - Specifies the TAPI DLL's opaque handle for the line device to be 
        used in subsequent calls to the LINEEVENT callback procedure to 
        identify the device.

    phdLine - A far pointer to a HDRVLINE where the Service Provider fills in
        its opaque handle for the line device to be used by the TAPI DLL in 
        subsequent calls to identify the device.

    dwTSPIVersion - The TSPI version negotiated through 
        TSPI_lineNegotiateTSPIVersion under which the Service Provider is 
        willing to operate.

    pfnEventProc - A far pointer to the LINEEVENT callback procedure supplied
        by the TAPI DLL that the Service Provider will call to report 
        subsequent events on the line.

Return Values:

    Returns zero if the function is successful, or a negative error number 
    if an error has occurred. Possible return values are as follows:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The passed TSPI version or version 
            range did not match an interface version definition supported by 
            the service provider.

        LINEERR_INUSE - The line device is in use and cannot currently be 
            configured, allow a party to be added, allow a call to be 
            answered, or allow a call to be placed. 

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 

--*/
LONG
TSPIAPI
TSPI_lineOpen (
    IN  DWORD       DeviceID,
    IN  HTAPILINE   TapiLine,
    IN  LPHDRVLINE  ReturnDriverLine,
    IN  DWORD       TspiVersion,
    IN  LINEEVENT   pfnEventProc)
{
    return g_H323Line.Open (DeviceID, TapiLine, TspiVersion, ReturnDriverLine);
}


LONG
TSPIAPI
TSPI_lineCreateMSPInstance(
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPIMSPLINE    htMSPLine,
    LPHDRVMSPLINE   phdMSPLine
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCreateMSPInstance - Entered." ));

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_RESOURCEUNAVAIL;
    }

    // We are not keeping the msp handles. Just fake a handle here.
    *phdMSPLine = g_pH323Line->GetNextMSPHandle();

    if( !g_pH323Line->AddMSPInstance( htMSPLine , *phdMSPLine ) )
    {
        return LINEERR_NOMEM;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "MSP instance created. hdMSP:%lx, htMSP:%lx.",
        *phdMSPLine, htMSPLine ));

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCreateMSPInstance - Exited." ));
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineCloseMSPInstance(
    HDRVMSPLINE hdMSPLine
    )
{
    HTAPIMSPLINE    htMSPLine;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCloseMSPInstance - Entered." ));

    if( !g_pH323Line->DeleteMSPInstance( &htMSPLine , hdMSPLine ) )
    {
        return LINEERR_INVALPOINTER;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "MSP instance deleted. hdMSP:%lx, htMSP:%lx.",
        hdMSPLine, htMSPLine ));

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCloseMSPInstance - Exited." ));

    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\q931obj.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    q931obj.cpp

Abstract:

    Functionality for accepting the Q931 connections.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#include "globals.h"
#include "q931obj.h"
#include "line.h"
#include "q931pdu.h"
#include "winbase.h"
#include "ras.h"



class   Q931_BUFFER_CACHE
{
private:

    enum { RECV_BUFFER_LIST_COUNT_MAX = 0x10 };

    CRITICAL_SECTION        m_CriticalSection;
    LIST_ENTRY              m_FreeRecvBufferList;
    DWORD                   m_FreeRecvBufferListCount;

private:

    void    Lock    (void)  { EnterCriticalSection (&m_CriticalSection); }
    void    Unlock  (void)  { LeaveCriticalSection (&m_CriticalSection); }

public:

    Q931_BUFFER_CACHE   (void);
    ~Q931_BUFFER_CACHE  (void);

    BOOL    AllocRecvBuffer     (
        OUT RECVBUF **  ReturnRecvBuffer);

    void    FreeRecvBuffer      (
        IN  RECVBUF *   RecvBuffer);

    void    FreeAll     (void);
};


// global data

        Q931_LISTENER       Q931Listener;
static  Q931_BUFFER_CACHE   Q931BufferCache;


HRESULT 
Q931AcceptStart (void)
{
    return Q931Listener.Start();
}


void 
Q931AcceptStop (void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "Q931AcceptStop entered." ));
    
    Q931Listener.Stop();
    Q931Listener.WaitIo();

    H323DBG(( DEBUG_LEVEL_TRACE, "Q931AcceptStop exited." ));
}


void 
Q931FreeRecvBuffer (
    IN  RECVBUF *   RecvBuffer)
{
    Q931BufferCache.FreeRecvBuffer (RecvBuffer);
}


BOOL 
Q931AllocRecvBuffer (
    OUT RECVBUF **  ReturnRecvBuffer)
{
    return Q931BufferCache.AllocRecvBuffer (ReturnRecvBuffer);
}

// Q931_LISTENER ---------------------------------------------------------

Q931_LISTENER::Q931_LISTENER (void)
{
    // No need to check the result of this one since this object is
    // not allocated on heap, right when the DLL is loaded
    InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 0x80000000 );

    m_ListenSocket = INVALID_SOCKET;

    InitializeListHead (&m_AcceptPendingList);

    H225ASN_Module_Startup();
    H4503PP_Module_Startup();

    _ASSERTE( H225ASN_Module );
    _ASSERTE( H4503PP_Module );

    m_StopNotifyEvent = H323CreateEvent (NULL, TRUE, TRUE, 
        _T( "H323TSP_StopIncomingCallNotify" ) );

    if( m_StopNotifyEvent == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Q931: failed to create stop notify event -- will be unable to accept Q.931 connections" ));
    }
}


Q931_LISTENER::~Q931_LISTENER (void)
{
    DeleteCriticalSection (&m_CriticalSection);

    _ASSERTE( m_ListenSocket == INVALID_SOCKET );
    _ASSERTE( IsListEmpty (&m_AcceptPendingList) );

    if (m_StopNotifyEvent)
    {
        CloseHandle (m_StopNotifyEvent);
        m_StopNotifyEvent = NULL;
    }

    if( H225ASN_Module )
    {
        H225ASN_Module_Cleanup();
    }

    if( H4503PP_Module )
    {
        H4503PP_Module_Cleanup();
    }
}


HRESULT Q931_LISTENER::Start (void)
{
    HRESULT hr;

    Lock();

    hr = StartLocked();
    if (hr != S_OK)
    {
        if (m_ListenSocket != INVALID_SOCKET)
        {
            closesocket (m_ListenSocket);
            m_ListenSocket = INVALID_SOCKET;
        }
    }

    Unlock();

    return hr;
}


HRESULT Q931_LISTENER::StartLocked (void)
{
    INT SocketAddressLength;

    if( m_ListenSocket != INVALID_SOCKET )
    {
        return S_OK;
    }

    m_ListenSocket = WSASocket( 
        AF_INET, 
        SOCK_STREAM, 
        IPPROTO_TCP, 
        NULL, 
        0, 
        WSA_FLAG_OVERLAPPED );

    if (m_ListenSocket == INVALID_SOCKET)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "Q931: failed to create listen socket" ));
        DumpError (GetLastError());
        return GetLastResult();
    }

    m_SocketAddress.sin_family = AF_INET;
    m_SocketAddress.sin_addr.s_addr = htonl (INADDR_ANY);
    m_SocketAddress.sin_port = 
        htons( (WORD)g_RegistrySettings.dwQ931ListenPort );

    if( bind( m_ListenSocket,
            (SOCKADDR *)&m_SocketAddress, 
            sizeof (SOCKADDR_IN) )
            == SOCKET_ERROR)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Q931: failed to bind to requested port (%d), will try to use dynamic port.",
            g_RegistrySettings.dwQ931ListenPort));

        //ReportTSPEvent( _T("Q931 listen socket failed to bind to port 1720") );

        if( g_RegistrySettings.fIsGKEnabled )
        {
            m_SocketAddress.sin_port = htons (0);

            if( bind( m_ListenSocket, (SOCKADDR *)&m_SocketAddress,
                    sizeof (SOCKADDR_IN) ) == SOCKET_ERROR )
            {
                H323DBG ((DEBUG_LEVEL_ERROR,"Q931: failed to request dynamic "
                    "port for Q.931-cannot accept Q.931 connections" ));

                return E_FAIL;
            }
        }
    }

    SocketAddressLength = sizeof (SOCKADDR_IN);

    if( getsockname( m_ListenSocket,
            (SOCKADDR *)&m_SocketAddress, 
            &SocketAddressLength) )
    {
        H323DBG(( DEBUG_LEVEL_WARNING, 
            "Q931: failed to query socket address from TCP -- unexpected behavior"));

        return E_FAIL;
    }

    if( listen( m_ListenSocket, Q931_CONN_QUEUE_LEN) == SOCKET_ERROR )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "Q931: failed to begin listening on socket:%d",
            WSAGetLastError() ));
        return E_FAIL;
    }

    if( !H323BindIoCompletionCallback( (HANDLE)m_ListenSocket,
        Q931_LISTENER::IoCompletionCallback, 0) )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "Q931: failed to bind listen socket to i/o completion callback" ));
        return E_FAIL;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, 
        "Q931: listen socket created, bound, and ready to receive connections" ));


    // all looks good
    // issue initial accept buffer(s)

    AllocIssueAccept();
    AllocIssueAccept();
    AllocIssueAccept();
    AllocIssueAccept();

    return S_OK;
}


void 
Q931_LISTENER::Stop(void)
{
    Lock();

    if (m_ListenSocket != INVALID_SOCKET)
    {
        // this implicitly cancels all outstanding I/O against this socket
        closesocket (m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
    }

    Unlock();
}


void 
Q931_LISTENER::WaitIo(void)
{
    WaitForSingleObject (m_StopNotifyEvent, INFINITE);
}


WORD 
Q931_LISTENER::GetListenPort(void)
{
    SOCKADDR_IN socketAddress;  
    int SocketAddressLength = sizeof (SOCKADDR_IN);
    ZeroMemory( (PVOID)&socketAddress, sizeof(SOCKADDR_IN) );

    Lock();

    if( getsockname( m_ListenSocket,
            (SOCKADDR *)&socketAddress, 
            &SocketAddressLength) )
    {
        H323DBG(( DEBUG_LEVEL_WARNING, 
            "Q931: failed to query socket address from TCP -- unexpected behavior"));

        Unlock();
        return 0;
    }

    Unlock();
    return ntohs(socketAddress.sin_port);
}


void
Q931_LISTENER::HandleRegistryChange()
{
    if( g_pH323Line -> GetState() == H323_LINESTATE_LISTENING )
    {
        if( g_RegistrySettings.dwQ931ListenPort != GetListenPort() )
        {
            Q931AcceptStop();
            Q931AcceptStart();
        }
    }
}


HRESULT 
Q931_LISTENER::AllocIssueAccept (void)
{
    Q931_ACCEPT_OVERLAPPED *    AcceptOverlapped;
    HRESULT     hr;

    _ASSERTE( m_ListenSocket != INVALID_SOCKET );

    AcceptOverlapped = new Q931_ACCEPT_OVERLAPPED;
    if( AcceptOverlapped != NULL )
    {
        hr = IssueAccept (AcceptOverlapped);
        if (hr != S_OK)
        {
            delete AcceptOverlapped;
        }
    }
    else
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Q931: failed to allocate connection accept buffer" ));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT 
Q931_LISTENER::IssueAccept (
    IN  Q931_ACCEPT_OVERLAPPED *    AcceptOverlapped
    )
{
    HRESULT     hr;

    _ASSERTE( m_ListenSocket != INVALID_SOCKET );

    ZeroMemory (AcceptOverlapped, sizeof (Q931_ACCEPT_OVERLAPPED));

    AcceptOverlapped -> ParentObject = this;

    AcceptOverlapped -> Socket = WSASocket (
        AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

    if (AcceptOverlapped -> Socket == INVALID_SOCKET)
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "Q931: failed to create new accept socket"));
        DumpLastError();

        return GetLastResult();
    }

    if (!AcceptEx (m_ListenSocket,
        AcceptOverlapped -> Socket,
        AcceptOverlapped -> DataBuffer,
        0,
        sizeof (SOCKADDR_IN) + 0x10,
        sizeof (SOCKADDR_IN) + 0x10,
        &AcceptOverlapped -> BytesTransferred,
        &AcceptOverlapped -> Overlapped)
        && GetLastError() != ERROR_IO_PENDING)
    {
        hr = GetLastResult();

        H323DBG ((DEBUG_LEVEL_ERROR, "Q931: failed to issue accept on new socket"));
        DumpLastError();

        closesocket (AcceptOverlapped -> Socket);

        return hr;
    }

    if (IsListEmpty (&m_AcceptPendingList))
    {
        ResetEvent (m_StopNotifyEvent);
    }

    InsertTailList (&m_AcceptPendingList, &AcceptOverlapped -> ListEntry);

    H323DBG ((DEBUG_LEVEL_TRACE, 
        "Q931: created new accept socket (%08XH), issued accept request.",
        (DWORD) AcceptOverlapped -> Socket));

    return S_OK;
}


// static
void 
Q931_LISTENER::IoCompletionCallback (
    IN  DWORD           dwStatus,
    IN  DWORD           BytesTransferred,
    IN  OVERLAPPED *    Overlapped
    )
{
    Q931_ACCEPT_OVERLAPPED *    AcceptOverlapped;

    _ASSERTE( Overlapped );

#if _WIN64
    _ASSERTE( (DWORD_PTR) Overlapped != 0xfeeefeeefeeefeee);
    _ASSERTE( (DWORD_PTR) Overlapped != 0xbaadf00dbaadf00d);
#else
    _ASSERTE( (DWORD) Overlapped != 0xfeeefeee);
    _ASSERTE( (DWORD) Overlapped != 0xbaadf00d);
#endif

    AcceptOverlapped = CONTAINING_RECORD(Overlapped, 
        Q931_ACCEPT_OVERLAPPED, Overlapped);
    AcceptOverlapped -> BytesTransferred = BytesTransferred;
    AcceptOverlapped -> ParentObject -> CompleteAccept( dwStatus, AcceptOverlapped );
}


void 
Q931_LISTENER::CompleteAccept(
    IN DWORD                    dwStatus,
    IN Q931_ACCEPT_OVERLAPPED * AcceptOverlapped
    )
{
    SOCKET          Socket = INVALID_SOCKET;
    SOCKADDR_IN     RemoteAddress;
    SOCKADDR_IN *   RemoteAddressPointer;
    INT             RemoteAddressLength;
    SOCKADDR_IN     LocalAddress;
    SOCKADDR_IN *   LocalAddressPointer;
    INT             LocalAddressLength;
    HRESULT         hr;
    DWORD               dwEnable = 1;

    Lock();

    _ASSERTE( IsInList (&m_AcceptPendingList, &AcceptOverlapped -> ListEntry) );
    RemoveEntryList (&AcceptOverlapped -> ListEntry);

    if (IsListEmpty (&m_AcceptPendingList))
    {
        SetEvent (m_StopNotifyEvent);
    }

    if (m_ListenSocket != INVALID_SOCKET)
    {
        if (dwStatus == ERROR_SUCCESS)
        {
            // extract parameters from accepted socket, copy to local stack frame.
            // this is necessary, because we will recycle AcceptOverlapped (with
            // a newly allocated socket) and process the new client later.
            // this gives a high degree of concurrency.

            RemoteAddressPointer = NULL;
            LocalAddressPointer = NULL;

            RemoteAddressLength = sizeof RemoteAddress;
            LocalAddressLength = sizeof LocalAddress;

            GetAcceptExSockaddrs (AcceptOverlapped -> DataBuffer,
                0, sizeof (SOCKADDR_IN), sizeof (SOCKADDR_IN),
                (SOCKADDR **) &RemoteAddressPointer,
                &RemoteAddressLength,
                (SOCKADDR **) &LocalAddressPointer,
                &LocalAddressLength);

            _ASSERTE( RemoteAddressPointer );
            _ASSERTE( LocalAddressPointer );

            if( (RemoteAddressPointer == NULL) || (LocalAddressPointer == NULL) )
            {
                return;
            }

            RemoteAddress = *RemoteAddressPointer;
            LocalAddress = *LocalAddressPointer;
            Socket = AcceptOverlapped -> Socket;

            if( setsockopt( AcceptOverlapped -> Socket, 
                    SOL_SOCKET, 
                    SO_UPDATE_ACCEPT_CONTEXT, 
                    reinterpret_cast <char *> (&m_ListenSocket), 
                    sizeof m_ListenSocket))
            {
                H323DBG(( DEBUG_LEVEL_WARNING, 
                    "Q931: successfully accepted socket, but SO_UPDATE_ACCEPT_CONTEXT"
                    "failed -- future operations will fail" ));
                // don't fail here
            }

            if( setsockopt( Socket, IPPROTO_TCP, TCP_NODELAY, (char*)&dwEnable,
                sizeof(DWORD) ) == SOCKET_ERROR )
            {
                H323DBG(( DEBUG_LEVEL_WARNING, 
                    "Couldn't set NODELAY option on outgoing call socket:%d, %p", 
                    WSAGetLastError(), this ));
            }
        }
        else 
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "Q931: failed to accept connection"));
            DumpError (dwStatus);

            Socket = INVALID_SOCKET;

            // we will allocate a new socket in IssueAccept
            // if we hit an error accepting on this socket,
            // it can't hurt to use a new socket, anyway.
            closesocket (AcceptOverlapped -> Socket);
        }

        // post the accept context for a new receive

        hr = IssueAccept (AcceptOverlapped);
        if (hr != S_OK)
        {
            H323DBG(( DEBUG_LEVEL_WARNING, "Q931: failed to issue accept on "
                "buffer -- reception of new Q.931 connections may stall" ));

            delete AcceptOverlapped;
        }
    }
    else
    {
        // future accept requests are denied -- module is shutting down.

        if( AcceptOverlapped -> Socket != INVALID_SOCKET )
        {
            closesocket( AcceptOverlapped -> Socket );
            AcceptOverlapped -> Socket = INVALID_SOCKET;
        }

        delete AcceptOverlapped;
    }

    Unlock();

    if (Socket != INVALID_SOCKET)
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "Q931: accepted connection, remote address %08XH:%04X.",
            SOCKADDR_IN_PRINTF (&RemoteAddress)));

        // hand the newly accepted connection off to the call processing code.
        CallProcessIncomingCall (Socket, &LocalAddress, &RemoteAddress);
    }
}



// Q931_BUFFER_CACHE ----------------------------------------------------

Q931_BUFFER_CACHE::Q931_BUFFER_CACHE (void)
{
    // No need to check the result of this one since this object is
    // not allocated on heap, right when the DLL is loaded
    InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 0x80000000 );

    InitializeListHead (&m_FreeRecvBufferList);
    m_FreeRecvBufferListCount = 0;
}

Q931_BUFFER_CACHE::~Q931_BUFFER_CACHE (void)
{
    Q931BufferCache.FreeAll();
    DeleteCriticalSection( &m_CriticalSection );
}


BOOL Q931_BUFFER_CACHE::AllocRecvBuffer (
    OUT RECVBUF **  ReturnRecvBuffer
    )
{
    LIST_ENTRY *    ListEntry;
    RECVBUF *       RecvBuffer;

    Lock();

    if (m_FreeRecvBufferListCount > 0)
    {
        m_FreeRecvBufferListCount--;

        _ASSERTE( IsListEmpty (&m_FreeRecvBufferList) == FALSE );
        ListEntry = RemoveHeadList (&m_FreeRecvBufferList);
        RecvBuffer = CONTAINING_RECORD (ListEntry, RECVBUF, ListEntry);
    }
    else
    {
        // perform global heap allocation after unlocking (better concurrency)
        RecvBuffer = NULL;
    }

    Unlock();

    if( RecvBuffer == NULL )
    {
        RecvBuffer = new RECVBUF;
    }

    *ReturnRecvBuffer = RecvBuffer;
    return !!RecvBuffer;
}


void 
Q931_BUFFER_CACHE::FreeRecvBuffer (
    IN  RECVBUF *   RecvBuffer
    )
{
    Lock();

    _ASSERTE( !IsInList (&m_FreeRecvBufferList, &RecvBuffer -> ListEntry));

    if (m_FreeRecvBufferListCount < RECV_BUFFER_LIST_COUNT_MAX)
    {
        InsertHeadList (&m_FreeRecvBufferList, &RecvBuffer -> ListEntry);
        m_FreeRecvBufferListCount++;
        RecvBuffer = NULL;
    }

    Unlock();

    if( RecvBuffer )
    {
        delete RecvBuffer;
    }
}

void 
Q931_BUFFER_CACHE::FreeAll (void)
{
    LIST_ENTRY *    ListEntry;
    RECVBUF *       RecvBuffer;

    Lock();

    while( IsListEmpty(&m_FreeRecvBufferList) == FALSE )
    {
        _ASSERTE( m_FreeRecvBufferListCount > 0 );
        m_FreeRecvBufferListCount--;

        ListEntry = RemoveHeadList (&m_FreeRecvBufferList);
        RecvBuffer = CONTAINING_RECORD (ListEntry, RECVBUF, ListEntry);

        delete RecvBuffer;
    }

    _ASSERTE( m_FreeRecvBufferListCount == 0 );

    Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\q931obj.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    q931obj.h

Abstract:

    
Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#ifndef _Q931_OBJ_H_
#define _Q931_OBJ_H_

#define Q931_RECV_BUFFER_LENGTH     0x2000

typedef struct _RECVBUF
{
     WSABUF  WSABuf;
	 union {
     OVERLAPPED Overlapped;
	 LIST_ENTRY ListEntry;
	 };
     DWORD  dwBytesCopied;
     DWORD  dwPDULen;
     char   arBuf[Q931_RECV_BUFFER_LENGTH];
} RECVBUF;

void FreeAddressAliases( PSetup_UUIE_destinationAddress pAddr );
void CopyTransportAddress( TransportAddress& transportAddress,
                           PH323_ADDR pCalleeAddr );
void AddressReverseAndCopy( DWORD *dwAddr, BYTE* addrValue );
Setup_UUIE_sourceAddress * SetMsgAddressAlias( 
                        PH323_ALIASNAMES pCallerAliasNames );
void CopyVendorInfo( VendorIdentifier* vendor );




HRESULT	Q931AcceptStart	(void);

void	Q931AcceptStop	(void);

BOOL	Q931AllocRecvBuffer	(
	OUT	RECVBUF **	ReturnRecvBuffer);

void	Q931FreeRecvBuffer (
	IN	RECVBUF *	RecvBuffer);

#define Q931_CONN_QUEUE_LEN         64
#define	ACCEPT_BUFFER_LENGTH		((sizeof(SOCKADDR_IN) + 0x10) * 2)

class	Q931_LISTENER;

struct	Q931_ACCEPT_OVERLAPPED
{
	OVERLAPPED		Overlapped;
	LIST_ENTRY		ListEntry;
	Q931_LISTENER *	ParentObject;
	SOCKET			Socket;
	DWORD			BytesTransferred;
	BYTE			DataBuffer	[ACCEPT_BUFFER_LENGTH];
};


class	Q931_LISTENER
{
private:

	CRITICAL_SECTION	m_CriticalSection;
	SOCKET				m_ListenSocket;
	LIST_ENTRY			m_AcceptPendingList;	// contains ACCEPT_OVERLAPPED.ListEntry
	HANDLE				m_StopNotifyEvent;
	SOCKADDR_IN			m_SocketAddress;		// address (actually, only port) listening on

private:

    static void NTAPI IoCompletionCallback (
		IN	DWORD	dwStatus,
		IN	DWORD	BytesTransferred,
		IN	OVERLAPPED *	Overlapped);

    void	Lock	(void)	{ EnterCriticalSection (&m_CriticalSection); }
    void	Unlock	(void)	{ LeaveCriticalSection (&m_CriticalSection); }

	HRESULT	StartLocked	(void);

	HRESULT	AllocIssueAccept	(void);

	HRESULT	IssueAccept (
		IN	Q931_ACCEPT_OVERLAPPED *	AcceptOverlapped);

	void	CompleteAccept (
		IN	DWORD		dwStatus,
		IN	Q931_ACCEPT_OVERLAPPED *	AcceptOverlapped);

public:

	Q931_LISTENER	(void);
    ~Q931_LISTENER	(void);

	HRESULT		Start	(void);
	void		Stop	(void);
	void		WaitIo	(void);
    WORD        GetListenPort (void);
    void        HandleRegistryChange();

};

#endif //_Q931_OBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\provider.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    provider.cpp

Abstract:

    TAPI Service Provider functions related to provider info.

        TSPI_providerConfig
        TSPI_providerEnumDevices
        TSPI_providerFreeDialogInstance
        TSPI_providerGenericDialogData
        TSPI_providerInit
        TSPI_providerInstall
        TSPI_providerRemove
        TSPI_providerShutdown
        TSPI_providerUIIdentify

        TUISPI_providerConfig
        TUISPI_providerInstall
        TUISPI_providerRemove

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "config.h"
#include "q931obj.h"
#include "ras.h"
     

//                                                                           
// Global variables                                                          
//                                                                           


DWORD				g_dwLineDeviceIDBase = -1;
DWORD				g_dwPermanentProviderID = -1;
LINEEVENT			g_pfnLineEventProc = NULL;
HANDLE              g_hCanUnloadDll = NULL;
HANDLE              g_hEventLogSource = NULL;
static	HPROVIDER   g_hProvider = NULL;
ASYNC_COMPLETION	g_pfnCompletionProc = NULL;



//                                                                           //
// Public procedures                                                         //
//                                                                           //

BOOL
H323IsTSPAlreadyInstalled(void)

/*++

Routine Description:

    Searchs registry for previous instance of H323.TSP.

Arguments:

    None.

Return Values:

    Returns true if TSP already installed.

--*/

{
    DWORD i;
    HKEY hKey;
    LONG lStatus;
    DWORD dwNumProviders = 0;
    DWORD dwDataSize = sizeof(DWORD);
    DWORD dwDataType = REG_DWORD;
    LPTSTR pszProvidersKey = TAPI_REGKEY_PROVIDERS;
    LPTSTR pszNumProvidersValue = TAPI_REGVAL_NUMPROVIDERS;
    TCHAR szName[H323_MAXPATHNAMELEN+1];
    TCHAR szPath[H323_MAXPATHNAMELEN+1];

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszProvidersKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "error 0x%08lx opening tapi providers key.", lStatus ));

        // done
        return FALSE;
    }

    // see if installed bit set
    lStatus = RegQueryValueEx(
                hKey,
                pszNumProvidersValue,
                0,
                &dwDataType,
                (LPBYTE) &dwNumProviders,
                &dwDataSize
                );

    // validate status
    if( lStatus != NOERROR )
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "error 0x%08lx determining number of providers.", lStatus ));

        // release handle
        RegCloseKey(hKey);

        // done
        return FALSE;
    }

    // loop through each provider
    for (i = 0; i < dwNumProviders; i++)
    {
        // construct path to provider name
        wsprintf(szName, _T("ProviderFileName%d"), i);

        // reinitialize size
        dwDataSize = sizeof(szPath);

        // query the next name
        lStatus = RegQueryValueEx(
                        hKey,
                        szName,
                        0,
                        &dwDataType,
                        (unsigned char*)szPath,
                        &dwDataSize
                        );

        // validate status
        if (lStatus == NOERROR)
        {
            // upper case
            _tcsupr(szPath);

            // compare path string to h323 provider
            if (_tcsstr(szPath, H323_TSPDLL) != NULL)
            {
                // release handle
                RegCloseKey(hKey);

                // done
                return TRUE;
            }

        } else {

            H323DBG((
                DEBUG_LEVEL_WARNING,
                "error 0x%08lx loading %s.",
                lStatus,
                szName
                ));
        }
    }

    // release handle
    RegCloseKey(hKey);

    // done
    return FALSE;
}



//                                                                           
// TSPI procedures                                                           
//                                                                           


/*++

Routine Description:


    This function is called by TAPI in response to receipt of a LINE_CREATE
    message from the service provider, which allows the dynamic creation of
    a new line device.

Arguments:

    dwTempID - The temporary device identifier that the service provider
        passed to TAPI in the LINE_CREATE message.

    dwDeviceID - The device identifier that TAPI assigns to this device if
        this function succeeds.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    DWORD_PTR dwTempID,
    DWORD dwDeviceID
    )
{
    //in the new TSP we don't support creating multiple H323 lines. 
    //So return success silently but assert in the debug version
    _ASSERTE(0);

    /*H323DBG(( DEBUG_LEVEL_TRACE,
        "creating new device %d (hdLine=0x%08lx).",
        dwDeviceID, dwTempID ));

    // lock line device using temporary device id
    if (!H323GetLineFromIDAndLock(&pLine, (DWORD)dwTempID))
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "invalid temp device id 0x%08lx.", dwTempID ));

        // failure
        return LINEERR_BADDEVICEID;
    }

    // initialize new line device
    H323InitializeLine(pLine, dwDeviceID);

    // unlock line
    H323UnlockLine(pLine);*/

    // success
    return NOERROR;
}



/*++

Routine Description:

    TAPI.DLL calls this function before TSPI_providerInit to determine the
    number of line and phone devices supported by the service provider.

Arguments:

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        initialized.

    pdwNumLines - Specifies a far pointer to a DWORD-sized memory location
        into which the service provider must write the number of line devices
        it is configured to support. TAPI.DLL initializes the value to zero,
        so if the service provider fails to write a different value, the
        value 0 is assumed.

    pdwNumPhones - Specifies a far pointer to a DWORD-sized memory location
        into which the service provider must write the number of phone devices
        it is configured to support. TAPI.DLL initializes the value to zero,
        so if the service provider fails to write a different value, the
        value 0 is assumed.

    hProvider - Specifies an opaque DWORD-sized value which uniquely identifies
        this instance of this service provider during this execution of the
        Windows Telephony environment.

    pfnLineCreateProc - Specifies a far pointer to the LINEEVENT callback
        procedure supplied by TAPI.DLL. The service provider will use this
        function to send LINE_CREATE messages when a new line device needs to
        be created. This function should not be called to send a LINE_CREATE
        message until after the service provider has returned from the
        TSPI_providerInit procedure.

    pfnPhoneCreateProc - Specifies a far pointer to the PHONEEVENT callback
        procedure supplied by TAPI.DLL. The service provider will use this
        function to send PHONE_CREATE messages when a new phone device needs
        to be created. This function should not be called to send a
        PHONE_CREATE message until after the service provider has returned
        from the TSPI_providerInit procedure.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/
LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD      dwPermanentProviderID,
    PDWORD     pdwNumLines,
    PDWORD     pdwNumPhones,
    HPROVIDER  hProvider,
    LINEEVENT  pfnLineCreateProc,
    PHONEEVENT pfnPhoneCreateProc
    )
{
    WSADATA wsaData;
    WORD wVersionRequested = H323_WINSOCKVERSION;

    UNREFERENCED_PARAMETER(pdwNumPhones);           // no phone support
    UNREFERENCED_PARAMETER(pfnPhoneCreateProc);     // no dynamic phones
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // legacy parameter
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerEnumDevices - Entered." ));

    // initialize winsock stack
    WSAStartup(wVersionRequested, &wsaData);

    // save provider handle
    g_hProvider = hProvider;

    	
    // save line create tapi callback
    g_pfnLineEventProc = pfnLineCreateProc;
    _ASSERTE(g_pfnLineEventProc);

    H323DBG(( DEBUG_LEVEL_VERBOSE, "service provider supports 1 line."));

    // report number of interfaces
    *pdwNumLines = 1;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerEnumdevices - Exited." ));

    // success
    return NOERROR;
}


static LONG H323Initialize (
	IN	DWORD	LineDeviceIDBase)
{
	HRESULT		hr;

    H323DBG(( DEBUG_LEVEL_TRACE, "H323Initialize - Entered." ));

    if (!g_pH323Line -> Initialize (LineDeviceIDBase))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "init failed for h323 line." ));
        return ERROR_GEN_FAILURE;
    }

	RegistryStart();

    g_hCanUnloadDll = H323CreateEvent( NULL, TRUE, TRUE, 
        _T( "H323TSP_DLLUnloadEvent" ) );

    if( g_hCanUnloadDll == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not create unloadDLL handle." ));
        return ERROR_GEN_FAILURE;
    }

#if	H323_USE_PRIVATE_IO_THREAD

	hr = H323IoThreadStart();
	if (hr != S_OK)
		return ERROR_GEN_FAILURE;

#endif

    H323DBG(( DEBUG_LEVEL_TRACE, "H323Initialize - Exited." ));

    return ERROR_SUCCESS;
}


void ReportTSPEvent( 
    LPCTSTR wszErrorMessage )
{
    if( g_hEventLogSource )
    {
        ReportEvent(
			    g_hEventLogSource,	// handle of event source
			    EVENTLOG_ERROR_TYPE,// event type
			    0,					// event category
			    0x80000001,			// event ID
			    NULL,				// user SID
			    1,		            // string count
			    0,					// no bytes of raw data
			    &wszErrorMessage,	// array of error strings
			    NULL);				// no raw data
    }
}


static 
VOID H323Shutdown (void)
{
    g_pH323Line -> Shutdown();

	RegistryStop();

    if( g_hCanUnloadDll != NULL )
    {
        H323DBG(( DEBUG_LEVEL_WARNING, "waiting for i/o refcount to get 0..." ));

        //wait until all the calls have been deleted
        WaitForSingleObject( 
            g_hCanUnloadDll, 
            300 * 1000        // Wait for 5 minutes to let everything shutdown.
            );

        H323DBG ((DEBUG_LEVEL_WARNING, "i/o refcount is 0..."));

        CloseHandle( g_hCanUnloadDll );
        g_hCanUnloadDll = NULL;

        //sleep for 500 ms
        Sleep( 500 );
    }

#if	H323_USE_PRIVATE_IO_THREAD

	H323IoThreadStop();

#endif

    if( g_hEventLogSource  )
    {
		DeregisterEventSource( g_hEventLogSource  );
		g_hEventLogSource = NULL;
	}

    // shutdown
    WSACleanup();
}


/*++

Routine Description:

    Initializes the service provider, also giving it parameters required for
    subsequent operation.

    This function is guaranteed to be called before any of the other functions
    prefixed with TSPI_line or TSPI_phone except TSPI_lineNegotiateTSPIVersion.
    It is strictly paired with a subsequent call to TSPI_providerShutdown. It
    is the caller's reponsibility to ensure proper pairing.

    Note that a service provider should perform as many consistency checks as
    is practical at the time TSPI_providerInit is called to ensure that it is
    ready to run. Some consistency or installation errors, however, may not be
    detectable until the operation is attempted. The error LINEERR_NODRIVER can
    be used to report such non-specific errors at the time they are detected.

    There is no directly corresponding function at the TAPI level. At that
    level, multiple different usage instances can be outstanding, with an
    "application handle" returned to identify the instance in subsequent
    operations. At the TSPI level, the interface architecture supports only a
    single usage instance for each distinct service provider.

    A new parameter, lpdwTSPIOptions, is added to this function. This parameter
    allows the service provider to return bits indicating optional behaviors
    desired of TAPI. TAPI sets the options DWORD to 0 before calling
    TSPI_providerInit, so if the service provider doesn't want any of these
    options, it can just leave the DWORD set to 0.

    At this time, only one bit is defined to be returned through this pointer:
    LINETSPIOPTION_NONREENTRANT. The service provider sets this bit if it is
    not designed for fully pre-emptive, multithreaded, multitasking,
    multiprocessor operation (e.g., updating of global data protected by
    mutexes). When this bit is set, TAPI will only make one call at a time to
    the service provider; it will not call any other entry point, nor that
    entry point again, until the service provider returns from the original
    function call. Without this bit set, TAPI may call into multiple service
    provider entry points, including multiple times to the same entry point,
    simultaneously (actually simultaneously in a multiprocessor system). Note:
    TAPI will not serialize access to TSPI functions that display a dialog
    (TUISPI_lineConfigDialog, TUISPI_lineConfigDialogEdit,
    TUISPI_phoneConfigDialog, TUISPI_providerConfig, TUISPI_providerInstall,
    TUISPI_providerRemove) so that they do not block other TSPI functions
    from being called; the service provider must include internal protection
    on these functions.

Arguments:

    dwTSPIVersion - Specifies the version of the TSPI definition under which
        this function must operate. The caller may use
        TSPI_lineNegotiateTSPIVersion with the special dwDeviceID
        INITIALIZE_NEGOTIATION to negotiate a version that is guaranteed to be
        acceptible to the service provider.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        initialized.

    dwLineDeviceIDBase - Specifies the lowest device ID for the line devices
        supported by this service provider.

    dwPhoneDeviceIDBase - Specifies the lowest device ID for the phone devices
        supported by this service provider.

    dwNumLines - Specifies how many line devices this service provider
        supports.

    dwNumPhones - Specifies how many line devices this service provider
        supports.

    pfnCompletionProc - Specifies the procedure the service provider calls to
        report completion of all asynchronously operating procedures on line
        and phone devices.

    pdwTSPIOptions - A pointer to a DWORD-sized memory location, into which
        the service provider may write a value specifying LINETSPIOPTIONS_
        values.

Return Values:

    Returns zero if the function is successful, or a negative error number if
    an error has occurred. Possible return values are as follows:

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot be
            supported by the Telephony API implementation and/or corresponding
            service provider.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

        LINEERR_RESOURCEUNAVAIL - Insufficient resources to complete the
            operation.

--*/


LONG
TSPIAPI
TSPI_providerInit(
    DWORD            dwTSPIVersion,
    DWORD            dwPermanentProviderID,
    DWORD            dwLineDeviceIDBase,
    DWORD            dwPhoneDeviceIDBase,
    DWORD_PTR        dwNumLines,
    DWORD_PTR        dwNumPhones,
    ASYNC_COMPLETION pfnCompletionProc,
    LPDWORD          pdwTSPIOptions
    )
{
	LONG	dwStatus;

	UNREFERENCED_PARAMETER (dwNumLines);             // legacy parameter
	UNREFERENCED_PARAMETER (dwNumPhones);            // legacy parameter
	UNREFERENCED_PARAMETER (dwPhoneDeviceIDBase);    // no phone support
	UNREFERENCED_PARAMETER (pdwTSPIOptions);         // already thread-safe

#if DBG
    // Register for trace output.
    TRACELogRegister(_T("h323tsp"));
#else
    OpenLogFile();
#endif

    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion)) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "provider init::incompatible tspi version." ));

        // incompatible api version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    dwStatus = H323Initialize (dwLineDeviceIDBase);

    if (dwStatus == ERROR_SUCCESS)
    {
	    // save global service provider info

	    // we don't store dwTSPIVersion, because our behavior does not change based
	    // on any negotiated version.
	    // if this changes in the future, then we will record the negotiated version.

	    g_pfnCompletionProc = pfnCompletionProc;
        _ASSERTE( g_pfnCompletionProc );

	    g_dwLineDeviceIDBase    = dwLineDeviceIDBase;
	    g_dwPermanentProviderID = dwPermanentProviderID;
    }
    else
    {
	    H323Shutdown();
    }
    
    return dwStatus;
}



LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD dwTSPIVersion,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    Shuts down the service provider. The service provider should terminate
    any activities it has in progress and release any resources it has
    allocated.

Arguments:

    dwTSPIVersion - Specifies the version of the TSPI definition under which
        this function must operate. The caller may use
        TSPI_lineNegotiateTSPIVersion or TSPI_phoneNegotiateTSPIVersion with
        the special dwDeviceID INITIALIZE_NEGOTIATION to negotiate a version
        that is guaranteed to be acceptible to the service provider.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        shut down.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot be
            supported by the Telephony API implementation and/or corresponding
            service provider.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // legacy parameter

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerShutdown - Entered." ));
    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "invalid tspi version." ));

        // failure
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

	H323Shutdown();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerShutdown - Exited." ));
	return ERROR_SUCCESS;
}



LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )

/*++

Routine Description:

    The TSPI_providerInstall function is obsolete. TAPI version 1.4
    or earlier service providers can implement this TSPI function.
    TAPI version 2.0 or later TSPs implement TUISPI_providerInstall.

Arguments:

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Always returns NOERROR.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerRemove(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )

/*++

Routine Description:

    The TSPI_providerRemove function is obsolete. TAPI version 1.4 or
    earlier service providers can implement this TSPI function. TAPI
    version 2.0 or later TSPs implement TUISPI_providerRemove.

Arguments:

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Always returns NOERROR.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineTSPIProviderRemove - Entered." ));
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineTSPIProviderRemove - Exited." ));
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR pwszUIDLLName
   )

/*++

Routine Description:

    The TSPI_providerUIIdentify function extracts from the service
    provider the fully qualified path to load the service provider's
    UI DLL component.

    Implementation is mandatory if the service provider implements
    any UI DLL functions.

Arguments:

    pwszUIDLLName - Pointer to a block of memory at least MAX_PATH
        in length, into which the service provider must copy a NULL-
        terminated string specifying the fully-qualified path for the
        DLL containing the service provider functions which must execute
        in the process of the calling application.

Return Values:

    Always returns NOERROR.

--*/

{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_ProviderUIIdentify - Entered." ));
    
    // copy name of our dll as ui dll
    lstrcpyW(pwszUIDLLName,H323_UIDLL);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_ProviderUIIdentify - Exited." ));

    // success
    return NOERROR;
}


/*++

Routine Description:

    Implementation of the TUISPI_providerInstall function is the
    service provider's opportunity to install any additional
    "pieces" of the provider into the right directories (or at
    least verifying that they're there) and set up registry entries
    the provider needs.

Arguments:

    pfnUIDLLCallback - Pointer to a function the UI DLL can call to
        communicate with the service provider DLL to obtain information
        needed to display the dialog box.

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_NOMULTIPLEINSTANCE - A telephony service provider which
            does not support multiple instances is listed more than once
            in the [Providers] section in the registry. The application

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND              hwndOwner,
    DWORD             dwPermanentProviderID
    )
{
    HKEY hKey;
    HKEY hKeyTSP;
    LONG lStatus;
    LPTSTR pszKey;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    H323DBG(( DEBUG_LEVEL_TRACE, "TUISPI_providerInstall - Entered." ));
    
    // check for previous instance
    if (H323IsTSPAlreadyInstalled())
    {
        // cannot be installed twice
        return LINEERR_NOMULTIPLEINSTANCE;
    }

    // set key to h323
    pszKey = H323_REGKEY_ROOT;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if( lStatus == NOERROR )
    {
        H323DBG((DEBUG_LEVEL_TRACE, 
            "successfully installed H.323 provider." ));

        // release handle
        RegCloseKey(hKey);
    
        H323DBG(( DEBUG_LEVEL_TRACE, "TUISPI_providerInstall - Exited." ));
        
        // success
        return NOERROR;
    }

    // set key to windows
    pszKey = REGSTR_PATH_WINDOWS_CURRENTVERSION;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_WRITE,
                &hKey
                );

    // validate status
    if( lStatus != NOERROR )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "error 0x%08lx opening windows registry key.", lStatus ));

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    // attempt to create key
    lStatus = RegCreateKey(
                hKey,
                H323_SUBKEY,
                &hKeyTSP
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "error 0x%08lx creating tsp registry key.", lStatus ));

        // release handle
        RegCloseKey(hKey);

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "successfully installed H.323 provider." ));

    // release handle
    RegCloseKey(hKeyTSP);

    // release handle
    RegCloseKey(hKey);
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TUISPI_providerInstall - Exited." ));
    // success
    return NOERROR;
}


LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND hwndOwner,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    The TUISPI_providerRemove function asks the user to confirm
    elimination of the service provider.

    It is the responsibility of the service provider to remove any
    registry entries that the service provider added at addProvider
    time, as well as any other modules and files that are no longer
    needed.

Arguments:

    pfnUIDLLCallback - Pointer to a function the UI DLL can call to
        communicate with the service provider DLL to obtain information
        needed to display the dialog box.

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        removal.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    HKEY hKey;
    LONG lStatus;
    LPTSTR pszKey;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // set key to h323
    pszKey = H323_REGKEY_ROOT;

    H323DBG(( DEBUG_LEVEL_FORCE, "TUISPI_providerRemove - Entered." ));
    
    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG ((DEBUG_LEVEL_TRACE, "successfully removed H.323 provider."));
        H323DBG ((DEBUG_LEVEL_TRACE, "TUISPI_providerRemove - Exited."));

        // success
        return NOERROR;
    }

    // release handle
    RegCloseKey(hKey);

    // set key to windows
    pszKey = REGSTR_PATH_WINDOWS_CURRENTVERSION;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_WRITE,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "error 0x%08lx opening windows registry key.", lStatus ));

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    // attempt to delete key
    lStatus = RegDeleteKey(
                hKey,
                H323_SUBKEY
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "error 0x%08lx deleting tsp registry key.", lStatus ));

        // release handle
        RegCloseKey(hKey);

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG(( DEBUG_LEVEL_FORCE, "successfully removed H.323 provider." ));

    // release handle
    RegCloseKey(hKey);
    H323DBG(( DEBUG_LEVEL_TRACE, "TUISPI_providerRemove - Exited." ));
    
    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\line.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    line.h

Abstract:

    Definitions for H.323 TAPI Service Provider line device.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#ifndef _LINE_H_
#define _LINE_H_
 

//                                                                           
// Header files                                                              
//                                                                           


#include "call.h"

extern H323_OCTETSTRING g_ProductID;
extern H323_OCTETSTRING g_ProductVersion;


enum LINEOBJECT_STATE
{
    LINEOBJECT_INITIALIZED  = 0x00000001,
    LINEOBJECT_SHUTDOWN     = 0x00000002,

};


//                                                                           
// Line device GUID                                                          
//                                                                           


DEFINE_GUID(LINE_H323,
0xe41e1898, 0x7292, 0x11d2, 0xba, 0xd6, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);



//                                                                           
// Line capabilities                                                         
//                                                                           
#define H323_MAXADDRSPERLINE        1
#define H323_MAXCALLSPERADDR        32768        
                                
#define H323_LINE_ADDRESSMODES      LINEADDRESSMODE_ADDRESSID
#define H323_LINE_ADDRESSTYPES     (LINEADDRESSTYPE_DOMAINNAME  | \
                                    LINEADDRESSTYPE_IPADDRESS   | \
                                    LINEADDRESSTYPE_PHONENUMBER | \
                                    LINEADDRESSTYPE_EMAILNAME)
#define H323_LINE_BEARERMODES      (LINEBEARERMODE_DATA | \
                                    LINEBEARERMODE_VOICE)
#define H323_LINE_DEFMEDIAMODES     LINEMEDIAMODE_AUTOMATEDVOICE
#define H323_LINE_DEVCAPFLAGS      (LINEDEVCAPFLAGS_CLOSEDROP   | \
                                    LINEDEVCAPFLAGS_MSP         | \
                                    LINEDEVCAPFLAGS_LOCAL )
#define H323_LINE_DEVSTATUSFLAGS   (LINEDEVSTATUSFLAGS_CONNECTED | \
                                    LINEDEVSTATUSFLAGS_INSERVICE)
#define H323_LINE_MAXRATE           1048576 //1 mbps
#define H323_LINE_MEDIAMODES       (H323_LINE_DEFMEDIAMODES | \
                                    LINEMEDIAMODE_INTERACTIVEVOICE | \
                                    LINEMEDIAMODE_VIDEO)
#define H323_LINE_LINEFEATURES     (LINEFEATURE_MAKECALL    | \
                                    LINEFEATURE_FORWARD     | \
                                    LINEFEATURE_FORWARDFWD )    

//
// Type definitions                                                    
//                                                          


typedef enum _H323_LINESTATE 
{
    H323_LINESTATE_NONE = 0, //before call to LineOPen
    H323_LINESTATE_OPENED,        //after call to lineOpen
    H323_LINESTATE_OPENING,
    H323_LINESTATE_CLOSING,
    H323_LINESTATE_LISTENING

} H323_LINESTATE, *PH323_LINESTATE;


typedef struct _TAPI_LINEREQUEST_DATA
{
    DWORD EventID;
    HDRVCALL hdCall1;
    union {
    HDRVCALL hdCall2;
    DWORD    dwDisconnectMode;
    };
    WORD     wCallReference;

} TAPI_LINEREQUEST_DATA;


typedef struct _CTCALLID_CONTEXT
{
    int         iCTCallIdentity;
    HDRVCALL	hdCall;

}CTCALLID_CONTEXT, *PCTCALLID_CONTEXT;


typedef struct _MSPHANDLEENTRY
{

    struct _MSPHANDLEENTRY* next;
    HTAPIMSPLINE            htMSPLine;
    HDRVMSPLINE             hdMSPLine;

} MSPHANDLEENTRY;


typedef TSPTable<PCTCALLID_CONTEXT>   CTCALLID_TABLE;


class CH323Line
{

    CRITICAL_SECTION    m_CriticalSection;                   // synchronization object
    H323_LINESTATE      m_nState;                // state of line object
    DWORD               m_dwTSPIVersion;        // tapi selected version
    DWORD               m_dwMediaModes;         // tapi selected media modes
    H323_CALL_TABLE     m_H323CallTable;        // table of allocated calls
    H323_VENDORINFO     m_VendorInfo;
    DWORD               m_dwDeviceID;           // tapi line device id
    WCHAR               m_wszAddr[H323_MAXADDRNAMELEN+1]; // line address
    HDRVLINE            m_hdLine;               // tspi line handle
    DWORD               m_dwInitState;
    HDRVMSPLINE         m_hdNextMSPHandle;      // bogus msp handle count
    H323_CONF_TABLE     m_H323ConfTable;        // table of allocated calls
    CALLFORWARDPARAMS*  m_pCallForwardParams;
    DWORD               m_dwInvokeID;
    CTCALLID_TABLE      m_CTCallIDTable;
    MSPHANDLEENTRY*     m_MSPHandleList;
    
    void ShutdownAllCalls(void);
    void ShutdownCTCallIDTable();
    PH323_CALL CreateNewTransferedCall( IN PH323_ALIASNAMES pwszCalleeAddr );

public:

    
    
    //public data members
    BOOLEAN             m_fForwardConsultInProgress;
    DWORD               m_dwNumRingsNoAnswer;
    HTAPILINE           m_htLine;   // tapi line handle
    
    //public functions

    CH323Line();
    BOOL Initialize( DWORD dwLineDeviceIDBase );
    ~CH323Line();
    void Shutdown(void);
    
    void RemoveFromCTCallIdentityTable( HDRVCALL hdCall );
    HDRVCALL GetCallFromCTCallIdentity( int iCTCallID );
    int GetCTCallIdentity( IN HDRVCALL hdCall );
    void SetCallForwardParams( IN CALLFORWARDPARAMS* pCallForwardParams );
    BOOL SetCallForwardParams( IN LPFORWARDADDRESS pForwardAddress );
    PH323_CALL FindH323CallAndLock( IN	HDRVCALL hdCall );
    PH323_CALL FindCallByARQSeqNumAndLock( WORD seqNumber );
    PH323_CALL FindCallByDRQSeqNumAndLock( WORD seqNumber );
    PH323_CALL FindCallByCallRefAndLock( WORD wCallRef );
    PH323_CALL Find2H323CallsAndLock( IN	HDRVCALL hdCall1,
        IN HDRVCALL hdCall2, OUT PH323_CALL * ppCall2 );
    BOOL AddMSPInstance( HTAPIMSPLINE htMSPLine, HDRVMSPLINE  hdMSPLine );
    BOOL IsValidMSPHandle( HDRVMSPLINE hdMSPLine, HTAPIMSPLINE* phtMSPLine );
    BOOL DeleteMSPInstance( HTAPIMSPLINE*   phtMSPLine,
        HDRVMSPLINE hdMSPLine );
    LONG Close();
    LONG CopyLineInfo(DWORD dwDeviceID, LPLINEADDRESSCAPS pAddressCaps );
    void H323ReleaseCall( HDRVCALL hdCall, IN DWORD dwDisconnectMode, 
        IN WORD wCallReference );
    BOOL CallReferenceDuped(WORD wCallReference);


    //supplementary services functionality
    LONG CopyAddressForwardInfo( IN LPLINEADDRESSSTATUS lpAddressStatus );
    PH323_ALIASITEM CallToBeDiverted( IN WCHAR* pwszCallerName,
        IN DWORD  dwCallerNameSize, IN DWORD dwForwardMode );
    void PlaceDivertedCall( IN HDRVCALL hdCall, 
        IN PH323_ALIASNAMES pDivertedToAlias );
    void PlaceTransferedCall(IN HDRVCALL hdCall, 
        IN PH323_ALIASNAMES pTransferedToAlias);
    void SwapReplacementCall(
		HDRVCALL hdReplacementCall, 
        HDRVCALL hdPrimaryCall,
        BOOL fChangeCallState );

    
    H323_CONF_TABLE* GetH323ConfTable()
    {
        return &m_H323ConfTable;
    }

    HDRVMSPLINE GetNextMSPHandle()
    {
        return ++m_hdNextMSPHandle;
    }

    HDRVLINE GetHDLine()
    {
        return m_hdLine;
    }
    
    DWORD GetDeviceID()
    {
        return m_dwDeviceID;
    }

    PH323_CALL 
    GetCallAtIndex( int iIndex ) 
    {
        return m_H323CallTable[iIndex];
    }
    
    CALLFORWARDPARAMS* GetCallForwardParams()
    {
        return m_pCallForwardParams;
    }
    
    BOOL ForwardEnabledForAllOrigins(void)
    {
        return
            (
                m_pCallForwardParams &&
                (m_pCallForwardParams ->fForwardForAllOrigins == TRUE) &&
                (m_pCallForwardParams ->fForwardingEnabled = TRUE)
            );
    }

    H323_VENDORINFO *GetVendorInfo()
    {
        return &m_VendorInfo;
    }

    WCHAR * GetMachineName()
    {
        return m_wszAddr;
    }

    //!!must be always called in a lock
    WORD GetNextInvokeID()
    {
        return (WORD)InterlockedIncrement( (LONG*)&m_dwInvokeID );
    }

    BOOL IsValidAddressID( DWORD dwID )
    {
        return (dwID == 0);
    }
    
    void Lock()
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 line waiting on lock." ));
        EnterCriticalSection( &m_CriticalSection );
        
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 line locked." ));
    }

    void Unlock()
    {
        LeaveCriticalSection( &m_CriticalSection );
        
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 line unlocked." ));
    }

    int GetNoOfCalls()
    {
        DWORD dwNumCalls;

        LockCallTable();
        dwNumCalls = m_H323CallTable.GetSize();
        UnlockCallTable();
        return dwNumCalls;
    }

    //!!must be always called after locking the call table.
    int GetCallTableSize()
    {
        return m_H323CallTable.GetAllocSize();
    }

    //!This function should not be called while holding a lock on a call object
    //!When called from shutdown the calltable object is locked before the call object, so its OK.
    void RemoveCallFromTable(
                               HDRVCALL hdCall
                            )
    {
        m_H323CallTable.RemoveAt( LOWORD(hdCall) );
    }

    //!This function should not be called while holding a lock on a call object
    int AddCallToTable( 
                        PH323_CALL pCall
                       )
    {
        return m_H323CallTable.Add( pCall );
    }
 
    void DisableCallForwarding()
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "DisableCallForwarding -Entered" ));

        if( m_pCallForwardParams != NULL )
        {
            FreeCallForwardParams( m_pCallForwardParams );
            m_pCallForwardParams = NULL;
        }

        H323DBG(( DEBUG_LEVEL_TRACE, "DisableCallForwarding -Exited" ));
    }

    //!This function should not be called while holding a lock on a call object
    void LockCallTable()
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "Waiting on call table lock - %p.",
            m_H323CallTable ));
        
        m_H323CallTable.Lock();

        H323DBG(( DEBUG_LEVEL_TRACE, "Call table locked - %p.",
            m_H323CallTable ));
    }

    void UnlockCallTable()
    {
        m_H323CallTable.Unlock();
        
        H323DBG(( DEBUG_LEVEL_TRACE, "Call table lock released - %p.",
            m_H323CallTable ));
    }

    H323_LINESTATE  GetState()
    {
        return m_nState;
    }

    void SetState( H323_LINESTATE  nState )
    {
        m_nState = nState;
    }

    DWORD GetMediaModes()
    {
        return m_dwMediaModes;
    }

    void SetMediaModes( 
                        DWORD dwMediaModes
                       )
    {
        m_dwMediaModes = dwMediaModes;
    }

    BOOL IsMediaDetectionEnabled() 
    {
        return  (m_dwMediaModes != 0) && 
                (m_dwMediaModes != LINEMEDIAMODE_UNKNOWN);
    }

    LONG	Open	(
		IN	DWORD		DeviceID,
		IN	HTAPILINE	TapiLine,
		IN	DWORD		TspiVersion,
		OUT	HDRVLINE *	ReturnDriverLine);

};




//                                                                           
// Address capabilities                                                      
//                                                                           


#define H323_NUMRINGS_LO           4
#define H323_NUMRINGS_NOANSWER      8
#define H323_NUMRINGS_HI           12

#define H323_ADDR_ADDRESSSHARING    LINEADDRESSSHARING_PRIVATE
#define H323_ADDR_ADDRFEATURES      (LINEADDRFEATURE_MAKECALL | LINEADDRFEATURE_FORWARD)
#define H323_ADDR_CALLFEATURES     (LINECALLFEATURE_ACCEPT | \
                                    LINECALLFEATURE_ANSWER | \
                                    LINECALLFEATURE_DROP | \
                                    LINECALLFEATURE_RELEASEUSERUSERINFO | \
				    LINECALLFEATURE_SENDUSERUSER | \
				    LINECALLFEATURE_MONITORDIGITS | \
				    LINECALLFEATURE_GENERATEDIGITS)
#define H323_ADDR_CALLINFOSTATES    LINECALLINFOSTATE_MEDIAMODE
#define H323_ADDR_CALLPARTYIDFLAGS  LINECALLPARTYID_NAME
#define H323_ADDR_CALLSTATES       (H323_CALL_INBOUNDSTATES | \
                                    H323_CALL_OUTBOUNDSTATES)
#define H323_ADDR_CAPFLAGS         (LINEADDRCAPFLAGS_DIALED | \
                                    LINEADDRCAPFLAGS_ORIGOFFHOOK)
/*LINEADDRCAPFLAGS_FWDCONSULT )*/
                
#define H323_ADDR_DISCONNECTMODES  (LINEDISCONNECTMODE_BADADDRESS | \
                                    LINEDISCONNECTMODE_BUSY | \
                                    LINEDISCONNECTMODE_NOANSWER | \
                                    LINEDISCONNECTMODE_NORMAL | \
                                    LINEDISCONNECTMODE_REJECT | \
                                    LINEDISCONNECTMODE_UNAVAIL)


extern	CH323Line	g_H323Line;
#define	g_pH323Line		(&g_H323Line)

BOOL
QueueTAPILineRequest(
    IN DWORD    EventID,
    IN HDRVCALL	hdCall1,
    IN HDRVCALL	hdCall2,
    IN DWORD    dwDisconnectMode,
    IN WORD     wCallReference);


static DWORD
ProcessTAPILineRequestFre(
    IN PVOID ContextParam
    );

#endif // _LINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\q931pdu.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    q931pdu.cpp

Abstract:

    Encode/decode/transport routines for Q931/H450 messages.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


#include "globals.h"
#include "q931obj.h"
#include "line.h"
#include "q931pdu.h"
#include "ras.h"

//PARSE ROUTINES

//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
//
// Parameters:
//     pbBuffer  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     bIdent      Pointer to space for field identifier
//     Value      Pointer to space for field value
//------------------------------------------------------------------------------
HRESULT 
ParseSingleOctetType1(
                        PBUFFERDESCR    pBuf,
                        BYTE *          bIdent,
                        BYTE *          Value
                     )
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (pBuf->dwLength < 1)
    {
        return E_INVALIDARG;
    }

    // low bits (0, 1, 2, 3) of the byte are the value
    *Value = (BYTE)(*pBuf->pbBuffer & TYPE1VALUEMASK);

    // higher bits (4, 5, 6) are the identifier.  bit 7 is always 1,
    // and is not returned as part of the id.
    *bIdent = (BYTE)((*pBuf->pbBuffer & 0x70) >> 4);

    pBuf->pbBuffer++;
    pBuf->dwLength--;

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
// This octet has no value, only an identifier.
//
// Parameters:
//     pbBuffer  Pointer to a descriptor of the buffer containing the
//                length and a pointer to the raw bytes of the input stream.
//     bIdent      Pointer to space for field identifier
//------------------------------------------------------------------------------
HRESULT
ParseSingleOctetType2(
                        PBUFFERDESCR    pBuf,
                        BYTE *          bIdent
                     )
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (pBuf->dwLength < 1)
    {
        return E_INVALIDARG;
    }

    // low 7 bits of the byte are the identifier
    *bIdent = (BYTE)(*pBuf->pbBuffer & 0x7f);

    pBuf->pbBuffer++;
    pBuf->dwLength--;

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//
// Parameters :
//     pbBuffer  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     bIdent      Pointer to space for field identifier
//     dwLength     Pointer to space for the length
//     pbContents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
HRESULT 
ParseVariableOctet(
                    PBUFFERDESCR    pBuf,
                    BYTE *          dwLength,
                    BYTE *          pbContents
                  )
{
    // There has to be at least 2 bytes in order just to get 
    // the length and the identifier
    // able to parse the single octet value
    if (pBuf->dwLength < 2)
    {
        return E_INVALIDARG;
    }

    //Increment the ident byte
    pBuf->pbBuffer++;
    pBuf->dwLength--;

    // The next byte is the length
    *dwLength = *pBuf->pbBuffer;
    pBuf->pbBuffer++;
    pBuf->dwLength--;

    if (pBuf->dwLength < *dwLength)
    {
        return E_INVALIDARG;
    }

    CopyMemory( pbContents, pBuf->pbBuffer, *dwLength );
    pBuf->pbBuffer += *dwLength;
    pBuf->dwLength -= *dwLength;

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
HRESULT 
ParseVariableASN(
                    PBUFFERDESCR pBuf,
                    BYTE *bIdent,
                    BYTE *ProtocolDiscriminator,
                    PUSERUSERIE pUserUserIE
                )
{
    pUserUserIE -> wUserInfoLen = 0;

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    if (pBuf->dwLength < 4)
    {
        return E_INVALIDARG;
    }

    // low 7 bits of the first byte are the identifier
    *bIdent= (BYTE)(*pBuf->pbBuffer & 0x7f);
    pBuf->pbBuffer++;
    pBuf->dwLength--;

    // The next 2 bytes are the length
    pUserUserIE -> wUserInfoLen = *(pBuf->pbBuffer);
    pBuf->pbBuffer++;
    pUserUserIE -> wUserInfoLen = 
        (WORD)(((pUserUserIE -> wUserInfoLen) << 8) + *pBuf->pbBuffer);
    pBuf->pbBuffer++;
    pBuf->dwLength -= 2;

    if (pBuf->dwLength < pUserUserIE -> wUserInfoLen )
    {
        return E_INVALIDARG;
    }

    // The next byte is the protocol discriminator.
    *ProtocolDiscriminator = *pBuf->pbBuffer;
    pBuf->pbBuffer++;
    pBuf->dwLength--;

    if( pUserUserIE -> wUserInfoLen > 0 )
    {
        pUserUserIE -> wUserInfoLen--;
    }

    CopyMemory( pUserUserIE -> pbUserInfo, 
            pBuf->pbBuffer, 
            pUserUserIE -> wUserInfoLen );

    pBuf->pbBuffer += pUserUserIE -> wUserInfoLen;
    pBuf->dwLength -= pUserUserIE -> wUserInfoLen;

    return S_OK;
}

//------------------------------------------------------------------------------
// Get the identifier of the next field from the buffer and
// return it.  The buffer pointer is not incremented, To
// parse the field and extract its values, the above functions
// should be used.  See Q931 table 4-3 for the encodings of the 
// identifiers.
//
// Parameters:
//      pbBuffer        Pointer to the buffer space
//------------------------------------------------------------------------------
 BYTE
GetNextIdent(
            void *pbBuffer
            )
{
    FIELDIDENTTYPE bIdent;

    // Extract the first byte from the buffer
    bIdent= (*(FIELDIDENTTYPE *)pbBuffer);

    // This value can be returned as the identifier as long
    // as it is not a single Octet - Type 1 element.
    // Those items must have the value removed from them
    // before they can be returned.
    if ((bIdent & 0x80) && ((bIdent & TYPE1IDENTMASK) != 0xA0))
    {
        return (BYTE)(bIdent & TYPE1IDENTMASK);
    }

    return bIdent;
}

//------------------------------------------------------------------------------
// Parse and return a protocol discriminator. See Q931 section 4.2.
// The octet pointed to by **pbBuffer is the protocol Discriminator.
//
// Parameters:
//     pbBuffer  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Discrim    Pointer to space for discriminator
//------------------------------------------------------------------------------
HRESULT
ParseProtocolDiscriminator(
    PBUFFERDESCR pBuf,
    PDTYPE *Discrim)
{
    // There has to be at least enough bytes left in the 
    // string for the operation
    if (pBuf->dwLength < sizeof(PDTYPE))
    {
        return E_INVALIDARG;
    }

    *Discrim = *(PDTYPE *)pBuf->pbBuffer;
    if (*Discrim != Q931PDVALUE)
    {
        return E_INVALIDARG;
    }

    pBuf->pbBuffer += sizeof(PDTYPE);
    pBuf->dwLength -= sizeof(PDTYPE);
    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 call reference see 
// Q931 section 4.3.
//
// Parameters:
//     pbBuffer  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     dwLength     Pointer to space for the length
//     pbContents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
HRESULT
ParseCallReference(
                    PBUFFERDESCR    pBuf,
                    CRTYPE *        wCallRef
                  )
{
    register int indexI;
    BYTE dwLength;

    // There has to be at least enough bytes left in the 
    // string for the length byte
    if( pBuf->dwLength < 1 )
    {
        return E_INVALIDARG;
    }

    // low 4 bits of the first byte are the length.
    // the rest of the bits are zeroes.
    dwLength = (BYTE)(*pBuf->pbBuffer & 0x0f);
    if( dwLength != sizeof(WORD) )
    {
        return E_INVALIDARG;
    }

    pBuf->pbBuffer++;
    pBuf->dwLength--;

    // There has to be at least enough bytes left in the 
    // string for the operation
    if (pBuf->dwLength < dwLength)
    {
        return E_INVALIDARG;
    }

    *wCallRef = 0;     // length can be 0, so initialize here first...
    for (indexI = 0; indexI < dwLength; indexI++)
    {
        if (indexI < sizeof(CRTYPE))
        {
            // Copy the bytes out of the rest of the buffer
            *wCallRef = (WORD)((*wCallRef << 8) +
                *pBuf->pbBuffer);
        }
        pBuf->pbBuffer++;
        pBuf->dwLength--;
    }

    // note:  the high order bit of the value represents callee relationship.

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a message type.  See Q931 section 4.4.
// The octet pointed to by **pbBuffer is the message type.
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     MessageType  Pointer to space for message type
//------------------------------------------------------------------------------
HRESULT
ParseMessageType(
                PBUFFERDESCR    pBuf,
                MESSAGEIDTYPE * MessageType
                )
{
    // There has to be at least enough bytes left in the 
    // string for the operation
    if (pBuf->dwLength < sizeof(MESSAGEIDTYPE))
    {
        return E_INVALIDARG;
    }

    *MessageType = (BYTE)(*((MESSAGEIDTYPE *)pBuf->pbBuffer) & MESSAGETYPEMASK);

    if( ISVALIDQ931MESSAGE(*MessageType) == FALSE )
    {
        return E_INVALIDARG;
    }

    pBuf->pbBuffer += sizeof(MESSAGEIDTYPE);
    pBuf->dwLength -= sizeof(MESSAGEIDTYPE);
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional facility ie field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed facility
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseFacility(
                PBUFFERDESCR pBuf,
                PFACILITYIE pFieldStruct
             )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(FACILITYIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional bearer capability field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed bearer capability
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseBearerCapability(
    PBUFFERDESCR pBuf,
    PBEARERCAPIE pFieldStruct)
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(BEARERCAPIE));
    pFieldStruct->fPresent = FALSE;
    
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional cause field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed cause
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCause(
    PBUFFERDESCR pBuf,
    PCAUSEIE pFieldStruct)
{
    HRESULT hr;
    memset( (PVOID)pFieldStruct, 0, sizeof(CAUSEIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional call state field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed call state
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCallState(
    PBUFFERDESCR pBuf,
    PCALLSTATEIE pFieldStruct)
{
    memset( (PVOID)pFieldStruct, 0, sizeof(CALLSTATEIE));
    pFieldStruct->fPresent = FALSE;

    HRESULT hr;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional channel identification field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed channel identity
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseChannelIdentification(
    PBUFFERDESCR pBuf,
    PCHANIDENTIE pFieldStruct)
{
    memset( (PVOID)pFieldStruct, 0, sizeof(CHANIDENTIE));
    pFieldStruct->fPresent = FALSE;

    HRESULT hr;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional progress indication field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed progress
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseProgress(
    PBUFFERDESCR pBuf,
    PPROGRESSIE pFieldStruct)
{
    memset( (PVOID)pFieldStruct, 0, sizeof(PROGRESSIE));
    pFieldStruct->fPresent = FALSE;
    HRESULT hr;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional network specific facilities field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed network facitlities
//                  information.
//------------------------------------------------------------------------------
HRESULT 
ParseNetworkSpec(
    PBUFFERDESCR pBuf,
    PNETWORKIE pFieldStruct)
{
   
    memset( (PVOID)pFieldStruct, 0, sizeof(NETWORKIE));
    pFieldStruct->fPresent = FALSE;
        
    HRESULT hr;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional notification indicator field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parse notification indicator
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseNotificationIndicator(
    PBUFFERDESCR pBuf,
    PNOTIFICATIONINDIE pFieldStruct)
{
    memset( (PVOID)pFieldStruct, 0, sizeof(NOTIFICATIONINDIE));
    pFieldStruct->fPresent = FALSE;
    if (GetNextIdent(pBuf->pbBuffer) == IDENT_NOTIFICATION)
    {
        HRESULT hr;
        hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
            &pFieldStruct->pbContents[0]);
        if( FAILED(hr) )
        {
            return hr;
        }
        if (pFieldStruct->dwLength > 0)
        {
            pFieldStruct->fPresent = TRUE;
        }
    }

    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional display field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed display
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseDisplay(
    PBUFFERDESCR pBuf,
    PDISPLAYIE pFieldStruct)
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(DISPLAYIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}


HRESULT
ParseDate(
    PBUFFERDESCR pBuf,
    PDATEIE pFieldStruct)
{
    HRESULT hr;    
    
    memset( (PVOID)pFieldStruct, 0, sizeof(DATEIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional keypad field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed keypad
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseKeypad(
    PBUFFERDESCR pBuf,
    PKEYPADIE pFieldStruct)
{
    HRESULT hr;    
    
    memset( (PVOID)pFieldStruct, 0, sizeof(KEYPADIE));
    pFieldStruct->fPresent = FALSE;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);
    
    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional signal field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed signal
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseSignal(
    PBUFFERDESCR pBuf,
    PSIGNALIE pFieldStruct)
{
    HRESULT hr;    
    
    memset( (PVOID)pFieldStruct, 0, sizeof(SIGNALIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional information rate field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed information rate
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseInformationRate(
    PBUFFERDESCR pBuf,
    PINFORATEIE pFieldStruct)
{
    HRESULT hr;    
    
    memset( (PVOID)pFieldStruct, 0, sizeof(INFORATEIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);
    
    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional calling party number field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCallingPartyNumber(
    PBUFFERDESCR pBuf,
    PCALLINGNUMBERIE pFieldStruct)
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(CALLINGNUMBERIE));
    pFieldStruct->fPresent = FALSE;
    
    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional calling party subaddress field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCallingPartySubaddress(
    PBUFFERDESCR pBuf,
    PCALLINGSUBADDRIE pFieldStruct)
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(CALLINGSUBADDRIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party number field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCalledPartyNumber(
                        PBUFFERDESCR pBuf,
                        PCALLEDNUMBERIE pFieldStruct
                      )
{
    memset( (PVOID)pFieldStruct, 0, sizeof(PCALLEDNUMBERIE));
    pFieldStruct->fPresent = FALSE;
    if (GetNextIdent(pBuf->pbBuffer) == IDENT_CALLEDNUMBER)
    {
        BYTE RemainingLength = 0;
    
        // Need 3 bytes for the ident (1), length (1),
        // and type + plan (1) fields.
        if (pBuf->dwLength < 3)
        {
            return E_INVALIDARG;
        }

        // skip the ie identifier...    
        pBuf->pbBuffer++;
        pBuf->dwLength--;

        // Get the length of the contents following the length field.
        RemainingLength = *pBuf->pbBuffer;
        pBuf->pbBuffer++;
        pBuf->dwLength--;

        // make sure we have at least that much length left...    
        if (pBuf->dwLength < RemainingLength)
        {
            return E_INVALIDARG;
        }

        // Get the type + plan fields.
        if (*(pBuf->pbBuffer) & 0x80)
        {
            pFieldStruct->NumberType =
                (BYTE)(*pBuf->pbBuffer & 0xf0);
            pFieldStruct->NumberingPlan =
                (BYTE)(*pBuf->pbBuffer & 0x0f);
            pBuf->pbBuffer++;
            pBuf->dwLength--;
            RemainingLength--;
        }

        pFieldStruct->PartyNumberLength = RemainingLength;
        pFieldStruct->fPresent = TRUE;

        CopyMemory( pFieldStruct->PartyNumbers, pBuf->pbBuffer, RemainingLength );

        pBuf->pbBuffer += RemainingLength;
        pBuf->dwLength -= RemainingLength;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party subaddress field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCalledPartySubaddress(
                            PBUFFERDESCR pBuf,
                            PCALLEDSUBADDRIE pFieldStruct
                          )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(CALLEDSUBADDRIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional redirecting number field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseRedirectingNumber(
                        PBUFFERDESCR pBuf, 
                        PREDIRECTINGIE pFieldStruct
                      )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(REDIRECTINGIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional lower layer compatibility field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseLowLayerCompatibility(
    PBUFFERDESCR pBuf,
    PLLCOMPATIBILITYIE pFieldStruct
    )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(LLCOMPATIBILITYIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional higher layer compatibility field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseHighLayerCompatibility(
                            PBUFFERDESCR pBuf,
                            PHLCOMPATIBILITYIE pFieldStruct
                           )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(HLCOMPATIBILITYIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}


HRESULT
ParseUserToUser(
                PBUFFERDESCR pBuf,
                PUSERUSERIE pFieldStruct
               )
{
    BYTE    bIdent;
    HRESULT hr;
    
    ZeroMemory( (PVOID)pFieldStruct, sizeof(USERUSERIE));
    pFieldStruct->fPresent = FALSE;
    hr = ParseVariableASN(  pBuf, 
                            &bIdent, 
                            &(pFieldStruct->ProtocolDiscriminator),
                            pFieldStruct
                         );
    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->wUserInfoLen > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

HRESULT
ParseQ931Field(
                PBUFFERDESCR pBuf,
                PQ931MESSAGE pMessage
              )
{
    FIELDIDENTTYPE bIdent;

    bIdent = GetNextIdent(pBuf->pbBuffer);
    switch (bIdent)
    {
    /*case IDENT_REVCHARGE:
    case IDENT_TRANSITNET:
    case IDENT_RESTART:
    case IDENT_MORE:
    case IDENT_REPEAT:
    case IDENT_SEGMENTED:
    case IDENT_SHIFT:
    case IDENT_CALLIDENT:
    case IDENT_CLOSEDUG:
    case IDENT_SENDINGCOMPLETE:
    case IDENT_PACKETSIZE:
    case IDENT_CONGESTION:
    case IDENT_NETWORKSPEC:
    case IDENT_PLWINDOWSIZE:
    case IDENT_TRANSITDELAY:
    case IDENT_PLBINARYPARAMS:
    case IDENT_ENDTOENDDELAY:
        
        return E_INVALIDARG;*/

    case IDENT_FACILITY:

        return ParseFacility( pBuf, &pMessage->Facility );

    case IDENT_BEARERCAP:
        
        return ParseBearerCapability( pBuf, &pMessage->BearerCapability );

    case IDENT_CAUSE:
        
        return ParseCause(pBuf, &pMessage->Cause);

    case IDENT_CALLSTATE:
        return ParseCallState(pBuf, &pMessage->CallState);

    case IDENT_CHANNELIDENT:
        return ParseChannelIdentification( pBuf, 
            &pMessage->ChannelIdentification );

    case IDENT_PROGRESS:
        return ParseProgress( pBuf, &pMessage->ProgressIndicator );

    case IDENT_NOTIFICATION:
        return ParseNotificationIndicator( pBuf, 
            &pMessage->NotificationIndicator );

    case IDENT_DISPLAY:
        return ParseDisplay( pBuf, &pMessage->Display );

    case IDENT_DATE:
        return ParseDate( pBuf, &pMessage->Date );

    case IDENT_KEYPAD:
        return ParseKeypad( pBuf, &pMessage->Keypad );

    case IDENT_SIGNAL:
        return ParseSignal(pBuf, &pMessage->Signal);

    case IDENT_INFORMATIONRATE:
        return ParseInformationRate( pBuf, &pMessage->InformationRate );

    case IDENT_CALLINGNUMBER:
        return ParseCallingPartyNumber( pBuf, &pMessage->CallingPartyNumber );

    case IDENT_CALLINGSUBADDR:
        return ParseCallingPartySubaddress(pBuf, 
            &pMessage->CallingPartySubaddress);

    case IDENT_CALLEDNUMBER:
        return ParseCalledPartyNumber(pBuf, &pMessage->CalledPartyNumber);

    case IDENT_CALLEDSUBADDR:
        return ParseCalledPartySubaddress( pBuf, 
            &pMessage->CalledPartySubaddress );

    case IDENT_REDIRECTING:
        return ParseRedirectingNumber( pBuf, &pMessage->RedirectingNumber );

    case IDENT_LLCOMPATIBILITY:
        return ParseLowLayerCompatibility( pBuf, 
            &pMessage->LowLayerCompatibility );

    case IDENT_HLCOMPATIBILITY:
        return ParseHighLayerCompatibility( pBuf, 
            &pMessage->HighLayerCompatibility );

    case IDENT_USERUSER:
        return ParseUserToUser(pBuf, &pMessage->UserToUser);

    default:

        //Increment the ident byte
        pBuf->pbBuffer++;
        pBuf->dwLength--;
        return S_OK;
    }
}


//------------------------------------------------------------------------------
// Write a Q931 message type.  See Q931 section 4.4.
//------------------------------------------------------------------------------

void 
WriteMessageType(
                PBUFFERDESCR    pBuf,
                MESSAGEIDTYPE * MessageType,
                DWORD*          pdwPDULen
                )
{
    (*pdwPDULen) += sizeof(MESSAGEIDTYPE);

    _ASSERTE( pBuf->dwLength > *pdwPDULen );

    *(MESSAGEIDTYPE *)(pBuf->pbBuffer) =
        (BYTE)(*MessageType & MESSAGETYPEMASK);
    pBuf->pbBuffer += sizeof(MESSAGEIDTYPE);
}



void 
WriteVariableOctet(
                    PBUFFERDESCR pBuf,
                    BYTE bIdent,
                    BYTE dwLength,
                    BYTE *pbContents,
                    DWORD* pdwPDULen
                  )
{
    if( pbContents == NULL )
    {
        dwLength = 0;
    }

    // space for the length and the identifier bytes and octet array
    (*pdwPDULen) += (2 + dwLength);
    _ASSERTE( pBuf->dwLength > *pdwPDULen );

    // the id byte, then the length byte
    // low 7 bits of the first byte are the identifier
    *pBuf->pbBuffer = (BYTE)(bIdent & 0x7f);
    pBuf->pbBuffer++;
    *pBuf->pbBuffer = dwLength;
    pBuf->pbBuffer++;

    CopyMemory( (PVOID)pBuf->pbBuffer, (PVOID)pbContents, dwLength );
    pBuf->pbBuffer +=  dwLength;
}


void
WriteUserInformation(
                    PBUFFERDESCR    pBuf,
                    BYTE            bIdent,
                    WORD            wUserInfoLen,
                    BYTE *          pbUserInfo,
                    DWORD *         pdwPDULen
                    )
{
    WORD ContentsLength = (WORD)(wUserInfoLen + 1);

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    (*pdwPDULen) += (4 + wUserInfoLen);
    _ASSERTE( pBuf->dwLength > *pdwPDULen );

    // low 7 bits of the first byte are the identifier
    *pBuf->pbBuffer = (BYTE)(bIdent & 0x7f);
    pBuf->pbBuffer++;

    // write the contents length bytes.
    *pBuf->pbBuffer = (BYTE)(ContentsLength >> 8);
    pBuf->pbBuffer++;
    *pBuf->pbBuffer = (BYTE)ContentsLength;
    pBuf->pbBuffer++;

    // write the protocol discriminator byte.
    *(pBuf->pbBuffer) = Q931_PROTOCOL_X209;
    pBuf->pbBuffer++;

    CopyMemory( (PVOID)pBuf->pbBuffer, 
            (PVOID)pbUserInfo, 
            wUserInfoLen);

    pBuf->pbBuffer +=  wUserInfoLen;
}


HRESULT
WritePartyNumber(
    PBUFFERDESCR pBuf,
    BYTE bIdent,
    BYTE NumberType,
    BYTE NumberingPlan,
    BYTE bPartyNumberLength,
    BYTE *pbPartyNumbers,
    DWORD *  pdwPDULen )
{
    if (pbPartyNumbers == NULL)
    {
        bPartyNumberLength = 1;
    }

    // space for the ident (1), length (1), and type + plan (1) fields.
    (*pdwPDULen) += (2 + bPartyNumberLength);
    _ASSERTE( pBuf->dwLength > *pdwPDULen );
    
    // low 7 bits of byte 1 are the ie identifier
    *pBuf->pbBuffer = (BYTE)(bIdent & 0x7f);
    pBuf->pbBuffer++;


    // byte 2 is the ie contents length following the length field.
    *pBuf->pbBuffer = (BYTE)(bPartyNumberLength);
    pBuf->pbBuffer++;

    // byte 3 is the type and plan field.
    *pBuf->pbBuffer = (BYTE)(NumberType | NumberingPlan);
    pBuf->pbBuffer++;

    if( pbPartyNumbers != NULL )
    {
        CopyMemory( (PVOID)pBuf->pbBuffer, 
                    (PVOID)pbPartyNumbers, 
                    bPartyNumberLength-1 );
    }
    pBuf->pbBuffer += (bPartyNumberLength-1);

    return S_OK;
}


//
//ASN Parsing functions
//

BOOL 
ParseVendorInfo(
                 OUT PH323_VENDORINFO   pDestVendorInfo,
                 IN VendorIdentifier*  pVendor
               )
{
    memset( (PVOID)pDestVendorInfo, 0, sizeof(H323_VENDORINFO) );

    pDestVendorInfo ->bCountryCode = (BYTE)pVendor->vendor.t35CountryCode;
    pDestVendorInfo ->bExtension = (BYTE)pVendor->vendor.t35Extension;
    pDestVendorInfo ->wManufacturerCode = pVendor->vendor.manufacturerCode;

    if( pVendor->bit_mask & (productId_present) )
    {
        pDestVendorInfo ->pProductNumber = new H323_OCTETSTRING;
        if( pDestVendorInfo ->pProductNumber == NULL )
        {
            goto cleanup;
        }

        pDestVendorInfo ->pProductNumber->wOctetStringLength = 
            (WORD)min(pVendor->productId.length, H323_MAX_PRODUCT_LENGTH - 1);

        pDestVendorInfo ->pProductNumber->pOctetString = (BYTE*)
            new char[pDestVendorInfo ->pProductNumber->wOctetStringLength + 1];

        if( pDestVendorInfo ->pProductNumber->pOctetString == NULL )
        {
            goto cleanup;
        }

        CopyMemory( (PVOID)pDestVendorInfo ->pProductNumber->pOctetString,
                (PVOID)pVendor->productId.value,
                pDestVendorInfo -> pProductNumber->wOctetStringLength );
        
        pDestVendorInfo ->pProductNumber->pOctetString[
            pDestVendorInfo ->pProductNumber->wOctetStringLength] = '\0';
    }
    
    if( pVendor->bit_mask & versionId_present )
    {
        pDestVendorInfo ->pVersionNumber = new H323_OCTETSTRING;

        if( pDestVendorInfo ->pVersionNumber == NULL )
        {
            goto cleanup;
        }
        
        pDestVendorInfo ->pVersionNumber->wOctetStringLength = 
            (WORD)min(pVendor->versionId.length, H323_MAX_VERSION_LENGTH - 1);

        pDestVendorInfo ->pVersionNumber->pOctetString = (BYTE*)
            new char[pDestVendorInfo ->pVersionNumber->wOctetStringLength+1];

        if( pDestVendorInfo ->pVersionNumber->pOctetString == NULL )
        {
            goto cleanup;
        }

        CopyMemory( (PVOID)pDestVendorInfo ->pVersionNumber->pOctetString,
                (PVOID)pVendor->versionId.value,
                pDestVendorInfo ->pVersionNumber->wOctetStringLength);

        pDestVendorInfo ->pVersionNumber->pOctetString[
            pDestVendorInfo ->pVersionNumber->wOctetStringLength] = '\0';
    }

    return TRUE;

cleanup:

    FreeVendorInfo( pDestVendorInfo );
    return FALSE;
}

BOOL 
ParseNonStandardData( 
    OUT H323NonStandardData *       dstNonStdData,
    IN H225NonStandardParameter *   srcNonStdData
    )
{
    H221NonStandard & h221NonStdData = 
        srcNonStdData ->nonStandardIdentifier.u.h221NonStandard;

    if( srcNonStdData ->nonStandardIdentifier.choice ==
            H225NonStandardIdentifier_h221NonStandard_chosen )
    {
        dstNonStdData ->bCountryCode = (BYTE)(h221NonStdData.t35CountryCode);
        dstNonStdData ->bExtension = (BYTE)(h221NonStdData.t35Extension);
        dstNonStdData ->wManufacturerCode = h221NonStdData.manufacturerCode;
    }

    dstNonStdData->sData.wOctetStringLength = (WORD)srcNonStdData->data.length;

    dstNonStdData ->sData.pOctetString =
        (BYTE *)new char[dstNonStdData ->sData.wOctetStringLength];

    if( dstNonStdData -> sData.pOctetString == NULL )
    {
        return FALSE;
    }
    
    CopyMemory( (PVOID)dstNonStdData ->sData.pOctetString,
            (PVOID)srcNonStdData ->data.value,
            dstNonStdData ->sData.wOctetStringLength );

    return TRUE;
}


BOOL 
AliasAddrToAliasNames( 
                        OUT PH323_ALIASNAMES *ppTarget, 
                        IN Setup_UUIE_sourceAddress *pSource
                     )
{
    Setup_UUIE_sourceAddress *CurrentNode = NULL;
    WORD wCount = 0;
    int indexI = 0;
    HRESULT hr;

    *ppTarget = NULL;

    for( CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next )
    {
        wCount++;
    }

    if( wCount == 0 )
    {
        return TRUE;
    }

    *ppTarget = new H323_ALIASNAMES;
    if (*ppTarget == NULL)
    {
        return FALSE;
    }
    ZeroMemory( *ppTarget, sizeof(H323_ALIASNAMES) );
    (*ppTarget)->pItems = new H323_ALIASITEM[wCount];

    if( (*ppTarget)->pItems == NULL )
    {
        goto cleanup;
    }

    for( CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next )
    {
        hr = AliasAddrToAliasItem( &((*ppTarget)->pItems[indexI]),
            &(CurrentNode->value));

        if( hr == E_OUTOFMEMORY )
        {
            WORD indexJ;
            //Free everything that has been allocated so far...
            for (indexJ = 0; indexJ < indexI; indexJ++)
            {
                delete (*ppTarget)->pItems[indexJ].pData;
            }
            goto cleanup;
        }
        else if( SUCCEEDED(hr) )
        {
            indexI++;
        }
    }

    // any aliases?
    if (indexI > 0)
    {
        // save number of aliases
        (*ppTarget)->wCount = (WORD)indexI;
    } 
    else 
    {
        //free everything
        delete (*ppTarget)->pItems;
        delete (*ppTarget);
        *ppTarget = NULL;
        return FALSE;
    }

    return TRUE;

cleanup:
    if( *ppTarget )
    {
        if( (*ppTarget)->pItems )
        {
            delete (*ppTarget)->pItems;
        }

        delete( *ppTarget );
        *ppTarget = NULL;
    }

    return FALSE;
}


HRESULT
AliasAddrToAliasItem(
                    OUT PH323_ALIASITEM pAliasItem,
                    IN AliasAddress *   pAliasAddr
                    )
{
    WORD indexI;

    if( pAliasItem == NULL )
    {
        return E_FAIL;
    }

    memset( (PVOID)pAliasItem, 0, sizeof(H323_ALIASITEM) );

    switch( pAliasAddr->choice )
    {
    case h323_ID_chosen:

        pAliasItem->wType = h323_ID_chosen;
        
        if ((pAliasAddr->u.h323_ID.length != 0) &&
            (pAliasAddr->u.h323_ID.value  != NULL))
        {
            pAliasItem->wDataLength = (WORD)pAliasAddr->u.h323_ID.length;
            pAliasItem->pData = 
                (LPWSTR)new char[(pAliasItem->wDataLength+1) * sizeof(WCHAR)];
            
            if (pAliasItem->pData == NULL)
            {
                return E_OUTOFMEMORY;
            }

            CopyMemory( (PVOID)pAliasItem->pData,
                    (PVOID)pAliasAddr->u.h323_ID.value,
                    pAliasItem->wDataLength * sizeof(WCHAR) );
            pAliasItem->pData[pAliasItem->wDataLength] = L'\0';
        }
        break;

    case e164_chosen:

        pAliasItem->wType = e164_chosen;
        pAliasItem->wDataLength = (WORD)strlen(pAliasAddr->u.e164);
        pAliasItem->pData = 
            (LPWSTR)new char[(pAliasItem->wDataLength + 1) * sizeof(WCHAR)];

        if( pAliasItem->pData == NULL )
        {
            return E_OUTOFMEMORY;
        }

        //converting from byte to UNICODE
        for (indexI = 0; indexI < pAliasItem->wDataLength; indexI++)
        {
            pAliasItem->pData[indexI] = (WCHAR)pAliasAddr->u.e164[indexI];
        }

        pAliasItem->pData[pAliasItem->wDataLength] = '\0';
        break;

    default:
        return E_INVALIDARG;
    } // switch

    return S_OK;
}


void FreeFacilityASN(
    IN Q931_FACILITY_ASN* pFacilityASN
    )
{
    //free non standard data
    if( pFacilityASN->fNonStandardDataPresent != NULL )
    {
        delete pFacilityASN->nonStandardData.sData.pOctetString;
        pFacilityASN->nonStandardData.sData.pOctetString =NULL;
    }
    
    if( pFacilityASN->pAlternativeAliasList != NULL )
    {
        FreeAliasNames(pFacilityASN->pAlternativeAliasList );
        pFacilityASN->pAlternativeAliasList  = NULL;
    }
}


void FreeAlertingASN( 
                     IN Q931_ALERTING_ASN* pAlertingASN
                    )
{
    FreeProceedingASN( (Q931_CALL_PROCEEDING_ASN*)pAlertingASN );
}

void FreeProceedingASN( 
                      IN Q931_CALL_PROCEEDING_ASN* pProceedingASN
                      )
{
    //free non standard data
    if( pProceedingASN->fNonStandardDataPresent == TRUE )
    {
        delete pProceedingASN->nonStandardData.sData.pOctetString;
        pProceedingASN->nonStandardData.sData.pOctetString = NULL;
    }
    
    if( pProceedingASN->fFastStartPresent  &&pProceedingASN->pFastStart )
    {
        FreeFastStart( pProceedingASN->pFastStart );
    }
}


void FreeSetupASN(
    IN Q931_SETUP_ASN* pSetupASN
    )
{
    if( pSetupASN == NULL )
    {
        return;
    }

    if( pSetupASN->pExtensionAliasItem != NULL )
    {
        if( pSetupASN->pExtensionAliasItem -> pData != NULL )
        {
            delete pSetupASN->pExtensionAliasItem -> pData;
        }

        delete pSetupASN->pExtensionAliasItem;
    }

    if( pSetupASN->pExtraAliasList != NULL )
    {
        FreeAliasNames(pSetupASN->pExtraAliasList);
        pSetupASN->pExtraAliasList = NULL;
    }
    
    if( pSetupASN->pCalleeAliasList != NULL )
    {
        FreeAliasNames(pSetupASN->pCalleeAliasList);
        pSetupASN->pCalleeAliasList = NULL;
    }

    if( pSetupASN->pCallerAliasList != NULL )
    {
        FreeAliasNames(pSetupASN->pCallerAliasList);
        pSetupASN->pCallerAliasList = NULL;
    }

    if( pSetupASN->fNonStandardDataPresent == TRUE )
    {
        delete pSetupASN->nonStandardData.sData.pOctetString;
    }

    if( pSetupASN->EndpointType.pVendorInfo != NULL )
    {
        FreeVendorInfo( pSetupASN->EndpointType.pVendorInfo );
    }

    if( pSetupASN->fFastStartPresent == TRUE )
    {
        if( pSetupASN->pFastStart != NULL )
        {
            FreeFastStart( pSetupASN->pFastStart );
        }
    }
}


void FreeConnectASN(
                    IN Q931_CONNECT_ASN *pConnectASN
                   )
{
    if( pConnectASN != NULL )
    {
        // Cleanup any dynamically allocated fields within SetupASN
        if (pConnectASN->nonStandardData.sData.pOctetString)
        {
            delete pConnectASN->nonStandardData.sData.pOctetString;
            pConnectASN->nonStandardData.sData.pOctetString = NULL;
        }

        if( pConnectASN->EndpointType.pVendorInfo != NULL )
        {
            FreeVendorInfo( pConnectASN->EndpointType.pVendorInfo );
        }

        if( pConnectASN->fFastStartPresent == TRUE )
        {
            if( pConnectASN->pFastStart != NULL )
            {
                FreeFastStart( pConnectASN->pFastStart );
            }
        }
    }
}


void 
FreeFastStart(
               IN PH323_FASTSTART pFastStart
             )
{
    PH323_FASTSTART pTempFastStart;

    while( pFastStart )
    {
        pTempFastStart = pFastStart -> next;

        if(pFastStart -> value)
        {
            delete pFastStart -> value;
        }

        delete pFastStart;

        pFastStart = pTempFastStart;
    }
}



//FastStart is a plain linked list because it is exactly the same struct
//as defined by ASN.1. This allows to pass on the m_pFastStart member to
//the ASN encoder directly without any conversons
PH323_FASTSTART
CopyFastStart(
              IN PSetup_UUIE_fastStart pSrcFastStart
             )
{
    PH323_FASTSTART pCurr, pHead = NULL, pTail = NULL;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CopyFastStart entered." ));
    
    while( pSrcFastStart )
    {
        pCurr = new H323_FASTSTART;
        if( pCurr == NULL )
        {
            FreeFastStart( pHead );
            return NULL;
        }

        pCurr -> next = NULL;
        
        if( pHead == NULL )
        {
            pHead = pCurr;
        }
        else
        {
            pTail -> next = pCurr;
        }
        
        pTail = pCurr;

        pCurr -> length = pSrcFastStart -> value.length;
        pCurr -> value = (BYTE*)new char[pCurr -> length];
        if( pCurr -> value == NULL )
        {
            FreeFastStart( pHead );
            return NULL;
        }

        CopyMemory( (PVOID)pCurr -> value,
            (PVOID)pSrcFastStart -> value.value,
            pCurr -> length );

        pSrcFastStart = pSrcFastStart->next;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CopyFastStart exited." ));
    return pHead;
}


void 
FreeVendorInfo( 
               IN PH323_VENDORINFO pVendorInfo 
              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeVendorInfo entered." ));

    if( pVendorInfo != NULL )
    {
        if( pVendorInfo ->pProductNumber != NULL )
        {
            if( pVendorInfo ->pProductNumber->pOctetString != NULL )
            {
                delete pVendorInfo ->pProductNumber->pOctetString;
            }

            delete pVendorInfo ->pProductNumber;
        }

        if( pVendorInfo ->pVersionNumber != NULL )
        {
            if( pVendorInfo ->pVersionNumber->pOctetString != NULL )
            {
                delete pVendorInfo ->pVersionNumber->pOctetString;
            }

            delete pVendorInfo ->pVersionNumber;
        }

        memset( (PVOID) pVendorInfo, 0, sizeof(H323_VENDORINFO) );
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeVendorInfo exited." ));
}



void 
FreeAliasNames( 
               IN PH323_ALIASNAMES pSource
              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeAliasNames entered." ));

    if( pSource != NULL )
    {
        if( pSource->wCount != 0 )
        {
            // Free everything that has been allocated so far...
            int indexI;
            for( indexI = 0; indexI < pSource->wCount; indexI++ )
            {
                if( pSource->pItems[indexI].pPrefix != NULL )
                {
                    H323DBG(( DEBUG_LEVEL_TRACE, "delete prefix:%d.", indexI ));
                    delete pSource->pItems[indexI].pPrefix;
                }
                if( pSource->pItems[indexI].pData != NULL )
                {
                    H323DBG(( DEBUG_LEVEL_TRACE, "delete pdata:%d.", indexI ));
                    delete pSource->pItems[indexI].pData;
                }
            }
            if( pSource->pItems != NULL )
            {
                H323DBG(( DEBUG_LEVEL_TRACE, "delete pitems." ));
                delete pSource->pItems;
            }
        }
        
        H323DBG(( DEBUG_LEVEL_TRACE, "outta loop." ));
        delete pSource;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "FreeAliasNames exited." ));
}


void
FreeAliasItems(
               IN PH323_ALIASNAMES pSource
              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeAliasItems entered." ));

    if( pSource != NULL )
    {
        if( pSource->wCount != 0 )
        {
            // Free everything that has been allocated so far...
            int indexI;
            for( indexI = 0; indexI < pSource->wCount; indexI++ )
            {
                if( pSource->pItems[indexI].pPrefix )
                {
                    delete pSource->pItems[indexI].pPrefix;
                }
                if( pSource->pItems[indexI].pData )
                {
                    delete pSource->pItems[indexI].pData;
                }
            }
            if( pSource->pItems != NULL )
            {
                delete pSource->pItems;
                pSource->pItems = NULL;
            }
            pSource->wCount = 0;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "FreeAliasItems exited." ));
}

void 
SetupTPKTHeader(
                OUT BYTE *  pbTpktHeader, 
                IN DWORD   dwLength
                )
{
    dwLength += TPKT_HEADER_SIZE;

    // TPKT requires that the packet size fit in two bytes.
    _ASSERTE( dwLength < (1L << 16));

    pbTpktHeader[0] = TPKT_VERSION;
    pbTpktHeader[1] = 0;
    pbTpktHeader[2] = (BYTE)(dwLength >> 8);
    pbTpktHeader[3] = (BYTE)dwLength;
}

int
GetTpktLength( 
              IN char * pTpktHeader 
             )
{
    BYTE * pbTempPtr = (BYTE*)pTpktHeader;
    return (pbTempPtr[2] << 8) + pbTempPtr[3];
}


BOOL
AddAliasItem( 
            IN OUT PH323_ALIASNAMES pAliasNames,
            IN BYTE*                pbAliasName,
            IN DWORD                dwAliasSize,
            IN WORD                 wType
            )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "AddAliasItem entered." ));
    
    PH323_ALIASITEM pAliasItem;
    PH323_ALIASITEM tempPtr = pAliasNames -> pItems;

    pAliasNames -> pItems = (PH323_ALIASITEM)realloc( pAliasNames -> pItems,
        sizeof(H323_ALIASITEM) * (pAliasNames->wCount+1) );

    if( pAliasNames -> pItems == NULL )
    {
        //restore the old pointer in case enough memory was not available to 
        //expand the memory block
        pAliasNames -> pItems = tempPtr;
        return FALSE;
    }

    pAliasItem = &(pAliasNames -> pItems[pAliasNames->wCount]);

    pAliasItem->pData = (WCHAR*)new char[dwAliasSize];

    if( pAliasItem ->pData == NULL )
    {
        return FALSE;
    }
    pAliasNames->wCount++;

    // transfer memory
    CopyMemory((PVOID)pAliasItem ->pData,
        pbAliasName,
        dwAliasSize );

    // complete alias
    pAliasItem ->wType         = wType;
    pAliasItem ->wPrefixLength = 0;
    pAliasItem ->pPrefix       = NULL;
    pAliasItem ->wDataLength   = (WORD)wcslen(pAliasItem -> pData);
    _ASSERTE( ((pAliasItem->wDataLength+1)*2) == (WORD)dwAliasSize );

        
    H323DBG(( DEBUG_LEVEL_TRACE, "AddAliasItem exited." ));
    return TRUE;
}


void
FreeAddressAliases( 
                   IN PSetup_UUIE_destinationAddress pAddr 
                  )
{
    PSetup_UUIE_destinationAddress pTempAddr;

    while( pAddr )
    {
        pTempAddr = pAddr -> next;
        if( pAddr ->value.choice == h323_ID_chosen )
        {
            if( pAddr -> value.u.h323_ID.value )
            {
                delete pAddr -> value.u.h323_ID.value;
            }
        }

        delete pAddr;            
        pAddr = pTempAddr;
    }
}


void CopyTransportAddress(
                         OUT TransportAddress& transportAddress,
                         IN PH323_ADDR pCalleeAddr
                         )
{
    DWORD dwAddr = pCalleeAddr->Addr.IP_Binary.dwAddr;

    transportAddress.choice = ipAddress_chosen;
    transportAddress.u.ipAddress.ip.length = 4;
    transportAddress.u.ipAddress.port 
        = pCalleeAddr->Addr.IP_Binary.wPort;
    *(DWORD*)transportAddress.u.ipAddress.ip.value =
        htonl( pCalleeAddr->Addr.IP_Binary.dwAddr );
    //ReverseAddressAndCopy( transportAddress.u.ipAddress.ip.value, dwAddr);
}


void 
AddressReverseAndCopy( 
                        OUT DWORD * pdwAddr, 
                        IN  BYTE *  addrValue
                     )
{
    BYTE *addr = (BYTE *)(pdwAddr);
    
    addr[3] = addrValue[0];
    addr[2] = addrValue[1];
    addr[1] = addrValue[2];
    addr[0] = addrValue[3];
}


Setup_UUIE_sourceAddress *
SetMsgAddressAlias( 
                    IN PH323_ALIASNAMES pAliasNames
                  )
{
    PH323_ALIASITEM pAliasItem;
    Setup_UUIE_sourceAddress *addressAlias, *currHead = NULL;
    WORD    wCount;
    int     indexI;

    for( wCount=0; wCount < pAliasNames->wCount; wCount++ )
    {
        addressAlias = new Setup_UUIE_sourceAddress;

        if( addressAlias == NULL )
        {
            goto cleanup;
        }

        ZeroMemory( (PVOID)addressAlias, sizeof(Setup_UUIE_sourceAddress) );
        
        addressAlias -> next = currHead;
        currHead = addressAlias;
        
        pAliasItem = &(pAliasNames->pItems[wCount]);

        // then do the required memory copying.
        if( pAliasItem -> wType == h323_ID_chosen )
        {
            addressAlias ->value.choice = h323_ID_chosen;
            addressAlias ->value.u.h323_ID.length = pAliasItem -> wDataLength;

            _ASSERTE( pAliasItem -> wDataLength );

            addressAlias->value.u.h323_ID.value = 
                new WCHAR[pAliasItem -> wDataLength];
        
            if( addressAlias->value.u.h323_ID.value == NULL )
            {
                goto cleanup;
            }

            CopyMemory((PVOID)addressAlias->value.u.h323_ID.value,
                   (PVOID)pAliasItem->pData,
                   pAliasItem -> wDataLength * sizeof(WCHAR) );
        }
        else if( pAliasItem -> wType == e164_chosen )
        {
            addressAlias ->value.choice = e164_chosen;

            for( indexI =0; indexI < pAliasItem->wDataLength; indexI++ )
            {
                addressAlias->value.u.e164[indexI] = (BYTE)pAliasItem->pData[indexI];
            }

            addressAlias->value.u.e164[ pAliasItem->wDataLength ] = '\0';
        }
        else
        {
            continue;
        }
    }

    return currHead;

cleanup:

    FreeAddressAliases( (PSetup_UUIE_destinationAddress)currHead );
    return NULL;
}


/*BOOL 
SetSetupMsgAddressAliasWithPrefix(
                                  PH323_ALIASITEM pCallerAlias,
                                  Setup_UUIE_sourceAddress *addressAlias
                                 )
{

    UINT indexI;
    addressAlias -> next = NULL;
    UINT uPrefixLength = pCallerAlias -> wPrefixLength;
    UINT uDataLength = pCallerAlias -> wDataLength;

    if(pCallerAlias->wType == h323_ID_chosen)
    {
        addressAlias->value.choice = h323_ID_chosen;

        addressAlias->value.u.h323_ID.length = 
            (WORD)(uPrefixLength + uDataLength);

        if(!addressAlias->value.u.h323_ID.length)
        {
            addressAlias->value.u.h323_ID.value = NULL;
            //no data to copy
            return TRUE;
        }

        addressAlias->value.u.h323_ID.value =
            (WCHAR*)new char[(uPrefixLength + uDataLength) * sizeof(WCHAR)];
    
        if( addressAlias->value.u.h323_ID.value == NULL )
        {
            return FALSE;
        }
    
        addressAlias->value.u.h323_ID.length = (WORD)(uDataLength+uPrefixLength);
        
        if( uPrefixLength != 0 )
        {
            CopyMemory((PVOID)addressAlias->value.u.h323_ID.value,
                    (PVOID)pCallerAlias->pPrefix,
                    uPrefixLength * sizeof(WCHAR) );
        }            

        if( uDataLength != 0 )
        {
            CopyMemory((PVOID)&addressAlias->value.u.h323_ID.value[uPrefixLength],
                   (PVOID)pCallerAlias->pData,
                   uDataLength * sizeof(WCHAR) );
        }
    }
    else if(pCallerAlias->wType == e164_chosen )
    {
        addressAlias->value.choice = e164_chosen;
        for (indexI = 0; indexI < uPrefixLength; ++indexI)
        {
            addressAlias->value.u.e164[indexI] = (BYTE)(pCallerAlias->pPrefix[indexI]);
        }
        for (indexI = 0; indexI < uDataLength; ++indexI)
        {
            addressAlias->value.u.e164[uPrefixLength + indexI] = (BYTE)(pCallerAlias->pData[indexI]);
        }
        for (indexI = uDataLength + uPrefixLength; indexI < sizeof(addressAlias->value.u.e164); ++indexI)
        {
            addressAlias->value.u.e164[indexI] = 0;
        }
    }
    else
    {
        //un identified alias type
        return FALSE;
    }

    return TRUE;
}*/


void 
CopyVendorInfo( 
               OUT VendorIdentifier* vendor 
              )
{
    H323_VENDORINFO*  pVendorInfo = g_pH323Line -> GetVendorInfo();

    vendor->bit_mask = 0;
    vendor->vendor.t35CountryCode = pVendorInfo ->bCountryCode;
    vendor->vendor.t35Extension = pVendorInfo ->bExtension;
    vendor->vendor.manufacturerCode = pVendorInfo ->wManufacturerCode;
    if (pVendorInfo ->pProductNumber && pVendorInfo ->pProductNumber->pOctetString &&
            pVendorInfo ->pProductNumber->wOctetStringLength)
    {
        vendor->bit_mask |= productId_present;
        vendor->productId.length =
            pVendorInfo ->pProductNumber->wOctetStringLength;
        CopyMemory( (PVOID)&vendor->productId.value,
            (PVOID)pVendorInfo ->pProductNumber->pOctetString,
            pVendorInfo ->pProductNumber->wOctetStringLength);
    }
    if (pVendorInfo ->pVersionNumber && pVendorInfo ->pVersionNumber->pOctetString &&
            pVendorInfo ->pVersionNumber->wOctetStringLength)
    {
        vendor->bit_mask |= versionId_present;
        vendor->versionId.length =
            pVendorInfo ->pVersionNumber->wOctetStringLength;
        CopyMemory( (PVOID)&vendor->versionId.value,
            (PVOID)pVendorInfo ->pVersionNumber->pOctetString,
            pVendorInfo ->pVersionNumber->wOctetStringLength);
    }
}


// check to see if entry is in list
BOOL 
IsInList( 
        IN LIST_ENTRY * List, 
        IN LIST_ENTRY * Entry
        )
{
    LIST_ENTRY *    Pos;

    for( Pos = List -> Flink; Pos != List; Pos = Pos -> Flink )
    {
        if( Pos == Entry )
        {
            return TRUE;
        }
    }

    return FALSE;
}


void WriteProtocolDiscriminator(
                                PBUFFERDESCR    pBuf,
                                DWORD *         dwPDULen
                               )
{
    // space for the length byte
    (*dwPDULen)++;

    _ASSERTE( pBuf->dwLength > *dwPDULen );

    *(PDTYPE *)pBuf->pbBuffer = Q931PDVALUE;
    pBuf->pbBuffer += sizeof(PDTYPE);
}

//------------------------------------------------------------------------------
// Write a variable length Q931 call reference.  See Q931 section 4.3.
//------------------------------------------------------------------------------

void 
WriteCallReference(
                    PBUFFERDESCR    pBuf,
                    WORD *          pwCallReference,
                    DWORD *         pdwPDULen 
                  )
{
    int indexI;

    // space for the length byte
    (*pdwPDULen) += 1+ sizeof(WORD);

    _ASSERTE( pBuf->dwLength > *pdwPDULen );

    // the length byte
    *pBuf->pbBuffer = (BYTE)sizeof(WORD);
    pBuf->pbBuffer++;

    for (indexI = 0; indexI < sizeof(WORD); indexI++)
    {
        // Copy the value bytes to the buffer
        *pBuf->pbBuffer =
            (BYTE)(((*pwCallReference) >> ((sizeof(WORD) - 1 -indexI) * 8)) & 0xff);
        pBuf->pbBuffer++;
    }
}


void
FreeCallForwardParams( 
                      IN PCALLFORWARDPARAMS pCallForwardParams
                     )
{
    LPFORWARDADDRESS pForwardedAddress, pTemp;

    if( pCallForwardParams != NULL )
    {
        if( pCallForwardParams->divertedToAlias.pData != NULL )
        {
            delete pCallForwardParams->divertedToAlias.pData;
        }

        pForwardedAddress = pCallForwardParams->pForwardedAddresses;
        while( pForwardedAddress )
        {
            pTemp = pForwardedAddress->next;
            FreeForwardAddress( pForwardedAddress );
            pForwardedAddress = pTemp;
        }

        delete pCallForwardParams;
    }
}


void    
FreeForwardAddress( 
                   IN LPFORWARDADDRESS pForwardAddress
                  )
{
    if( pForwardAddress != NULL )
    {
        if( pForwardAddress->callerAlias.pData != NULL )
        {
            delete pForwardAddress->callerAlias.pData;
        }

        if( pForwardAddress->divertedToAlias.pData != NULL )
        {
            delete pForwardAddress->divertedToAlias.pData;
        }

        delete pForwardAddress;
    }
}



//Replaces first alias item in the alias list with the alias address passed.
BOOL
MapAliasItem(
    IN PH323_ALIASNAMES pCalleeAliasNames,
    IN AliasAddress*    pAliasAddress )
{
    int iIndex;

    _ASSERTE( pCalleeAliasNames && pCalleeAliasNames->pItems );

    if( pCalleeAliasNames != NULL )
    {
        switch( pAliasAddress->choice )
        {
        case e164_chosen:

            pCalleeAliasNames->pItems[0].wType = pAliasAddress->choice;
                
            if( pCalleeAliasNames->pItems[0].pData != NULL )
            {
                delete pCalleeAliasNames->pItems[0].pData;
            }
        
            pCalleeAliasNames->pItems[0].wDataLength = 
                (WORD)strlen( pAliasAddress->u.e164 );

            pCalleeAliasNames->pItems[0].pData = 
                new WCHAR[pCalleeAliasNames->pItems[0].wDataLength];

            if( pCalleeAliasNames->pItems[0].pData == NULL )
            {
                return FALSE;
            }

            for( iIndex=0; iIndex < pCalleeAliasNames->pItems[0].wDataLength;
                iIndex++ )
            {
                pCalleeAliasNames->pItems[0].pData[iIndex] =
                    pAliasAddress->u.e164[iIndex];
            }
            break;

        case h323_ID_chosen:

            pCalleeAliasNames->pItems[0].wType = pAliasAddress->choice;
                
            if( pCalleeAliasNames->pItems[0].pData != NULL )
            {
                delete pCalleeAliasNames->pItems[0].pData;
            }

            pCalleeAliasNames->pItems[0].wDataLength =
                (WORD)pAliasAddress->u.h323_ID.length;

            pCalleeAliasNames->pItems[0].pData =
                new WCHAR[pCalleeAliasNames->pItems[0].wDataLength];

            if( pCalleeAliasNames->pItems[0].pData == NULL )
            {
                return FALSE;
            }

            CopyMemory( (PVOID)pCalleeAliasNames->pItems[0].pData,
                (PVOID)pAliasAddress->u.h323_ID.value,
                pCalleeAliasNames->pItems[0].wDataLength );

            break;
        }
    }
    return TRUE;
}


//
//creates a new alias list and copies the first alias item from the given list.
//
PH323_ALIASNAMES 
DuplicateAliasName(
    PH323_ALIASNAMES pSrcAliasNames
    )
{
    PH323_ALIASNAMES pDestAliasNames = new H323_ALIASNAMES;
    
    if( pDestAliasNames == NULL )
    {
        return NULL;
    }

    ZeroMemory( pDestAliasNames, sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( 
            pDestAliasNames, 
            pSrcAliasNames->pItems[0].pData, 
            pSrcAliasNames->pItems[0].wType ) )
    {
        delete pDestAliasNames;
        return NULL;
    }

    return pDestAliasNames;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\media.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    media.cpp

Abstract:

    TAPI Service Provider functions related to media.

        TSPI_lineConditionalMediaDetection
        TSPI_lineGetID
        TSPI_lineMSPIdentify
        TSPI_lineReceiveMSPData
        TSPI_lineSetDefaultMediaDetection
        TSPI_lineSetMediaMode

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 

//                                                                           
// Include files                                                             
//                                                                           

#include "globals.h"
#include <initguid.h>
#include "line.h"
#include "ras.h"

// {0F1BE7F8-45CA-11d2-831F-00A0244D2298}
DEFINE_GUID(CLSID_IPMSP,
0x0F1BE7F8,0x45CA, 0x11d2, 0x83, 0x1F, 0x0, 0xA0, 0x24, 0x4D, 0x22, 0x98);


//                                                                           
// TSPI procedures                                                           
//                                                                           


/*++

Routine Description:

    If the Service Provider can monitor for the indicated set of media modes 
    AND support the capabilities indicated in pCallParams, then it sets the 
    indicated media moditoring modes for the line and replies with a "success" 
    indication.  Otherwise, it leaves the media monitoring modes for the line 
    unchanged and replies with a "failure" indication.  
    
    A TAPI lineOpen that specifies the device ID LINE_MAPPER typically results
    in calling this procedure for multiple line devices to hunt for a suitable
    line, possibly also opening as-yet unopened lines.  A "success" result 
    indicates that the line is suitable for the calling application's 
    requirements.  Note that the media monitoring modes demanded at the TSPI 
    level are the union of monitoring modes demanded by multiple applications
    at the TAPI level.  As a consequence of this, it is most common for 
    multiple media mode flags to be set simultaneously at this level.  The 
    Service Provider should test to determine if it can support at least the 
    specified set regardless of what modes are currently in effect.

    The Device ID LINE_MAPPER is never used at the TSPI level.

    The service provider shall return an error (e.g., LINEERR_RESOURCEUNAVAIL)
    if, at the time this function is called, it is impossible to place a new 
    call on the specified line device (in other words, if it would return 
    LINEERR_CALLUNAVAIL or LINEERR_RESOURCEUNAVAIL should TSPI_lineMakeCall be 
    invoked immediately after opening the line).

    The function operates strictly synchronously.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to 
        have media monitoring and parameter capabilities tested and set.

    dwMediaModes - Specifies the media mode(s) of interest to the app, of 
        type LINEMEDIAMODE. The dwMediaModes parameter is used to register 
        the app as a potential target for inbound call and call hand off for 
        the specified media mode. This parameter is ignored if the OWNER flag 
        is not set in dwPrivileges. 

    pCallParams - Specifies a far pointer to a structure of type 
        LINECALLPARAMS.  It describes the call parameters that the line device 
        should be able to provide.  

Return Values:

    Returns zero if the function is successful, or a negative error number if 
    an error has occurred. Possible error returns are:

        LINEERR_INVALADDRESSMODE - The address mode is invalid.

        LINEERR_INVALBEARERMODE - The bearer mode is invalid.

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

        LINEERR_RESOURCEUNAVAIL - The specified operation cannot be completed 
            because of resource overcommitment.

--*/
LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE               hdLine, 
    DWORD                  dwMediaModes,
    LPLINECALLPARAMS const pCallParams
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCondMediaDetect - Entered." ));
    
    // attempt to close line device
    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_INVALLINEHANDLE;
    }

    // see if we support media modes specified
    if (dwMediaModes & ~H323_LINE_MEDIAMODES)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "do not support media modes 0x%08lx.",
             dwMediaModes ));

        // do not support media mode
        return LINEERR_INVALMEDIAMODE;
    }

    // validate pointer
    if (pCallParams != NULL)
    {
        // see if we support media modes specified
        if (pCallParams->dwMediaMode & ~H323_LINE_MEDIAMODES)
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "do not support media modes 0x%08lx.",
                 pCallParams->dwMediaMode ));

            // do not support media mode
            return LINEERR_INVALMEDIAMODE;
        }

        // see if we support bearer modes
        if (pCallParams->dwBearerMode & ~H323_LINE_BEARERMODES)
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "do not support bearer mode 0x%08lx.",
                pCallParams->dwBearerMode ));

            // do not support bearer mode
            return LINEERR_INVALBEARERMODE;
        }

        // see if we support address modes
        if (pCallParams->dwAddressMode & ~H323_LINE_ADDRESSMODES)
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "do not support address mode 0x%08lx.",
                pCallParams->dwAddressMode ));

            // do not support address mode
            return LINEERR_INVALADDRESSMODE;
        }
    }

    // retrieve line device pointer from handle
    if (g_pH323Line -> GetHDLine() != hdLine)
    {
        // invalid line device handle
        return LINEERR_INVALLINEHANDLE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCondMediaDetect - Entered." ));
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING pDeviceID,
    LPCWSTR     pwszDeviceClass,
    HANDLE      hTargetProcess
    )
    
/*++

Routine Description:

    This function returns a device ID for the specified device class 
    associated with the selected line, address or call.

    This function can be used to retrieve a line device ID given a 
    line handle. Although the TAPI DLL has sufficient information to 
    determine the line device ID from a line handle, it may still call 
    this operation in such a fashion on behalf of an application that 
    has opened a line device using LINE_MAPPER.  The Service Provider 
    should support the "line" device class to allow applications to 
    determine the real line device ID of an opened line.

    This function can also be used to obtain the device ID of a phone 
    device or media device (e.g., mci waveform, mci midi, wave, fax, 
    etc.) associated with a call, address or line. This ID can then be 
    used with the appropriate API (e.g., phone, mci, midi, wave, etc.) 
    to select the corresponding media device associated with the specified 
    call.

    Note that the notion of Windows device class is different from that of 
    media mode. For example, the interactive voice or stored voice media 
    modes may be accessed using either the mci waveaudio or the low level 
    wave device classes. A media modes describes a format of information 
    on a call, a device class defines a Windows API used to manage that 
    stream. Often, a single media stream may be accessed using multiple 
    device classes, or a single device class (e.g., the Windows COMM API) 
    may provide access to multiple media modes. 

    Note that a new device class value is defined in TAPI 2.0: 
    
        "comm/datamodem/portname" 
        
    When TSPI_lineGetID is called specifying this device class on a line 
    device that supports the class, the VARSTRING structure returned will 
    contain a null-terminated ANSI (not UNICODE) string specifying the name 
    of the port to which the specified modem is attached, such as "COM1\0". 
    This is intended primarily for identification purposes in user interface, 
    but could be used under some circumstances to open the device directly, 
    bypassing the service provider (if the service provider does not already 
    have the device open itself). If there is no port associated with the 
    device, a null string ("\0") is returned in the VARSTRING structure (with 
    a string length of 1).

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        to be queried.

    dwAddressID - Specifies an address on the given open line device.

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be queried.

    dwSelect - Specifies the whether the device ID requested is associated 
        with the line, address or a single call, of type LINECALLSELECT. 

    pDeviceID - Specifies a far pointer to the memory location of type 
        VARSTRING where the device ID is returned. Upon successful completion 
        of the request, this location is filled with the device ID. The 
        format of the returned information depends on the method used by the 
        device class (API) for naming devices. 

    pwszDeviceClass - Specifies a far pointer to a NULL-terminated ASCII 
        string that specifies the device class of the device whose ID is 
        requested. Valid device class strings are those used in the SYSTEM.INI 
        section to identify device classes.

    hTargetProcess - The process handle of the application on behalf of which 
        the TSPI_lineGetID function is being invoked. If the information being 
        returned in the VARSTRING structure includes a handle for use by the 
        application, the service provider should create or duplicate the handle
        for the process.

        If hTargetProcess is set to INVALID_HANDLE_VALUE, then the application
        is executing on a remote client system and it is not possible to create
        a duplicate handle directly. Instead, the VARSTRING structure should 
        contain a UNC name of a network device or other name that the remote 
        client can use to access the device. If this is not possible, then the 
        function should fail.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The hdCall parameter is an invalid handle.

        LINEERR_INVALCALLSELECT - The specified dwCallSelect parameter is 
            invalid.

        LINEERR_INVALCALLSTATE - One or more of the specified calls are not in 
            a valid state for the requested operation. 

        LINEERR_NODEVICE - The line device has no associated device for the 
            given device class.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.
        
--*/

{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetID - Entered." ));
    // do not support device
    return LINEERR_NODEVICE;
}


LONG
TSPIAPI
TSPI_lineMSPIdentify(
    DWORD  dwDeviceID,
    GUID * pCLSID
    )
    
/*++

Routine Description:

    This procedure is called after TAPI has initialized the line device in 
    order to determine the assoicated Media Service Provider.

Arguments:

    dwDeviceID - Identifies the line device to be opened.  The value 
        LINE_MAPPER for a device ID is not permitted.

    pCLSID - Points to a GUID-sized memory location which the service 
        provider writes the class identifier of the associated media 
        service provider.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 

--*/

{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMSPIdentify - Entered." ));

    if( g_pH323Line -> GetDeviceID() != dwDeviceID )
    {
        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // copy class id
    *pCLSID = CLSID_IPMSP;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMSPIdentify - Exited." ));
    
    // success
    return NOERROR;

}

    
/*++
Routine Description:

    This procedure is called to deliver a payload from the MSP.

Arguments:
    
    hdCall - Handle to line object.

    hdCall - Handle to call object associated with MSP.

    hdMSPLine - Handle to MSP.

    pBuffer - Pointer to opaque buffer with MSP data.

    dwSize - Size of buffer above.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 
--*/
LONG 
TSPIAPI 
TSPI_lineReceiveMSPData( 
    HDRVLINE hdLine,
    HDRVCALL hdCall,
    HDRVMSPLINE hdMSPLine,
    LPVOID pBuffer, 
    DWORD dwSize 
    )
{
    HTAPIMSPLINE htMSPLine;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineRecvMSPData - Entered." ));
    
    // line device
    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_RESOURCEUNAVAIL;
    }

    PH323_CALL pCall;
    PTspMspMessage pMessage = (PTspMspMessage)pBuffer;

    if( !g_pH323Line -> IsValidMSPHandle( hdMSPLine, &htMSPLine ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Invalid MSP handle:%lx.", hdMSPLine ));
        return LINEERR_RESOURCEUNAVAIL;
    }

    // see if call handle is valid
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "msp message-wrong call handle." ));
        return LINEERR_INVALCALLHANDLE;
    }

    // validate pointer and message size
    if( dwSize < pMessage -> dwMessageSize )
    {
        pCall -> Unlock();
        H323DBG(( DEBUG_LEVEL_ERROR, "msp message has wrong size." ));
        //error in processing message
        return LINEERR_OPERATIONFAILED;
    }

    //HandleMSPMessage unlocks the call object always.
    if(!pCall -> HandleMSPMessage( pMessage, hdMSPLine, htMSPLine ) )
    {
        //error in processing message
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineRecvMSPData - Exited." ));
    
    // success
    return NOERROR;
}


/*++

Routine Description:

    This procedure tells the Service Provider the new set of Media Modes to 
    detect for the indicated line (replacing any previous set). It also sets 
    the initial set of Media Modes that should be monitored for on subsequent 
    calls (inbound or outbound) on this line. 

    The TAPI DLL typically calls this function to update the set of detected 
    media modes for the line to the union of all modes selected by all 
    outstanding lineOpens whenever a line is Opened or Closed at the TAPI 
    level. A lineOpen attempt is rejected if media detection is rejected. 
    A single call to this procedure is typically the result of a lineOpen 
    that does not specify the device ID LINE_MAPPER. The Device ID LINE_MAPPER
    is never used at the TSPI level.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to 
        have media monitoring set.

    dwMediaModes - Specifies the media mode(s) of interest to the TAPI DLL, 
        of type LINEMEDIAMODE. 

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

--*/

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
	HRESULT	hResult;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetDefaultMediaDtect-Entered." ));
    
    // attempt to close line device
    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_RESOURCEUNAVAIL;
    }
        
    // see if unknown bit is specified 
    if (dwMediaModes & LINEMEDIAMODE_UNKNOWN)
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE, "clearing unknown media mode." ));

        // clear unknown bit from modes
        dwMediaModes &= ~LINEMEDIAMODE_UNKNOWN;
    }

    // see if both audio bits are specified 
    if ((dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) &&
        (dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE))
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "clearing automated voice media mode." ));

        // clear extra audio bit from modes
        dwMediaModes &= ~LINEMEDIAMODE_INTERACTIVEVOICE;
    }

    // see if we support media modes specified
    if (dwMediaModes & ~H323_LINE_MEDIAMODES)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "do not support media modes 0x%08lx.", dwMediaModes ));

        // do not support media mode
        return LINEERR_INVALMEDIAMODE;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE,
        "line %d enabled to detect media modes 0x%08lx.",
         g_pH323Line->GetDeviceID(), dwMediaModes ));

    g_pH323Line -> Lock();

    // record media modes to detect
    g_pH323Line->SetMediaModes( dwMediaModes );     

    // see if we need to start listening
    if( g_pH323Line -> IsMediaDetectionEnabled() &&
        (g_pH323Line -> GetState() != H323_LINESTATE_LISTENING)
      )
    {
        hResult = Q931AcceptStart();

        if( hResult != S_OK )
        {
            // release line device
            g_pH323Line -> Unlock();

            // could not cancel listen
            return LINEERR_OPERATIONFAILED;
        }
        g_pH323Line -> SetState( H323_LINESTATE_LISTENING );
        RasStart();
    }
    else if( (g_pH323Line -> GetState() == H323_LINESTATE_LISTENING) &&
             !g_pH323Line -> IsMediaDetectionEnabled() )
    {
        //stop listening means dont close exiting calls but stop accepting new
        //ones for some time close means close all the existing calls and stop
        //listening for new ones

        Q931AcceptStop();
        //RasStop();

        g_pH323Line -> SetState( H323_LINESTATE_OPENED );
    }
               
    // release line device
    g_pH323Line -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetDefaultMediaDetect - Exited." ));
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL hdCall,
    DWORD    dwMediaMode
    )
    
/*++

Routine Description:

    This function changes the call's media as stored in the call's 
    LINECALLINFO structure.

    Other than changing the call's media as stored in the call's 
    LINECALLINFO structure, this procedure is simply "advisory" in the sense 
    that it indicates an expected media change that is about to occur, rather 
    than forcing a specific change to the call.  Typical usage is to set a 
    calls media mode to a specific known media mode, or to exclude possible 
    media modes as long as the call's media mode is not fully known; i.e., 
    the UNKNOWN media mode flag is set.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        undergoing a change in media mode.  Valid call states: any.

    dwMediaMode - Specifies the new media mode(s) for the call, of type 
        LINEMEDIAMODE. As long as the UNKNOWN media mode flag is set, 
        multiple other media mode flags may be set as well. This is used 
        to indentify a call's media mode as not fully determined, but 
        narrowed down to one of just a small set of specified media modes. 
        If the UNKNOWN flag is not set, then only a single media mode can 
        be specified. 

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALMEDIAMODE - The specified media mode parameter is invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\main.cpp ===
#include "globals.h"
#include "line.h"
#include "config.h"


#define H323_VERSION_LO     0x00000000
#define H323_VERSION_HI     0x00000000

#define TSPI_VERSION_LO     0x00030000
#define TSPI_VERSION_HI     TAPI_CURRENT_VERSION


//                                                                           
// Global variables                                                          
//                                                                           


HINSTANCE       g_hInstance;
WCHAR           g_pwszProviderInfo[64];
WCHAR           g_pwszLineName[16];
DWORD           g_dwTSPIVersion;

//                                                                           
// Private procedures                                                        
//                                                                           


/*++

Routine Description:

    This function determines whether or not specified TSPI version is
    supported by the service provider.

Arguments:

    dwLowVersion - Specifies the lowest TSPI version number under which the
        TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    dwHighVersion - Specifies the highest TSPI version number under which
        the TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    pdwTSPIVersion - Specifies a far pointer to a DWORD. The service
        provider fills this location with the highest TSPI version number,
        within the range requested by the caller, under which the service
        provider is willing to operate. The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

Return Values:

    Returns true if successful.

--*/

BOOL
H323NegotiateTSPIVersion(
                        IN DWORD  dwLowVersion,
                        IN DWORD  dwHighVersion,
                        OUT PDWORD pdwTSPIVersion
                        )
{
    // validate extension version range
    if ((TSPI_VERSION_HI <= dwHighVersion) &&
        (TSPI_VERSION_HI >= dwLowVersion))
    {
        // save negotiated version
        *pdwTSPIVersion = TSPI_VERSION_HI;

        // success
        return TRUE;
    }
    else if( (dwHighVersion <= TSPI_VERSION_HI) &&
             (dwHighVersion >= TSPI_VERSION_LO) )
    {
        // save negotiated version
        *pdwTSPIVersion = dwHighVersion;

        // success
        return TRUE;
    }

    H323DBG(( DEBUG_LEVEL_FORCE, "TSPI version (%08XH:%08XH) rejected.",
		dwHighVersion, dwLowVersion ));

    // failure
    return FALSE;
}



//                                                                           
// Public procedures                                                         
//                                                                           


/*++

Routine Description:

    This function determines whether or not specified TSPI version is
    supported by the service provider.

Arguments:

    dwTSPIVersion - Specifies the TSPI version to validate.

Return Values:

    Returns true if successful.

--*/

BOOL
H323ValidateTSPIVersion(
                        IN DWORD dwTSPIVersion
                       )
{
    // see if specified version is supported
    if ((dwTSPIVersion >= TSPI_VERSION_LO) &&
        (dwTSPIVersion <= TSPI_VERSION_HI)) {

        // success
        return TRUE;
    }

    H323DBG((DEBUG_LEVEL_FORCE, "do not support TSPI version %08XH.",
		dwTSPIVersion));

    // failure
    return FALSE;
}


/*++

Routine Description:

    This function determines whether or not specified extension version is
    supported by the service provider.

Arguments:

    dwExtVersion - Specifies the extension version to validate.

Return Values:

    Returns true if successful.

--*/

BOOL
H323ValidateExtVersion(
                        IN DWORD dwExtVersion
                      )
{
    //  no device specific extension
    if (dwExtVersion == H323_VERSION_HI) {

        // success
        return TRUE;
    }

    H323DBG((
        DEBUG_LEVEL_ERROR,
        "do not support extension version %d.%d.",
        HIWORD(dwExtVersion),
        LOWORD(dwExtVersion)
        ));

    // failure
    return FALSE;
}



//                                                                           
// TSPI procedures                                                           
//                                                                           


/*++

Routine Description:

    This function returns the highest SPI version the Service Provider is
    willing to operate under for this device given the range of possible
    SPI versions.

    The TAPI DLL typically calls this function early in the initialization
    sequence for each line device.  In addition, it calls this with the
    value INITIALIZE_NEGOTIATION for dwDeviceID to negotiate an interface
    version for calling early initialization functions.

    Note that when dwDeviceID is INITIALIZE_NEGOTIATION, this function must
    not return LINEERR_OPERATIONUNAVAIL, since this function (with that value)
    is mandatory for negotiating the overall interface version even if the
    service provider supports no line devices.

    Negotiation of an Extension version is done through the separate
    procedure TSPI_lineNegotiateExtVersion.

Arguments:

    dwDeviceID - Identifies the line device for which interface version
        negotiation is to be performed.  In addition to device IDs within
        the range the Service Provider supports, this may be the value:

        INITIALIZE_NEGOTIATION - This value is used to signify that an overall
            interface version is to be negotiated.  Such an interface version
            is required for functions that can be called early in the
            initialization sequence, i.e., before the device ID range has
            been set.

    dwLowVersion - Specifies the lowest TSPI version number under which the
        TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    dwHighVersion - Specifies the highest TSPI version number under which
        the TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    pdwTSPIVersion - Specifies a far pointer to a DWORD. The service
        provider fills this location with the highest TSPI version number,
        within the range requested by the caller, under which the service
        provider is willing to operate. The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number. If the requested range does not overlap the range
        supported by the service provider, the function returns
        LINEERR_INCOMPATIBLEAPIVERSION.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_BADDEVICEID - The specified device identifier or line device
            identifier (such as in a dwDeviceID parameter) is invalid or
            out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot
            be supported by the Telephony API implementation and/or
            corresponding service provider.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified
            or unknown reason.

--*/

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD  dwDeviceID,
    DWORD  dwLowVersion,
    DWORD  dwHighVersion,
    PDWORD pdwTSPIVersion
    )
{
    DWORD dwTSPIVersion;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - Entered." ));

    // see if this is a init line device
    if ((DWORD_PTR)dwDeviceID == INITIALIZE_NEGOTIATION)
    {

        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "tapisrv supports tspi version %d.%d through %d.%d.",
            HIWORD(dwLowVersion),
            LOWORD(dwLowVersion),
            HIWORD(dwHighVersion),
            LOWORD(dwHighVersion)
            ));

        // perform version negotiation
        if (!H323NegotiateTSPIVersion(
                dwLowVersion,
                dwHighVersion,
                &dwTSPIVersion)) 
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - bad version." ));
            
            // negotiated version not agreed upon
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }

    // see if this is a valid line device
    }
    else if( g_pH323Line -> GetDeviceID() == (DWORD)dwDeviceID )
    {
        // perform version negotiation
        if (!H323NegotiateTSPIVersion(
                dwLowVersion,
                dwHighVersion,
                &dwTSPIVersion))
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - incompat ver." ));

            // negotiated version not agreed upon
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    else 
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - bad device id:%d:%d.", 
            g_pH323Line -> GetDeviceID(), dwDeviceID));
        
        // do not recognize device
        return LINEERR_BADDEVICEID;
    }

    // return negotiated version
    *pdwTSPIVersion = dwTSPIVersion;
    g_dwTSPIVersion = dwTSPIVersion;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - Exited." ));
    
    // success
    return NOERROR;
}


/*++

Routine Description:

    Loads strings from resource table.

Arguments:

    None.

Return Values:

    Returns true if successful. 

--*/

BOOL
H323LoadStrings(
    )
{
    DWORD dwNumBytes;
    DWORD dwNumChars;
    WCHAR wszBuffer[256];

    // load string into buffer
    dwNumChars = LoadStringW(
                    g_hInstance,
                    IDS_LINENAME,
                    g_pwszLineName,
                    sizeof(g_pwszLineName)/sizeof(WCHAR)
                    );

    if( dwNumChars == 0 )
        return FALSE;

    // load string into buffer
    dwNumChars = LoadStringW(
                    g_hInstance,
                    IDS_PROVIDERNAME,
                    g_pwszProviderInfo,
                    sizeof(g_pwszProviderInfo)/sizeof(WCHAR)
                    );
    
    if( dwNumChars == 0 )
        return FALSE;

    // success
    return TRUE;
}



//                                                                           
// Public Procedures                                                         
//                                                                           


/*++

Routine Description:

    Dll entry point.

Arguments:

    Same as DllMain.

Return Values:

    Returns true if successful. 

--*/

BOOL
WINAPI
DllMain(
    PVOID  DllHandle,
    ULONG  Reason,
    LPVOID lpReserved 
    )
{
    BOOL fOk = TRUE;

    // check if new process attaching
    if (Reason == DLL_PROCESS_ATTACH)
    {
		g_RegistrySettings.dwLogLevel = DEBUG_LEVEL_FORCE;

		H323DBG ((DEBUG_LEVEL_FORCE, "DLL_PROCESS_ATTACH"));

        // store the handle into a global variable so that
        // the UI code can use it.
        g_hInstance = (HINSTANCE)DllHandle;

        // turn off thread attach messages
        DisableThreadLibraryCalls( g_hInstance );

        // start h323 tsp
        fOk = H323LoadStrings();

    // check if new process detaching
    }
    else if (Reason == DLL_PROCESS_DETACH)
    {
		H323DBG ((DEBUG_LEVEL_FORCE, "DLL_PROCESS_DETACH"));

#if DBG
        TRACELogDeRegister();
#else
        CloseLogFile();
#endif
        fOk = TRUE;
    }

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\q931pdu.h ===
#ifndef _Q931PDU_H
#define _Q931PDU_H

#define TPKT_VERSION            3
#define TPKT_HEADER_SIZE        4

#define CALLED_PARTY_PLAN_E164      0x01
#define CALLED_PARTY_EXT_BIT        0x80
#define CALLED_PARTY_TYPE_UNKNOWN   0x00


typedef struct S_BUFFERDESCR
{
    DWORD dwLength;
    BYTE *pbBuffer;

}BUFFERDESCR, *PBUFFERDESCR;


typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;

} ASN1_CODER_INFO;


// Mask to extract a message type from a byte
#define MESSAGETYPEMASK 0x7f

typedef BYTE MESSAGEIDTYPE;

//==========================================================
// BEARER FIELD DEFINITIONS
//==========================================================
// bearer encoding bits...
#define BEAR_EXT_BIT                0x80

// bearer coding standards...
#define BEAR_CCITT                  0x00
        // ...others not needed...

// bearer information transfer capability...
#define BEAR_UNRESTRICTED_DIGITAL   0x08
        // ...others not needed...

// bearer transfer mode...
#define BEAR_CIRCUIT_MODE			0x00
#define BEAR_PACKET_MODE            0x40
        // ...others not needed...

// bearer information transfer rate...
#define BEAR_NO_CIRCUIT_RATE        0x00
#define BEAR_MULTIRATE				0x18
        // ...others not needed...

// bearer layer1 protocol...
#define BEAR_LAYER1_INDICATOR       0x20
#define BEAR_LAYER1_H221_H242       0x05
        // ...others not needed...


// Q931 defined message types
#define ALERTINGMESSAGETYPE      0x01
#define PROCEEDINGMESSAGETYPE    0x02
#define CONNECTMESSAGETYPE       0x07
#define CONNECTACKMESSAGETYPE    0x0F
#define PROGRESSMESSAGETYPE      0x03
#define SETUPMESSAGETYPE         0x05
#define SETUPACKMESSAGETYPE      0x0D

#define RESUMEMESSAGETYPE        0x26
#define RESUMEACKMESSAGETYPE     0x2E
#define RESUMEREJMESSAGETYPE     0x22
#define SUSPENDMESSAGETYPE       0x25
#define SUSPENDACKMESSAGETYPE    0x2D
#define SUSPENDREJMESSAGETYPE    0x21
#define USERINFOMESSAGETYPE      0x20

#define DISCONNECTMESSAGETYPE    0x45
#define RELEASEMESSAGETYPE       0x4D
#define RELEASECOMPLMESSAGETYPE  0x5A
#define RESTARTMESSAGETYPE       0x46
#define RESTARTACKMESSAGETYPE    0x4E

#define SEGMENTMESSAGETYPE       0x60
#define CONGCTRLMESSAGETYPE      0x79
#define INFORMATIONMESSAGETYPE   0x7B
#define NOTIFYMESSAGETYPE        0x6E
#define STATUSMESSAGETYPE        0x7D
#define STATUSENQUIRYMESSAGETYPE 0x75


// Mask to remove only the field identifier from a type 1 single octet field
#define TYPE1IDENTMASK 0xf0

// Mask to remove only the value from a type 1 single octet field
#define TYPE1VALUEMASK 0x0f

// Type of the field identitifiers
typedef BYTE FIELDIDENTTYPE;

// Field identifiers
// Single octet values
#define IDENT_RESERVED        0x80
#define IDENT_SHIFT           0x90
#define IDENT_MORE            0xA0
#define IDENT_SENDINGCOMPLETE 0xA1
#define IDENT_CONGESTION      0xB0
#define IDENT_REPEAT          0xD0

// Variable length octet values
#define IDENT_SEGMENTED       0x00
#define IDENT_BEARERCAP       0x04
#define IDENT_CAUSE           0x08
#define IDENT_CALLIDENT       0x10
#define IDENT_CALLSTATE       0x14
#define IDENT_CHANNELIDENT    0x18
#define IDENT_PROGRESS        0x1E
#define IDENT_NETWORKSPEC     0x20
#define IDENT_NOTIFICATION    0x27
#define IDENT_DISPLAY         0x28
#define IDENT_DATE            0x29
#define IDENT_KEYPAD          0x2C
#define IDENT_SIGNAL          0x34
#define IDENT_INFORMATIONRATE 0x40
#define IDENT_ENDTOENDDELAY   0x42
#define IDENT_TRANSITDELAY    0x43
#define IDENT_PLBINARYPARAMS  0x44
#define IDENT_PLWINDOWSIZE    0x45
#define IDENT_PACKETSIZE      0x46
#define IDENT_CLOSEDUG        0x47
#define IDENT_REVCHARGE       0x4A
#define IDENT_CALLINGNUMBER   0x6C
#define IDENT_CALLINGSUBADDR  0x6D
#define IDENT_CALLEDNUMBER    0x70
#define IDENT_CALLEDSUBADDR   0x71
#define IDENT_REDIRECTING     0x74
#define IDENT_TRANSITNET      0x78
#define IDENT_RESTART         0x79
#define IDENT_LLCOMPATIBILITY 0x7C
#define IDENT_HLCOMPATIBILITY 0x7D
#define IDENT_USERUSER        0x7E

#define USE_ASN1_ENCODING     5   
//-------------------------------------------------------------------
// Structures for messages and information elements
//-------------------------------------------------------------------

typedef BYTE PDTYPE;
#define Q931PDVALUE ((PDTYPE)0x08)

typedef WORD CRTYPE;

// Since right now we don't need to separate out the individual
// parts of the fields of the structures these are the base 
// types from which the fields are made.
// Single octet element type 1 (contains a value)
struct S_SINGLESTRUCT1
{
    BOOLEAN fPresent;
    BYTE Value;
};

// Single octet element type 2 (does not contain a value)
struct S_SINGLESTRUCT2
{
    BOOLEAN fPresent;
};

// Variable length element
// Maximum element size
#define MAXVARFIELDLEN 131

struct S_VARSTRUCT
{
    BOOLEAN fPresent;
    BYTE dwLength;
    BYTE pbContents[MAXVARFIELDLEN];
};

// Right now all of the fields are bound to the simplest
// structures above.  No parsing other than just 
// single octet/variable octet is done.  When the values
// in some of the subfields are important, change the 
// structures here and change the appropriate parsing
// routine to generate the right structure

// The shift element is a single type 1
typedef struct S_SINGLESTRUCT1 SHIFTIE;
typedef struct S_SINGLESTRUCT1 *PSHIFTIE;

// The more data element is a single type 2
typedef struct S_SINGLESTRUCT2 MOREDATAIE;
typedef struct S_SINGLESTRUCT2 *PMOREDATAIE;

// The congestion level element is a single type 1
typedef struct S_SINGLESTRUCT1 CONGESTIONIE;
typedef struct S_SINGLESTRUCT1 *PCONGESTIONIE;

// The bearer capability element is a variable 
typedef struct S_VARSTRUCT BEARERCAPIE;
typedef struct S_VARSTRUCT *PBEARERCAPIE;

// The cause element is a variable 
typedef struct S_VARSTRUCT CAUSEIE;
typedef struct S_VARSTRUCT *PCAUSEIE;

// The call identity element is a variable 
typedef struct S_VARSTRUCT CALLIDENTIE;
typedef struct S_VARSTRUCT *PCALLIDENTIE;

// The call state element is a variable 
typedef struct S_VARSTRUCT CALLSTATEIE;
typedef struct S_VARSTRUCT *PCALLSTATEIE;

// The channel identifier element is a variable 
typedef struct S_VARSTRUCT CHANIDENTIE;
typedef struct S_VARSTRUCT *PCHANIDENTIE;

// The progress indicator element is a variable 
typedef struct S_VARSTRUCT PROGRESSIE;
typedef struct S_VARSTRUCT *PPROGRESSIE;

// The network specific element is a variable 
typedef struct S_VARSTRUCT NETWORKIE;
typedef struct S_VARSTRUCT *PNETWORKIE;

// The notification indicator element is a variable 
typedef struct S_VARSTRUCT NOTIFICATIONINDIE;
typedef struct S_VARSTRUCT *PNOTIFICATIONINDIE;

// The display element is a variable 
typedef struct S_VARSTRUCT DISPLAYIE;
typedef struct S_VARSTRUCT *PDISPLAYIE;

// The date element is a variable 
typedef struct S_VARSTRUCT DATEIE;
typedef struct S_VARSTRUCT *PDATEIE;

// The keypad element is a variable 
typedef struct S_VARSTRUCT KEYPADIE;
typedef struct S_VARSTRUCT *PKEYPADIE;

// The signal element is a variable 
typedef struct S_VARSTRUCT SIGNALIE;
typedef struct S_VARSTRUCT *PSIGNALIE;

// The information rate element is a variable 
typedef struct S_VARSTRUCT INFORATEIE;
typedef struct S_VARSTRUCT *PINFORATEIE;

// The transit delay element is a variable 
typedef struct S_VARSTRUCT TRANSITDELAYIE;
typedef struct S_VARSTRUCT *PTRANSITDELAYIE;

// The packet layer binary parameters element is a variable 
typedef struct S_VARSTRUCT PLBINARYPARAMSIE;
typedef struct S_VARSTRUCT *PPLBINARYPARAMSIE;

// The packet layer window size element is a variable 
typedef struct S_VARSTRUCT PLWINDOWSIZEIE;
typedef struct S_VARSTRUCT *PPLWINDOWSIZEIE;

// The packet size element is a variable 
typedef struct S_VARSTRUCT PACKETSIZEIE;
typedef struct S_VARSTRUCT *PPACKETSIZEIE;

// The closed user group element is a variable 
typedef struct S_VARSTRUCT CLOSEDUGIE;
typedef struct S_VARSTRUCT *PCLOSEDUGIE;

// The calling party number element is a variable 
typedef struct S_VARSTRUCT CALLINGNUMBERIE;
typedef struct S_VARSTRUCT *PCALLINGNUMBERIE;

// The calling party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLINGSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLINGSUBADDRIE;

// The called party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLEDSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLEDSUBADDRIE;

// The redirecting number element is a variable 
typedef struct S_VARSTRUCT REDIRECTINGIE;
typedef struct S_VARSTRUCT *PREDIRECTINGIE;

// The restart indicator element is a variable 
typedef struct S_VARSTRUCT RESTARTIE;
typedef struct S_VARSTRUCT *PRESTARTIE;

// The low layer compatibility element is a variable 
typedef struct S_VARSTRUCT LLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PLLCOMPATIBILITYIE;

// The higher layer compatibility element is a variable 
typedef struct S_VARSTRUCT HLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PHLCOMPATIBILITYIE;

#define Q931_PROTOCOL_X209 ((PDTYPE)0x05)


typedef struct
{
    BOOLEAN fPresent;
    BYTE    ProtocolDiscriminator;
    WORD    wUserInfoLen;
    BYTE    pbUserInfo[0x1000];   // 4k bytes should be good for now...

} USERUSERIE, *PUSERUSERIE;


typedef struct S_PARTY_NUMBER
{
    BOOLEAN fPresent;
    BYTE    NumberType;
    BYTE    NumberingPlan;
    BYTE    PartyNumberLength;
    BYTE    PartyNumbers[MAXVARFIELDLEN];

} CALLEDNUMBERIE, *PCALLEDNUMBERIE;


// Q932 defined message types
#define HOLDMESSAGETYPE				0x24
#define HOLDACKMESSAGETYPE			0x28
#define HOLDREJECTMESSAGETYPE		0x30
#define RETRIEVEMESSAGETYPE			0x31
#define RETRIEVEACKMESSAGETYPE		0x33
#define RETRIEVEREJECTMESSAGETYPE	0x37
#define FACILITYMESSAGETYPE			0x62
#define REGISTERMESSAGETYPE			0x64

#define IDENT_FACILITY        0x1C
typedef struct S_VARSTRUCT FACILITYIE;
typedef struct S_VARSTRUCT *PFACILITYIE;


// Generic structure for a Q.931 message
typedef struct S_MESSAGE
{
    PDTYPE ProtocolDiscriminator;
    CRTYPE wCallRef;
    MESSAGEIDTYPE MessageType;
    SHIFTIE Shift;
    MOREDATAIE MoreData;
    BEARERCAPIE BearerCapability;
    CAUSEIE Cause;
    CALLIDENTIE CallIdentity;
    CALLSTATEIE CallState;
    CHANIDENTIE ChannelIdentification;
    PROGRESSIE ProgressIndicator;
    NETWORKIE NetworkFacilities;
    NOTIFICATIONINDIE NotificationIndicator;
    DISPLAYIE Display;
    DATEIE Date;
    KEYPADIE Keypad;
    SIGNALIE Signal;
    INFORATEIE InformationRate;
    PLBINARYPARAMSIE PacketLayerBinaryParams;
    PLWINDOWSIZEIE PacketLayerWindowSize;
    PACKETSIZEIE PacketSize;
    CALLINGNUMBERIE CallingPartyNumber;
    CALLINGSUBADDRIE CallingPartySubaddress;
    CALLEDNUMBERIE CalledPartyNumber;
    CALLEDSUBADDRIE CalledPartySubaddress;
    REDIRECTINGIE RedirectingNumber;
    RESTARTIE RestartIndicator;
    LLCOMPATIBILITYIE LowLayerCompatibility;
    HLCOMPATIBILITYIE HighLayerCompatibility;
    FACILITYIE Facility;
    USERUSERIE UserToUser;

}Q931MESSAGE, *PQ931MESSAGE;


typedef struct _BINARY_STRING
{
    WORD length;
    BYTE *pbBuffer;

} BINARY_STRING;


typedef struct _Q931_SETUP_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    PH323_ALIASNAMES        pCallerAliasList;
    PH323_ALIASNAMES        pCalleeAliasList;
    PH323_ALIASNAMES        pExtraAliasList;
    PH323_ALIASITEM         pExtensionAliasItem;
    BOOL                    fSourceAddrPresent;
    BOOL                    fCallerAddrPresent;
    BOOL                    fCalleeAddrPresent;
    BOOL                    fCalleeDestAddrPresent;
    H323_ADDR               sourceAddr;             // originating addr
    H323_ADDR               callerAddr;             // gk addr
    H323_ADDR               calleeAddr;             // local addr
    H323_ADDR               calleeDestAddr;         // target destination addr
    WORD                    wGoal;
    WORD                    wCallType;
    BOOL                    bCallerIsMC;
    GUID                    ConferenceID;
    H323_ENDPOINTTYPE       EndpointType;
    H323_VENDORINFO         VendorInfo;
    BOOL                    fFastStartPresent;
    PH323_FASTSTART         pFastStart;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;

} Q931_SETUP_ASN;


typedef struct _Q931_RELEASE_COMPLETE_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    BYTE                    bReason;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;

} Q931_RELEASE_COMPLETE_ASN;


typedef struct _Q931_CONNECT_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    BOOL                    h245AddrPresent;
    H323_ADDR               h245Addr;
    GUID                    ConferenceID;
    H323_ENDPOINTTYPE       EndpointType;
    H323_VENDORINFO         VendorInfo;
    BOOL                    fFastStartPresent;
    PH323_FASTSTART         pFastStart;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;

} Q931_CONNECT_ASN;


typedef struct _Q931_ALERTING_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    BOOL                    fH245AddrPresent;
    H323_ADDR               h245Addr;
    BOOL                    fFastStartPresent;
    PH323_FASTSTART         pFastStart;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;

} Q931_ALERTING_ASN, Q931_CALL_PROCEEDING_ASN ;


typedef struct _Q931_FACILITY_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    H323_ADDR               AlternativeAddr;
    BOOL                    fAlternativeAddressPresent;
    PH323_ALIASNAMES        pAlternativeAliasList;
    GUID                    ConferenceID;
    BOOL                    ConferenceIDPresent;
    WORD                    bReason;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;
    DWORD                   dwInvokeID;
    ASN1octetstring_t       pH245PDU;
    DWORD                   dwH450APDUType;
    H323_ADDR               h245Addr;
    BOOL                    fH245AddrPresent;

} Q931_FACILITY_ASN;



//-------------------------------------------------------------------
// Initialization Routines
//-------------------------------------------------------------------
HRESULT 
WritePartyNumber(
    PBUFFERDESCR pBuf,
    BYTE bIdent,
    BYTE NumberType,
    BYTE NumberingPlan,
    BYTE bPartyNumberLength,
    BYTE *pbPartyNumbers,
    DWORD *  pdwPDULen );

void WriteProtocolDiscriminator(
    PBUFFERDESCR pBuf,
       DWORD * dwPDULen );

void WriteCallReference(
    PBUFFERDESCR pBuf,
    WORD *pwCallReference,
    DWORD * dwPDULen );
void WriteMessageType(
    PBUFFERDESCR pBuf,
    MESSAGEIDTYPE *MessageType,
    DWORD* pdwPDULen );
void WriteVariableOctet(
    PBUFFERDESCR pBuf,
    BYTE bIdent,
    BYTE dwLength,
    BYTE *pbContents,
    DWORD* pdwPDULen);
void WriteUserInformation(
    PBUFFERDESCR pBuf,
    BYTE bIdent,
    WORD wUserInfoLen,
    BYTE *pbUserInfo,
    DWORD* pdwPDULen);
HRESULT 
ParseSingleOctetType1(
    PBUFFERDESCR pBuf,
    BYTE *bIdent,
    BYTE *Value);
HRESULT
ParseSingleOctetType2(
    PBUFFERDESCR pBuf,
    BYTE *bIdent);
HRESULT 
ParseVariableOctet(
    PBUFFERDESCR pBuf,
    BYTE *pdwLength,
    BYTE *pbContents);
HRESULT 
ParseVariableASN(
    PBUFFERDESCR pBuf,
    BYTE *bIdent,
    BYTE *ProtocolDiscriminator,
    WORD *pwUserInfoLen,     // Length of the User Information.
    BYTE *pbUserInfo);       // Bytes of the User Information.
BYTE
GetNextIdent(
    void *BufferPtr);
HRESULT
ParseProtocolDiscriminator(
    PBUFFERDESCR pBuf,
    PDTYPE *Discrim);
HRESULT
ParseCallReference(
    PBUFFERDESCR pBuf,
    CRTYPE *wCallRef);
HRESULT
ParseMessageType(
    PBUFFERDESCR pBuf,
    MESSAGEIDTYPE *MessageType);
HRESULT
ParseShift(
    PBUFFERDESCR pBuf,
    PSHIFTIE FieldStruct);
HRESULT
ParseFacility(
    PBUFFERDESCR pBuf,
    PFACILITYIE FieldStruct);
HRESULT
ParseBearerCapability(
    PBUFFERDESCR pBuf,
    PBEARERCAPIE FieldStruct);
HRESULT
ParseCause(
    PBUFFERDESCR pBuf,
    PCAUSEIE FieldStruct);
HRESULT
ParseCallState(
    PBUFFERDESCR pBuf,
    PCALLSTATEIE FieldStruct);
HRESULT
ParseChannelIdentification(
    PBUFFERDESCR pBuf,
    PCHANIDENTIE FieldStruct);
HRESULT
ParseProgress(
    PBUFFERDESCR pBuf,
    PPROGRESSIE FieldStruct);
HRESULT 
ParseNetworkSpec(
    PBUFFERDESCR pBuf,
    PNETWORKIE FieldStruct);
HRESULT
ParseNotificationIndicator(
    PBUFFERDESCR pBuf,
    PNOTIFICATIONINDIE FieldStruct);
HRESULT
ParseDisplay(
    PBUFFERDESCR pBuf,
    PDISPLAYIE FieldStruct);
HRESULT
ParseDate(
    PBUFFERDESCR pBuf,
    PDATEIE FieldStruct);
HRESULT
ParseKeypad(
    PBUFFERDESCR pBuf,
    PKEYPADIE FieldStruct);
HRESULT
ParseSignal(
    PBUFFERDESCR pBuf,
    PSIGNALIE FieldStruct);
HRESULT
ParseInformationRate(
    PBUFFERDESCR pBuf,
    PINFORATEIE FieldStruct);
HRESULT
ParseCallingPartyNumber(
    PBUFFERDESCR pBuf,
    PCALLINGNUMBERIE FieldStruct);
HRESULT
ParseCallingPartySubaddress(
    PBUFFERDESCR pBuf,
    PCALLINGSUBADDRIE FieldStruct);
HRESULT
ParseCalledPartyNumber(
    PBUFFERDESCR pBuf, 
    PCALLEDNUMBERIE FieldStruct);
HRESULT
ParseCalledPartySubaddress(
    PBUFFERDESCR pBuf,
    PCALLEDSUBADDRIE FieldStruct);
HRESULT
ParseRedirectingNumber(
    PBUFFERDESCR pBuf, 
    PREDIRECTINGIE FieldStruct);
HRESULT
ParseLowLayerCompatibility(
    PBUFFERDESCR pBuf,
    PLLCOMPATIBILITYIE FieldStruct);
HRESULT
ParseHighLayerCompatibility(
    PBUFFERDESCR pBuf,
    PHLCOMPATIBILITYIE FieldStruct);
HRESULT
ParseUserToUser(
    PBUFFERDESCR pBuf,
    PUSERUSERIE FieldStruct);
HRESULT
ParseQ931Field(
    PBUFFERDESCR pBuf,
    PQ931MESSAGE pMessage);
BOOL ParseVendorInfo(
                     PH323_VENDORINFO pDestVendorInfo,
                     VendorIdentifier* pVendor
                     );
BOOL ParseNonStandardData( 
        H323NonStandardData * dstNonStdData,
        H225NonStandardParameter *srcNonStdData );
BOOL AliasAddrToAliasNames( 
                        PH323_ALIASNAMES *ppTarget, 
                        Setup_UUIE_sourceAddress *pSource );
HRESULT AliasAddrToAliasItem( PH323_ALIASITEM pTarget, 
                           AliasAddress *pSource);
void FreeConnectASN( Q931_CONNECT_ASN *pConnectASN );
void FreeSetupASN( Q931_SETUP_ASN* pSetupASN );
void FreeAlertingASN( Q931_ALERTING_ASN* pAlertingASN );
void FreeFacilityASN( IN Q931_FACILITY_ASN* pFacilityASN );
void FreeProceedingASN( Q931_CALL_PROCEEDING_ASN* pProceedingASN );
void FreeVendorInfo( PH323_VENDORINFO pVendorInfo );
void FreeAliasNames( PH323_ALIASNAMES pSource );
void FreeAliasItems( PH323_ALIASNAMES pSource );
void FreeFastStart( PH323_FASTSTART pFastStart );
PH323_FASTSTART CopyFastStart( PSetup_UUIE_fastStart pSrcFastStart );
int GetTpktLength( char * pTpktHeader );
int Q931_InitModule(void);
void SetupTPKTHeader( BYTE * pbTpktHeader, DWORD dwLength);
BOOL IsInList( LIST_ENTRY * List, LIST_ENTRY * Entry );
DWORD GetLocalIPAddress( DWORD dwRemoteAddr );
BOOL CompareAliasItems( AliasAddress* pAliasAddress, 
    PH323_ALIASITEM pAliasItem );
BOOL MapAliasItem(  IN PH323_ALIASNAMES pCalleeAliasNames, 
    IN AliasAddress* pAliasAddress );

#define ISVALIDQ931MESSAGE(messageType)   ( (messageType==ALERTINGMESSAGETYPE) ||   \
                                            (messageType==PROCEEDINGMESSAGETYPE) || \
                                            (messageType==CONNECTMESSAGETYPE) ||    \
                                            (messageType==SETUPMESSAGETYPE) ||      \
                                            (messageType==RELEASEMESSAGETYPE) ||    \
                                            (messageType==RELEASECOMPLMESSAGETYPE)||\
                                            (messageType==FACILITYMESSAGETYPE) )


//-------------------------------------------------------------------
// Encoding Routines
//-------------------------------------------------------------------


// extract an IP address and UDP/TCP port from an H.323 TransportAddress PDU
static __inline BOOL GetTransportAddress (
	IN	const TransportAddress *	transport,
	OUT	SOCKADDR_IN *	sockaddr)
{
    union {
        IN_ADDR		in_addr;
        UCHAR		octet	[4];
    }	ip_addr;

    _ASSERTE (transport);
    _ASSERTE (sockaddr);

    if (transport -> choice != ipAddress_chosen)
    {
        H323DBG ((DEBUG_LEVEL_WARNING, "GetTransportAddress: not IP address"));
        return FALSE;
    }

    if (transport -> u.ipAddress.ip.length != 4)
    {
        H323DBG ((DEBUG_LEVEL_WARNING, "GetTransportAddress: bogus IP address byte length"));
        return FALSE;
    }

#define	Bx(x) ip_addr.octet [x] = transport -> u.ipAddress.ip.value [x];

    Bx (0)
    Bx (1)
    Bx (2)
    Bx (3)

#undef	Bx

    sockaddr -> sin_family = AF_INET;
    sockaddr -> sin_port = htons (transport -> u.ipAddress.port);
    sockaddr -> sin_addr = ip_addr.in_addr;

    return TRUE;
}

// construct an H.323 TransportAddress from an IP address and TCP/UDP port
static __inline void SetTransportAddress (
	IN	const SOCKADDR_IN * addr,
	OUT	TransportAddress * transport)
{
	union {
		IN_ADDR		in_addr;
		UCHAR		octet	[4];
	}	ip_addr;

	_ASSERTE( addr );
	_ASSERTE( transport );

	ip_addr.in_addr = addr -> sin_addr;

#define	Bx(x) transport -> u.ipAddress.ip.value [x] = ip_addr.octet [x];

	Bx (0)
	Bx (1)
	Bx (2)
	Bx (3)

#undef	Bx

	transport -> choice = ipAddress_chosen;
	transport -> u.ipAddress.port = ntohs (addr -> sin_port);
	transport -> u.ipAddress.ip.length = 4;
}


#endif //_Q931PDU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\ras.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ras.cpp

Abstract:

    The RAS client functionality (Transport/session mangement)

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#include "globals.h"
#include "q931obj.h"
#include "line.h"
#include "q931pdu.h"
#include "ras.h"



#define OID_ELEMENT_LAST(Value) { NULL, Value }

#define OID_ELEMENT(Index,Value) { (ASN1objectidentifier_s *) &_OID_H225ProtocolIdentifierV1 [Index], Value },

// this stores an unrolled constant linked list
const ASN1objectidentifier_s    _OID_H225ProtocolIdentifierV1 [] = {
    OID_ELEMENT (1, 0)          // 0 = ITU-T
    OID_ELEMENT (2, 0)          // 0 = Recommendation
    OID_ELEMENT (3, 8)          // 8 = H Series
    OID_ELEMENT (4, 2250)       // 2250 = H.225.0
    OID_ELEMENT (5, 0)          // 0 = Version
    OID_ELEMENT_LAST (1)        // 1 = V1
};

#undef  OID_ELEMENT



#define OID_ELEMENT(Index,Value) { (ASN1objectidentifier_s *) &_OID_H225ProtocolIdentifierV2 [Index], Value },

// this stores an unrolled constant linked list
const ASN1objectidentifier_s    _OID_H225ProtocolIdentifierV2 [] = {
    OID_ELEMENT (1, 0)          // 0 = ITU-T
    OID_ELEMENT (2, 0)          // 0 = Recommendation
    OID_ELEMENT (3, 8)          // 8 = H Series
    OID_ELEMENT (4, 2250)       // 2250 = H.225.0
    OID_ELEMENT (5, 0)          // 0 = Version
    OID_ELEMENT_LAST (2)        // 2 = V2
};


RAS_CLIENT      g_RasClient;
static LONG     RasSequenceNumber;


PH323_ALIASNAMES 
RASGetRegisteredAliasList()
{
    return g_RasClient.GetRegisteredAliasList();
}

HRESULT RasStart (void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RasStart - entered." ));

    if( (g_RegistrySettings.saGKAddr.sin_addr.s_addr == NULL) ||
        (g_RegistrySettings.saGKAddr.sin_addr.s_addr == INADDR_NONE )
      )
    {
        return E_FAIL;
    }

    if (g_RegistrySettings.fIsGKEnabled)
    {
        if( !g_RasClient.Initialize (&g_RegistrySettings.saGKAddr) )
            return E_OUTOFMEMORY;
        //send the rrq message
        if( !g_RasClient.SendRRQ( NOT_RESEND_SEQ_NUM, NULL ) )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "couldn't send rrq." ));
            //m_RegisterState = RAS_REGISTER_STATE_IDLE;
            return E_FAIL;
        }
    }
    H323DBG(( DEBUG_LEVEL_TRACE, "RasStart - exited." ));
    return S_OK;
}

void RasStop (void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RasStop - entered." ));
    
    DWORD dwState = g_RasClient.GetRegState();

    if( (dwState==RAS_REGISTER_STATE_REGISTERED) ||
        (dwState==RAS_REGISTER_STATE_RRQSENT) )
    {
        //send urq
        g_RasClient.SendURQ( NOT_RESEND_SEQ_NUM, NULL );
    }
    
    g_RasClient.Shutdown();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "RasStop - exited." ));
}

BOOL RasIsRegistered (void)
{
    return g_RasClient.GetRegState() == RAS_REGISTER_STATE_REGISTERED;
}

HRESULT RasGetLocalAddress (
    OUT SOCKADDR_IN *   ReturnLocalAddress)
{
    return g_RasClient.GetLocalAddress (ReturnLocalAddress);
}

USHORT RasAllocSequenceNumber (void)
{
    USHORT  SequenceNumber;

    H323DBG(( DEBUG_LEVEL_TRACE, "RasAllocSequenceNumber - entered." ));
    
    do
    {
        SequenceNumber = (USHORT) InterlockedIncrement (&RasSequenceNumber);
    } while( SequenceNumber == 0 );

    H323DBG(( DEBUG_LEVEL_TRACE, "RasAllocSequenceNumber - exited." ));
    
    return SequenceNumber;
}


HRESULT RasEncodeSendMessage (
    IN  RasMessage * pRasMessage)
{
    return g_RasClient.IssueSend( pRasMessage ) ? S_OK : E_FAIL;
}


HRESULT RasGetEndpointID (
    OUT EndpointIdentifier *    ReturnEndpointID)
{
    return g_RasClient.GetEndpointID (ReturnEndpointID);
}


void RasHandleRegistryChange()
{
    g_RasClient.HandleRegistryChange();
}


RAS_CLIENT::RAS_CLIENT()
{
    //create the timer queue
    m_hRegTimer = NULL;
    m_hRegTTLTimer = NULL;
    m_hUnRegTimer = NULL;
    m_RegisterState = RAS_REGISTER_STATE_IDLE;
    m_IoRefCount = 0;
    m_dwState = RAS_CLIENT_STATE_NONE;
    m_pAliasList = NULL;
    m_Socket = INVALID_SOCKET;
    InitializeListHead( &m_sendPendingList );
    InitializeListHead( &m_sendFreeList );
    InitializeListHead( &m_aliasChangeRequestList );
    m_dwSendFreeLen = 0;
    m_lastRegisterSeqNum = 0;
    m_wTTLSeqNumber = 0;
    m_UnRegisterSeqNum = 0;
    m_wRASSeqNum = 0;
    m_dwRegRetryCount = 0;
    m_dwUnRegRetryCount = 0;
    m_dwCallsInProgress = 0;
    m_dwRegTimeToLive = 0;
    m_pRRQExpireContext = NULL;
    m_pURQExpireContext = NULL;

    ZeroMemory( (PVOID)&m_GKAddress, sizeof(SOCKADDR_IN) );
    ZeroMemory( (PVOID)&m_ASNCoderInfo, sizeof(ASN1_CODER_INFO) );
    ZeroMemory( (PVOID)&m_PendingURQ, sizeof(PENDINGURQ) );
    ZeroMemory( (PVOID)&m_RASEndpointID, sizeof(ENDPOINT_ID) );

    // No need to check the result of this one since this object is
    // not allocated on heap, right when the DLL is loaded.
    InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 0x80000000 );
}


RAS_CLIENT::~RAS_CLIENT (void)
{
    //free the various lists
    FreeSendList( &m_sendFreeList );
    FreeSendList( &m_sendPendingList );
    FreeSendList( &m_aliasChangeRequestList );

    DeleteCriticalSection( &m_CriticalSection );
}


HRESULT 
RAS_CLIENT::GetEndpointID(
    OUT EndpointIdentifier * ReturnEndpointID )
{
    HRESULT hr;

    H323DBG(( DEBUG_LEVEL_TRACE, "GetEndpointID - entered." ));
    Lock();

    if (m_RegisterState == RAS_REGISTER_STATE_REGISTERED)
    {
        ReturnEndpointID->length = m_RASEndpointID.length;
        
        //m_RASEndpointID.value is an array and not a pointer. 
        //so explicit assignment of each field is required
        ReturnEndpointID->value = m_RASEndpointID.value;
        hr = S_OK;
    }
    else
    {
        hr = S_OK;
    }

    Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "GetEndpointID - exited." ));
    return hr;
}


//the addr and port are in network byte order
BOOL
RAS_CLIENT::Initialize(
    IN SOCKADDR_IN* psaGKAddr
    )
{
    DWORD   dwSize;
    int     rc;

    H323DBG(( DEBUG_LEVEL_TRACE, "RAS Initialize entered:%p.",this ));
    //set the m_GKAddress here

    dwSize = sizeof m_RASEndpointID.value;
    GetComputerNameW( m_RASEndpointID.value, &dwSize );
    m_RASEndpointID.length = (WORD)wcslen(m_RASEndpointID.value);

    m_pAliasList = new H323_ALIASNAMES;
    if( m_pAliasList == NULL )
    {
        goto error2;
    }
    
    ZeroMemory( (PVOID)m_pAliasList, sizeof(H323_ALIASNAMES) );

    if( g_RegistrySettings.fIsGKLogOnPhoneEnabled )
    {
        if(!AddAliasItem( m_pAliasList,
              g_RegistrySettings.wszGKLogOnPhone,
              e164_chosen ))
        {
           goto error3;
        }
    }
    
    if( g_RegistrySettings.fIsGKLogOnAccountEnabled )
    {
        if(!AddAliasItem( m_pAliasList,
              g_RegistrySettings.wszGKLogOnAccount,
              h323_ID_chosen ))
        {
           goto error3;
        }
    }

    if( m_pAliasList->wCount == 0 )
    {
        //add the machine name as he default alias
        if(!AddAliasItem( m_pAliasList,
                  m_RASEndpointID.value,
                  h323_ID_chosen ))
        {
            goto error3;
        }
    }

    rc = InitASNCoder();

    if( rc != ASN1_SUCCESS )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "RAS_InitCoder() returned: %d ", rc));
        goto error3;
    }

    m_GKAddress = *psaGKAddr;

    if(!InitializeIo() )
    {
        goto error4;
    }
    
    H323DBG((DEBUG_LEVEL_TRACE, "GK addr:%lx.", m_GKAddress.sin_addr.s_addr ));
    m_dwState = RAS_CLIENT_STATE_INITIALIZED;
    m_RegisterState = RAS_REGISTER_STATE_IDLE;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS Initialize exited:%p.",this ));
    return TRUE;

error4:
    TermASNCoder();
error3:
    FreeAliasNames( m_pAliasList );
    m_pAliasList = NULL;
error2:
    return FALSE;

}

    
void 
RAS_CLIENT::Shutdown(void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS Shutdown entered:%p.",this ));

    Lock();

    switch (m_dwState)
    {
    case RAS_CLIENT_STATE_NONE:
        // nothing to do
        break;

    case RAS_CLIENT_STATE_INITIALIZED:

        if( m_Socket != INVALID_SOCKET )
        {
            closesocket(m_Socket);
            m_Socket = INVALID_SOCKET;
        }

        //free alias list
        FreeAliasNames( m_pAliasList );
        m_pAliasList = NULL;

        TermASNCoder();
    
        m_dwState = RAS_CLIENT_STATE_NONE;

        //delete if any timers
        if( m_hRegTTLTimer )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTTLTimer, NULL );
            m_hRegTTLTimer = NULL;
        }

        if( m_hUnRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL );
            m_hUnRegTimer = NULL;
            m_dwUnRegRetryCount = 0;
        }

        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL );
            m_hRegTimer = NULL;
        }

        if( m_pRRQExpireContext != NULL )
        {
            delete m_pRRQExpireContext;
            m_pRRQExpireContext = NULL;
        }

        if( m_pURQExpireContext != NULL )
        {
            delete m_pURQExpireContext;
            m_pURQExpireContext = NULL;
        }
        
        m_RegisterState = RAS_REGISTER_STATE_IDLE;
        m_dwSendFreeLen = 0;
        m_dwRegRetryCount = 0;
        m_dwUnRegRetryCount = 0;
        m_dwCallsInProgress = 0;
        m_lastRegisterSeqNum = 0;
        m_wTTLSeqNumber = 0;
        m_UnRegisterSeqNum = 0;
        m_wRASSeqNum = 0;
        m_dwRegTimeToLive = 0;
        ZeroMemory( (PVOID)&m_GKAddress, sizeof(SOCKADDR_IN) );
        ZeroMemory( (PVOID)&m_ASNCoderInfo, sizeof(ASN1_CODER_INFO) );
        ZeroMemory( (PVOID)&m_PendingURQ, sizeof(PENDINGURQ) );
        ZeroMemory( (PVOID)&m_RASEndpointID, sizeof(ENDPOINT_ID) );
    
        break;

    default:
        _ASSERTE(FALSE);
        break;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS Shutdown exited:%p.",this ));
}


BOOL
RAS_CLIENT::FreeSendList(
                        PLIST_ENTRY pListHead
                        )
{
    PLIST_ENTRY         pLE;
    RAS_SEND_CONTEXT *  pSendContext;

    H323DBG(( DEBUG_LEVEL_ERROR, "FreeSendList entered." ));

    // process list until empty
    while( IsListEmpty(pListHead) == FALSE )
    {
        // retrieve first entry
        pLE = RemoveHeadList(pListHead);

        // convert list entry to structure pointer
        pSendContext = CONTAINING_RECORD( pLE, RAS_SEND_CONTEXT, ListEntry );
        
        //  release memory
        if( pSendContext != NULL )
        {
            delete pSendContext;
            pSendContext = NULL;
        }
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "FreeSendList exited:%p.", this ));
    // success
    return TRUE;
}

//!!always called from a lock
RAS_SEND_CONTEXT *
RAS_CLIENT::AllocSendBuffer(void)
{
    RAS_SEND_CONTEXT *pSendBuf;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "AllocSendBuffer entered:%p.",this ));
    
    if( m_dwSendFreeLen )
    {
        m_dwSendFreeLen--;
        _ASSERTE( IsListEmpty(&m_sendFreeList) == FALSE );

        LIST_ENTRY *pLE = RemoveHeadList( &m_sendFreeList );
        pSendBuf = CONTAINING_RECORD( pLE, RAS_SEND_CONTEXT, ListEntry );

    }
    else
    {
        pSendBuf = (RAS_SEND_CONTEXT*)new RAS_SEND_CONTEXT;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "AllocSendBuffer exited:%p.",this ));
    return pSendBuf;
}


//!!always called from a lock
void 
RAS_CLIENT::FreeSendBuffer(
                           IN RAS_SEND_CONTEXT * pBuffer
                          )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeSendBuffer entered:%p.",this ));

    if(m_dwSendFreeLen < RASIO_SEND_BUFFER_LIST_MAX )
    {
        m_dwSendFreeLen++;
        InsertHeadList( &m_sendFreeList, &pBuffer->ListEntry );
    }
    else
    {
        delete pBuffer;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeSendBuffer exited:%p.",this ));
}

    
//RAS client functions
void
NTAPI RAS_CLIENT::RegExpiredCallback ( 
    IN  PVOID       ContextParameter,       // ExpContext
    IN  BOOLEAN     TimerFired)             // not used
{
    EXPIRE_CONTEXT *    pExpireContext;
    RAS_CLIENT *        This;

    H323DBG(( DEBUG_LEVEL_TRACE, "RegExpiredCallback - entered." ));
    
    _ASSERTE( ContextParameter );
    pExpireContext = (EXPIRE_CONTEXT *)ContextParameter;
    _ASSERTE( m_pRRQExpireContext == pExpireContext );

    _ASSERTE(pExpireContext -> RasClient);
    This = (RAS_CLIENT *) pExpireContext -> RasClient;

    This -> RegExpired (pExpireContext -> seqNumber);

    H323DBG(( DEBUG_LEVEL_TRACE, "RegExpiredCallback - exited." ));
    delete pExpireContext;
}


void
NTAPI RAS_CLIENT::UnregExpiredCallback(
    IN  PVOID       ContextParameter,       // ExpContext
    IN  BOOLEAN     TimerFired)             // not used
{
    EXPIRE_CONTEXT *    pExpireContext;
    RAS_CLIENT *        This;

    H323DBG(( DEBUG_LEVEL_TRACE, "UnregExpiredCallback - entered." ));
    
    _ASSERTE(ContextParameter);
    pExpireContext = (EXPIRE_CONTEXT *) ContextParameter;
    _ASSERTE( m_pURQExpireContext == pExpireContext );

    _ASSERTE( pExpireContext -> RasClient );
    This = (RAS_CLIENT *) pExpireContext -> RasClient;

    This -> UnregExpired( pExpireContext -> seqNumber );

    H323DBG(( DEBUG_LEVEL_TRACE, "UnregExpiredCallback - exited." ));
    delete pExpireContext;
}


void
NTAPI RAS_CLIENT::TTLExpiredCallback(
    IN  PVOID       ContextParameter,       // ExpContext
    IN  BOOLEAN     TimerFired)             // not used
{
    RAS_CLIENT *        This;

    _ASSERTE(ContextParameter);

    This = (RAS_CLIENT*)ContextParameter;
     
    _ASSERTE(This == &g_RasClient);
    This -> TTLExpired();
}


//If we have already sent RRQ to this GK then this RRQ is supposed to rplace 
//the original alias list with the new list
BOOL
RAS_CLIENT::SendRRQ(
                    IN long seqNumber,
                    IN PALIASCHANGE_REQUEST pAliasChangeRequest
                   )
{
    RasMessage                              rasMessage;
    RegistrationRequest *                   RRQ;
    SOCKADDR_IN                             sockAddr;
    EXPIRE_CONTEXT *                        pExpireContext = NULL;
    RegistrationRequest_callSignalAddress   CallSignalAddressSequence;
    RegistrationRequest_rasAddress          RasAddressSequence;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendRRQ entered:%p.",this ));
    
    pExpireContext = new EXPIRE_CONTEXT;
    if( pExpireContext == NULL )
    {
        return FALSE;
    }

    Lock();

    // initialize the structure
    ZeroMemory (&rasMessage, sizeof rasMessage);
    rasMessage.choice = registrationRequest_chosen;
    RRQ = &rasMessage.u.registrationRequest;
    RRQ -> bit_mask = 0;
    RRQ -> protocolIdentifier = OID_H225ProtocolIdentifierV2;

    // get sequence number
    if( seqNumber != NOT_RESEND_SEQ_NUM )
    {
        RRQ -> requestSeqNum = (WORD)seqNumber;
    }
    else
    {
        RRQ -> requestSeqNum = GetNextSeqNum();
        if( pAliasChangeRequest == NULL )
        {
            m_lastRegisterSeqNum = RRQ -> requestSeqNum;
        }
        else
        {
            pAliasChangeRequest->wRequestSeqNum = RRQ -> requestSeqNum;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "RRQ seqNum:%d.", RRQ -> requestSeqNum ));
    
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 
        htons(LOWORD(g_RegistrySettings.dwQ931ListenPort));
    //we are listening for Q931 conns on all local interfaces
    //so specify just one of the local IP addresses
    sockAddr.sin_addr.s_addr = m_sockAddr.sin_addr.s_addr;
    
    SetTransportAddress( &sockAddr, &CallSignalAddressSequence.value);
    CallSignalAddressSequence.next = NULL;
    RRQ -> callSignalAddress = &CallSignalAddressSequence;

    // ras address. The UDP socket for this GK
    RasAddressSequence.next = NULL;
    RasAddressSequence.value = m_transportAddress;
    RRQ -> rasAddress = &RasAddressSequence;

    // fill in endpoint type
    RRQ -> terminalType.bit_mask |= terminal_present;
    RRQ -> terminalType.terminal.bit_mask = 0;

    //fill in terminal alias list
    if( pAliasChangeRequest && pAliasChangeRequest->pAliasList )
    {
        RRQ -> terminalAlias = (RegistrationRequest_terminalAlias *)
            SetMsgAddressAlias( pAliasChangeRequest->pAliasList );
        if (NULL == RRQ -> terminalAlias)
        {
            goto cleanup;
        }
        RRQ -> bit_mask |= RegistrationRequest_terminalAlias_present;

        RRQ -> bit_mask |= RegistrationRequest_endpointIdentifier_present;
        RRQ->endpointIdentifier.length = pAliasChangeRequest->rasEndpointID.length;
        RRQ->endpointIdentifier.value = pAliasChangeRequest->rasEndpointID.value;
    }
    else if( m_pAliasList && m_pAliasList->wCount )
    {
        RRQ -> terminalAlias = (RegistrationRequest_terminalAlias *)
            SetMsgAddressAlias( m_pAliasList );
        if (NULL == RRQ -> terminalAlias)
        {
            goto cleanup;
        }
        RRQ -> bit_mask |= RegistrationRequest_terminalAlias_present;
    }
    else
    {
        _ASSERTE(0);
    }

    //endpointVendor
    CopyVendorInfo( &(RRQ -> endpointVendor) );

    //a few random booleans
    RRQ -> discoveryComplete = FALSE;
    RRQ -> keepAlive = FALSE;
    RRQ -> willSupplyUUIEs = FALSE;

    // encode and send
    if( !IssueSend(&rasMessage) )
    {
        goto cleanup;
    }

    //delete if any previous TTL timer
    if( m_hRegTTLTimer )
    {
        DeleteTimerQueueTimer(H323TimerQueue, m_hRegTTLTimer, NULL );
        m_hRegTTLTimer = NULL;
    }

    //delete if any previous RRQ sent timer
    if( m_hRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL );
        m_hRegTimer = NULL;
    }

    pExpireContext -> RasClient = this;
    pExpireContext -> seqNumber = RRQ -> requestSeqNum;

    if( !CreateTimerQueueTimer(
            &m_hRegTimer,
            H323TimerQueue,
            RAS_CLIENT::RegExpiredCallback,
            pExpireContext,
            REG_EXPIRE_TIME, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ) )
    {
        goto cleanup;
    }
    
    if( RRQ -> bit_mask & RegistrationRequest_terminalAlias_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            RRQ -> terminalAlias);
    }

    m_dwRegRetryCount++;

    if( pAliasChangeRequest == NULL )
    {
        m_RegisterState = RAS_REGISTER_STATE_RRQSENT;
    }

    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SendRRQ exited:%p.", this ));
    return TRUE;

cleanup:
    if( RRQ -> bit_mask & RegistrationRequest_terminalAlias_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
             RRQ -> terminalAlias);
    }
    
    if( pExpireContext != NULL )
    {
        delete pExpireContext;    
    }
    
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "SendRRQ error:%p.",this ));
    return FALSE;
}


BOOL
RAS_CLIENT::SendURQ(
                    IN long seqNumber,
                    IN EndpointIdentifier * pEndpointID
                   )
{
    RasMessage              rasMessage;
    UnregistrationRequest * URQ;
    SOCKADDR_IN             sockAddr;
    EXPIRE_CONTEXT *            pExpireContext = NULL;
    UnregistrationRequest_callSignalAddress CallSignalAddressSequence;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendURQ entered:%p.",this ));
    Lock();

    if( m_RegisterState == RAS_REGISTER_STATE_RRQSENT )
    {
        //store the seqNumber of this RRQ and send URQ if we recv RCF
        m_PendingURQ.RRQSeqNumber = m_lastRegisterSeqNum;

        Unlock();
        H323DBG(( DEBUG_LEVEL_TRACE, "rrq sent:so pending urq." ));
        return TRUE;
    }
    else if( m_RegisterState != RAS_REGISTER_STATE_REGISTERED )
    {
        //if already unregistered or URQ sent then return success
        Unlock();
        H323DBG(( DEBUG_LEVEL_TRACE, "current state:%d.", m_RegisterState ));
        return TRUE;
    }

    pExpireContext = new EXPIRE_CONTEXT;
    if( pExpireContext == NULL )
    {
        goto cleanup;
    }

    ZeroMemory (&rasMessage, sizeof RasMessage);
    rasMessage.choice = unregistrationRequest_chosen;
    URQ = &rasMessage.u.unregistrationRequest;

    // get sequence number
    if( seqNumber != NOT_RESEND_SEQ_NUM )
    {
        URQ -> requestSeqNum = (WORD)seqNumber;
    }
    else
    {
        m_UnRegisterSeqNum = GetNextSeqNum();
        URQ -> requestSeqNum = (WORD)m_UnRegisterSeqNum;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "RRQ seqNum:%d.", URQ -> requestSeqNum ));
    
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 
        htons(LOWORD(g_RegistrySettings.dwQ931ListenPort));
    //we are listening for Q931 conns on all local interfaces
    //so specify just one of the local IP addresses
    sockAddr.sin_addr.s_addr = m_sockAddr.sin_addr.s_addr;

    SetTransportAddress( &sockAddr, &CallSignalAddressSequence.value);
    CallSignalAddressSequence.next = NULL;
    URQ -> callSignalAddress = &CallSignalAddressSequence;

    //get endpointidentifier by using GetComputerNameW
    URQ -> bit_mask |= UnregistrationRequest_endpointIdentifier_present;
    if( pEndpointID != NULL )
    {
        URQ->endpointIdentifier.length = pEndpointID ->length;
        URQ->endpointIdentifier.value = pEndpointID -> value;
    }
    else
    {
        URQ->endpointIdentifier.length = m_RASEndpointID.length;
        URQ->endpointIdentifier.value = m_RASEndpointID.value;
    }

    // encode and send
    if( !IssueSend( &rasMessage ) )
    {
        goto cleanup;
    }

    pExpireContext -> RasClient = this;
    pExpireContext -> seqNumber = URQ -> requestSeqNum;

    //delete if any previous RRQ sent timer
    if( m_hUnRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL );
        m_hUnRegTimer = NULL;
        m_dwUnRegRetryCount = 0;
    }

    if( !CreateTimerQueueTimer(
            &m_hUnRegTimer,
            H323TimerQueue,
            RAS_CLIENT::UnregExpiredCallback,
            pExpireContext,
            REG_EXPIRE_TIME, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE) )
    {
        goto cleanup;
    }

    //delete if any TTL timer
    if( m_hRegTTLTimer )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hRegTTLTimer, NULL );
        m_hRegTTLTimer = NULL;
    }

    m_dwUnRegRetryCount++;        
    m_RegisterState = RAS_REGISTER_STATE_URQSENT;
        
    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SendURQ exited:%p.",this ));
    return TRUE;

cleanup:
    if( pExpireContext != NULL )
    {
        delete pExpireContext;
    }
    Unlock();
    return FALSE;
}


//!!always called from a lock
BOOL
RAS_CLIENT::SendUCF(
                    IN WORD seqNumber
                   )
{
    RasMessage              rasMessage;
    UnregistrationConfirm * UCF;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendUCF entered:%p.",this ));

    // initialize the structure
    ZeroMemory (&rasMessage, sizeof rasMessage);
    rasMessage.choice = unregistrationConfirm_chosen;
    UCF = &rasMessage.u.unregistrationConfirm;
    UCF -> bit_mask = 0;
    UCF -> requestSeqNum = seqNumber;

    if( !IssueSend( &rasMessage ) )
    {
        return FALSE;
    }   

        
    H323DBG(( DEBUG_LEVEL_TRACE, "SendUCF exited:%p.",this ));
    return TRUE;
}


//!!always called from a lock
BOOL
RAS_CLIENT::SendURJ(
                    IN WORD seqNumber,
                    IN DWORD dwReason
                   )
{
    RasMessage          rasMessage;
    UnregistrationReject *  URJ;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendURJ entered:%p.",this ));

    // initialize the structure
    ZeroMemory (&rasMessage, sizeof rasMessage);
    rasMessage.choice = unregistrationReject_chosen;
    URJ = &rasMessage.u.unregistrationReject;
    URJ -> bit_mask = 0;
    URJ -> requestSeqNum = seqNumber;
    URJ -> rejectReason.choice = (WORD)dwReason;

    if( !IssueSend( &rasMessage ) )
    {
        return FALSE;
    }   
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendURJ exited:%p.",this ));
    return TRUE;
}


//!!always called from a lock
void 
RAS_CLIENT::ProcessRasMessage(
    IN RasMessage *pRasMessage
    )
{
    PH323_CALL      pCall = NULL;
    ASN1decoding_s  ASN1decInfo;

    H323DBG(( DEBUG_LEVEL_TRACE, "RAS: processing RasMessage" ));

    //Verify that the RCF came from the expected gatekeeper

    switch( pRasMessage -> choice )
    {
    case registrationReject_chosen:
        
        OnRegistrationReject( &pRasMessage -> u.registrationReject );
        break;

    case registrationConfirm_chosen:
        
        OnRegistrationConfirm( &pRasMessage -> u.registrationConfirm );
        break;

    case unregistrationRequest_chosen:
        
        OnUnregistrationRequest( &pRasMessage -> u.unregistrationRequest );
        break;

    case unregistrationReject_chosen:
        
        OnUnregistrationReject( &pRasMessage -> u.unregistrationReject );
        break;

    case unregistrationConfirm_chosen:
        
        OnUnregistrationConfirm( &pRasMessage -> u.unregistrationConfirm );
        break;

    case infoRequest_chosen:

        CopyMemory( (PVOID)&ASN1decInfo, (PVOID)m_ASNCoderInfo.pDecInfo, 
            sizeof(ASN1decoding_s) );
        
        //This function should be always called in
        //a lock and it unlocks the the ras client
        OnInfoRequest( &pRasMessage -> u.infoRequest );

        ASN1_FreeDecoded( &ASN1decInfo, pRasMessage, RasMessage_PDU );

        //return here since we have already unlocked and freed the buffer
        return;

    default:
        
        CopyMemory( (PVOID)&ASN1decInfo, (PVOID)m_ASNCoderInfo.pDecInfo, 
            sizeof(ASN1decoding_s) );

        //Don't loclk the RAS client while locking the call object.
        Unlock();
        
        HandleRASCallMessage( pRasMessage );
        ASN1_FreeDecoded( &ASN1decInfo, pRasMessage, RasMessage_PDU );

        //return here since we have already unlocked and freed the buffer
        return;
    }
     
    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pRasMessage, RasMessage_PDU );
    Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "ProcessRasMessage exited:%p.",this ));
}


//!!always called from a lock
void 
HandleRASCallMessage(
    IN RasMessage *pRasMessage
    )
{
    PH323_CALL pCall = NULL;
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS: processing RASCallMessage" ));

    switch( pRasMessage -> choice )
    {
    case admissionConfirm_chosen:

        pCall = g_pH323Line -> FindCallByARQSeqNumAndLock(
            pRasMessage -> u.admissionConfirm.requestSeqNum);

        if( pCall != NULL )
        {
            pCall -> OnAdmissionConfirm( &pRasMessage->u.admissionConfirm );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "acf:call not found:%d.", 
                pRasMessage -> u.admissionConfirm.requestSeqNum ));
        break;

    case admissionReject_chosen:

        pCall = g_pH323Line -> FindCallByARQSeqNumAndLock( 
            pRasMessage -> u.admissionReject.requestSeqNum );

        if( pCall != NULL )
        {
            pCall -> OnAdmissionReject( &pRasMessage->u.admissionReject );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "arj:call not found:%d.",
                pRasMessage -> u.admissionReject.requestSeqNum ));
        break;

    case disengageRequest_chosen:

        pCall = g_pH323Line -> FindCallByCallRefAndLock( 
            pRasMessage -> u.disengageRequest.callReferenceValue );

        if( pCall != NULL )
        {
            pCall -> OnDisengageRequest( &pRasMessage -> u.disengageRequest );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "drq:call not found:%d.", 
                pRasMessage -> u.disengageRequest.callReferenceValue ));
        break;
    
    case disengageConfirm_chosen:

        pCall = g_pH323Line -> FindCallByDRQSeqNumAndLock( 
            pRasMessage -> u.disengageConfirm.requestSeqNum );

        if( pCall != NULL )
        {
            pCall -> OnDisengageConfirm( &pRasMessage -> u.disengageConfirm );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "dcf:call not found:%d.", 
                pRasMessage -> u.disengageConfirm.requestSeqNum ));
        break;
        
    case disengageReject_chosen:

        pCall = g_pH323Line -> FindCallByDRQSeqNumAndLock( 
            pRasMessage -> u.disengageReject.requestSeqNum );

        if( pCall != NULL )
        {
            pCall -> OnDisengageReject( &pRasMessage -> u.disengageReject );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "drj:call not found:%d.", 
                pRasMessage -> u.disengageReject.requestSeqNum));
        break;

    case requestInProgress_chosen:

        pCall = g_pH323Line -> FindCallByARQSeqNumAndLock(
            pRasMessage->u.requestInProgress.requestSeqNum );

        if( pCall != NULL )
        {
            pCall -> OnRequestInProgress( &pRasMessage->u.requestInProgress );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "rip:call not found:%d.", 
                pRasMessage->u.requestInProgress.requestSeqNum ));
        break;

    default:
        _ASSERTE(0);
        H323DBG(( DEBUG_LEVEL_ERROR, "ProcessRASMessage: wrong message:%d",
            pRasMessage -> choice));
        break;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleRASCallMessage exited" ));
}


void
RAS_CLIENT::RegExpired(
    IN WORD seqNumber
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RegExpired entered:%p.", this ));
    Lock();

    m_pRRQExpireContext = NULL;
    
    if( m_hRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL );
        m_hRegTimer = NULL;
    }

    /*
    1. Registered:ignore this timeout
    2. RRQ sent: (the endpoint has initiated the process of registering but 
       hasn't heard from the GK yet) Resend the RRQ
    3. Unregistered: ignore this imeout
    4. URQ sent: (the endpoint has initiated the process of unregistering but
       hasn't heard from the GK yet) ignore this timeout
    5. Idle: The GK client object has just been initialized and hasn't done 
       anything. This should not happen.
    */

    switch( m_RegisterState )
    {
    case RAS_REGISTER_STATE_RRQSENT:

        if( m_dwRegRetryCount < REG_RETRY_MAX )
        {
            if( !SendRRQ( (long)seqNumber, NULL ) )
            {
                m_RegisterState = RAS_REGISTER_STATE_RRQEXPIRED;
            }
        }
        else
        {
            m_RegisterState = RAS_REGISTER_STATE_RRQEXPIRED;
        }
        break;

    case RAS_REGISTER_STATE_REGISTERED:
    case RAS_REGISTER_STATE_URQSENT:
    case RAS_REGISTER_STATE_UNREGISTERED:
        break;

    case RAS_REGISTER_STATE_IDLE:
        _ASSERTE(0);
        break;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "RegExpired exited:%p.",this ));
}


void
RAS_CLIENT::TTLExpired()
{
    RasMessage                  rasMessage;
    RegistrationRequest *       RRQ;

    H323DBG(( DEBUG_LEVEL_TRACE, "TTLExpired entered:%p.",this ));
    Lock();

    if( m_RegisterState == RAS_REGISTER_STATE_REGISTERED )
    {
        //send light weight RRQ
        // initialize the structure
        ZeroMemory (&rasMessage, sizeof rasMessage);
        rasMessage.choice = registrationRequest_chosen;
        RRQ = &rasMessage.u.registrationRequest;
        RRQ -> bit_mask = 0;
        RRQ -> protocolIdentifier = OID_H225ProtocolIdentifierV2;

        RRQ -> bit_mask |= keepAlive_present;
        RRQ -> keepAlive = TRUE;

        //copy TTL
        RRQ -> bit_mask |= RegistrationRequest_timeToLive_present;
        RRQ -> timeToLive = m_dwRegTimeToLive;

        //endpoint identifier
        RRQ -> bit_mask |= RegistrationRequest_endpointIdentifier_present;
        RRQ->endpointIdentifier.length = m_RASEndpointID.length;
        RRQ->endpointIdentifier.value = m_RASEndpointID.value;

        //seqNumber
        m_wTTLSeqNumber = GetNextSeqNum();
        RRQ -> requestSeqNum = (WORD)m_wTTLSeqNumber;

        //what about gatekeeperIdentifier, tokens?

        // encode and send
        if( !IssueSend(&rasMessage) )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "SendLwtRRQ error:%p.",this ));
            Unlock();
            return;
        }
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TTLExpired exited:%p.",this ));
}


void
RAS_CLIENT::UnregExpired(
    IN WORD seqNumber
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "UnregExpired entered:%p.",this ));
    Lock();
    
    m_pURQExpireContext = NULL;

    if( m_hUnRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL);
        m_hUnRegTimer = NULL;
        m_dwUnRegRetryCount = 0;
    }

    switch( m_RegisterState )
    {
    case RAS_REGISTER_STATE_URQSENT:

        if( m_dwUnRegRetryCount < URQ_RETRY_MAX )
        {
            SendURQ( (long)seqNumber, NULL );
        }
        else
        {
            m_RegisterState = RAS_REGISTER_STATE_URQEXPIRED;
        }
        break;

    case RAS_REGISTER_STATE_REGISTERED:
    case RAS_REGISTER_STATE_RRQSENT:
    case RAS_REGISTER_STATE_UNREGISTERED:
        break;

    case RAS_REGISTER_STATE_IDLE:
        _ASSERTE(0);
        break;
    }
    
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "UnregExpired exited:%p.",this ));
}


void
RAS_CLIENT::OnUnregistrationRequest(
                                   IN UnregistrationRequest *URQ
                                  )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationRequest entered:%p.", this ));

    _ASSERTE( m_RegisterState != RAS_REGISTER_STATE_IDLE );

    if( (m_RegisterState == RAS_REGISTER_STATE_UNREGISTERED) ||
        (m_RegisterState == RAS_REGISTER_STATE_RRJ) )
    {
        SendURJ( URQ -> requestSeqNum, notCurrentlyRegistered_chosen );
    }
    else if( m_dwCallsInProgress )
    {
        SendURJ( URQ -> requestSeqNum, callInProgress_chosen );
    }
    else
    {
        m_RegisterState = RAS_REGISTER_STATE_UNREGISTERED;
        SendUCF( URQ -> requestSeqNum );
        
        //try to register again
        if( !SendRRQ( NOT_RESEND_SEQ_NUM, NULL ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "couldn't send rrq on urq request." ));
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationRequest exited:%p.",this ));
}

//!!always called from a lock
void
RAS_CLIENT::OnUnregistrationConfirm(
                                    IN UnregistrationConfirm *UCF
                                   )
{
    H323DBG((DEBUG_LEVEL_TRACE, "OnUnregistrationConfirm entered:%p.",this));

    if( UCF -> requestSeqNum != m_UnRegisterSeqNum )
        return;

    _ASSERTE( m_hUnRegTimer );
    if( m_hUnRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL);
        m_hUnRegTimer = NULL;
        m_dwUnRegRetryCount = 0;
    }
    
    if( (m_RegisterState == RAS_REGISTER_STATE_URQSENT) ||
        (m_RegisterState == RAS_REGISTER_STATE_URQEXPIRED) )
    {
        //delete if any TTL timer
        if( m_hRegTTLTimer )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTTLTimer, NULL );
            m_hRegTTLTimer = NULL;
        }

        m_RegisterState = RAS_REGISTER_STATE_UNREGISTERED;
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationConfirm exited:%p.",this));
}


//!!always called from a lock
void 
RAS_CLIENT::OnUnregistrationReject(
    IN UnregistrationReject *URJ
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationReject entered:%p.",this ));

    if( URJ -> requestSeqNum != m_UnRegisterSeqNum )
    {
        return;
    }

    if( m_hUnRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL);
        m_hUnRegTimer = NULL;
        m_dwUnRegRetryCount = 0;
    }

    if( (m_RegisterState == RAS_REGISTER_STATE_URQSENT) ||
        (m_RegisterState == RAS_REGISTER_STATE_URQEXPIRED) )
    {
        m_RegisterState = RAS_REGISTER_STATE_UNREGISTERED;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationReject exited:%p.",this ));
}


//!!always called from a lock
void 
RAS_CLIENT::OnRegistrationReject(
                                IN RegistrationReject * RRJ
                                )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnRegistrationReject entered:%p.",this ));

    if( RRJ -> requestSeqNum == m_wTTLSeqNumber )
    {
        //Keep alive failed. So start registration process again.
        //This will change the RAS registration state to RRQSENT from REGISTERED.
        if( !SendRRQ( NOT_RESEND_SEQ_NUM, NULL ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "couldn't send rrq on Keep alive failure." ));
            m_RegisterState = RAS_REGISTER_STATE_UNREGISTERED;
        }
    }
    else if( RRJ -> requestSeqNum == m_lastRegisterSeqNum )
    {
        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
            m_hRegTimer = NULL;
            m_dwRegRetryCount = 0;
        }

        if( (m_RegisterState == RAS_REGISTER_STATE_RRQSENT) ||
            (m_RegisterState == RAS_REGISTER_STATE_RRQEXPIRED) )
        {
            m_RegisterState = RAS_REGISTER_STATE_RRJ;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRegistrationReject exitd:%p.",this ));
}


//!!always called in lock
void
RAS_CLIENT::OnRegistrationConfirm(
    IN RegistrationConfirm * RCF )
{
    LIST_ENTRY *pListEntry = NULL;
    PALIASCHANGE_REQUEST pAliasChangeRequest = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRegistrationConfirm entered:%p.", this ));

    if( RCF -> requestSeqNum == m_PendingURQ.RRQSeqNumber )
    {
        //The timer could have been startd with the last RRQ, 
        //irrespective of the current state of registration.
        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
            m_hRegTimer = NULL;
            m_dwRegRetryCount = 0;
        }
        
        //send URQ with the endpointIdentifier
        SendURQ( NOT_RESEND_SEQ_NUM, &RCF->endpointIdentifier );
        H323DBG(( DEBUG_LEVEL_TRACE, "sending pending URQ for RRQ:%d",
            RCF->requestSeqNum ));
        
        return;
    }
    else if( RCF -> requestSeqNum == m_lastRegisterSeqNum )
    {
        //The timer could have been startd with the last RRQ, 
        //irrespective of the current state of registration.
        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
            m_hRegTimer = NULL;
            m_dwRegRetryCount = 0;
        }

        switch (m_RegisterState)
        {
        case RAS_REGISTER_STATE_REGISTERED:
    
            if (RCF->requestSeqNum == m_wTTLSeqNumber)
            {
                H323DBG(( DEBUG_LEVEL_TRACE, "RCF for TTL-RRQ." ));
            }
            else
            {
                H323DBG(( DEBUG_LEVEL_WARNING, 
                "warning: received RCF, but was already registered-ignoring"));
            }
            break;

        case RAS_REGISTER_STATE_RRQEXPIRED:
            
            H323DBG(( DEBUG_LEVEL_TRACE, 
                "received RCF, but registration already expired, send URQ" ));
            SendURQ (NOT_RESEND_SEQ_NUM, &RCF->endpointIdentifier);
            break;

        case RAS_REGISTER_STATE_RRQSENT:

            //expecting RRQ. gatekeeper has responded.

            m_RegisterState = RAS_REGISTER_STATE_REGISTERED;
            
            CopyMemory( (PVOID)m_RASEndpointID.value, 
                        (PVOID)RCF -> endpointIdentifier.value, 
                        RCF -> endpointIdentifier.length * sizeof(WCHAR) );

            m_RASEndpointID.value[RCF -> endpointIdentifier.length] = L'\0';
            m_RASEndpointID.length = (WORD)RCF -> endpointIdentifier.length;

            InitializeTTLTimer( RCF );

            break;

        default:

            H323DBG(( DEBUG_LEVEL_TRACE, 
                "RAS: received RRQ, but was in unexpected state"));
            break;
        }
    }
    else if( RCF -> requestSeqNum == m_wTTLSeqNumber )
    {
        //The timer could have been startd with the last RRQ, 
        //irrespective of the current state of registration.
        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
            m_hRegTimer = NULL;
            m_dwRegRetryCount = 0;
        }
        
        //look for the change in keepalive interval.
        InitializeTTLTimer( RCF );
    }
    else
    {
        //Try to find if this is a alias change request.
        for( pListEntry = m_aliasChangeRequestList.Flink; 
             pListEntry != &m_aliasChangeRequestList; 
             pListEntry = pListEntry -> Flink )
        {
            pAliasChangeRequest = CONTAINING_RECORD( pListEntry,
                ALIASCHANGE_REQUEST, listEntry );

            if( pAliasChangeRequest -> wRequestSeqNum == RCF -> requestSeqNum )
            {
                break;
            }
        }

        if( pListEntry != &m_aliasChangeRequestList )
        {
            //The timer could have been startd with the last RRQ, 
            //irrespective of the current state of registration.
            if( m_hRegTimer != NULL )
            {
                DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
                m_hRegTimer = NULL;
                m_dwRegRetryCount = 0;
            }
    
            //if registration has changed since this request was made then
            //ignore the message.
            if( memcmp( (PVOID)pAliasChangeRequest -> rasEndpointID.value,
                m_RASEndpointID.value, m_RASEndpointID.length * sizeof(WCHAR) )
                    == 0 )
            {
                //update the alias list.
                FreeAliasNames( m_pAliasList );

                m_pAliasList = pAliasChangeRequest->pAliasList;
                RemoveEntryList( &pAliasChangeRequest->listEntry );
                delete pAliasChangeRequest;
            }
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRegistrationConfirm exited:%p.", this ));
}


//!!always called in a lock.
BOOL
RAS_CLIENT::InitializeTTLTimer(
    IN RegistrationConfirm * RCF )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "InitializeTTLTimer - entered." ));
    
    if( (RCF->bit_mask & RegistrationConfirm_timeToLive_present) &&
        ( (m_dwRegTimeToLive != RCF->timeToLive) || (m_hRegTTLTimer == NULL) )
      )
    {
        m_dwRegTimeToLive = RCF->timeToLive;

        H323DBG(( DEBUG_LEVEL_TRACE, "timetolive value:%d.",
            m_dwRegTimeToLive ));

        //delete if any previous TTL timer
        if( m_hRegTTLTimer )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTTLTimer, NULL );
            m_hRegTTLTimer = NULL;
        }

        //start a timer to send lightweight RRQ afetr given time
        if( !CreateTimerQueueTimer(
                &m_hRegTTLTimer,
                H323TimerQueue,
                RAS_CLIENT::TTLExpiredCallback,
                this,
                (m_dwRegTimeToLive - REG_TTL_MARGIN)*1000, 
                (m_dwRegTimeToLive - REG_TTL_MARGIN)*1000,
                WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ) )
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "failed to create timer queue timer"));
            m_hRegTTLTimer = NULL;
            return FALSE;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "InitializeTTLTimer - exited." ));
    return TRUE;
}


void 
RAS_CLIENT::OnInfoRequest (
    IN  InfoRequest *   IRQ)
{
    PH323_CALL      pCall;
    SOCKADDR_IN     ReplyAddress;
    InfoRequestResponse_perCallInfo CallInfoList;
    InfoRequestResponse_perCallInfo * pCallInfoList = NULL;
    InfoRequestResponse_perCallInfo_Seq *   CallInfo;
    HRESULT         hr;
    int             iIndex, jIndex;
    int             iNumCalls = 0;
    int             iCallTableSize;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnInfoRequest - entered." ));
    
    if (m_RegisterState != RAS_REGISTER_STATE_REGISTERED)
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "RAS: received InfoRequest, but was not registered"));
        
        Unlock();
        return;
    }

    if (IRQ->bit_mask & replyAddress_present)
    {

        if (!GetTransportAddress (&IRQ -> replyAddress, &ReplyAddress))
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "RAS: received InfoRequest, but replyAddress was malformed"));
            
            Unlock();
            return;
        }
    }
    else
    {
        ReplyAddress = m_GKAddress;
    }

    //Don't loclk the RAS client while locking the call object.
    Unlock();

    if( IRQ -> callReferenceValue )
    {
        //query is for a specific call. So find the call and then send IRR

        pCall = g_pH323Line -> 
            FindCallByCallRefAndLock( IRQ -> callReferenceValue );
        
        if( pCall )
        {

            CallInfo = &CallInfoList.value;
            CallInfoList.next = NULL;

            ZeroMemory (CallInfo, sizeof (InfoRequestResponse_perCallInfo_Seq));

            CallInfo -> callIdentifier.guid.length = sizeof (GUID);
            CallInfo -> conferenceID.length = sizeof (GUID);

            hr = pCall -> GetCallInfo (
                (GUID *) &CallInfo -> callIdentifier.guid.value,
                (GUID *) &CallInfo -> conferenceID.value);

            if( hr != S_OK )
            {
                H323DBG ((DEBUG_LEVEL_ERROR, 
                    "RAS: call is disconnected for crv (%04XH).", 
                    IRQ -> callReferenceValue));
                return;
            }

            pCall -> Unlock();

            CallInfo -> callReferenceValue = IRQ -> callReferenceValue;
            CallInfo -> callType.choice = pointToPoint_chosen;
            CallInfo -> callModel.choice = direct_chosen;
        }
        else
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "RAS: received InfoRequest for nonexistent crv (%04XH).",
                IRQ -> callReferenceValue));

            return;
        }

        SendInfoRequestResponse (&ReplyAddress, IRQ -> requestSeqNum, &CallInfoList);
    }
    else
    {
        //send the info about all the active calls.
        iNumCalls = g_pH323Line->GetNoOfCalls();

        if( iNumCalls != 0 )
        {
            pCallInfoList = new InfoRequestResponse_perCallInfo[iNumCalls];
        }

        if( pCallInfoList  != NULL )
        {
            //lock the call table
            g_pH323Line -> LockCallTable();

            iCallTableSize = g_pH323Line->GetCallTableSize();

            //lock the call so that nobody else would be able to delete the call
            for(    jIndex=0, iIndex=0;
                    (iIndex < iCallTableSize) && (jIndex < iNumCalls);
                    iIndex++ )
            {
                pCall = g_pH323Line->GetCallAtIndex(iIndex);

                if( pCall != NULL )
                {
                    pCall -> Lock();

                    CallInfo = &(pCallInfoList[jIndex++].value);

                    ZeroMemory( CallInfo, sizeof (InfoRequestResponse_perCallInfo_Seq) );

                    CallInfo -> callIdentifier.guid.length = sizeof( GUID );
                    CallInfo -> conferenceID.length = sizeof( GUID );

                    pCall -> GetCallInfo(
                        (GUID *) &CallInfo -> callIdentifier.guid.value,
                        (GUID *) &CallInfo -> conferenceID.value);

                    CallInfo -> callReferenceValue = pCall->GetCallRef();

                    pCall -> Unlock();

                    CallInfo -> callType.choice = pointToPoint_chosen;
                    CallInfo -> callModel.choice = direct_chosen;
                }
            }

            for( iIndex=0; iIndex < jIndex-1; iIndex++ )
            {
                pCallInfoList[iIndex].next = &(pCallInfoList[iIndex+1]);
            }

            pCallInfoList[iIndex].next = NULL;

            //unlock the call table
            g_pH323Line -> UnlockCallTable();
        }

        SendInfoRequestResponse( &ReplyAddress, IRQ -> requestSeqNum,
            pCallInfoList );

        if( pCallInfoList != NULL )
        {
            delete pCallInfoList;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnInfoRequest - exited." ));
}


HRESULT RAS_CLIENT::SendInfoRequestResponse (
    IN  SOCKADDR_IN *           RasAddress,
    IN  USHORT                  SequenceNumber,
    IN  InfoRequestResponse_perCallInfo *   CallInfoList)
{
    RasMessage          RasMessage;
    InfoRequestResponse *                   IRR;
    SOCKADDR_IN                             SocketAddress;
    HRESULT             hr;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendInfoRequestResponse - entered." ));
    Lock();

    if( m_RegisterState == RAS_REGISTER_STATE_REGISTERED )
    {

        InfoRequestResponse_callSignalAddress   CallSignalAddressSequence;

        H323DBG(( DEBUG_LEVEL_TRACE, "SendIRR entered:%p.",this ));

        ZeroMemory (&RasMessage, sizeof RasMessage);
        RasMessage.choice = infoRequestResponse_chosen;
        IRR = &RasMessage.u.infoRequestResponse;


        IRR -> requestSeqNum = SequenceNumber;

        // we are listening for Q931 conns on all local interfaces
        // so specify just one of the local IP addresses
        // -XXX- fix for multihomed support later
        SocketAddress.sin_family = AF_INET;
        SocketAddress.sin_port = htons (LOWORD(g_RegistrySettings.dwQ931ListenPort));
        SocketAddress.sin_addr.s_addr = m_sockAddr.sin_addr.s_addr;

        // callSignalAddress
        SetTransportAddress (&SocketAddress, &CallSignalAddressSequence.value);
        CallSignalAddressSequence.next = NULL;
        IRR -> callSignalAddress = &CallSignalAddressSequence;

        // rasAddress
        IRR -> rasAddress = m_transportAddress;

        // endpointIdentifier
        IRR -> endpointIdentifier.length = m_RASEndpointID.length;
        IRR -> endpointIdentifier.value = m_RASEndpointID.value;

        // fill in endpoint type
        IRR -> endpointType.bit_mask |= terminal_present;
        IRR -> endpointType.terminal.bit_mask = 0;

        if( CallInfoList )
        {
            IRR -> bit_mask |= perCallInfo_present;
            IRR -> perCallInfo = CallInfoList;
        }

        // send the pdu
        hr = EncodeSendMessage (&RasMessage);
    }
    else
    {
        hr = E_FAIL;
    }

    Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "SendInfoRequestResponse - exited." ));
    return TRUE;
}


//!!always called from a lock
BOOL
RAS_CLIENT::InitializeIo (void)
{
    DWORD               dwFlags = 0;
    int                 AddressLength;

    H323DBG(( DEBUG_LEVEL_TRACE, "InitializeIo entered:%p.",this ));
    m_Socket = WSASocket (AF_INET, 
        SOCK_DGRAM, 
        IPPROTO_UDP, 
        NULL, 0, 
        WSA_FLAG_OVERLAPPED);

    if( m_Socket == INVALID_SOCKET )
    {
        WSAGetLastError();
        return FALSE;
    }

    if( !H323BindIoCompletionCallback ( (HANDLE)m_Socket,
        RAS_CLIENT::IoCompletionCallback, 0))
    {
        GetLastError();
        goto cleanup;
    }
    
    m_sockAddr.sin_family = AF_INET;
    m_sockAddr.sin_port = htons (0);   
    m_sockAddr.sin_addr.s_addr = 
        GetLocalIPAddress( m_GKAddress.sin_addr.S_un.S_addr );
    
    H323DBG(( DEBUG_LEVEL_TRACE, 
        "gk sock addr:%lx.", m_sockAddr.sin_addr.s_addr ));
    
    if( bind( m_Socket, (SOCKADDR *)&m_sockAddr, sizeof(m_sockAddr) )
        == SOCKET_ERROR )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Couldn't bind the RAS socket:%d, %p", WSAGetLastError(), this ));
                
        goto cleanup;
    }

    // now that we've bound to a dynamic UDP port,
    // query that port from the stack and store it.
    AddressLength = sizeof m_sockAddr;
    if( getsockname(m_Socket, (SOCKADDR *)&m_sockAddr, &AddressLength)
        == SOCKET_ERROR )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "getsockname failed :%d, %p", WSAGetLastError(), this ));

        goto cleanup;
    }
    _ASSERTE( ntohs(m_sockAddr.sin_port) );

    // fill in the IoTransportAddress structure.
    // this structure is the ASN.1-friendly transport
    // address of this client's endpoint.
    SetTransportAddress( &m_sockAddr, &m_transportAddress );

    // initiate i/o
    ZeroMemory( (PVOID)&m_recvOverlapped, sizeof(RAS_RECV_CONTEXT) );

    if( !IssueRecv() )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "InitializeIo exited:%p.",this ));
    return TRUE;

cleanup:

    closesocket(m_Socket);
    m_Socket = INVALID_SOCKET;
    return FALSE;
}


DWORD GetLocalIPAddress(
                        IN DWORD dwRemoteAddr
                       )
{
    DWORD       dwLocalAddr = INADDR_ANY;
    SOCKADDR_IN sRemoteAddr;
    SOCKADDR_IN sLocalAddr;
    DWORD       dwNumBytesReturned = 0;
    SOCKET      querySocket;

    H323DBG(( DEBUG_LEVEL_TRACE, "GetLocalIPAddress - entered." ));
    
    ZeroMemory( (PVOID)&sRemoteAddr, sizeof(SOCKADDR_IN) );
    ZeroMemory( (PVOID)&sLocalAddr, sizeof(SOCKADDR_IN) );
    sRemoteAddr.sin_family = AF_INET;
    sRemoteAddr.sin_addr =  *(struct in_addr *) &dwRemoteAddr;

    querySocket = WSASocket(
            AF_INET,            // int af 
            SOCK_DGRAM,         // int type
            IPPROTO_UDP,        // int protocol
            NULL,               // LPWSAPROTOCOL_INFO lpProtocolInfo
            0,                  // GROUP g 
            WSA_FLAG_OVERLAPPED // DWORD dwFlags 
        );

    if( querySocket == INVALID_SOCKET )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "getlocalIP wsasocket:%d.",
                WSAGetLastError() ));
            return dwLocalAddr;
    }

    if( WSAIoctl(
            querySocket,       // SOCKET s
            SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
            &sRemoteAddr,        // LPVOID  lpvInBuffer
            sizeof(SOCKADDR_IN), // DWORD   cbInBuffer
            &sLocalAddr,         // LPVOID  lpvOUTBuffer
            sizeof(SOCKADDR_IN),  // DWORD   cbOUTBuffer
            &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
            NULL, // LPWSAOVERLAPPED lpOverlapped
            NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
        ) == SOCKET_ERROR) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "getlocalIP error wsaioctl:%d.",
            WSAGetLastError() ));
    } 
    else 
    {
        dwLocalAddr = *(DWORD *)&sLocalAddr.sin_addr; 
        
        //if the remote address is on the same machine then...
        H323DBG(( DEBUG_LEVEL_ERROR, "dwLocalAddr:%x.", dwLocalAddr ));
        
        if( dwLocalAddr == NET_LOCAL_IP_ADDR_INTERFACE )
        {
            dwLocalAddr = dwRemoteAddr;
        }

        _ASSERTE( dwLocalAddr );
    }
    
    closesocket( querySocket );
    
    H323DBG(( DEBUG_LEVEL_TRACE, "GetLocalIPAddress - exited." ));
    return dwLocalAddr;
}


//!!always called from a lock
BOOL
RAS_CLIENT::IssueRecv(void)
{
    int    iError;
    WSABUF  BufferArray     [1];

    H323DBG(( DEBUG_LEVEL_TRACE, "IssueRecv entered:%p.",this ));
    _ASSERTE(!m_recvOverlapped.IsPending);

    if(m_Socket == INVALID_SOCKET)
    {
        return FALSE;
    }

    BufferArray [0].buf = (char *)(m_recvOverlapped.arBuf);
    BufferArray [0].len = IO_BUFFER_SIZE;

    ZeroMemory (&m_recvOverlapped.Overlapped, sizeof(OVERLAPPED));

    m_recvOverlapped.Type = OVERLAPPED_TYPE_RECV;
    m_recvOverlapped.RasClient = this;
    m_recvOverlapped.AddressLength = sizeof (SOCKADDR_IN);
    m_recvOverlapped.Flags = 0;

    if( WSARecvFrom(m_Socket,
                    BufferArray, 1,
                    &m_recvOverlapped.BytesTransferred,
                    &m_recvOverlapped.Flags,
                    (SOCKADDR*)&m_recvOverlapped.Address,
                    &m_recvOverlapped.AddressLength,
                    &m_recvOverlapped.Overlapped,
                    NULL) == SOCKET_ERROR )
    {
        iError = WSAGetLastError();
        if( iError == WSA_IO_PENDING )
        {
            m_recvOverlapped.IsPending = TRUE;
            m_IoRefCount++;
        }
        else if( iError == WSAEMSGSIZE )
        {
            //We don't handle this condition right now as it should not happen
            //In future with changes in the protocol this might be invoked and 
            //should be fixed
            _ASSERTE( FALSE );
        }
        else if( iError == WSAECONNRESET )
        {
            //On a UPD-datagram socket this error would indicate that a
            //previous send operation resulted in an ICMP "Port Unreachable"
            //message. This will happen if GK is not listening on the specified
            //port. This case would need special handling.
            _ASSERTE( FALSE );
            return FALSE;
        }
        else
        {
            //fatal error on the socket. shutdown the RAS client
            return FALSE;
        }
    }
    else
    {
        //data recvd immediately. IsPending is set beacause anyway a 
        //SendComplete event will be sent which will reset this BOOL
        m_recvOverlapped.IsPending = TRUE;
        m_IoRefCount++;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "IssueRecv exited:%p.",this ));
    return TRUE;
}



HRESULT 
RAS_CLIENT::EncodeSendMessage(
    IN RasMessage * RasMessage)
{
    RAS_SEND_CONTEXT *  SendContext;
    ASN1error_e     AsnError;
    WSABUF          BufferArray [1];
    DWORD           dwStatus;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeSendMessage entered:%p.",this ));

    Lock();

    if (m_Socket == INVALID_SOCKET)
    {
        Unlock();
        return E_FAIL;
    }
    
    SendContext = AllocSendBuffer();
    if( SendContext == NULL )
    {
        Unlock();
        return E_OUTOFMEMORY;
    }

    ZeroMemory( &SendContext -> Overlapped, sizeof (OVERLAPPED) );

    AsnError = ASN1_Encode (
        m_ASNCoderInfo.pEncInfo,
        RasMessage,
        RasMessage_PDU,
        ASN1ENCODE_SETBUFFER,
        SendContext -> arBuf,
        IO_BUFFER_SIZE);

    if (ASN1_FAILED (AsnError))
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "RAS: failed to encode RAS PDU (%d).", AsnError));
        FreeSendBuffer (SendContext);
        Unlock();
        return E_FAIL;
    }

    BufferArray [0].buf = (char *) SendContext -> arBuf;
    BufferArray [0].len = m_ASNCoderInfo.pEncInfo -> len;

    SendContext -> Type = OVERLAPPED_TYPE_SEND;
    SendContext -> RasClient = this;
    SendContext -> Address = m_GKAddress;

    if( WSASendTo (m_Socket,
        BufferArray, 
        1,
        &SendContext -> BytesTransferred, 
        0,
        (SOCKADDR *)&SendContext -> Address, 
        sizeof (SOCKADDR_IN),
        &SendContext->Overlapped, 
        NULL) == SOCKET_ERROR
        && WSAGetLastError() != WSA_IO_PENDING)
    {

        dwStatus = WSAGetLastError();

        H323DBG(( DEBUG_LEVEL_ERROR, "failed to issue async send on RAS socket" ));
        DumpError (dwStatus);

        //fatal error: shut down the client
        FreeSendBuffer (SendContext);
        Unlock();

        return HRESULT_FROM_WIN32 (dwStatus);
    }

    InsertHeadList( &m_sendPendingList, &SendContext -> ListEntry );
    m_IoRefCount++;

    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeSendMessage exited:%p.",this ));
    return S_OK;
}


// static
void 
NTAPI RAS_CLIENT::IoCompletionCallback(
    IN  DWORD           dwStatus,
    IN  DWORD           BytesTransferred,
    IN  OVERLAPPED *    Overlapped
    )
{
    RAS_OVERLAPPED *    RasOverlapped;
    RAS_CLIENT *        pRASClient;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "ras-IoCompletionCallback entered." ));

    _ASSERTE( Overlapped );
    RasOverlapped = CONTAINING_RECORD( Overlapped, RAS_OVERLAPPED, Overlapped );

    pRASClient = RasOverlapped -> RasClient;

    switch (RasOverlapped -> Type)
    {
    case OVERLAPPED_TYPE_SEND:

        pRASClient -> OnSendComplete( dwStatus, 
            static_cast<RAS_SEND_CONTEXT *> (RasOverlapped));
        break;

    case OVERLAPPED_TYPE_RECV:

        RasOverlapped -> BytesTransferred = BytesTransferred;
        pRASClient -> OnRecvComplete( dwStatus, 
            static_cast<RAS_RECV_CONTEXT *> (RasOverlapped));
        break;

    default:
        _ASSERTE(FALSE);
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "ras-IoCompletionCallback exited." ));
}


void 
RAS_CLIENT::OnSendComplete(
    IN DWORD dwStatus,
    IN RAS_SEND_CONTEXT * pSendContext
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnSendComplete entered:%p.",this ));

    if( dwStatus != ERROR_SUCCESS )
    {
        return;
    }

    Lock();
            
    m_IoRefCount--;
    
    //if the RAS client is already shutdown, then reduce the I/O refcount and return.
    if( m_dwState == RAS_CLIENT_STATE_NONE )
    {
        Unlock();
        return;
    }

    //this buffer may have already been freed
    if( IsInList( &m_sendPendingList, &pSendContext->ListEntry ) )
    {
        RemoveEntryList( &pSendContext->ListEntry );
        FreeSendBuffer( pSendContext );
    }
    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "OnSendComplete exited:%p.",this ));
}


void
RAS_CLIENT::OnRecvComplete(
    IN  DWORD dwStatus,
    IN  RAS_RECV_CONTEXT * RecvContext )
{
    RasMessage *    RasMessage = NULL;
    ASN1error_e     AsnError;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRecvComplete enterd:%p.",this ));
    Lock();

    m_IoRefCount--;

    //if the RAS client is already shutdown, then reduce the I/O refcount and return.
    if( m_dwState == RAS_CLIENT_STATE_NONE )
    {
        Unlock();
        return;
    }

    _ASSERTE(m_recvOverlapped.IsPending);
    m_recvOverlapped.IsPending = FALSE;

    switch( dwStatus )
    {
    case ERROR_SUCCESS:

        //asn decode and process the message
        if( m_recvOverlapped.BytesTransferred != 0 )
        {
            AsnError = ASN1_Decode (
                m_ASNCoderInfo.pDecInfo,                // ptr to encoder info
                (PVOID *) &RasMessage,                  // pdu data structure
                RasMessage_PDU,                         // pdu id
                ASN1DECODE_SETBUFFER,                   // flags
                m_recvOverlapped.arBuf,                 // buffer to decode
                m_recvOverlapped.BytesTransferred);     // size of buffer to decode

            //issue another read
            IssueRecv();

            if( ASN1_SUCCEEDED(AsnError) )
            {
                _ASSERTE(RasMessage);
                //This function should be always called in
                //a lock and it unlocks the the ras client
                ProcessRasMessage( RasMessage );
                return;
            }
            else
            {
                H323DBG(( DEBUG_LEVEL_ERROR, "RAS ASNDecode returned error:%d.",
                    AsnError ));
                H323DUMPBUFFER( (BYTE*)m_recvOverlapped.arBuf,
                    (DWORD)m_recvOverlapped.BytesTransferred);
            }
        }
        break;

    case STATUS_PORT_UNREACHABLE:
    case STATUS_CANCELLED:

        IssueRecv();
        break;

    default:
        H323DBG ((DEBUG_LEVEL_ERROR, "failed to recv data on socket"));
        DumpError (dwStatus);
        break;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "OnRecvComplete exited:%p.",this ));
}


int
RAS_CLIENT::InitASNCoder(void)
{
    int rc;
    H323DBG((DEBUG_LEVEL_TRACE, "InitASNCoder entered: %p.", this ));

    memset((PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    if( H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H225ASN_Module,         // ptr to mdule
                &(m_ASNCoderInfo.pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        _ASSERTE(m_ASNCoderInfo.pEncInfo );

        rc = ASN1_CreateDecoder(
                H225ASN_Module,         // ptr to mdule
                &(m_ASNCoderInfo.pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        _ASSERTE(m_ASNCoderInfo.pDecInfo );
    }

    if (rc != ASN1_SUCCESS)
    {
        TermASNCoder();
    }

    H323DBG((DEBUG_LEVEL_TRACE, "InitASNCoder exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
RAS_CLIENT::TermASNCoder(void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS TermASNCoder entered:%p.",this ));

    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(m_ASNCoderInfo.pEncInfo);
    ASN1_CloseDecoder(m_ASNCoderInfo.pDecInfo);

    memset( (PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    H323DBG(( DEBUG_LEVEL_TRACE, "RAS TermASNCoder exited:%p.",this ));
    return ASN1_SUCCESS;
}


void 
RAS_CLIENT::HandleRegistryChange()
{
    PH323_ALIASNAMES        pAliasList = NULL;
    PH323_ALIASITEM         pAliasItem = NULL;
    PALIASCHANGE_REQUEST    pAliasChangeRequest = NULL;
    int                     iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "RAS HandleRegistryChange entered:%p.",this ));
    
    //If line is not in listening mode then, return
    if( g_pH323Line -> GetState() != H323_LINESTATE_LISTENING )
        return;

    Lock();

    __try
    {
    
    //If registered with a GK, and GK disabled then send URQ.
    if( g_RegistrySettings.fIsGKEnabled == FALSE )
    {
        RasStop();
    }
    else
    {
        switch( m_RegisterState )
        {
        //If not registered then send RRQ to the GK.
        case RAS_REGISTER_STATE_IDLE:

            //No need to send URQ.
            //Shutdown the object.
            g_RasClient.Shutdown();
            RasStart();
            break;

        case RAS_REGISTER_STATE_REGISTERED:
        case RAS_REGISTER_STATE_RRQSENT:

            if( g_RegistrySettings.saGKAddr.sin_addr.s_addr !=
                m_GKAddress.sin_addr.s_addr )
            {
                //change of GK address

                //send URQ to the old GK and shutdown the RASClinet object.
                RasStop();
            
                //Initialize the GK object with new settings and send RRQ to the new GK.
                RasStart();
            }
            else 
            {
                //check for change in alias list.
                for( iIndex=0; iIndex < m_pAliasList->wCount; iIndex++ )
                {
                    pAliasItem = &(m_pAliasList->pItems[iIndex]);
                    
                    if( pAliasItem->wType == e164_chosen )
                    {
                        if( g_RegistrySettings.fIsGKLogOnPhoneEnabled == FALSE )
                        {
                            break;
                        }
                        else if( memcmp(
                            (PVOID)g_RegistrySettings.wszGKLogOnPhone, 
                            pAliasItem->pData, 
                            (pAliasItem->wDataLength+1) * sizeof(WCHAR) ) != 0 )
                        {
                            break;
                        }
                    }
                    else if( pAliasItem->wType == h323_ID_chosen )
                    {
                        if( g_RegistrySettings.fIsGKLogOnAccountEnabled==FALSE )
                        {
                            break;
                        }
                        else if( memcmp(
                            (PVOID)g_RegistrySettings.wszGKLogOnAccount, 
                            pAliasItem->pData, 
                            (pAliasItem->wDataLength+1) * sizeof(WCHAR) ) != 0 )
                        {
                            break;
                        }
                    }
                }
                    
                if( (iIndex < m_pAliasList->wCount ) ||
                    ( m_pAliasList->wCount !=
                      (g_RegistrySettings.fIsGKLogOnPhoneEnabled +
                       g_RegistrySettings.fIsGKLogOnAccountEnabled
                      )
                    )
                  )
                {
                    //create the new alias list.
                    pAliasList = new H323_ALIASNAMES;
                    
                    if( pAliasList != NULL )
                    {
                        ZeroMemory( (PVOID)pAliasList, sizeof(H323_ALIASNAMES) );
                        if( g_RegistrySettings.fIsGKLogOnPhoneEnabled )
                        {
                            if( !AddAliasItem( pAliasList, 
                                    g_RegistrySettings.wszGKLogOnPhone,
                                    e164_chosen ) )
                            {
                                goto cleanup;
                            }
                        }
                        
                        if( g_RegistrySettings.fIsGKLogOnAccountEnabled )
                        {
                            if( !AddAliasItem( pAliasList,
                                    g_RegistrySettings.wszGKLogOnAccount,
                                    h323_ID_chosen ) )
                            {
                                goto cleanup;
                            }
                        }

                        //queue the alias change request in the list
                        pAliasChangeRequest = new ALIASCHANGE_REQUEST;
                        
                        if( pAliasChangeRequest == NULL )
                        {
                            goto cleanup;
                        }

                        pAliasChangeRequest->rasEndpointID.length = m_RASEndpointID.length;
                        CopyMemory( (PVOID)pAliasChangeRequest->rasEndpointID.value,
                            m_RASEndpointID.value, 
                            (pAliasChangeRequest->rasEndpointID.length+1)*sizeof(WCHAR) );

                        pAliasChangeRequest->wRequestSeqNum = 0;
                        pAliasChangeRequest->pAliasList = pAliasList;

                        //Send RRQ with the new alias list.
                        if( !SendRRQ(NOT_RESEND_SEQ_NUM, pAliasChangeRequest) )
                        {
                            goto cleanup;
                        }

                        InsertHeadList( &m_aliasChangeRequestList,
                            &pAliasChangeRequest->listEntry );
                    }
                }
            }
            break;

        default:

            //Shutdown the RASClinet object. Send RRQ to new GK.
            RasStop();
            RasStart();
            break;
        }
    }
    
    }
    __except(1)
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "except in HandleRegistryChange :%p.", this ));
        _ASSERTE(0);
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS HandleRegistryChange exited:%p.", this ));
    return;

cleanup:

    if( pAliasList != NULL )
    {
        FreeAliasNames( pAliasList );
    }
    
    if( pAliasChangeRequest != NULL )
    {
        delete pAliasChangeRequest;
    }

    Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\common.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    common.h

Abstract:

    commonly used headers.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/
#ifndef __COMMON_H_
#define __COMMON_H_

#include "H323msp.h"
#include "H323addr.h"
#include "H323call.h"
#include "H323strm.h"
#include "H323aud.h"
#include "H323vid.h"
#include "H323util.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\ras.h ===
#ifndef _RAS_H_
#define _RAS_H_

#define  REG_RETRY_MAX                      3
#define  URQ_RETRY_MAX                      2
#define  ARQ_RETRY_MAX                      3
#define  DRQ_RETRY_MAX                      3
#define  RASIO_SEND_BUFFER_LIST_MAX         10
#define  REG_EXPIRE_TIME                    4000
#define  ARQ_EXPIRE_TIME                    4000


#define  NOT_RESEND_SEQ_NUM                 -1

//(127.0.0.1 in network byte order)
#define  NET_LOCAL_IP_ADDR_INTERFACE        0x0100007F

//(127.0.0.1 in host byte order)
#define  HOST_LOCAL_IP_ADDR_INTERFACE       0x7F000001

extern	const	ASN1objectidentifier_s	    _OID_H225ProtocolIdentifierV1 [];
extern	const	ASN1objectidentifier_s	    _OID_H225ProtocolIdentifierV2 [];

#define	OID_H225ProtocolIdentifierV1	    const_cast<ASN1objectidentifier_s *> (_OID_H225ProtocolIdentifierV1);
#define	OID_H225ProtocolIdentifierV2	    const_cast<ASN1objectidentifier_s *> (_OID_H225ProtocolIdentifierV2);

#undef	OID_ELEMENT
#define	OID_RasProtocolIdentifierV2	        (ASN1objectidentifier_s *)_OID_RasProtocolIdentifierV2


class	RAS_CLIENT;

struct EXPIRE_CONTEXT
{
    WORD			seqNumber;
	union
    {
	    HDRVCALL		DriverCallHandle;
	    RAS_CLIENT *	RasClient;
	};
};

typedef struct _ALIASCHANGE_REQUEST
{
    LIST_ENTRY          listEntry;
    ENDPOINT_ID         rasEndpointID;
    WORD                wRequestSeqNum;
    PH323_ALIASNAMES    pAliasList;

} ALIASCHANGE_REQUEST, *PALIASCHANGE_REQUEST;


#define REG_TTL_MARGIN      2

enum RAS_CLIENT_STATE
{
	RAS_CLIENT_STATE_NONE = 0,
	RAS_CLIENT_STATE_INITIALIZED
};


//If the app wants to send an URQ but the TSP ihasn't received RCF yet then we
//the information in this struct and send URQ when we get RCF.
typedef struct _PENDINGURQ
{
    WORD    RRQSeqNumber;
} PENDINGURQ;


enum RAS_REGISTER_STATE
{
	RAS_REGISTER_STATE_IDLE = 0,
	RAS_REGISTER_STATE_RRQSENT,
	RAS_REGISTER_STATE_RRQEXPIRED,
	RAS_REGISTER_STATE_REGISTERED,
	RAS_REGISTER_STATE_URQSENT,
	RAS_REGISTER_STATE_URQEXPIRED,
	RAS_REGISTER_STATE_UNREGISTERED,
	RAS_REGISTER_STATE_RRJ,
	RAS_REGISTER_STATE_URQRECVD,
};


class RAS_CLIENT
{

private:
    HANDLE              m_hRegTimer;
    HANDLE              m_hUnRegTimer;
    HANDLE              m_hRegTTLTimer;
    PH323_ALIASNAMES    m_pAliasList;//list of all the aliases registered with this list
    SOCKET              m_Socket;
    CRITICAL_SECTION    m_CriticalSection;
    RAS_REGISTER_STATE	m_RegisterState;
    DWORD               m_IoRefCount;
    RAS_CLIENT_STATE	m_dwState;
    LIST_ENTRY          m_sendFreeList;
    LIST_ENTRY          m_sendPendingList;
    DWORD               m_dwSendFreeLen;
    SOCKADDR_IN         m_GKAddress;
    SOCKADDR_IN         m_sockAddr;
    TransportAddress    m_transportAddress;
    RAS_RECV_CONTEXT    m_recvOverlapped;
    WORD                m_lastRegisterSeqNum;
    WORD                m_wTTLSeqNumber;
    WORD                m_UnRegisterSeqNum;
    WORD                m_wRASSeqNum;
    DWORD               m_dwRegRetryCount;
    DWORD               m_dwUnRegRetryCount;
    DWORD               m_dwCallsInProgress;
    ENDPOINT_ID         m_RASEndpointID;
    ASN1_CODER_INFO     m_ASNCoderInfo;
    PENDINGURQ          m_PendingURQ;
    DWORD               m_dwRegTimeToLive;
    EXPIRE_CONTEXT*     m_pRRQExpireContext;
    EXPIRE_CONTEXT*     m_pURQExpireContext;
    LIST_ENTRY          m_aliasChangeRequestList;

    
    
    RAS_SEND_CONTEXT *AllocSendBuffer();
    void FreeSendBuffer( RAS_SEND_CONTEXT * pBuffer );
    void OnInfoRequest( InfoRequest * IRQ );
    void ProcessRasMessage(IN RasMessage *rasMessage );
    void OnUnregistrationConfirm( IN UnregistrationConfirm *UCF );
    void OnUnregistrationReject( IN UnregistrationReject *URJ );
    void OnRegistrationReject( IN RegistrationReject *	RRJ );
    void OnRegistrationConfirm( IN RegistrationConfirm * RCF );
    BOOL InitializeIo();
    BOOL IssueRecv();
    int TermASNCoder(void);
    int InitASNCoder(void);
    BOOL SendUCF( WORD seqNumber );
    BOOL SendURJ( WORD seqNumber, DWORD dwReason );
    void OnUnregistrationRequest( IN UnregistrationRequest *URQ );
    BOOL FreeSendList( PLIST_ENTRY pListHead );
    BOOL InitializeTTLTimer( IN RegistrationConfirm * RCF );

	HRESULT	SendInfoRequestResponse(
		IN	SOCKADDR_IN *			RasAddress,
		IN	USHORT					SequenceNumber,
		IN	InfoRequestResponse_perCallInfo *	CallInfoList);

	HRESULT	EncodeSendMessage(
		IN	RasMessage * rasMessage );


public:
    RAS_CLIENT();
    
    ~RAS_CLIENT();

    void Lock()
    {
        H323DBG((DEBUG_LEVEL_TRACE, "wait on RAS client lock:%p.", this ));
        EnterCriticalSection( &m_CriticalSection );
        H323DBG((DEBUG_LEVEL_TRACE, "RAS client locked: %p.", this ));
    }

    void Unlock()
    {
        LeaveCriticalSection( &m_CriticalSection );
        H323DBG((DEBUG_LEVEL_TRACE, "RAS client unlocked: %p.", this ));
    }
     
    WORD GetNextSeqNum()
    {
        WORD wSeqNum;
        Lock();
        wSeqNum = ++m_wRASSeqNum;
        if( wSeqNum == 0 )
            wSeqNum = ++m_wRASSeqNum;
        Unlock();
        return wSeqNum;
    }

    RAS_REGISTER_STATE GetRegState()
    {
        return m_RegisterState;
    }

    HRESULT	GetEndpointID	(
		OUT	ASN1char16string_t *	ReturnEndpointID);

	HRESULT	GetLocalAddress	(
		OUT	SOCKADDR_IN *	ReturnSocketAddress)
	{
		HRESULT		hr;

		Lock();

		if (m_RegisterState == RAS_REGISTER_STATE_REGISTERED)
        {
			*ReturnSocketAddress = m_sockAddr;
			hr = S_OK;
		}
		else
        {
			hr = E_FAIL;
		}

		Unlock();

		return hr;
	}

    PH323_ALIASNAMES
    GetRegisteredAliasList()
    {
        return m_pAliasList;
    }
        
    BOOL Initialize( SOCKADDR_IN* psaGKAddr );
    void Shutdown();
    static void NTAPI RegExpiredCallback( PVOID dwParam1, BOOLEAN bTimer );
    static void NTAPI UnregExpiredCallback( PVOID dwParam1, BOOLEAN bTimer );
    static void NTAPI TTLExpiredCallback( IN PVOID dwParam1, IN BOOLEAN bTimer );

    BOOL SendRRQ( IN long seqNumber, IN PALIASCHANGE_REQUEST pAliasList );
    BOOL SendURQ( long seqNumber, EndpointIdentifier * pEndpointID );

    void RegExpired( WORD seqNumber );
    void UnregExpired( WORD seqNumber );
    void TTLExpired();
    static void NTAPI IoCompletionCallback(IN DWORD dwStatus, IN DWORD cbTransferred,
        IN LPOVERLAPPED pOverlapped );
    void OnSendComplete( IN DWORD dwStatus, RAS_SEND_CONTEXT *pOverlappedSend );
    void OnRecvComplete( IN DWORD dwStatus, RAS_RECV_CONTEXT * pOverlappedRecv );

    void HandleRegistryChange();

    BOOL IssueSend( RasMessage * pRasMessage )
    {
		return EncodeSendMessage (pRasMessage) == S_OK;
	}
};

void 
HandleRASCallMessage(
    IN RasMessage *pRasMessage
);


HRESULT	RasStart	(void);

void	RasStop		(void);

HRESULT	RasSetAliasList (
	IN	AliasAddress *	AliasArray,
	IN	DWORD			Count);

BOOL	RasIsRegistered	(void);

HRESULT	RasGetLocalAddress	(
	OUT	SOCKADDR_IN *	ReturnLocalAddress);

USHORT	RasAllocSequenceNumber			(void);

HRESULT	RasGetEndpointID	(
	OUT	EndpointIdentifier *	ReturnEndpointID);

HRESULT	RasEncodeSendMessage (
	IN	RasMessage *			RasMessage);

PH323_ALIASNAMES RASGetRegisteredAliasList();
void RasHandleRegistryChange();



#endif //_RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\tspicall.cpp ===
#include "globals.h"
#include "line.h"
#include "q931pdu.h"
#include "q931obj.h"
#include "ras.h"



//
// TSPI procedures
//
// This file contains all of the TSPI export functions that act directly on calls.
//


/*++
Parameters
	
	  hdCall - The handle to the call whose application-specific field is to be
			set. The call state of hdCall can be any state. 
	
	  dwAppSpecific - The new content of the dwAppSpecific member for the call's
		LINECALLINFO structure. This value is uninterpreted by the service
		provider. This parameter is not validated by TAPI when this function is called. 

  
Return Values
	Returns zero if the function succeeds, or an error number if an error
	occurs. Possible return values are as follows: 

		LINEERR_INVALCALLHANDLE, 
		LINEERR_OPERATIONFAILED, 
		LINEERR_NOMEM, 
		LINEERR_RESOURCEUNAVAIL, 
		LINEERR_OPERATIONUNAVAIL. 

Routine Description:
	The application-specific field in the LINECALLINFO data structure that 
	exists for each call is uninterpreted by the Telephony API or any of its
	service providers. Its usage is entirely defined by the applications. The
	field can be read from the LINECALLINFO record returned by 
	TSPI_lineGetCallInfo. However, TSPI_lineSetAppSpecific must be used to set
	the field so that changes become visible to other applications. When this
	field is changed, the service provider sends a LINE_CALLINFO message with
	an indication that the AppSpecific field has changed.

++*/

LONG
TSPIAPI 
TSPI_lineSetAppSpecific(
  HDRVCALL hdCall,     
  DWORD dwAppSpecific  
)
{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetAppSpecific - Entered." ));

    //this function locks the call
    pCall = g_pH323Line -> FindH323CallAndLock( hdCall );

    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    pCall -> SetAppSpecific( dwAppSpecific );

    pCall -> Unlock();    
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetAppSpecific - Exited." ));

    // success
    return ERROR_SUCCESS;
}


LONG TSPIAPI TSPI_lineSetCallData(
  DRV_REQUESTID dwRequestID,  
  HDRVCALL hdCall,            
  LPVOID lpCallData,          
  DWORD dwSize                
)
{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetCallData - Entered." ));

    //This function locks the call
    pCall = g_pH323Line -> FindH323CallAndLock( hdCall );

    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( !pCall -> SetCallData( lpCallData, dwSize ) )
    {
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }

    pCall -> PostLineEvent( LINE_CALLINFO,
        LINECALLINFOSTATE_CALLDATA,
        0,
        0 );

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall -> Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetCallData - Exited." ));
    
    // success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID     dwRequestID,  
    HDRVCALL          hdCall,
    LPCSTR            pUserUserInfo,
    DWORD             dwSize
    )
    
/*++

Routine Description:

    This function answers the specified offering call.

    When a new call arrives, the Service Provider sends the TAPI DLL a 
    LINE_NEWCALL event to exchange opaque handles for the call.  The Service 
    Provider follows this with a LINE_CALLSTATE message inform the TAPI DLL 
    and its client applications of the call's call state.  The TAPI DLL 
    typically answers this call (on behalf of an application) using 
    TSPI_lineAnswer.  After the call has been successfully answered, the call 
    will typically transition to the connected state.
    
    In some telephony environments (like ISDN) where user alerting is separate 
    from call offering, the TAPI DLL and its client apps may have the option to 
    first accept a call prior to answering, or instead to reject or redirect 
    the offering call.
    
    If a call comes in (is offered) at the time another call is already active, 
    then the new call is connected to by invoking TSPI_lineAnswer. The effect 
    this has on the existing active call depends on the line's device 
    capabilities. The first call may be unaffected, it may automatically be 
    dropped, or it may automatically be placed on hold. The appropriate 
    LINE_CALLSTATE messages will report state transitions to the TAPI DLL about 
    both calls.
    
    The TAPI DLL has the option to send user-to-user information at the time of 
    the answer. Even if user-to-user information can be sent, often no 
    guarantees are made that the network will deliver this information to the 
    calling party. The TAPI DLL can consult a line's device capabilities to 
    determine whether or not sending user-to-user information on answer is 
    available.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        answered.  Valid call states: offering, accepted.

    pUserUserInfo - Specifies a far pointer to a string containing 
        user-to-user information to be sent to the remote party at the time of 
        answering the call. If this pointer is NULL, it indicates that no 
        user-to-user information is to be sent. User-to-user information is 
        only sent if supported by the underlying network (see LINEDEVCAPS).

    dwSize - Specifies the size in bytes of the user-to-user information in 
        pUserUserInfo. If pUserUserInfo is NULL, no user-to-user 
        information is sent to the calling party and dwSize is ignored.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative 
    error number if an error has occurred.  Possible error returns are:  
    
        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    PH323_CALL  pCall;
    DWORD       dwCallState;
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineAnswer - Entered." ));

    //this function locks the call
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // see if call in offering state
    dwCallState = pCall -> GetCallState();
    if( ( dwCallState & LINECALLSTATE_OFFERING) == 0 )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "call 0x%08lx cannot be accepted state 0x%08lx.",
            pCall,
            pCall -> GetCallState()));

        pCall -> Unlock();
        // invalid call state
        return LINEERR_INVALCALLSTATE;
    }

    // save outgoing user user information (if specified)
    if( !pCall -> AddU2U( U2U_OUTBOUND, dwSize, (PBYTE)pUserUserInfo) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not save user user info." ));

        pCall -> Unlock();
        // no memory available
        return LINEERR_NOMEM;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_ANSWER_CALL, NULL) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not post place call message." ));

        //drop the call
        pCall -> CloseCall( 0 );
        
        pCall -> Unlock();
        // could not complete operation
        return LINEERR_OPERATIONFAILED;
    }

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineAnswer - Exited." ));
        
    pCall -> Unlock();    
    // async success                        
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL hdCall
    )
    
/*++

Routine Description:

    This function deletes the call after completing or aborting all outstanding
    asynchronous operations on the call.

    The Service Provider has the responsibility to (eventually) report 
    completion for every operation it decides to execute asynchronously.  
    If this procedure is called for a call on which there are outstanding 
    asynchronous operations, the operations should be reported complete with an 
    appropriate result or error code before this procedure returns.  If there 
    is an active call on the line at the time of TSPI_lineCloseCall, the call 
    must be dropped.  Generally the TAPI DLL would wait for calls to be 
    finished and asynchronous operations to complete in an orderly fashion.  
    However, the Service Provider should be prepared to handle an early call to
    TSPI_lineCloseCall in "abort" or "emergency shutdown" situations.

    After this procedure returns the Service Provider must report no further 
    events on the call.  The Service Provider's opaque handle for the call 
    becomes "invalid".

    This function is presumed to complete successfully and synchronously.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        deleted.  After the call has been successfully deleted, this handle is 
        no longer valid.  Valid call states: any.

Return Values:

    None.  
    
--*/

{
    PH323_CALL pCall;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCloseCall - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "call already deleted." ));
        //return LINEERR_INVALCALLHANDLE;
        return NOERROR;
    }

    // drop specified call 
    pCall->CloseCall( LINEDISCONNECTMODE_CANCELLED );

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCloseCall - Exited." ));

    pCall -> Unlock();

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall,
    LPCSTR        pUserUserInfo,
    DWORD         dwSize
    )
    
/*++

Routine Description:

    This functions drops or disconnects the specified call. The TAPI DLL has 
    the option to specify user-to-user information to be transmitted as part 
    of the call disconnect.

    When invoking TSPI_lineDrop related calls may sometimes be affected as 
    well. For example, dropping a conference call may drop all individual 
    participating calls. LINE_CALLSTATE messages are sent to the TAPI DLL for 
    all calls whose call state is affected. A dropped call will typically 
    transition to the idle state.

    Invoking TSPI_lineDrop on a call in the offering state rejects the call. 
    Not all telephone networks provide this capability.

    Invoking TSPI_lineDrop on a consultation call that was set up using either
    TSPI_lineSetupTransfer or TSPI_lineSetupConference, will cancel the 
    consultation call. Some switches automatically unhold the other call. 

    The TAPI DLL has the option to send user-to-user information at the time 
    of the drop. Even if user-to-user information can be sent, often no 
    guarantees are made that the network will deliver this information to the 
    remote party.

    Note that in various bridged or party line configurations when multiple 
    parties are on the call, TSPI_lineDrop by the application may not actually
    clear the call.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to 
        be dropped.  Valid call states: any.

    psUserUserInfo - Specifies a far pointer to a string containing 
        user-to-user information to be sent to the remote party as part of 
        the call disconnect.  This pointer is unused if dwUserUserInfoSize 
        is zero and no user-to-user information is to be sent. User-to-user 
        information is only sent if supported by the underlying network 
        (see LINEDEVCAPS).

    dwSize - Specifies the size in bytes of the user-to-user information in 
        psUserUserInfo. If zero, then psUserUserInfo can be left NULL, and 
        no user-to-user information will be sent to the remote party.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALPOINTER - The specified pointer parameter is invalid.

        LINEERR_INVALCALLSTATE - The current state of the call does not allow 
            the call to be dropped.
            
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineDrop - Entered." ));
    
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {

        // complete the async accept operation now
        H323CompleteRequest (dwRequestID, ERROR_SUCCESS);
        return dwRequestID;

        //return LINEERR_INVALCALLHANDLE;
    }

    // save outgoing user user information (if specified)
    if( dwSize != 0 && pUserUserInfo )
    {
        if( !pCall -> AddU2U( U2U_OUTBOUND, dwSize, (PBYTE)pUserUserInfo) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "could not save user user info." ));
            pCall -> Unlock();
            // no memory available
            return LINEERR_NOMEM;
        }
    }

    // drop specified call 
    if( !pCall->QueueTAPICallRequest( TSPI_DROP_CALL, NULL ))
    {
        pCall -> Unlock();
        // could not drop call
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineDrop - Exited." ));
        
    pCall -> Unlock();   
    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL hdCall,
    LPDWORD  pdwAddressID
    )
    
/*++

Routine Description:

    This operation allows the TAPI DLL to retrieve the address ID for the 
    indicated call.

    This operation must be executed synchronously by the Service Provider, 
    with presumed success.  This operation may be called from within the 
    context of the ASYNC_LINE_COMPLETION or LINEEVENT callbacks (i.e., from 
    within an interrupt context).  This function would typically be called 
    at the start of the call life cycle.

    If the Service Provider models lines as "pools" of channel resources 
    and does "inverse multiplexing" of a call over several address IDs it 
    should consistently choose one of these address IDs as the primary 
    identifier reported by this function and in the LINE_CALLINFO data 
    structure.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        whose address ID is to be retrieved.  Valid call states: any.

    pdwAddressID - Specifies a far pointer to a DWORD into which the 
        Service Provider writes the call's address ID.

Return Values:
    
    None.

--*/

{
    PH323_CALL pCall;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallAddressID - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // only one addr
    *pdwAddressID = 0;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallAddressID - Exited." ));
        
    pCall -> Unlock();
    // success
    return NOERROR;
}


/*++

Routine Description:

    This operation enables the TAPI DLL to obtain fixed information about 
    the specified call.

    A separate LINECALLINFO structure exists for every (inbound or outbound) 
    call. The structure contains primarily fixed information about the call. 
    An application would typically be interested in checking this information 
    when it receives its handle for a call via the LINE_CALLSTATE message, or 
    each time it receives notification via a LINE_CALLINFO message that parts 
    of the call information structure have changed. These messages supply the 
    handle for the call as a parameter.

    If the Service Provider models lines as "pools" of channel resources and 
    does "inverse multiplexing" of a call over several address IDs it should 
    consistently choose one of these address IDs as the primary identifier 
    reported by this function in the LINE_CALLINFO data structure.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        whose call information is to be retrieved.

    pCallInfo - Specifies a far pointer to a variable sized data structure 
        of type LINECALLINFO. Upon successful completion of the request, this 
        structure is filled with call related information.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  pCallInfo
    )
    
{
    LONG retVal;
    PH323_CALL pCall;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallInfo - Entered." ));

    if( pCallInfo == NULL )
    {
        return LINEERR_INVALPARAM;
    }

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    retVal = pCall -> CopyCallInfo( pCallInfo );

    pCall -> Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallInfo - Exited." ));
    return retVal;
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL         hdCall,
    LPLINECALLSTATUS pCallStatus
    )
    
/*++

Routine Description:

    This operation returns the current status of the specified call.

    TSPI_lineCallStatus returns the dynamic status of a call, whereas 
    TSPI_lineGetCallInfo returns primarily static information about a call. 
    Call status information includes the current call state, detailed mode 
    information related to the call while in this state (if any), as well 
    as a list of the available TSPI functions the TAPI DLL can invoke on the 
    call while the call is in this state.  An application would typically be 
    interested in requesting this information when it receives notification 
    about a call state change via the LINE_CALLSTATE message.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be queried for its status.  Valid call states: any.

    pCallStatus - Specifies a far pointer to a variable sized data structure 
        of type LINECALLSTATUS. Upon successful completion of the request, 
        this structure is filled with call status information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallStatus - Entered." ));

    if( pCallStatus == NULL ) 
    {
        return LINEERR_INVALPARAM;
    }

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // determine number of bytes needed
    pCallStatus->dwNeededSize = sizeof(LINECALLSTATUS);

    // see if structure size is large enough
    if (pCallStatus->dwTotalSize < pCallStatus->dwNeededSize)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "linecallstatus structure too small." ));

        pCall -> Unlock();
        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    // record amount of memory used
    pCallStatus->dwUsedSize = pCallStatus->dwNeededSize;

    pCall -> CopyCallStatus( pCallStatus );

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallStatus - Exited." ));
            
    pCall -> Unlock();
    // success
    return NOERROR;
}


    
/*++

Routine Description:

    This function places a call on the specified line to the specified 
    destination address, exchanging opaque handles for the new call 
    between the TAPI DLL and Service Provider. Optionally, call parameters 
    can be specified if anything but default call setup parameters are 
    requested.

    After dialing has completed, several LINE_CALLSTATE messages will 
    typically be sent to the TAPI DLL to notify it about the progress of the 
    call. No generally valid sequence of call state transitions is specified 
    as no single fixed sequence of transitions can be guaranteed in practice. 
    A typical sequence may cause a call to transition from dialtone, dialing, 
    proceeding, ringback, to connected. With non-dialed lines, the call may 
    typically transition directly to connected state.

    The TAPI DLL has the option to specify an originating address on the 
    specified line device. A service provider that models all stations on a 
    switch as addresses on a single line device allows the TAPI DLL to 
    originate calls from any of these stations using TSPI_lineMakeCall.

    The call parameters allow the TAPI DLL to make non voice calls or request 
    special call setup options that are not available by default.

    The TAPI DLL can partially dial using TSPI_lineMakeCall and continue 
    dialing using TSPI_lineDial. To abandon a call attempt, use TSPI_lineDrop.

    The Service Provider initially does media monitoring on the new call for 
    at least the set of media modes that were monitored for on the line.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdLine - Specifies the Service Provider's opaque handle to the line on 
        which the new call is to be originated.

    htCall - Specifies the TAPI DLL's opaque handle to the new call.  The 
        Service Provider must save this and use it in all subsequent calls to 
        the LINEEVENT procedure reporting events on the call.

    phdCall - Specifies a far pointer to an opaque HDRVCALL representing the 
        Service Provider's identifier for the call.  The Service Provider must
        fill this location with its opaque handle for the call before this 
        procedure returns, whether it decides to execute the request 
        sychronously or asynchronously.  This handle is invalid if the function
        results in an error (either synchronously or asynchronously).

    pwszDialableAddr - Specifies a far pointer to the destination address. This 
        follows the standard dialable number format. This pointer may be 
        specified as NULL for non-dialed addresses (i.e., a hot phone) or when
        all dialing will be performed using TSPI_lineDial. In the latter case,
        TSPI_lineMakeCall will allocate an available call appearance which 
        would typically remain in the dialtone state until dialing begins. 
        Service providers that have inverse multiplexing capabilities may allow
        an application to specify multiple addresses at once.

    dwCountryCode - Specifies the country code of the called party. If a value 
        of zero is specified, then a default will be used by the 
        implementation.

    pCallParams - Specifies a far pointer to a LINECALLPARAMS structure. This 
        structure allows the TAPI DLL to specify how it wants the call to be 
        set up. If NULL is specified, then a default 3.1kHz voice call is 
        established, and an arbitrary origination address on the line is 
        selected.  This structure allows the TAPI DLL to select such elements 
        as the call's bearer mode, data rate, expected media mode, origination
        address, blocking of caller ID information, dialing parameters, etc.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error 
    number if an error has occurred. Possible error returns are:
    
        LINEERR_CALLUNAVAIL - All call appearances on the specified address are 
            currently in use.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_INVALADDRESSMODE - The address mode is invalid.

        LINEERR_INVALBEARERMODE - The bearer mode is invalid.

        LINEERR_INVALCALLPARAMS - The specified call parameter structure is 
            invalid.

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALLINESTATE - The line is currently not in a state in 
            which this operation can be performed. 

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

        LINEERR_OPERATIONFAILED - The operation failed for unspecified reasons.

        LINEERR_RESOURCEUNAVAIL - The specified operation cannot be completed 
            because of resource overcommitment.

--*/

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          phdCall,
    LPCWSTR             pwszDialableAddr,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const pCallParams
    )
{
    DWORD               dwStatus = dwRequestID;
    PH323_CALL          pCall = NULL;
    H323_CONFERENCE *   pConf = NULL;
    BOOL                fDelete = FALSE;
    DWORD               dwState;

    UNREFERENCED_PARAMETER( dwCountryCode );

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMakeCall - Entered." ));

    //lock the line device    
    g_pH323Line -> Lock();

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_RESOURCEUNAVAIL;
    }

    // validate line state
    dwState = g_pH323Line -> GetState();
    if( ( dwState != H323_LINESTATE_OPENED) &&
        ( dwState != H323_LINESTATE_LISTENING) ) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "H323 line is not currently opened:%d.",
            dwState ));

        // release line device
        g_pH323Line ->Unlock();

        // line needs to be opened
        return LINEERR_INVALLINESTATE;
    }
    
    // see if line is available
    if( g_pH323Line -> GetNoOfCalls() == H323_MAXCALLSPERLINE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "H323 line is currently used at maximum capacity." ));
    
        // release line device
        g_pH323Line -> Unlock();

        // line is currenty maxed
        return LINEERR_RESOURCEUNAVAIL;
    }

    // allocate outgoing call
    pCall = new CH323Call();

    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;
        goto cleanup;
    }

    // save tapi handle and specify outgoing call direction
    if( !pCall -> Initialize(   htCall, 
                                LINECALLORIGIN_OUTBOUND, 
                                CALLTYPE_NORMAL ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;
        goto cleanup;
    }

    //This function should be called in a lock. But here we aint calling it in
    //a lock because this call is not added to the call table yet. Before
    //calling this function from anywhere else the call should be locked first
    if (!pCall -> ValidateCallParams( pCallParams,
                                      pwszDialableAddr,
                                      &dwStatus))
    {
        dwStatus = LINEERR_INVALCALLPARAMS;

        // failure
        goto cleanup;
    }

    // transfer handle
    *phdCall = pCall -> GetCallHandle();

    // bind outgoing call
    pConf = pCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not create conference." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    pCall->Lock();

    // post place call request to callback thread
    if( !pCall -> QueueTAPICallRequest( TSPI_MAKE_CALL, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not post place call message." ));

        // could not complete operation
        dwStatus = LINEERR_OPERATIONFAILED;

        pCall->Unlock();
        // failure
        goto cleanup;
    }

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall->Unlock();


    // release line device
    g_pH323Line -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMakeCall - Exited." ));
    
    // success
    return dwStatus;

cleanup:

    if( pCall != NULL )
    {
        pCall -> Shutdown( &fDelete );
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
        delete pCall;
        pCall = NULL;
    }

    *phdCall = NULL;

    // release line device
    g_pH323Line -> Unlock();

    // failure
    return dwStatus;
}


LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineReleaseUUIE - Entered." ));
    
    // retrieve call pointer from handle
    PH323_CALL pCall;

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_RELEASE_U2U, NULL))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post close event." ));
    }

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineReleaseUUIE - Exited." ));
            
    pCall -> Unlock();
    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              pUserUserInfo,
    DWORD               dwSize
    )
{
    BYTE*                   pU2UInfo = NULL;
    PBUFFERDESCR            pBuf = NULL;
    
    // retrieve call pointer from handle
    PH323_CALL pCall;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSendUUIE - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( dwSize && pUserUserInfo )
    {
        pU2UInfo = (BYTE*)new char[dwSize];
        if( pU2UInfo == NULL )
        {
            pCall -> Unlock();
            return LINEERR_NOMEM;
        }
                
        pBuf = (PBUFFERDESCR) new BUFFERDESCR;
        if( pBuf == NULL )
        {
            delete pU2UInfo;
            pU2UInfo = NULL;
            pCall -> Unlock();
            return LINEERR_NOMEM;
        }

        CopyMemory( (PVOID)pU2UInfo, (PVOID)pUserUserInfo, dwSize );
        pBuf -> pbBuffer = pU2UInfo;
        pBuf -> dwLength = dwSize;

        if( !pCall -> QueueTAPICallRequest( TSPI_SEND_U2U, (PVOID)pBuf ))
        {
	        H323DBG(( DEBUG_LEVEL_ERROR, "could not post close event." ));
	        pCall -> Unlock();
	        return LINEERR_OPERATIONFAILED;
        }
    }

    //complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSendUUIE - Exited." ));
            
    pCall -> Unlock();
    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL hdCall,
    DWORD    dwDigitModes
    )
{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMonitor - Entered." ));
    
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // see if mode empty
    if( dwDigitModes == 0 )
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE, "disabling dtmf detection." ));

        // disable monitoring digits
        pCall->m_fMonitoringDigits = FALSE;

        //unlock the call
        pCall -> Unlock();

        // success
        return NOERROR;
    } 
    else if( dwDigitModes != LINEDIGITMODE_DTMF )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "invalid digit modes 0x%08lx.", dwDigitModes ));

        //unlock the call
        pCall -> Unlock();

        // invalid call handle
        return LINEERR_INVALDIGITMODE;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE, "enabling dtmf detection." ));

    // enable monitoring digits
    pCall->m_fMonitoringDigits = TRUE;

    //unlock the call
    pCall -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMonitor - Exited." ));
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL hdCall,
    DWORD    dwEndToEndID,
    DWORD    dwDigitMode,
    LPCWSTR  pwszDigits,
    DWORD    dwDuration
    )
{
    PH323_CALL pCall;
    DWORD dwLength;

    UNREFERENCED_PARAMETER(dwDuration);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGenerateDigits - Entered." ));
    
    // retrieve call pointer from handle
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // verify that the call was connected
    if( pCall -> GetCallState() != LINECALLSTATE_CONNECTED )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not connected.", pCall ));
        
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    // verify monitor modes
    if( dwDigitMode != LINEDIGITMODE_DTMF ) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "invalid digit mode 0x%08lx.",
            dwDigitMode ));
        
        pCall -> Unlock();
        // invalid call handle
        return LINEERR_INVALDIGITMODE;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE, "sending user input %S.", pwszDigits ));

    if( pwszDigits == NULL )
    {
        // signal completion
        pCall->PostLineEvent (
            LINE_GENERATE,
            LINEGENERATETERM_CANCEL,
            dwEndToEndID,
            GetTickCount()
            );
        
        pCall -> Unlock();

        return NOERROR;
    }

    LPCWSTR wszDigits = pwszDigits;
    for( dwLength = 0; (*wszDigits) != L'\0'; wszDigits++ )
    {
        if( IsValidDTMFDigit(*wszDigits) == FALSE )
        {
            // signal completion
            pCall->PostLineEvent (
                LINE_GENERATE,
                LINEGENERATETERM_CANCEL,
                dwEndToEndID,
                GetTickCount()
                );

            pCall -> Unlock();
            
            // digit generation cancelled.
            return LINEERR_INVALDIGITS;
        }

        dwLength++;
    }

    if( dwLength == 0 )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "no digits to passo on." ));
        
        pCall -> Unlock();
        // invalid call handle
        return LINEERR_INVALPARAM;
    }

    // send user input message
    pCall -> SendMSPMessage(
        SP_MSG_SendDTMFDigits, 
        (BYTE*)pwszDigits, 
        dwLength, 
        NULL );

    // signal completion
    pCall->PostLineEvent (
        LINE_GENERATE,
        LINEGENERATETERM_DONE,
        dwEndToEndID,
        GetTickCount()
        );

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGenerateDigits - Exited." ));
        
    pCall -> Unlock();
    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by h323.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\rascall.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rascall.cpp

Abstract:

    The RAS call functionality (ARQ/DRQ/ACF/DCF/IRR/ARJ/DRJ)

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#include "globals.h"
#include "q931obj.h"
#include "line.h"
#include "q931pdu.h"
#include "ras.h"


//!!always called from a lock
BOOL
CH323Call::SendARQ(
                    IN long seqNumber
                  )
{
    RasMessage                          rasMessage;
    AdmissionRequest *                  ARQ;
    EXPIRE_CONTEXT *                    pExpireContext;
    PH323_ALIASNAMES                    pAliasList;
    PAdmissionRequest_destinationInfo   destInfo = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendARQ entered:%p.",this ));

    //if not registered with the GK then return failure
    if (!RasIsRegistered())
        return FALSE;

    pExpireContext = new EXPIRE_CONTEXT;
    if( pExpireContext == NULL )
    {
        return FALSE;
    }

    ZeroMemory( &rasMessage, sizeof RasMessage );

    rasMessage.choice = admissionRequest_chosen;
    ARQ = &rasMessage.u.admissionRequest;

    // get sequence number
    if( seqNumber != NOT_RESEND_SEQ_NUM )
    {
        ARQ -> requestSeqNum = (WORD)seqNumber;
    }
    else
    {
        m_wARQSeqNum = RasAllocSequenceNumber();
        ARQ -> requestSeqNum = m_wARQSeqNum;
    }

    ARQ -> callType.choice = pointToPoint_chosen;

    // endpointIdentifier
    RasGetEndpointID (&ARQ -> endpointIdentifier);

    // srcInfo: pass on the registered aliases
    pAliasList = RASGetRegisteredAliasList();

    ARQ -> srcInfo = (PAdmissionRequest_srcInfo)
        SetMsgAddressAlias( pAliasList );

    if( ARQ -> srcInfo == NULL )
    {
        delete pExpireContext;
        return FALSE;
    }

    // destInfo
    if( (m_dwOrigin==LINECALLORIGIN_OUTBOUND) && m_pCalleeAliasNames &&
        (m_pCalleeAliasNames -> wCount) )
    {
        ARQ -> destinationInfo = (PAdmissionRequest_destinationInfo)
            SetMsgAddressAlias( m_pCalleeAliasNames );

        if( ARQ -> destinationInfo != NULL )
        {
            ARQ -> bit_mask |= AdmissionRequest_destinationInfo_present;
        }
    }
    else if( (m_dwOrigin==LINECALLORIGIN_INBOUND) && m_pCallerAliasNames
        && (m_pCallerAliasNames -> wCount) )
    {
        ARQ -> destinationInfo = (PAdmissionRequest_destinationInfo)
            SetMsgAddressAlias( m_pCallerAliasNames );

        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    
        if( ARQ -> destinationInfo )
        {
            ARQ -> bit_mask |= AdmissionRequest_destinationInfo_present;
        }
    }

    for( destInfo = ARQ -> destinationInfo; destInfo; destInfo=destInfo->next )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "the alias:%s.", destInfo->value.u.e164 ));
    }

    ARQ -> bandWidth = 0;
    ARQ -> callReferenceValue = m_wCallReference;

    // no destExtraCallInfo
    // no srcCallSignalAddress
    // no nonStandardData
    // no callServices

    CopyConferenceID (&ARQ -> conferenceID, &m_ConferenceID);

    ARQ -> activeMC = FALSE;
    ARQ -> answerCall = ( m_dwOrigin == LINECALLORIGIN_INBOUND );
    ARQ -> canMapAlias = TRUE;

    CopyMemory( (PVOID)&ARQ -> callIdentifier.guid.value,
        (PVOID)&m_callIdentifier, sizeof(GUID) );

    ARQ -> callIdentifier.guid.length = sizeof (GUID);
    ARQ -> bit_mask |= AdmissionRequest_callIdentifier_present;

    // no srcAlternatives
    // no destAlternatives
    // no gatekeeperIdentifier
    // no tokens
    // no cryptoTokens
    // no integrityCheckValue
    // no transportQOS
    
    ARQ -> willSupplyUUIEs = FALSE;
    
    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, NULL );
        m_hARQTimer = NULL;
    }

    pExpireContext -> DriverCallHandle = m_hdCall;
    pExpireContext -> seqNumber = ARQ -> requestSeqNum;

    if( !CreateTimerQueueTimer(
            &m_hARQTimer,
            H323TimerQueue,
            CH323Call::ARQExpiredCallback,
            (PVOID)pExpireContext,
            ARQ_EXPIRE_TIME, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ))
    {
        goto cleanup;
    }


    if( RasEncodeSendMessage (&rasMessage) != S_OK )
    {
        goto cleanup;
    }

    if( ARQ -> bit_mask & AdmissionRequest_destinationInfo_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            ARQ -> destinationInfo );
    }
    
    FreeAddressAliases( (PSetup_UUIE_destinationAddress)ARQ -> srcInfo );
    m_dwRASCallState = RASCALL_STATE_ARQSENT;
    m_dwARQRetryCount++;

    _ASSERTE( m_pARQExpireContext == NULL );
    m_pARQExpireContext = pExpireContext;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendARQ exited:%p.",this ));
    return TRUE;

cleanup:

    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, 
            m_hARQTimer, NULL );
        m_hARQTimer = NULL;
        m_dwARQRetryCount = 0;
    }
    if( ARQ -> bit_mask & AdmissionRequest_destinationInfo_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            ARQ -> destinationInfo );
    }

    if( pExpireContext != NULL )
    {
        delete pExpireContext;
    }

    FreeAddressAliases( (PSetup_UUIE_destinationAddress)ARQ -> srcInfo );
    return FALSE;
}


//!!always called from a lock
BOOL 
CH323Call::SendDRQ(
                    IN USHORT usDisengageReason,
                    IN long seqNumber,
                    IN BOOL fResendOnExpire
                  )
{
    RasMessage          rasMessage;
    DisengageRequest *  DRQ;
    EXPIRE_CONTEXT *        pExpireContext;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendDRQ entered:%p.",this ));

    ZeroMemory( &rasMessage, sizeof(rasMessage) );
    rasMessage.choice = disengageRequest_chosen;
    DRQ = &rasMessage.u.disengageRequest;

    //if not registered with the GK then return failure
    if (!RasIsRegistered())
    {
        return FALSE;
    }

    if( fResendOnExpire == TRUE )
    {
        pExpireContext = new EXPIRE_CONTEXT;
        if( pExpireContext == NULL )
        {
            return FALSE;
        }
    }

    // get sequence number
    if( seqNumber != NOT_RESEND_SEQ_NUM )
    {
        DRQ -> requestSeqNum = (WORD)seqNumber;
    }
    else
    {
        m_wDRQSeqNum = RasAllocSequenceNumber();
        DRQ -> requestSeqNum = m_wDRQSeqNum;
    }

    DRQ -> callReferenceValue = m_wCallReference;
    DRQ -> disengageReason.choice = usDisengageReason;

    // endpoint identifier
    RasGetEndpointID (&DRQ -> endpointIdentifier);

    // conferenceID
    CopyConferenceID (&DRQ -> conferenceID, &m_ConferenceID);

    // callIdentifier
    CopyConferenceID (&DRQ -> callIdentifier.guid, &m_callIdentifier);
    DRQ -> bit_mask |= DisengageRequest_callIdentifier_present;

    if( RasEncodeSendMessage( &rasMessage ) != S_OK )
    {
        delete pExpireContext;
        return FALSE;
    }   

    if( m_hDRQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hDRQTimer, NULL );
        m_hDRQTimer = NULL;
    }

    if( fResendOnExpire == TRUE )
    {
        pExpireContext -> DriverCallHandle = m_hdCall;
        pExpireContext -> seqNumber = DRQ -> requestSeqNum;

        if( !CreateTimerQueueTimer(
            &m_hDRQTimer,
            H323TimerQueue,
            CH323Call::DRQExpiredCallback,
            (PVOID)pExpireContext,
            ARQ_EXPIRE_TIME, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ))
        {
            delete pExpireContext;
            return FALSE;
        }
    
        _ASSERTE( m_pDRQExpireContext == NULL );
        m_pDRQExpireContext = pExpireContext;
    }

    m_dwRASCallState = RASCALL_STATE_DRQSENT;
    m_dwDRQRetryCount++;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendDRQ exited:%p.",this ));
    return TRUE;
}


//!!always called from a lock    
void
CH323Call::OnDisengageRequest( 
                                IN DisengageRequest * DRQ
                             )
{
    GUID    RequestConferenceID;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageRequest entered:%p.",this ));

    if( (m_dwRASCallState == RASCALL_STATE_UNREGISTERED) ||
        (m_dwRASCallState == RASCALL_STATE_ARJRECVD) )
    {
        return;
    }

    CopyConferenceID (&RequestConferenceID, &DRQ -> conferenceID);

    if (!IsEqualGUID (m_ConferenceID, RequestConferenceID))
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "DisengageRequest conference ID does not match this call, ignoring..."));
        return;
    }

    if (SendDCF (DRQ -> requestSeqNum))
    {
        m_dwRASCallState = RASCALL_STATE_UNREGISTERED;
        CloseCall( 0 );
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageRequest exited:%p.",this ));
}


//!!always called in a lock    
BOOL
CH323Call::SendDCF(
                   IN WORD seqNumber
                  )
{
    RasMessage          rasMessage;
    DisengageConfirm *  DCF;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendDCF entered:%p.",this ));

    ZeroMemory( &rasMessage, sizeof(rasMessage) );
    rasMessage.choice = disengageConfirm_chosen;
    DCF = &rasMessage.u.disengageConfirm;

    //if not registered with the GK then return failure
    if (!RasIsRegistered())
    {
        return FALSE;
    }
        
    DCF -> requestSeqNum = seqNumber;
    if (RasEncodeSendMessage (&rasMessage) != S_OK)
    {
        return FALSE;
    }   
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendDCF exited:%p.",this ));
    return TRUE;
}

//!!always called from a lock    
void 
CH323Call::OnDisengageReject(
                            IN DisengageReject* DRJ
                            )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageReject entered:%p.",this ));

    if( DRJ -> requestSeqNum != m_wDRQSeqNum )
    {
        return;
    }


    if( m_dwRASCallState != RASCALL_STATE_DRQSENT ) 
    {
        return;
    }
    
    if( DRJ->rejectReason.choice == requestToDropOther_chosen )
    {
        //
        H323DBG(( DEBUG_LEVEL_ERROR, "!!something is wrong in the way DRQ is encoded.",this ));
    }
    else //if( DRJ->rejectReason.choice == DisengageRejectReason_notRegistered_chosen )
    {
        //the call has been unregistered but is still around, so dsrop it
        m_dwRASCallState = RASCALL_STATE_UNREGISTERED;
        //CloseCall( 0 );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageReject exited:%p.",this ));
}


void
CH323Call::OnRequestInProgress( 
                               IN RequestInProgress* RIP
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnRequestInProgress entered:%p.",this ));
    EXPIRE_CONTEXT * pExpireContext;

    if( RIP -> requestSeqNum != m_wARQSeqNum )
    {
        return;
    }

    if( m_dwRASCallState != RASCALL_STATE_ARQSENT ) 
    {
        return;
    }

    //if delay is more than 30 seconds ignore it
    if( (RIP->delay > 0) && (RIP->delay > 30000) )
    {
        return;
    }

    pExpireContext = new EXPIRE_CONTEXT;
    if( pExpireContext == NULL )
    {
        return;
    }
    
    //restart the timer
    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, NULL );
        m_hARQTimer = NULL;
    }

    pExpireContext -> DriverCallHandle = m_hdCall;
    pExpireContext -> seqNumber = m_wARQSeqNum;

    if( !CreateTimerQueueTimer(
            &m_hARQTimer,
            H323TimerQueue,
            CH323Call::ARQExpiredCallback,
            (PVOID)pExpireContext,
            (DWORD)RIP->delay, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ))
    {
        //close the call        
        CloseCall( 0 );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRequestInProgress exited:%p.",this ));
}


//!!always called from a lock
void 
CH323Call::OnDisengageConfirm(
                                IN DisengageConfirm* DCF
                             )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageConfirm entered:%p.",this ));

    if( DCF -> requestSeqNum != m_wDRQSeqNum )
    {
        return;
    }

    if( m_dwRASCallState == RASCALL_STATE_DRQSENT )
    {
        if( m_hDRQTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hDRQTimer,
                NULL );
            m_hDRQTimer = NULL;
        }

        //nikhil:if this is a replacement call/diverted call then this may lead
        //to inconsistent behaviour
        m_dwRASCallState = RASCALL_STATE_UNREGISTERED;
        //CloseCall( 0 );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageConfirm exited:%p.",this ));
}


//!!always called from a lock
void 
CH323Call::OnAdmissionConfirm(
                                IN AdmissionConfirm * ACF
                             )
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnAdmissionConfirm entered:%p.",this ));

    _ASSERTE( m_dwRASCallState != RASCALL_STATE_IDLE );
    
    if( ACF -> requestSeqNum != m_wARQSeqNum )
    {
        return;
    }

    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, 
            NULL );
        m_hARQTimer = NULL;
        m_dwARQRetryCount = 0;
    }

    if( m_dwRASCallState == RASCALL_STATE_ARQSENT )
    {
        m_dwRASCallState = RASCALL_STATE_REGISTERED;

        if( m_dwOrigin == LINECALLORIGIN_OUTBOUND )
        {
            if( (ACF ->destCallSignalAddress.choice != ipAddress_chosen) ||
                (ACF->destCallSignalAddress.u.ipAddress.ip.length != 4) )
            {
                DropCall( LINEDISCONNECTMODE_BADADDRESS );
                return;
            }
            
            // save converted address
            m_CalleeAddr.nAddrType = H323_IP_BINARY;
            m_CalleeAddr.Addr.IP_Binary.dwAddr = 
                ntohl(*(DWORD*)(ACF->destCallSignalAddress.u.ipAddress.ip.value) );
            m_CalleeAddr.Addr.IP_Binary.wPort =
                ACF->destCallSignalAddress.u.ipAddress.port;
            m_CalleeAddr.bMulticast =
                IN_MULTICAST(m_CalleeAddr.Addr.IP_Binary.dwAddr);

            //Replaces the first alias in the callee list (the dialableAddress
            //passed in TSPI_lineMakecall ). The GK looks at the first alias
            //only. Its assumed that only the first alias is mapped by the GK.
            if( (ACF -> bit_mask & AdmissionConfirm_destinationInfo_present) &&
                ACF->destinationInfo )
            {
                MapAliasItem( m_pCalleeAliasNames,
                    &(ACF->destinationInfo->value) );
            }

            if( !PlaceCall() )
            {
                DropCall( LINEDISCONNECTMODE_UNREACHABLE );
            }
        }
        else
        {
            if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
            {
                MSPMessageData* pMSPMessageData = new MSPMessageData;
                if( pMSPMessageData == NULL )
                {
                    CloseCall( 0 );
                    return;
                }

                pMSPMessageData->hdCall = m_hdRelatedCall;
                pMSPMessageData->messageType = SP_MSG_PrepareToAnswer;
                pMSPMessageData->pbEncodedBuf = m_prepareToAnswerMsgData.pbBuffer;
                pMSPMessageData->wLength = (WORD)m_prepareToAnswerMsgData.dwLength;
                pMSPMessageData->hReplacementCall = m_hdCall;
                m_prepareToAnswerMsgData.pbBuffer = NULL;

                QueueUserWorkItem( SendMSPMessageOnRelatedCall,
                    pMSPMessageData, WT_EXECUTEDEFAULT );
            }
            else
            {

                // signal incoming call
                _ASSERTE(!m_htCall);

                PostLineEvent (
                    LINE_NEWCALL,
                    (DWORD_PTR)m_hdCall,
                    (DWORD_PTR)&m_htCall, 0);

                _ASSERTE( m_htCall );
                if( m_htCall == NULL )
                {
                    H323DBG(( DEBUG_LEVEL_ERROR, "tapi call handle NULL!!" ));
                    CloseCall( 0 );
                    return;
                }

                if( IsListEmpty(&m_IncomingU2U) == FALSE )
                {
                    // signal incoming
                    PostLineEvent (
                        LINE_CALLINFO,
                        (DWORD_PTR)LINECALLINFOSTATE_USERUSERINFO,
                        0, 0);
                }

                ChangeCallState( LINECALLSTATE_OFFERING, 0 );

                // send the new call message to the unspecified MSP
                SendMSPMessage( SP_MSG_PrepareToAnswer, 
                    m_prepareToAnswerMsgData.pbBuffer,
                    m_prepareToAnswerMsgData.dwLength, NULL );
            }

            if( m_prepareToAnswerMsgData.pbBuffer )
                delete m_prepareToAnswerMsgData.pbBuffer;
            ZeroMemory( (PVOID)&m_prepareToAnswerMsgData, sizeof(BUFFERDESCR) );

        }
    }
    else if( m_dwRASCallState == RASCALL_STATE_ARQEXPIRED )
    {
        SendDRQ( forcedDrop_chosen, NOT_RESEND_SEQ_NUM, TRUE );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnAdmissionConfirm exited:%p.",this ));
}


//!!always called from a lock
void
CH323Call::OnAdmissionReject(
                            IN AdmissionReject * ARJ
                            )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnAdmissionReject entered:%p.",this ));

    if( ARJ -> requestSeqNum != m_wARQSeqNum )
    {
        return;
    }
    
    m_dwRASCallState = RASCALL_STATE_ARJRECVD;
    
    //If a forward consult call then enable the forwarding anyway.
    if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
        (m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
    {
        //Success of forwarding
        EnableCallForwarding();
    }
    
    //drop the call. shutdown the call and rlease the call.
    CloseCall( LINEDISCONNECTMODE_BADADDRESS );    
    
    H323DBG(( DEBUG_LEVEL_TRACE, "OnAdmissionReject exited:%p.",this ));
}


HRESULT 
CH323Call::GetCallInfo (
    OUT GUID *  ReturnCallID,
    OUT GUID *  ReturnConferenceID )
{

    //verify call state
    if( m_dwCallState == LINECALLSTATE_DISCONNECTED )
    {
        return E_FAIL;
    }

    *ReturnCallID = m_callIdentifier;
    *ReturnConferenceID = m_ConferenceID;

    return S_OK;
}

 
void
NTAPI CH323Call::DRQExpiredCallback(
    IN  PVOID   ContextParameter,   // pExpireContext
    IN  BOOLEAN TimerFired          // not used
    )             
{
    EXPIRE_CONTEXT *    pExpireContext;
    HDRVCALL            DriverCall;
    PH323_CALL          pCall;

    _ASSERTE(ContextParameter);
    pExpireContext = (EXPIRE_CONTEXT *) ContextParameter;
    _ASSERTE( pExpireContext == m_pDRQExpireContext );

    __try
    {
        DriverCall = (HDRVCALL) pExpireContext -> DriverCallHandle;

        pCall = g_pH323Line -> FindH323CallAndLock (DriverCall);
        if (pCall)
        {
            pCall -> DRQExpired (pExpireContext -> seqNumber);
            
            delete pExpireContext;
            pCall -> Unlock();
        }
        else
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "warning: DRQExpiredCallback failed to locate call object"));
        }
    }
    __except( 1 )
    {
        // The call has already been deleted and hence the pExpireContext
        // buffer is also deleted.
        return;
    }
}


void
NTAPI CH323Call::ARQExpiredCallback(
    IN  PVOID   ContextParameter,       // pExpireContext
    IN  BOOLEAN TimerFired)             // not used
{
    EXPIRE_CONTEXT *    pExpireContext;
    HDRVCALL            DriverCall;
    PH323_CALL          pCall;

    _ASSERTE(ContextParameter);
    pExpireContext = (EXPIRE_CONTEXT *) ContextParameter;
    _ASSERTE( pExpireContext == m_pARQExpireContext );

    
    __try
    {
        DriverCall = (HDRVCALL) pExpireContext -> DriverCallHandle;

        pCall = g_pH323Line -> FindH323CallAndLock (DriverCall);
        if (pCall)
        {
            pCall -> ARQExpired (pExpireContext -> seqNumber);
        
            delete pExpireContext;
            pCall -> Unlock();
            
        }
        else
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "warning: ARQExpiredCallback failed to locate call object"));
        }
    }
    __except( 1 )
    {
        // The call has already been deleted and hence the pExpireContext
        // buffer is also deleted.
        return;
    }
}


//!!always called from a lock
void CH323Call::ARQExpired (
    IN  WORD    seqNumber)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "ARQExpired entered:%p.",this ));
    
    m_pARQExpireContext = NULL;
    
    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, NULL );
        m_hARQTimer = NULL;
    }

    if( m_dwRASCallState == RASCALL_STATE_ARQSENT )
    {
        if( m_dwARQRetryCount < ARQ_RETRY_MAX )
        {
            if( !SendARQ( (long)seqNumber ) )
            {
                // drop call using disconnect mode
                DropCall(0);
            }
        }
        else
        {
            m_dwRASCallState = RASCALL_STATE_ARQEXPIRED;
            //Not able to register, shutdown the RAS client object
            CloseCall( 0 );        
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "ARQExpired exited:%p.",this ));
}


//!!always called from a lock
void
CH323Call::DRQExpired(
                        IN WORD seqNumber
                     )
{    
    H323DBG(( DEBUG_LEVEL_TRACE, "DRQExpired entered:%p.", this ));
    m_pDRQExpireContext = NULL;
    
    if( m_hDRQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hDRQTimer, NULL );
        m_hDRQTimer = NULL;
    }

    if( m_dwRASCallState == RASCALL_STATE_DRQSENT )
    {
        if( m_dwDRQRetryCount < DRQ_RETRY_MAX )
        {
            if( !SendDRQ( forcedDrop_chosen, (long)seqNumber, TRUE ) )
            {
                // drop call using disconnect mode
                DropCall(0);
            }
        }
        else
        {
            m_dwRASCallState = RASCALL_STATE_DRQEXPIRED;
            //Not able to register, shutdown the RAS client object
            CloseCall( 0 );
        }
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "DRQExpired exited:%p.",this ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323\tsp\registry.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    Routines for reading registry configuration.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 

//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "ras.h"
#include "q931obj.h"

//
// Macro definitions
//

#define GK_PORT				            1719
#define EVENTLOG_SERVICE_APP_KEY_PATH	_T("System\\CurrentControlSet\\Services\\EventLog\\Application")
#define EVENTLOG_MESSAGE_FILE			_T("EventMessageFile")
#define EVENTLOG_TYPES_SUPPORTED		_T("TypesSupported")
#define EVENT_SOURCE_TYPES_SUPPORTED    7
#define H323_TSP_MODULE_NAME            _T("H323.TSP")

//                                                                           
// Global variables                                                          
//                                                                           

extern Q931_LISTENER		            Q931Listener;

H323_REGISTRY_SETTINGS                  g_RegistrySettings;

static	HKEY		                    g_RegistryKey = NULL;
static	HANDLE		                    g_RegistryNotifyEvent = NULL;

// RTL thread pool wait handle
static	HANDLE		                    g_RegistryNotifyWaitHandle = NULL;		


static void NTAPI RegistryNotifyCallback (
	IN	PVOID	ContextParameter,
	IN	BOOLEAN	TimerFired);

static BOOL H323GetConfigFromRegistry (void);



//                                                                           
// Public procedures                                                         
//                                                                           


/*++

Routine Description:
    
    Changes configuration settings back to defaults.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

static BOOL RegistrySetDefaultConfig(void)
{
    //initialize alerting timeout to default
    g_RegistrySettings.dwQ931AlertingTimeout = CALL_ALERTING_TIMEOUT;

    //initialize call signalling port to default
    g_RegistrySettings.dwQ931ListenPort= Q931_CALL_PORT;

    // success
    return TRUE;
}

static LONG RegistryRequestNotify(void)
{
    return RegNotifyChangeKeyValue (
        g_RegistryKey,                  // key to watch
        FALSE,                          // do not watch subtree
        REG_NOTIFY_CHANGE_LAST_SET,     // notify filter
        g_RegistryNotifyEvent,          // notification event
        TRUE);                          // is asychnronous
}


HRESULT RegistryStart(void)
{
    LONG    lStatus;
    DWORD   dwResult;
    HKEY    regKeyService;
    HKEY    hKey;
    DWORD   dwValue;
                    
    if( g_RegistryKey != NULL )
    {
        return TRUE;
    }

    RegistrySetDefaultConfig();

    lStatus = RegCreateKeyEx (
        HKEY_LOCAL_MACHINE,
        H323_REGKEY_ROOT,
        0, WIN31_CLASS, 0,
        KEY_READ, NULL,
        &g_RegistryKey, NULL);

    if( lStatus != ERROR_SUCCESS )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "configuration registry key could not be opened/created" ));
        DumpError (lStatus);

        return E_FAIL;
    }

    // load initial configuration
    H323GetConfigFromRegistry();


    g_RegistryNotifyEvent = NULL;
    g_RegistryNotifyWaitHandle = NULL;

    g_RegistryNotifyEvent = H323CreateEvent (NULL, FALSE, FALSE, 
        _T( "H323TSP_RegistryNotifyEvent" ) );

    if( g_RegistryNotifyEvent != NULL )
    {

        lStatus = RegistryRequestNotify();

        if( lStatus == ERROR_SUCCESS )
        {
            if (RegisterWaitForSingleObject (
                &g_RegistryNotifyWaitHandle,
                g_RegistryNotifyEvent,
                RegistryNotifyCallback,
                NULL, INFINITE, WT_EXECUTEDEFAULT))
            {

                _ASSERTE( g_RegistryNotifyWaitHandle );
                // ready
            }
            else
            {
                // failed to registry wait
                H323DBG(( DEBUG_LEVEL_ERROR, 
                    "failed to callback for registry notification" ));
                DumpError (lStatus);

                g_RegistryNotifyWaitHandle = NULL;
            }
        }
        else
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "failed to request notification on registry changes" ));
            DumpError (lStatus);
        }
    }
    else
    {
        // although this is an error, we continue anyway.
        // we just won't be able to receive notification of registry changes.

        H323DBG(( DEBUG_LEVEL_ERROR, 
            "failed to create event, cannot receive registry notification events" ));
    }

    //Eventlog params
    lStatus = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        EVENTLOG_SERVICE_APP_KEY_PATH,
        0,
        KEY_CREATE_SUB_KEY,
        &regKeyService );

    if( lStatus == ERROR_SUCCESS )
    {
        lStatus = RegCreateKey(
            regKeyService,
            H323TSP_EVENT_SOURCE_NAME,
            &hKey );

        RegCloseKey( regKeyService );
        regKeyService = NULL;
        
        if( lStatus == ERROR_SUCCESS )
        {
            TCHAR wszModulePath[MAX_PATH+1];

            dwResult = GetModuleFileName(
                GetModuleHandle( H323_TSP_MODULE_NAME ),
                wszModulePath, MAX_PATH );
            
            if( dwResult != 0 )
            {
                // query for registry value
                lStatus = RegSetValueEx(
                            hKey,
                            EVENTLOG_MESSAGE_FILE,
                            0,
                            REG_SZ,
                            (LPBYTE)wszModulePath,
                            H323SizeOfWSZ(wszModulePath) );

                // validate return code
                if( lStatus == ERROR_SUCCESS )
                {
                    dwValue = EVENT_SOURCE_TYPES_SUPPORTED;
                    // query for registry value
                    lStatus = RegSetValueEx(
                                hKey,
                                EVENTLOG_TYPES_SUPPORTED,
                                0,
                                REG_DWORD,
                                (LPBYTE)&dwValue,
                                sizeof(DWORD) );

                    if( lStatus == ERROR_SUCCESS )
                    {
                        // connect to event logging service
                        g_hEventLogSource = RegisterEventSource( NULL,
                            H323TSP_EVENT_SOURCE_NAME );
                    }
                }
            }
        }

        RegCloseKey( hKey );
        hKey = NULL;
    }

    return S_OK;
}


    
void RegistryStop(void)
{
    HKEY hKey;
    LONG lStatus;
    H323DBG ((DEBUG_LEVEL_TRACE, "RegistryStop Entered"));

    if (g_RegistryNotifyWaitHandle)
    {
        UnregisterWaitEx( g_RegistryNotifyWaitHandle, (HANDLE) -1 );
        g_RegistryNotifyWaitHandle = NULL;
    }

    if (g_RegistryNotifyEvent)
    {
        CloseHandle (g_RegistryNotifyEvent);
        g_RegistryNotifyEvent = NULL;
    }

    if (g_RegistryKey)
    {
        RegCloseKey (g_RegistryKey);
        g_RegistryKey = NULL;
    }

    //Eventlog params
    lStatus = RegOpenKeyEx (    
        HKEY_LOCAL_MACHINE,
        EVENTLOG_SERVICE_APP_KEY_PATH,
        0,
        KEY_CREATE_SUB_KEY,
        &hKey );

    if( lStatus==ERROR_SUCCESS )
    {
        RegDeleteKey( hKey, H323TSP_EVENT_SOURCE_NAME);
        RegCloseKey( hKey );
        hKey = NULL;
    }

    g_RegistrySettings.dwQ931ListenPort = 0;

    H323DBG ((DEBUG_LEVEL_TRACE, "RegistryStop Exited"));
}



static DWORD inet_addrW(
    IN  LPTSTR String
    )
{
    CHAR    AnsiString  [0x21];
    INT     Length;

    Length = WideCharToMultiByte (CP_ACP, 0, String, -1, AnsiString, 0x20, NULL, NULL);
    AnsiString [Length] = 0;

    return inet_addr (AnsiString);
}

static HOSTENT * gethostbynameW (LPTSTR String)
{
    CHAR    AnsiString  [0x21];
    INT     Length;

    Length = WideCharToMultiByte (CP_ACP, 0, String, -1, AnsiString, 0x20, NULL, NULL);
    AnsiString [Length] = 0;

    return gethostbyname (AnsiString);
}

static BOOL H323GetConfigFromRegistry (void)
    
/*++

Routine Description:
    
    Loads registry settings for service provider.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    LONG    lStatus = ERROR_SUCCESS;
    TCHAR    szAddr[H323_MAXDESTNAMELEN];
    DWORD   dwValue;
    DWORD   dwValueSize;
    DWORD   dwValueType;
    LPTSTR   pszValue;

    // see if key open
    if( g_RegistryKey == NULL )
    {
        return FALSE;
    }

    // initialize value name
    pszValue = H323_REGVAL_DEBUGLEVEL;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
        g_RegistryKey,
        pszValue,
        NULL,
        &dwValueType,
        (LPBYTE)&g_RegistrySettings.dwLogLevel,
        &dwValueSize
        );

    // validate return code
    if( lStatus != ERROR_SUCCESS )
    {
        // copy default value into global settings
        g_RegistrySettings.dwLogLevel = DEBUG_LEVEL_FORCE;
    }

    // initialize value name
    pszValue = H323_REGVAL_Q931LISTENPORT;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwQ931ListenPort,
                &dwValueSize
                );                    

    // validate return code
    if( (lStatus == ERROR_SUCCESS) && 
        (g_RegistrySettings.dwQ931ListenPort >=1000) &&
        (g_RegistrySettings.dwQ931ListenPort <= 32000)
      )
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
                  "using Q931 listen portof %d.",
                  g_RegistrySettings.dwQ931ListenPort ));
    } 
    else 
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "using default Q931 timeout." ));

        // copy default value into global settings
        g_RegistrySettings.dwQ931ListenPort = Q931_CALL_PORT;
    }   

    // initialize value name
    pszValue = H323_REGVAL_Q931ALERTINGTIMEOUT;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwQ931AlertingTimeout,
                &dwValueSize
                );                    

    // validate return code
    if( (lStatus == ERROR_SUCCESS) && 
        (g_RegistrySettings.dwQ931AlertingTimeout >=30000) &&
        (g_RegistrySettings.dwQ931AlertingTimeout <= CALL_ALERTING_TIMEOUT)
      )
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
                  "using Q931 timeout of %d milliseconds.",
                  g_RegistrySettings.dwQ931AlertingTimeout ));
    } 
    else 
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "using default Q931 timeout." ));

        // copy default value into global settings
        g_RegistrySettings.dwQ931AlertingTimeout = CALL_ALERTING_TIMEOUT;
    }   
    
    // initialize value name
    pszValue = H323_REGVAL_GATEWAYADDR;

    // initialize type 
    dwValueType = REG_SZ;
    dwValueSize = sizeof(szAddr);

    // initialize ip address
    dwValue = INADDR_NONE;

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (unsigned char*)szAddr,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // convert ip address
        dwValue = inet_addrW(szAddr);

        // see if address converted
        if( dwValue == INADDR_NONE )
        {
            struct hostent * pHost;

            // attempt to lookup hostname
            pHost = gethostbynameW(szAddr);

            // validate pointer
            if (pHost != NULL)
            {
                // retrieve host address from structure
                dwValue = *(unsigned long *)pHost->h_addr;
            }
        }
    }

    // see if address converted and check for null
    if ((dwValue > 0) && (dwValue != INADDR_NONE) )
    {
        // save new gateway address in registry structure
        g_RegistrySettings.gatewayAddr.nAddrType = H323_IP_BINARY;
        g_RegistrySettings.gatewayAddr.Addr.IP_Binary.dwAddr = ntohl(dwValue);
        g_RegistrySettings.gatewayAddr.Addr.IP_Binary.wPort =
            LOWORD(g_RegistrySettings.dwQ931ListenPort);
        g_RegistrySettings.gatewayAddr.bMulticast =
            IN_MULTICAST(g_RegistrySettings.gatewayAddr.Addr.IP_Binary.dwAddr);

        H323DBG((
            DEBUG_LEVEL_TRACE,
            "gateway address resolved to %s.",
            H323AddrToString(dwValue)
            ));

    } 
    else 
    {
        // clear memory used for gateway address
        memset( (PVOID) &g_RegistrySettings.gatewayAddr,0,sizeof(H323_ADDR));
    }

    // initialize value name
    pszValue = H323_REGVAL_GATEWAYENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGatewayEnabled = (dwValue != 0);

    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsGatewayEnabled = FALSE;
    }

    // initialize value name
    pszValue = H323_REGVAL_PROXYADDR;

    // initialize type 
    dwValueType = REG_SZ;
    dwValueSize = sizeof(szAddr);

    // initialize ip address
    dwValue = INADDR_NONE;

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (unsigned char*)szAddr,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // convert ip address
        dwValue = inet_addrW(szAddr);

        // see if address converted
        if( dwValue == INADDR_NONE )
        {
            struct hostent * pHost;

            // attempt to lookup hostname
            pHost = gethostbynameW(szAddr);

            // validate pointer
            if (pHost != NULL)
            {
                // retrieve host address from structure
                dwValue = *(unsigned long *)pHost->h_addr;
            }
        }
    }

    // see if address converted
    if( (dwValue > 0) && (dwValue != INADDR_NONE) ) 
    {
        // save new gateway address in registry structure
        g_RegistrySettings.proxyAddr.nAddrType = H323_IP_BINARY;
        g_RegistrySettings.proxyAddr.Addr.IP_Binary.dwAddr = ntohl(dwValue);
        g_RegistrySettings.proxyAddr.Addr.IP_Binary.wPort =
            LOWORD(g_RegistrySettings.dwQ931ListenPort);
        g_RegistrySettings.proxyAddr.bMulticast =
            IN_MULTICAST(g_RegistrySettings.proxyAddr.Addr.IP_Binary.dwAddr);

        H323DBG(( DEBUG_LEVEL_TRACE,
                  "proxy address resolved to %s.",
                  H323AddrToString(dwValue) ));
    } 
    else 
    {
        // clear memory used for gateway address
        memset( (PVOID)&g_RegistrySettings.proxyAddr,0,sizeof(H323_ADDR));
    }

    // initialize value name
    pszValue = H323_REGVAL_PROXYENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsProxyEnabled = (dwValue != 0);

    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsProxyEnabled = FALSE;
    }

    /////////////////////////////////////////////////////////////////////////
                    //Read the GK address
    ////////////////////////////////////////////////////////////////////////

    // initialize value name
    pszValue = H323_REGVAL_GKENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGKEnabled = (dwValue != 0);
    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsGKEnabled = FALSE;
    }

    if( g_RegistrySettings.fIsGKEnabled )
    {
        // initialize value name
        pszValue = H323_REGVAL_GKADDR;

        // initialize type 
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // initialize ip address
        dwValue = INADDR_NONE;

        // query for registry value
        lStatus = RegQueryValueEx(
                    g_RegistryKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (unsigned char*)szAddr,
                    &dwValueSize
                    );
    
        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            //convert ip address
            dwValue = inet_addrW(szAddr);

            // see if address converted
            if( dwValue == INADDR_NONE )
            {
                struct hostent * pHost;

                // attempt to lookup hostname
                pHost = gethostbynameW(szAddr);

                // validate pointer
                if (pHost != NULL)
                {
                    // retrieve host address from structure
                    dwValue = *(unsigned long *)pHost->h_addr;
                }
            }
        }

        // see if address converted and check for null
        if( (dwValue > 0) && (dwValue != INADDR_NONE) )
        {
            // save new gateway address in registry structure
            g_RegistrySettings.saGKAddr.sin_family = AF_INET;
            g_RegistrySettings.saGKAddr.sin_addr.s_addr = dwValue;
            g_RegistrySettings.saGKAddr.sin_port = htons( GK_PORT );

            H323DBG(( DEBUG_LEVEL_TRACE,
                "gatekeeper address resolved to %s.", H323AddrToString(dwValue) ));
        } 
        else
        {
            // clear memory used for gateway address
            memset( (PVOID) &g_RegistrySettings.saGKAddr,0,sizeof(SOCKADDR_IN));
            g_RegistrySettings.fIsGKEnabled = FALSE;
        }
    }
    /////////////////////////////////////////////////////////////////////////
                    //Read the GK log on phone number
    ////////////////////////////////////////////////////////////////////////
    
    // initialize value name
    pszValue = H323_REGVAL_GKLOGON_PHONEENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGKLogOnPhoneEnabled = (dwValue != 0);
    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsGKLogOnPhoneEnabled = FALSE;
    }

    if( g_RegistrySettings.fIsGKLogOnPhoneEnabled )
    {
        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_PHONE;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = H323_MAXDESTNAMELEN * sizeof (TCHAR);

        // query for registry value
        lStatus = RegQueryValueEx(
                    g_RegistryKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE) g_RegistrySettings.wszGKLogOnPhone,
                    &dwValueSize
                    );
    
        // validate return code
        if( (lStatus!=ERROR_SUCCESS) || 
            (dwValueSize > sizeof(szAddr)) )
        {
            memset( (PVOID) g_RegistrySettings.wszGKLogOnPhone, 0,
                sizeof(g_RegistrySettings.wszGKLogOnPhone));
            g_RegistrySettings.fIsGKLogOnPhoneEnabled = FALSE;
        }
        else
        {
           g_RegistrySettings.fIsGKLogOnPhoneEnabled = TRUE;
        }
    }

    /////////////////////////////////////////////////////////////////////////
                    //Read the GK log on acct name
    ////////////////////////////////////////////////////////////////////////
    
    // initialize value name
    pszValue = H323_REGVAL_GKLOGON_ACCOUNTENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGKLogOnAccountEnabled = (dwValue != 0);
    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsGKLogOnAccountEnabled = FALSE;
    }

    if( g_RegistrySettings.fIsGKLogOnAccountEnabled  )
    {
        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_ACCOUNT;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = H323_MAXDESTNAMELEN * sizeof (TCHAR);

        // initialize ip address
        dwValue = INADDR_NONE;

        // query for registry value
        lStatus = RegQueryValueEx(
                    g_RegistryKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE) g_RegistrySettings.wszGKLogOnAccount,
                    &dwValueSize
                    );
    
        // validate return code
        if( (lStatus!=ERROR_SUCCESS) || 
            (dwValueSize > sizeof(g_RegistrySettings.wszGKLogOnPhone)) )
        
        {
            memset( (PVOID) g_RegistrySettings.wszGKLogOnAccount, 0,
                sizeof(g_RegistrySettings.wszGKLogOnAccount));
            g_RegistrySettings.fIsGKLogOnAccountEnabled = FALSE;
        }
        else
        {
            g_RegistrySettings.fIsGKLogOnAccountEnabled = TRUE;
        }

    }
    
    // success
    return TRUE;
}


static void NTAPI RegistryNotifyCallback (
    IN  PVOID   ContextParameter,
    IN  BOOLEAN TimerFired
    )
{
    H323DBG ((DEBUG_LEVEL_TRACE, "registry notify event enter."));

    // refresh registry settings
    H323GetConfigFromRegistry();

    //if the gatekeeper has been enabled or disabled or changed then 
    //send RRQ and URQ as required
    //if the alias list has been changed then update the gatekeeper 
    //alias list
    RasHandleRegistryChange();

    //Listen on the new port number if changed.
    Q931Listener.HandleRegistryChange();

    RegistryRequestNotify();

    H323DBG ((DEBUG_LEVEL_TRACE, "registry notify event exit."));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323addr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    H323addr.cpp 

Abstract:

    This module contains implementation of CH323MSP.

Author:
    
    Mu Han (muhan)   5-September-1997

--*/
#include "stdafx.h"
#include "common.h"

STDMETHODIMP CH323MSP::CreateTerminal(
    IN      BSTR                pTerminalClass,
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    OUT     ITTerminal **       ppTerminal
    )
/*++

Routine Description:

This method is called by TAPI3 to create a dynamic terminal. It asks the 
terminal manager to create a dynamic terminal. 

Arguments:

iidTerminalClass
    IID of the terminal class to be created.

dwMediaType
    TAPI media type of the terminal to be created.

Direction
    Terminal direction of the terminal to be created.

ppTerminal
    Returned created terminal object
    
Return Value:

S_OK

E_OUTOFMEMORY
TAPI_E_INVALIDMEDIATYPE
TAPI_E_INVALIDTERMINALDIRECTION
TAPI_E_INVALIDTERMINALCLASS

--*/
{
    LOG((MSP_TRACE,
        "CH323MSP::CreateTerminal - enter"));

    //
    // Check if initialized.
    //

    // lock the event related data
    m_EventDataLock.Lock();

    if ( m_htEvent == NULL )
    {
        // unlock the event related data
        m_EventDataLock.Unlock();

        LOG((MSP_ERROR,
            "CH323MSP::CreateTerminal - "
            "not initialized - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    // unlock the event related data
    m_EventDataLock.Unlock();

    //
    // Get the IID from the BSTR representation.
    //

    HRESULT hr;
    IID     iidTerminalClass;

    hr = CLSIDFromString(pTerminalClass, &iidTerminalClass);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CH323MSP::CreateTerminal - "
            "bad CLSID string - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    
    //
    // we don't have any specific req's to terminal's media type. 
    // termmgr will check if the media type is valid at all.
    //
 
    //
    // The terminal manager checks the terminal class, terminal direction, 
    // and return pointer.
    //

    //
    // Use the terminal manager to create the dynamic terminal.
    //

    _ASSERTE( m_pITTerminalManager != NULL );

    hr = m_pITTerminalManager->CreateDynamicTerminal(NULL,
                                                     iidTerminalClass,
                                                     (DWORD) lMediaType,
                                                     Direction,
                                                     (MSP_HANDLE) this,
                                                     ppTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CH323MSP::CreateTerminal - "
            "create dynamic terminal failed - returning 0x%08x", hr));

        return hr;
    }

    if ((iidTerminalClass == CLSID_MediaStreamTerminal)
        && (lMediaType == TAPIMEDIATYPE_AUDIO))
    {
        // Set the format of the audio to 8KHZ, 16Bit/Sample, MONO.
        hr = ::SetAudioFormat(
            *ppTerminal, 
            g_wAudioCaptureBitPerSample, 
            g_dwAudioSampleRate
            );

        if (FAILED(hr))
        {
            LOG((MSP_WARN, "can't set audio format, %x", hr));
        }
    }

    LOG((MSP_TRACE, "CH323MSP::CreateTerminal - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CH323MSP::CreateMSPCall(
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType,
    IN      IUnknown *          pOuterUnknown,
    OUT     IUnknown **         ppMSPCall
    )
/*++

Routine Description:

This method is called by TAPI3 before a call is made or answered. It creates 
a aggregated MSPCall object and returns the IUnknown pointer. It calls the
helper template function defined in mspaddress.h to handle the real creation.

Arguments:

htCall
    TAPI 3.0's identifier for this call.  Returned in events passed back 
    to TAPI.

dwReserved
    Reserved parameter.  Not currently used.

dwMediaType
    Media type of the call being created.  These are TAPIMEDIATYPES and more 
    than one mediatype can be selected (bitwise).

pOuterUnknown
    pointer to the IUnknown interface of the containing object.

ppMSPCall
    Returned MSP call that the MSP fills on on success.
    
Return Value:

    S_OK
    E_OUTOFMEMORY
    E_POINTER
    TAPI_E_INVALIDMEDIATYPE


--*/
{
    LOG((MSP_TRACE, 
        "CreateMSPCall entered. htCall:%x, dwMediaType:%x, ppMSPCall:%x",
        htCall, dwMediaType, ppMSPCall
        ));

    CH323MSPCall * pMSPCall = NULL;

    // This function does all the parameter checkings.
    HRESULT hr = ::CreateMSPCallHelper(
        this, 
        htCall, 
        dwReserved, 
        dwMediaType, 
        pOuterUnknown, 
        ppMSPCall,
        &pMSPCall
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPCallHelper failed:%x", hr));
        return hr;
    }

    return hr;
}

STDMETHODIMP CH323MSP::ShutdownMSPCall(
    IN      IUnknown *   pUnknown
    )
/*++

Routine Description:

This method is called by TAPI3 to shutdown a MSPCall. It calls the helper
function defined in MSPAddress to to the real job.

Arguments:

pUnknown
    pointer to the IUnknown interface of the contained object. It is a
    CComAggObject that contains our call object.
    
Return Value:

    S_OK
    E_POINTER
    TAPI_E_INVALIDMEDIATYPE


--*/
{
    LOG((MSP_TRACE, "ShutDownMSPCall entered. pUnknown:%x", pUnknown));

    if (IsBadReadPtr(pUnknown, sizeof(VOID *) * 3))
    {
        LOG((MSP_ERROR, "ERROR:pUnknow is a bad pointer"));
        return E_POINTER;
    }

    
    CH323MSPCall * pMSPCall = NULL;
    HRESULT hr = ::ShutdownMSPCallHelper(pUnknown, &pMSPCall);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "ShutDownMSPCallhelper failed:: %x", hr));
        return hr;
    }

    return hr;
}

DWORD CH323MSP::GetCallMediaTypes(void)
{
    return H323CALLMEDIATYPES;
}

ULONG CH323MSP::MSPAddressAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CH323MSP::MSPAddressRelease(void)
{
    return MSPReleaseHelper(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323addr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    H323addr.h

Abstract:

    Declaration of the CH323MSP

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __CONFADDR_H_
#define __CONFADDR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

const DWORD H323CALLMEDIATYPES = (TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO);

/////////////////////////////////////////////////////////////////////////////
// CH323MSP
/////////////////////////////////////////////////////////////////////////////
class CH323MSP : 
    public CMSPAddress,
    public CComCoClass<CH323MSP, &CLSID_H323MSP>,
    public CMSPObjectSafetyImpl
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_H323MSP)
DECLARE_POLY_AGGREGATABLE(CH323MSP)

BEGIN_COM_MAP(CH323MSP)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPAddress)
END_COM_MAP()


public:
    STDMETHOD (CreateTerminal) (
        IN      BSTR                pTerminalClass,
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        OUT     ITTerminal **       ppTerminal
        );

    STDMETHOD (CreateMSPCall) (
        IN      MSP_HANDLE          htCall,
        IN      DWORD               dwReserved,
        IN      DWORD               dwMediaType,
        IN      IUnknown *          pOuterUnknown,
        OUT     IUnknown **         ppMSPCall
        );

    STDMETHOD (ShutdownMSPCall) (
        IN      IUnknown *          pMSPCall
        );

    ULONG MSPAddressAddRef(void);

    ULONG MSPAddressRelease(void);

protected:

    DWORD GetCallMediaTypes(void);
};

#endif //__CONFADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323aud.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confaud.h

Abstract:

    Definitions for audio streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFAUD_H_
#define __CONFAUD_H_

#include <amrtpss.h>

const DWORD g_dwAudioThreadPriority         = THREAD_PRIORITY_TIME_CRITICAL;
const DWORD g_dwAudioChannels               = 1;  
const DWORD g_wAudioCaptureBitPerSample     = 16;  
const DWORD g_dwAudioSampleRate             = 8000;  
const DWORD g_dwAudioCaptureNumBufffers     = 32;  
const DWORD g_dwRTPHeaderSize               = 12;
 
const DWORD g_dwG723BytesPerFrame           = 24;
const DWORD g_dwG723_DATARATE               = 16000; // bit per second.
const DWORD g_dwMilliSecondPerFrame         = 30;

inline DWORD AudioCaptureBufferSize(DWORD dwMillisecondPerPacket)
{
    return dwMillisecondPerPacket * (g_dwAudioSampleRate / 1000) 
        * (g_wAudioCaptureBitPerSample / 8);
}

inline DWORD G723PacketSize(DWORD dwMillisecondPerPacket)
{
    return dwMillisecondPerPacket / g_dwMilliSecondPerFrame 
        * g_dwG723BytesPerFrame + g_dwRTPHeaderSize;
}

inline DWORD G711PacketSize(DWORD dwMillisecondPerPacket)
{
    return dwMillisecondPerPacket * (g_dwAudioSampleRate / 1000) 
        + g_dwRTPHeaderSize;
}

class CStreamAudioRecv : public CH323MSPStream
{
public:
    CStreamAudioRecv();

    HRESULT Configure(
        IN      HANDLE              htChannel,
        IN      STREAMSETTINGS &    StreamSettings
        );

protected:
    HRESULT SetUpFilters();

    HRESULT ConfigureRTPFilter(
        IN      IBaseFilter *       pIBaseFilter
        );

    HRESULT SetUpInternalFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );
};

class CStreamAudioSend : public CH323MSPStream
{
public:
    CStreamAudioSend();

    virtual HRESULT Configure(
        IN  HANDLE          htChannel,
        IN  STREAMSETTINGS &StreamSettings
        );

protected:

    HRESULT SetUpFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pPin
        );

    HRESULT ConfigureRTPFilter(
        IN  IBaseFilter *   pIBaseFilter
        );

    HRESULT ConfigureAudioCaptureTerminal(
        IN   ITTerminalControl *    pTerminal,
        OUT  IPin **                ppIPin
        );

    HRESULT ProcessAGCEvent(
        IN  AGC_EVENT   Event,
        IN  long        lPercent
        );

    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  long lParam1,
        IN  long lParam2
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323aud.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    H323aud.cpp

Abstract:

    This module contains implementation of the audio send and receive
    stream implementations.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"
#include "common.h"

#include <initguid.h>
#include <amrtpnet.h>   // rtp guilds
#include <amrtpdmx.h>   // demux guild
#include <amrtpuid.h>   // AMRTP media types
#include <amrtpss.h>    // for silence suppression filter
#include <irtprph.h>    // for IRTPRPHFilter
#include <irtpsph.h>    // for IRTPSPHFilter
#include <mixflter.h>   // audio mixer
#include <g711uids.h>   // for G711 codec CLSID
#include <g723uids.h>   // for G723 codec CLSID


/////////////////////////////////////////////////////////////////////////////
//
//  Private functions
//
/////////////////////////////////////////////////////////////////////////////

DWORD AudioBitRate(
    IN  DWORD     dwPayloadType,
    IN  AUDIOSETTINGS * pAudioSettings
    )
/*++

Routine Description:

    Calculate the bit rate based on the audio settings.

Arguments:
    
    dwPayLoadType - the RTP paylaod type.

    pAudioSettings - the setting of the audio stream.

Return Value:

    >=0 the bit rate needed.
    -1 don't know the bit rate.

--*/
{
    const DWORD HEADER_OVERHEAD = 28; // in bytes, UDP + IP headers

    DWORD dwBitRate = -1;

    switch (dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        dwBitRate = (HEADER_OVERHEAD + 
            G711PacketSize(pAudioSettings->dwMillisecondsPerPacket)) * 8
            * 1000 / pAudioSettings->dwMillisecondsPerPacket;

        // adjust by three percent to make qos happy.
        dwBitRate = dwBitRate * 103 / 100;
        break;

    case PAYLOAD_G723:
        dwBitRate = (HEADER_OVERHEAD + 
            G723PacketSize(pAudioSettings->dwMillisecondsPerPacket)) * 8 
            * 1000 / pAudioSettings->dwMillisecondsPerPacket;

        // adjust by three percent to make qos happy.
        dwBitRate = dwBitRate * 103 / 100;
        break;
    }

    return dwBitRate;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamAudioRecv
//
/////////////////////////////////////////////////////////////////////////////

CStreamAudioRecv::CStreamAudioRecv()
    : CH323MSPStream()
{
      m_szName = L"AudioRecv";
}

HRESULT CStreamAudioRecv::Configure(
    IN HANDLE          htChannel,
    IN STREAMSETTINGS &StreamSettings
    )
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv Configure entered."));

    CLock lock(m_lock);

    _ASSERTE(m_fIsConfigured == FALSE);

    switch (StreamSettings.dwPayloadType)
    {
    case PAYLOAD_G711U:
        
        // The mixer can convert them, no codec needed.
        m_pClsidCodecFilter  = &GUID_NULL;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_G711U; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHAUD;

        break;

    case PAYLOAD_G711A:
        
        m_pClsidCodecFilter  = &CLSID_G711Codec;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_G711A; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHAUD;
        
        break;

    case PAYLOAD_G723:
        m_pClsidCodecFilter  = &CLSID_IntelG723Codec;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_G723; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHAUD;
        break;

    default:
        LOG((MSP_ERROR, "unknown payload type, %x", StreamSettings.dwPayloadType));
        return E_FAIL;
    }
    
    m_Settings      = StreamSettings;
    m_htChannel     = htChannel;
    m_fIsConfigured = TRUE;

    InternalConfigure();

    return S_OK;
}

HRESULT CStreamAudioRecv::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clcokrate, etc.

Arguments:
    
    pIBaseFilter - The source RTP Filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv ConfigureRTPFilter"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    // select the local interface that the RTP should be using.

    LOG((MSP_INFO, "set locol Address:%x", m_Settings.dwIPLocal));

    // Set the local address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SelectLocalIPAddress(
        htonl(m_Settings.dwIPLocal)
        )))
    {
        LOG((MSP_ERROR, "set locol Address, hr:%x", hr));
        return hr;
    }

    LOG((MSP_INFO, "set remote Address:%x, port:%d, local port:%d", 
        m_Settings.dwIPRemote, 0, m_Settings.wRTPPortLocal));

    // Set the remote address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SetAddress(
        htons(m_Settings.wRTPPortLocal),    // local port.
        0,                                  // remote port.
        htonl(m_Settings.dwIPRemote)        // remote address.
        )))
    {
        LOG((MSP_ERROR, "set remote Address, hr:%x", hr));
        return hr;
    }

    // Get the IRTCPStream interface pointer.
    CComQIPtr<IRTCPStream, 
        &IID_IRTCPStream> pIRTCPStream(pIBaseFilter);
    if (pIRTCPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTCP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set remote RTCP Address:%x, port:%d, local port:%d", 
            m_Settings.dwIPRemote, m_Settings.wRTCPPortRemote, 
            m_Settings.wRTCPPortLocal));

    // Set the remote RTCP address and port.
    if (FAILED(hr = pIRTCPStream->SetRTCPAddress(
        htons(m_Settings.wRTCPPortLocal), 
        htons(m_Settings.wRTCPPortRemote),
        htonl(m_Settings.dwIPRemote)
        )))
    {
        LOG((MSP_ERROR, "set remote RTCP Address, hr:%x", hr));
        return hr;
    }
    
    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastScope(DEFAULT_TTL)))
    {
        LOG((MSP_ERROR, "set TTL. %x", hr));
        return hr;
    }

    // Set the priority of the session
    if (FAILED(hr = pIRTPStream->SetSessionClassPriority(
        RTP_CLASS_AUDIO,
        g_dwAudioThreadPriority
        )))
    {
        LOG((MSP_WARN, "set session class and priority. %x", hr));
    }

    // Set the sample rate of the session
    LOG((MSP_INFO, "setting session sample rate to %d", g_dwAudioSampleRate));
    
    if (FAILED(hr = pIRTPStream->SetDataClock(g_dwAudioSampleRate)))
    {
        LOG((MSP_WARN, "set session sample rate. %x", hr));
    }

    // Enable the RTCP events
    if (FAILED(hr = ::EnableRTCPEvents(pIBaseFilter)))
    {
        LOG((MSP_WARN, "can not enable RTCP events %x", hr));
    }

    DWORD dwBitRate = AudioBitRate(
        m_Settings.dwPayloadType, 
        &m_Settings.Audio
        );

    if (FAILED(hr = ::SetQOSOption(
        pIBaseFilter,
        m_Settings.dwPayloadType,       // payload
        dwBitRate,
        TRUE
        )))
    {
        LOG((MSP_ERROR, "set QOS option. %x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamAudioRecv::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the mixer to the audio render terminal.

Arguments:
    
    pITTerminal - The terminal to be connected.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv.ConnectTerminal, pITTerminal %p", pITTerminal));

    HRESULT hr;

    // if our filters have not been contructed, do it now.
    if (m_pEdgeFilter == NULL)
    {
        hr = SetUpInternalFilters();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
            
            CleanUpFilters();

            return hr;
        }
    }

    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);
        
        return E_NOINTERFACE;
    }

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    // Get the pins.
    hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        return hr;
    }

    // the pin count should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    // Connect the mixer filter to the audio render terminal.
    hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)m_pEdgeFilter, 
        (IPin *)Pins[0]
        );

    // release the refcounts on the pins.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "connect to the mixer filter. %x", hr));

        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return hr;
    }
    
    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamAudioRecv::SetUpInternalFilters()
/*++

Routine Description:

    set up the filters used in the stream.

    RTP->Demux->RPH(->DECODER)->Mixer

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv.SetUpInternalFilters"));

    CComPtr<IBaseFilter> pSourceFilter;

    HRESULT hr;

    // create and add the source fitler.
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_RTPSourceFilter, 
            L"RtpSource", 
            &pSourceFilter)))
    {
        LOG((MSP_ERROR, "adding source filter. %x", hr));
        return hr;
    }

    if (FAILED(hr = ConfigureRTPFilter(pSourceFilter)))
    {
        LOG((MSP_ERROR, "configure RTP source filter. %x", hr));
        return hr;
    }

    // Create and add the payload handler into the filtergraph.
    CComPtr<IBaseFilter> pIRPHFilter;

    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidPHFilter, 
        L"RPH", 
        &pIRPHFilter
        )))
    {
        LOG((MSP_ERROR, "add RPH filter. %x", hr));
        return hr;
    }

    // Get the IRTPRPHFilter interface.
    CComQIPtr<IRTPRPHFilter, &IID_IRTPRPHFilter>pIRTPRPHFilter(pIRPHFilter);
    if (pIRTPRPHFilter == NULL)
    {
        LOG((MSP_ERROR, "get IRTPRPHFilter interface"));
        return hr;
    }

    DWORD dwBufferSize = 0;
    switch (m_Settings.dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        dwBufferSize = G711PacketSize(
            m_Settings.Audio.dwMillisecondsPerPacket
            );        

        break;

    case PAYLOAD_G723:
        dwBufferSize = G723PacketSize(
            m_Settings.Audio.dwMillisecondsPerPacket
            );        
        break;
    }

    // set the media buffer size so that the receive buffers are of the
    // right size. 
    if (FAILED(hr = pIRTPRPHFilter->SetMediaBufferSize(        
        dwBufferSize
        )))
    {
        LOG((MSP_ERROR, "Set media buffer size. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "Set RPH media buffer size to %d", dwBufferSize));
        
    if (FAILED(hr = pIRTPRPHFilter->OverridePayloadType(
        (BYTE)m_Settings.dwPayloadType
        )))
    {
        LOG((LOG_ERROR, "override payload type. %x", hr));
        return FALSE;
    }

#ifdef USEDEMUX
    // Connect the payload handler to the output pin on the demux.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IPin *)pIPinOutput, 
        (IBaseFilter *)pIRPHFilter
        )))
    {
        LOG((MSP_ERROR, "connect demux and RPH filter. %x", hr));
        return hr;
    }
#else
    // Connect the payload handler to the network filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pSourceFilter, 
        (IBaseFilter *)pIRPHFilter
        )))
    {
        LOG((MSP_ERROR, "connect network and RPH filter. %x", hr));
        return hr;
    }
#endif

    CComPtr<IBaseFilter> pIFilter;

    // connect the codec filter if it is needed.
    if (*m_pClsidCodecFilter != GUID_NULL)
    {

        if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            *m_pClsidCodecFilter, 
            L"codec", 
            &pIFilter
            )))
        {
            LOG((MSP_ERROR, "add Codec filter. %x", hr));
            return hr;
        }

        if (*m_pClsidCodecFilter == CLSID_IntelG723Codec)
        {
            IG723CodecLicense *pCodecLicense;
            if (SUCCEEDED(hr = pIFilter->QueryInterface(
                IID_IG723CodecLicense,
                (void **)&pCodecLicense
                )))
            {
                pCodecLicense->put_LicenseKey(G723KEY_PSword0, G723KEY_PSword1);
                pCodecLicense->Release();
            }
        }

        // Connect the decoder and the payload handler.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IBaseFilter *)pIRPHFilter, 
            (IBaseFilter *)pIFilter
            )))
        {
            LOG((MSP_ERROR, "connect RPH filter and codec. %x", hr));
            return hr;
        }
    }
    else 
    {
        pIFilter = pIRPHFilter;
    }

    // Create and add the mixer filter into the filtergraph.
    CComPtr<IBaseFilter> pIMixerFilter;

    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        CLSID_AudioMixFilter, 
        L"Mixer", 
        &pIMixerFilter
        )))
    {
        LOG((MSP_ERROR, "add Mixer filter. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "Added Mixer filter"));

    // Connect the payload handler or the codec filter to the mixer filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pIFilter, 
        (IBaseFilter *)pIMixerFilter
        )))
    {
        LOG((MSP_ERROR, "connect to the mixer filter. %x", hr));
        return hr;
    }

    // if every thing went well, keep a reference to the last filter so that
    // the change of terminal will not require a recreating of all the filters.
    if (SUCCEEDED(hr))
    {
        m_pEdgeFilter = pIMixerFilter;
        m_pEdgeFilter->AddRef();
    }

    return hr;
}

HRESULT CStreamAudioRecv::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv SetupFilters entered."));
    HRESULT hr;

    // we only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    // Connect the mixer to the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect to terminal failed. %x", hr));

        return hr;
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
//  CStreamAudioSend
//
/////////////////////////////////////////////////////////////////////////////

CStreamAudioSend::CStreamAudioSend()
    : CH323MSPStream()
{
      m_szName = L"AudioSend";
}

HRESULT CStreamAudioSend::Configure(
    IN HANDLE          htChannel,
    IN STREAMSETTINGS &StreamSettings
    )
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend Configure entered."));

    CLock lock(m_lock);

    _ASSERTE(m_fIsConfigured == FALSE);

    switch (StreamSettings.dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        
        m_pClsidCodecFilter  = &CLSID_G711Codec;
        m_pClsidPHFilter     = &CLSID_INTEL_SPHAUD;

        break;

    case PAYLOAD_G723:
        m_pClsidCodecFilter  = &CLSID_IntelG723Codec;
        m_pClsidPHFilter     = &CLSID_INTEL_SPHAUD;
        break;

    default:
        LOG((MSP_ERROR, 
            "unknow payload type, %x", StreamSettings.dwPayloadType));
        return E_FAIL;
    }
    
    m_Settings      = StreamSettings;
    m_htChannel     = htChannel;
    m_fIsConfigured = TRUE;

    InternalConfigure();

    return S_OK;
}

HRESULT CStreamAudioSend::ConfigureAudioCaptureTerminal(
    IN      ITTerminalControl *     pTerminal,
    OUT     IPin **                 ppIPin
    )
/*++

Routine Description:

    Configure the audio capture terminal. This function gets a output pin from
    the capture terminal and the configure the audio format and media type.

Arguments:
    
    pTerminal - An audio capture terminal.

    ppIPin - the address to hold the returned pointer to IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "AudioSend configure audio capture terminal."));

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    // Get the pins from the first terminal because we only use on terminal
    // on this stream.
    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    // The number of pins should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));
        return E_UNEXPECTED;
    }

    // Save the first pin and release the others.
    CComPtr <IPin> pIPin = Pins[0];
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    // Set the format of the audio to 8KHZ, 16Bit/Sample, MONO.
    hr = ::SetAudioFormat(
        pIPin, 
        g_wAudioCaptureBitPerSample, 
        g_dwAudioSampleRate
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't set audio format, %x", hr));
        return hr;
    }

    // Set the capture buffer size.
    hr = ::SetAudioBufferSize(
        pIPin, 
        g_dwAudioCaptureNumBufffers, 
        AudioCaptureBufferSize(m_Settings.Audio.dwMillisecondsPerPacket)
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't set aduio capture buffer size, %x", hr));
        return hr;
    }

    pIPin->AddRef();
    *ppIPin = pIPin;

    return hr;
}

HRESULT CStreamAudioSend::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the audio capture terminal to the stream.

Arguments:

    pITTerminal - The terminal to be connected.
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend ConnectTerminal, pITTerminal %p", pITTerminal));

    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));
        
        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);

        return E_NOINTERFACE;
    }

    // configure the terminal.
    CComPtr<IPin>   pIPin;
    HRESULT hr = ConfigureAudioCaptureTerminal(pTerminal, &pIPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "configure audio capture terminal failed. %x", hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        return hr;
    }

    // Create other filters to be use in the stream.
    hr = CreateSendFilters(pIPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create audio send filters failed. %x", hr));

        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        // clean up internal filters as well.
        CleanUpFilters();

        return hr;
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamAudioSend::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend SetUpFilters"));

    // we only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr;

    // Connect the terminal to the rest of the stream.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect the terminal to the filters. %x", hr));

        return hr;
    }
    return hr;
}

HRESULT CStreamAudioSend::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clcokrate, etc.

Arguments:
    
    pIBaseFilter - The source RTP Filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend ConfigureRTPFilter"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get IRTPStream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set locol Address:%x", m_Settings.dwIPLocal));

    // Set the local address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SelectLocalIPAddress(
        htonl(m_Settings.dwIPLocal)
        )))
    {
        LOG((MSP_ERROR, "set locol Address, hr:%x", hr));
        return hr;
    }

    LOG((MSP_INFO, "set remote Address:%x, port:%d", 
        m_Settings.dwIPRemote, m_Settings.wRTPPortRemote));

    // Set the remote address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SetAddress(
        0,                                  // local port.
        htons(m_Settings.wRTPPortRemote),   // remote port.
        htonl(m_Settings.dwIPRemote)        // remote IP.
        )))
    {
        LOG((MSP_ERROR, "set remote Address, hr:%x", hr));
        return hr;
    }

    // Get the IRTCPStream interface pointer.
    CComQIPtr<IRTCPStream, 
        &IID_IRTCPStream> pIRTCPStream(pIBaseFilter);
    if (pIRTCPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTCP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set remote RTCP Address:%x, port:%d, local port:%d", 
            m_Settings.dwIPRemote, m_Settings.wRTCPPortRemote, 
            m_Settings.wRTCPPortLocal));

    // Set the remote RTCP address and port.
    if (FAILED(hr = pIRTCPStream->SetRTCPAddress(
        htons(m_Settings.wRTCPPortLocal), 
        htons(m_Settings.wRTCPPortRemote), 
        htonl(m_Settings.dwIPRemote)
        )))
    {
        LOG((MSP_ERROR, "set remote RTCP Address, hr:%x", hr));
        return hr;
    }

    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastScope(DEFAULT_TTL)))
    {
        LOG((MSP_ERROR, "set TTL. %x", hr));
        return hr;
    }

    // Set the priority of the session
    if (FAILED(hr = pIRTPStream->SetSessionClassPriority(
        RTP_CLASS_AUDIO,
        g_dwAudioThreadPriority
        )))
    {
        LOG((MSP_WARN, "set session class and priority. %x", hr));
    }

    // Set the sample rate of the session
    LOG((MSP_INFO, "setting session sample rate to %d", g_dwAudioSampleRate));
    
    if (FAILED(hr = pIRTPStream->SetDataClock(g_dwAudioSampleRate)))
    {
        LOG((MSP_WARN, "set session sample rate. %x", hr));
    }

    // Enable the RTCP events
    if (FAILED(hr = ::EnableRTCPEvents(pIBaseFilter)))
    {
        LOG((MSP_WARN, "can not enable RTCP events %x", hr));
    }

    DWORD dwBitRate = AudioBitRate(
        m_Settings.dwPayloadType, 
        &m_Settings.Audio
        );

    if (FAILED(hr = ::SetQOSOption(
        pIBaseFilter,
        m_Settings.dwPayloadType,       // payload
        dwBitRate,
        FALSE
        )))
    {
        LOG((MSP_ERROR, "set QOS option. %x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamAudioSend::CreateSendFilters(
    IN    IPin          *pPin
    )
/*++

Routine Description:

    Insert filters into the graph and connect to the capture pin.

    Capturepin->SilenceSuppressor->Encoder->SPH->RTPRender

Arguments:
    
    pPin - The output pin on the capture filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend.CreateSendFilters"));

    HRESULT hr;

    // if the the internal filters have been created before, just
    // connect the terminal to the first filter in the chain.
    if (m_pEdgeFilter != NULL)
    {
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            pPin, 
            (IBaseFilter *)m_pEdgeFilter
            )))
        {
            LOG((MSP_ERROR, "connect capture and ss %x", hr));
            return hr;
        }
        return hr;
    }

    DWORD dwSilenceSuppression = 1;
    GetRegValue(L"SilenceSuppression", &dwSilenceSuppression);

    CComPtr<IBaseFilter> pISSFilter;

    if (dwSilenceSuppression)
    {

        // Create the silence suppression filter and add it into the graph. 
        // The filter is optional.

        if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_SilenceSuppressionFilter, 
            L"SS", 
            &pISSFilter
            )))
        {
            LOG((MSP_ERROR, "can't add SS filter, %x", hr));
            return hr;
        }

        // connect the capture pin with the SS filter.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            pPin, 
            (IBaseFilter *)pISSFilter
            )))
        {
            LOG((MSP_ERROR, "connect capture and ss %x", hr));
            return hr;
        }

        // enable AGC events.
        DWORD dwAGC = 0;
        if (FALSE == ::GetRegValue(L"AGC", &dwAGC) || dwAGC != 0)
        {
            // AGC is not disabled, just do it.
            CComQIPtr<ISilenceSuppressor, &IID_ISilenceSuppressor> 
                pISilcnecSuppressor(pISSFilter);
            if (pISilcnecSuppressor != NULL)
            {
                hr = pISilcnecSuppressor->EnableEvents(
                    (1 << AGC_INCREASE_GAIN) | (1 << AGC_DECREASE_GAIN),
                    2000       // no more that an event every two seconds.
                    );

                if (FAILED(hr))
                {
                    LOG((MSP_WARN, "can't enable AGC events, %x", hr));
                }
            }
        }
    }

    // Create the codec filter and add it into the graph.
    CComPtr<IBaseFilter> pICodecFilter;

    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            *m_pClsidCodecFilter, 
            L"Encoder", 
            &pICodecFilter)))
    {
        LOG((MSP_ERROR, "add Codec filter. %x", hr));
        return hr;
    }

    if (*m_pClsidCodecFilter == CLSID_IntelG723Codec)
    {
        IG723CodecLicense *pCodecLicense;
        if (SUCCEEDED(hr = pICodecFilter->QueryInterface(
            IID_IG723CodecLicense,
            (void **)&pCodecLicense
            )))
        {
            pCodecLicense->put_LicenseKey(G723KEY_PSword0, G723KEY_PSword1);
            pCodecLicense->Release();
        }
    }

    if (dwSilenceSuppression)
    {
        // connect the SS filter and the Codec filter.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IBaseFilter *)pISSFilter, 
            (IBaseFilter *)pICodecFilter
            )))
        {
            LOG((MSP_ERROR, "connect ss filter and codec filter. %x", hr));
            return hr;
        }
    }
    else
    {
        // connect the pin and the Codec filter.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            pPin, 
            (IBaseFilter *)pICodecFilter
            )))
        {
            LOG((MSP_ERROR, "connect capture output pin and codec filter. %x", hr));
            return hr;
        }
    }

    // Create the send payload handler and add it into the graph.
    CComPtr<IBaseFilter> pISPHFilter;
    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidPHFilter, 
        L"SPH", 
        &pISPHFilter
        )))
    {
        LOG((MSP_ERROR, "add SPH filter. %x", hr));
        return hr;
    }

    // Get the IRTPSPHFilter interface.
    CComQIPtr<IRTPSPHFilter, 
        &IID_IRTPSPHFilter> pIRTPSPHFilter(pISPHFilter);
    if (pIRTPSPHFilter == NULL)
    {
        LOG((MSP_ERROR, "get IRTPSPHFilter interface"));
        return E_NOINTERFACE;
    }

    DWORD dwBufferSize = 0;
    switch (m_Settings.dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        dwBufferSize = G711PacketSize(
            m_Settings.Audio.dwMillisecondsPerPacket
            );        

        break;

    case PAYLOAD_G723:
        dwBufferSize = G723PacketSize(
            m_Settings.Audio.dwMillisecondsPerPacket
            );        
        break;
    }

    // Set the packetSize.
    if (FAILED(hr= pIRTPSPHFilter->SetMaxPacketSize(dwBufferSize)))
    {
        LOG((MSP_ERROR, "set SPH filter Max packet size: %d hr: %x", 
            dwBufferSize, hr));
        return hr;
    }

    if (FAILED(hr = pIRTPSPHFilter->OverridePayloadType(
        (BYTE)m_Settings.dwPayloadType
        )))
    {
        LOG((LOG_ERROR, "Set SPH payload type. %x", hr));
        return hr;
    }

    // Connect the Codec filter with the SPH filter .
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pICodecFilter, 
        (IBaseFilter *)pISPHFilter
        )))
    {
        LOG((MSP_ERROR, "connect codec filter and SPH filter. %x", hr));
        return hr;
    }

    // Create the RTP render filter and add it into the graph.
    CComPtr<IBaseFilter> pRenderFilter;

    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_RTPRenderFilter, 
            L"RtpRender", 
            &pRenderFilter)))
    {
        LOG((MSP_ERROR, "adding render filter. %x", hr));
        return hr;
    }

    // Set the address for the render fitler.
    if (FAILED(hr = ConfigureRTPFilter(pRenderFilter)))
    {
        LOG((MSP_ERROR, "set destination address. %x", hr));
        return hr;
    }

    // Connect the SPH filter with the RTP Render filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pISPHFilter, 
        (IBaseFilter *)pRenderFilter
        )))
    {
        LOG((MSP_ERROR, "connect SPH filter and Render filter. %x", hr));
        return hr;
    }

    // remember the first filter after the terminal 
    if (dwSilenceSuppression)
    {
        m_pEdgeFilter = pISSFilter;
    }
    else
    {
        m_pEdgeFilter = pICodecFilter;
    }
    m_pEdgeFilter->AddRef();

    return S_OK;
}

HRESULT AdjustGain(
    IN  IUnknown *  pIUnknown,
    IN  long        lPercent
    )
/*++

Routine Description:

    This function uses IAMAudioInputMixer interface to adjust the gain.

Arguments:

    pIUnknown - the object that supports IAMAudioInputMixer

    lPercent - the adjustment, a negative value means decrease.

Return Value:

    S_OK,
    E_NOINTERFACE,
    E_UNEXPECTED

--*/
{
    CComPtr <IAMAudioInputMixer> pMixer;
    HRESULT hr = pIUnknown->QueryInterface(
        IID_IAMAudioInputMixer, (void **)&pMixer
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get IAMAudioInputMixer interface."));
        return hr;
    }
    
    BOOL fEnabled;
    hr = pMixer->get_Enable(&fEnabled);
    if (SUCCEEDED(hr) && !fEnabled)
    {
        return S_OK;
    }

    double MixLevel;
    hr = pMixer->get_MixLevel(&MixLevel);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get_MixLevel returned %d", hr));
        return hr;
    }

    LOG((MSP_INFO, "get_MixLevel returned %d", hr));
    MixLevel = MixLevel * (100 + lPercent) / 100;

    hr = pMixer->put_MixLevel(MixLevel);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "put_MixLevel returned %d", hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamAudioSend::ProcessAGCEvent(
    IN  AGC_EVENT   Event,
    IN  long        lPercent
    )
/*++

Routine Description:

    The filters fire AGC events to requste a change in the microphone gain.
    This function finds the capture terminal and adjust the gain on it.

Arguments:

    Event - either AGC_INCREASE_GAIN or AGC_DECREASE_GAIN.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "ProcessAGCEvent %s %d percent", 
        (Event == AGC_INCREASE_GAIN) ? "Increase" : "Decrease",
        lPercent
        ));

    _ASSERTE(lPercent > 0 && lPercent <= 100);

    CLock lock(m_lock);
    if (m_pEdgeFilter == NULL)
    {
        LOG((MSP_ERROR, "No filter to adjust gain."));
        return E_UNEXPECTED;
    }

    CComPtr<IPin> pMyPin, pCapturePin;

    // find the first pin in the stream
    HRESULT hr = ::FindPin(m_pEdgeFilter, &pMyPin, PINDIR_INPUT, FALSE);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get find the first pin the stream, %x", hr));
        return hr;
    }

    // find the capture pin that connects to our first pin.
    hr = pMyPin->ConnectedTo(&pCapturePin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't find the capture pin, %x", hr));
        return hr;
    }

    // find the filter that has the capture pin.
    PIN_INFO PinInfo;
    hr = pCapturePin->QueryPinInfo(&PinInfo);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't find the capture filter, %x", hr));
        return hr;
    }

    // save the filter pointer.
    CComPtr<IBaseFilter> pICaptureFilter = PinInfo.pFilter;
    PinInfo.pFilter->Release();

    // get the amount to adjust.
    if (Event == AGC_DECREASE_GAIN)
    {
        lPercent = -lPercent;
    }

    AdjustGain(pICaptureFilter, lPercent);

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pICaptureFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    // Enumerate all the pins and adjust gains on each active one.
    for (;;)
    {
        CComPtr<IPin> pIPin;
        DWORD dwFeched;
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            LOG((MSP_ERROR, "find pin on filter."));
            break;
        }
        
        AdjustGain(pIPin, lPercent);
    }
    
    return hr;
}


HRESULT CStreamAudioSend::ProcessGraphEvent(
    IN  long lEventCode,
    IN  long lParam1,
    IN  long lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d", m_szName, lEventCode));

    switch (lEventCode)
    {
    case AGC_EVENTBASE + AGC_INCREASE_GAIN:
        
        ProcessAGCEvent(AGC_INCREASE_GAIN, lParam1);

        break;

    case AGC_EVENTBASE + AGC_DECREASE_GAIN:

        ProcessAGCEvent(AGC_DECREASE_GAIN, lParam1);

        break;

    default:
        return CH323MSPStream::ProcessGraphEvent(
            lEventCode, lParam1, lParam2
            );
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323call.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    H323call.h

Abstract:

    Declaration of the CH323MSPCall

Author:
    
    Mu Han (muhan) 5-September-1998

--*/

#ifndef __CONFCALL_H_
#define __CONFCALL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <H323pdu.h>

/////////////////////////////////////////////////////////////////////////////
// CH323MSPCall
/////////////////////////////////////////////////////////////////////////////
class CH323MSPCall : 
    public CMSPCallMultiGraph,
    public CMSPObjectSafetyImpl
{

public:

BEGIN_COM_MAP(CH323MSPCall)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPCallMultiGraph)
END_COM_MAP()

    
    
    // ITStreamControl methods, called by the app.
    STDMETHOD (CreateStream) (
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN OUT  ITStream **         ppStream
        );
    
    STDMETHOD (RemoveStream) (
        IN      ITStream *          pStream
        );                      

// methods called by the MSPAddress object.
    virtual HRESULT Init(
        IN      CMSPAddress *       pMSPAddress,
        IN      MSP_HANDLE          htCall,
        IN      DWORD               dwReserved,
        IN      DWORD               dwMediaType
        );

    virtual HRESULT ReceiveTSPCallData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );
    
    HRESULT ShutDown();

// method called by the worker thread.
    static DWORD WINAPI WorkerCallbackDispatcher(VOID *pContext);

    DWORD ProcessWorkerCallBack(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

    HRESULT InternalShutDown();
    
    DWORD MSPCallAddRef()
    {
        return MSPAddRefHelper(this);
    }

    DWORD MSPCallRelease()
    {
        return MSPReleaseHelper(this);
    }

// method called by the stream.
    HRESULT SendTSPMessage(
        IN  H323MSP_MESSAGE_TYPE    Type,
        IN  ITStream    *           hmChannel,
        IN  HANDLE                  htChannel = NULL,
        IN  MEDIATYPE               MediaType = MEDIA_AUDIO,
        IN  DWORD                   dwReason = 0,
        IN  DWORD                   dwBitRate = 0
        ) const;

protected:
    virtual HRESULT CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        );

    void ProcessNewCallIndication(void);

    void ProcessOpenChannelResponse(
        IN  H323MSG_OPEN_CHANNEL_RESPONSE * pOpenChannelResponse
        );

    void ProcessAcceptChannelRequest(
        IN  H323MSG_ACCEPT_CHANNEL_REQUEST * pAcceptChannelRequest
        );

    void ProcessCloseChannelCommand(
        IN  H323MSG_CLOSE_CHANNEL_COMMAND * pCloseChannelCommand
        );

    void ProcessIFrameRequest(
        IN  H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND * pIFrameRequest
        );

    void ProcessFlowControlCommand(
        IN  H323MSG_FLOW_CONTROL_COMMAND * pFlowControlCommand
        );

private:
    HRESULT SendTAPIStreamEvent(
        IN  ITStream *              pITStream,
        IN  MSP_CALL_EVENT          Type,
        IN  MSP_CALL_EVENT_CAUSE    Cause
        );

private:
    BOOL            m_fCallConnected;
    BOOL            m_fShutDown;
};

typedef struct _CALLWORKITEM
{
    CH323MSPCall  *pCall;
    DWORD           dwLen;
    BYTE            Buffer[1];

} CALLWORKITEM, *PCALLWORKITEM;

#endif //__CONFCALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323msp.cpp ===
// H323.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f H323ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "H323msp.h"
#include "H323addr.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "H323msp_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_H323MSP, CH323MSP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        MSPLogRegister(_T("h323msp"));
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    { 
        _Module.Term();
        MSPLogDeRegister();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323strm.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    H323strm.cpp

Abstract:

    This module contains implementation of CMSPStream. The object represents
    one stream in the filter graph.

Author:

    Mu Han (muhan)   1-November-1997

--*/

#include "stdafx.h"
#include "common.h"
#include "rtp.h" // for RTP events.

/*  State Transition Table


States:

RO   - Running whithout terminal. This is the initial state.
PO   - Paused without terminal
SO   - Stopped without terminal.
RT   - Runing with terminal.
PT   - Paused with termianl.
ST   - Stopped with terminal.

Actions:
S   - Stop graph.
P   - Pause graph.
C   - Change graph.
D   - Disonnect terminals.
F   - Free extra references to filters and terminals.
R   - Run Graph.
NIU - Not in use.

Note: the same graph operation can be called multiple times, the graph
just returns S_OK if it is already in desired state.

NOTE: if the stream is not configured, the transition will happen without
really doing anything to the graph.

CONFIG will only be called for NC streams.

        CONFIG  Select  Unselect    Run     Pause   Stop    ShutDown

RO      OK      C/R     FAIL        OK      OK      OK      F
        RO       RT      RO         RO      PO      SO      -

PO      OK      C/P     FAIL        OK      OK      OK      F
        PO       PT      PO         RO      PO      SO      -

SO      OK      C       FAIL        OK      OK      OK      F
        SO       ST      SO         RO      PO      SO      -

RT      C/R     S/C/R   S/C/(R)     R       P       S       S/D/F
        RT       RT     RT,RO       RT      PT      ST      -

PT      C/P     S/C/P   S/C/(P)     R       P       S       S/D/F
        PT       PT     PT,PO       RT      PT      ST      -

ST      C       C       C           R       P       S       D/F
        ST       ST     ST,SO       RT      PT      ST      -

*/

CH323MSPStream::CH323MSPStream()
    : CMSPStream(),
      m_szName(NULL),
      m_pClsidPHFilter(NULL),
      m_pClsidCodecFilter(NULL),
      m_pRPHInputMinorType(NULL),
      m_fNeedsToOpenChannel(FALSE),
      m_fIsConfigured(FALSE),
      m_pEdgeFilter(NULL),
      m_htChannel(NULL)
{
    // The default state is always running.
    m_dwState   = STRM_RUNNING;
    ZeroMemory(&m_Settings, sizeof m_Settings);
}

#ifdef DEBUG_REFCOUNT
LONG g_lStreamObjects = 0;

ULONG CH323MSPStream::InternalAddRef()
{
    InterlockedIncrement(&g_lStreamObjects);
    
    ULONG lRef = CMSPStream::InternalAddRef();
    
    LOG((MSP_TRACE, "%ws Addref, ref = %d", m_szName, lRef));

    return lRef;
}

ULONG CH323MSPStream::InternalRelease()
{
    InterlockedDecrement(&g_lStreamObjects);

    ULONG lRef = CMSPStream::InternalRelease();
    
    LOG((MSP_TRACE, "%ws Release, ref = %d", m_szName, lRef));

    return lRef;
}
#endif

HANDLE CH323MSPStream::TSPChannel()
{
    CLock lock(m_lock);
    return m_htChannel;
}

BOOL CH323MSPStream::IsTerminalSelected()
{
    CLock lock(m_lock);
    return m_Terminals.GetSize() > 0;
}

BOOL CH323MSPStream::IsConfigured()
{
    CLock lock(m_lock);
    return m_fIsConfigured;
}

VOID CH323MSPStream::CallConnect()
{
    CLock lock(m_lock);
    m_fNeedsToOpenChannel = TRUE;
}

STDMETHODIMP CH323MSPStream::get_Name(
    OUT     BSTR *                  ppName
    )
/*++

Routine Description:

    Get the name of this stream.

Arguments:
    
    ppName  - the mem address to store a BSTR.

Return Value:

    HRESULT.


*/
{
    LOG((MSP_TRACE, "CIPH323MSPStream::get_Name - enter"));
    
    if (IsBadWritePtr(ppName, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CMSPStream::get_Name - exit E_POINTER"));
        return E_POINTER;
    }

    DWORD dwID;

    if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        if (m_Direction == TD_CAPTURE)
        {
            dwID = IDS_AUDIO_CAPTURE_STREAM;
        }
        else
        {
            dwID = IDS_AUDIO_RENDER_STREAM;
        }
    }
    else
    {
        if (m_Direction == TD_CAPTURE)
        {
            dwID = IDS_VIDEO_CAPTURE_STREAM;
        }
        else
        {
            dwID = IDS_VIDEO_RENDER_STREAM;
        }
    }

    const int   BUFSIZE = 1024;
    WCHAR       wszName[BUFSIZE];

    if (LoadStringW( 
            _Module.GetModuleInstance(),
            dwID,
            wszName,
            BUFSIZE - 1 ) == 0)
    {
        *ppName = NULL;

        LOG((MSP_ERROR, "CMSPStream::get_Name - "
            "LoadString failed - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Convert to a BSTR and return the BSTR.
    //

    BSTR pName = SysAllocString(wszName);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CMSPStream::get_Name - exit out of mem"));
        return E_OUTOFMEMORY;
    }

    *ppName = pName;

    return S_OK; 
}

HRESULT CH323MSPStream::SendStreamEvent(
    IN      MSP_CALL_EVENT          Event,
    IN      MSP_CALL_EVENT_CAUSE    Cause,
    IN      HRESULT                 hrError = 0,
    IN      ITTerminal *            pTerminal = NULL
    )
/*++

Routine Description:

    Send a stream event to the app.
*/
{
    CLock lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    ITStream *  pITStream;
    HRESULT hr = this->_InternalQueryInterface(
        IID_ITStream, 
        (void **)&pITStream
    );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "SendStreamEvent:QueryInterface failed: %x", hr));
        return hr;
    }

    MSPEVENTITEM* pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data, size: %d", sizeof(MSPEVENTITEM)));
        pITStream->Release();

        return E_OUTOFMEMORY;
    }
    
    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
    
    pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;
    
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type = Event;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause = Cause;
    
    // pITStream has a refcount becaust it was from QI.
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream = pITStream;

    // the terminal needs to be addrefed.
    if (pTerminal) pTerminal->AddRef();
    
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = pTerminal;

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError= hrError;

    hr = m_pMSPCall->HandleStreamEvent(pEventItem);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));
        
        pITStream->Release();
        FreeEventItem(pEventItem);

        return hr;
    }
    return S_OK;
}

HRESULT CH323MSPStream::CleanUpFilters()
/*++

Routine Description:

    remove all the filters in the graph.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CleanUpFilters for %ws %p", m_szName, this));
   
    if (m_pEdgeFilter)
    {
        m_pEdgeFilter->Release();
        m_pEdgeFilter = NULL;
    }

    for(;;)
    {
        // Because the enumerator is invalid after removing a filter from
        // the graph, we have to try to get all the filters in one shot.
        // If there are still more, we loop again.

        // Enumerate the filters in the graph.
        CComPtr<IEnumFilters>pEnum;
        HRESULT hr = m_pIGraphBuilder->EnumFilters(&pEnum);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "cleanup filters, enumfilters failed: %x", hr));
            return hr;
        }

        const DWORD MAXFILTERS = 40;
        IBaseFilter * Filters[MAXFILTERS];
        DWORD dwFetched = 0;
    
        hr = pEnum->Next(MAXFILTERS, Filters, &dwFetched);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get next filter failed: %x", hr));
            return hr;
        }

        for (DWORD i = 0; i< dwFetched; i ++)
        {
            m_pIGraphBuilder->RemoveFilter(Filters[i]);
            Filters[i]->Release();
        }

        if (hr != S_OK)
        {
            break;
        }
    }
    return S_OK;
}

HRESULT DisableGraphClock(
    IGraphBuilder *pIGraphBuilder
    )
{
    // Get the graph builder interface on the graph.
    IMediaFilter *pFilter;
    HRESULT hr = pIGraphBuilder->QueryInterface(
            IID_IMediaFilter, (void **) &pFilter);

    if(FAILED(hr))
    {
        LOG((MSP_ERROR, "get IFilter interface, %x", hr));
        return hr;
    }

    hr = pFilter->SetSyncSource(NULL);

    pFilter->Release();

    LOG((MSP_TRACE, "SetSyncSource returned, %x", hr));
    
    return hr;
}

HRESULT CH323MSPStream::InternalConfigure()
/*++

Routine Description:

    This method is called by the derived streams to handle the state
    transition needed for configure. It should be called after the
    stream finished configuring itself.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    _ASSERTE(m_fIsConfigured == TRUE);

    // Disable the graph clock to save us a thread. don't care the result.
//    DisableGraphClock(m_pIGraphBuilder);

    // if there is no terminal selected, just return.
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        return S_OK;
    }

    // set up the filters and the terminals.
    HRESULT hr = SetUpFilters();

    if (FAILED(hr))
    {
        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_CONNECT_FAIL, hr);

        LOG((MSP_ERROR, "stream %ws %p set up filters failed, %x", 
            m_szName, this, hr));
        return hr;
    }
    
    switch (m_dwState)
    {
    case STRM_RUNNING:
        // start the graph.
        hr = CMSPStream::StartStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
            return hr;
        }

        SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);

        LOG((MSP_INFO, "stream %ws %p started", m_szName, this));
        break;

    case STRM_PAUSED:
        // pause the graph.
        hr = CMSPStream::PauseStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
            return hr;
        }

        LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));
        break;

    case STRM_STOPPED:
        break;
    }

    LOG((MSP_INFO, "stream %ws %p configure exit S_OK", m_szName, this));

    return S_OK;
}

STDMETHODIMP CH323MSPStream::StartStream()
/*++

Routine Description:

    Start the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter Runing state. (RO)
        m_dwState = STRM_RUNNING; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter Runing state. (RO, RT)
        m_dwState = STRM_RUNNING; 

        return S_OK;
    }

    // Start the stream.
    HRESULT hr = CMSPStream::StartStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
        return hr;
    }

    SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);

    LOG((MSP_INFO, "stream %ws %p started", m_szName, this));

    // Enter Runing state.(RT)
    m_dwState = STRM_RUNNING;

    return S_OK;
}

STDMETHODIMP CH323MSPStream::PauseStream()
/*++

Routine Description:

    Pause the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter paused state. (PO)
        m_dwState = STRM_PAUSED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter paused state. (PO, PT)
        m_dwState = STRM_PAUSED; 
        
        return S_OK;
    }

    // Start the stream.
    HRESULT hr = CMSPStream::PauseStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
        return hr;
    }

    LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));

    // Enter paused state.(PT)
    m_dwState = STRM_PAUSED;

    return S_OK;
}

STDMETHODIMP CH323MSPStream::StopStream()
/*++

Routine Description:

    Stop the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter stopped state. (SO)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter stopped state. (SO, ST)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    // Stop the graph.
    HRESULT hr = CMSPStream::StopStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));
        return hr;
    }

    SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);

    LOG((MSP_INFO, "stream %ws %p stopped", m_szName, this));

    // Enter stopped state.(ST)
    m_dwState = STRM_STOPPED; 

    return S_OK;
}

HRESULT CH323MSPStream::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    The implementation in this class checks to see if the terminal
    is th right type and direction and it only allows on terminal per
    stream.

Arguments:
    
    pTerminal - the terminal object.

*/
{
    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (Direction != m_Direction)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // By default, only one terminal is supported per stream.
    if (m_Terminals.GetSize() > 0)
    {
        return TAPI_E_MAXTERMINALS;
    }

    return S_OK;
}

HRESULT CH323MSPStream::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    Select a terminal on the stream. The stream will start itself if it
    was in running state. See the state transition table at the beginning
    of this file.

Arguments:
    
    pTerminal - the terminal object.

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, "CMSPStream::SelectTerminal, %p", pTerminal));

    //
    // Check parameter.
    //
    if ( IsBadReadPtr(pTerminal, sizeof(ITTerminal) ) )
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal - exit E_POINTER"));

        return E_POINTER;
    }

    CLock lock(m_lock);

    // validate the terminal.
    HRESULT hr = CheckTerminalTypeAndDirection(pTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "wrong terminal. %x", hr));
        return hr;
    }

    // put the terminal into our list.
    hr = CMSPStream::SelectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal - failed, %x", hr));
        return hr;
    }

    // At this point, the select terminal opration succeeded. All the 
    // failure cases are handled by sending events after this.

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // if the call is connected, send an open channel request if the stream
        // is an outgoing stream.
        if ((m_Direction == TD_CAPTURE) && m_fNeedsToOpenChannel)
        {
            // Send an open Channel request for outgoing channels.
            ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
                H323MSP_OPEN_CHANNEL_REQUEST, 
                (ITStream *)this, 
                NULL,
                (m_dwMediaType == TAPIMEDIATYPE_AUDIO) ? MEDIA_AUDIO : MEDIA_VIDEO
                );

            m_fNeedsToOpenChannel = FALSE;
        }

        return S_OK;
    }

    // stop the graph before making changes.
    hr = CMSPStream::StopStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        return S_OK;
    }

    // connect the new terminal into the graph. 
    // this method will send events if the terminal failed.
    hr = ConnectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p connect to terminal failed, %x", 
            m_szName, this, hr));

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_CONNECT_FAIL, hr);

        return S_OK;
    }

    // after connecting the termanal, go back to the original state.
    switch  (m_dwState)
    {
    case STRM_RUNNING:

        // start the stream.
        hr = CMSPStream::StartStream();
        
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed, %x", m_szName, this, hr));
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            break;
        }
    
        SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        LOG((MSP_INFO, "stream %ws %p started", m_szName, this));

        break;

    case STRM_PAUSED:

        // pause the stream.
        hr = CMSPStream::PauseStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed, %x", m_szName, this, hr));
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        }
        LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));

        break;
    }

    return S_OK;
}

STDMETHODIMP CH323MSPStream::UnselectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

  Unselect a terminal from the stream. It handles changing the graph and
  going back to the original state.

Arguments:
    

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, 
        "CH323MSPStream::UnselectTerminal, pTerminal %p", pTerminal));

    CLock lock(m_lock);
    int index;

    if ((index = m_Terminals.Find(pTerminal)) < 0)
    {
        LOG((MSP_ERROR, "UnselectTerminal - exit TAPI_E_INVALIDTERMINAL"));
    
        return TAPI_E_INVALIDTERMINAL;
    }

    // if the stream is not configured, just remove it and return.
    if (!m_fIsConfigured)
    {
        if (!m_Terminals.RemoveAt(index))
        {
            LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
                "exit E_UNEXPECTED"));
    
            return E_UNEXPECTED;
        }

        // release the refcount that was in our list.
        pTerminal->Release();

        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));
        return S_OK;
    }

    // stop the graph before making changes.
    HRESULT hr = CMSPStream::StopStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));

        return hr;
    }

    SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
       
    // disconnect the terminal from the graph. 
    // this method will send events if the terminal failed.
    hr = DisconnectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p disconnectTerminal failed, %x", 
            m_szName, this, hr));

        return hr;
    }

    if (!m_Terminals.RemoveAt(index))
    {
        LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
            "exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    // release the refcount that was in our list.
    pTerminal->Release();

    // if there is no terminal selected, just return and wait for terminals.
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));
        return S_OK;
    }

    // At this point, the Unselect terminal opration succeeded. All the 
    // failure cases are handled by sending events after this.

    // after disconnecting the termanal, go back to the original state.
    switch  (m_dwState)
    {
    case STRM_RUNNING:

        // start the stream.
        hr = CMSPStream::StartStream();

        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
            return hr;
        }

        SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        LOG((MSP_INFO, "stream %ws %p started", m_szName, this));
        
        break;

    case STRM_PAUSED:

        // pause the stream.
        hr = CMSPStream::PauseStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
            return hr;
        }

        LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));

        break;
    }

    return S_OK;
}

HRESULT CH323MSPStream::ShutDown()
/*++

Routine Description:

    Shut down the stream. It release the filters and terminals.

Arguments:
    

Return Value:

S_OK
--*/
{
    LOG((MSP_TRACE, "CH323MSPStream::Shutdown %ws- enter", m_szName));

    CLock lock(m_lock);

    if (m_pMSPCall)
    {
        m_pMSPCall->MSPCallRelease();
        m_pMSPCall  = NULL;
    }

    m_fNeedsToOpenChannel = FALSE;
    m_htChannel = NULL;

    // free the extra filter reference.
    if (m_pEdgeFilter)
    {
        m_pEdgeFilter->Release();
        m_pEdgeFilter = NULL;
    }

    // If the stream is not configured, just free the terminals.
    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
        {
            m_Terminals[i]->Release();
        }
        m_Terminals.RemoveAll();

        return S_OK;
    }

    m_fIsConfigured = FALSE;

    // if there are terminals and configured, we need to disconnect 
    // the terminals.
    if (m_Terminals.GetSize() > 0)
    {
        // Stop the graph before disconnecting the terminals.
        HRESULT hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "stream %ws %p failed to stop, %x", m_szName, this, hr));
            return hr;
        }

        for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
        {
            hr = DisconnectTerminal(m_Terminals[i]);
            LOG((MSP_TRACE, "Disconnect terminal returned %x", hr));

            m_Terminals[i]->Release();
        }
        m_Terminals.RemoveAll();
    }

    LOG((MSP_TRACE, "CH323MSPStream::Shutdown - exit S_OK"));

    return S_OK;
}

HRESULT CH323MSPStream::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminalControl(pITTerminal);
    if (pTerminalControl == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));
        return E_NOINTERFACE;
    }

    HRESULT hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

    LOG((MSP_TRACE, "terminal %p is disonnected. hr:%x", pITTerminal, hr));

    return hr;
}

HRESULT CH323MSPStream::ProcessQOSEvent(
    IN  long lEventCode
    )
{
    CLock lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    switch (lEventCode)
    {
    case DXMRTP_QOSEVENT_NOQOS:
        ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
            H323MSP_QOS_Evnet,
            NULL,
            NULL,
            (m_dwMediaType == TAPIMEDIATYPE_AUDIO) ? MEDIA_AUDIO : MEDIA_VIDEO,
            QE_NOQOS
            );
        break;

    case DXMRTP_QOSEVENT_RECEIVERS:
    case DXMRTP_QOSEVENT_SENDERS:
    case DXMRTP_QOSEVENT_NO_SENDERS:
    case DXMRTP_QOSEVENT_NO_RECEIVERS:
        break;
    
    case DXMRTP_QOSEVENT_REQUEST_CONFIRMED:
        break;
    
    case DXMRTP_QOSEVENT_ADMISSION_FAILURE:
        ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
            H323MSP_QOS_Evnet,
            NULL,
            m_htChannel,
            (m_dwMediaType == TAPIMEDIATYPE_AUDIO) ? MEDIA_AUDIO : MEDIA_VIDEO,
            QE_ADMISSIONFAILURE
            );
        break;
    
    case DXMRTP_QOSEVENT_POLICY_FAILURE:
        ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
            H323MSP_QOS_Evnet, 
            NULL,
            m_htChannel,
            (m_dwMediaType == TAPIMEDIATYPE_AUDIO) ? MEDIA_AUDIO : MEDIA_VIDEO,
            QE_POLICYFAILURE
            );
        break;

    case DXMRTP_QOSEVENT_BAD_STYLE:
    case DXMRTP_QOSEVENT_BAD_OBJECT:
    case DXMRTP_QOSEVENT_TRAFFIC_CTRL_ERROR:
    case DXMRTP_QOSEVENT_GENERIC_ERROR:
        ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
            H323MSP_QOS_Evnet, 
            NULL,
            m_htChannel,
            (m_dwMediaType == TAPIMEDIATYPE_AUDIO) ? MEDIA_AUDIO : MEDIA_VIDEO,
            QE_GENERICERROR
            );
        break;
    
    case DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND:
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_REMOTE_REQUEST);
        break;
    
    case DXMRTP_QOSEVENT_ALLOWEDTOSEND:
        SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_REMOTE_REQUEST);
        break;
    }
    return S_OK;
}

HRESULT CH323MSPStream::HandlePacketReceiveLoss(
    IN  DWORD dwLossRate
    )
{
    return S_OK;
}

HRESULT CH323MSPStream::HandlePacketTransmitLoss(
    IN  DWORD dwLossRate
    )
{
    return S_OK;
}

HRESULT CH323MSPStream::ProcessGraphEvent(
    IN  long lEventCode,
    IN  long lParam1,
    IN  long lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d", m_szName, lEventCode));

    if ((lEventCode >= DXMRTP_QOSEVENTBASE + DXMRTP_QOSEVENT_NOQOS)
        && (lEventCode < DXMRTP_QOSEVENTBASE + DXMRTP_QOSEVENT_LAST))
    {
        ProcessQOSEvent(lEventCode - DXMRTP_QOSEVENTBASE);
    }
    else
    {
        switch (lEventCode)
        {
        case EC_COMPLETE:

            SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_UNKNOWN);
            
            break;

        case EC_USERABORT:

            SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_UNKNOWN);
            
            break;

        case EC_ERRORABORT:
        case EC_STREAM_ERROR_STOPPED:
        case EC_STREAM_ERROR_STILLPLAYING:
        case EC_ERROR_STILLPLAYING:

            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, (HRESULT)lParam1);
            
            break;

        case DXMRTP_EVENTBASE + DXMRTP_INACTIVE_EVENT:
            
            SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_MEDIA_TIMEOUT);
            
            break;

        case DXMRTP_EVENTBASE + DXMRTP_ACTIVE_AGAIN_EVENT:

            SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_MEDIA_RECOVERED);
            
            break;

        // Packet loss event.
        case DXMRTP_EVENTBASE + DXMRTP_LOSS_RATE_LOCAL_EVENT:

            HandlePacketReceiveLoss((HRESULT)lParam1);
            
            break;

        case DXMRTP_EVENTBASE + DXMRTP_LOSS_RATE_RR_EVENT:

            HandlePacketTransmitLoss((HRESULT)lParam1);
            
            break;
        }
    }

    LOG((MSP_TRACE, "TRACE:CIPConfMSPStream::ProcessGraphEvent - exit S_OK"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323strm.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ConfStrm.h

Abstract:

    Definitions for CH323MSPStream class.

Author:

    Mu Han (muhan) 1-November-1997

--*/
#ifndef __CONFSTRM_H
#define __CONFSTRM_H

/////////////////////////////////////////////////////////////////////////////
// CH323MSPStream
/////////////////////////////////////////////////////////////////////////////

const DWORD DEFAULT_TTL = 127;

//#define DEBUG_REFCOUNT

#ifdef DEBUG_REFCOUNT
extern LONG g_lStreamObjects;
#endif

class CH323MSPStream :
    public CMSPStream,
    public CMSPObjectSafetyImpl
{
public:

    BEGIN_COM_MAP(CH323MSPStream)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
    END_COM_MAP()

    CH323MSPStream();

    DWORD   MediaType() const               { return m_dwMediaType; }
    TERMINAL_DIRECTION  Direction() const   { return m_Direction;   }
    
    HANDLE TSPChannel();
    BOOL IsConfigured();
    BOOL IsTerminalSelected();
    VOID CallConnect();

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    virtual HRESULT Configure(
        IN      HANDLE          htChannel,
        IN      STREAMSETTINGS &StreamSettings
        ) = 0;

    virtual HRESULT SendIFrame() { return S_OK; }
    virtual HRESULT ChangeMaxBitRate(DWORD dwMaxBitRate) { return S_OK; }

    // CMSPStream methods.
    HRESULT ShutDown ();

     // ITStream
    STDMETHOD (get_Name) (
        OUT     BSTR *      ppName
        );

    STDMETHOD (StartStream) ();
    STDMETHOD (PauseStream) ();
    STDMETHOD (StopStream) ();

    STDMETHOD (SelectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal)(
        IN      ITTerminal *            pTerminal
        );

protected:
    virtual HRESULT CheckTerminalTypeAndDirection(
        IN      ITTerminal *    pTerminal
        );

    virtual HRESULT SendStreamEvent(
        IN      MSP_CALL_EVENT          Event,
        IN      MSP_CALL_EVENT_CAUSE    Cause,
        IN      HRESULT                 hrError,
        IN      ITTerminal *            pTerminal
        );

    virtual HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        ) = 0;

    virtual HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    virtual HRESULT InternalConfigure();
    virtual HRESULT SetUpFilters() = 0;
    virtual HRESULT CleanUpFilters();
    
    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  long lParam1,
        IN  long lParam2
        );

    virtual HRESULT ProcessQOSEvent(
        IN  long lEventCode
        );

    virtual HRESULT HandlePacketReceiveLoss(
        IN  DWORD dwLossRate
        );

    virtual HRESULT HandlePacketTransmitLoss(
        IN  DWORD dwLossRate
        );
            
protected:
    const WCHAR *   m_szName;

    const GUID *    m_pClsidPHFilter;
    const GUID *    m_pClsidCodecFilter;
    const GUID *    m_pRPHInputMinorType;  // only used in receiving stream.

    BOOL            m_fNeedsToOpenChannel;
    BOOL            m_fIsConfigured;
    STREAMSETTINGS  m_Settings;

    IBaseFilter *   m_pEdgeFilter;

    HANDLE          m_htChannel;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323call.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    H323call.cpp 

Abstract:

    This module contains implementation of CH323MSPCall.

Author:
    
    Mu Han (muhan)   5-September-1998

--*/
#include "stdafx.h"
#include "common.h"
#include <H323pdu.h>

STDMETHODIMP CH323MSPCall::CreateStream(
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
/*++

Routine Description:

    This method is called by the app to create a new stream. If this happens
    before the TSP's new call notification, we just create the object. If the
    call is already connected, we will send the TSP an open channel request
    when the first terminal is selected.

Arguments:
    
    lMediaType - The media type of this stream.

    Direction   - The direction of this stream.

    ppStream    - The memory address to store the returned pointer.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "CH323MSPCall.CreateStream--dwMediaType:%x, Direction:%x, ppStream %x",
        lMediaType, Direction, ppStream
        ));

    // first call the base class's implementation to create the stream object.
    HRESULT hr = CMSPCallBase::CreateStream(
        lMediaType,
        Direction,
        ppStream
        );

    return hr;
}

STDMETHODIMP CH323MSPCall::RemoveStream(
    IN      ITStream *          pStream
    )
/*++

Routine Description:

    This method is called by the app to remove a stream. If the channel is
    already connected, we need to send the TSP an close channel request.

Arguments:
    
    pStream    - The stream to be removed.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CH323MSPCall::RemoveStream - pStream %x", pStream));

    // acquire the lock before accessing the stream object list.
    CLock lock(m_lock);

    if (m_Streams.Find(pStream) < 0)
    {
        LOG((MSP_ERROR, "CH323MSPCall::RemoveStream - Stream %x is not found.", pStream));
        return E_INVALIDARG;
    }

    // Close the TSP channel if it is active.
    HANDLE htChannel;
    if ((htChannel = ((CH323MSPStream *)pStream)->TSPChannel()) != NULL)
    {
        SendTSPMessage(
            H323MSP_CLOSE_CHANNEL_COMMAND,
            NULL,
            htChannel
            );
    }

    return CMSPCallMultiGraph::RemoveStream(pStream);
}

HRESULT CH323MSPCall::Init(
    IN      CMSPAddress *       pMSPAddress,
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType
    )
/*++

Routine Description:

    This method is called when the call is first created. It sets
    up the streams based on the mediatype specified.

Arguments:
    
    pMSPAddress - The pointer to the address object.

    htCall      - The handle to the Call in TAPI's space. 
                    Used in sending events.

    dwReserved  - Reserved.

    dwMediaType - The media type of this call.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "H323MSP call %x initialize entered,"
        " pMSPAddress:%x, htCall %x, dwMediaType %x",
        this, pMSPAddress, htCall, dwMediaType
        ));

#ifdef DEBUG_REFCOUNT
    LOG((MSP_TRACE, "Number of Streams alive: %d", g_lStreamObjects));

    if (g_lStreamObjects != 0)
    {
        DebugBreak();
    }
#endif

    // Call the base class's init.
    HRESULT hr= CMSPCallMultiGraph::Init(
        pMSPAddress, 
        htCall, 
        dwReserved, 
        dwMediaType
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "MSPCallMultiGraph init failed:%x", hr));
        return hr;
    }

    // create streams based on the media types.
    if (dwMediaType & TAPIMEDIATYPE_AUDIO)
    {
        ITStream * pStream;

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_AUDIO, TD_RENDER, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create audio render stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_AUDIO, TD_CAPTURE, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create audio capture stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();
    }

    if (dwMediaType & TAPIMEDIATYPE_VIDEO)
    {
        ITStream * pStream;

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_VIDEO, TD_RENDER, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create video render stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_VIDEO, TD_CAPTURE, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create video capture stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();
    }

    m_fCallConnected = FALSE;
    m_fShutDown      = FALSE;

    return S_OK;
}

HRESULT CH323MSPCall::ShutDown()
/*++

Routine Description:

    Just call the internal shut down method. 
Arguments:
    
Return Value:

    HRESULT.

--*/
{
    InternalShutDown();

    // acquire the lock on the call.
    CLock lock(m_lock);

    // release all the streams
    for (int i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        m_Streams[i]->Release();
    }
    m_Streams.RemoveAll();

    return S_OK;
}

HRESULT CH323MSPCall::InternalShutDown()
/*++

Routine Description:

    First call the base class's shutdown and then release all the participant
    objects.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    // acquire the lock on the call.
    CLock lock(m_lock);
    
    if (m_fShutDown)
    {
        return S_OK;
    }
    // Shutdown all the streams
    for (int i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        UnregisterWaitEvent(i);
        ((CMSPStream*)m_Streams[i])->ShutDown();
    }
    m_ThreadPoolWaitBlocks.RemoveAll();

    m_fShutDown = TRUE;

    return S_OK;
}

template <class T>
HRESULT CreateStreamHelper(
    IN      T *                     pT,
    IN      HANDLE                  hAddress,
    IN      CH323MSPCall*         pMSPCall,
    IN      IMediaEvent *           pGraph,
    IN      DWORD                   dwMediaType,
    IN      TERMINAL_DIRECTION      Direction,
    OUT     ITStream **             ppITStream
    )
/*++

Routine Description:

    Create a stream object and initialize it. This method is called internally
    to create a stream object of different class.

Arguments:
    
    hAddress    - the handle to the address object.

    pCall       - the call object.

    pGraph      - the filter graph for this stream.

    dwMediaType - the media type of the stream. 

    Direction   - the direction of the steam.
    
    ppITStream  - the interface on this stream object.

Return Value:

    HRESULT.

--*/
{
    CComObject<T> * pCOMMSPStream;

    HRESULT hr = CComObject<T>::CreateInstance(&pCOMMSPStream);

    if (NULL == pCOMMSPStream)
    {
        LOG((MSP_ERROR, "CreateMSPStream:could not create stream:%x", hr));
        return hr;
    }

    // get the interface pointer.
    hr = pCOMMSPStream->_InternalQueryInterface(
        IID_ITStream, 
        (void **)ppITStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPStream:QueryInterface failed: %x", hr));
        delete pCOMMSPStream;
        return hr;
    }

    // Initialize the object.
    hr = pCOMMSPStream->Init(
        hAddress,
        pMSPCall, 
        pGraph,
        dwMediaType,
        Direction
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPStream:call init failed: %x", hr));
        (*ppITStream)->Release();
        return hr;
    }

    return S_OK;
}


HRESULT CH323MSPCall::CreateStreamObject(
    IN      DWORD               dwMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN      IMediaEvent *       pGraph,
    IN      ITStream **         ppStream
    )
/*++

Routine Description:

    Create a media stream object based on the mediatype and direction.

Arguments:
    
    pMediaType  - TAPI3 media type.

    Direction   - direction of this stream.

    IMediaEvent - The filter graph used in this stream.

    ppStream    - the return pointer of the stream interface

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CreateStreamObject, entered"));

    HRESULT         hr;
    ITStream   * pIMSPStream = NULL;

    // Create a stream object based on the media type.
    if (dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        if (Direction == TD_RENDER)
        {
            CStreamAudioRecv *pAudioRecv = NULL;
            hr = ::CreateStreamHelper(
                pAudioRecv,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_AUDIO,
                TD_RENDER,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create audio receive:%x, hr:%x", pIMSPStream,hr));
        }
        else if (Direction == TD_CAPTURE)
        {
            CStreamAudioSend *pAudioSend = NULL;
            hr = ::CreateStreamHelper(
                pAudioSend,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_AUDIO,
                TD_CAPTURE,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create audio send:%x, hr:%x", pIMSPStream,hr));
        }
    }
    else if (dwMediaType == TAPIMEDIATYPE_VIDEO)
    {
        if (Direction == TD_RENDER)
        {
            CStreamVideoRecv *pVideoRecv = NULL;
            hr = ::CreateStreamHelper(
                pVideoRecv,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_VIDEO,
                TD_RENDER,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create video Recv:%x, hr:%x", pIMSPStream,hr));
        }
        else if (Direction == TD_CAPTURE)
        {
            CStreamVideoSend *pVideoSend = NULL;
            hr = ::CreateStreamHelper(
                pVideoSend,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_VIDEO,
                TD_CAPTURE,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create video send:%x, hr:%x", pIMSPStream,hr));
        }
    }
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create stream failed. %x", hr));
        return hr;
    }

    *ppStream = pIMSPStream;

    return S_OK;
}

HRESULT CH323MSPCall::SendTSPMessage(
    IN  H323MSP_MESSAGE_TYPE    Type,
    IN  ITStream    *           hmChannel,
    IN  HANDLE                  htChannel,
    IN  MEDIATYPE               MediaType,
    IN  DWORD                   dwReason,
    IN  DWORD                   dwBitRate
    ) const
/*++

Routine Description:

    Send the TSP a message from the MSP. 

Arguments:

    command     - the command to be sent.

    hmChannel   - the handle of the stream.

    htChannel   - the handle of the channel in the TSP.

    Mediatype   - the media type of the channel.

    dwReason    - the reason for the command.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "SendTSPMessage, type %d, hmChannel %p, htChannel %d",
        Type, hmChannel, htChannel));

    // first allocate the memory.
    DWORD dwSize = sizeof(H323MSP_MESSAGE);

    MSPEVENTITEM* pEventItem = AllocateEventItem(dwSize);

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data, size: %d", dwSize));
        return E_OUTOFMEMORY;
    }
    
    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = 
        sizeof(MSP_EVENT_INFO) + sizeof(H323MSP_MESSAGE);
    pEventItem->MSPEventInfo.Event  = ME_TSP_DATA;
    pEventItem->MSPEventInfo.hCall  = m_htCall;

    pEventItem->MSPEventInfo.MSP_TSP_DATA.dwBufferSize = sizeof(H323MSP_MESSAGE);

    H323MSP_MESSAGE *pData = (H323MSP_MESSAGE *)
        pEventItem->MSPEventInfo.MSP_TSP_DATA.pBuffer;

    // Fill in the data for the TSP.
    pData->Type = Type;

    switch (Type)
    {
    case H323MSP_OPEN_CHANNEL_REQUEST:
        pData->OpenChannelRequest.hmChannel = hmChannel;
        pData->OpenChannelRequest.Settings.MediaType = MediaType;
        break;

    case H323MSP_ACCEPT_CHANNEL_RESPONSE:
        pData->AcceptChannelResponse.hmChannel = hmChannel;
        pData->AcceptChannelResponse.htChannel = htChannel;
        break;

    case H323MSP_CLOSE_CHANNEL_COMMAND:
        pData->CloseChannelCommand.hChannel = htChannel;
        pData->CloseChannelCommand.dwReason = dwReason;
        break;

    case H323MSP_QOS_Evnet:
        pData->QOSEvent.dwEvent = dwReason;
        pData->QOSEvent.htChannel = htChannel;
        break;

    case H323MSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND:
        pData->VideoFastUpdatePictureCommand.hChannel = htChannel;
        break;

    case H323MSP_FLOW_CONTROL_COMMAND:
        pData->FlowControlCommand.hChannel = htChannel;
        pData->FlowControlCommand.dwBitRate = dwBitRate;
        break;
    
    }

    HRESULT hr = m_pMSPAddress->PostEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));

        FreeEventItem(pEventItem);

        return hr;
    }
    return S_OK;
}

void CH323MSPCall::ProcessNewCallIndication(void)
/*++

Routine Description:

    This function handles the new call indication pdu. It walk through the
    list of streams and send open channel requests to the TSP for each 
    outgoing stream.

Arguments:

    none.

Return Value:

    none.
--*/
{
    LOG((MSP_TRACE, "NewCallIndication entered."));

    CLock lock(m_lock);

    if (m_fCallConnected)
    {
        LOG((MSP_ERROR, "New Call indication Twice!!!"));
        return;
    }

    for (int i = 0; i < m_Streams.GetSize(); i ++)
    {
        CH323MSPStream* pH323MSPStream = (CH323MSPStream*)m_Streams[i];

        // Notify the stream that the call is connected.
        pH323MSPStream->CallConnect();

        if ((pH323MSPStream->Direction() == TD_CAPTURE)
            && (pH323MSPStream->IsTerminalSelected()))
        {
            // Send an open Channel request for outgoing channels.
            SendTSPMessage(
                H323MSP_OPEN_CHANNEL_REQUEST, 
                m_Streams[i], 
                NULL,
                (pH323MSPStream->MediaType() == TAPIMEDIATYPE_AUDIO)
                    ? MEDIA_AUDIO : MEDIA_VIDEO
                );
        }
    }

    m_fCallConnected = TRUE;

    return;
}

void CH323MSPCall::ProcessOpenChannelResponse(
    IN  H323MSG_OPEN_CHANNEL_RESPONSE * pOpenChannelResponse
    )
/*++

Routine Description:

    This function handles the open channel response pdu. It finds the stream
    based on the handle and configures the stream.

Arguments:

    pOpenChannelResponse - the PDU that has the detailed info.

Return Value:

    none.
--*/
{
    LOG((MSP_TRACE, 
        "OpenChannelResponse entered, hmChannel %x, htChannel %x, media %d",
        pOpenChannelResponse->hmChannel,
        pOpenChannelResponse->htChannel,
        pOpenChannelResponse->Settings.MediaType
        ));

    ITStream *pITStream = (ITStream *)(pOpenChannelResponse->hmChannel);

    m_lock.Lock();

    if (m_Streams.Find(pITStream) < 0)
    {
        LOG((MSP_ERROR, "Stream %x does not exit", pITStream));
        m_lock.Unlock();
        return;
    }
        
    // it is a valid stream, addref it so that it won't go away.
    pITStream->AddRef();

    // release the lock on the call.
    m_lock.Unlock();

    HRESULT hr = ((CH323MSPStream *)pITStream)->Configure(
        pOpenChannelResponse->htChannel,
        pOpenChannelResponse->Settings
        );

    if (FAILED(hr))
    {
        SendTSPMessage(
            H323MSP_CLOSE_CHANNEL_COMMAND,
            NULL,
            pOpenChannelResponse->htChannel
            );
    }

    // release the refcount we just added.
    pITStream->Release();

    return;
}

HRESULT CH323MSPCall::SendTAPIStreamEvent(
    IN  ITStream *              pITStream,
    IN  MSP_CALL_EVENT          Type,
    IN  MSP_CALL_EVENT_CAUSE    Cause
    )
{

    MSPEVENTITEM* pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data, size: %d", sizeof(MSPEVENTITEM)));

        return E_OUTOFMEMORY;
    }

    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);;
    pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type = Type;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause = Cause;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream = pITStream;
    
    // Addref to prevent it from going away.
    pITStream->AddRef();

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = NULL;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError= 0;

    // send the event to tapi.
    HRESULT hr = HandleStreamEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));
    
        FreeEventItem(pEventItem);
        return hr;
    }
    return S_OK;
}

void CH323MSPCall::ProcessAcceptChannelRequest(
    IN  H323MSG_ACCEPT_CHANNEL_REQUEST * pAcceptChannelRequest
    )
/*++

Routine Description:

    This function handles the accept channel request pdu. It finds a free 
    stream that can be used for this channel. If no one can be found, it will
    create a new stream and notify the app. The channel is always accepted
    automatically. If the app choose to remove the stream, the channel will
    be closed.

Arguments:

    pAcceptChannelRequest - the PDU that has the detailed info.

Return Value:

    none.
--*/
{
    LOG((MSP_TRACE, 
        "AcceptChannelRequest entered, htChannel %x, media %d",
        pAcceptChannelRequest->htChannel,
        pAcceptChannelRequest->Settings.MediaType
        ));

    DWORD dwMediaType;
    if (pAcceptChannelRequest->Settings.MediaType == MEDIA_AUDIO)
    {
        dwMediaType = TAPIMEDIATYPE_AUDIO;
    }
    else
    {
        dwMediaType = TAPIMEDIATYPE_VIDEO;
    }

    // if the media type of the channel is not one of the media types of the
    // call, reject the channel.
    if (!(dwMediaType & m_dwMediaType))
    {
        LOG((MSP_WARN, 
            "Unwanted media type %x, call media type %x",
            dwMediaType, m_dwMediaType
            ));

        SendTSPMessage(
            H323MSP_CLOSE_CHANNEL_COMMAND, 
            NULL,
            pAcceptChannelRequest->htChannel
            );

        return;
    }

    CH323MSPStream* pStream = NULL;
    BOOL fFoundUnused       = FALSE;
    BOOL fExistButInUse     = FALSE;

    CLock lock(m_lock);

    // find an unused incoming stream of that media type.
    for (int i = 0; i < m_Streams.GetSize(); i++)
    {
        pStream = (CH323MSPStream*)m_Streams[i];
        if ((pStream->Direction() == TD_RENDER)
             && (pStream->MediaType() == dwMediaType))
        {
            if (pStream->IsConfigured())
            {
                fExistButInUse  = TRUE;
            }
            else
            {
                fFoundUnused    = TRUE;
                break;
            }
        }
    }

    HRESULT hr;

    if (!fFoundUnused)
    {
        if (!fExistButInUse)
        {
            // This means the app has deleted the streams of this type and
            // direction. We should reject this channel.

            SendTSPMessage(
                H323MSP_CLOSE_CHANNEL_COMMAND, 
                NULL,
                pAcceptChannelRequest->htChannel
                );

            return;
        }

        //
        // This channel might be wanted by the APP, create a stream for it.
        //

        ITStream * pITStream;

        // create a stream object.
        hr = InternalCreateStream(dwMediaType, TD_RENDER, &pITStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create stream failed:%x", hr));

            SendTSPMessage(
                H323MSP_CLOSE_CHANNEL_COMMAND, 
                NULL,
                pAcceptChannelRequest->htChannel
                );

            return;
        }

        // notify the app about the new stream.
        hr = SendTAPIStreamEvent(pITStream, CALL_NEW_STREAM, CALL_CAUSE_REMOTE_REQUEST);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Send new stream event failed:%x", hr));

            RemoveStream(pITStream);

            SendTSPMessage(
                H323MSP_CLOSE_CHANNEL_COMMAND, 
                NULL,
                pAcceptChannelRequest->htChannel
                );

            return;
        }

        // The stream is already in our array, we don't need this pointer.
        pITStream->Release();

        pStream = (CH323MSPStream*)pITStream;
    }

    if (SUCCEEDED(pStream->Configure(
        pAcceptChannelRequest->htChannel,
        pAcceptChannelRequest->Settings
        )))
    {

        SendTSPMessage(
            H323MSP_ACCEPT_CHANNEL_RESPONSE,
            (ITStream*)pStream,
            pAcceptChannelRequest->htChannel
            );
    }

    return;
}

void CH323MSPCall::ProcessCloseChannelCommand(
    IN  H323MSG_CLOSE_CHANNEL_COMMAND * pCloseChannelCommand
    )
/*++

Routine Description:

    This function handles the close channel pdu. It finds the stream
    based on the handle and remove the stream and also notify the app.

Arguments:

    pCloseChannelCommand - the PDU that has the detailed info.

Return Value:

    none.
--*/
{
    LOG((MSP_TRACE, 
        "CloseChannelCommand entered, hChannel %x, reason: %x",
        pCloseChannelCommand->hChannel,
        pCloseChannelCommand->dwReason
        ));

    ITStream *pITStream = (ITStream *)(pCloseChannelCommand->hChannel);

    m_lock.Lock();

    if (m_Streams.Find(pITStream) < 0)
    {
        LOG((MSP_ERROR, "Stream %x does not exit", pITStream));
        m_lock.Unlock();
        return;
    }

    // it is a valid stream, addref it so that it won't go away.
    pITStream->AddRef();

    // release the lock on the call.
    m_lock.Unlock();

    ((CH323MSPStream *)pITStream)->ShutDown();

    // notify the app about the stream being closed. 
    SendTAPIStreamEvent(pITStream, CALL_STREAM_NOT_USED, CALL_CAUSE_REMOTE_REQUEST);
    
    // release the refcount we just added.
    pITStream->Release();

    return;
}


void CH323MSPCall::ProcessIFrameRequest(
    IN  H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND * pIFrameRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

    none.
--*/
{

    LOG((MSP_TRACE, 
        "ProcessIFrameRequest entered, hChannel %x",
        pIFrameRequest->hChannel
        ));

    ITStream *pITStream = (ITStream *)(pIFrameRequest->hChannel);

    m_lock.Lock();

    if (m_Streams.Find(pITStream) < 0)
    {
        LOG((MSP_ERROR, "Stream %x does not exit", pITStream));
        m_lock.Unlock();
        return;
    }

    // it is a valid stream, addref it so that it won't go away.
    pITStream->AddRef();

    // release the lock on the call.
    m_lock.Unlock();

    ((CH323MSPStream *)pITStream)->SendIFrame();

    // release the refcount we just added.
    pITStream->Release();

    return;
}

void CH323MSPCall::ProcessFlowControlCommand(
    IN  H323MSG_FLOW_CONTROL_COMMAND * pFlowControlCommand
    )
/*++

Routine Description:

Arguments:

Return Value:

    none.
--*/
{

    LOG((MSP_TRACE, 
        "FlowControlCommand entered, hChannel %x, dataRate: %d",
        pFlowControlCommand->hChannel,
        pFlowControlCommand->dwBitRate
        ));

    ITStream *pITStream = (ITStream *)(pFlowControlCommand->hChannel);

    m_lock.Lock();

    if (m_Streams.Find(pITStream) < 0)
    {
        LOG((MSP_ERROR, "Stream %x does not exit", pITStream));
        m_lock.Unlock();
        return;
    }

    // it is a valid stream, addref it so that it won't go away.
    pITStream->AddRef();

    // release the lock on the call.
    m_lock.Unlock();

    ((CH323MSPStream *)pITStream)->ChangeMaxBitRate(
        pFlowControlCommand->dwBitRate
        );

    // release the refcount we just added.
    pITStream->Release();

    return;
}



DWORD CH323MSPCall::ProcessWorkerCallBack(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
/*++

Routine Description:

    This function handles the work item given by the TSP. 

Arguments:

    pBuffer - a buffer that contains a TSP_MSP command block.

    dwSize  - the size of the buffer.

Return Value:

    NOERROR.

--*/
{
    LOG((MSP_TRACE, "ProcessWorkerCallBAck"));

    _ASSERTE(!IsBadReadPtr(pBuffer, dwSize));

    H323TSP_MESSAGE * pData = (H323TSP_MESSAGE *)pBuffer;
    switch (pData->Type)
    {
        //
        // H323TSP_NEW_CALL_INDICATION - sent only from the TSP
        //  to the MSP in order to initiate communication once
        //  a call has been created.
        //

    case H323TSP_NEW_CALL_INDICATION:
        ProcessNewCallIndication();
    break;

        //
        // H323TSP_OPEN_CHANNEL_RESPONSE - sent only from the TSP
        // to the MSP in response to H323MSP_OPEN_CHANNEL_REQUEST.
        //

    case H323TSP_OPEN_CHANNEL_RESPONSE:
        ProcessOpenChannelResponse(&(pData->OpenChannelResponse));
    break;

        //
        // H323TSP_ACCEPT_CHANNEL_REQUEST - sent only from the TSP
        // to the MSP in order to request the acceptance of an
        // incoming logical channel.
        //

    case H323TSP_ACCEPT_CHANNEL_REQUEST:
        ProcessAcceptChannelRequest(&(pData->AcceptChannelRequest));
    break;

        //
        // H323TSP_CLOSE_CHANNEL_COMMAND - sent only from the TSP
        // to the MSP in order to demand the immediate closure of
        // an incoming or outgoing logical channel.
        //

    case H323TSP_CLOSE_CHANNEL_COMMAND:
        ProcessCloseChannelCommand(&(pData->CloseChannelCommand));
    break;

        //
        // H323TSP_CLOSE_CALL_CAMMAND - sent only from the TSP
        //  to the MSP in order to stop all the streaming for a call.
        //

    case H323TSP_CLOSE_CALL_COMMAND:
        InternalShutDown();
    break;

        //  I Frame Request.
        //

    case H323TSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND:
        ProcessIFrameRequest(&(pData->VideoFastUpdatePictureCommand));
    break;

        //  Flow control command Request.
        //

    case H323TSP_FLOW_CONTROL_COMMAND:
        ProcessFlowControlCommand(&(pData->FlowControlCommand));
    break;
    }

    return NOERROR;
}

DWORD WINAPI CH323MSPCall::WorkerCallbackDispatcher(VOID *pContext)
/*++

Routine Description:

    Because configure the streams uses a lot of COM
    stuff, we can't rely on the RPC thread the calls into the MSP to 
    receive the TSP data. So, we let our own working thread do the work.
    This method is the callback function for the queued work item. It 
    just gets the call object from the context structure and calls a method
    on the call object to handle the work item.

Arguments:

    pContext - A pointer to a CALLWORKITEM structure.

Return Value:

    HRESULT.

--*/
{
    CALLWORKITEM *pItem = (CALLWORKITEM *)pContext;
    
    pItem->pCall->ProcessWorkerCallBack(pItem->Buffer, pItem->dwLen);
    pItem->pCall->MSPCallRelease();

    free(pItem);

    return NOERROR;
}

HRESULT CH323MSPCall::ReceiveTSPCallData(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
/*++

Routine Description:

    This function handles the work item given by the TSP. 

Arguments:

    pBuffer - a buffer that contains a TSP_MSP command block.

    dwSize  - the size of the buffer.

Return Value:

    E_POINTER.
    S_OK.

--*/
{
    LOG((MSP_TRACE, 
        "ReceiveTSPCallData, pBuffer %x, dwSize %d", pBuffer, dwSize));

    // make sure the data is valid.
    if (IsBadReadPtr(pBuffer, dwSize))
    {
        LOG((MSP_ERROR, "the TSP data is invalid."));
        return E_POINTER;
    }

    // allocate a work item structure for our worker thread.
    CALLWORKITEM *pItem = (CALLWORKITEM *)malloc(sizeof(CALLWORKITEM) + dwSize);

    if (pItem == NULL)
    {
        LOG((MSP_ERROR, "out of memory for work item."));
        return E_OUTOFMEMORY;
    }

    this->MSPCallAddRef();
    pItem->pCall = this;
    pItem->dwLen = dwSize;
    CopyMemory(pItem->Buffer, pBuffer, dwSize);
    
    // post a work item to our worker thread.
    HRESULT hr = g_Thread.QueueWorkItem(
        WorkerCallbackDispatcher,           // the callback
        pItem,                              // the context.
        FALSE                               // sync (FALSE means asyn)
        );

    if (FAILED(hr))
    {
        this->MSPCallRelease();
        free(pItem);

        LOG((MSP_ERROR, "queue work item failed."));
        return E_UNEXPECTED;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323util.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    MSPutil.cpp 

Abstract:

    This module contains implementation of msp utility functions.

Author:
    
    Mu Han (muhan)   1-November-1997

--*/
#include "stdafx.h"
#include "common.h"
#include <amrtpnet.h>   // rtp guilds
#include <amrtpdmx.h>   // demux guild
#include <amrtpuid.h>   // AMRTP media types

HRESULT
AddFilter(
    IN IGraphBuilder *      pIGraph,
    IN const CLSID &        Clsid,
    IN LPCWSTR              pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    )
/*++

Routine Description:

    Create a filter and add it into the filtergraph.

Arguments:
    
    pIGraph         - the filter graph.

    Clsid           - reference to the CLSID of the filter

    pwstrName       - The name of ther filter added.

    ppIBaseFilter   - pointer to a pointer that stores the returned IBaseFilter
                      interface pointer to the newly created filter.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "AddFilter %ws", pwstrName));

    _ASSERTE(ppIBaseFilter != NULL);

    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(
            Clsid,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IBaseFilter,
            (void **) ppIBaseFilter
            )))
    {
        LOG((MSP_ERROR, "create filter %x", hr));
        return hr;
    }

    if (FAILED(hr = pIGraph->AddFilter(*ppIBaseFilter, pwstrName)))
    {
        LOG((MSP_ERROR, "add filter. %x", hr));
        (*ppIBaseFilter)->Release();
        *ppIBaseFilter = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter
    )
/*++

Routine Description:

    Set the address of a rtp stream

Arguments:
    
    pIBaseFilter    - an rtp source filters.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "EnableRTCPEvents"));

    HRESULT hr;

    // Get the IRTCPStream interface pointer on the filter.
    CComQIPtr<IRTCPStream, 
        &IID_IRTCPStream> pIRTCPStream(pIBaseFilter);
    if (pIRTCPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTCP Stream interface"));
        return E_NOINTERFACE;
    }

    // enable events.
    if (FAILED(hr = pIRTCPStream->ModifyRTCPEventMask(  
            0xffffffff, 0
            )))
    {
        LOG((MSP_ERROR, "clear RTCP event mask. %x", hr));
        return hr;
    }

            // enable events.
    if (FAILED(hr = pIRTCPStream->ModifyRTCPEventMask(  
            (1 << DXMRTP_INACTIVE_EVENT) |
            (1 << DXMRTP_LOSS_RATE_LOCAL_EVENT) |
            (1 << DXMRTP_LOSS_RATE_RR_EVENT) |
            (1 << DXMRTP_ACTIVE_AGAIN_EVENT)
            , 1
            )))
    {
        LOG((MSP_ERROR, "set RTCP event mask. %x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBandwidth,
    IN BOOL             bReceive,
    IN BOOL             bCIF
    )
/*++

Routine Description:

    Enable QOS based on registry settings.

Arguments:
    
    pIBaseFilter    - rtp source filter.

    dwPayloadType   - the rtp payload type of this stream.

    bCIF            - CIF or QCIF.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetQOSOption, Payload: %d, bandwidth:%d",
        dwPayloadType, dwMaxBandwidth
        ));

    char * szQOSName;
    DWORD fSharedStyle = DXMRTP_RESERVE_EXPLICIT;

    switch (dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        szQOSName       = "G711";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;

        break;

    case PAYLOAD_G723:
        szQOSName       = "G723";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;
        
        break;

    case PAYLOAD_H261:
        szQOSName = (bCIF) ? "H261CIF" : "H261QCIF";
        break;

    case PAYLOAD_H263:
        szQOSName = (bCIF) ? "H263CIF" : "H263QCIF";
        break;

    default:
        LOG((MSP_WARN, "Don't know the QOS name for payload type: %d", 
            dwPayloadType));
        return S_FALSE;
    }

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, 
        &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    HRESULT hr;

    // Enable QOS, 
    if (FAILED(hr = pIRTPStream->SetQOSByName(szQOSName, 0)))
    {
        LOG((MSP_ERROR, "set QOS by name. %x", hr));
        return hr;
    }

    // Get the IRTPParticipant interface pointer on the filter.
    CComQIPtr<IRTPParticipant,
        &IID_IRTPParticipant> pIRTPParticipant(pIBaseFilter);
    if (pIRTPParticipant == NULL)
    {
        LOG((MSP_ERROR, "get RTP participant interface"));
        return E_NOINTERFACE;
    }

    if (FAILED(hr = pIRTPParticipant->SetMaxQOSEnabledParticipants(
            1,
            dwMaxBandwidth,
            fSharedStyle 
        )))
    {
        LOG((MSP_ERROR, "SetMaxQOSEnabledParticipants. %x", hr));
        return hr;
    }

    DWORD dwQOSEventMask = 
            (1 << DXMRTP_QOSEVENT_NOQOS) |
            (1 << DXMRTP_QOSEVENT_REQUEST_CONFIRMED) |
            (1 << DXMRTP_QOSEVENT_ADMISSION_FAILURE) |
            (1 << DXMRTP_QOSEVENT_POLICY_FAILURE) |
            (1 << DXMRTP_QOSEVENT_BAD_STYLE) |
            (1 << DXMRTP_QOSEVENT_BAD_OBJECT) |
            (1 << DXMRTP_QOSEVENT_TRAFFIC_CTRL_ERROR) |
            (1 << DXMRTP_QOSEVENT_GENERIC_ERROR);

    if (bReceive)
    {
        dwQOSEventMask |= 
            (1 << DXMRTP_QOSEVENT_SENDERS) |
            (1 << DXMRTP_QOSEVENT_NO_SENDERS);
    }
    else
    {
        dwQOSEventMask |= 
            (1 << DXMRTP_QOSEVENT_RECEIVERS) |
            (1 << DXMRTP_QOSEVENT_NO_RECEIVERS) |
            (1 << DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND) |
            (1 << DXMRTP_QOSEVENT_ALLOWEDTOSEND);
    }

    // enable events.
    if (FAILED(hr = pIRTPStream->ModifyQOSEventMask(dwQOSEventMask, 1)))
    {
        LOG((MSP_ERROR, "set QOSEventMask. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "enabled qos for %s.", szQOSName));
    return hr;
}

HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree
    )
/*++

Routine Description:

    Find a input pin or output pin on a filter.

Arguments:
    
    pIFilter    - the filter that has pins.

    ppIPin      - the place to store the returned interface pointer.

    direction   - PINDIR_INPUT or PINDIR_OUTPUT.

    bFree       - look for a free pin or not.

Return Value:

    HRESULT

--*/
{
    _ASSERTE(ppIPin != NULL);

    HRESULT hr;
    DWORD dwFeched;

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pIFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    IPin * pIPin;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            LOG((MSP_ERROR, "find pin on filter."));
            return E_FAIL;
        }
        if (0 == dwFeched)
        {
            LOG((MSP_ERROR, "get 0 pin from filter."));
            return E_FAIL;
        }

        PIN_DIRECTION dir;
        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            LOG((MSP_ERROR, "query pin direction. %x", hr));
            pIPin->Release();
            return hr;
        }
        if (direction == dir)
        {
            if (!bFree)
            {
                break;
            }

            // Check to see if the pin is free.
            CComPtr<IPin> pIPinConnected;
            hr = pIPin->ConnectedTo(&pIPinConnected);
            if (pIPinConnected == NULL)
            {
                break;
            }
        }
        pIPin->Release();
    }
    *ppIPin = pIPin;
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter1, 
    IN IBaseFilter *    pIFilter2,
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect the output pin of the first filter to the input pin of the
    second filter.

Arguments:

    pIGraph     - the filter graph.

    pIFilter1   - the filter that has the output pin.

    pIFilter2   - the filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;

    CComPtr<IPin> pIPinOutput;
    if (FAILED(hr = ::FindPin(pIFilter1, &pIPinOutput, PINDIR_OUTPUT)))
    {
        LOG((MSP_ERROR, "find output pin on filter1. %x", hr));
        return hr;
    }

    CComPtr<IPin> pIPinInput;
    if (FAILED(hr = ::FindPin(pIFilter2, &pIPinInput, PINDIR_INPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter2. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }
 
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pIFilter,
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect an output pin to the input pin of a filter.

Arguments:
    
    pIGraph     - the filter graph.

    pIPinOutput - an output pin.

    pIFilter    - a filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;
    CComPtr<IPin> pIPinInput;

    if (FAILED(hr = ::FindPin(pIFilter, &pIPinInput, PINDIR_INPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect an filter to the input pin of a filter.

Arguments:
    
    pIGraph     - the filter graph.

    pIPinOutput - an output pin.

    pIFilter    - a filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;
    CComPtr<IPin> pIPinOutput;

    if (FAILED(hr = ::FindPin(pIFilter, &pIPinOutput, PINDIR_OUTPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }

    return S_OK;
}


void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt)
/*++

Routine Description:
    
    Delete a AM media type returned by the filters.

Arguments:

    pmt     - a pointer to a AM_MEDIA_TYPE structure.

Return Value:

    HRESULT

--*/
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    if (pmt->cbFormat != 0) {
        CoTaskMemFree((PVOID)pmt->pbFormat);

        // Strictly unnecessary but tidier
        pmt->cbFormat = 0;
        pmt->pbFormat = NULL;
    }
    if (pmt->pUnk != NULL) {
        pmt->pUnk->Release();
        pmt->pUnk = NULL;
    }

    CoTaskMemFree((PVOID)pmt);
}


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    )
/*++

Routine Description:

    Get a dword from the registry in the ipH323msp key.

Arguments:
    
    szName  - The name of the value.

    pdwValue  - a pointer to the dword returned.

Return Value:

    TURE    - SUCCEED.

    FALSE   - MSP_ERROR

--*/
{
    HKEY  hKey;
    DWORD dwDataSize, dwDataType, dwData = 0;

    if (::RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszSDPMSPKey,
        0,
        KEY_READ,
        &hKey) != NOERROR)
    {
        return FALSE;
    }

    dwDataSize = sizeof(DWORD);
    if (::RegQueryValueExW(
        hKey,
        szName,
        0,
        &dwDataType,
        (LPBYTE) dwData,
        &dwDataSize) != NOERROR)
    {
        RegCloseKey (hKey);
        return FALSE;
    }

    RegCloseKey (hKey);
    
    *pdwValue = dwData;

    return TRUE;
}

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    )
/*++

Routine Description:

    Get the IAMStreamConfig interface on the object and config the
    audio format by using WAVEFORMATEX.

Arguments:
    
    pIPin       - a capture terminal.

    wBitPerSample  - the number of bits in each sample.

    dwSampleRate    - number of samples per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetAudioFormat entered"));

    HRESULT hr;

    CComPtr<IAMStreamConfig> pIAMStreamConfig;

    if (FAILED(hr = pIUnknown->QueryInterface(
        IID_IAMStreamConfig,
        (void **)&pIAMStreamConfig
        )))
    {
        LOG((MSP_ERROR, "Can't get IAMStreamConfig interface.%8x", hr));
        return hr;
    }

    AM_MEDIA_TYPE mt;
    WAVEFORMATEX wfx;

    wfx.wFormatTag          = WAVE_FORMAT_PCM;
    wfx.wBitsPerSample      = wBitPerSample;
    wfx.nChannels           = 1;
    wfx.nSamplesPerSec      = dwSampleRate;
    wfx.nBlockAlign         = wfx.wBitsPerSample * wfx.nChannels / 8;
    wfx.nAvgBytesPerSec     = ((DWORD) wfx.nBlockAlign * wfx.nSamplesPerSec);
    wfx.cbSize              = 0;

    mt.majortype            = MEDIATYPE_Audio;
    mt.subtype              = MEDIASUBTYPE_PCM;
    mt.bFixedSizeSamples    = TRUE;
    mt.bTemporalCompression = FALSE;
    mt.lSampleSize          = 0;
    mt.formattype           = FORMAT_WaveFormatEx;
    mt.pUnk                 = NULL;
    mt.cbFormat             = sizeof(WAVEFORMATEX);
    mt.pbFormat             = (BYTE*)&wfx;

    // set the format of the audio capture terminal.
    if (FAILED(hr = pIAMStreamConfig->SetFormat(&mt)))
    {
        LOG((MSP_ERROR, "SetFormat returns error: %8x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    )
/*++

Routine Description:

    Set the audio capture buffer size. The buffer size
    determins how many milliseconds worth of samples are contained 
    in a buffer.

Arguments:
    
    pIUnknown - an object that supports IAMBufferNegotiation.

    dwNumBuffers - the number of buffers to be allocated. Too few buffers
    might cause starvation on the capture device.

    dwBufferSize - The size of each buffer.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetAudioBufferSize, dwNumBuffers %d, dwBuffersize %d",
        dwNumBuffers, dwBufferSize));

    _ASSERTE(dwNumBuffers != 0 && dwBufferSize != 0);

    HRESULT hr;

    CComPtr<IAMBufferNegotiation> pBN;
    if (FAILED(hr = pIUnknown->QueryInterface(
            IID_IAMBufferNegotiation,
            (void **)&pBN
            )))
    {
        LOG((MSP_ERROR, "Can't get buffer negotiation.%8x", hr));
        return hr;
    }

    ALLOCATOR_PROPERTIES prop;

    // Set the number of buffers.
    prop.cBuffers = dwNumBuffers;
    prop.cbBuffer = dwBufferSize;

    prop.cbAlign  = -1;
    prop.cbPrefix = -1;

    if (FAILED(hr = pBN->SuggestAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "SuggestAllocatorProperties returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "SetAudioBuffersize"
            " buffers: %d, buffersize: %d, align: %d, Prefix: %d",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
            ));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323util.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    MSPCall.h

Abstract:

    Definitions for MSP utililty functions. There are all related to 
    active movie filter manipulation.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __MSPUTIL_H
#define __MSPUTIL_H

const DWORD PAYLOAD_G711U   = 0;
const DWORD PAYLOAD_G723    = 4;
const DWORD PAYLOAD_G711A   = 8;
const DWORD PAYLOAD_H261    = 31;
const DWORD PAYLOAD_H263    = 34;

const TCHAR gszSDPMSPKey[]   =
   _T("Software\\Microsoft\\Windows\\CurrentVersion\\H323MSP\\");


HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE
    );

HRESULT
AddFilter(
    IN  IGraphBuilder *     pIGraph,
    IN  const CLSID &       Clsid,
    IN  LPCWSTR             pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    );

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBandwidth,
    IN BOOL             bReceive,
    IN BOOL             bCIF = FALSE
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter1, 
    IN IBaseFilter *    pIFilter2,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pIFilter,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter
    );

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt);


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    );

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    );

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED_)
#define AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <mspbase.h>
#include <winsock2.h>

#include <streams.h>    // for amvideo stuff
#include <mmreg.h>      // for WAVEFORMATEX

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\resource.h ===
#ifndef __RESOURCE_h_
#define __RESOURCE_h_

#define IDS_PROJNAME                  100
#define IDR_H323MSP                   101

#define IDS_AUDIO_CAPTURE_STREAM      102
#define IDS_AUDIO_RENDER_STREAM       103
#define IDS_VIDEO_CAPTURE_STREAM      104
#define IDS_VIDEO_RENDER_STREAM       105

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323vid.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    H323vid.cpp

Abstract:

    This module contains implementation of the video send and receive
    stream implementations.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"
#include "common.h"

#include <irtprph.h>    // for IRTPRPHFilter
#include <irtpsph.h>    // for IRTPSPHFilter
#include <amrtpuid.h>   // AMRTP media types
#include <amrtpnet.h>   // rtp guilds
#include <ih26xcd.h>    // for the h26X encoder filter

#include <initguid.h>
#include <amrtpdmx.h>   // demux guild

#include <viduids.h>    // for video CLSIDs

const DWORD c_SlowLinkSpeed = 40000;

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamVideoRecv
//
/////////////////////////////////////////////////////////////////////////////

CStreamVideoRecv::CStreamVideoRecv()
    : CH323MSPStream(),
      m_dwCurrentBitRate(0),
      m_dwProposedBitRate(0)
{
    m_szName = L"VideoRecv";
    m_dwLastIFrameRequestedTime = timeGetTime();
    m_dwIFramePending = FALSE;
}

HRESULT CStreamVideoRecv::Configure(
    IN HANDLE          htChannel,
    IN STREAMSETTINGS &StreamSettings
    )
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv configure entered."));

    CLock lock(m_lock);
    
    _ASSERTE(m_fIsConfigured == FALSE);

    switch (StreamSettings.dwPayloadType)
    {
    case PAYLOAD_H261:

        m_pClsidCodecFilter  = &CLSID_H261_DECODE_FILTER;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_H261; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHH26X;
        break;

    case PAYLOAD_H263:

        m_pClsidCodecFilter  = &CLSID_H263_DECODE_FILTER;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_H263; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHH26X;

        break;

    default:
        LOG((MSP_ERROR, "unknow payload type, %x", StreamSettings.dwPayloadType));
        return E_FAIL;
    }
    
    m_Settings      = StreamSettings;
    m_htChannel     = htChannel;
    m_fIsConfigured = TRUE;
    m_dwCurrentBitRate = m_Settings.Video.dwMaxBitRate;
    m_dwProposedBitRate = m_dwCurrentBitRate;

    InternalConfigure();

    return S_OK;
}

HRESULT CStreamVideoRecv::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clcokrate, etc.

Arguments:
    
    pIBaseFilter - The source RTP Filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv ConfigureRTPFilter"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set locol Address:%x", m_Settings.dwIPLocal));

    // Set the local address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SelectLocalIPAddress(
        htonl(m_Settings.dwIPLocal)
        )))
    {
        LOG((MSP_ERROR, "set locol Address, hr:%x", hr));
        return hr;
    }

    LOG((MSP_INFO, "set remote Address:%x, port:%d", 
        m_Settings.dwIPRemote, m_Settings.wRTPPortRemote));

    // Set the remote address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SetAddress(
        htons(m_Settings.wRTPPortLocal),    // local port.
        0,                                  // remote port.
        htonl(m_Settings.dwIPRemote)        // remote address.
        )))
    {
        LOG((MSP_ERROR, "set remote Address, hr:%x", hr));
        return hr;
    }

 // Get the IRTCPStream interface pointer.
    CComQIPtr<IRTCPStream, 
        &IID_IRTCPStream> pIRTCPStream(pIBaseFilter);
    if (pIRTCPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTCP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set remote RTCP Address:%x, port:%d, local port: %d", 
            m_Settings.dwIPRemote, m_Settings.wRTCPPortRemote, 
            m_Settings.wRTCPPortLocal));

    // Set the remote RTCP address and port.
    if (FAILED(hr = pIRTCPStream->SetRTCPAddress(
        htons(m_Settings.wRTCPPortLocal), 
        htons(m_Settings.wRTCPPortRemote),
        htonl(m_Settings.dwIPRemote)
        )))
    {
        LOG((MSP_ERROR, "set remote RTCP Address, hr:%x", hr));
        return hr;
    }
    
    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastScope(DEFAULT_TTL)))
    {
        LOG((MSP_ERROR, "set TTL. %x", hr));
        return hr;
    }

    // Set the priority of the session
    if (FAILED(hr = pIRTPStream->SetSessionClassPriority(
        RTP_CLASS_VIDEO,
        g_dwVideoThreadPriority
        )))
    {
        LOG((MSP_ERROR, "set session class and priority. %x", hr));
    }

    // Set the sample rate of the session
    LOG((MSP_INFO, "setting session sample rate to %d", g_dwVideoSampleRateHigh));
    
    if (FAILED(hr = pIRTPStream->SetDataClock(g_dwVideoSampleRateHigh)))
    {
        LOG((MSP_ERROR, "set session sample rate. %x", hr));
    }

    // Enable the RTCP events.
    if (FAILED(hr = ::EnableRTCPEvents(pIBaseFilter)))
    {
        LOG((MSP_WARN, "can not enable RTCP events %x", hr));
    }

    if (FAILED(hr = ::SetQOSOption(
        pIBaseFilter,
        m_Settings.dwPayloadType,        // payload
        m_Settings.Video.dwMaxBitRate,
        TRUE
        )))
    {
        LOG((MSP_ERROR, "set QOS option. %x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SetUpInternalFilters()
/*++

Routine Description:

    set up the filters used in the stream.

    RTP->Demux->RPH->DECODER->Render terminal

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv.SetUpInternalFilters"));

    CComPtr<IBaseFilter> pSourceFilter;

    HRESULT hr;

    // create and add the source fitler.
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_RTPSourceFilter, 
            L"RtpSource", 
            &pSourceFilter)))
    {
        LOG((MSP_ERROR, "adding source filter. %x", hr));
        return hr;
    }

    if (FAILED(hr = ConfigureRTPFilter(pSourceFilter)))
    {
        LOG((MSP_ERROR, "configure RTP source filter. %x", hr));
        return hr;
    }

    // Create and add the payload handler into the filtergraph.
    CComPtr<IBaseFilter> pIRPHFilter;

    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidPHFilter, 
        L"RPH", 
        &pIRPHFilter
        )))
    {
        LOG((MSP_ERROR, "add RPH filter. %x", hr));
        return hr;
    }

     // Get the IRPHH26XSettings interface used in H323iguring the RPH 
    // filter to the right image size.
    CComQIPtr<IRPHH26XSettings, 
        &IID_IRPHH26XSettings> pIRPHH26XSettings(pIRPHFilter);
    if (pIRPHH26XSettings == NULL)
    {
        LOG((MSP_WARN, "can't get IRPHH26XSettings interface"));
    }
    else if (FAILED(pIRPHH26XSettings->SetCIF(m_Settings.Video.bCIF)))
    {
        LOG((MSP_WARN, "can't set CIF or QCIF"));
    }
            
    // Get the IRTPRPHFilter interface.
    CComQIPtr<IRTPRPHFilter, &IID_IRTPRPHFilter>pIRTPRPHFilter(pIRPHFilter);
    if (pIRTPRPHFilter == NULL)
    {
        LOG((MSP_ERROR, "get IRTPRPHFilter interface"));
        return hr;
    }

    if (FAILED(hr = pIRTPRPHFilter->OverridePayloadType(
        (BYTE)m_Settings.dwPayloadType
        )))
    {
        LOG((LOG_ERROR, "override payload type. %x", hr));
        return FALSE;
    }

    // Connect the payload handler to the output pin on the source filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pSourceFilter, 
        (IBaseFilter *)pIRPHFilter
        )))
    {
        LOG((MSP_ERROR, "connect demux and RPH filter. %x", hr));
        return hr;
    }

    CComPtr<IBaseFilter> pCodecFilter;

    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidCodecFilter, 
        L"codec", 
        &pCodecFilter
        )))
    {
        LOG((MSP_ERROR, "add Codec filter. %x", hr));
        return hr;
    }

    // Connect the payload handler to the output pin on the demux.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pIRPHFilter, 
        (IBaseFilter *)pCodecFilter
        )))
    {
        LOG((MSP_ERROR, "connect RPH filter and codec. %x", hr));
        return hr;
    }

    m_pEdgeFilter = pCodecFilter;
    m_pEdgeFilter->AddRef();

    return hr;
}

HRESULT CStreamVideoRecv::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the codec to the video render terminal.

Arguments:
    
    pITTerminal - The terminal to be connected.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv.ConnectTerminal, pTerminal %p", pITTerminal));

    HRESULT hr;

    // if our filters have not been contructed, do it now.
    if (m_pEdgeFilter == NULL)
    {
        hr = SetUpInternalFilters();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
            
            CleanUpFilters();

            return hr;
        }
    }

    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);
        
        return E_NOINTERFACE;
    }

    // try to disable DDraw because the decoders can't handle DDraw now.
    HRESULT hr2; 
    IDrawVideoImage *pIDrawVideoImage;
    hr2 = pTerminal->QueryInterface(IID_IDrawVideoImage, (void **)&pIDrawVideoImage); 
    if (SUCCEEDED(hr2))
    {
        hr2 = pIDrawVideoImage->DrawVideoImageBegin();
        if (FAILED(hr2))
        {
            LOG((MSP_WARN, "Can't disable DDraw. %x", hr2));
        }
        else
        {
            LOG((MSP_INFO, "DDraw disabled."));
        }
        
        pIDrawVideoImage->Release();
    }
    else
    {
        LOG((MSP_WARN, "Can't get IDrawVideoImage. %x", hr2));
    }

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        return hr;
    }

    // the number of pins should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    // Connect the codec filter to the video render terminal.
    hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)m_pEdgeFilter, 
        (IPin *)Pins[0],
        FALSE               // use Connect instead of ConnectDirect.
        );

    // release the refcounts on the pins.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "connect to the codec filter. %x", hr));

        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return hr;
    }
    
    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamVideoRecv::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv.SetUpFilters"));

    // we only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr;

    // Connect the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect the terminal. %x", hr));

        return hr;
    }

    return hr;
}

HRESULT CStreamVideoRecv::HandlePacketReceiveLoss(
    IN DWORD dwLossRate
    )
{
    LOG((MSP_TRACE, "%ls HandlePacketReceiveLoss, lossRate:%d", 
        m_szName, dwLossRate));

    CLock lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    DWORD dwCurrentTime = timeGetTime();

    if (dwLossRate == 0)
    {
        if (m_dwIFramePending)
        {
            ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
                H323MSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND, 
                (ITStream *)this, 
                m_htChannel
                );

            m_dwLastIFrameRequestedTime = dwCurrentTime;
            m_dwIFramePending = 0;
        }

        if (m_dwCurrentBitRate >= m_Settings.Video.dwMaxBitRate)
        {
            return S_OK;
        }

        // Adjust the proposed bitrate and
        m_dwProposedBitRate += BITRATEINC;
        if (m_dwProposedBitRate > m_Settings.Video.dwMaxBitRate)
        {
            m_dwProposedBitRate = m_Settings.Video.dwMaxBitRate;
        }

        if ((m_dwProposedBitRate - m_dwCurrentBitRate >= BITRATEDELTA)
            || (m_dwProposedBitRate == m_Settings.Video.dwMaxBitRate))
        {
            m_dwCurrentBitRate = m_dwProposedBitRate;

            // Tell the TSP to send a new flow control command.
            ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
                H323MSP_FLOW_CONTROL_COMMAND, 
                (ITStream *)this, 
                m_htChannel,
                (m_dwMediaType == TAPIMEDIATYPE_AUDIO) ? MEDIA_AUDIO : MEDIA_VIDEO,
                0,
                m_dwCurrentBitRate
                );
    
            LOG((MSP_INFO, "%ls New bitrate:%d", m_szName, m_dwCurrentBitRate));
        }

        return S_OK;
    }

    _ASSERTE(dwLossRate < 100);

    m_dwProposedBitRate = (DWORD)(m_dwCurrentBitRate / 100.0 * (100 - dwLossRate));

    if (m_dwProposedBitRate < BITRATELOWERLIMIT)
    {
        // we don't want the bitRate to go too low.
        m_dwProposedBitRate = BITRATELOWERLIMIT;

        // TODO, if this happens too many times, close the channel.
    }

    if (m_dwCurrentBitRate - m_dwProposedBitRate >= BITRATEDELTA)
    {
        m_dwCurrentBitRate = m_dwProposedBitRate;

        // Tell the TSP to send a new flow control command.
        ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
            H323MSP_FLOW_CONTROL_COMMAND, 
            (ITStream *)this, 
            m_htChannel,
            (m_dwMediaType == TAPIMEDIATYPE_AUDIO) ? MEDIA_AUDIO : MEDIA_VIDEO,
            0,
            m_dwCurrentBitRate
            );
        LOG((MSP_INFO, "%ls New bitrate:%d", m_szName, m_dwCurrentBitRate));
    }

    if (dwCurrentTime - m_dwLastIFrameRequestedTime > IFRAMEINTERVAL)
    {
        ((CH323MSPCall*)m_pMSPCall)->SendTSPMessage(
            H323MSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND, 
            (ITStream *)this, 
            m_htChannel
            );

        m_dwLastIFrameRequestedTime = dwCurrentTime;
        m_dwIFramePending = 0;
    }
    else
    {
        // Remember that we need to send an I Frame request when time arrives.
        m_dwIFramePending = 1;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamVideoSend
//
/////////////////////////////////////////////////////////////////////////////
CStreamVideoSend::CStreamVideoSend()
    : CH323MSPStream(),
      m_pIEncoderFilter(NULL),
      m_dwCurrentBitRate(0),
      m_dwProposedBitRate(0)
{
    m_szName = L"VideoSend";
    m_dwIFramePending = FALSE;
    m_dwLastIFrameSentTime = timeGetTime();
}

HRESULT CStreamVideoSend::ShutDown()
/*++

Routine Description:

    Shut down the stream. Release our members and then calls the base class's
    ShutDown method.

Arguments:
    

Return Value:

S_OK
--*/
{
    CLock lock(m_lock);

    if (m_pIEncoderFilter)
    {
        m_pIEncoderFilter->Release();
        m_pIEncoderFilter = NULL;
    }

    return CH323MSPStream::ShutDown();
}

HRESULT CStreamVideoSend::Configure(
    IN HANDLE          htChannel,
    IN STREAMSETTINGS &StreamSettings
    )
/*++

Routine Description:

    Configure this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.Configure"));

    CLock lock(m_lock);

    _ASSERTE(m_fIsConfigured == FALSE);

    switch (StreamSettings.dwPayloadType)
    {
    case PAYLOAD_H261:

        m_pClsidCodecFilter  = &CLSID_H261_ENCODE_FILTER;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_H261; 
        m_pClsidPHFilter     = &CLSID_INTEL_SPHH26X;

        break;

    case PAYLOAD_H263:

        m_pClsidCodecFilter  = &CLSID_H263_ENCODE_FILTER;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_H263; 
        m_pClsidPHFilter     = &CLSID_INTEL_SPHH26X;

        break;

    default:
        LOG((MSP_ERROR, "unknow payload type, %x", StreamSettings.dwPayloadType));
        return E_FAIL;
    }
    
    m_Settings      = StreamSettings;
    m_htChannel     = htChannel;
    m_fIsConfigured = TRUE;

    m_dwCurrentBitRate  = m_Settings.Video.dwStartUpBitRate;
    m_dwProposedBitRate = m_dwCurrentBitRate;

    InternalConfigure();

    return S_OK;
}

HRESULT 
SetVideoFormat(
    IN      IUnknown *  pIUnknown,
    IN      BOOL        bCIF,
    IN      DWORD       dwFramesPerSecond
    )
/*++

Routine Description:

    Set the video format to be CIF or QCIF and also set the frames per second.

Arguments:
    
    pIUnknown - a capture terminal.

    bCIF                - CIF or QCIF.

    dwFramesPerSecond   - Frames per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetVideoFormat"));

    HRESULT hr;

    // first get eht IAMStreamConfig interface.
    CComPtr<IAMStreamConfig> pIAMStreamConfig;

    if (FAILED(hr = pIUnknown->QueryInterface(
        IID_IAMStreamConfig,
        (void **)&pIAMStreamConfig
        )))
    {
        LOG((MSP_ERROR, "Can't get IAMStreamConfig interface.%8x", hr));
        return hr;
    }
    
    // get the current format of the video capture terminal.
    AM_MEDIA_TYPE *pmt;
    if (FAILED(hr = pIAMStreamConfig->GetFormat(&pmt)))
    {
        LOG((MSP_ERROR, "GetFormat returns error: %8x", hr));
        return hr;
    }

    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
    if (pVideoInfo == NULL)
    {
        DeleteMediaType(pmt);
        return E_UNEXPECTED;
    }

    BITMAPINFOHEADER *pHeader = HEADER(pmt->pbFormat);
    if (pHeader == NULL)
    {
        DeleteMediaType(pmt);
        return E_UNEXPECTED;
    }

    LOG((MSP_INFO,
        "Video capture: Format BitRate: %d, TimePerFrame: %d",
        pVideoInfo->dwBitRate,
        pVideoInfo->AvgTimePerFrame));

    LOG((MSP_INFO, "Video capture: Format Compression:%c%c%c%c %dbit %dx%d",
        (DWORD)pHeader->biCompression & 0xff,
        ((DWORD)pHeader->biCompression >> 8) & 0xff,
        ((DWORD)pHeader->biCompression >> 16) & 0xff,
        ((DWORD)pHeader->biCompression >> 24) & 0xff,
        pHeader->biBitCount,
        pHeader->biWidth,
        pHeader->biHeight));

    // The time is in 100ns unit.
    pVideoInfo->AvgTimePerFrame = (DWORD) 1e7 / dwFramesPerSecond;
    
    if (bCIF)
    {
        pHeader->biWidth = CIFWIDTH;
        pHeader->biHeight = CIFHEIGHT;
    }
    else
    {
        pHeader->biWidth = QCIFWIDTH;
        pHeader->biHeight = QCIFHEIGHT;
    }

#if defined(ALPHA)
    // update bmiSize with new Width/Height
    pHeader->biSizeImage = DIBSIZE( ((VIDEOINFOHEADER *)pmt->pbFormat)->bmiHeader );
#endif
    
    if (FAILED(hr = pIAMStreamConfig->SetFormat(pmt)))
    {
        LOG((MSP_ERROR, "putMediaFormat returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO,
            "Video capture: Format BitRate: %d, TimePerFrame: %d",
            pVideoInfo->dwBitRate,
            pVideoInfo->AvgTimePerFrame));

        LOG((MSP_INFO, "Video capture: Format Compression:%c%c%c%c %dbit %dx%d",
            (DWORD)pHeader->biCompression & 0xff,
            ((DWORD)pHeader->biCompression >> 8) & 0xff,
            ((DWORD)pHeader->biCompression >> 16) & 0xff,
            ((DWORD)pHeader->biCompression >> 24) & 0xff,
            pHeader->biBitCount,
            pHeader->biWidth,
            pHeader->biHeight));
    }

    DeleteMediaType(pmt);

    return hr;
}

HRESULT 
SetVideoBufferSize(
    IN IUnknown *pIUnknown
    )
/*++

Routine Description:

    Set the video capture terminal's buffersize.

Arguments:
    
    pIUnknown - a capture terminal.

Return Value:

    HRESULT

--*/
{
// The number of capture buffers is four for now.
#define NUMCAPTUREBUFFER 4

    LOG((MSP_TRACE, "SetVideoBufferSize"));

    HRESULT hr;

    CComPtr<IAMBufferNegotiation> pBN;
    if (FAILED(hr = pIUnknown->QueryInterface(
            IID_IAMBufferNegotiation,
            (void **)&pBN
            )))
    {
        LOG((MSP_ERROR, "Can't get buffer negotiation interface.%8x", hr));
        return hr;
    }

    ALLOCATOR_PROPERTIES prop;

#if 0   // Get allocator property is not working.
    if (FAILED(hr = pBN->GetAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "GetAllocatorProperties returns error: %8x", hr));
        return hr;
    }

    // Set the number of buffers.
    if (prop.cBuffers > NUMCAPTUREBUFFER)
    {
        prop.cBuffers = NUMCAPTUREBUFFER;
    }
#endif
    
    prop.cBuffers = NUMCAPTUREBUFFER;
    prop.cbBuffer = -1;
    prop.cbAlign  = -1;
    prop.cbPrefix = -1;

    if (FAILED(hr = pBN->SuggestAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "SuggestAllocatorProperties returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "SetVidedobuffersize"
            " buffers: %d, buffersize: %d, align: %d, Prefix: %d",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
            ));
    }
    return hr;
}

HRESULT CStreamVideoSend::ConfigureVideoCaptureTerminal(
    IN  ITTerminalControl*  pTerminal,
    OUT IPin **             ppIPin
    )
/*++

Routine Description:

    Given a terminal, find the capture pin and configure it.

Arguments:
    
    pTerminal - a capture terminal.

    ppIPin  - the address to store a pointer to a IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConfigureVideoCaptureTerminal, pTerminal %x", pTerminal));

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));
        return hr;
    }

    // Save the first pin and release the others.
    CComPtr <IPin> pIPin = Pins[0];
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    // set the video format.
    hr = SetVideoFormat(
        pIPin, 
        m_Settings.Video.bCIF, 
#ifdef TWOFRAMERATES
        (m_dwCurrentBitRate > c_SlowLinkSpeed) ? g_dwVideoSampleRateHigh
            : g_dwVideoSampleRateLow
#else
        g_dwVideoSampleRateHigh
#endif
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't set video format, %x", hr));
        return hr;
    }

    // set the video buffer size.
    hr = SetVideoBufferSize(
        pIPin
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't set aduio capture buffer size, %x", hr));
        return hr;
    }

    pIPin->AddRef();
    *ppIPin = pIPin;

    return hr;
}

HRESULT CStreamVideoSend::FindPreviewInputPin(
    IN  ITTerminalControl*  pTerminal,
    OUT IPin **             ppIPin
    )
/*++

Routine Description:

    Find the input pin on a preview terminal.

Arguments:
    
    pTerminal - a video render terminal.

    ppIPin  - the address to store a pointer to a IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "VideoSend.FindPreviewInputPin, pTerminal %x", pTerminal));

    // Get the pins from the first terminal because we only use on terminal
    // on this stream.
    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));
        return hr;
    }

    // Save the first pin and release the others.
    CComPtr <IPin> pIPin = Pins[0];
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    pIPin->AddRef();
    *ppIPin = pIPin;

    return hr;
}
HRESULT CStreamVideoSend::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:
    
    Check if the terminal is allowed on this stream.
    VideoSend allows both a capture terminal and a preivew terminal.

Arguments:

    pTerminal   - the terminal.

Return value:

    HRESULT.
    S_OK means the terminal is OK.
*/
{
    LOG((MSP_TRACE, "VideoSend.CheckTerminalTypeAndDirection"));

    // This stream only support one capture + one preview terminal
    if (m_Terminals.GetSize() > 1)
    {
        return TAPI_E_MAXTERMINALS;
    }

    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (m_Terminals.GetSize() > 0)
    {
        // check the direction of this terminal.
        TERMINAL_DIRECTION Direction2;
        hr = m_Terminals[0]->get_Direction(&Direction2);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
            return TAPI_E_INVALIDTERMINAL;
        }
        if (Direction == Direction2)
        {
            LOG((MSP_ERROR, 
                "can't have two terminals with the same direction. %x", hr));
            return TAPI_E_MAXTERMINALS;
        }
    }
    return S_OK;
}

HRESULT CStreamVideoSend::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.SetUpFilters"));

    // we only support one capture terminal and one preview 
    // window on this stream.
    if (m_Terminals.GetSize() > 2)
    {
        return E_UNEXPECTED;
    }

    int iCaptureIndex = -1, iPreviewIndex = -1;

    // Find out which terminal is capture and which is preview.
    HRESULT hr;
    for (int i = 0; i < m_Terminals.GetSize(); i ++)
    {
        TERMINAL_DIRECTION Direction;
        hr = m_Terminals[i]->get_Direction(&Direction);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, m_Terminals[i]);
        
            return hr;
        }
        if (Direction == TD_CAPTURE)
        {
            iCaptureIndex = i;
        }
        else
        {
            iPreviewIndex = i;
        }
    }

    // the stream will not work without a capture terminal.
    if (iCaptureIndex == -1)
    {
        LOG((MSP_ERROR, "no capture terminal selected."));
        return E_UNEXPECTED;
    }

    // Connect the capture filter to the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[iCaptureIndex]
        )))
    {
        LOG((MSP_ERROR, "connect the codec filter to terminal. %x", hr));

        return hr;
    }

    if (iPreviewIndex != -1)
    {
        // Connect the preview filter to the terminal.
        if (FAILED(hr = ConnectTerminal(
            m_Terminals[iPreviewIndex]
            )))
        {
            LOG((MSP_ERROR, "connect the codec filter to terminal. %x", hr));

            return hr;
        }
    }

    return hr;
}

HRESULT CStreamVideoSend::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clcokrate, etc.

Arguments:
    
    pIBaseFilter - The source RTP Filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.ConfigureRTPFilter"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set locol Address:%x", m_Settings.dwIPLocal));

    // Set the local address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SelectLocalIPAddress(
        htonl(m_Settings.dwIPLocal)
        )))
    {
        LOG((MSP_ERROR, "set locol Address, hr:%x", hr));
        return hr;
    }

    LOG((MSP_INFO, "set remote Address:%x, port:%d, TTL:%d", 
        m_Settings.dwIPRemote, m_Settings.wRTPPortRemote, DEFAULT_TTL));

    // Set the address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SetAddress(
        0,                                  // local port.
        htons(m_Settings.wRTPPortRemote),   // remote port.
        htonl(m_Settings.dwIPRemote)        // remote IP.
        )))
    {
        LOG((MSP_ERROR, "set remote Address, hr:%x", hr));
        return hr;
    }

    // Get the IRTCPStream interface pointer.
    CComQIPtr<IRTCPStream, 
        &IID_IRTCPStream> pIRTCPStream(pIBaseFilter);
    if (pIRTCPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTCP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set remote RTCP Address:%x, port:%d, local port:%d", 
            m_Settings.dwIPRemote, m_Settings.wRTCPPortRemote, 
            m_Settings.wRTCPPortLocal));

    // Set the remote RTCP address and port.
    if (FAILED(hr = pIRTCPStream->SetRTCPAddress(
        htons(m_Settings.wRTCPPortLocal), 
        htons(m_Settings.wRTCPPortRemote), 
        htonl(m_Settings.dwIPRemote)
        )))
    {
        LOG((MSP_ERROR, "set remote RTCP Address, hr:%x", hr));
        return hr;
    }
    
    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastScope(DEFAULT_TTL)))
    {
        LOG((MSP_ERROR, "set TTL. %x", hr));
        return hr;
    }

    // Set the priority of the session
    if (FAILED(hr = pIRTPStream->SetSessionClassPriority(
        RTP_CLASS_VIDEO,
        g_dwVideoThreadPriority
        )))
    {
        LOG((MSP_ERROR, "set session class and priority. %x", hr));
    }

    // Set the sample rate of the session
#ifdef TWOFRAMERATES
    LOG((MSP_INFO, "setting session sample rate to %d", 
        (m_dwCurrentBitRate > c_SlowLinkSpeed) ? g_dwVideoSampleRateHigh
            : g_dwVideoSampleRateLow
        ));
#else
    LOG((MSP_INFO, "setting session sample rate to %d", 
        g_dwVideoSampleRateHigh
        ));
#endif
    
#ifdef TWOFRAMERATES
    if (FAILED(hr = pIRTPStream->SetDataClock(
        (m_dwCurrentBitRate > c_SlowLinkSpeed) ? g_dwVideoSampleRateHigh
            : g_dwVideoSampleRateLow
        )))
#else
    if (FAILED(hr = pIRTPStream->SetDataClock(
        g_dwVideoSampleRateHigh
        )))
#endif
    {
        LOG((MSP_ERROR, "set session sample rate. %x", hr));
    }

    // Enable the RTCP events
    if (FAILED(hr = ::EnableRTCPEvents(pIBaseFilter)))
    {
        LOG((MSP_WARN, "can not enable RTCP events %x", hr));
    }

    if (FAILED(hr = ::SetQOSOption(
        pIBaseFilter,
        m_Settings.dwPayloadType,         // payload
        m_Settings.Video.dwMaxBitRate,
        FALSE
        )))
    {
        LOG((MSP_ERROR, "set QOS option. %x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamVideoSend::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the video terminals to the stream.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.ConnectTerminal %x", pITTerminal));

    // Get the TerminalControl interface on the terminal
    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));
        
        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);

        return E_NOINTERFACE;
    }

    // Find out the direction of the terminal.
    TERMINAL_DIRECTION Direction;
    HRESULT hr = pITTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
    
        return hr;
    }

    if (Direction == TD_CAPTURE)
    {
        // find the capture pin on the capture terminal and configure it.
        CComPtr<IPin>   pCapturePin;
        hr = ConfigureVideoCaptureTerminal(pTerminal, &pCapturePin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "configure video capture termianl failed. %x", hr));

            SendStreamEvent(CALL_TERMINAL_FAIL, 
                CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
            return hr;
        }

        hr = CreateSendFilters(pCapturePin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Create video send filters failed. %x", hr));

            // disconnect the terminal.
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            // clean up internal filters as well.
            CleanUpFilters();

            return hr;
        }

        //
        // Now we are actually connected. Update our state and perform postconnection
        // (ignore postconnection error code).
        //
        pTerminal->CompleteConnectTerminal();

    }
    else
    {
        // find the input pin on the preview window. If there is no preview window,
        // we just pass in NULL for the next function.
        CComPtr<IPin>   pPreviewInputPin;

        hr = FindPreviewInputPin(pTerminal, &pPreviewInputPin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "find preview input pin failed. %x", hr));

            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
            return hr;
        }

        hr = ConnectPreview(pPreviewInputPin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Create video send filters failed. %x", hr));

            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            return hr;
        }

        //
        // Now we are actually connected. Update our state and perform postconnection
        // (ignore postconnection error code).
        //
        pTerminal->CompleteConnectTerminal();

    }
    return hr;
}

HRESULT 
EncoderDoCommand(
    IN IBaseFilter *    pIFilter,
    IN ENCODERCOMMAND   command,
    IN DWORD            dwParam1
    )
/*++

Routine Description:

    Set the video capture terminal's buffersize.

Arguments:
    
    pIFilter  - a H26x encoder.

    command   - the command needs to be performed on the encoder.

    dwparam1  - the parameter.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "EncoderDoCommand, command:%d, param1: %d", 
        command, dwParam1));

    HRESULT hr;

    CComPtr<IH26XEncoderControl> pIH26XEncoderControl;
    if (FAILED(hr = pIFilter->QueryInterface(
        IID_IH26XEncoderControl, 
        (void **)&pIH26XEncoderControl
        )))
    {
        LOG((MSP_ERROR, "Can't get pIH26XEncoderControl interface.%8x", hr));
        return hr;
    }
    
    // get the current encoder properties of the video capture terminal.
    ENC_CMP_DATA prop;
    if (FAILED(hr = pIH26XEncoderControl->get_EncodeCompression(&prop)))
    {
        LOG((MSP_ERROR, "get_EncodeCompression returns error: %8x", hr));
        return hr;
    }

    LOG((MSP_INFO, 
        "Video encoder::get_EncodeCompression"
        " FrameRate: %d, DataRate: %d, Width %d, bSendKey: %s, interval: %d, Quality: %d",
        prop.dwFrameRate,
        prop.dwDataRate,
        prop.dwWidth,
        prop.bSendKey ? "TRUE" : "FALSE",
        prop.dwKeyFrameInterval,
        prop.dwQuality
        ));

    switch (command) 
    {
    case EC_BITRATE:
        prop.bFrameSizeBRC  = FALSE;          // control bit rate
        prop.dwDataRate = dwParam1 / 1000;  // in kbps
        break;

    case EC_IFRAME:
        prop.bSendKey       = TRUE;
        break;
    }
    
    if (FAILED(hr = pIH26XEncoderControl->set_EncodeCompression(&prop)))
    {
        LOG((MSP_ERROR, "set_EncodeCompression returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "Video encoder::set_EncodeCompression"
            " FrameRate: %d, DataRate: %d, Width %d, bSendKey: %s, interval: %d, Quality: %d",
            prop.dwFrameRate,
            prop.dwDataRate,
            prop.dwWidth,
            prop.bSendKey ? "TRUE" : "FALSE",
            prop.dwKeyFrameInterval,
            prop.dwQuality
            ));

    }
    return hr;
}


HRESULT 
ConfigureEncoder(
    IN IBaseFilter *    pIFilter,
    IN BOOL             bCIF,
    IN DWORD            dwMaxBitRate,
    IN DWORD            dwFramesPerSecond
    )
/*++

Routine Description:

    Set the video capture terminal's buffersize.

Arguments:
    
    pIFilter            - a H26x encoder.

    bCIF                - CIF or QCIF.

    pdwFramesPerSecond  - Frames per second.

    dwKeyFrameInterval  - The number of frames before sending a key frame.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConfigureEncoder, dwMaxBitRate :%d", dwMaxBitRate));

    HRESULT hr;

    CComPtr<IH26XEncoderControl> pIH26XEncoderControl;
    if (FAILED(hr = pIFilter->QueryInterface(
        IID_IH26XEncoderControl, 
        (void **)&pIH26XEncoderControl
        )))
    {
        LOG((MSP_ERROR, "Can't get pIH26XEncoderControl interface.%8x", hr));
        return hr;
    }
    
    // get the current encoder properties of the video capture terminal.
    ENC_CMP_DATA prop;
    if (FAILED(hr = pIH26XEncoderControl->get_EncodeCompression(&prop)))
    {
        LOG((MSP_ERROR, "get_EncodeCompression returns error: %8x", hr));
        return hr;
    }

    LOG((MSP_INFO, 
        "Video encoder::get_EncodeCompression"
        " FrameRate: %d, DataRate: %d, Width %d, bSendKey: %s, interval: %d, Quality: %d",
        prop.dwFrameRate,
        prop.dwDataRate,
        prop.dwWidth,
        prop.bSendKey ? "TRUE" : "FALSE",
        prop.dwKeyFrameInterval,
        prop.dwQuality
        ));

    prop.bSendKey           = TRUE;
    prop.dwFrameRate        = dwFramesPerSecond;
    prop.bFrameSizeBRC      = FALSE;                // control bit rate
    prop.dwQuality          = 8500;
    prop.dwDataRate         = dwMaxBitRate / 1000;  // in kbps
    prop.dwKeyFrameInterval = 9999999;              // don't send Keyframes.

    if (bCIF)
    {
        prop.dwWidth = CIFWIDTH;
    }
    else
    {
        prop.dwWidth = QCIFWIDTH;
    }
    if (FAILED(hr = pIH26XEncoderControl->set_EncodeCompression(&prop)))
    {
        LOG((MSP_ERROR, "set_EncodeCompression returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "Video encoder::set_EncodeCompression"
            " FrameRate: %d, DataRate: %d, Width %d, bSendKey: %s, interval: %d, Quality: %d",
            prop.dwFrameRate,
            prop.dwDataRate,
            prop.dwWidth,
            prop.bSendKey ? "TRUE" : "FALSE",
            prop.dwKeyFrameInterval,
            prop.dwQuality
            ));

    }
    return hr;
}

HRESULT CStreamVideoSend::ConnectPreview(
    IN    IPin          *pPreviewInputPin
    )
/*++

Routine Description:

    connect the preview pin the the TEE filter.

    Capturepin->TEE+->Encoder->SPH->RTPRender
                   +->PreviewInputPin

Arguments:
    
    pPin - The output pin on the capture filter.

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    if (m_pEdgeFilter == NULL)
    {
        LOG((MSP_ERROR, "no capture to preview"));
        return E_UNEXPECTED;
    }

     // Create the AVI decompressor filter and add it into the graph.
    // This will make the graph construction faster for since the AVI
    // decompressor are always needed for the preview
    CComPtr<IBaseFilter> pAviFilter;
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_AVIDec,   
            L"Avi", 
            &pAviFilter)))
    {
        LOG((MSP_ERROR, "add Avi filter. %x", hr));
        return hr;
    }
    
   // connect the preview input pin with the smart tee filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)m_pEdgeFilter,
        (IPin *)pPreviewInputPin,
        FALSE       // not direct connect
        )))
    {
        LOG((MSP_ERROR, "connect preview input pin with the tee. %x", hr));
        return hr;
    }
    return hr;
}

HRESULT CStreamVideoSend::CreateSendFilters(
    IN    IPin          *pCapturePin
    )
/*++

Routine Description:

    Insert filters into the graph and connect to the capture pin.

    Capturepin->TEE+->Encoder->SPH->RTPRender
 
Arguments:
    
    pPin - The output pin on the capture filter.

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    if (m_pEdgeFilter)
    {
        // connect the capture pin with the smart tee filter.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IPin *)pCapturePin, 
            (IBaseFilter *)m_pEdgeFilter
            )))
        {
            LOG((MSP_ERROR, "connect capture pin with the tee. %x", hr));
            return hr;
        }
        return hr;
    }

    // Create the tee filter and add it into the graph.
    CComPtr<IBaseFilter> pTeeFilter;
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_SmartTee,   
//            CLSID_InfTee, 
            L"tee", 
            &pTeeFilter)))
    {
        LOG((MSP_ERROR, "add smart tee filter. %x", hr));
        return hr;
    }

    // connect the capture pin with the tee filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IPin *)pCapturePin, 
        (IBaseFilter *)pTeeFilter
        )))
    {
        LOG((MSP_ERROR, "connect capture pin with the tee. %x", hr));
        return hr;
    }

    // Create the codec filter and add it into the graph.
    CComPtr<IBaseFilter> pCodecFilter;

    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            *m_pClsidCodecFilter, 
            L"Encoder", 
            &pCodecFilter)))
    {
        LOG((MSP_ERROR, "add Codec filter. %x", hr));
        return hr;
    }

    // configure the encoder
#ifdef TWOFRAMERATES
    if (FAILED(hr = ::ConfigureEncoder(
        pCodecFilter, 
        m_Settings.Video.bCIF, 
        m_dwCurrentBitRate,
        (m_dwCurrentBitRate > c_SlowLinkSpeed) ? g_dwVideoSampleRateHigh
            : g_dwVideoSampleRateLow
        )))
#else
    if (FAILED(hr = ::ConfigureEncoder(
        pCodecFilter, 
        m_Settings.Video.bCIF, 
        m_dwCurrentBitRate,
        g_dwVideoSampleRateHigh
        )))
#endif
    {
        LOG((MSP_WARN, "Configure video encoder. %x", hr));
    }

    // connect the smart tee filter and the Codec filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pTeeFilter, 
        (IBaseFilter *)pCodecFilter
        )))
    {
        LOG((MSP_ERROR, "connect Tee filter and codec filter. %x", hr));
        return hr;
    }

    // Create the send payload handler and add it into the graph.
    CComPtr<IBaseFilter> pISPHFilter;
    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidPHFilter, 
        L"SPH", 
        &pISPHFilter
        )))
    {
        LOG((MSP_ERROR, "add SPH filter. %x", hr));
        return hr;
    }

    // Connect the Codec filter with the SPH filter .
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pCodecFilter, 
        (IBaseFilter *)pISPHFilter
        )))
    {
        LOG((MSP_ERROR, "connect codec filter and SPH filter. %x", hr));
        return hr;
    }

    // Get the IRTPSPHFilter interface.
    CComQIPtr<IRTPSPHFilter, 
        &IID_IRTPSPHFilter> pIRTPSPHFilter(pISPHFilter);
    if (pIRTPSPHFilter == NULL)
    {
        LOG((MSP_ERROR, "get IRTPSPHFilter interface"));
        return E_NOINTERFACE;
    }

    // Create the RTP render filter and add it into the graph.
    CComPtr<IBaseFilter> pRenderFilter;

    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_RTPRenderFilter, 
            L"RtpRender", 
            &pRenderFilter)))
    {
        LOG((MSP_ERROR, "adding render filter. %x", hr));
        return hr;
    }

    // Set the address for the render fitler.
    if (FAILED(hr = ConfigureRTPFilter(pRenderFilter)))
    {
        LOG((MSP_ERROR, "configure RTP Filter failed %x", hr));
        return hr;
    }

    // Connect the SPH filter with the RTP Render filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pISPHFilter, 
        (IBaseFilter *)pRenderFilter
        )))
    {
        LOG((MSP_ERROR, "connect SPH filter and Render filter. %x", hr));
        return hr;
    }

    // remember the first filter after the terminal 
    m_pEdgeFilter = pTeeFilter;
    m_pEdgeFilter->AddRef();

    m_pIEncoderFilter = pCodecFilter;
    m_pIEncoderFilter->AddRef();

    return S_OK;
}

HRESULT CStreamVideoSend::SendIFrame()
/*++

Routine Description:

    Now we got a I Frame request from the TSP. Use the encoder filter to 
    generate a I frame.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    if (!m_pIEncoderFilter)
    {
        return E_UNEXPECTED;
    }
    
    DWORD dwCurrentTime = timeGetTime();
    if (dwCurrentTime - m_dwLastIFrameSentTime > IFRAMEINTERVAL)
    {
        // this function always succeeds.
        EncoderDoCommand(m_pIEncoderFilter, EC_IFRAME, 0);

        m_dwLastIFrameSentTime = dwCurrentTime;
        m_dwIFramePending = 0;
    }
    else
    {
        m_dwIFramePending = 1;
    }
    
    return S_OK;
}

HRESULT CStreamVideoSend::ChangeMaxBitRate(
    IN  DWORD dwMaxBitRate
    )
/*++

Routine Description:

    The receiver set the max bit-rate to a new value.

Arguments:
    
    dwMaxBitRate - the new max bit rate requested by the other endpoint.

Return Value:

    S_OK;

--*/
{
    LOG((MSP_INFO, "new Max bitrate: %d", dwMaxBitRate));

    CLock lock(m_lock);

    m_Settings.Video.dwMaxBitRate = dwMaxBitRate;

    if (m_dwCurrentBitRate > m_Settings.Video.dwMaxBitRate)
    {
        m_dwCurrentBitRate = m_Settings.Video.dwMaxBitRate;

        if (m_pIEncoderFilter)
        {
            // this function always succeeds.
            EncoderDoCommand(
                m_pIEncoderFilter, EC_BITRATE, m_dwCurrentBitRate
                );
        }
    }
    return S_OK;
}

HRESULT CStreamVideoSend::HandlePacketTransmitLoss(
    IN DWORD dwLossRate
    )
/*++

Routine Description:

    .

Arguments:
    
    dwMaxBitRate - the new max bit rate requested by the other endpoint.

Return Value:

    S_OK;

--*/
{
    LOG((MSP_TRACE, "%ls HandlePacketTransmitLoss, lossRate:%d", 
        m_szName, dwLossRate));

    CLock lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    DWORD dwCurrentTime = timeGetTime();

    if (dwLossRate == 0)
    {
        if (m_dwIFramePending)
        {
            // this function always succeeds.
            EncoderDoCommand(m_pIEncoderFilter, EC_IFRAME, 0);
            m_dwLastIFrameSentTime = dwCurrentTime;
            m_dwIFramePending = 0;
        }

        if (m_dwCurrentBitRate >= m_Settings.Video.dwMaxBitRate)
        {
            return S_OK;
        }

        // Adjust the proposed bitrate and
        m_dwProposedBitRate += BITRATEINC;
        if (m_dwProposedBitRate > m_Settings.Video.dwMaxBitRate)
        {
            m_dwProposedBitRate = m_Settings.Video.dwMaxBitRate;
        }

        if ((m_dwProposedBitRate - m_dwCurrentBitRate >= BITRATEDELTA)
            || (m_dwProposedBitRate == m_Settings.Video.dwMaxBitRate))
        {
            m_dwCurrentBitRate = m_dwProposedBitRate;

            // this function always succeeds.
            EncoderDoCommand(
                m_pIEncoderFilter, EC_BITRATE, m_dwCurrentBitRate
                );
        }

        return S_OK;
    }

    _ASSERTE(dwLossRate < 100);

    m_dwProposedBitRate = (DWORD)(m_dwCurrentBitRate / 100.0 * (100 - dwLossRate));

    if (m_dwProposedBitRate < BITRATELOWERLIMIT)
    {
        // we don't want the bitRate to go too low.
        m_dwProposedBitRate = BITRATELOWERLIMIT;

        // TODO, if this happens too many times, close the channel.
    }

    if (m_dwCurrentBitRate - m_dwProposedBitRate >= BITRATEDELTA)
    {
        m_dwCurrentBitRate = m_dwProposedBitRate;

        // this function always succeeds.
        EncoderDoCommand(
            m_pIEncoderFilter, EC_BITRATE, m_dwCurrentBitRate
            );
    }

    if (dwCurrentTime - m_dwLastIFrameSentTime > IFRAMEINTERVAL)
    {
        // this function always succeeds.
        EncoderDoCommand(
            m_pIEncoderFilter, EC_IFRAME, 0
            );
        m_dwLastIFrameSentTime = dwCurrentTime;
        m_dwIFramePending = 0;
    }
    else
    {
        // Remember that we need to send an I Frame when time arrives.
        m_dwIFramePending = 1;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\address.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    address.c

Abstract:

    TAPI Service Provider functions related to manipulating addresses.

        TSPI_lineGetAddressCaps
        TSPI_lineGetAddressStatus

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "provider.h"
#include "version.h"
#include "line.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI procedures                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD             dwDeviceID,
    DWORD             dwAddressID,
    DWORD             dwTSPIVersion,
    DWORD             dwExtVersion,
    LPLINEADDRESSCAPS pAddressCaps
    )
    
/*++

Routine Description:

    This function queries the specified address on the specified line device 
    to determine its telephony capabilities.

    The line device IDs supported by a particular driver are numbered 
    sequentially starting at a value set by the TAPI DLL using the 
    TSPI_lineSetDeviceIDBase function.

    The version number supplied has been negotiated by the TAPI DLL using 
    TSPI_lineNegotiateTSPIVersion.

Arguments:

    dwDeviceID - Specifies the line device containing the address to be 
        queried.

    dwAddressID - Specifies the address on the given line device whose 
        capabilities are to be queried.

    dwTSPIVersion - Specifies the version number of the Telephony SPI to be 
        used. The high order word contains the major version number; the low 
        order word contains the minor version number.

    dwExtVersion - Specifies the version number of the service 
        provider-specific extensions to be used. This number can be left 
        zero if no device specific extensions are to be used. Otherwise, 
        the high order word contains the major version number; the low 
        order word contain the minor version number.

    pAddressCaps - Specifies a far pointer to a variable sized structure 
        of type LINEADDRESSCAPS. Upon successful completion of the request, 
        this structure is filled with address capabilities information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of the range 
            of line devices IDs supported by this driver.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_INCOMPATIBLEVERSION - The specified TSPI and/or extension 
            version number is not supported by the Service Provider for the 
            specified line device.

        LINEERR_INVALEXTVERSION - The app requested an invalid extension 
            version number.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    DWORD dwAddressSize;
    PH323_LINE pLine = NULL;

    // make sure this is a version we support    
    if (!H323ValidateTSPIVersion(dwTSPIVersion)) {

        // do not support tspi version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // make sure this is a version we support    
    if (!H323ValidateExtVersion(dwExtVersion)) {

        // do not support extensions 
        return LINEERR_INVALEXTVERSION;
    }

    // make sure address id is supported
    if (!H323IsValidAddressID(dwAddressID)) {

        // invalid address id
        return LINEERR_INVALADDRESSID;
    }

    // retrieve line device pointer from device id
    if (!H323GetLineFromIDAndLock(&pLine, dwDeviceID)) {

        // invalid line device id
        return LINEERR_BADDEVICEID;
    }

    // determine size of address name
    dwAddressSize = H323SizeOfWSZ(pLine->wszAddr);

    // calculate number of bytes needed
    pAddressCaps->dwNeededSize = sizeof(LINEADDRESSCAPS) + 
                                 dwAddressSize
                                 ;

    // validate buffer allocated is large enough
    if (pAddressCaps->dwTotalSize >= pAddressCaps->dwNeededSize) {

        // record amount of memory used
        pAddressCaps->dwUsedSize = pAddressCaps->dwNeededSize;

        // position address name after fixed portion
        pAddressCaps->dwAddressSize = dwAddressSize;
        pAddressCaps->dwAddressOffset = sizeof(LINEADDRESSCAPS);
    
        // copy address name after fixed portion
        memcpy((LPBYTE)pAddressCaps + pAddressCaps->dwAddressOffset, 
               (LPBYTE)pLine->wszAddr,
               pAddressCaps->dwAddressSize
               );
           
    } else if (pAddressCaps->dwTotalSize >= sizeof(LINEADDRESSCAPS)) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "lineaddresscaps structure too small for strings.\n"
            ));

        // record amount of memory used
        pAddressCaps->dwUsedSize = sizeof(LINEADDRESSCAPS);

    } else {
                                 
        H323DBG((
            DEBUG_LEVEL_ERROR,
            "lineaddresscaps structure too small.\n"
            ));

        // release line device
        H323UnlockLine(pLine);

        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "addr 0 capabilities requested.\n"
        ));
    
    // transfer associated device id 
    pAddressCaps->dwLineDeviceID = dwDeviceID;

    // initialize number of calls allowed per address 
    pAddressCaps->dwMaxNumActiveCalls = H323_MAXCALLSPERADDR;

    // initialize supported address capabilities
    pAddressCaps->dwAddressSharing     = H323_ADDR_ADDRESSSHARING;
    pAddressCaps->dwCallInfoStates     = H323_ADDR_CALLINFOSTATES;
    pAddressCaps->dwCallStates         = H323_ADDR_CALLSTATES;
    pAddressCaps->dwDisconnectModes    = H323_ADDR_DISCONNECTMODES;
    pAddressCaps->dwAddrCapFlags       = H323_ADDR_CAPFLAGS;
    pAddressCaps->dwCallFeatures       = H323_ADDR_CALLFEATURES;
    pAddressCaps->dwAddressFeatures    = H323_ADDR_ADDRFEATURES;
    pAddressCaps->dwCallerIDFlags      = H323_ADDR_CALLERIDFLAGS;
    pAddressCaps->dwCalledIDFlags      = H323_ADDR_CALLEDIDFLAGS;

    // initialize unsupported address capabilities
    pAddressCaps->dwConnectedIDFlags   = LINECALLPARTYID_UNAVAIL;
    pAddressCaps->dwRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    pAddressCaps->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    
    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS pAddressStatus
    )
    
/*++

Routine Description:

    This operation allows the TAPI DLL to query the specified address for its 
    current status.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        containing the address to be queried.

    dwAddressID - Specifies an address on the given open line device. 
        This is the address to be queried.

    pAddressStatus - Specifies a far pointer to a variable sized data 
        structure of type LINEADDRESSSTATUS.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified device handle is invalid.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    PH323_LINE pLine = NULL;

    // make sure address id is supported
    if (!H323IsValidAddressID(dwAddressID)) {

        // invalid address id
        return LINEERR_INVALADDRESSID;
    }

    // retrieve line device pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        // invalid line device handle
        return LINEERR_INVALLINEHANDLE;
    }

    // calculate the number of bytes required
    pAddressStatus->dwNeededSize = sizeof(LINEADDRESSSTATUS);

    // see if lineaddressstatus structure is of correct size
    if (pAddressStatus->dwTotalSize < pAddressStatus->dwNeededSize) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "lineaddressstatus structure too small.\n"
            ));

        // release line device
        H323UnlockLine(pLine);

        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    // record amount of memory used
    pAddressStatus->dwUsedSize = pAddressStatus->dwNeededSize;

    // transfer number of active calls from line device structure
    pAddressStatus->dwNumActiveCalls = pLine->pCallTable->dwNumInUse;
    
    // specify that outbound call is possible on the address
    pAddressStatus->dwAddressFeatures = H323_ADDR_ADDRFEATURES;    

    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\call.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    call.c

Abstract:

    TAPI Service Provider functions related to manipulating calls.

        TSPI_lineAnswer
        TSPI_lineCloseCall
        TSPI_lineDrop
        TSPI_lineGetCallAddressID
        TSPI_lineGetCallInfo
        TSPI_lineGetCallStatus
        TSPI_lineMakeCallMSP

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "provider.h"
#include "registry.h"
#include "termcaps.h"
#include "callback.h"
#include "line.h"
#include <h323tsp.h>
#include <h323pdu.h>
#include <iphlpapi.h>

WCHAR g_strAlias[MAX_ALIAS_LENGTH+1];
DWORD g_dwAliasLength = 0;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323CloseCallCommand(
    PH323_CALL pCall
    )

/*++

Routine Description:

    Sends CLOSE_CALL_COMMAND from TSP to MSP.

Arguments:

    pCall - Specifies a pointer to the associated call object.

Return Values:

    Returns true if successful.
    
--*/

{
    H323TSP_MESSAGE Message;

    // set the appropriate message type
    Message.Type = H323TSP_CLOSE_CALL_COMMAND;

    // send msp message
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_SENDMSPDATA,
        MSP_HANDLE_UNKNOWN,
        (DWORD_PTR)&Message,
        sizeof(Message)
        );

    // success
    return TRUE;
}


BOOL
H323AddU2U(
    PLIST_ENTRY pListHead,
    DWORD       dwDataSize,
    PBYTE       pData
    )
        
/*++

Routine Description:

    Create user user structure and adds to list.

Arguments:

    pListHead - Pointer to list in which to add user user info.

    dwDataSize - Size of buffer pointed to by pData.

    pData - Pointer to user user info.

Return Values:

    Returns true if successful.
    
--*/

{
    PH323_U2ULE pU2ULE;

    // validate data buffer pointer and size
    if ((pData != NULL) && (dwDataSize > 0)) {

        // allocate memory for user user info
        pU2ULE = H323HeapAlloc(dwDataSize + sizeof(H323_U2ULE));

        // validate pointer
        if (pU2ULE == NULL) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "could not allocate user user info.\n"
                ));

            // failure
            return FALSE;
        }

        // aim pointer at the end of the buffer by default
        pU2ULE->pU2U = (LPBYTE)pU2ULE + sizeof(H323_U2ULE);
        pU2ULE->dwU2USize = dwDataSize;

        // transfer user user info into list entry
        memcpy(pU2ULE->pU2U, pData, pU2ULE->dwU2USize);

        // add list entry to back of list
        InsertTailList(pListHead, &pU2ULE->Link);

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "added user user info 0x%08lx (%d bytes).\n",
            pU2ULE->pU2U,
            pU2ULE->dwU2USize
            ));
    }

    // success
    return TRUE;
}


BOOL
H323RemoveU2U(
    PLIST_ENTRY   pListHead,
    PH323_U2ULE * ppU2ULE
    )
        
/*++

Routine Description:

    Removes user user info structure from list.

Arguments:

    pListHead - Pointer to list in which to remove user user info.

    ppU2ULE - Pointer to pointer to list entry.

Return Values:

    Returns true if successful.
    
--*/

{
    PLIST_ENTRY pLE;

    // process list until empty
    if (!IsListEmpty(pListHead)) {

        // retrieve first entry
        pLE = RemoveHeadList(pListHead);

        // convert list entry to structure pointer
        *ppU2ULE = CONTAINING_RECORD(pLE, H323_U2ULE, Link);

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "removed user user info 0x%08lx (%d bytes).\n",
            (*ppU2ULE)->pU2U,
            (*ppU2ULE)->dwU2USize
            ));

        // success
        return TRUE;
    }

    // failure
    return FALSE;
}


BOOL
H323FreeU2U(
    PLIST_ENTRY pListHead
    )
        
/*++

Routine Description:

    Releases memory for user user list.

Arguments:

    pListHead - Pointer to list in which to free user user info.

Return Values:

    Returns true if successful.
    
--*/

{
    PLIST_ENTRY pLE;
    PH323_U2ULE pU2ULE;

    // process list until empty
    while (!IsListEmpty(pListHead)) {

        // retrieve first entry
        pLE = RemoveHeadList(pListHead);

        // convert list entry to structure pointer
        pU2ULE = CONTAINING_RECORD(pLE, H323_U2ULE, Link);

        //  release memory
        H323HeapFree(pU2ULE);
    }

    // success
    return TRUE;
}


BOOL
H323ResetCall(
    PH323_CALL pCall
    )
        
/*++

Routine Description:

    Resets call object to original state for re-use.

Arguments:

    pCall - Specifies a pointer to the call object to be reset.

Return Values:

    Returns true if successful.
    
--*/

{
    // reset state of call object
    pCall->nState = H323_CALLSTATE_ALLOCATED;

    // reset tapi info
    pCall->dwCallState       = LINECALLSTATE_UNKNOWN;
    pCall->dwCallStateMode   = 0;
    pCall->dwOrigin          = LINECALLORIGIN_UNKNOWN;
    pCall->dwAddressType     = 0;
    pCall->dwIncomingModes   = 0;
    pCall->dwOutgoingModes   = 0;
    pCall->dwRequestedModes  = 0;
    pCall->fMonitoringDigits = FALSE;

    pCall->dwAppSpecific     = 0;

    // reset tapi handles
    pCall->hdCall    = (HDRVCALL)NULL;
    pCall->htCall    = (HTAPICALL)NULL;

    // reset intelcc handles
    pCall->hccCall = UNINITIALIZED;
    pCall->hccConf = UNINITIALIZED;

    // reset link speeds
    pCall->dwLinkSpeed = UNINITIALIZED;

    // reset addresses
    memset(&pCall->ccCalleeAddr,0,sizeof(CC_ADDR));
    memset(&pCall->ccCallerAddr,0,sizeof(CC_ADDR));

    // release alias strings
    H323HeapFree(pCall->ccCalleeAlias.pData);
    H323HeapFree(pCall->ccCallerAlias.pData);

    // reset aliases
    memset(&pCall->ccCalleeAlias,0,sizeof(CC_ALIASITEM));
    memset(&pCall->ccCallerAlias,0,sizeof(CC_ALIASITEM));

    // reset remote caps
    memset(&pCall->ccRemoteAudioCaps,0,sizeof(CC_TERMCAP));
    memset(&pCall->ccRemoteVideoCaps,0,sizeof(CC_TERMCAP));

    // release user user information
    H323FreeU2U(&pCall->IncomingU2U);
    H323FreeU2U(&pCall->OutgoingU2U);

    // success
    return TRUE;
}


BOOL
H323AllocCall(
    PH323_CALL * ppCall
    )
        
/*++

Routine Description:

    Allocates call object and channel table.

Arguments:

    ppCall - Specifies a pointer to a DWORD-sized value which the service
        provider fills in with the newly allocated call object.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    PH323_CALL pCall;

    // allocate call from heap
    pCall = H323HeapAlloc(sizeof(H323_CALL));

    // validate pointer
    if (pCall == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate call object.\n"
            ));

        // failure
        return FALSE;
    }

    // allocate default channel objects
    if (!H323AllocChannelTable(&pCall->pChannelTable)) {

        // release call
        H323HeapFree(pCall);

        // failure
        return FALSE;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx allocated.\n",
        pCall
        ));

    // initialize user user information
    InitializeListHead(&pCall->IncomingU2U);
    InitializeListHead(&pCall->OutgoingU2U);

    // reset call object
    H323ResetCall(pCall);

    // transfer 
    *ppCall = pCall;

    // success
    return TRUE;    
}


BOOL
H323FreeCall(
    PH323_CALL pCall
    )
        
/*++

Routine Description:

    Deallocates call object and channel table.

Arguments:

    pCall - Specifies a pointer to the call object to release.

Return Values:

    Returns true if successful.
    
--*/

{
    // validate pointer
    if (pCall != NULL) {
                
        // release memory for channel table
        H323FreeChannelTable(pCall->pChannelTable);

        // reset call
        H323ResetCall(pCall);

        // release call
        H323HeapFree(pCall);
    }
    
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx released.\n",
        pCall
        ));

    // success
    return TRUE;    
}


DWORD
H323DetermineLinkSpeed(
    DWORD dwHostAddr
    )
        

/*++

Routine Description:

    Determines speed of specified link.

Arguments:

    dwHostAddr - interface address given in host order.

Return Values:

    Returns link speed (defaults to 28.8kbps).
    
--*/

{

#define DEFAULT_IPADDRROW 10
#define DEFAULT_LINKSPEED (MAXIMUM_BITRATE_28800 * 100)

    DWORD dwSize;
    DWORD dwIndex;
    DWORD dwStatus;
    DWORD dwIPAddr;
    DWORD dwIfIndex = UNINITIALIZED;
    PMIB_IPADDRTABLE pIPAddrTable = NULL;
    MIB_IFROW IfRow;

    // convert to network order
    dwIPAddr = htonl(dwHostAddr);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "determining link speed for %s\n",
        H323AddrToString(dwIPAddr)
        ));

    // default to reasonable size
    dwSize = sizeof(MIB_IPADDRTABLE) +
             sizeof(MIB_IPADDRROW) * DEFAULT_IPADDRROW
             ;

    do {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "allocating IP address table (%d bytes)\n",
            dwSize
            ));

        // release buffer
        H323HeapFree(pIPAddrTable);

        // allocate default table
        pIPAddrTable = H323HeapAlloc(dwSize);

        // validate pointer
        if (pIPAddrTable == NULL) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "could not allocate IP address table\n"
                ));

            // failure
            return DEFAULT_LINKSPEED;
        }

        // attempt to get table
        dwStatus = GetIpAddrTable(
                        pIPAddrTable,
                        &dwSize,
                        FALSE       // sort table
                        );

    } while (dwStatus == ERROR_INSUFFICIENT_BUFFER);

    // validate status
    if (dwStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx calling GetIpAddrTable\n",
            dwStatus
            ));

        // release buffer
        H323HeapFree(pIPAddrTable);

        // failure
        return DEFAULT_LINKSPEED;
    }

    // find the correct row in the table
    for (dwIndex = 0; dwIndex < pIPAddrTable->dwNumEntries; dwIndex++) {

        // compare given address to interface address
        if (dwIPAddr == pIPAddrTable->table[dwIndex].dwAddr) {

            // save index into interface table
            dwIfIndex = pIPAddrTable->table[dwIndex].dwIndex;

            H323DBG((
                DEBUG_LEVEL_TRACE,
                "address %s maps to interface %d\n",
                H323AddrToString(dwIPAddr),
                dwIfIndex
                ));

            // done
            break;
        }
    }

    // release buffer
    H323HeapFree(pIPAddrTable);

    // validate row pointer
    if (dwIfIndex == UNINITIALIZED) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not locate %s in IP address table\n",
            H323AddrToString(dwIPAddr)
            ));

        // failure
        return DEFAULT_LINKSPEED;
    }

    // initialize structure
    memset(&IfRow,0,sizeof(IfRow));

    // set interface index
    IfRow.dwIndex = dwIfIndex;

    // retrieve interface info
    dwStatus = GetIfEntry(&IfRow);

    // validate status
    if (dwStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx calling GetIfEntry(%d)\n",
            dwStatus,
            dwIfIndex
            ));

        // failure
        return DEFAULT_LINKSPEED;
    }

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "interface %d has link speed of %d bps\n",
        dwIfIndex,
        IfRow.dwSpeed
        ));

    // return link speed
    return IfRow.dwSpeed;
}


BOOL
H323ResolveCallerAddress(
    PH323_CALL pCall
    )
        
/*++

Routine Description:

    Resolves caller address from callee address.

Arguments:

    pCall - Specifies a pointer to the call object of interest.

Return Values:

    Returns true if successful.
    
--*/

{
    INT      nStatus;
    SOCKET   hCtrlSocket;
    SOCKADDR CalleeSockAddr;
    SOCKADDR CallerSockAddr;
    DWORD    dwNumBytesReturned = 0;

    // allocate control socket
    hCtrlSocket = WSASocket(
                    AF_INET,            // af
                    SOCK_DGRAM,         // type
                    IPPROTO_IP,         // protocol
                    NULL,               // lpProtocolInfo
                    0,                  // g
                    WSA_FLAG_OVERLAPPED // dwFlags
                    );

    // validate control socket
    if (hCtrlSocket == INVALID_SOCKET) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error %d creating control socket.\n",
            WSAGetLastError()
            ));

        // failure
        return FALSE;
    }

    // initialize ioctl parameters
    memset(&CalleeSockAddr,0,sizeof(SOCKADDR));
    memset(&CallerSockAddr,0,sizeof(SOCKADDR));

    // initialize address family
    CalleeSockAddr.sa_family = AF_INET;

    // transfer callee information
    ((SOCKADDR_IN*)&CalleeSockAddr)->sin_addr.s_addr =
        htonl(pCall->ccCalleeAddr.Addr.IP_Binary.dwAddr);

    // query stack
    nStatus = WSAIoctl(
                hCtrlSocket,
                SIO_ROUTING_INTERFACE_QUERY,
                &CalleeSockAddr,
                sizeof(SOCKADDR),
                &CallerSockAddr,
                sizeof(SOCKADDR),
                &dwNumBytesReturned,
                NULL,
                NULL
                );

    // release handle
    closesocket(hCtrlSocket);

    // validate return code
    if (nStatus == SOCKET_ERROR) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx calling SIO_ROUTING_INTERFACE_QUERY.\n",
            WSAGetLastError()
            ));

        // failure
        return FALSE;
    }

    // save interface address of best route
    pCall->ccCallerAddr.nAddrType = CC_IP_BINARY;
    pCall->ccCallerAddr.Addr.IP_Binary.dwAddr =
        ntohl(((SOCKADDR_IN*)&CallerSockAddr)->sin_addr.s_addr);
    pCall->ccCallerAddr.Addr.IP_Binary.wPort =
        LOWORD(g_RegistrySettings.dwQ931CallSignallingPort);
    pCall->ccCallerAddr.bMulticast =
        IN_MULTICAST(pCall->ccCallerAddr.Addr.IP_Binary.dwAddr);

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "caller address resolved to %s.\n",
        H323AddrToString(((SOCKADDR_IN*)&CallerSockAddr)->sin_addr.s_addr)
        ));

    // determine link speed for local interface
    pCall->dwLinkSpeed = H323DetermineLinkSpeed(
                            pCall->ccCallerAddr.Addr.IP_Binary.dwAddr
                            );

    // success
    return TRUE;
}


BOOL
H323ResolveE164Address(
    PH323_CALL pCall,
    LPCWSTR    pwszDialableAddr
    )
        
/*++

Routine Description:

    Resolves E.164 address ("4259367111").

Arguments:

    pCall - Specifies a pointer to the call object of interest.

    pwszDialableAddr - Specifies a pointer to the dialable address specified
        by the TAPI application.

Return Values:

    Returns true if successful.
    
--*/

{
    WCHAR * pwszValidE164Chars;
    WCHAR wszAddr[H323_MAXDESTNAMELEN+1];

    DWORD dwE164AddrSize = 0;
    WCHAR wszValidE164Chars[] = { CC_ALIAS_H323_PHONE_CHARS L"\0" };

    // make sure pstn gateway has been specified
    if ((g_RegistrySettings.fIsGatewayEnabled == FALSE) ||
        (g_RegistrySettings.ccGatewayAddr.nAddrType == 0)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "pstn gateway not specified.\n"
            ));

        // failure
        return FALSE;
    }

    // save gateway address as callee address
    pCall->ccCalleeAddr = g_RegistrySettings.ccGatewayAddr;

    // process until termination char
    while (*pwszDialableAddr != L'\0') {

        // reset pointer to valid characters
        pwszValidE164Chars = wszValidE164Chars;

        // process until termination char
        while (*pwszValidE164Chars != L'\0') {

            // see if valid E.164 character specified
            if (*pwszDialableAddr == *pwszValidE164Chars) {

                // save valid character in temp buffer
                wszAddr[dwE164AddrSize++] = *pwszDialableAddr;

                break;
            }

            // next valid char
            ++pwszValidE164Chars;
        }

        // next input char
        ++pwszDialableAddr;
    }

    // validate string
    if (dwE164AddrSize == 0) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "no valid E.164 characters in string.\n"
            ));

        // failure
        return FALSE;
    }

    // terminate string
    wszAddr[dwE164AddrSize++] = '\0';

    // allocate callee alias from e164 address
    pCall->ccCalleeAlias.pData = H323HeapAlloc(
        dwE164AddrSize * sizeof(WCHAR)
        );

    // validate pointer
    if (pCall->ccCalleeAlias.pData == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate E.164 number.\n"
            ));

        // failure
        return FALSE;
    }

    // transfer callee alias
    memcpy(pCall->ccCalleeAlias.pData,
           wszAddr,
           dwE164AddrSize * sizeof(WCHAR)
           );

    // complete alias
    pCall->ccCalleeAlias.wType         = CC_ALIAS_H323_PHONE;
    pCall->ccCalleeAlias.wPrefixLength = 0;
    pCall->ccCalleeAlias.pPrefix       = NULL;
    pCall->ccCalleeAlias.wDataLength   = LOWORD(dwE164AddrSize - 1);

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "callee alias resolved to E.164 number %S.\n",
        pCall->ccCalleeAlias.pData
        ));

    // determine caller address
    return H323ResolveCallerAddress(pCall);
}


BOOL
H323ResolveIPAddress(
    PH323_CALL pCall,
    LPSTR      pszDialableAddr
    )
        
/*++

Routine Description:

    Resolves IP address ("172.31.255.231") or DNS entry ("DONRYAN1").

Arguments:

    pCall - Specifies a pointer to the call object of interest.

    pszDialableAddr - Specifies a pointer to the dialable address specified
        by the TAPI application.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD dwIPAddr;
    struct hostent * pHost;

    // attempt to convert ip address
    dwIPAddr = inet_addr(pszDialableAddr);

    // see if address converted
    if (dwIPAddr == UNINITIALIZED) {

        // attempt to lookup hostname
        pHost = gethostbyname(pszDialableAddr);

        // validate pointer
        if (pHost != NULL) {

            // retrieve host address from structure
            dwIPAddr = *(unsigned long *)pHost->h_addr;
        }
    }

    // see if address converted
    if (dwIPAddr == UNINITIALIZED) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx resolving IP address.\n",
            WSAGetLastError()
            ));

        // failure
        return FALSE;
    }

    // save converted address
    pCall->ccCalleeAddr.nAddrType = CC_IP_BINARY;
    pCall->ccCalleeAddr.Addr.IP_Binary.dwAddr = ntohl(dwIPAddr);
    pCall->ccCalleeAddr.Addr.IP_Binary.wPort =
        LOWORD(g_RegistrySettings.dwQ931CallSignallingPort);
    pCall->ccCalleeAddr.bMulticast =
        IN_MULTICAST(pCall->ccCalleeAddr.Addr.IP_Binary.dwAddr);

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "callee address resolved to %s:%d.\n",
        H323AddrToString(dwIPAddr),
        pCall->ccCalleeAddr.Addr.IP_Binary.wPort
        ));

    // determine caller address
    return H323ResolveCallerAddress(pCall);
}


BOOL
H323ResolveEmailAddress(
    PH323_CALL pCall,
    LPCWSTR    pwszDialableAddr,
    LPSTR      pszUser,
    LPSTR      pszDomain
    )
        
/*++

Routine Description:

    Resolves e-mail address ("donryan@microsoft.com").

Arguments:

    pCall - Specifies a pointer to the call object of interest.

    pwszDialableAddr - Specifies a pointer to the dialable address specified
        by the TAPI application.

    pszUser - Specifies a pointer to the user component of e-mail name.

    pszDomain - Specified a pointer to the domain component of e-mail name.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD dwAddrSize;

    // attempt to resolve domain locally
    if (H323ResolveIPAddress(pCall, pszDomain)) {

        // success
        return TRUE;
    }

    // make sure proxy has been specified
    if ((g_RegistrySettings.fIsProxyEnabled == FALSE) ||
        (g_RegistrySettings.ccProxyAddr.nAddrType == 0)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "proxy not specified.\n"
            ));

        // failure
        return FALSE;
    }

    // save proxy address as callee address
    pCall->ccCalleeAddr = g_RegistrySettings.ccProxyAddr;

    // size destination address string
    dwAddrSize = wcslen(pwszDialableAddr) + 1;

    // allocate callee alias from e164 address
    pCall->ccCalleeAlias.pData = H323HeapAlloc(
        dwAddrSize * sizeof(WCHAR)
        );

    // validate pointer
    if (pCall->ccCalleeAlias.pData == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate H.323 alias.\n"
            ));

        // failure
        return FALSE;
    }

    // transfer callee alias
    memcpy(pCall->ccCalleeAlias.pData,
           pwszDialableAddr,
           dwAddrSize * sizeof(WCHAR)
           );

    // complete alias
    pCall->ccCalleeAlias.wType         = CC_ALIAS_H323_ID;
    pCall->ccCalleeAlias.wPrefixLength = 0;
    pCall->ccCalleeAlias.pPrefix       = NULL;
    pCall->ccCalleeAlias.wDataLength   = LOWORD(dwAddrSize - 1);

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "callee alias resolved to H.323 alias %S.\n",
        pCall->ccCalleeAlias.pData
        ));

    // determine caller address
    return H323ResolveCallerAddress(pCall);
}


BOOL
H323ResolveAddress(
    PH323_CALL pCall,
    LPCWSTR    pwszDialableAddr
    )
        
/*++

Routine Description:

    Resolves remote address and determines the correct local address
    to use in order to reach remote address.

Arguments:

    pCall - Specifies a pointer to the call object of interest.

    pwszDialableAddr - Specifies a pointer to the dialable address specified
        by the TAPI application.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD dwIPAddr;
    CHAR szDelimiters[] = "@ \t\n";
    CHAR szAddr[H323_MAXDESTNAMELEN+1];
    LPSTR pszUser = NULL;
    LPSTR pszDomain = NULL;

    // validate pointerr
    if (pwszDialableAddr == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "null destination address.\n"
            ));        

        // failure
        return FALSE;
    }

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "resolving %s %S.\n",
        H323AddressTypeToString(pCall->dwAddressType),
        pwszDialableAddr
        ));

    // check whether phone number has been specified
    if (pCall->dwAddressType == LINEADDRESSTYPE_PHONENUMBER) {

        // need to direct call to pstn gateway
        return H323ResolveE164Address(pCall, pwszDialableAddr);
    }

    // convert address from unicode
    if (WideCharToMultiByte(
            CP_ACP,
            0,
            pwszDialableAddr,
            -1,
            szAddr,
            sizeof(szAddr),
            NULL,
            NULL
            ) == 0) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not convert address from unicode.\n"
            ));

        // failure
        return FALSE;
    }

    // parse user name
    pszUser = strtok(szAddr, szDelimiters);

    // parse domain name
    pszDomain = strtok(NULL, szDelimiters);

    // validate pointer
    if (pszUser == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not parse destination address.\n"
            ));

        // failure
        return FALSE;
    }

    // validate pointer
    if (pszDomain == NULL) {

        // switch pointers
        pszDomain = pszUser;

        // re-initialize
        pszUser = NULL;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "resolving user %s domain %s.\n",
        pszUser,
        pszDomain
        ));

    // process e-mail and domain names
    return H323ResolveEmailAddress(
                pCall,
                pwszDialableAddr,
                pszUser,
                pszDomain
                );
}


BOOL
H323ValidateCallParams(
    PH323_CALL       pCall,
    LPLINECALLPARAMS pCallParams,
    LPCWSTR          pwszDialableAddr,
    PDWORD           pdwStatus
    )

/*++

Routine Description:

    Validate optional call parameters specified by user.

Arguments:

    pCall - Pointer to call object of interest.

    pCallParams - Pointer to specified call parameters to be
        validated.

    pwszDialableAddr - Pointer to the dialable address specified
        by the TAPI application.

    pdwStatus - Pointer to DWORD containing error code if this
        routine fails for any reason.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD dwMediaModes = H323_LINE_DEFMEDIAMODES;

    // validate pointer
    if (pCallParams != NULL) {

        // retrieve media modes specified
        dwMediaModes = pCallParams->dwMediaMode;

        // retrieve address type specified
        pCall->dwAddressType = pCallParams->dwAddressType;

        // see if we support call parameters
        if (pCallParams->dwCallParamFlags != 0) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "do not support call parameters 0x%08lx.\n",
                pCallParams->dwCallParamFlags 
                ));

            // do not support param flags
            *pdwStatus = LINEERR_INVALCALLPARAMS;

            // failure
            return FALSE;
        }

        // see if unknown bit is specified
        if (dwMediaModes & LINEMEDIAMODE_UNKNOWN) {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "clearing unknown media mode.\n"
                 ));

            // clear unknown bit from modes
            dwMediaModes &= ~LINEMEDIAMODE_UNKNOWN;
        }

        // see if both audio bits are specified 
        if ((dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) &&
            (dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE)) {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "clearing automated voice media mode.\n"
                 ));

            // clear extra audio bit from modes
            dwMediaModes &= ~LINEMEDIAMODE_INTERACTIVEVOICE;
        }

        // see if we support media modes specified
        if (dwMediaModes & ~H323_LINE_MEDIAMODES) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "do not support media modes 0x%08lx.\n",
                 pCallParams->dwMediaMode
                 ));

            // do not support media mode
            *pdwStatus = LINEERR_INVALMEDIAMODE;

            // failure
            return FALSE;
        }

        // see if we support bearer modes
        if (pCallParams->dwBearerMode & ~H323_LINE_BEARERMODES) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "do not support bearer mode 0x%08lx.\n",
                pCallParams->dwBearerMode 
                ));

            // do not support bearer mode
            *pdwStatus = LINEERR_INVALBEARERMODE;

            // failure
            return FALSE;
        }

        // see if we support address modes
        if (pCallParams->dwAddressMode & ~H323_LINE_ADDRESSMODES) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "do not support address mode 0x%08lx.\n",
                pCallParams->dwAddressMode 
                ));

            // do not support address mode
            *pdwStatus = LINEERR_INVALADDRESSMODE;

            // failure
            return FALSE;
        }

        // validate address id specified
        if (!H323IsValidAddressID(pCallParams->dwAddressID)) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "address id 0x%08lx invalid.\n",
                pCallParams->dwAddressID
                ));

            // invalid address id
            *pdwStatus = LINEERR_INVALADDRESSID;

            // failure
            return FALSE;
        }

        // validate destination address type specified
        if (pCall->dwAddressType & ~H323_LINE_ADDRESSTYPES) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "address type 0x%08lx invalid.\n",
                pCallParams->dwAddressType
                ));

            // invalid address type
            *pdwStatus = LINEERR_INVALADDRESSTYPE;

            // failure
            return FALSE;
        }

        // see if callee alias specified
        if ((pCallParams->dwCalledPartySize > 0) &&
            (pCall->dwAddressType != LINEADDRESSTYPE_PHONENUMBER)) {

            // allocate memory for callee string
            pCall->ccCalleeAlias.pData = H323HeapAlloc(
                pCallParams->dwCalledPartySize
                );

            // validate pointer
            if (pCall->ccCalleeAlias.pData == NULL) {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "could not allocate callee name.\n"
                    ));

                // no memory available
                *pdwStatus = LINEERR_NOMEM;

                // failure
                return FALSE;
            }

            // transfer memory
            memcpy(pCall->ccCalleeAlias.pData,
                   (LPBYTE)pCallParams +
                      pCallParams->dwCalledPartyOffset,
                   pCallParams->dwCalledPartySize
                   );

            // complete alias
            pCall->ccCalleeAlias.wType         = CC_ALIAS_H323_ID;
            pCall->ccCalleeAlias.wPrefixLength = 0;
            pCall->ccCalleeAlias.pPrefix       = NULL;
            pCall->ccCalleeAlias.wDataLength   =
                (WORD)wcslen(pCall->ccCalleeAlias.pData);
        }

        // see if caller name specified
        if (pCallParams->dwCallingPartyIDSize > 0) {

            // allocate memory for callee string
            pCall->ccCallerAlias.pData = H323HeapAlloc(
                pCallParams->dwCallingPartyIDSize
                );

            // validate pointer
            if (pCall->ccCallerAlias.pData == NULL) {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "could not allocate caller name.\n"
                    ));

                // no memory available
                *pdwStatus = LINEERR_NOMEM;

                // failure
                return FALSE;
            }

            // transfer memory
            memcpy(pCall->ccCallerAlias.pData,
                   (LPBYTE)pCallParams +
                      pCallParams->dwCallingPartyIDOffset,
                   pCallParams->dwCallingPartyIDSize
                   );

            // complete alias
            pCall->ccCallerAlias.wType         = CC_ALIAS_H323_ID;
            pCall->ccCallerAlias.wPrefixLength = 0;
            pCall->ccCallerAlias.pPrefix       = NULL;
            pCall->ccCallerAlias.wDataLength   =
                (WORD)wcslen(pCall->ccCallerAlias.pData);
        }

        // check for user user information
        if (pCallParams->dwUserUserInfoSize > 0) {

            // save user user info
            if (!H323AddU2U(
                    &pCall->OutgoingU2U,
                    pCallParams->dwUserUserInfoSize,
                    (LPBYTE)pCallParams +
                         pCallParams->dwUserUserInfoOffset
                    )) {

                // invalid address id
                *pdwStatus = LINEERR_NOMEM;

                // failure
                return FALSE;
            }
        }
    }

    // clear incoming modes
    pCall->dwIncomingModes = 0;
    
    // outgoing modes will be finalized during H.245 stage
    pCall->dwOutgoingModes = dwMediaModes | LINEMEDIAMODE_UNKNOWN;
    
    // save media modes specified
    pCall->dwRequestedModes = dwMediaModes;

    // resolve dialable into local and remote address
    if (!H323ResolveAddress(pCall, pwszDialableAddr)) {

        // invalid destination addr
        *pdwStatus = LINEERR_INVALADDRESS;

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323BindCall(
    PH323_CALL       pCall,
    PCC_CONFERENCEID pConferenceID
    )
        
/*++

Routine Description:

    Associates call object with the specified conference id.

Arguments:

    pCall - Specifies a pointer to the call object to bind.

    pConferenceID - Pointer to conference id to be associated with call object.  

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    CC_TERMCAPLIST TermCapList;
    CC_TERMCAPDESCRIPTORS TermCapDescriptors;

    // determine term caps from link speed
    H323GetTermCapList(pCall,&TermCapList,&TermCapDescriptors);

    // create conference    
    hr = CC_CreateConference(
            &pCall->hccConf,        // phConference
            pConferenceID,          // pConferenceID
            0,                      // dwConferenceConfiguration
            &TermCapList,           // pTermCapList
            &TermCapDescriptors,    // pTermCapDescriptors
            &g_VendorInfo,          // pVendorInfo
            NULL,                   // pTerminalID
            PtrToUlong(pCall->hdCall),   // dwConferenceToken
            NULL,                   // TermCapConstructor
            NULL,                   // SessionTableConstructor
            H323ConferenceCallback  // ConferenceCallback
            );
        
    // validate 
    if (hr != S_OK) {
        
        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error %s (0x%08lx) binding call 0x%08lx.\n", 
            H323StatusToString(hr), hr,
            pCall
            ));

        // failure
        return FALSE;
    }
    
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx bound to conference 0x%08lx.\n",
        pCall,
        pCall->hccConf
        ));

    // success
    return TRUE;    
}


BOOL
H323UnbindCall(
    PH323_CALL pCall
    )
        
/*++

Routine Description:

    Removes association between call object and conference object.

Arguments:

    pCall - Specifies a pointer to the call object to unbind.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;

    // validate conference handle
    if (pCall->hccConf != UNINITIALIZED) {

        // destroy conference object used for call
        hr = CC_DestroyConference(pCall->hccConf, FALSE);

        // validate
        if (hr != S_OK) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "error 0x%08lx destroying conference 0x%08lx.\n",
                hr,
                pCall->hccConf
                ));

            // failure
            return FALSE;
        }

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "call 0x%08lx unbound from conference 0x%08lx.\n",
            pCall,
            pCall->hccConf
            ));

        // invalidate conference handle
        pCall->hccConf = UNINITIALIZED;
    }

    // success
    return TRUE;        
}


BOOL
H323PlaceCall(
    PH323_CALL pCall
    )
        
/*++

Routine Description:

    Initiates outbound call to specified destination.

Arguments:

    pCall - Specifies the pointer to the call object.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    CC_ALIASITEM LocalAlias;
    CC_ALIASITEM CalleeAlias;
    CC_ALIASNAMES LocalAliasNames;
    CC_ALIASNAMES CalleeAliasNames;
    PCC_ALIASNAMES pLocalAliasNames = NULL;
    PCC_ALIASNAMES pCalleeAliasNames = NULL;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_NONSTANDARDDATA pNonStandardData = NULL;
    PH323_U2ULE pU2ULE = NULL;
    PWSTR pwszDisplay = NULL;

    // see if user user information specified
    if (H323RemoveU2U(&pCall->OutgoingU2U,&pU2ULE)) {

        // transfer header information
        NonStandardData.bCountryCode      = H221_COUNTRY_CODE_USA;
        NonStandardData.bExtension        = H221_COUNTRY_EXT_USA;
        NonStandardData.wManufacturerCode = H221_MFG_CODE_MICROSOFT;

        // initialize octet string containing data
        NonStandardData.sData.wOctetStringLength = LOWORD(pU2ULE->dwU2USize);
        NonStandardData.sData.pOctetString = pU2ULE->pU2U;

        // point to stack based structure
        pNonStandardData = &NonStandardData;
    }

    // see if caller alias specified
    if (g_dwAliasLength > 0)
    {
        // send caller name as display
        pwszDisplay = g_strAlias;
    }
    else if ((pCall->ccCallerAlias.wType == CC_ALIAS_H323_ID) ||
        (pCall->ccCallerAlias.wType == CC_ALIAS_H323_PHONE)) {

        // fill in local alias list
        LocalAliasNames.wCount   = 1;
        LocalAliasNames.pItems   = &pCall->ccCallerAlias;

        // initialize pointer
        pLocalAliasNames = &LocalAliasNames;

        // send caller name as display
        pwszDisplay = pCall->ccCallerAlias.pData;
    }

    // see if callee alias specified
    if ((pCall->ccCalleeAlias.wType == CC_ALIAS_H323_ID) ||
        (pCall->ccCalleeAlias.wType == CC_ALIAS_H323_PHONE)) {

        // fill in callee alias list
        CalleeAliasNames.wCount   = 1;
        CalleeAliasNames.pItems   = &pCall->ccCalleeAlias;

        // initialize pointer
        pCalleeAliasNames = &CalleeAliasNames;
    }

    // place call
    hr = CC_PlaceCall(
            pCall->hccConf,         // hConference
            &pCall->hccCall,        // phCall
            pLocalAliasNames,       // pLocalAliasNames
            pCalleeAliasNames,      // pCalleeAliasNames
            NULL,                   // pExtraCalleeAliasNames
            NULL,                   // pCalleeExtension
            pNonStandardData,       // pNonStandardData
            pwszDisplay,            // pwszDisplay
            &pCall->ccCalleeAddr,   // pDestinationAddr
            NULL,                   // pConnectAddr                        
            0,                      // dwBandwidth
            PtrToUlong(pCall->hdCall)    // dwUserToken
            );

    // validate 
    if (hr == S_OK) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "call 0x%08lx placed.\n",
            pCall
            ));

    } else {
        
        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx calling CC_PlaceCall.\n", hr
            ));
    }

    // release memory
    H323HeapFree(pU2ULE);

    // return status
    return (hr == S_OK);
}


BOOL
H323DropCall(
    PH323_CALL pCall,
    DWORD      dwDisconnectMode
    )
        
/*++

Routine Description:

    Hangs up call (if necessary) and changes state to idle.

Arguments:

    pCall - Specifies a pointer to the call object to drop.

    dwDisconnectMode - Status code for disconnect.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    PH323_U2ULE pU2ULE = NULL;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_NONSTANDARDDATA pNonStandardData = NULL;

    // determine call state
    switch (pCall->dwCallState) {

    case LINECALLSTATE_CONNECTED:

        // hangup call (this will invoke async indication)
        hr = CC_Hangup(pCall->hccConf, FALSE, PtrToUlong(pCall->hdCall));

        // validate
        if (hr == CC_OK) {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "call 0x%08lx hung up.\n",
                pCall
                ));

        } else {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "error %s (0x%08lx) hanging up call 0x%08lx.\n",
                H323StatusToString((DWORD)hr), hr,
                pCall
                ));
        }

        // change call state to disconnected
        H323ChangeCallState(pCall, LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

        break;

    case LINECALLSTATE_OFFERING:

        // see if user user information specified
        if (H323RemoveU2U(&pCall->OutgoingU2U,&pU2ULE)) {

            // transfer header information
            NonStandardData.bCountryCode      = H221_COUNTRY_CODE_USA;
            NonStandardData.bExtension        = H221_COUNTRY_EXT_USA;
            NonStandardData.wManufacturerCode = H221_MFG_CODE_MICROSOFT;

            // initialize octet string containing data
            NonStandardData.sData.wOctetStringLength = LOWORD(pU2ULE->dwU2USize);
            NonStandardData.sData.pOctetString = pU2ULE->pU2U;

            // point to stack based structure
            pNonStandardData = &NonStandardData;
        }

        // reject call
        hr = CC_RejectCall(
                CC_REJECT_DESTINATION_REJECTION,
                pNonStandardData,
                pCall->hccCall
                );

        // validate
        if (hr == CC_OK) {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "call 0x%08lx rejected.\n",
                pCall
                ));

        } else {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "error %s (0x%08lx) reject call 0x%08lx.\n",
                H323StatusToString((DWORD)hr), hr,
                pCall
                ));
        }

        // release memory
        H323HeapFree(pU2ULE);

        // change call state to disconnected
        H323ChangeCallState(pCall, LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

        break;

    case LINECALLSTATE_DIALING:
    case LINECALLSTATE_RINGBACK:
    case LINECALLSTATE_ACCEPTED:

        // cancel outbound call
        hr = CC_CancelCall(pCall->hccCall);

        // validate
        if (hr == CC_OK) {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "call 0x%08lx cancelled.\n",
                pCall
                ));

        } else {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "error %s (0x%08lx) cancelling call 0x%08lx.\n",
                H323StatusToString((DWORD)hr), hr,
                pCall
                ));
        }

        // change call state to disconnected
        H323ChangeCallState(pCall, LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

        break;

    case LINECALLSTATE_DISCONNECTED:

        //
        // disconnected but still need to clean up
        //

        break;

    case LINECALLSTATE_IDLE:

        //
        // call object already idle
        //

        return TRUE;
    }

    // Tell the MSP to stop streaming.
    H323CloseCallCommand(pCall);

    // close logical channels
    H323CloseChannelTable(pCall->pChannelTable);

    // change call state to idle
    H323ChangeCallState(pCall, LINECALLSTATE_IDLE, 0);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx dropped.\n",
        pCall
        ));
    
    // success
    return TRUE;
}
     

BOOL
H323CloseCall(
    PH323_CALL pCall 
    )
        
/*++

Routine Description:

    Hangs up call (if necessary) and closes call object.  

Arguments:

    pCall - Specifies a pointer to the call object to release.

Return Values:

    Returns true if successful.
    
--*/

{
    // drop call using normal disconnect code
    H323DropCall(pCall,LINEDISCONNECTMODE_NORMAL);

    // unbind conference
    H323UnbindCall(pCall);

    // mark entry as allocated
    H323FreeCallFromTable(pCall,pCall->pLine->pCallTable);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx closed.\n",
        pCall
        ));
    
    // success
    return TRUE;
}


BOOL
H323GetCallAndLock(
    PH323_CALL * ppCall, 
    HDRVCALL     hdCall
    )
        
/*++

Routine Description:

    Retrieves pointer to call object given call handle.

Arguments:

    ppCall - Specifies a pointer to a DWORD-sized memory location
        into which the service provider must write the call object pointer
        associated with the given call handle.

    hdCall - Specifies the Service Provider's opaque handle to the call.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    HDRVLINE hdLine;
    PH323_LINE pLine = NULL;
    PH323_CALL pCall = NULL;

    // retrieve line handle from call
    hdLine = H323GetLineHandle(PtrToUlong(hdCall));

    // retrieve line pointer
    if (!H323GetLineAndLock(&pLine, hdLine)) {
        
        H323DBG((
            DEBUG_LEVEL_ERROR,
            "call handle 0x%08lx invalid line.\n",
            PtrToUlong(hdCall)
            ));

        // unlock line device
        H323UnlockLine(pLine);

        // failure
        return FALSE;
    }

    // retrieve call table index
    i = H323GetCallTableIndex(PtrToUlong(hdCall));

    // validate call table index
    if (i >= pLine->pCallTable->dwNumSlots) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "call handle 0x%08lx invalid index.\n",
            PtrToUlong(hdCall)
            ));

        // unlock line device
        H323UnlockLine(pLine);

        // failure
        return FALSE;
    }
    
    // retrieve call pointer from table
    pCall = pLine->pCallTable->pCalls[i];

    // validate call information
    if (!H323IsCallEqual(pCall,hdCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "call handle 0x%08lx mismatch.\n",
            PtrToUlong(hdCall)
            ));

        // unlock line device
        H323UnlockLine(pLine);

        // failure
        return FALSE;
    }
    
    // transfer 
    *ppCall = pCall;

    // success
    return TRUE;    
}


BOOL
H323GetCallByHCall(
    PH323_CALL *        ppCall,
    struct _H323_LINE * pLine,
    CC_HCALL            hccCall
    )

/*++

Routine Description:

    Retrieves pointer to call object given callcont call handle.

Arguments:

    ppCall - Specifies a pointer to a DWORD-sized memory location
        into which the service provider must write the call object pointer
        associated with the given call handle.

    pLine - Specifies a pointer to associated line object.

    hccCall - Specifies the call control module handle to the call.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    PH323_CALL_TABLE pCallTable = pLine->pCallTable;

    // loop through each object in table
    for (i = 0; i < pCallTable->dwNumSlots; i++) {

        // validate object has been allocated
        if (H323IsCallInUse(pCallTable->pCalls[i])) {

            // check for given call control handle
            if (pCallTable->pCalls[i]->hccCall == hccCall) {

                // transfer pointer
                *ppCall = pCallTable->pCalls[i];

                // success
                return TRUE;
            }
        }
    }

    // failure
    return FALSE;
}


BOOL
H323ChangeCallState(
    PH323_CALL pCall,
    DWORD      dwCallState,
    DWORD      dwCallStateMode
    )
        
/*++

Routine Description:

    Reports call state of specified call object.

Arguments:

    pCall - Specifies a pointer to call object.
    
    dwCallState - Specifies new state of call object.
    
    dwCallStateMode - Specifies new state mode of call object.

Return Values:

    Returns true if successful.
    
--*/

{   
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx %s. state mode: 0x%08lx\n",
        pCall,
        H323CallStateToString(dwCallState),
        dwCallStateMode
        ));    
    
    // save new call state
    pCall->dwCallState = dwCallState;
    pCall->dwCallStateMode = dwCallStateMode;
    
    // report call status
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_CALLSTATE,
        pCall->dwCallState,
        pCall->dwCallStateMode,
        pCall->dwIncomingModes | pCall->dwOutgoingModes
        );

    // success
    return TRUE;
}


BOOL
H323AllocCallTable(
    PH323_CALL_TABLE * ppCallTable
    )
        
/*++

Routine Description:

    Allocates table of call objects.

Arguments:

    ppCallTable - Pointer to DWORD-sized value which service
         provider must fill in with newly allocated table.

Return Values:

    Returns true if successful.
    
--*/

{
    PH323_CALL_TABLE pCallTable;

    // allocate table from heap
    pCallTable = H323HeapAlloc(
                     sizeof(H323_CALL_TABLE) + 
                     sizeof(PH323_CALL) * H323_DEFCALLSPERLINE
                     );

    // validate table pointer
    if (pCallTable == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate call table.\n"
            ));

        // failure
        return FALSE;
    }

    // initialize number of entries in table
    pCallTable->dwNumSlots = H323_DEFCALLSPERLINE;

    // transfer pointer to caller
    *ppCallTable = pCallTable;

    // success
    return TRUE;
}


BOOL
H323FreeCallTable(
    PH323_CALL_TABLE pCallTable
    )
        
/*++

Routine Description:

    Deallocates table of call objects.

Arguments:

    pCallTable - Pointer to call table to release.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;

    // loop through each object in table
    for (i = 0; i < pCallTable->dwNumSlots; i++) {

        // validate object has been allocated
        if (H323IsCallAllocated(pCallTable->pCalls[i])) {

            // release memory for object 
            H323FreeCall(pCallTable->pCalls[i]);
        }
    }

    // release memory for table 
    H323HeapFree(pCallTable);

    // success
    return TRUE;
}


BOOL
H323CloseCallTable(
    PH323_CALL_TABLE pCallTable
    )
        
/*++

Routine Description:

    Closes table of call objects.

Arguments:

    pCallTable - Pointer to table to close.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    
    // loop through each objectin table
    for (i = 0; i < pCallTable->dwNumSlots; i++) {

        // validate object is in use
        if (H323IsCallInUse(pCallTable->pCalls[i])) {

            // close previously opened object 
            H323PostCloseCallMessage(pCallTable->pCalls[i]->hdCall);
        }
    }

    // success
    return TRUE;
}


BOOL
H323AllocCallFromTable(
    PH323_CALL *       ppCall,
    PH323_CALL_TABLE * ppCallTable,
    PH323_LINE         pLine
    )
        
/*++

Routine Description:

    Allocates call object in table.

Arguments:

    ppCall - Specifies a pointer to a DWORD-sized value in which the
        service provider must write the allocated call object.

    ppCallTable - Pointer to pointer to call table in which to 
        allocate call from (expands table if necessary).

    pLine - Pointer to containing line object.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    PH323_CALL pCall = NULL;
    PH323_CALL_TABLE pCallTable = *ppCallTable;
    
    // retrieve index to next entry
    i = pCallTable->dwNextAvailable;

    // see if previously allocated entries available
    if (pCallTable->dwNumAllocated > pCallTable->dwNumInUse) {

        // search table looking for available entry
        while (H323IsCallInUse(pCallTable->pCalls[i]) ||
              !H323IsCallAllocated(pCallTable->pCalls[i])) {

            // increment index and adjust to wrap
            i = H323GetNextIndex(i, pCallTable->dwNumSlots);
        }

        // retrieve pointer to object
        pCall = pCallTable->pCalls[i];

        // mark entry as being in use
        pCall->nState = H323_CALLSTATE_IN_USE;

        // initialize call handle with index
        pCall->hdCall = H323CreateCallHandle(PtrToUlong(pLine->hdLine),i);

        // increment number in use
        pCallTable->dwNumInUse++;

        // adjust next available index
        pCallTable->dwNextAvailable = 
            H323GetNextIndex(i, pCallTable->dwNumSlots);

        // transfer pointer
        *ppCall = pCall;

        // success
        return TRUE;
    } 
    
    // see if table is full and more slots need to be allocated
    if (pCallTable->dwNumAllocated == pCallTable->dwNumSlots) {

        // attempt to double table
        pCallTable = H323HeapReAlloc(
                          pCallTable, 
                          sizeof(H323_CALL_TABLE) +
                          pCallTable->dwNumSlots * 2 * sizeof(PH323_CALL)
                          );                                 

        // validate pointer
        if (pCallTable == NULL) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "could not expand channel table.\n"
                ));

            // failure
            return FALSE;
        }

        // adjust index into table
        i = pCallTable->dwNumSlots;
        
        // adjust number of slots
        pCallTable->dwNumSlots *= 2;

        // transfer pointer to caller
        *ppCallTable = pCallTable;
    } 
    
    // allocate new object 
    if (!H323AllocCall(&pCall)) {

        // failure
        return FALSE;
    }

    // search table looking for slot with no object allocated
    while (H323IsCallAllocated(pCallTable->pCalls[i])) {

        // increment index and adjust to wrap
        i = H323GetNextIndex(i, pCallTable->dwNumSlots);
    }

    // store pointer to object
    pCallTable->pCalls[i] = pCall;

    // mark entry as being in use
    pCall->nState = H323_CALLSTATE_IN_USE;

    // initialize call handle with index
    pCall->hdCall = H323CreateCallHandle(PtrToUlong(pLine->hdLine),i);

    // increment number in use
    pCallTable->dwNumInUse++;

    // increment number allocated
    pCallTable->dwNumAllocated++;    

    // adjust next available index
    pCallTable->dwNextAvailable = 
        H323GetNextIndex(i, pCallTable->dwNumSlots);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx stored in slot %d (hdCall=0x%08lx).\n",
        pCall, i, 
        pCall->hdCall
        ));

    // transfer pointer
    *ppCall = pCall;

    // success
    return TRUE;
}


BOOL
H323FreeCallFromTable(
    PH323_CALL       pCall,
    PH323_CALL_TABLE pCallTable
    )
        
/*++

Routine Description:

    Deallocates call object in table.

Arguments:

    pCall - Pointer to object to deallocate.

    pCallTable - Pointer to table containing object.

Return Values:

    Returns true if successful.
    
--*/

{
    // reset call object
    H323ResetCall(pCall);

    // decrement entries in use
    pCallTable->dwNumInUse--;

    // success
    return TRUE;    
}


BOOL
H323AcceptCall(
    PH323_CALL pCall
    )
        
/*++

Routine Description:

    Accepts incoming call.

Arguments:

    pCall - Pointer to object to accept.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    PH323_U2ULE pU2ULE = NULL;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_NONSTANDARDDATA pNonStandardData = NULL;
    PWSTR pwszDisplay = NULL;

    // see if user user information specified
    if (H323RemoveU2U(&pCall->OutgoingU2U,&pU2ULE)) {

        // transfer header information
        NonStandardData.bCountryCode      = H221_COUNTRY_CODE_USA;
        NonStandardData.bExtension        = H221_COUNTRY_EXT_USA;
        NonStandardData.wManufacturerCode = H221_MFG_CODE_MICROSOFT;

        // initialize octet string containing data
        NonStandardData.sData.wOctetStringLength = LOWORD(pU2ULE->dwU2USize);
        NonStandardData.sData.pOctetString = pU2ULE->pU2U;

        // point to stack based structure
        pNonStandardData = &NonStandardData;
    }

    // see if callee alias specified
    if (g_dwAliasLength > 0)
    {
        pwszDisplay = g_strAlias;
    }
    else if ((pCall->ccCalleeAlias.wType == CC_ALIAS_H323_ID) ||
        (pCall->ccCalleeAlias.wType == CC_ALIAS_H323_PHONE)) {

        // send caller name as display
        pwszDisplay = pCall->ccCalleeAlias.pData;
    }

    // accept call
    hr = CC_AcceptCall(
            pCall->hccConf,         // hConference
            pNonStandardData,       // pNonStandardData
            pwszDisplay,            // pwszDisplay
            pCall->hccCall,         // hCall
            0,                      // dwBandwidth
            PtrToUlong(pCall->hdCall)    // dwUserToken
            );

    // validate status
    if (hr != CC_OK) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error %s (0x%08lx) answering call 0x%08lx.\n",
            H323StatusToString((DWORD)hr), hr,
            pCall
            ));

        // release memory
        H323HeapFree(pU2ULE);

        // drop call using disconnect mode
        H323DropCall(pCall, LINEDISCONNECTMODE_TEMPFAILURE);

        // failure
        return FALSE;
    }

    // release memory
    H323HeapFree(pU2ULE);

    // change call state to accepted from offering
    H323ChangeCallState(pCall, LINECALLSTATE_ACCEPTED, 0);

    // success
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI procedures                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID     dwRequestID,  
    HDRVCALL          hdCall,
    LPCSTR            pUserUserInfo,
    DWORD             dwSize
    )
    
/*++

Routine Description:

    This function answers the specified offering call.

    When a new call arrives, the Service Provider sends the TAPI DLL a 
    LINE_NEWCALL event to exchange opaque handles for the call.  The Service 
    Provider follows this with a LINE_CALLSTATE message inform the TAPI DLL 
    and its client applications of the call's call state.  The TAPI DLL 
    typically answers this call (on behalf of an application) using 
    TSPI_lineAnswer.  After the call has been successfully answered, the call 
    will typically transition to the connected state.
    
    In some telephony environments (like ISDN) where user alerting is separate 
    from call offering, the TAPI DLL and its client apps may have the option to 
    first accept a call prior to answering, or instead to reject or redirect 
    the offering call.
    
    If a call comes in (is offered) at the time another call is already active, 
    then the new call is connected to by invoking TSPI_lineAnswer. The effect 
    this has on the existing active call depends on the line's device 
    capabilities. The first call may be unaffected, it may automatically be 
    dropped, or it may automatically be placed on hold. The appropriate 
    LINE_CALLSTATE messages will report state transitions to the TAPI DLL about 
    both calls.
    
    The TAPI DLL has the option to send user-to-user information at the time of 
    the answer. Even if user-to-user information can be sent, often no 
    guarantees are made that the network will deliver this information to the 
    calling party. The TAPI DLL can consult a line's device capabilities to 
    determine whether or not sending user-to-user information on answer is 
    available.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        answered.  Valid call states: offering, accepted.

    pUserUserInfo - Specifies a far pointer to a string containing 
        user-to-user information to be sent to the remote party at the time of 
        answering the call. If this pointer is NULL, it indicates that no 
        user-to-user information is to be sent. User-to-user information is 
        only sent if supported by the underlying network (see LINEDEVCAPS).

    dwSize - Specifies the size in bytes of the user-to-user information in 
        pUserUserInfo. If pUserUserInfo is NULL, no user-to-user 
        information is sent to the calling party and dwSize is ignored.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative 
    error number if an error has occurred.  Possible error returns are:  
    
        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    PH323_CALL pCall = NULL;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_NONSTANDARDDATA pNonStandardData = NULL;

    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // see if call in offering state
    if (!H323IsCallOffering(pCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "call 0x%08lx cannot be accepted state 0x%08lx.\n",
            pCall,
            pCall->dwCallState
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // invalid call state
        return LINEERR_INVALCALLSTATE;
    }

    // save outgoing user user information (if specified)
    if (!H323AddU2U(&pCall->OutgoingU2U,dwSize,(PBYTE)pUserUserInfo)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not save user user info.\n"
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // no memory available
        return LINEERR_NOMEM;
    }

    // post place request to callback thread
    if (!H323PostAcceptCallMessage(pCall->hdCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not accept place call message.\n"
            ));

        // drop call using disconnect mode
        H323PostDropCallMessage(pCall->hdCall, LINEDISCONNECTMODE_TEMPFAILURE);

        // release line device
        H323UnlockLine(pCall->pLine);

        // could not complete operation
        return LINEERR_OPERATIONFAILED;
    }

    // complete the async accept operation now
    (*g_pfnCompletionProc)(dwRequestID, NOERROR);

    // release line device
    H323UnlockLine(pCall->pLine);

    // async success                        
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL hdCall
    )
    
/*++

Routine Description:

    This function deletes the call after completing or aborting all outstanding
    asynchronous operations on the call.

    The Service Provider has the responsibility to (eventually) report 
    completion for every operation it decides to execute asynchronously.  
    If this procedure is called for a call on which there are outstanding 
    asynchronous operations, the operations should be reported complete with an 
    appropriate result or error code before this procedure returns.  If there 
    is an active call on the line at the time of TSPI_lineCloseCall, the call 
    must be dropped.  Generally the TAPI DLL would wait for calls to be 
    finished and asynchronous operations to complete in an orderly fashion.  
    However, the Service Provider should be prepared to handle an early call to
    TSPI_lineCloseCall in "abort" or "emergency shutdown" situations.

    After this procedure returns the Service Provider must report no further 
    events on the call.  The Service Provider's opaque handle for the call 
    becomes "invalid".

    This function is presumed to complete successfully and synchronously.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        deleted.  After the call has been successfully deleted, this handle is 
        no longer valid.  Valid call states: any.

Return Values:

    None.  
    
--*/

{
    PH323_CALL pCall = NULL;
    
    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // close call asynchronously
    if (!H323PostCloseCallMessage(pCall->hdCall)) {

        // could not close call
        return LINEERR_OPERATIONFAILED;
    }

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall,
    LPCSTR        pUserUserInfo,
    DWORD         dwSize
    )
    
/*++

Routine Description:

    This functions drops or disconnects the specified call. The TAPI DLL has 
    the option to specify user-to-user information to be transmitted as part 
    of the call disconnect.

    When invoking TSPI_lineDrop related calls may sometimes be affected as 
    well. For example, dropping a conference call may drop all individual 
    participating calls. LINE_CALLSTATE messages are sent to the TAPI DLL for 
    all calls whose call state is affected. A dropped call will typically 
    transition to the idle state.

    Invoking TSPI_lineDrop on a call in the offering state rejects the call. 
    Not all telephone networks provide this capability.

    Invoking TSPI_lineDrop on a consultation call that was set up using either
    TSPI_lineSetupTransfer or TSPI_lineSetupConference, will cancel the 
    consultation call. Some switches automatically unhold the other call. 

    The TAPI DLL has the option to send user-to-user information at the time 
    of the drop. Even if user-to-user information can be sent, often no 
    guarantees are made that the network will deliver this information to the 
    remote party.

    Note that in various bridged or party line configurations when multiple 
    parties are on the call, TSPI_lineDrop by the application may not actually
    clear the call.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to 
        be dropped.  Valid call states: any.

    psUserUserInfo - Specifies a far pointer to a string containing 
        user-to-user information to be sent to the remote party as part of 
        the call disconnect.  This pointer is unused if dwUserUserInfoSize 
        is zero and no user-to-user information is to be sent. User-to-user 
        information is only sent if supported by the underlying network 
        (see LINEDEVCAPS).

    dwSize - Specifies the size in bytes of the user-to-user information in 
        psUserUserInfo. If zero, then psUserUserInfo can be left NULL, and 
        no user-to-user information will be sent to the remote party.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALPOINTER - The specified pointer parameter is invalid.

        LINEERR_INVALCALLSTATE - The current state of the call does not allow 
            the call to be dropped.
            
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    PH323_CALL pCall = NULL;

    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // save outgoing user user information (if specified)
    if (!H323AddU2U(&pCall->OutgoingU2U,dwSize,(PBYTE)pUserUserInfo)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not save user user info.\n"
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // no memory available
        return LINEERR_NOMEM;
    }

    // drop specified call 
    if (!H323PostDropCallMessage(pCall->hdCall,LINEDISCONNECTMODE_NORMAL)) {

        // release line device
        H323UnlockLine(pCall->pLine);

        // could not drop call
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    (*g_pfnCompletionProc)(dwRequestID, NOERROR);

    // release line device
    H323UnlockLine(pCall->pLine);

    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL hdCall,
    LPDWORD  pdwAddressID
    )
    
/*++

Routine Description:

    This operation allows the TAPI DLL to retrieve the address ID for the 
    indicated call.

    This operation must be executed synchronously by the Service Provider, 
    with presumed success.  This operation may be called from within the 
    context of the ASYNC_LINE_COMPLETION or LINEEVENT callbacks (i.e., from 
    within an interrupt context).  This function would typically be called 
    at the start of the call life cycle.

    If the Service Provider models lines as "pools" of channel resources 
    and does "inverse multiplexing" of a call over several address IDs it 
    should consistently choose one of these address IDs as the primary 
    identifier reported by this function and in the LINE_CALLINFO data 
    structure.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        whose address ID is to be retrieved.  Valid call states: any.

    pdwAddressID - Specifies a far pointer to a DWORD into which the 
        Service Provider writes the call's address ID.

Return Values:
    
    None.

--*/

{
    // only one addr
    *pdwAddressID = 0;

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  pCallInfo
    )
    
/*++

Routine Description:

    This operation enables the TAPI DLL to obtain fixed information about 
    the specified call.

    A separate LINECALLINFO structure exists for every (inbound or outbound) 
    call. The structure contains primarily fixed information about the call. 
    An application would typically be interested in checking this information 
    when it receives its handle for a call via the LINE_CALLSTATE message, or 
    each time it receives notification via a LINE_CALLINFO message that parts 
    of the call information structure have changed. These messages supply the 
    handle for the call as a parameter.

    If the Service Provider models lines as "pools" of channel resources and 
    does "inverse multiplexing" of a call over several address IDs it should 
    consistently choose one of these address IDs as the primary identifier 
    reported by this function in the LINE_CALLINFO data structure.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        whose call information is to be retrieved.

    pCallInfo - Specifies a far pointer to a variable sized data structure 
        of type LINECALLINFO. Upon successful completion of the request, this 
        structure is filled with call related information.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    PH323_CALL pCall = NULL;
    DWORD dwCalleeNameSize = 0;
    DWORD dwCallerNameSize = 0;
    DWORD dwCallerNumberSize = 0;
    DWORD dwNextOffset = sizeof(LINECALLINFO);
    DWORD dwU2USize = 0;
    WCHAR IPAddress[20];
    PBYTE pU2U = NULL;

    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // see if user user info available
    if (!IsListEmpty(&pCall->IncomingU2U)) {

        PLIST_ENTRY pLE;
        PH323_U2ULE pU2ULE;

        // get first list entry
        pLE = pCall->IncomingU2U.Flink;

        // convert to user user structure
        pU2ULE = CONTAINING_RECORD(pLE, H323_U2ULE, Link);

        // transfer info
        dwU2USize = pU2ULE->dwU2USize;
        pU2U = pU2ULE->pU2U;
    }

    // initialize caller and callee id flags now
    pCallInfo->dwCalledIDFlags = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwCallerIDFlags = LINECALLPARTYID_UNAVAIL;

    // calculate memory necessary for strings
    dwCalleeNameSize = H323SizeOfWSZ(pCall->ccCalleeAlias.pData);
    dwCallerNameSize = H323SizeOfWSZ(pCall->ccCallerAlias.pData);

    // convert the IP address to string. It is in host order.
    wsprintfW(IPAddress, L"%d.%d.%d.%d", 
            (pCall->ccCallerAddr.Addr.IP_Binary.dwAddr >> 24) & 0xff,
            (pCall->ccCallerAddr.Addr.IP_Binary.dwAddr >> 16) & 0xff,
            (pCall->ccCallerAddr.Addr.IP_Binary.dwAddr >> 8) & 0xff,
            (pCall->ccCallerAddr.Addr.IP_Binary.dwAddr) & 0xff
            );

    dwCallerNumberSize = H323SizeOfWSZ(IPAddress);

    // determine number of bytes needed
    pCallInfo->dwNeededSize = sizeof(LINECALLINFO) +
                              dwCalleeNameSize +
                              dwCallerNameSize +
                              dwCallerNumberSize +
                              dwU2USize
                              ;

    // see if structure size is large enough
    if (pCallInfo->dwTotalSize >= pCallInfo->dwNeededSize) {

        // record number of bytes used
        pCallInfo->dwUsedSize = pCallInfo->dwNeededSize;

        // validate string size
        if (dwCalleeNameSize > 0) {

            // callee name was specified
            pCallInfo->dwCalledIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for callee name
            pCallInfo->dwCalledIDNameSize = dwCalleeNameSize;
            pCallInfo->dwCalledIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            memcpy((LPBYTE)pCallInfo + pCallInfo->dwCalledIDNameOffset,
                   (LPBYTE)pCall->ccCalleeAlias.pData,
                   pCallInfo->dwCalledIDNameSize
                   );

            // adjust offset to include string
            dwNextOffset += pCallInfo->dwCalledIDNameSize;
        }

        // validate string size
        if (dwCallerNameSize > 0) {

            // caller name was specified
            pCallInfo->dwCallerIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwCallerIDNameSize = dwCallerNameSize;
            pCallInfo->dwCallerIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            memcpy((LPBYTE)pCallInfo + pCallInfo->dwCallerIDNameOffset,
                   (LPBYTE)pCall->ccCallerAlias.pData,
                   pCallInfo->dwCallerIDNameSize
                   );

            // adjust offset to include string
            dwNextOffset += pCallInfo->dwCallerIDNameSize;
        }

        // validate string size
        if (dwCallerNumberSize > 0) {

            // caller name was specified
            pCallInfo->dwCallerIDFlags |= LINECALLPARTYID_ADDRESS;

            // determine size and offset for caller name
            pCallInfo->dwCallerIDSize = dwCallerNumberSize;
            pCallInfo->dwCallerIDOffset = dwNextOffset;

            // copy call info after fixed portion
            memcpy((LPBYTE)pCallInfo + pCallInfo->dwCallerIDOffset,
                   (LPBYTE)IPAddress,
                   pCallInfo->dwCallerIDSize
                   );

            // adjust offset to include string
            dwNextOffset += pCallInfo->dwCallerIDSize;
        }

        // validate buffer
        if (dwU2USize > 0) {

            // determine size and offset of info
            pCallInfo->dwUserUserInfoSize = dwU2USize;
            pCallInfo->dwUserUserInfoOffset = dwNextOffset;

            // copy user user info after fixed portion
            memcpy((LPBYTE)pCallInfo + pCallInfo->dwUserUserInfoOffset,
                   (LPBYTE)pU2U,
                   pCallInfo->dwUserUserInfoSize
                   );

            // adjust offset to include string
            dwNextOffset += pCallInfo->dwUserUserInfoSize;
        }

    } else if (pCallInfo->dwTotalSize >= sizeof(LINECALLINFO)) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "linecallinfo structure too small for strings.\n"
            ));

        // structure only contains fixed portion
        pCallInfo->dwUsedSize = sizeof(LINECALLINFO);

    } else {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "linecallinfo structure too small.\n"
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // structure is too small
        return LINEERR_STRUCTURETOOSMALL;
    }

    // initialize call line device and address info
    pCallInfo->dwLineDeviceID = pCall->pLine->dwDeviceID;
    pCallInfo->dwAddressID    = 0;

    // initialize variable call parameters
    pCallInfo->dwOrigin     = pCall->dwOrigin;
    pCallInfo->dwMediaMode  = pCall->dwIncomingModes | pCall->dwOutgoingModes;
    pCallInfo->dwReason     = H323IsCallInbound(pCall) 
                                ? LINECALLREASON_UNAVAIL
                                : LINECALLREASON_DIRECT
                                ;
    pCallInfo->dwCallStates = H323IsCallInbound(pCall) 
                                ? H323_CALL_INBOUNDSTATES
                                : H323_CALL_OUTBOUNDSTATES
                                ;

    // initialize constant call parameters
    pCallInfo->dwBearerMode = H323_LINE_BEARERMODES;
    pCallInfo->dwRate       = H323_LINE_MAXRATE;

    // initialize unsupported call capabilities
    pCallInfo->dwConnectedIDFlags   = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    //pass on the dwAppSpecific info
    pCallInfo->dwAppSpecific = pCall->dwAppSpecific;

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return NOERROR;
}

/*++
Parameters
	
	  hdCall - The handle to the call whose application-specific field is to be
			set. The call state of hdCall can be any state. 
	
	  dwAppSpecific - The new content of the dwAppSpecific member for the call's
		LINECALLINFO structure. This value is uninterpreted by the service
		provider. This parameter is not validated by TAPI when this function is called. 

  
Return Values
	Returns zero if the function succeeds, or an error number if an error
	occurs. Possible return values are as follows: 

		LINEERR_INVALCALLHANDLE, 
		LINEERR_OPERATIONFAILED, 
		LINEERR_NOMEM, 
		LINEERR_RESOURCEUNAVAIL, 
		LINEERR_OPERATIONUNAVAIL. 

Routine Description:
	The application-specific field in the LINECALLINFO data structure that 
	exists for each call is uninterpreted by the Telephony API or any of its
	service providers. Its usage is entirely defined by the applications. The
	field can be read from the LINECALLINFO record returned by 
	TSPI_lineGetCallInfo. However, TSPI_lineSetAppSpecific must be used to set
	the field so that changes become visible to other applications. When this
	field is changed, the service provider sends a LINE_CALLINFO message with
	an indication that the AppSpecific field has changed.

++*/

LONG
TSPIAPI 
TSPI_lineSetAppSpecific(
  HDRVCALL hdCall,     
  DWORD dwAppSpecific  
)
{
    PH323_CALL pCall = NULL;
    
    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    pCall->dwAppSpecific = dwAppSpecific;

    (*g_pfnLineEventProc)(
            pCall->pLine->htLine,
            pCall->htCall,
            LINE_CALLINFO,
            LINECALLINFOSTATE_APPSPECIFIC,
            0,
            0
            );
    
    // release line device
    H323UnlockLine( pCall->pLine );

    // success
    return ERROR_SUCCESS;
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL         hdCall,
    LPLINECALLSTATUS pCallStatus
    )
    
/*++

Routine Description:

    This operation returns the current status of the specified call.

    TSPI_lineCallStatus returns the dynamic status of a call, whereas 
    TSPI_lineGetCallInfo returns primarily static information about a call. 
    Call status information includes the current call state, detailed mode 
    information related to the call while in this state (if any), as well 
    as a list of the available TSPI functions the TAPI DLL can invoke on the 
    call while the call is in this state.  An application would typically be 
    interested in requesting this information when it receives notification 
    about a call state change via the LINE_CALLSTATE message.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be queried for its status.  Valid call states: any.

    pCallStatus - Specifies a far pointer to a variable sized data structure 
        of type LINECALLSTATUS. Upon successful completion of the request, 
        this structure is filled with call status information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    PH323_CALL pCall = NULL;
    
    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // determine number of bytes needed
    pCallStatus->dwNeededSize = sizeof(LINECALLSTATUS);

    // see if structure size is large enough
    if (pCallStatus->dwTotalSize < pCallStatus->dwNeededSize) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "linecallstatus structure too small.\n"
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    // record amount of memory used
    pCallStatus->dwUsedSize = pCallStatus->dwNeededSize;

    // transer call state information    
    pCallStatus->dwCallState     = pCall->dwCallState;
    pCallStatus->dwCallStateMode = pCall->dwCallStateMode;

    // determine call feature based on state
    pCallStatus->dwCallFeatures = H323GetCallFeatures(pCall);

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          phdCall,
    LPCWSTR             pwszDialableAddr,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const pCallParams
    )
    
/*++

Routine Description:

    This function places a call on the specified line to the specified 
    destination address, exchanging opaque handles for the new call 
    between the TAPI DLL and Service Provider. Optionally, call parameters 
    can be specified if anything but default call setup parameters are 
    requested.

    After dialing has completed, several LINE_CALLSTATE messages will 
    typically be sent to the TAPI DLL to notify it about the progress of the 
    call. No generally valid sequence of call state transitions is specified 
    as no single fixed sequence of transitions can be guaranteed in practice. 
    A typical sequence may cause a call to transition from dialtone, dialing, 
    proceeding, ringback, to connected. With non-dialed lines, the call may 
    typically transition directly to connected state.

    The TAPI DLL has the option to specify an originating address on the 
    specified line device. A service provider that models all stations on a 
    switch as addresses on a single line device allows the TAPI DLL to 
    originate calls from any of these stations using TSPI_lineMakeCall.

    The call parameters allow the TAPI DLL to make non voice calls or request 
    special call setup options that are not available by default.

    The TAPI DLL can partially dial using TSPI_lineMakeCall and continue 
    dialing using TSPI_lineDial. To abandon a call attempt, use TSPI_lineDrop.

    The Service Provider initially does media monitoring on the new call for 
    at least the set of media modes that were monitored for on the line.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdLine - Specifies the Service Provider's opaque handle to the line on 
        which the new call is to be originated.

    htCall - Specifies the TAPI DLL's opaque handle to the new call.  The 
        Service Provider must save this and use it in all subsequent calls to 
        the LINEEVENT procedure reporting events on the call.

    phdCall - Specifies a far pointer to an opaque HDRVCALL representing the 
        Service Provider's identifier for the call.  The Service Provider must
        fill this location with its opaque handle for the call before this 
        procedure returns, whether it decides to execute the request 
        sychronously or asynchronously.  This handle is invalid if the function
        results in an error (either synchronously or asynchronously).

    pwszDialableAddr - Specifies a far pointer to the destination address. This 
        follows the standard dialable number format. This pointer may be 
        specified as NULL for non-dialed addresses (i.e., a hot phone) or when
        all dialing will be performed using TSPI_lineDial. In the latter case,
        TSPI_lineMakeCall will allocate an available call appearance which 
        would typically remain in the dialtone state until dialing begins. 
        Service providers that have inverse multiplexing capabilities may allow
        an application to specify multiple addresses at once.

    dwCountryCode - Specifies the country code of the called party. If a value 
        of zero is specified, then a default will be used by the 
        implementation.

    pCallParams - Specifies a far pointer to a LINECALLPARAMS structure. This 
        structure allows the TAPI DLL to specify how it wants the call to be 
        set up. If NULL is specified, then a default 3.1kHz voice call is 
        established, and an arbitrary origination address on the line is 
        selected.  This structure allows the TAPI DLL to select such elements 
        as the call's bearer mode, data rate, expected media mode, origination
        address, blocking of caller ID information, dialing parameters, etc.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error 
    number if an error has occurred. Possible error returns are:
    
        LINEERR_CALLUNAVAIL - All call appearances on the specified address are 
            currently in use.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_INVALADDRESSMODE - The address mode is invalid.

        LINEERR_INVALBEARERMODE - The bearer mode is invalid.

        LINEERR_INVALCALLPARAMS - The specified call parameter structure is 
            invalid.

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALLINESTATE - The line is currently not in a state in 
            which this operation can be performed. 

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

        LINEERR_OPERATIONFAILED - The operation failed for unspecified reasons.

        LINEERR_RESOURCEUNAVAIL - The specified operation cannot be completed 
            because of resource overcommitment.

--*/

{
    PH323_CALL pCall = NULL;
    PH323_LINE pLine = NULL;
    DWORD dwStatus = dwRequestID;

    UNREFERENCED_PARAMETER(dwCountryCode);

    // retrieve line device pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        // invalid line device handle
        return LINEERR_INVALLINEHANDLE;
    }

    // validate line state
    if (!H323IsLineOpen(pLine)) {
        
        H323DBG((
            DEBUG_LEVEL_ERROR,
            "line %d is not currently opened.\n",
            pLine->dwDeviceID
            ));

        // release line device
        H323UnlockLine(pLine);

        // line needs to be opened
        return LINEERR_INVALLINESTATE;
    }
    
    // see if line is available
    if (!H323IsLineAvailable(pLine)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "line %d is currently at maximum capacity.\n",
            pLine->dwDeviceID
            ));
    
        // release line device
        H323UnlockLine(pLine);

        // line is currenty maxed
        return LINEERR_RESOURCEUNAVAIL;
    }

    // allocate outgoing call from line call table
    if (!H323AllocCallFromTable(&pCall,&pLine->pCallTable,pLine)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call.\n"
            ));

        // release line device
        H323UnlockLine(pLine);

        // no memory available
        return LINEERR_NOMEM;
    }    

    // save tapi handle
    pCall->htCall = htCall;

    // save back pointer
    pCall->pLine = pLine;

    // specify outgoing call direction
    pCall->dwOrigin = LINECALLORIGIN_OUTBOUND;    

    // validate call parameters
    if (!H323ValidateCallParams(
            pCall,
            pCallParams,
            pwszDialableAddr,
            &dwStatus)) {

        // failure
        goto cleanup;
    }

    // bind outgoing call
    if (!H323BindCall(pCall,NULL)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not bind call.\n"
            ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    // post place request to callback thread
    if (!H323PostPlaceCallMessage(pCall->hdCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not post place call message.\n"
            ));

        // could not complete operation
        dwStatus = LINEERR_OPERATIONFAILED;

        // failure
        goto cleanup;
    }
    
    // complete the async accept operation now
    (*g_pfnCompletionProc)(dwRequestID, NOERROR);

    // change call state to accepted from offering
    H323ChangeCallState(pCall, LINECALLSTATE_DIALING, 0);

    // transfer handle
    *phdCall = pCall->hdCall;

    // release line device
    H323UnlockLine(pLine);

    // success
    return dwStatus;

cleanup:

    // unbind call
    H323UnbindCall(pCall);

    // release outgoing call from line call table
    H323FreeCallFromTable(pCall,pLine->pCallTable);

    // release line device
    H323UnlockLine(pLine);

    // failure
    return dwStatus;
}


LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    )
{
    PLIST_ENTRY pLE;
    PH323_U2ULE pU2ULE;
    PH323_CALL  pCall = NULL;

    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // see if list is empty
    if (!IsListEmpty(&pCall->IncomingU2U)) {

        // remove first entry from list
        pLE = RemoveHeadList(&pCall->IncomingU2U);

        // convert to user user structure
        pU2ULE = CONTAINING_RECORD(pLE, H323_U2ULE, Link);

        // release memory
        H323HeapFree(pU2ULE);
    }

    // see if list contains pending data
    if (!IsListEmpty(&pCall->IncomingU2U)) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "more user user info available.\n"
            ));

        // signal incoming
        (*g_pfnLineEventProc)(
            pCall->pLine->htLine,
            pCall->htCall,
            LINE_CALLINFO,
            LINECALLINFOSTATE_USERUSERINFO,
            0,
            0
            );
    }

    // complete the async accept operation now
    (*g_pfnCompletionProc)(dwRequestID, NOERROR);

    // release line device
    H323UnlockLine(pCall->pLine);

    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              pUserUserInfo,
    DWORD               dwSize
    )
{
    HRESULT hr;
    PH323_CALL pCall = NULL;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_NONSTANDARDDATA pNonStandardData = NULL;
    
    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // check for user user info
    if (pUserUserInfo != NULL) {

        // transfer header information
        NonStandardData.bCountryCode      = H221_COUNTRY_CODE_USA;
        NonStandardData.bExtension        = H221_COUNTRY_EXT_USA;
        NonStandardData.wManufacturerCode = H221_MFG_CODE_MICROSOFT;
                
        // initialize octet string containing data
        NonStandardData.sData.wOctetStringLength = LOWORD(dwSize);
        NonStandardData.sData.pOctetString = (PBYTE)pUserUserInfo;

        // point to stack based structure
        pNonStandardData = &NonStandardData;
    }

    // send user user data
    hr = CC_SendNonStandardMessage(
                pCall->hccCall,
                CC_H245_MESSAGE_COMMAND,
                pNonStandardData
                );
                
    // validate status
    if (hr != CC_OK) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error %s (0x%08lx) sending non-standard message.\n",
            H323StatusToString((DWORD)hr), hr
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // unable to answer call
        return LINEERR_OPERATIONFAILED;
    }

    // complete the async accept operation now
    (*g_pfnCompletionProc)(dwRequestID, NOERROR);

    // release line device
    H323UnlockLine(pCall->pLine);

    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL hdCall,
    DWORD    dwDigitModes
    )
{
    PH323_CALL pCall = NULL;

    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // see if mode empty
    if (dwDigitModes == 0) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "disabling dtmf detection.\n"
            ));

        // enable monitoring digits
        pCall->fMonitoringDigits = FALSE;

        // release line device
        H323UnlockLine(pCall->pLine);

        // success
        return NOERROR;

    } else if (dwDigitModes != LINEDIGITMODE_DTMF) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid digit modes 0x%08lx.\n",
            dwDigitModes
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // invalid call handle
        return LINEERR_INVALDIGITMODE;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "enabling dtmf detection.\n"
        ));

    // enable monitoring digits
    pCall->fMonitoringDigits = TRUE;

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL hdCall,
    DWORD    dwEndToEndID,
    DWORD    dwDigitMode,
    LPCWSTR  pwszDigits,
    DWORD    dwDuration
    )
{
    HRESULT hr;
    PH323_CALL pCall = NULL;

    UNREFERENCED_PARAMETER(dwDuration);

    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // invalid call handle
        return LINEERR_INVALCALLHANDLE;
    }

    // verify that the call was connected
    if (!H323IsCallConnected(pCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "call 0x%08lx not connected.\n",
            pCall
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        return LINEERR_INVALCALLSTATE;
    }

    // verify monitor modes
    if (dwDigitMode != LINEDIGITMODE_DTMF) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid digit mode 0x%08lx.\n",
            dwDigitMode
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // invalid call handle
        return LINEERR_INVALDIGITMODE;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "sending user input %S.\n",
        pwszDigits
        ));

    // send user input message
    hr = CC_UserInput(pCall->hccCall, (PWSTR)pwszDigits);

    // validate
    if (hr != CC_OK) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx sending user input message.\n",
            hr
            ));

        // signal completion
        (*g_pfnLineEventProc)(
            pCall->pLine->htLine,
            pCall->htCall,
            LINE_GENERATE,
            LINEGENERATETERM_CANCEL,
            dwEndToEndID,
            GetTickCount()
            );

        // release line device
        H323UnlockLine(pCall->pLine);

        // failure
        return LINEERR_INVALDIGITS;
    }

    // signal completion
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_GENERATE,
        LINEGENERATETERM_DONE,
        dwEndToEndID,
        GetTickCount()
        );

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\call.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    call.h

Abstract:

    Definitions for H.323 TAPI Service Provider call objects.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_CALL
#define _INC_CALL
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "channel.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Type definitions                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef enum _H323_CALLSTATE {

    H323_CALLSTATE_ALLOCATED = 0,           
    H323_CALLSTATE_IN_USE                   

} H323_CALLSTATE, *PH323_CALLSTATE;

typedef struct _H323_U2ULE {

    LIST_ENTRY Link;
    DWORD dwU2USize;
    PBYTE pU2U;

} H323_U2ULE, *PH323_U2ULE;

typedef struct _H323_CALL {
                        
    HDRVCALL               hdCall;              // tspi call handle
    HTAPICALL              htCall;              // tapi call handle
    CC_HCALL               hccCall;             // intelcc call handle
    CC_HCONFERENCE         hccConf;             // intelcc conf handle

    H323_CALLSTATE         nState;              // state of call object

    DWORD                  dwCallState;         // tspi call state
    DWORD                  dwCallStateMode;     // tspi call state mode

    DWORD                  dwOrigin;            // inbound or outbound

    DWORD                  dwAddressType;       // type of dst address

    DWORD                  dwIncomingModes;     // available media modes
    DWORD                  dwOutgoingModes;     // available media modes
    DWORD                  dwRequestedModes;    // requested media modes
    DWORD		   dwAppSpecific;	

    BOOL                   fMonitoringDigits;   // listening for dtmf flag

    DWORD                  dwLinkSpeed;         // speed of network connection

    LIST_ENTRY             IncomingU2U;         // incoming user user messages
    LIST_ENTRY             OutgoingU2U;         // outgoing user user messages

    CC_ADDR                ccCalleeAddr;        // intelcc src address
    CC_ADDR                ccCallerAddr;        // intelcc dst address

    CC_ALIASITEM           ccCalleeAlias;       // intelcc src alias
    CC_ALIASITEM           ccCallerAlias;       // intelcc dst alias

    CC_TERMCAP             ccRemoteAudioCaps;   // remote party audio
    CC_TERMCAP             ccRemoteVideoCaps;   // remote party video

    PH323_CHANNEL_TABLE    pChannelTable;       // table of logical channels
    struct _H323_LINE *    pLine;               // pointer to containing line

} H323_CALL, *PH323_CALL;                   

typedef struct _H323_CALL_TABLE {

    DWORD       dwNumSlots;                 // number of entries
    DWORD       dwNumInUse;                 // number of entries in use
    DWORD       dwNumAllocated;             // number of entries allocated
    DWORD       dwNextAvailable;            // next available table index 
    PH323_CALL  pCalls[ANYSIZE];            // array of object pointers
                
} H323_CALL_TABLE, *PH323_CALL_TABLE;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323BindCall(
    PH323_CALL       pCall,
    PCC_CONFERENCEID pConferenceID
    );
        
BOOL
H323UnbindCall(
    PH323_CALL pCall
    );
   
BOOL
H323PlaceCall(
    PH323_CALL pCall
    );

BOOL
H323HangupCall(
    PH323_CALL pCall
    );
        
BOOL
H323CloseCall(
    PH323_CALL pCall 
    );
        
BOOL
H323DropCall(
    PH323_CALL pCall,
    DWORD      dwDisconnectMode
    );

BOOL
H323GetCallAndLock(
    PH323_CALL * ppCall, 
    HDRVCALL     hdCall
    );

BOOL
H323GetCallByHCall(
    PH323_CALL *        ppCall,
    struct _H323_LINE * pLine,
    CC_HCALL            hccCall
    );

BOOL
H323ChangeCallState(
    PH323_CALL pCall,
    DWORD      dwCallState,
    DWORD      dwCallStateMode
    );
        
BOOL
H323ChangeCallStateToIdle(
    PH323_CALL pCall,
    DWORD      dwDisconnectMode
    );

BOOL
H323AllocCallTable(
    PH323_CALL_TABLE * ppCallTable
    );
        
BOOL
H323FreeCallTable(
    PH323_CALL_TABLE pCallTable
    );
        
BOOL
H323CloseCallTable(
    PH323_CALL_TABLE pCallTable
    );
        
BOOL
H323AllocCallFromTable(
    PH323_CALL *        ppCall,
    PH323_CALL_TABLE *  ppCallTable,
    struct _H323_LINE * pLine
    );

BOOL
H323FreeCallFromTable(
    PH323_CALL       pCall,
    PH323_CALL_TABLE pCallTable
    );

BOOL
H323UpdateMediaModes(
    PH323_CALL pCall
    );

BOOL
H323AcceptCall(
    PH323_CALL pCall
    );

BOOL
H323AddU2U(
    PLIST_ENTRY pListHead,
    DWORD       dwDataSize,
    PBYTE       pData
    );

BOOL
H323RemoveU2U(
    PLIST_ENTRY   pListHead,
    PH323_U2ULE * ppU2ULE
    );

DWORD
H323DetermineLinkSpeed(
    DWORD dwHostAddr
    );

BOOL
H323GetTermCapList(
    PH323_CALL             pCall,
    PCC_TERMCAPLIST        pTermCapList,
    PCC_TERMCAPDESCRIPTORS pTermCapDescriptors
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Call capabilites                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323_CALL_INBOUNDSTATES        (LINECALLSTATE_ACCEPTED | \
                                        LINECALLSTATE_CONNECTED | \
                                        LINECALLSTATE_DISCONNECTED | \
                                        LINECALLSTATE_IDLE | \
                                        LINECALLSTATE_OFFERING)   
#define H323_CALL_OUTBOUNDSTATES       (LINECALLSTATE_CONNECTED | \
                                        LINECALLSTATE_DIALING | \
                                        LINECALLSTATE_DISCONNECTED | \
                                        LINECALLSTATE_IDLE | \
                                        LINECALLSTATE_RINGBACK)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323IsCallAllocated(_pCall_) \
    ((_pCall_) != NULL)

#define H323IsCallInUse(_pCall_) \
    (H323IsCallAllocated(_pCall_) && \
     ((_pCall_)->nState > H323_CALLSTATE_ALLOCATED))

#define H323IsCallEqual(_pCall_,_hdCall_) \
    (H323IsCallInUse(_pCall_) && \
     ((_pCall_)->hdCall == (_hdCall_)))

#define H323IsCallActive(_pCall_) \
    (((_pCall_)->dwCallState != LINECALLSTATE_IDLE) && \
     ((_pCall_)->dwCallState != LINECALLSTATE_DISCONNECTED))

#define H323IsCallIdle(_pCall_) \
    ((_pCall_)->dwCallState == LINECALLSTATE_IDLE) 

#define H323IsCallDisconnected(_pCall_) \
    ((_pCall_)->dwCallState == LINECALLSTATE_DISCONNECTED)

#define H323IsCallConnected(_pCall_) \
    ((_pCall_)->dwCallState == LINECALLSTATE_CONNECTED)

#define H323IsCallProceeding(_pCall_) \
    (((_pCall_)->dwCallState == LINECALLSTATE_DIALING) || \
     ((_pCall_)->dwCallState == LINECALLSTATE_RINGBACK))

#define H323IsCallOffering(_pCall_) \
    ((_pCall_)->dwCallState == LINECALLSTATE_OFFERING)

#define H323IsCallInbound(_pCall_) \
    ((_pCall_)->dwOrigin == LINECALLORIGIN_INBOUND)

#define H323GetCallFeatures(_pCall_) \
    (((_pCall_)->dwCallState != LINECALLSTATE_IDLE) \
        ? LINECALLFEATURE_DROP \
        : 0) 

#define H323GetLineHandle(_hdCall_) \
    ((HDRVLINE)(DWORD)HIWORD((DWORD)(_hdCall_)))

#define H323GetCallTableIndex(_hdCall_) \
    ((DWORD)LOWORD((DWORD)(_hdCall_)))

#define H323CreateCallHandle(_hdLine_,_i_) \
    ((HDRVCALL)MAKELONG(LOWORD((DWORD)(_i_)),LOWORD((DWORD)(_hdLine_))))

#define H323IsVideoRequested(_pCall_) \
    ((_pCall_)->dwRequestedModes & LINEMEDIAMODE_VIDEO)

#define H323IsAutomatedVoiceRequested(_pCall_) \
     ((_pCall_)->dwRequestedModes & LINEMEDIAMODE_AUTOMATEDVOICE)

#define H323IsInteractiveVoiceRequested(_pCall_) \
     ((_pCall_)->dwRequestedModes & LINEMEDIAMODE_INTERACTIVEVOICE)

#define H323IsMediaUnresolved(_pCall_) \
    ((_pCall_)->dwOutgoingModes & LINEMEDIAMODE_UNKNOWN)

#define H323IsAudioRequested(_pCall_) \
    (H323IsAutomatedVoiceRequested(_pCall_) || \
     H323IsInteractiveVoiceRequested(_pCall_)) 

#endif // _INC_CALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323msp\h323vid.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confvid.h

Abstract:

    Definitions for video streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFVID_H_
#define __CONFVID_H_

const DWORD g_dwVideoThreadPriority = THREAD_PRIORITY_NORMAL;
const DWORD g_dwVideoChannels       = 1;  
const DWORD g_dwVideoSampleRateHigh    = 8;  
const DWORD g_dwVideoSampleRateLow     = 5;  

const int CIFWIDTH      = 0x160;
const int CIFHEIGHT     = 0x120;

const int QCIFWIDTH     = 0xb0;
const int QCIFHEIGHT    = 0x90;

// This is the lowest bitrate we will use.
const int BITRATELOWERLIMIT  = 4000;  

// This is the threshold for sending a flow control command.
const int BITRATEDELTA  = 2000;

// This is increment we use for adjust back to normal.
const int BITRATEINC    = 1000;  

const DWORD VIDEO_INITIAL_ADJUSTMENT_THRESHOLD = 12000;
const float VIDEO_INITIAL_ADJUSTMENT = 0.8f;

const int IFRAMEINTERVAL = 15000;  // in miliseconds.

typedef enum _ENCODERCOMMAND
{
    EC_BITRATE,
    EC_IFRAME
} ENCODERCOMMAND, *PENCODERCOMMAND;

class CStreamVideoRecv : public CH323MSPStream
{
public:
    CStreamVideoRecv();

    HRESULT Configure(
        IN HANDLE          htChannel,
        IN STREAMSETTINGS &StreamSettings
        );

protected:
    HRESULT SetUpFilters();

    HRESULT SetUpInternalFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConfigureRTPFilter(
        IN  IBaseFilter *   pIBaseFilter
        );
    
    HRESULT HandlePacketReceiveLoss(
        IN DWORD dwLossRate
        );

protected:
    DWORD           m_dwCurrentBitRate;
    DWORD           m_dwProposedBitRate;
    DWORD           m_dwLastIFrameRequestedTime;
    DWORD           m_dwIFramePending;
};


class CStreamVideoSend : public CH323MSPStream
{
public:
    CStreamVideoSend();

    HRESULT Configure(
        IN HANDLE          htChannel,
        IN STREAMSETTINGS &StreamSettings
        );
    
    HRESULT ShutDown ();

    HRESULT SendIFrame();

    HRESULT ChangeMaxBitRate(
        IN  DWORD dwMaxBitRate
        );

protected:
    HRESULT CheckTerminalTypeAndDirection(
        IN  ITTerminal *            pTerminal
        );

    HRESULT SetUpFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CStreamVideoSend::CreateSendFilters(
        IN    IPin          *pCapturePin
        );

    HRESULT CStreamVideoSend::ConnectPreview(
        IN    IPin          *pPreviewInputPin
        );

    HRESULT ConfigureVideoCaptureTerminal(
        IN  ITTerminalControl*  pTerminal,
        OUT IPin **             ppIPin
        );

    HRESULT FindPreviewInputPin(
        IN  ITTerminalControl*  pTerminal,
        OUT IPin **             ppIpin
        );

    HRESULT ConfigureRTPFilter(
        IN  IBaseFilter *   pIBaseFilter
        );

    HRESULT HandlePacketTransmitLoss(
        IN DWORD dwLossRate
        );

protected:
    IBaseFilter *   m_pIEncoderFilter;

    DWORD           m_dwCurrentBitRate;
    DWORD           m_dwProposedBitRate;
    DWORD           m_dwLastIFrameSentTime;
    DWORD           m_dwIFramePending;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\channel.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    channel.c

Abstract:

    Routines to manipulate H.245 logical channels.

Environment:

    User Mode - Win32

Revision History:

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "termcaps.h"
#include "callback.h"
#include "line.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323ResetChannel(
    PH323_CHANNEL pChannel
    )
        
/*++

Routine Description:

    Resets channel object original state for re-use.

Arguments:

    pChannel - Pointer to channel object to reset.

Return Values:

    Returns true if successful.
    
--*/

{
    // change channel state to allocated
    pChannel->nState = H323_CHANNELSTATE_ALLOCATED;

    // initialize stream description
    memset(&pChannel->Settings,0,sizeof(STREAMSETTINGS));

    // uninitialize msp channel handle
    pChannel->hmChannel = NULL;

    // uninitialize channel handle
    pChannel->hccChannel = UNINITIALIZED;

    // reset local addresses and sync up RTCP ports
    pChannel->ccLocalRTPAddr.Addr.IP_Binary.dwAddr  = 0;
    pChannel->ccLocalRTCPAddr.Addr.IP_Binary.dwAddr = 0;
    pChannel->ccLocalRTCPAddr.Addr.IP_Binary.wPort  =
        pChannel->ccLocalRTPAddr.Addr.IP_Binary.wPort + 1;

    // reset remote addresses (including port numbers)
    pChannel->ccRemoteRTPAddr.Addr.IP_Binary.dwAddr  = 0;
    pChannel->ccRemoteRTPAddr.Addr.IP_Binary.wPort   = 0;
    pChannel->ccRemoteRTCPAddr.Addr.IP_Binary.dwAddr = 0;
    pChannel->ccRemoteRTCPAddr.Addr.IP_Binary.wPort  = 0;

    // initialize caps
    memset(&pChannel->ccTermCaps,0,sizeof(CC_TERMCAP));

    // initialize other info
    pChannel->bPayloadType = (BYTE)UNINITIALIZED;
    pChannel->bSessionID   = (BYTE)UNINITIALIZED;

    // initialize direction
    pChannel->fInbound = FALSE;

    // success
    return TRUE;
}


BOOL
H323AllocChannel(
    PH323_CHANNEL * ppChannel
    )
        
/*++

Routine Description:

    Allocates new channel object.

Arguments:

    ppChannel - Pointer to DWORD-sized value in which service provider
        must place the newly allocated channel object.

Return Values:

    Returns true if successful.
    
--*/

{
    PH323_CHANNEL pChannel = NULL;

    // allocate channel object
    pChannel = H323HeapAlloc(sizeof(H323_CHANNEL));

    // validate pointer
    if (pChannel == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate channel object.\n"
            ));

        // failure
        return FALSE;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "channel 0x%08lx allocated.\n",
        pChannel
        ));

    // reset channel object
    H323ResetChannel(pChannel);

    // transfer pointer
    *ppChannel = pChannel;

    // success
    return TRUE;
}


BOOL
H323FreeChannel(
    PH323_CHANNEL pChannel
    )
        
/*++

Routine Description:

    Release memory associated with channel.

Arguments:

    pChannel - Pointer to channel to release.

Return Values:

    Returns true if successful.
    
--*/

{
    // release memory    
    H323HeapFree(pChannel);
    
    H323DBG((  
        DEBUG_LEVEL_VERBOSE,
        "channel 0x%08lx released.\n", 
        pChannel
        ));

    // success
    return TRUE; 
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323OpenChannel(
    PH323_CHANNEL pChannel
    )
        
/*++

Routine Description:

    Opens channel to destination address.

Arguments:

    pChannel - Pointer to channel to open.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;

    // open channel
    hr = CC_OpenChannel(
            pChannel->pCall->hccConf,       // hConference
            &pChannel->hccChannel,          // phChannel
            pChannel->bSessionID,           // bSessionID
            0,                              // bAssociatedSessionID
            TRUE,                           // bSilenceSuppression
            &pChannel->ccTermCaps,          // pTermCap
            &pChannel->ccLocalRTCPAddr,     // pLocalRTCPAddr    
            0,                              // bDynamicRTPPayloadType
            0,                              // dwChannelBitRate
            PtrToUlong(pChannel->pCall->hdCall)  // dwUserToken
            );
                    
    // validate
    if (hr != CC_OK) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error %s (0x%08lx) opening channel 0x%08lx.\n",
            H323StatusToString((DWORD)hr), hr,
            pChannel
            ));

        // failure
        return FALSE;
    }

    // change channel state to opening
    pChannel->nState = H323_CHANNELSTATE_OPENING;

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "channel 0x%08lx opening.\n",
        pChannel
        ));

    // success
    return TRUE;    
}


BOOL
H323CloseChannel(
    PH323_CHANNEL pChannel
    )
        
/*++

Routine Description:

    Closes channel.

Arguments:

    pChannel - Pointer to channel to close.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    
    // see if channel opened
    if (H323IsChannelOpen(pChannel) &&
        H323IsCallActive(pChannel->pCall)) {

        // give peer close channel indication        
        hr = CC_CloseChannel(pChannel->hccChannel);

        // validate status
        if (hr != CC_OK) {

            H323DBG((  
                DEBUG_LEVEL_ERROR,
                "error %s (0x%08lx) closing channel 0x%08lx.\n", 
                H323StatusToString((DWORD)hr), hr,
                pChannel
                ));
        
            // 
            // Could not close channel so just 
            // mark as closed and continue...
            //
        }
    }

    // mark entry as allocated
    H323FreeChannelFromTable(pChannel,pChannel->pCall->pChannelTable);

    H323DBG((  
        DEBUG_LEVEL_VERBOSE,
        "channel 0x%08lx closed.\n", 
        pChannel
        ));

    // success
    return TRUE; 
}


BOOL
H323AllocChannelTable(
    PH323_CHANNEL_TABLE * ppChannelTable
    )
        
/*++

Routine Description:

    Allocates table of channel objects.

Arguments:

    ppChannelTable - Pointer to DWORD-sized value which service
         provider must fill in with newly allocated table.

Return Values:

    Returns true if successful.
    
--*/

{
    PH323_CHANNEL_TABLE pChannelTable;

    // allocate table from heap
    pChannelTable = H323HeapAlloc(
                     sizeof(H323_CHANNEL_TABLE) + 
                     sizeof(PH323_CHANNEL) * H323_DEFMEDIAPERCALL
                     );

    // validate table pointer
    if (pChannelTable == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate channel table.\n"
            ));

        // failure
        return FALSE;
    }

    // initialize number of entries in table
    pChannelTable->dwNumSlots = H323_DEFMEDIAPERCALL;

    // transfer pointer to caller
    *ppChannelTable = pChannelTable;

    // success
    return TRUE;
}


BOOL
H323FreeChannelTable(
    PH323_CHANNEL_TABLE pChannelTable
    )
        
/*++

Routine Description:

    Deallocates table of channel objects.

Arguments:

    pChannelTable - Pointer to channel table to release.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;

    // loop through each object in table
    for (i = 0; i < pChannelTable->dwNumSlots; i++) {

        // validate object has been allocated
        if (H323IsChannelAllocated(pChannelTable->pChannels[i])) {

            // release memory for object 
            H323FreeChannel(pChannelTable->pChannels[i]);
        }
    }

    // release memory for table 
    H323HeapFree(pChannelTable);

    // success
    return TRUE;
}


BOOL
H323CloseChannelTable(
    PH323_CHANNEL_TABLE pChannelTable
    )
        
/*++

Routine Description:

    Closes table of channel objects.

Arguments:

    pChannelTable - Pointer to channel table to close.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    
    // loop through each object in table
    for (i = 0; i < pChannelTable->dwNumSlots; i++) {

        // validate object is in use
        if (H323IsChannelInUse(pChannelTable->pChannels[i])) {

            // close channel object
            H323CloseChannel(pChannelTable->pChannels[i]);
        }
    }

    // success
    return TRUE;
}


BOOL
H323AllocChannelFromTable(
    PH323_CHANNEL *       ppChannel,
    PH323_CHANNEL_TABLE * ppChannelTable,
    PH323_CALL            pCall
    )
        
/*++

Routine Description:

    Allocates channel object in table.

Arguments:

    ppChannel - Specifies a pointer to a DWORD-sized value in which the
        service provider must write the allocated channel object.

    ppChannelTable - Pointer to pointer to channel table in which to 
        allocate channel from (expands table if necessary).

    pCall - Pointer to containing call object.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    PH323_CHANNEL pChannel = NULL;
    PH323_CHANNEL_TABLE pChannelTable = *ppChannelTable;
    
    // retrieve index to next entry
    i = pChannelTable->dwNextAvailable;

    // see if previously allocated entries available
    if (pChannelTable->dwNumAllocated > pChannelTable->dwNumInUse) {

        // search table looking for available entry
        while (H323IsChannelInUse(pChannelTable->pChannels[i]) ||
              !H323IsChannelAllocated(pChannelTable->pChannels[i])) {

            // increment index and adjust to wrap
            i = H323GetNextIndex(i, pChannelTable->dwNumSlots);
        }

        // retrieve pointer to object
        pChannel = pChannelTable->pChannels[i];

        // mark entry as being in use
        pChannel->nState = H323_CHANNELSTATE_CLOSED;

        // re-initialize rtp address
        pChannel->ccLocalRTPAddr.Addr.IP_Binary.dwAddr =
            H323IsCallInbound(pCall)
                ? pCall->ccCalleeAddr.Addr.IP_Binary.dwAddr
                : pCall->ccCallerAddr.Addr.IP_Binary.dwAddr
                ;

        // re-initialize rtcp address
        pChannel->ccLocalRTCPAddr.Addr.IP_Binary.dwAddr =
            pChannel->ccLocalRTPAddr.Addr.IP_Binary.dwAddr;

        // increment number in use
        pChannelTable->dwNumInUse++;

        // adjust next available index
        pChannelTable->dwNextAvailable = 
            H323GetNextIndex(i, pChannelTable->dwNumSlots);

        // transfer pointer
        *ppChannel = pChannel;

        // success
        return TRUE;
    } 
    
    // see if table is full and more slots need to be allocated
    if (pChannelTable->dwNumAllocated == pChannelTable->dwNumSlots) {

        // attempt to double table
        pChannelTable = H323HeapReAlloc(
                          pChannelTable, 
                          sizeof(H323_CHANNEL_TABLE) +
                          pChannelTable->dwNumSlots * 2 * sizeof(PH323_CHANNEL)
                          );                                 

        // validate pointer
        if (pChannelTable == NULL) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "could not expand channel table.\n"
                ));

            // failure
            return FALSE;
        }

        // adjust index into table
        i = pChannelTable->dwNumSlots;
        
        // adjust number of slots
        pChannelTable->dwNumSlots *= 2;

        // transfer pointer to caller
        *ppChannelTable = pChannelTable;
    } 
    
    // allocate new object 
    if (!H323AllocChannel(&pChannel)) {

        // failure
        return FALSE;
    }

    // search table looking for slot with no object allocated
    while (H323IsChannelAllocated(pChannelTable->pChannels[i])) {

        // increment index and adjust to wrap
        i = H323GetNextIndex(i, pChannelTable->dwNumSlots);
    }

    // store pointer to object
    pChannelTable->pChannels[i] = pChannel;

    // mark entry as being in use
    pChannel->nState = H323_CHANNELSTATE_CLOSED;

    // initialize rtp address
    pChannel->ccLocalRTPAddr.nAddrType = CC_IP_BINARY;
    pChannel->ccLocalRTPAddr.Addr.IP_Binary.dwAddr =
        H323IsCallInbound(pCall)
            ? pCall->ccCalleeAddr.Addr.IP_Binary.dwAddr
            : pCall->ccCallerAddr.Addr.IP_Binary.dwAddr
            ;
    pChannel->ccLocalRTPAddr.Addr.IP_Binary.wPort =
        LOWORD(pCall->pLine->dwNextPort++);
    pChannel->ccLocalRTPAddr.bMulticast = FALSE;

    // initialize rtcp address
    pChannel->ccLocalRTCPAddr.nAddrType = CC_IP_BINARY;
    pChannel->ccLocalRTCPAddr.Addr.IP_Binary.dwAddr =
        pChannel->ccLocalRTPAddr.Addr.IP_Binary.dwAddr;
    pChannel->ccLocalRTCPAddr.Addr.IP_Binary.wPort =
        LOWORD(pCall->pLine->dwNextPort++);
    pChannel->ccLocalRTCPAddr.bMulticast = FALSE;

    // increment number in use
    pChannelTable->dwNumInUse++;

    // increment number allocated
    pChannelTable->dwNumAllocated++;    

    // adjust next available index
    pChannelTable->dwNextAvailable = 
        H323GetNextIndex(i, pChannelTable->dwNumSlots);

#if DBG
    {
        DWORD dwIPAddr;

        dwIPAddr = htonl(pChannel->ccLocalRTPAddr.Addr.IP_Binary.dwAddr);

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "channel 0x%08lx stored in slot %d (%s:%d).\n",
            pChannel, i,
            H323AddrToString(dwIPAddr),
            pChannel->ccLocalRTPAddr.Addr.IP_Binary.wPort
            ));
    }
#endif

    // transfer pointer
    *ppChannel = pChannel;

    // success
    return TRUE;
}


BOOL
H323FreeChannelFromTable(
    PH323_CHANNEL       pChannel,
    PH323_CHANNEL_TABLE pChannelTable
    )
        
/*++

Routine Description:

    Deallocates channel object in table.

Arguments:

    pChannel - Pointer to object to deallocate.

    pChannelTable - Pointer to table containing object.

Return Values:

    Returns true if successful.
    
--*/

{
    // reset channel object
    H323ResetChannel(pChannel);

    // decrement entries in use
    pChannelTable->dwNumInUse--;

    // success
    return TRUE;    
}


BOOL
H323LookupChannelByHandle(
    PH323_CHANNEL *     ppChannel,
    PH323_CHANNEL_TABLE pChannelTable,
    CC_HCHANNEL         hccChannel
    )
        
/*++

Routine Description:

    Looks up channel based on handle returned from call control module.

Arguments:

    ppChannel - Specifies a pointer to a DWORD-sized value in which the
        service provider must write the channel associated with the 
        call control handle specified.

    pChannelTable - Pointer to channel table to search.

    hccChannel - Handle return by call control module.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    
    // loop through each channel in table
    for (i = 0; i < pChannelTable->dwNumSlots; i++) {

        // see if channel handle matches the one specified
        if (H323IsChannelEqual(pChannelTable->pChannels[i],hccChannel)) {

            // tranfer channel pointer to caller
            *ppChannel = pChannelTable->pChannels[i];
            
            // success
            return TRUE;    
        }
    }

    // failure
    return FALSE;
}


BOOL
H323LookupChannelBySessionID(
    PH323_CHANNEL *     ppChannel,
    PH323_CHANNEL_TABLE pChannelTable,
    BYTE                bSessionID
    )

/*++

Routine Description:

    Looks up channel based on session ID negotiated.

Arguments:

    ppChannel - Specifies a pointer to a DWORD-sized value in which the
        service provider must write the channel associated with the 
        call control handle specified.

    pChannelTable - Pointer to channel table to search.

    bSessionID - session id.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    
    // loop through each channel in table
    for (i = 0; i < pChannelTable->dwNumSlots; i++) {

        // see if channel handle matches the one specified
        if (H323IsSessionIDEqual(pChannelTable->pChannels[i],bSessionID)) {

            // tranfer channel pointer to caller
            *ppChannel = pChannelTable->pChannels[i];
            
            // success
            return TRUE;    
        }
    }

    // failure
    return FALSE;
}


BOOL
H323AreThereOutgoingChannels(
    PH323_CHANNEL_TABLE pChannelTable,
    BOOL                fIgnoreOpenChannels
    )
        
/*++

Routine Description:

    Searchs for outgoing channel objects.

Arguments:

    pChannelTable - Pointer to channel table to search.

    fIgnoreOpenChannels - Restricts search to unopened channels.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    BOOL  fFoundOk = FALSE;
    
    // loop through each channel in table
    for (i = 0; i < pChannelTable->dwNumSlots; i++) {

        // see if channel is in use and outbound
        if (H323IsChannelInUse(pChannelTable->pChannels[i]) &&
            !H323IsChannelInbound(pChannelTable->pChannels[i]) &&
           (!H323IsChannelOpen(pChannelTable->pChannels[i]) ||
            !fIgnoreOpenChannels)) {

            // success
            return TRUE;    
        }
    }

    // failure
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\callback.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    Callback routines for Intel Call Control Module.

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include <limits.h>
#include "registry.h"
#include "termcaps.h"
#include "provider.h"
#include "callback.h"
#include "line.h"
#include "apierror.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HANDLE     g_hCallbackThread    = NULL;
DWORD      g_dwCallbackThreadID = UNINITIALIZED;
HANDLE     g_WaitableObjects[NUM_WAITABLE_OBJECTS];


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
H323ComputeVideoChannelBitRates(
    IN  const DWORD   dwReferenceMaxBitRate,
    IN  const DWORD   dwAudioBitRate,
    OUT DWORD * pdwFinalBitRate,           
    OUT DWORD * pdwStartUpBitRate
    )
/*++

Routine Description:

    caculate the bit rate for opening the local channel and the initial bit 
    rate for the MSP.

Arguments:

    dwReferenceMaxBitRate - The max bit rate we got from capability exchange.
        (in 100 bps unit)

    dwAudioBitRate - The bit rate of the audio stream.
        (in 100 bps unit)

    pdwFinalBitRate - the bit rate we are going to use to open the channel.
        (in 100 bps unit)

    pdwStartUpBitRate - the bit rate the MSP should use to start the stream. It 
        will adapt to the max bit rate if everything is fine. 
        (in 1 bps unit)


Return Values:

    Returns true if successful.
    
--*/
{
    DWORD dwMaxBitRate = dwReferenceMaxBitRate;

    if (dwMaxBitRate < H323_UNADJ_VIDEORATE_THRESHOLD) {

        // if the max bit rate is too small, just use it.
        *pdwStartUpBitRate = dwMaxBitRate * 100;

    } else if (dwMaxBitRate < H323_TRUE_VIDEORATE_THRESHOLD) {

        // if the max bit rate is still smaller than our threshold,
        // the other side must mean .
        *pdwStartUpBitRate = dwMaxBitRate * 80;

        if (*pdwStartUpBitRate < H323_UNADJ_VIDEORATE_THRESHOLD * 100) {

            *pdwStartUpBitRate =  H323_UNADJ_VIDEORATE_THRESHOLD * 100;
        }

    } else if (dwMaxBitRate < MAXIMUM_BITRATE_28800) {

        // We assume the MaxBitRate is the total bandwidth of 
        // the pipe. We need to substract the bandwidth needed 
        // by audio from this number. 
        dwMaxBitRate -= dwAudioBitRate;

        // We don't want to use 100% of the bandwidth for RTP packets
        // So the video bandwidth is further adjusted.
        dwMaxBitRate = dwMaxBitRate * (100 - H323_BANDWIDTH_CUSHION_PERCENT) / 100;

        *pdwStartUpBitRate = dwMaxBitRate * 100;

    } else if (dwMaxBitRate < MAXIMUM_BITRATE_63000) {

        // We assume the MaxBitRate is the total bandwidth of 
        // the pipe. We need to substract the bandwidth needed 
        // by audio from this number. 
        dwMaxBitRate -= dwAudioBitRate;

        // We don't want to use 100% of the bandwidth for RTP packets
        // So the video bandwidth is further adjusted.
        dwMaxBitRate = dwMaxBitRate * (100 - H323_BANDWIDTH_CUSHION_PERCENT) / 100;

        *pdwStartUpBitRate = dwMaxBitRate * 80;

        if (*pdwStartUpBitRate < H323_UNADJ_VIDEORATE_THRESHOLD * 100) {

            *pdwStartUpBitRate = H323_UNADJ_VIDEORATE_THRESHOLD * 100;
        }

    } else {

        *pdwStartUpBitRate = dwMaxBitRate * 80;
    }

    *pdwFinalBitRate = dwMaxBitRate;
}


BOOL
H323SendNewCallIndication(
    PH323_CALL pCall
    )

/*++

Routine Description:

    Sends NEW_CALL_INDICATION from TSP to MSP.

Arguments:

    pCall - Specifies a pointer to the associated call object.

Return Values:

    Returns true if successful.
    
--*/

{
    H323TSP_MESSAGE Message;

    // set the appropriate message type
    Message.Type = H323TSP_NEW_CALL_INDICATION;

    // send msp message
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_SENDMSPDATA,
        MSP_HANDLE_UNKNOWN,
        (DWORD_PTR)&Message,
        size