ontext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        SetHasAtLeastOnePointer( TRUE );

    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) )
        {
        RpcSemError( this, MyContext, BAD_CON_UNION_FIELD_CONF , NULL );
        }

    if ( pCommand->NeedsNDR64Run() )
        {
        if ( MyContext.AnyDescendantBits( HAS_UNSAT_REP_AS ) )
            {
            RpcSemError( this, MyContext, UNSPECIFIED_EMBEDDED_REPRESENT_AS_NOT_SUPPORTED, NULL );
            }
        }

    // clear flags not affecting complexity above
    MyContext.ClearDescendantBits( HAS_POINTER |
        HAS_CONF_PTR |
        HAS_VAR_PTR |
        HAS_CONF_VAR_PTR |
        HAS_MULTIDIM_SIZING |
        HAS_MULTIDIM_VECTOR |
        HAS_ARRAY_OF_REF |
        HAS_ENUM |
        HAS_DIRECT_CONF_OR_VAR |
        HAS_ARRAY |
        HAS_REPRESENT_AS |
        HAS_TRANSMIT_AS |
        HAS_CONF_VAR_ARRAY |
        HAS_CONF_ARRAY |
        HAS_VAR_ARRAY );

    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}

void
node_en_union::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_field * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    node_switch_type* pSwTypeAttr = ( node_switch_type* ) MyContext.ExtractAttribute( ATTR_SWITCH_TYPE );
    node_skl * pSwType;
    node_switch_is* pSwIsAttr = ( node_switch_is* ) MyContext.ExtractAttribute( ATTR_SWITCH_IS );
    BOOL NonEmptyArm = FALSE;

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    // gaj - tbd do semantic checks on these attributes
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    if ( fBeingAnalyzed )
        {
        // if we hit the same node more than once (it can only be through a ptr),
        // and the ptr type is ref, we flag an error; recursive defn. through a ref ptr.
        if ( !MyContext.AnyAncestorBits( IN_NON_REF_PTR ) &&
             MyContext.AnyAncestorBits( IN_RPC ) )
            {
            TypeSemError( this, MyContext, RECURSION_THRU_REF, NULL );
            }
        return;
        }
    fBeingAnalyzed = TRUE;
        
    CheckDeclspecAlign( MyContext );

    if ( pSwTypeAttr )
        {
        pSwType = pSwTypeAttr->GetSwitchType();
        if ( !pSwType ||
             !Xxx_Is_Type_OK( pSwType )  ||
             pSwType->NodeKind() == NODE_BYTE )
            {
            TypeSemError( this,
                MyContext,
                SWITCH_IS_TYPE_IS_WRONG,
                pSwType ? pSwType->GetSymName() : NULL );
            }
        }

    if ( pSwIsAttr )
        {
        EXPR_CTXT SwCtxt( &MyContext );
        expr_node * pSwIsExpr = pSwIsAttr->GetExpr();

        pSwIsExpr->ExprAnalyze( &SwCtxt );

        if ( SwCtxt.AnyUpFlags( EX_UNSAT_FWD ) )
            TypeSemError( this,
                MyContext,
                ATTRIBUTE_ID_UNRESOLVED,
                pSwIsAttr->GetNodeNameString() );

        if ( !SwCtxt.AnyUpFlags( EX_VALUE_INVALID ) )
            TypeSemError( this,
                MyContext,
                ATTRIBUTE_ID_MUST_BE_VAR,
                pSwIsAttr->GetNodeNameString() );
        }

    MyContext.MarkImportantPosition();
    MyContext.SetAncestorBits( IN_UNION );
    MyContext.SetDescendantBits( HAS_UNION );

    while ( ( pN = (node_field *) MemIter.GetNext() ) != 0 )
        {
        // tbd - put cases into case database...
        // tbd - check type, range, and duplication
        pN->SemanticAnalysis( &MyContext );
        if ( !pN->IsEmptyArm() )
            NonEmptyArm = TRUE;
        }

    // at least one arm should be non-empty
    if ( !NonEmptyArm )
        SemError( this, MyContext, UNION_NO_FIELDS, NULL );

    // remember if we have a pointer
    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        SetHasAtLeastOnePointer( TRUE );

    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) )
        {
        RpcSemError( this, MyContext, BAD_CON_UNION_FIELD_CONF , NULL );
        }

    // clear flags not affecting complexity above
    MyContext.ClearDescendantBits( HAS_POINTER |
        HAS_CONF_PTR |
        HAS_VAR_PTR |
        HAS_CONF_VAR_PTR |
        HAS_MULTIDIM_SIZING |
        HAS_MULTIDIM_VECTOR |
        HAS_ARRAY_OF_REF |
        HAS_ENUM |
        HAS_DIRECT_CONF_OR_VAR |
        HAS_ARRAY |
        HAS_REPRESENT_AS |
        HAS_TRANSMIT_AS |
        HAS_CONF_VAR_ARRAY |
        HAS_CONF_ARRAY |
        HAS_VAR_ARRAY );

    pParentCtxt->ReturnValues( MyContext );
    fBeingAnalyzed = FALSE;
}


void
node_def::SemanticAnalysisForTransmit( 
    SEM_ANALYSIS_CTXT * pMyContext,
    BOOL                fPresented )
{
    if ( fPresented )
        {
        // the presented type may not be conformant.
        if ( pMyContext->AnyDescendantBits( HAS_VAR_ARRAY
             | HAS_CONF_ARRAY
             | HAS_CONF_VAR_ARRAY ) )
            TypeSemError( this, *pMyContext, TRANSMIT_TYPE_CONF, NULL );
        }
    else
        {
        // transmitted type may not have a pointer.
        if ( pMyContext->AnyDescendantBits( HAS_POINTER | HAS_INTERFACE_PTR ) )
            TypeSemError( this,*pMyContext, TRANSMIT_AS_POINTER, NULL );

        // transmitted type may not derive from void
        if ( pMyContext->AnyDescendantBits(  DERIVES_FROM_VOID ) )
            TypeSemError( this, *pMyContext, TRANSMIT_AS_VOID, NULL );
        }

} 

void
node_def::SemanticAnalysisForWireMarshal( 
    SEM_ANALYSIS_CTXT * pMyContext,
    BOOL fPresented )
{

    if ( fPresented )
        {
        // We need to check if the presented type is not void; note, void * is ok.
        }
    else
        {
        // We check only the transmitted type for wire_marshal, user marshal.
        //
        // The transmitted type must not have full pointers, since
        // the app has no mechanism to generate the full pointer ids.

        // BUG, BUG semantic analysis treats arrays in structures 
        // as pointers.  Change to error once the bug is fixed. 

        if ( pMyContext->AnyDescendantBits( HAS_FULL_PTR ) )
            TypeSemError( this, *pMyContext, WIRE_HAS_FULL_PTR, NULL);
      
        // The wire type must have a fully defined memory size. It cannot be
        // conformant or conformant varying.  Arrays have a problem
        // in that the app can't marshal the MaxCount, Actual Count, or Offset properly.
        if ( pMyContext->AnyDescendantBits( HAS_CONF_ARRAY
                                            | HAS_CONF_VAR_ARRAY ) )
            TypeSemError( this, *pMyContext, WIRE_NOT_DEFINED_SIZE, NULL);  

        // transmitted type may not derive from void
        if ( pMyContext->AnyDescendantBits(  DERIVES_FROM_VOID ) )
            TypeSemError( this, *pMyContext, TRANSMIT_AS_VOID, NULL );
        }

}

void
node_def::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fInRpc = MyContext.AnyAncestorBits( IN_RPC );
    BOOL fInPresented = MyContext.AnyAncestorBits( IN_PRESENTED_TYPE );
    SEM_ANALYSIS_CTXT * pIntfCtxt = (SEM_ANALYSIS_CTXT *)
        MyContext.GetInterfaceContext();
    node_represent_as * pRepresent  = (node_represent_as *)
        MyContext.ExtractAttribute( ATTR_REPRESENT_AS );
    node_transmit * pTransmit = (node_transmit *)
        MyContext.ExtractAttribute( ATTR_TRANSMIT );
    node_user_marshal * pUserMarshal = (node_user_marshal *)
        MyContext.ExtractAttribute( ATTR_USER_MARSHAL );
    node_wire_marshal * pWireMarshal = (node_wire_marshal *)
        MyContext.ExtractAttribute( ATTR_WIRE_MARSHAL );
    BOOL fRepMarshal  = pRepresent || pUserMarshal;
    BOOL fXmitMarshal = pTransmit  || pWireMarshal;
    BOOL fEncodeDecode = (NULL != MyContext.ExtractAttribute( ATTR_ENCODE ));
    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    
    
    // Partial ignore may not be used directly on an xmit or rep as.
    if (MyContext.AnyAncestorBits( UNDER_PARTIAL_IGNORE_PARAM ) && 
        ( fRepMarshal || fXmitMarshal ) )
        {
        SemError( this, MyContext, PARTIAL_IGNORE_UNIQUE, 0 );
        }
    
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    CheckDeclspecAlign( MyContext );

    node_range_attr* pRange = ( node_range_attr* ) MyContext.GetAttribute(ATTR_RANGE);
    if ( pRange )
        {
        if ( pRange->GetMinExpr()->GetValue() > pRange->GetMaxExpr()->GetValue() )
            {
            SemError(this, MyContext, INCORRECT_RANGE_DEFN, 0);
            }
        }

    BOOL fPropogateChild = TRUE; // propogate direct child info
    unsigned long ulHandleKind;

    // check for illegal type attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_PUBLIC:
                {
                break;
                }
                // unacceptable attributes
            case TATTR_LICENSED:
            case TATTR_OLEAUTOMATION:
            case TATTR_APPOBJECT:
            case TATTR_CONTROL:
            case TATTR_PROXY:
            case TATTR_DUAL:
            case TATTR_NONEXTENSIBLE:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char        *       pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }
    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_RESTRICTED:
                break;
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_VARARG:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_USESGETLASTERROR:
            case MATTR_IMMEDIATEBIND:
            case MATTR_REPLACEABLE:
            default:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

#if defined(TARGET_RKK)
    // Checking the release compatibility

    if ( pCommand->GetTargetSystem() < NT40 )
        {
        if ( pWireMarshal )
            SemError( this, MyContext, REQUIRES_NT40, "[wire_marshal]" );
        if ( pUserMarshal )
            SemError( this, MyContext, REQUIRES_NT40, "[user_marshal]" );
        }

    if ( pCommand->GetTargetSystem() < NT351 )
        {
        if ( fEncodeDecode )
            SemError( this, MyContext, REQUIRES_NT351, "[encode,decode]" );
        }
#endif

    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));

    // clear the GUID, VERSION and HIDDEN attributes if set
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT);

    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    // get the encode and decode attributes
    fEncodeDecode |= (NULL != MyContext.ExtractAttribute( ATTR_DECODE ));
    fEncodeDecode |= pIntfCtxt->FInSummary( ATTR_ENCODE );
    fEncodeDecode |= pIntfCtxt->FInSummary( ATTR_DECODE );

    if ( fEncodeDecode )
        {
        // only direct children of the interface get these bits
        if ( !pParentCtxt->GetParent()->IsInterfaceOrObject() )
            {
            fEncodeDecode = FALSE;
            }
        else if (MyContext.AnyAncestorBits( IN_OBJECT_INTF ) )
            {
            fEncodeDecode = FALSE;
            TypeSemError( this, MyContext, PICKLING_INVALID_IN_OBJECT, NULL );
            }
        else
            {
            // note that this is an rpc-able interface
            GetMyInterfaceNode()->SetPickleInterface();
            MyContext.SetAncestorBits( IN_RPC );
            }

        SemError( this, MyContext, TYPE_PICKLING_INVALID_IN_OSF, NULL );

        BOOL HasV2Optimize = pCommand->GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2;

        if ( pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
            {
            if ( HasV2Optimize )
                {
                pCommand->GetNdrVersionControl().SetHasOicfPickling(); 
                }
                else
                {
                SemError( this, MyContext, ROBUST_PICKLING_NO_OICF, 0 );
                }
            }

        BOOL HasCommFault = MyContext.FInSummary( ATTR_COMMSTAT )
                            || MyContext.FInSummary( ATTR_FAULTSTAT );

        if ( HasCommFault && !HasV2Optimize)
            {
            SemError( this, MyContext, COMMFAULT_PICKLING_NO_OICF, 0 );
            }
        }

    // kind of handle applied right now     (HandleKind only set for ones on this
    // typedef node)

    if ( FInSummary(ATTR_HANDLE) )
        {
        MyContext.ExtractAttribute( ATTR_HANDLE );
        SetHandleKind( HDL_GEN );
        }

    bool fSerialize = MyContext.ExtractAttribute( ATTR_SERIALIZE ) != 0;
    bool fNoSerialize = MyContext.ExtractAttribute( ATTR_NOSERIALIZE ) != 0;
    // See if context_handle applied to param reached us
    if ( FInSummary(ATTR_CONTEXT) )
        {
        if ( ( GetHandleKind() != HDL_NONE ) &&
                ( GetHandleKind() != HDL_CTXT ) )
            TypeSemError( this, MyContext, CTXT_HDL_GENERIC_HDL, NULL );

        MyContext.ExtractAttribute( ATTR_CONTEXT );
        if ( fSerialize && fNoSerialize )
            {
            SemError( this, MyContext, CONFLICTING_ATTRIBUTES, GetSymName() );
            }
        SetHandleKind( HDL_CTXT );

        // since the base type is not transmitted, we aren't really
        // in an rpc after here
        MyContext.ClearAncestorBits( IN_RPC );
        }
    else
        {
        if ( fSerialize || fNoSerialize )
            {
            SemError( this, MyContext, NO_CONTEXT_HANDLE, GetSymName() );
            }
        }

    ulHandleKind = GetHandleKind();
    if ( ulHandleKind != HDL_NONE )
        {
        MyContext.SetAncestorBits( IN_HANDLE );
        }

    // effectively, the presented type is NOT involved in an RPC

    if ( fXmitMarshal )
        {
        MyContext.ClearAncestorBits( IN_RPC );
        MyContext.SetAncestorBits( IN_PRESENTED_TYPE );

        if ( MyContext.FInSummary( ATTR_ALLOCATE ) )
            AcfError( (acf_attr *) MyContext.ExtractAttribute( ATTR_ALLOCATE ),
                this,
                MyContext,
                ALLOCATE_ON_TRANSMIT_AS,
                NULL );

        if ( GetHandleKind() == HDL_CTXT )
            TypeSemError( this, MyContext, TRANSMIT_AS_CTXT_HANDLE, NULL );

        }

    if ( MyContext.ExtractAttribute( ATTR_CSCHAR ) )
        {
        if ( MyContext.AnyAncestorBits( UNDER_IN_PARAM ) )
            MyContext.SetDescendantBits( HAS_IN_CSTYPE );

        if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
            MyContext.SetDescendantBits( HAS_OUT_CSTYPE );
        }

    // process the child
    GetChild()->SemanticAnalysis( &MyContext );

    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        {
        switch (GetChild()->NodeKind())
            {
            case NODE_STRUCT:
            case NODE_UNION:
            case NODE_ENUM:
                {
                // This is the 'typedef' part of a 'typedef struct',
                // 'typedef union', or 'typedef enum' declaration.
                // Make sure that the type info name is set to the name of the
                // typedef and not the child.
                ((node_su_base *)GetChild())->SetTypeInfoName(GetSymName());
                }
                break;
            }
        }
    else
        {
        if (GetChild()->GetSymName() && IsTempName(GetChild()->GetSymName()))
            {
            // Make sure that at least the [public] attribute is
            // set on this typedef, forcing this typedef to be put
            // in a type library if it is referenced from within one.
            SetAttribute(new node_type_attr(TATTR_PUBLIC));
            }
        }
/* yongqu: don't enable this before we read custom data. 
    if ( GetChild()->NodeKind() == NODE_INT3264 )
        {
        SetAttribute( GetCustomAttrINT3264() );
        }
*/
    // process all the nasties of transmit_as and wire_marshal
    if ( fXmitMarshal && !fInPresented && fInRpc )
        {
        SEM_ANALYSIS_CTXT TransmitContext( &MyContext );
        // eat the attributes added by the above constructor
        TransmitContext.ClearAttributes();

        // process the transmitted type
        TransmitContext.SetAncestorBits( IN_TRANSMIT_AS );
        if ( pWireMarshal )
            TransmitContext.SetAncestorBits( IN_USER_MARSHAL );
        TransmitContext.ClearAncestorBits( IN_PRESENTED_TYPE );

        if ( fInRpc)
            TransmitContext.SetAncestorBits( IN_RPC );

        if ( pTransmit )
            pTransmit->GetType()->SemanticAnalysis( &TransmitContext );
        else if ( pWireMarshal )
            pWireMarshal->GetType()->SemanticAnalysis( &TransmitContext );
        else
            MIDL_ASSERT(0);

        if ( pTransmit )
            {
            // check the transmitted type.
            SemanticAnalysisForTransmit( &TransmitContext, FALSE );
            
            // Check the presented type.
            SemanticAnalysisForTransmit( &MyContext, TRUE );

            }
        else if ( pWireMarshal )
            {
            // check the transmitted type
            SemanticAnalysisForWireMarshal( &TransmitContext, FALSE );

            // check the presented type
            SemanticAnalysisForWireMarshal( &MyContext, TRUE );

            }
        else {
           MIDL_ASSERT(0);
           }

        if ( TransmitContext.AnyDescendantBits( HAS_HANDLE ) )
            {
            //gaj TypeSemError( this, MyContext, HANDLE_T_XMIT, NULL );
            }

        if ( TransmitContext.AnyDescendantBits( HAS_TRANSMIT_AS ) )
            {
            TypeSemError( this, MyContext, TRANSMIT_AS_NON_RPCABLE, NULL );
            }

        TransmitContext.SetDescendantBits( HAS_TRANSMIT_AS );
        // since the base type is not transmitted, we aren't really
        // in an rpc after here
        pParentCtxt->ReturnValues( TransmitContext );
        fPropogateChild = FALSE;
        }

    // process all the nasties of represent_as and user_marshal
    if ( fRepMarshal )
        {
        node_represent_as * pRepUser = (pRepresent) ? pRepresent
                                                    : pUserMarshal ;

        if ( ulHandleKind == HDL_CTXT )
            AcfError( pRepUser, this, MyContext, TRANSMIT_AS_CTXT_HANDLE, NULL );

        // process the transmitted type
        MyContext.SetAncestorBits( IN_REPRESENT_AS  );
        if ( pUserMarshal )
            MyContext.SetAncestorBits( IN_USER_MARSHAL );
        pParentCtxt->SetDescendantBits( HAS_REPRESENT_AS );
        if ( !pRepUser->GetRepresentationType() )
           {
           pParentCtxt->SetDescendantBits( HAS_UNSAT_REP_AS );
           
           if ( pCommand->NeedsNDR64Run() )
               {
               AcfError( pRepUser, this, MyContext, UNSPECIFIED_REP_OR_UMRSHL_IN_NDR64, NULL );
               }
           }

        if ( pUserMarshal )
           {
           // Check the transmitted type.
           SemanticAnalysisForWireMarshal( &MyContext, FALSE );
           }
        else if ( pRepresent )
           {
           // Check the transmitted type.
           SemanticAnalysisForTransmit( &MyContext, FALSE );
           }

        // since the base type is not transmitted, we aren't really
        // in an rpc after here
        }

    // make checks for encode/decode
    if ( fEncodeDecode )
        {
        if ( MyContext.AnyDescendantBits( HAS_DIRECT_CONF_OR_VAR ) )
            TypeSemError( this, MyContext, ENCODE_CONF_OR_VAR, NULL );

        }

    // process handles
    if ( ulHandleKind != HDL_NONE)
        {
        if  ( ulHandleKind == HDL_GEN )
            {
            if ( MyContext.AnyDescendantBits( DERIVES_FROM_VOID ) )
                TypeSemError( this, MyContext, GENERIC_HDL_VOID, NULL );

            if ( MyContext.AnyDescendantBits( HAS_TRANSMIT_AS ) )
                TypeSemError( this, MyContext, GENERIC_HANDLE_XMIT_AS, NULL );

            if ( MyContext.AnyAncestorBits( IN_INTERPRET ) &&
                    ( GetChild()->GetSize() > (unsigned long)(SIZEOF_MEM_PTR()) ) )
                {
                if ( pCommand->NeedsNDR64Run() )
                    TypeSemError( this, MyContext, UNSUPPORTED_LARGE_GENERIC_HANDLE, NULL );
                else
                    MyContext.SetDescendantBits( HAS_TOO_BIG_HDL );
                }
            }

        if ( ulHandleKind == HDL_CTXT )
            {
            MyContext.SetDescendantBits( HAS_CONTEXT_HANDLE );
            if ( GetBasicType()->NodeKind() != NODE_POINTER )
                TypeSemError( this, MyContext, CTXT_HDL_NON_PTR, NULL );
            }

        MyContext.SetDescendantBits( HAS_HANDLE );

        WALK_CTXT * pParamCtxt = (SEM_ANALYSIS_CTXT *)
            MyContext.GetParentContext();
        node_param * pParamNode;
        node_skl * pCurNode;
        short PtrDepth = 0;

        // this returns NULL if no appropriate ancestor found
        while ( pParamCtxt )
            {
            pCurNode = pParamCtxt->GetParent();
            if ( pCurNode->NodeKind() == NODE_PARAM )
                break;

            if ( ( pCurNode->NodeKind() == NODE_DEF ) &&
                    pCurNode->FInSummary( ATTR_TRANSMIT ) )
                {
                pParamCtxt = NULL;
                break;
                }

            if ( pCurNode->NodeKind() == NODE_POINTER )
                {
                PtrDepth ++;

                if ( MyContext.AllAncestorBits( IN_RPC | IN_FUNCTION_RESULT ) )
                    {
                    SemError( this, MyContext, CTXT_HDL_MUST_BE_DIRECT_RETURN, NULL );
                    pParamCtxt = NULL;
                    break;
                    }
                }

            pParamCtxt = (SEM_ANALYSIS_CTXT *)pParamCtxt->GetParentContext();
            }

        pParamNode = (pParamCtxt) ? (node_param *) pParamCtxt->GetParent() : NULL;

        // stuff handle info into our param node
        if ( pParamNode )
            pParamNode->HandleKind = ulHandleKind;

        // out context/generic handles must be two levels deep
        if ( pParamCtxt &&
                MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) &&
                ( PtrDepth < 1 ) )
            TypeSemError( this, MyContext, OUT_CONTEXT_GENERIC_HANDLE, NULL );

        }

    if ( IsHResultOrSCode() )
        {
        MyContext.SetDescendantBits( HAS_HRESULT );
        }

    // don't propogate info here from below if we had transmit_as,
    // it is propogated above...
    if ( fPropogateChild )
        {
        pParentCtxt->ReturnValues( MyContext );
        }

    // set the DontCallFreeInst flag on the param
    if ( ( pTransmit || pRepresent ) &&
            fInRpc &&
            MyContext.AllAncestorBits( IN_PARAM_LIST ) &&
            !MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
        {
        // look up the context stack.  If any non-pointer, non-def found,
        // set the fDontCallFreeInst flag on the param
        MarkDontCallFreeInst( &MyContext );
        }
}


// look up the context stack.  If any non-pointer, non-def found,
// set the fDontCallFreeInst flag on the param
void
node_def::MarkDontCallFreeInst( SEM_ANALYSIS_CTXT * pCtxt )
{
    SEM_ANALYSIS_CTXT * pCurCtxt = pCtxt;
    node_skl * pCurNode;
    NODE_T Kind;
    unsigned long MarkIt = 2;

    for(;;)
        {
        pCurCtxt = (SEM_ANALYSIS_CTXT *) pCurCtxt->GetParentContext();
        pCurNode = pCurCtxt->GetParent();
        Kind = pCurNode->NodeKind();

        switch ( Kind )
            {
            case NODE_DEF:
            case NODE_POINTER:
                break;
            case NODE_PARAM:
                // if we only found defs and pointers, this will
                // leave it unchanged
                ((node_param *)pCurNode)->fDontCallFreeInst |= MarkIt;
                return;
            default:
                MarkIt = 1;
                break;
            }
        }

}


// interface nodes have two entries on the context stack;
// one for the interface node, and one for info to pass to
// the children
void
node_interface::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT   MyContext( this, pParentCtxt );
    MEM_ITER            MemList( this );
    named_node*         pN;
    SEM_ANALYSIS_CTXT   ChildCtxt( &MyContext );

    BOOL IsLocal    = MyContext.FInSummary( ATTR_LOCAL );
    BOOL HasGuid    = MyContext.FInSummary( ATTR_GUID );
    BOOL IsObject   = MyContext.FInSummary( ATTR_OBJECT );
    BOOL fEncode    = MyContext.FInSummary( ATTR_ENCODE );
    BOOL fDecode    = MyContext.FInSummary( ATTR_DECODE );
    BOOL IsPickle   = fEncode || fDecode;
    BOOL HasVersion = MyContext.FInSummary( ATTR_VERSION );
    BOOL IsIUnknown = FALSE;
    BOOL fAuto      = MyContext.FInSummary( ATTR_AUTO );
    BOOL fCode      = MyContext.FInSummary( ATTR_CODE );
    BOOL fNoCode    = MyContext.FInSummary( ATTR_NOCODE );
    
    fHasMSConfStructAttr   = fHasMSConfStructAttr || MyContext.ExtractAttribute( ATTR_MS_CONF_STRUCT ) != 0;

    node_implicit*  pImplicit       = ( node_implicit* ) MyContext.GetAttribute( ATTR_IMPLICIT );
    acf_attr*       pExplicit       = ( acf_attr* ) MyContext.GetAttribute( ATTR_EXPLICIT );
    node_optimize*  pOptAttr        = 0;
    bool            fAnalizeAsyncIf = false;
    node_cs_tag_rtn*    pCSTagAttr  = 0;

    // [message] only allowed in ORPC interfaces and RPC procs.
    node_base_attr* pTemp = MyContext.GetAttribute( ATTR_MESSAGE );
    if ( pTemp )
        {
        if ( !IsObject )
            {
            SemError(
                    this,
                    MyContext,
                    INAPPLICABLE_ATTRIBUTE, 
                    pTemp->GetNodeNameString()
                    );
            }
        ChildCtxt.SetAncestorBits( HAS_MESSAGE );
        }

    // process async_uuid before doing anything
    if ( !IsAsyncClone() )
        {
        node_guid*  pAsyncGuid = (node_guid*) MyContext.GetAttribute( ATTR_ASYNCUUID );

        if ( pAsyncGuid )
            {
            if ( GetDefiningFile()->GetImportLevel() == 0 )
                {
                pCommand->GetNdrVersionControl().SetHasAsyncUUID();
                }

            ChildCtxt.SetAncestorBits( HAS_ASYNC_UUID );
            // async_uuid can only be applied to an object interface.
            if ( !IsObject || !pBaseIntf )
                {
                SemError(
                        this,
                        MyContext,
                        INAPPLICABLE_ATTRIBUTE, 
                        pAsyncGuid->GetNodeNameString()
                        );
                }

            if (  !GetAsyncInterface() )
                {
                // duplicate this interface and split its methods
                SetAsyncInterface( CloneIFAndSplitMethods( this ) );
                if ( GetAsyncInterface() )
                    {
                    fAnalizeAsyncIf = true;
                    GetAsyncInterface()->SetIsAsyncClone();
                    }
                }
            }
        }
    else
        {
        // This is the cloned interface, don't clone it again.
        ChildCtxt.SetAncestorBits( HAS_ASYNC_UUID );
        }

    while( MyContext.ExtractAttribute(ATTR_CUSTOM) )
        ;
    MyContext.ExtractAttribute( ATTR_TYPEDESCATTR );
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_LCID );

    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    // don't pass the interface attributes down directly...
    // pass them down elsewhere

    ChildCtxt.SetInterfaceContext( &MyContext );

    //
    // check the interface attributes
    //

    // make sure we only get analyzed once when object interfaces
    // check their inherited info
    if ( fSemAnalyzed )
        return;

    fSemAnalyzed = TRUE;

#ifdef gajgaj
    // look for pointer default
    if ( !FInSummary( ATTR_PTR_KIND ) &&
            MyContext.AnyAncestorBits( IN_INTERFACE ) )
        {
        RpcSemError(this, MyContext, NO_PTR_DEFAULT_ON_INTERFACE, NULL );
        }
#endif // gajgaj

    // must have exactly one of [local] or [UUID]
    if (IsLocal && HasGuid && !IsObject )
        {
        SemError( this, MyContext, UUID_LOCAL_BOTH_SPECIFIED, NULL );
        }

    // object interface error checking
    if ( IsObject )
        {
        MyContext.SetAncestorBits( IN_OBJECT_INTF );
        ChildCtxt.SetAncestorBits( IN_OBJECT_INTF );

        if ( HasVersion )
            {
            SemError( this, MyContext, OBJECT_WITH_VERSION, NULL );
            }
        }

    // make sure the uuid is unique
    node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
    // make sure the UUID is unique
    if ( pGuid )
        {
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    /////////////////////////////////////////////////////////////////////
    //Check the base interface
    if (pBaseIntf)
        {
        if ( !IsObject  && !MyContext.AnyAncestorBits(IN_LIBRARY))
            {
            SemError( this, MyContext, ILLEGAL_INTERFACE_DERIVATION, NULL );
            }

        ChildCtxt.SetAncestorBits( IN_BASE_CLASS );

        pBaseIntf->SemanticAnalysis( &ChildCtxt );

        if ( ChildCtxt.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
            {
            SemError( pBaseIntf, ChildCtxt, UNRESOLVED_TYPE, pBaseIntf->GetSymName() );
            }
        else
            {
            if ( pBaseIntf->NodeKind() != NODE_INTERFACE_REFERENCE &&  pBaseIntf->NodeKind() != NODE_HREF )
                {
                SemError( this, MyContext, ILLEGAL_BASE_INTERFACE, NULL );
                }
            
            node_interface* pRealBaseIf = ( ( node_interface_reference* ) pBaseIntf )->GetRealInterface();

            // verify the base interface is really an interface. 
            if ( pRealBaseIf == NULL || ( pRealBaseIf->NodeKind() != NODE_INTERFACE && 
                                          pRealBaseIf->NodeKind() != NODE_DISPINTERFACE ) )
                {
                SemError( this, MyContext, ILLEGAL_BASE_INTERFACE, NULL );          
                }
            
            if ( fAnalizeAsyncIf )
                {
                if ( pBaseIntf->NodeKind() != NODE_INTERFACE_REFERENCE )
                    {
                    SemError( this, MyContext, ILLEGAL_BASE_INTERFACE, NULL );
                    }
                else
                    {
                    node_interface* pRealBaseIf = ( ( node_interface_reference* ) pBaseIntf )->GetRealInterface();
                    if ( !pRealBaseIf->GetAsyncInterface() && strcmp( pRealBaseIf->GetSymName(), "IUnknown" ) ) 
                        {
                        SemError( this, MyContext, ILLEGAL_BASE_INTERFACE, NULL );
                        }
                    }
                }

            if ( pBaseIntf->NodeKind() == NODE_INTERFACE_REFERENCE && HasGuid )
                {
                node_interface* pRealBaseIf = ( ( node_interface_reference* ) pBaseIntf )->GetRealInterface();
                if ( pRealBaseIf )
                    {
                    node_guid * pNodeGuid = (node_guid *) pRealBaseIf->GetAttribute( ATTR_GUID );
                    if ( pNodeGuid )
                        {
                        GUID thisGuid;
                        pGuid->GetGuid( thisGuid );
                        GUID baseIFGuid;
                        pNodeGuid->GetGuid( baseIFGuid );
                        if ( !IsAnyIAdviseSinkIID( thisGuid ) )
                            {
                            if ( IsAnyIAdviseSinkIID( baseIFGuid ) )
                                {
                                SemError( this, MyContext, CANNOT_INHERIT_IADVISESINK, pBaseIntf->GetSymName() );
                                }
                            }
                        else 
                            {
                            ChildCtxt.SetAncestorBits( IN_IADVISESINK );
                            }
                        }
                    }
                }
            }

        // note that the above deletes intervening forwards
        ChildCtxt.ClearAncestorBits( IN_BASE_CLASS );
        }

    if ( IsValidRootInterface() )
        {
        ChildCtxt.SetAncestorBits( IN_ROOT_CLASS );
        IsIUnknown = TRUE;
        }

    if ( IsObject && !pBaseIntf && !IsIUnknown && !MyContext.AnyAncestorBits(IN_LIBRARY))
        {
        SemError( pBaseIntf, MyContext, ILLEGAL_INTERFACE_DERIVATION, NULL );
        }

    // our optimization is controlled either here or for the whole compile
    if ( IsAsyncClone() )
        {
        SetOptimizationFlags( OPTIMIZE_ALL_I2_FLAGS );
        }
    else
        {
        if ( ( pOptAttr = (node_optimize *) GetAttribute( ATTR_OPTIMIZE ) ) != 0 )
            {
            SetOptimizationFlags( pOptAttr->GetOptimizationFlags() );
            SetOptimizationLevel( pOptAttr->GetOptimizationLevel() );
            }
        else
            {
            SetOptimizationFlags( pCommand->GetOptimizationFlags() );
            SetOptimizationLevel( pCommand->GetOptimizationLevel() );
            }
        }

    if ( MyContext.FInSummary( ATTR_NOCODE ) &&
            pCommand->GenerateSStub() &&
            !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
        {
        SemError( this, MyContext, NOCODE_WITH_SERVER_STUBS, NULL );
        }

    if ( IsPickle && pCommand->IsSwitchDefined( SWITCH_ROBUST ) )
        {
        if ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 )
            {
            pCommand->GetNdrVersionControl().SetHasOicfPickling();
            }
        else
            {
            SemError(this, MyContext, ROBUST_PICKLING_NO_OICF, 0);
            }
        }

    BOOL HasCommFault = MyContext.FInSummary( ATTR_COMMSTAT )
                        || MyContext.FInSummary( ATTR_FAULTSTAT );

    if ( HasCommFault )
        {
        if ( ! ( GetOptimizationFlags() & OPTIMIZE_INTERPRETER_V2 ) )
            {
            SemError( this, MyContext, COMMFAULT_PICKLING_NO_OICF, 0 );
            }
        }

    // mark the interface as a pickle interface
    if ( IsPickle )
        SetPickleInterface();

    // default the handle type, if needed
    if ( !IsObject && !pImplicit && !pExplicit && !fAuto && !IsLocal )
        {
        if ( IsPickleInterface() )
            {
            pExplicit = new acf_attr( ATTR_EXPLICIT );
            SetAttribute( pExplicit );
            }
        else
            {
            fAuto = TRUE;
            SetAttribute( new acf_attr( ATTR_AUTO ) );
            }
        }

    // make sure no pickle w/ auto handle
    if ( IsPickleInterface() )
        {
        ChildCtxt.SetAncestorBits( IN_ENCODE_INTF );
        if ( fAuto )
            SemError( this, MyContext, ENCODE_AUTO_HANDLE, NULL );
        }

    // check for handle conflicts
    if ( ( fAuto && pImplicit ) ||
            ( fAuto && pExplicit ) ||
            ( pImplicit && pExplicit ) )
        SemError( this, MyContext, CONFLICTING_INTF_HANDLES, NULL );

    if ( pImplicit )
        {
        node_id * pID;
        node_skl * pType;
        pImplicit->ImplicitHandleDetails( &pType, &pID );
        char* szName = pType->GetNonDefSelf()->GetSymName();

        if ( pImplicit->IsHandleTypeDefined() )
            {
            if ( !pType->FInSummary( ATTR_HANDLE ) &&
                    strcmp( szName, "handle_t" ) &&
                    !pID->FInSummary( ATTR_HANDLE ) )
                {
                SemError( this, MyContext, IMPLICIT_HANDLE_NON_HANDLE, NULL );
                }
            }
        else
            {
            if ( !pID->FInSummary( ATTR_HANDLE ) )
                SemError( this, MyContext, IMPLICIT_HDL_ASSUMED_GENERIC, NULL );
            }
        }

    if ( fAuto )
        {
        ChildCtxt.SetAncestorBits( HAS_AUTO_HANDLE );
        }
    else if ( pExplicit )
        {
        ChildCtxt.SetAncestorBits( HAS_EXPLICIT_HANDLE );
        }
    else if ( pImplicit )
        {
        ChildCtxt.SetAncestorBits( HAS_IMPLICIT_HANDLE );
        }

    // check for illegal type attributes
    node_type_attr * pTA;
    BOOL fIsDual = FALSE;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
                // acceptable attributes
            case TATTR_DUAL:
                fIsDual = TRUE;
                // fall through
            case TATTR_OLEAUTOMATION:
                HasOLEAutomation(TRUE);
                break;
            case TATTR_PROXY:
            case TATTR_PUBLIC:
            case TATTR_NONEXTENSIBLE:
                break;
                // unacceptable attributes
            case TATTR_CONTROL:
            case TATTR_LICENSED:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            
            case TATTR_APPOBJECT:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }

    if (HasOLEAutomation())
        {
        node_interface* pUltimate           = 0;
        node_interface* pIntf               = this;
        STATUS_T        ErrorCode           = NOT_OLEAUTOMATION_INTERFACE;

        while ( pIntf )
            {
            pUltimate = pIntf;
            pIntf = pIntf->GetMyBaseInterface();

            if ( !pUltimate->IsValidRootInterface() )
            {
            // pUltimate is not IUnknown. If it is not a IDispatch either, it is not
            // an oleautomation compliant interface.
                char* szName = pUltimate->GetSymName();
                if ( _stricmp(szName, "IDispatch") == 0 )
                    {
                    ErrorCode = STATUS_OK;
                    break;
                    }
            }
           else
                {
                // IUnknown could be OLEAUTOMATION compatible, but not DUAL
                if ( fIsDual )
                    ErrorCode = NOT_DUAL_INTERFACE;
                else
                    ErrorCode = STATUS_OK;
                break;
                }
            }

        if ( ErrorCode != STATUS_OK )
            SemError( this, MyContext, ErrorCode, GetSymName() );
            
        ChildCtxt.SetAncestorBits( HAS_OLEAUTOMATION );
        }

    // check for illegal member attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            case MATTR_RESTRICTED:
                break;
            case MATTR_DEFAULTVTABLE:
            case MATTR_SOURCE:
                {
                if ( MyContext.AnyAncestorBits( IN_COCLASS ) )
                    // [source] and [defaultvtable] are only allowed on
                    // interface's defined as members of coclasses.
                    break;
                // illegal attribute, so fall through
                }
            case MATTR_READONLY:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            }
        }

    node_base_attr* pAttrAsync = MyContext.ExtractAttribute( ATTR_ASYNC );
    if ( pAttrAsync )
        {
        if ( !pAttrAsync->IsAcfAttr() )
            {
            SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
            }
        if ( fCode || fNoCode || IsLocal || pOptAttr || IsObject || HasOLEAutomation() )
            {
            SemError( this, MyContext, ILLEGAL_COMBINATION_OF_ATTRIBUTES, 0 );
            }
        ChildCtxt.SetAncestorBits( HAS_ASYNCHANDLE );
        }

    pCSTagAttr = ( node_cs_tag_rtn *) MyContext.ExtractAttribute( ATTR_CSTAGRTN );

    ////////////////////////////////////////////////////////////////////////
    // process all the children of the interface
    //
    while ( ( pN = MemList.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &ChildCtxt );

        // Set the cs tag routine for the proc if it needs one and doesn't
        // have one yet

        if ( NODE_PROC == pN->NodeKind() )
            {
            node_proc *pProc = ( node_proc * ) pN;

            if ( ChildCtxt.AnyDescendantBits( HAS_IN_CSTYPE | HAS_OUT_CSTYPE )
                 && ( NULL == pProc->GetCSTagRoutine() )
                 && ( NULL != pCSTagAttr ) )
                {
                pProc->SetCSTagRoutine( pCSTagAttr->GetCSTagRoutine() );
                }
            }
        }

    // make sure we had some rpc-able routines

    if ( IsObject )
        {
        //UUID must be specified on object procs.
        if( !HasGuid )
            {
            SemError( this, MyContext, NO_UUID_SPECIFIED, NULL );
            }
        }
    else if( MyContext.AnyAncestorBits( IN_INTERFACE ) &&
            pCommand->GenerateStubs() &&
            !IsLocal )
        {
        if ( ProcCount == 0 )
            {
            if ( !IsPickleInterface() &&
                    !IsObject )
                {
                if (CallBackProcCount == 0 )
                    {
                    SemError( this, MyContext, NO_REMOTE_PROCS_NO_STUBS, NULL );
                    }
                else
                    {
                    SemError( this, MyContext, INTERFACE_ONLY_CALLBACKS, NULL );
                    }
                }
            }
        else
            {
            //UUID must be specified when interface has remote procs.
            if( !HasGuid )
                {
                SemError( this, MyContext, NO_UUID_SPECIFIED, NULL );
                }
            }
        }

    if (pExplicit && MyContext.AnyAncestorBits( IN_LIBRARY ))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, NULL);
        }

    if (fCode && fNoCode)
        {
        SemError(this, MyContext, CODE_NOCODE_CONFLICT, NULL);
        }

    if ( IsObject )
        {
        unsigned short uProcCount = GetProcCount();
        
        if ( GetFileNode() && GetFileNode()->GetImportLevel() > 0 )
            {
            if ( uProcCount > 64 && uProcCount <= 256 )
                {
                pCommand->GetNdrVersionControl().SetHasMoreThan64DelegatedProcs();
                }
            else if ( uProcCount > 256 )
                {
                SemError(this, MyContext, TOO_MANY_DELEGATED_PROCS, NULL);
                }
            }

        // method limits apply only to stubless proxies. /Oicf not /Oi or /Os
        /*
            < 32        Windows NT 3.51-
            32 - 110    Windows NT 4.0
            110 - 512   Windows NT 4.0 SP3
            > 512       Windows 2000
        */
        unsigned short uOpt = GetOptimizationFlags();
        if ( GetFileNode() && GetFileNode()->GetImportLevel() == 0 && ( uOpt & OPTIMIZE_STUBLESS_CLIENT ) )
            {
            if ( (uProcCount > 512) && MyContext.AnyAncestorBits(IN_LIBRARY))
                {
                SemError(this, MyContext, TOO_MANY_PROCS, 0);
                pCommand->GetNdrVersionControl().SetHasNT5VTableSize();
                }
            else if ( (uProcCount > 110) && (uProcCount <= 512) && MyContext.AnyAncestorBits(IN_LIBRARY))
                {
                SemError(this, MyContext, TOO_MANY_PROCS_FOR_NT4, 0);
                pCommand->GetNdrVersionControl().SetHasNT43VTableSize();
                }
            else if ( uProcCount > 32 && uProcCount <= 110 )
                {
                pCommand->GetNdrVersionControl().SetHasNT4VTableSize();
                }
            }
        }

    if ( GetAsyncInterface() && fAnalizeAsyncIf )
        {
        GetAsyncInterface()->SemanticAnalysis( pParentCtxt );
        }

    MyContext.ReturnValues(ChildCtxt);
    // consume all the interface attributes
    MyContext.ClearAttributes();
    pParentCtxt->ReturnValues( MyContext );
}

// a reference to an interface...
//Check for ms_ext mode.
//Check if the interface has the [object] attribute
//if used in an RPC, the parent must be a pointer.
void
node_interface_reference::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    CheckDeclspecAlign( MyContext );

    // see if we are detecting class dependencies
    if ( MyContext.AnyAncestorBits( IN_BASE_CLASS ) )
        {
        if ( !GetRealInterface()->FInSummary( ATTR_OBJECT ) && !MyContext.AnyAncestorBits(IN_LIBRARY))
            {
            SemError( this, MyContext, ILLEGAL_INTERFACE_DERIVATION, NULL );
            }

        // fetch my interface's BaseInteraceReference
        named_node * pBaseClass = GetMyBaseInterfaceReference();
        if ( pBaseClass )
            {
            if ( MyContext.FindRecursiveContext( pBaseClass ) )
                SemError( this, MyContext, CIRCULAR_INTERFACE_DEPENDENCY, NULL);
            else
                {
                // make sure our base class got analyzed
                SEM_ANALYSIS_CTXT BaseContext( this, &MyContext );

                BaseContext.ClearAncestorBits( IN_BASE_CLASS | IN_INTERFACE );
                BaseContext.SetInterfaceContext( &BaseContext );
                GetRealInterface()->SemanticAnalysis( &BaseContext );

                pBaseClass->SemanticAnalysis( &MyContext );
                }
            }
        else    // root base class
            {
            if ( !GetRealInterface()->IsValidRootInterface() && !MyContext.AnyAncestorBits(IN_LIBRARY))
                SemError( this, MyContext, NOT_VALID_AS_BASE_INTF, NULL );
            }
        }

    else if ( ( pParentCtxt->GetParent()->NodeKind() == NODE_FORWARD ) &&
            ( pParentCtxt->GetParentContext()->GetParent()->IsInterfaceOrObject() ) )
        {
        // we are an interface forward decl
        }
    else    // we are at an interface pointer
        {
        node_interface * pIntf = GetRealInterface();

        if ( !MyContext.AnyAncestorBits( IN_POINTER ) && !MyContext.AnyAncestorBits( IN_LIBRARY ))
            {
            SemError( this, MyContext, INTF_NON_POINTER, NULL );
            }

        if ( !pIntf->FInSummary( ATTR_GUID ) )
            {
            SemError( this, MyContext, PTR_INTF_NO_GUID, NULL );
            }

        MyContext.SetDescendantBits( HAS_INTERFACE_PTR );

        }

    pParentCtxt->ReturnValues( MyContext );
    return;
};

void
node_source::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    MEM_ITER MemIter( this );
    node_skl * pN;
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis( &MyContext );
        }

    pParentCtxt->ReturnValues( MyContext );
};

void
node_pointer::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    PTRTYPE           PtrKind = PTR_UNKNOWN;
    FIELD_ATTR_INFO   FAInfo;
    node_ptr_attr *   pPAttr;                 // pointer attribute
    node_byte_count * pCountAttr;
    node_allocate *   pAlloc;

    BOOL fInterfacePtr = (GetChild()->NodeKind() == NODE_INTERFACE_REFERENCE );
    BOOL fUnderAPtr = MyContext.AnyAncestorBits( IN_POINTER | IN_ARRAY );
    BOOL fIgnore;
    BOOL fIsSizedPtr = FALSE;

    // see if we have allocate
    pAlloc = (node_allocate *) MyContext.ExtractAttribute( ATTR_ALLOCATE );

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    CheckDeclspecAlign( MyContext );

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    BOOL fExplicitPtrAttr = FALSE;

    PtrKind = MyContext.GetPtrKind( &fExplicitPtrAttr );

    if ( PtrKind == PTR_FULL )
        {
        MyContext.SetDescendantBits( HAS_FULL_PTR );
        }

    if ( ( pPAttr = (node_ptr_attr *)MyContext.ExtractAttribute( ATTR_PTR_KIND) ) != 0 )
        {
        TypeSemError( this, MyContext, MORE_THAN_ONE_PTR_ATTR, NULL );
        }

    if ( MyContext.AnyAncestorBits( UNDER_PARTIAL_IGNORE_PARAM )  &&
         ( PtrKind != PTR_UNIQUE ) )
        {
        TypeSemError( this, MyContext, PARTIAL_IGNORE_UNIQUE, NULL );
        }
    MyContext.ClearAncestorBits( UNDER_PARTIAL_IGNORE_PARAM );

    // mark this pointer as ref or non-ref.  This flag is only valid for the
    // pointer nodes themselves.
    if ( PtrKind == PTR_REF )
        MyContext.ClearAncestorBits( IN_NON_REF_PTR );
    else
        MyContext.SetAncestorBits( IN_NON_REF_PTR );

    // detect top level ref pointer on return type
    if ( ( PtrKind == PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_FUNCTION_RESULT ) )
        {
        if (MyContext.FindNonDefAncestorContext()->GetParent()->NodeKind()
                == NODE_PROC )
            TypeSemError( this, MyContext, BAD_CON_REF_RT, NULL );
        }

    // unique or full pointer may not be out only
    if ( ( PtrKind != PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_PARAM_LIST ) &&
            !fUnderAPtr &&
            !MyContext.AnyAncestorBits( UNDER_IN_PARAM |
            IN_STRUCT | IN_UNION ))
        TypeSemError( this, MyContext, UNIQUE_FULL_PTR_OUT_ONLY, NULL );

    MyContext.SetAncestorBits( IN_POINTER );

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        {
        if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
            RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );
        else if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
            RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );
        }

    // ignore pointers do not need to be rpc-able
    fIgnore = (NULL != MyContext.ExtractAttribute( ATTR_IGNORE ));
    if ( fIgnore )
        {
        MyContext.ClearAncestorBits( IN_RPC );
        }

    ////////////////////////////////////////////////////////////////////////
    // process field attributes

    // see if we have any field attributes (are conformant or varying)
    FAInfo.SetControl( TRUE, GetBasicType()->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );
    FAInfo.Validate( &MyContext );    

    // ptr is conf or varying or conf/varying
    if ( FAInfo.Kind & FA_CONFORMANT_VARYING )
        {
        fIsSizedPtr = TRUE;
        }

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            break;
            }
        case FA_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );

            if ( MyContext.AllAncestorBits( UNDER_OUT_PARAM |
                    IN_PARAM_LIST | IN_RPC ) &&
                    !fUnderAPtr &&
                    !MyContext.AnyAncestorBits( IN_STRUCT | IN_UNION |
                    UNDER_IN_PARAM ) )
                TypeSemError( this, MyContext, DERIVES_FROM_UNSIZED_STRING, NULL );

            MyContext.SetDescendantBits( HAS_STRING );
            // break;  deliberate fall through to case below
            }
        case FA_VARYING:
            {
            MyContext.SetDescendantBits( HAS_VAR_PTR );
            break;
            }
        case FA_CONFORMANT:
            {
            MyContext.SetDescendantBits( HAS_CONF_PTR );
            break;
            }
        case FA_CONFORMANT_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );
            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            // break;  deliberate fall through to case below
            }
        case FA_CONFORMANT_VARYING:
            {
            MyContext.SetDescendantBits( HAS_CONF_VAR_PTR );
            break;
            }
        case FA_INTERFACE:
            {
            if ( !fInterfacePtr && (GetBasicType()->NodeKind() != NODE_VOID ) )
                {
                TypeSemError( this, MyContext, IID_IS_NON_POINTER, NULL );
                }
            fInterfacePtr = TRUE;
            break;
            }
        default:        // string + varying combinations
            {
            TypeSemError( this, MyContext, INVALID_SIZE_ATTR_ON_STRING, NULL );
            break;
            }
        }
    // tell our children we are constructing an interface pointer
    if (fInterfacePtr)
        MyContext.SetAncestorBits( IN_INTERFACE_PTR );

    // interface pointer shouldn't have explicit pointer attributes

    if ( fInterfacePtr  &&  fExplicitPtrAttr  &&
         (PtrKind == PTR_FULL || PtrKind == PTR_REF ) )
        {
        TypeSemError( this, MyContext, INTF_EXPLICIT_PTR_ATTR, NULL );
        }

    // Non pipe [out] interface pointers must use double indirection.
    // However, pipe interface pointers can use only a single indirection.
    // Note that fInterfacePtr may be true for a void *.

    if (  fInterfacePtr  &&  MyContext.AnyAncestorBits( UNDER_OUT_PARAM )  &&
          !fUnderAPtr )
        {
        if ( GetChild()->NodeKind() == NODE_INTERFACE_REFERENCE )
            TypeSemError( this, MyContext, NON_INTF_PTR_PTR_OUT, NULL );
        }

    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) &&
            ( FAInfo.Kind != FA_NONE) )
        TypeSemError( this, MyContext, ARRAY_OF_UNIONS_ILLEGAL, NULL );

    // see if a param or return type context attr reached us...
    bool fSerialize = MyContext.ExtractAttribute( ATTR_SERIALIZE ) != 0;
    bool fNoSerialize = MyContext.ExtractAttribute( ATTR_NOSERIALIZE ) != 0;
    if ( MyContext.FInSummary( ATTR_CONTEXT ) )
        {
        if (GetBasicType()->NodeKind() != NODE_POINTER )
            {
            if ( fSerialize && fNoSerialize )
                {
                SemError( this, MyContext, CONFLICTING_ATTRIBUTES, GetSymName() );
                }
            MyContext.ExtractAttribute( ATTR_CONTEXT );
            MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
            pParentCtxt->SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
            MyContext.ClearAncestorBits( IN_RPC );
            if (GetBasicType()->NodeKind() != NODE_VOID )
                {
                TypeSemError( this, MyContext, CONTEXT_HANDLE_VOID_PTR, NULL );
                }
            }
        }
    else
        {
        if ( fSerialize || fNoSerialize )
            {
            SemError( this, MyContext, NO_CONTEXT_HANDLE, GetSymName() );
            }
        }


    // see if a byte_count reached us...
    pCountAttr = (node_byte_count *)
        MyContext.ExtractAttribute( ATTR_BYTE_COUNT );

    if (pCountAttr)
        {
        // byte count error checking
        
        if ( pCommand->NeedsNDR64Run() )
            TypeSemError( this, MyContext, BYTE_COUNT_IN_NDR64, 0 );

        node_param * pParam  = pCountAttr->GetByteCountParam();

        if ( !MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) ||
                        MyContext.AnyAncestorBits( UNDER_IN_PARAM ) )
            {
            TypeSemError( this, MyContext, BYTE_COUNT_NOT_OUT_PTR, 0 );
            }

        if ( !pParam || !pParam->FInSummary( ATTR_IN ) || pParam->FInSummary( ATTR_OUT ) )
            TypeSemError( this, MyContext, BYTE_COUNT_PARAM_NOT_IN, 0 );

        if ( pParam )
            {
            NODE_T nodeKind = pParam->GetBasicType()->NodeKind();
            if ( nodeKind < NODE_HYPER || nodeKind > NODE_BYTE )
                {
                SemError( this, MyContext, BYTE_COUNT_PARAM_NOT_INTEGRAL, 0 );
                }
            }

        if ( !pCommand->IsSwitchDefined( SWITCH_MS_EXT ) )
            {
            SemError( this, MyContext, BYTE_COUNT_INVALID, 0 );
            }

        if ( MyContext.AnyDescendantBits( HAS_CONF_VAR_PTR | HAS_VAR_PTR | HAS_CONF_PTR ) )
            {
            SemError( this, MyContext, BYTE_COUNT_INVALID, 0 );
            }
        }

    if ( PtrKind == PTR_REF )
        {
        SEM_ANALYSIS_CTXT * pCtxt = (SEM_ANALYSIS_CTXT *)
            MyContext.FindNonDefAncestorContext();
        if ( ( pCtxt->GetParent()->NodeKind() == NODE_FIELD ) &&
                ( pCtxt->GetParentContext()->GetParent()->NodeKind() == NODE_UNION ) )
            TypeSemError( this, MyContext, REF_PTR_IN_UNION, NULL );
        }

    MyContext.ClearAncestorBits( IN_UNION | IN_NE_UNION | IN_ARRAY );

    ////////////////////////////////////////////////////////////////////////
    // finally, process the child

    GetChild()->SemanticAnalysis( &MyContext );

    // if the child and this node is a conf and/or varying pointer
    if ( fIsSizedPtr )
        {
        if ( MyContext.AnyDescendantBits( HAS_SIZED_PTR ) )
            {
            MyContext.SetDescendantBits( HAS_MULTIDIM_VECTOR );
            }
        else
            {
            MyContext.SetDescendantBits( HAS_SIZED_PTR );
            }
        }

    // allocate error checking
    if ( pAlloc )
        {
        if ( MyContext.AnyDescendantBits( HAS_TRANSMIT_AS | HAS_REPRESENT_AS ) )
            {
            if ( MyContext.AnyAncestorBits( IN_RPC ) )
                SemError( this, MyContext, ALLOCATE_ON_TRANSMIT_AS, NULL );
            else
                AcfError( pAlloc, this, MyContext, ALLOCATE_ON_TRANSMIT_AS, NULL );
            }

        if ( MyContext.AnyDescendantBits( HAS_HANDLE ) )
            {
            if ( MyContext.AnyAncestorBits( IN_RPC ) )
                SemError( this, MyContext, ALLOCATE_ON_HANDLE, NULL );
            else
                AcfError( pAlloc, this, MyContext, ALLOCATE_ON_HANDLE, NULL );
            }

        // warn about allocate(all_nodes) with [in,out] parameter
        if ( MyContext.AllAncestorBits( IN_RPC |
                IN_PARAM_LIST |
                UNDER_IN_PARAM |
                UNDER_OUT_PARAM ) &&
                ( pAlloc->GetAllocateDetails() & ALLOCATE_ALL_NODES ) )
            {
            SemError( this, MyContext, ALLOCATE_IN_OUT_PTR, NULL );
            }

        }

    if ( fInterfacePtr )
        MyContext.SetAncestorBits( IN_INTERFACE_PTR );

    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY |
            HAS_CONF_VAR_ARRAY ) &&
            !MyContext.AnyDescendantBits( HAS_ARRAY |
            HAS_TRANSMIT_AS ) &&
            MyContext.AllAncestorBits( IN_RPC | UNDER_OUT_PARAM ) &&
            !MyContext.AnyAncestorBits( UNDER_IN_PARAM |
            IN_ARRAY |
            IN_STRUCT |
            IN_UNION |
            IN_TRANSMIT_AS |
            IN_REPRESENT_AS )      &&
            ( PtrKind == PTR_REF ) )
        TypeSemError( this, MyContext, DERIVES_FROM_PTR_TO_CONF, NULL );

#if 0
    if ( MyContext.AnyDescendantBits( HAS_DIRECT_CONF_OR_VAR ) )
        {
        TypeSemError( this, MyContext, ILLEGAL_CONFORMANT_ARRAY, NULL );
        }
#endif

    // incomplete types are OK below a pointer
    // array characteristics blocked by pointer
    MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE
        | HAS_RECURSIVE_DEF
        | HAS_ARRAY
        | HAS_VAR_ARRAY
        | HAS_CONF_ARRAY
        | HAS_CONF_VAR_ARRAY
        | HAS_MULTIDIM_SIZING
        | HAS_UNION
        | HAS_STRUCT
        | HAS_TRANSMIT_AS
        | HAS_REPRESENT_AS
        | HAS_UNSAT_REP_AS
        | HAS_DIRECT_CONF_OR_VAR
        | HAS_ENUM
        | HAS_ARRAY_OF_REF
        | HAS_CONTEXT_HANDLE
        | HAS_HRESULT );

    if ( !fInterfacePtr && !fIgnore )
        MyContext.SetDescendantBits( HAS_POINTER );

    if ( ( FAInfo.Kind != FA_NONE ) &&
            ( FAInfo.Kind != FA_STRING ) &&
            ( FAInfo.Kind != FA_INTERFACE ) )
        MyContext.SetDescendantBits( HAS_DIRECT_CONF_OR_VAR );

    if ( ( PtrKind == PTR_REF ) &&
            ( MyContext.FindNonDefAncestorContext()
            ->GetParent()->NodeKind() == NODE_ARRAY ) )
        {
        MyContext.SetDescendantBits( HAS_ARRAY_OF_REF );
        }

#ifdef gajgaj
    if ( (PtrKind != PTR_REF ) &&
            MyContext.AnyDescendantBits( HAS_HANDLE ) &&
            MyContext.AnyAncestorBits( IN_RPC ) )
        TypeSemError( this, MyContext, PTR_TO_HDL_UNIQUE_OR_FULL, NULL );
#endif //gajgaj

    if ( MyContext.AnyDescendantBits( HAS_IN_CSTYPE | HAS_OUT_CSTYPE ) )
        {
        if ( !FAInfo.VerifyOnlySimpleExpression() )
            SemError( this, MyContext, CSCHAR_EXPR_MUST_BE_SIMPLE, NULL );

        if ( FA_CONFORMANT == FAInfo.Kind )
            SemError( this, MyContext, NO_CONFORMANT_CSCHAR, NULL );

        if ( MyContext.AnyDescendantBits( HAS_MULTIDIM_SIZING
                                            | HAS_MULTIDIM_VECTOR ) )
            {
            SemError( this, MyContext, NO_MULTIDIM_CSCHAR, NULL );
            }

        // We want to propagate the the descendant bits up so that the proc
        // and interface know the cs stuff is around but we only want to set
        // the "this is a cs array" flag if it's actually a cs array

        if ( GetChild()->FInSummary( ATTR_CSCHAR ) )
            SetHasCSType();
        }

    SIZE_LENGTH_USAGE usage;

    if ( HasCSType() )
        usage = CSSizeLengthUsage;            
    else
        usage = NonCSSizeLengthUsage;

    if ( ! FAInfo.SetExpressionVariableUsage( usage ) )
        SemError( this, MyContext, SHARED_CSCHAR_EXPR_VAR, NULL );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_array::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    FIELD_ATTR_INFO FAInfo;
    PTRTYPE PtrKind = PTR_UNKNOWN;
    BOOL fArrayParent = MyContext.AnyAncestorBits( IN_ARRAY );

    if ( HasCorrelation( this ) )
        {
        MyContext.IncCorrelationCount();
        }

    CheckDeclspecAlign( MyContext );

    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) )
        TypeSemError( this, MyContext, ARRAY_OF_UNIONS_ILLEGAL, NULL );

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    PtrKind = MyContext.GetPtrKind();

    MIDL_ASSERT( PtrKind != PTR_UNKNOWN );

    if ( PtrKind == PTR_FULL )
        {
        MyContext.SetDescendantBits( HAS_FULL_PTR );
        }

    if ( MyContext.ExtractAttribute( ATTR_PTR_KIND) )
        TypeSemError( this, MyContext, MORE_THAN_ONE_PTR_ATTR, NULL );

    // ref pointer may not be returned
    if ( ( PtrKind == PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_FUNCTION_RESULT ) )
        {
        if (MyContext.FindNonDefAncestorContext()->GetParent()->NodeKind()
            == NODE_PROC )
        TypeSemError( this, MyContext, BAD_CON_REF_RT, NULL );
        }

    // unique or full pointer may not be out only
    if ( ( PtrKind != PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_PARAM_LIST ) &&
            !MyContext.AnyAncestorBits( UNDER_IN_PARAM |
            IN_STRUCT |
            IN_UNION |
            IN_ARRAY |
            IN_POINTER ) )
        TypeSemError( this, MyContext, UNIQUE_FULL_PTR_OUT_ONLY, NULL );

    MyContext.SetAncestorBits( IN_ARRAY );

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        {
        if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
            RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );
        else if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
            RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );
        }

    /////////////////////////////////////////////////////////////////////////
    // process field attributes

    FAInfo.SetControl( FALSE, GetBasicType()->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );
    FAInfo.Validate( &MyContext, pLowerBound, pUpperBound );

    if (MyContext.AnyAncestorBits( IN_LIBRARY ))
    {
        if ( FA_NONE != FAInfo.Kind  && FA_CONFORMANT != FAInfo.Kind)
        {
            // only Fixed size arrays and SAFEARRAYs are allowed in Type Libraries
            SemError( this, MyContext, NOT_FIXED_ARRAY, NULL );
        }
    }

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            break;
            }
        case FA_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );

            if ( MyContext.AllAncestorBits( UNDER_OUT_PARAM |
                    IN_PARAM_LIST |
                    IN_RPC ) &&
                    !MyContext.AnyAncestorBits( IN_STRUCT |
                    IN_UNION |
                    IN_POINTER |
                    IN_ARRAY |
                    UNDER_IN_PARAM ) )
                TypeSemError( this, MyContext, DERIVES_FROM_UNSIZED_STRING, NULL );

            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            // break;  deliberate fall through to case below
            }
        case FA_VARYING:
            {
            MyContext.SetDescendantBits( HAS_VAR_ARRAY );
            break;
            }
        case FA_CONFORMANT:
            {
            MyContext.SetDescendantBits( HAS_CONF_ARRAY );
            break;
            }
        case FA_CONFORMANT_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );
            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            MyContext.SetDescendantBits( HAS_STRING );
            // break;  deliberate fall through to case below
            }
        case FA_CONFORMANT_VARYING:
            {
            MyContext.SetDescendantBits( HAS_CONF_VAR_ARRAY );
            break;
            }
        case FA_INTERFACE:
            {
            // gaj - tbd
            break;
            }
        default:    // string + varying combinations
            {
            TypeSemError( this, MyContext, INVALID_SIZE_ATTR_ON_STRING, NULL );
            break;
            }
        }

    // detect things like arrays of conf structs...
    // if we have an array as an ancestor, and we have conformance, then complain
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) &&
            fArrayParent )
        {
        // see if there are any bad things between us and our parent array
        SEM_ANALYSIS_CTXT * pCtxt = (SEM_ANALYSIS_CTXT *) pParentCtxt;
        node_skl * pCur = pCtxt->GetParent();

        // check up for anything other than def below proc
        // make sure the proc only has one param
        while ( pCur->NodeKind() != NODE_ARRAY )
            {
            if ( pCur->NodeKind() != NODE_DEF )
                {
                SemError( this, MyContext, ILLEGAL_CONFORMANT_ARRAY, NULL );
                break;
                }
            pCtxt = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
            pCur = pCtxt->GetParent();
            }

        }


    //////////////////////////////////////////////////////////////
    // process the array element
    GetChild()->SemanticAnalysis( &MyContext );

    if ( MyContext.AnyDescendantBits( HAS_PIPE ) )
        {
        SemError( this, MyContext, INVALID_ARRAY_ELEMENT, 0 );
        }

    BOOL IsMultiDim = MyContext.AnyDescendantBits( HAS_ARRAY );

    if ( MyContext.AnyDescendantBits( HAS_ARRAY ) &&
            MyContext.AnyDescendantBits( HAS_CONF_ARRAY |
            HAS_CONF_VAR_ARRAY |
            HAS_VAR_ARRAY ) )
        {
        MyContext.SetDescendantBits( HAS_MULTIDIM_SIZING );
        MyContext.SetDescendantBits( HAS_MULTIDIM_VECTOR );
        }

    MyContext.SetDescendantBits( HAS_ARRAY );

    if ( NODE_POINTER == GetNonDefChild()->NodeKind() )
        MyContext.SetDescendantBits( HAS_ARRAYOFPOINTERS );

    // disallow forward references as array elements
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        if (! MyContext.AnyAncestorBits( IN_LIBRARY ))
            SemError( this, MyContext, UNDEFINED_SYMBOL, NULL );
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    if ( MyContext.AllDescendantBits( HAS_DIRECT_CONF_OR_VAR |
            HAS_MULTIDIM_SIZING ) &&
            MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) &&
            ( GetChild()->NodeKind() == NODE_DEF ) )
        {
        SemError( this, MyContext, NON_ANSI_MULTI_CONF_ARRAY, NULL );
        }

    MyContext.ClearDescendantBits( HAS_DIRECT_CONF_OR_VAR );
    if ( ( FAInfo.Kind != FA_NONE ) &&
            ( FAInfo.Kind != FA_STRING ) &&
            ( FAInfo.Kind != FA_INTERFACE ) )
        MyContext.SetDescendantBits( HAS_DIRECT_CONF_OR_VAR );

    if ( MyContext.AnyDescendantBits( HAS_POINTER ) )
        fHasPointer = TRUE;

    if ( MyContext.AnyDescendantBits( HAS_HANDLE ) )
        TypeSemError( this, MyContext, BAD_CON_CTXT_HDL_ARRAY, NULL );

    // don't allow functions as elements
    if ( MyContext.AnyDescendantBits( HAS_FUNC ) &&
            MyContext.AllAncestorBits( IN_INTERFACE | IN_RPC ) )
        TypeSemError( this, MyContext, BAD_CON_ARRAY_FUNC, NULL );

    if ( MyContext.AnyDescendantBits( HAS_IN_CSTYPE | HAS_OUT_CSTYPE ) )
        {
        if ( FA_CONFORMANT == FAInfo.Kind )
            SemError( this, MyContext, NO_CONFORMANT_CSCHAR, NULL );

        if ( IsMultiDim )
            SemError( this, MyContext, NO_MULTIDIM_CSCHAR, NULL );

        SetHasCSType();
        }

    SIZE_LENGTH_USAGE usage;

    if ( HasCSType() )
        usage = CSSizeLengthUsage;            
    else
        usage = NonCSSizeLengthUsage;

    if ( ! FAInfo.SetExpressionVariableUsage( usage ) )
        SemError( this, MyContext, SHARED_CSCHAR_EXPR_VAR, NULL );

    MyContext.ClearDescendantBits( HAS_STRUCT );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_echo_string::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    pParentCtxt->ReturnValues( MyContext );
};

void
node_e_status_t::VerifyParamUsage( SEM_ANALYSIS_CTXT * pCtxt )
{
    // verify that we are under an OUT-only pointer
    // or a "hidden" status parameter (only specified in the acf file)

    if ( pCtxt->AnyAncestorBits( UNDER_IN_PARAM ) ||
            !pCtxt->AnyAncestorBits( UNDER_OUT_PARAM ) )
        {
        if ( !pCtxt->AnyAncestorBits( UNDER_HIDDEN_STATUS ) )
            {
            TypeSemError( this, *pCtxt, E_STAT_T_MUST_BE_PTR_TO_E, NULL );
            return;
            }
        }

    SEM_ANALYSIS_CTXT * pCurCtxt = (SEM_ANALYSIS_CTXT *)pCtxt->GetParentContext();
    node_skl * pPar = pCurCtxt->GetParent();
    unsigned short PtrSeen = 0;
    NODE_T Kind;

    while ( ( Kind = pPar->NodeKind() ) != NODE_PARAM )
        {
        switch ( Kind )
            {
            case NODE_POINTER:      // count pointers (must see just 1 )
                PtrSeen++;
                break;
            case NODE_DEF:          // skip DEF nodes
            case NODE_E_STATUS_T:   // and the error_status_t node
                break;
            default:                // error on anything else
                TypeSemError( this, *pCtxt, E_STAT_T_MUST_BE_PTR_TO_E, NULL );
                return;
            }
        // advance up the stack
        pCurCtxt = (SEM_ANALYSIS_CTXT *) pCurCtxt->GetParentContext();
        pPar = pCurCtxt->GetParent();
        }

    // complain about wrong number of pointers
    if ( PtrSeen != 1 )
        TypeSemError( this, *pCtxt, E_STAT_T_MUST_BE_PTR_TO_E, NULL );

}

void
node_e_status_t::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{

    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    BOOL fFaultstat = (NULL != MyContext.ExtractAttribute( ATTR_FAULTSTAT ));
    BOOL fCommstat = (NULL != MyContext.ExtractAttribute( ATTR_COMMSTAT ));

    MyContext.SetDescendantBits( HAS_E_STAT_T );

    CheckDeclspecAlign( MyContext );

    // an error status_t can only be:
    //      1: a parameter return type, or
    //      2: an [out] only pointer parameter
    // and it must have at least one of [comm_status] or
    // [fault_status] applied

    // make sure parameter is an OUT-only pointer if it has comm/fault_status
    if ( fFaultstat || fCommstat )
        {
        if ( MyContext.AnyAncestorBits( IN_RPC ) )
            {
            // A proc in an actual remote interface.
            // Then it must be an appropriate parameter
            if ( MyContext.AnyAncestorBits( IN_PARAM_LIST ) )
                {
                VerifyParamUsage( &MyContext );
                }
            // or on a return type.
            else if ( !MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
                {
                TypeSemError( this, MyContext, E_STAT_T_MUST_BE_PTR_TO_E , NULL );
                }
            }

        if ( MyContext.AnyAncestorBits( IN_ARRAY ) )
            TypeSemError( this, MyContext, E_STAT_T_ARRAY_ELEMENT, NULL );

        if ( MyContext.AnyAncestorBits( IN_TRANSMIT_AS | IN_REPRESENT_AS ) )
            TypeSemError( this, MyContext, TRANSMIT_AS_ON_E_STAT_T, NULL );

        if ( MyContext.AnyAncestorBits( IN_STRUCT | IN_UNION ) )
            TypeSemError( this, MyContext, BAD_CON_E_STAT_T_FIELD, NULL );

        if ( MyContext.AnyAncestorBits( IN_USER_MARSHAL ) )
            TypeSemError( this, MyContext, TRANSMIT_AS_ON_E_STAT_T, NULL );
        }

    MyContext.RejectAttributes();

    pParentCtxt->ReturnValues( MyContext );

};

void
node_error::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );

    MyContext.RejectAttributes();
        
    CheckDeclspecAlign( MyContext );

    pParentCtxt->ReturnValues( MyContext );
};

void
node_wchar_t::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
        
    CheckDeclspecAlign( MyContext );

    TypeSemError( this, MyContext, WCHAR_T_INVALID_OSF, NULL );

    if ( MyContext.AllAncestorBits( IN_PARAM_LIST | IN_RPC ) )
        SemError( this, MyContext, WCHAR_T_NEEDS_MS_EXT_TO_RPC, NULL );

    MyContext.RejectAttributes();

    pParentCtxt->ReturnValues( MyContext );
};

void
node_library::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt)
{
    MEM_ITER MemIter(this);
    SEM_ANALYSIS_CTXT MyContext(this, pParentCtxt);

    BOOL HasGuid = MyContext.FInSummary( ATTR_GUID );

    MyContext.ExtractAttribute(ATTR_HELPSTRING);
    MyContext.ExtractAttribute(ATTR_HELPCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGCONTEXT);
    MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL);

    gfCaseSensitive=FALSE;

    // check for illegal attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            // acceptable attributes
            case MATTR_RESTRICTED:
                break;
            // unacceptable attributes
            case MATTR_READONLY:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_CONTROL:
                break;
            // unacceptable attributes
            case TATTR_LICENSED:
            case TATTR_APPOBJECT:
            case TATTR_PUBLIC:
            case TATTR_DUAL:
            case TATTR_PROXY:
            case TATTR_NONEXTENSIBLE:
            case TATTR_OLEAUTOMATION:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }

    // make sure the UUID is unique
    if ( HasGuid )
        {
        node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }
    else
        {
        SemError(this, MyContext, NO_UUID_SPECIFIED, NULL);
        }
    node_skl * pN;
    NODE_T     nodeKind;

    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        SEM_ANALYSIS_CTXT ChildContext(MyContext);
        ChildContext.SetInterfaceContext( &MyContext );
        ChildContext.SetAncestorBits(IN_LIBRARY);
        nodeKind = pN->NodeKind();
        
        if ( nodeKind == NODE_PROC )
            {
            SemError( this, MyContext, INVALID_MEMBER, pN->GetSymName() );
            }
        else if (
                nodeKind != NODE_MODULE &&
                nodeKind != NODE_DISPINTERFACE &&
                nodeKind != NODE_COCLASS &&
                nodeKind != NODE_INTERFACE &&
                nodeKind != NODE_STRUCT &&
                nodeKind != NODE_UNION &&
                nodeKind != NODE_ENUM &&
                nodeKind != NODE_LABEL &&
                nodeKind != NODE_DEF &&
                nodeKind != NODE_INTERFACE_REFERENCE &&
                nodeKind != NODE_ID &&
                nodeKind != NODE_ECHO_STRING &&
                nodeKind != NODE_FORWARD && 
                nodeKind != NODE_MIDL_PRAGMA
                )
            {
            SemError(this, MyContext, POSSIBLE_INVALID_MEMBER, pN->GetSymName());
            }

        pN->SemanticAnalysis(&ChildContext);
        }

    // consume all the library attributes
    MyContext.CheckAttributes( );
    // MyContext.ReturnValues(ChildContext);
    pParentCtxt->ReturnValues( MyContext );
    gfCaseSensitive=TRUE;
}

void
node_coclass::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt)
{
    // make sure each coclass only gets analyzed once
    if (fSemAnalyzed)
        return;
    fSemAnalyzed = TRUE;

    MEM_ITER MemIter(this);
    SEM_ANALYSIS_CTXT MyContext(this, pParentCtxt);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_LCID );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    SEM_ANALYSIS_CTXT ChildContext(MyContext);
    ChildContext.SetInterfaceContext( &MyContext );

    // check for illegal attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_NONCREATABLE:
                SetNotCreatable(TRUE);
                break;
            case TATTR_LICENSED:
            case TATTR_APPOBJECT:
            case TATTR_CONTROL:
            case TATTR_AGGREGATABLE:
                break;
            // unacceptable attributes
            case TATTR_PUBLIC:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            
            case TATTR_DUAL:
            case TATTR_PROXY:
            case TATTR_NONEXTENSIBLE:
            case TATTR_OLEAUTOMATION:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
        // check for illegal attributes
    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            // acceptable attributes
            case MATTR_RESTRICTED:
                break;
            // unacceptable attributes
            case MATTR_READONLY:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
    BOOL HasGuid = MyContext.FInSummary( ATTR_GUID );

    // make sure the UUID is unique
    if ( HasGuid )
        {
        node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }
    else
        {
        SemError(this, MyContext, NO_UUID_SPECIFIED, NULL);
        }

    ChildContext.SetAncestorBits(IN_COCLASS);

    BOOL fHasDefaultSource = FALSE;
    BOOL fHasDefaultSink = FALSE;

    named_node * pN = (named_node *)MemIter.GetNext();
    named_node * pNFirstSource = NULL;
    named_node * pNFirstSink = NULL;
    while (pN)
        {
        BOOL fSource = pN->FMATTRInSummary(MATTR_SOURCE);
        BOOL fDefaultVtable = pN->FMATTRInSummary(MATTR_DEFAULTVTABLE);
        if (fSource)
            {
            if (NULL == pNFirstSource && !pN->FMATTRInSummary(MATTR_RESTRICTED))
                pNFirstSource = pN;
            }
        else
            {
            if (NULL == pNFirstSink && !pN->FMATTRInSummary(MATTR_RESTRICTED))
                pNFirstSink = pN;
            }
        if (fDefaultVtable)
            {
            if (!fSource)
                {
                SemError(this, MyContext, DEFAULTVTABLE_REQUIRES_SOURCE, pN->GetSymName());
                }
            }
        if (pN->GetAttribute(ATTR_DEFAULT))
            {
            if (fSource)
                {
                if (fHasDefaultSource)
                    {
                    SemError(this, MyContext, TWO_DEFAULT_INTERFACES, pN->GetSymName());
                    }
                fHasDefaultSource = TRUE;
                }
            else
                {
                if (fHasDefaultSink)
                    {
                    SemError(this, MyContext, TWO_DEFAULT_INTERFACES, pN->GetSymName());
                    }
                fHasDefaultSink = TRUE;
                }
            }
        pN->SemanticAnalysis(&ChildContext);
        pN = MemIter.GetNext();
        }

    if (!fHasDefaultSink)
        {
        if (pNFirstSink)
            pNFirstSink->SetAttribute(ATTR_DEFAULT);
        }
    if (!fHasDefaultSource)
        {
        if (pNFirstSource)
            pNFirstSource->SetAttribute(ATTR_DEFAULT);
        }

    MyContext.CheckAttributes( );
    MyContext.ReturnValues(ChildContext);
    pParentCtxt->ReturnValues( MyContext );
}

void
node_dispinterface::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt)
{
    // make sure each dispinterface gets analyzed only once
    if (fSemAnalyzed)
        return;
    fSemAnalyzed = TRUE;

    MEM_ITER MemIter(this);
    SEM_ANALYSIS_CTXT MyContext(this, pParentCtxt);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_LCID );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    SEM_ANALYSIS_CTXT ChildContext(MyContext);
    ChildContext.SetInterfaceContext( &MyContext );

    // check for illegal attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_NONEXTENSIBLE:
                break;
            // unacceptable attributes
            case TATTR_OLEAUTOMATION:
            case TATTR_PUBLIC:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
            case TATTR_PROXY:
            case TATTR_DUAL:
            case TATTR_LICENSED:
            case TATTR_APPOBJECT:
            case TATTR_CONTROL:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }

    node_member_attr * pMA;
    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER) ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            // acceptable attributes
            case MATTR_RESTRICTED:
                break;
            // unacceptable attributes
            case MATTR_READONLY:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_USESGETLASTERROR:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
    BOOL HasGuid = MyContext.FInSummary( ATTR_GUID );

    // make sure the UUID is unique
    if ( HasGuid )
        {
        node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }
    else
        {
        SemError(this, MyContext, NO_UUID_SPECIFIED, NULL);
        }

    // make sure IDispatch is defined.
    SymKey SKey("IDispatch", NAME_DEF);
    pDispatch = pBaseSymTbl->SymSearch(SKey);
    if (!pDispatch)
        {
        // IDispatch is not defined: generate error.
        SemError(this, MyContext, NO_IDISPATCH, GetSymName());
        }
    else
        {
        if (pDispatch->NodeKind() == NODE_INTERFACE_REFERENCE)
            pDispatch = ((node_interface_reference *)pDispatch)->GetRealInterface();
        }
    ChildContext.SetAncestorBits((ANCESTOR_FLAGS) IN_DISPINTERFACE);

    node_skl * pN;
    while ( ( pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis(&ChildContext);
        }
    MyContext.CheckAttributes( );
    MyContext.ReturnValues(ChildContext);
    pParentCtxt->ReturnValues( MyContext );
}

void
node_module::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt)
{
    // make sure each module gets analyzed only once
    if (fSemAnalyzed)
        return;
    fSemAnalyzed = TRUE;

    MEM_ITER MemIter(this);
    SEM_ANALYSIS_CTXT MyContext(this, pParentCtxt);
    BOOL HasGuid = MyContext.FInSummary( ATTR_GUID );
    MyContext.ExtractAttribute(ATTR_DLLNAME);
    while(MyContext.ExtractAttribute(ATTR_CUSTOM));
    MyContext.ExtractAttribute(ATTR_TYPEDESCATTR);
    MyContext.ExtractAttribute( ATTR_HIDDEN );
    MyContext.ExtractAttribute( ATTR_VERSION );
    MyContext.ExtractAttribute( ATTR_HELPSTRING );
    MyContext.ExtractAttribute( ATTR_HELPSTRINGCONTEXT );
    MyContext.ExtractAttribute( ATTR_HELPCONTEXT );
    MyContext.ExtractAttribute( ATTR_LCID );
    if (MyContext.ExtractAttribute(ATTR_HELPSTRINGDLL))
        {
        SemError(this, MyContext, INAPPLICABLE_ATTRIBUTE, 0);
        }

    if ( !MyContext.AnyAncestorBits( IN_LIBRARY ) )
        {
        SemError(this, MyContext, NO_LIBRARY, 0);
        }

    SEM_ANALYSIS_CTXT ChildContext(MyContext);
    ChildContext.SetInterfaceContext( &MyContext );

    // make sure the UUID is unique
    if ( HasGuid )
        {
        node_guid * pGuid = (node_guid *) MyContext.ExtractAttribute( ATTR_GUID );
        node_skl* pDuplicate = GetDuplicateGuid( pGuid, pUUIDTable );
        if ( pDuplicate )
            {
            SemError(this, MyContext, DUPLICATE_UUID, pDuplicate->GetSymName());
            }
        }

    // check for illegal attributes
    node_type_attr * pTA;
    while ( ( pTA = (node_type_attr *)MyContext.ExtractAttribute(ATTR_TYPE) ) != 0 )
        {
        switch (pTA->GetAttr())
            {
            // acceptable attributes
            case TATTR_PUBLIC:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, NEWLYFOUND_INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }
                break;
            // unacceptable attributes
            case TATTR_OLEAUTOMATION:
            case TATTR_LICENSED:
            case TATTR_APPOBJECT:
            case TATTR_CONTROL:
            case TATTR_PROXY:
            case TATTR_DUAL:
            case TATTR_NONEXTENSIBLE:
            case TATTR_NONCREATABLE:
            case TATTR_AGGREGATABLE:
                {
                char * pAttrName = pTA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
    node_member_attr * pMA;
    node_member_attr * pUsesGetLastErrorAttr = 0;

    while ( ( pMA = (node_member_attr *)MyContext.ExtractAttribute(ATTR_MEMBER)  ) != 0 )
        {
        switch (pMA->GetAttr())
            {
            // acceptable attributes
            case MATTR_RESTRICTED:
                break;
            case MATTR_USESGETLASTERROR:
                pUsesGetLastErrorAttr = pMA;
                break;
            // unacceptable attributes
            case MATTR_READONLY:
            case MATTR_SOURCE:
            case MATTR_DEFAULTVTABLE:
            case MATTR_BINDABLE:
            case MATTR_DISPLAYBIND:
            case MATTR_DEFAULTBIND:
            case MATTR_REQUESTEDIT:
            case MATTR_PROPGET:
            case MATTR_PROPPUT:
            case MATTR_PROPPUTREF:
            case MATTR_OPTIONAL:
            case MATTR_RETVAL:
            case MATTR_VARARG:
            case MATTR_PREDECLID:
            case MATTR_UIDEFAULT:
            case MATTR_NONBROWSABLE:
            case MATTR_DEFAULTCOLLELEM:
            case MATTR_IMMEDIATEBIND:
            case MATTR_REPLACEABLE:
                {
                char * pAttrName = pMA->GetNodeNameString();
                SemError( this, MyContext, INAPPLICABLE_ATTRIBUTE, pAttrName);
                break;
                }

            }
        }
        if (pUsesGetLastErrorAttr != 0)
            {
            MyContext.Add(pUsesGetLastErrorAttr);
            }

    ChildContext.SetAncestorBits(IN_MODULE);
    node_skl * pN;
    while ( (pN = MemIter.GetNext() ) != 0 )
        {
        pN->SemanticAnalysis(&ChildContext);
        }

    MyContext.CheckAttributes( );
    MyContext.ReturnValues(ChildContext);
    pParentCtxt->ReturnValues( MyContext );
}

void
node_pipe::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    if (!GetSymName())
    {
        char * pParentName = pParentCtxt->GetParent()->GetSymName();
        char * pName = new char [strlen(pParentName) + 6]; // the length of "pipe_" plus terminating null
        strcpy(pName, "pipe_");
        strcat(pName,pParentName);
        SetSymName(pName);
    }

    if ( MyContext.AnyAncestorBits( HAS_ASYNCHANDLE ) &&
         !MyContext.AnyAncestorBits( IN_OBJECT_INTF ) )
        {
        SetGenAsyncPipeFlavor();
        }

    GetChild()->SemanticAnalysis(&MyContext);

    CheckDeclspecAlign( MyContext );

    // Remove the following statement once support for UNIONS within PIPES is provided by the interpreter.
    if (MyContext.AnyDescendantBits( HAS_UNION ))
        {
        // pipe with a UNION
        RpcSemError(this , MyContext, UNIMPLEMENTED_FEATURE, "pipes can't contain unions" );
        }

    if (MyContext.AnyDescendantBits( HAS_HANDLE
                                   | HAS_POINTER
                                   | HAS_VAR_ARRAY
                                   | HAS_CONF_ARRAY
                                   | HAS_CONF_VAR_ARRAY
                                   | HAS_CONTEXT_HANDLE
                                   | HAS_CONF_PTR
                                   | HAS_VAR_PTR
                                   | HAS_CONF_VAR_PTR
                                   | HAS_TRANSMIT_AS
                                   | HAS_REPRESENT_AS
                                   | HAS_INTERFACE_PTR
                                   | HAS_DIRECT_CONF_OR_VAR ))
        {
        // All the above are illegal types within a pipe
        RpcSemError(this, MyContext, ILLEGAL_PIPE_TYPE, NULL );
        }

    MyContext.ClearAncestorBits( IN_UNION | IN_NE_UNION | IN_ARRAY );
    if ( MyContext.AnyAncestorBits( IN_ARRAY |
                                    IN_UNION |
                                    IN_NE_UNION |
                                    IN_STRUCT ))
        TypeSemError( this, MyContext, ILLEGAL_PIPE_EMBEDDING, NULL );

    if ( MyContext.AnyAncestorBits( IN_TRANSMIT_AS  |
                                    IN_REPRESENT_AS |
                                    IN_USER_MARSHAL |
                                    IN_FUNCTION_RESULT ))
        TypeSemError( this, MyContext, ILLEGAL_PIPE_CONTEXT, NULL );

    if ( MyContext.AnyAncestorBits( IN_ENCODE_INTF ))
        TypeSemError( this, MyContext, PIPES_WITH_PICKLING, NULL );

    if ( MyContext.AnyAncestorBits( IN_OBJECT_INTF ) )
        {
        node_skl* pType = pParentCtxt->GetParent();
        if ( pType->GetChild() )
            {
            pType = pType->GetChild();
            }
        }    
    // BUGBUG UNDONE

    // Basically, a pipe can only be used as a parameter.

    // Pipe parameters may only be passed by value or by reference.

    // Need to make sure that /-Os mode isn't enabled (until support
    // for it has been implemented).

    // Need to enable /-Oi2 mode for the containing proc if we decide not
    // to implement /-Oi mode.

    MyContext.SetDescendantBits( (DESCENDANT_FLAGS) HAS_PIPE );

    pParentCtxt->ReturnValues( MyContext );
}

void
node_safearray::SemanticAnalysis( SEM_ANALYSIS_CTXT * pParentCtxt )
{
    SEM_ANALYSIS_CTXT MyContext( this, pParentCtxt );
    FIELD_ATTR_INFO FAInfo;
    PTRTYPE PtrKind = PTR_UNKNOWN;
    BOOL fArrayParent = MyContext.AnyAncestorBits( IN_ARRAY );

    // this maintains a reference to LPSAFEARRAY. This is
    // necessary to generate the appropriate code when
    // SAFEARRAY(type) construct is used outside the library block
    char*       szSafeArray = "LPSAFEARRAY";
    SymKey      SKey( szSafeArray, NAME_DEF );
    named_node* pSafeArrayNode =  pBaseSymTbl->SymSearch( SKey );

    if ( pSafeArrayNode == 0 )
        {
        SemError( this, MyContext, UNDEFINED_SYMBOL, szSafeArray );
        }
    else
        {
        SetTypeAlias( pSafeArrayNode );
        }

    CheckDeclspecAlign( MyContext );

    // See if context_handle applied to param reached us
    if ( CheckContextHandle( MyContext ) )
        {
        MyContext.SetDescendantBits( HAS_HANDLE | HAS_CONTEXT_HANDLE );
        }

    if ( MyContext.FInSummary( ATTR_SWITCH_IS ) )
        TypeSemError( this, MyContext, ARRAY_OF_UNIONS_ILLEGAL, NULL );


//    if ( !MyContext.AnyAncestorBits( IN_LIBRARY ) )
//        {
//        SemError(this, MyContext, SAFEARRAY_NOT_SUPPORT_OUTSIDE_TLB, 0);
//        }
    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    PtrKind = MyContext.GetPtrKind();

    MIDL_ASSERT( PtrKind != PTR_UNKNOWN );

    if ( PtrKind == PTR_FULL )
        {
        MyContext.SetDescendantBits( HAS_FULL_PTR );
        }

    if ( MyContext.ExtractAttribute( ATTR_PTR_KIND) )
        TypeSemError( this, MyContext, MORE_THAN_ONE_PTR_ATTR, NULL );

    // ref pointer may not be returned
    if ( ( PtrKind == PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_FUNCTION_RESULT ) )
        {
        if (MyContext.FindNonDefAncestorContext()->GetParent()->NodeKind()
                == NODE_PROC )
            TypeSemError( this, MyContext, BAD_CON_REF_RT, NULL );
        }

    // unique or full pointer may not be out only
    if ( ( PtrKind != PTR_REF ) &&
            MyContext.AllAncestorBits( IN_RPC | IN_PARAM_LIST ) &&
            !MyContext.AnyAncestorBits( UNDER_IN_PARAM |
            IN_STRUCT |
            IN_UNION |
            IN_ARRAY |
            IN_POINTER ) )
        TypeSemError( this, MyContext, UNIQUE_FULL_PTR_OUT_ONLY, NULL );

    MyContext.SetAncestorBits( IN_ARRAY );

    // warn about OUT const things
    if ( FInSummary( ATTR_CONST ) )
        {
        if ( MyContext.AnyAncestorBits( UNDER_OUT_PARAM ) )
            RpcSemError( this, MyContext, CONST_ON_OUT_PARAM, NULL );
        else if ( MyContext.AnyAncestorBits( IN_FUNCTION_RESULT ) )
            RpcSemError( this, MyContext, CONST_ON_RETVAL, NULL );
        }

    /////////////////////////////////////////////////////////////////////////
    // process field attributes

    FAInfo.SetControl( FALSE, GetBasicType()->IsPtrOrArray() );
    MyContext.ExtractFieldAttributes( &FAInfo );

    switch ( FAInfo.Kind )
        {
        case FA_NONE:
            {
            break;
            }
        case FA_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );

            if ( MyContext.AllAncestorBits( UNDER_OUT_PARAM |
                    IN_PARAM_LIST |
                    IN_RPC ) &&
                    !MyContext.AnyAncestorBits( IN_STRUCT |
                    IN_UNION |
                    IN_POINTER |
                    IN_ARRAY |
                    UNDER_IN_PARAM ) )
                TypeSemError( this, MyContext, DERIVES_FROM_UNSIZED_STRING, NULL );

            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            // break;  deliberate fall through to case below
            }
        case FA_VARYING:
            {
            MyContext.SetDescendantBits( HAS_VAR_ARRAY );
            break;
            }
        case FA_CONFORMANT:
            {
            MyContext.SetDescendantBits( HAS_CONF_ARRAY );
            break;
            }
        case FA_CONFORMANT_STRING:
            {
            // string attributes only allowed on char and wchar_t
            if ( !GetBasicType()->IsStringableType() )
                TypeSemError( this, MyContext, STRING_NOT_ON_BYTE_CHAR, NULL );
            if ( FAInfo.StringKind == STR_BSTRING )
                TypeSemError( this, MyContext, BSTRING_NOT_ON_PLAIN_PTR, NULL );
            // break;  deliberate fall through to case below
            }
        case FA_CONFORMANT_VARYING:
            {
            MyContext.SetDescendantBits( HAS_CONF_VAR_ARRAY );
            break;
            }
        case FA_INTERFACE:
            {
            // gaj - tbd
            break;
            }
        default:    // string + varying combinations
            {
            TypeSemError( this, MyContext, INVALID_SIZE_ATTR_ON_STRING, NULL );
            break;
            }
        }

    // detect things like arrays of conf structs...
    // if we have an array as an ancestor, and we have conformance, then complain
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) &&
            fArrayParent )
        {
        // see if there are any bad things between us and our parent array
        SEM_ANALYSIS_CTXT * pCtxt = (SEM_ANALYSIS_CTXT *) pParentCtxt;
        node_skl * pCur = pCtxt->GetParent();

        // check up for anything other than def below proc
        // make sure the proc only has one param
        while ( pCur->NodeKind() != NODE_ARRAY )
            {
            if ( pCur->NodeKind() != NODE_DEF )
                {
                SemError( this, MyContext, ILLEGAL_CONFORMANT_ARRAY, NULL );
                break;
                }
            pCtxt = (SEM_ANALYSIS_CTXT *) pCtxt->GetParentContext();
            pCur = pCtxt->GetParent();
            }

        }

    //////////////////////////////////////////////////////////////
    // process the array element
    GetChild()->SemanticAnalysis( &MyContext );

/*
    // BSTR has sizeis_ptr, eventhough under variant, and it would be ugly to
    // hardcode checking variant here. well...
    if ( MyContext.AnyDescendantBits( HAS_CONF_ARRAY |
                                      HAS_CONF_VAR_ARRAY |
                                      HAS_VAR_ARRAY |
                                      HAS_UNSAT_REP_AS |
                                      HAS_CONTEXT_HANDLE |
                                      HAS_CONF_PTR |
                                      HAS_VAR_PTR |
                                      HAS_CONF_VAR_PTR |
                                      HAS_DIRECT_CONF_OR_VAR |
                                      HAS_FUNC |
                                      HAS_FULL_PTR |
                                      HAS_TOO_BIG_HDL |
                                      HAS_MULTIDIM_SIZING |
                                      HAS_PIPE |
                                      HAS_MULTIDIM_VECTOR |
                                      HAS_SIZED_ARRAY |
                                      HAS_SIZED_PTR ) )
        TypeSemError( this, MyContext, INVALID_SAFEARRAY_ATTRIBUTE, NULL );
*/                                      
    MyContext.SetDescendantBits( HAS_ARRAY );

	// early binding of safearray(interface pointer) doesn't work
    node_skl * pChild = GetChild()->GetBasicType();
    SEM_ANALYSIS_CTXT * pIntfCtxt = (SEM_ANALYSIS_CTXT *)
        MyContext.GetInterfaceContext();
    BOOL fLocal         = pIntfCtxt->FInSummary( ATTR_LOCAL );
    fLocal |= MyContext.AnyAncestorBits( IN_LOCAL_PROC );
        
    if ( pChild->NodeKind() == NODE_POINTER ) 
        pChild = pChild->GetChild();
    if ( IsInterfaceKind( pChild->NodeKind() )  &&
         !MyContext.AnyAncestorBits( IN_LIBRARY ) &&
         !fLocal )
        SemError( this, MyContext, SAFEARRAY_IF_OUTSIDE_LIBRARY, NULL );

    // disallow forward references as array elements
    // NOTE- all safearray elements are VARIANTS, we don't really need
    // to enforce this restriction for safearrays.  Besides, enforcing
    // this restriction breaks some of our test cases.
    if ( MyContext.AnyDescendantBits( HAS_INCOMPLETE_TYPE ) )
        {
        MyContext.ClearDescendantBits( HAS_INCOMPLETE_TYPE );
        }
    MyContext.ClearDescendantBits( HAS_RECURSIVE_DEF );

    if ( MyContext.AllDescendantBits( HAS_DIRECT_CONF_OR_VAR |
            HAS_MULTIDIM_SIZING ) &&
            MyContext.AnyDescendantBits( HAS_CONF_ARRAY | HAS_CONF_VAR_ARRAY ) &&
            ( GetChild()->NodeKind() == NODE_DEF ) )
        {
        SemError( this, MyContext, NON_ANSI_MULTI_CONF_ARRAY, NULL );
        }

    MyContext.ClearDescendantBits( HAS_DIRECT_CONF_OR_VAR );
    if ( ( FAInfo.Kind != FA_NONE ) &&
            ( FAInfo.Kind != FA_STRING ) &&
            ( FAInfo.Kind != FA_INTERFACE ) )
        MyContext.SetDescendantBits( HAS_DIRECT_CONF_OR_VAR );

    if ( MyContext.AnyDescendantBits( HAS_HANDLE ) )
        TypeSemError( this, MyContext, BAD_CON_CTXT_HDL_ARRAY, NULL );

    // don't allow functions as elements
    if ( MyContext.AnyDescendantBits( HAS_FUNC ) &&
            MyContext.AllAncestorBits( IN_INTERFACE | IN_RPC ) )
        TypeSemError( this, MyContext, BAD_CON_ARRAY_FUNC, NULL );

    // This is a hack to propagate the correct attributes up to the next level.
    // Unfortunately, semantic analysis does more then just determine 
    // if the *.idl file is legal.  It also catches known limitations of the 
    // engine, aids in determining the complexity of the marshaling problem,
    // and other checks that change the state of the front end which directly 
    // affect the backend.
 
    // gracelly handle the error case and the library case.
    if ( ! pSafeArrayNode | MyContext.AnyAncestorBits( IN_LIBRARY ) )
    {
        // Is this class was used in a proxy, continue to pass up the proxy bits.
        if ( fInProxy )
            {
            pSafeArrayNode->SemanticAnalysis( pParentCtxt );
            return;
            }
        MyContext.ClearDescendantBits( HAS_STRUCT );
        pParentCtxt->ReturnValues( MyContext );
        return;
    }  

    fInProxy = TRUE;
    pSafeArrayNode->SemanticAnalysis( pParentCtxt );
    
};

void
node_async_handle::SemanticAnalysis( SEM_ANALYSIS_CTXT* )
    {
    }


BOOL IsOLEAutomationType( char* szTypeName )
    {
    BOOL    fRet = FALSE;
    // keep this list sorted!
    static char*   szOLEAutomationTypes[] =
        {
        "BSTR",             // wchar_t
        "CURRENCY",         // struct
        "DATE",             // double
        "SCODE",            // long
        "VARIANT",
        "VARIANT_BOOL",
        };

    int uFirst = 0;
    int uLast  = (sizeof(szOLEAutomationTypes) - 1) / sizeof(char*);
    int uMid   = (uFirst + uLast) / 2;
    
    while (uLast >= uFirst && uLast >= 0 && uFirst <= (sizeof(szOLEAutomationTypes) - 1) / sizeof(char*))
        {
        int nCmp = strcmp(szOLEAutomationTypes[uMid], szTypeName);

        if (nCmp == 0)
            {
            fRet = TRUE;
            break;
            }
        else if (nCmp > 0)
            {
            uLast = uMid - 1;
            }
        else
            {
            uFirst = uMid + 1;
            }
        uMid = (uFirst + uLast) / 2;
        }

    return fRet;
    }


BOOL IsBasicOleAutoKind( NODE_T x)
    {
    // NODE_INT128, NODE_FLOAT80, NODE_FLOAT128 is not supported.
    return ( (x) == NODE_DOUBLE || (x) == NODE_FLOAT || (x) == NODE_INT ||  
             (x) == NODE_SHORT || (x) == NODE_LONG || (x) == NODE_CHAR  ||
             (x) == NODE_INT32 ||
             (x) == NODE_HYPER  || (x) == NODE_INT64  ||  (x) == NODE_INT3264 ||
             (x) == NODE_BOOLEAN || (x) == NODE_WCHAR_T 
             );
    }

BOOL IsOLEAutoBasicType ( node_base_type* pNBT )
    {
    NODE_T          nodeKind    = pNBT->NodeKind();

    if ( nodeKind == NODE_CHAR )
        {
        return ( (node_base_type*) pNBT )->IsUnsigned();
        }
    else
        {
        return TRUE;
        }
    }

BOOL IsOLEAutoInterface ( node_interface* pType )
    {
    node_interface* pNodeIf;
    BOOL            fRet = FALSE;

    // pType may be a node_interface or a node_interaface_reference
    // "normalize" it.
    if ( pType->NodeKind() == NODE_INTERFACE_REFERENCE )
        {
        pNodeIf = (( node_interface_reference *) pType )->GetRealInterface();
        }
    else
        {
        pNodeIf = pType;
        }

    fRet = pNodeIf->HasOLEAutomation();
    if ( !fRet )
        {
        // the interface is forward declared,
        // and has not been analyzed for semantic errors,
        // it does not have HasOleAutomation flag set.
        fRet = pNodeIf->FTATTRInSummary( TATTR_OLEAUTOMATION ) ||
               pNodeIf->FTATTRInSummary( TATTR_DUAL );
        if ( !fRet )
            {
            // interface may be an IUnknown or an IDispatch and these do not
            // have HasOleAutomation flag set.
            fRet = pNodeIf->IsValidRootInterface();
            if ( !fRet )
                {
                // It is not IUnknown. If it is not IFont or IDispatch, it is not
                // an oleautomation compliant interface.
                char*  szIfName = pNodeIf->GetSymName();
                fRet = !_stricmp(szIfName, "IDispatch") || !_stricmp(szIfName, "IFontDisp");
                }
            }
        }

    return fRet;
    }

BOOL 
IsOLEAutomationCompliant( node_skl* pParamType )
    {

    if ( pParamType == 0 )
        {
        return FALSE;
        }

    BOOL    fConforms   = FALSE;
    NODE_T  nKind       = pParamType->NodeKind();

    if ( nKind == NODE_SAFEARRAY || nKind == NODE_HREF || nKind == NODE_POINTER )
        {
        fConforms = IsOLEAutomationCompliant( pParamType->GetChild() );
        }
    else if ( IsInterfaceKind( nKind ) )
        {
        fConforms = IsOLEAutoInterface( (node_interface*) pParamType );
        }
    else if ( IsCoclassOrDispKind( nKind ) || nKind == NODE_ENUM || nKind == NODE_STRUCT || 
            IsBasicOleAutoKind( nKind ) )
        {
        fConforms = TRUE;
        }
    else if ( nKind == NODE_DEF )
        {
        node_skl* pChild = pParamType->GetChild();
        fConforms = IsOLEAutomationType( pParamType->GetSymName() ) ? TRUE : IsOLEAutomationCompliant( pChild );
        }
    else if ( nKind == NODE_FORWARD )
        {
        node_skl* pChild = ( (node_forward*) pParamType )->ResolveFDecl();

        fConforms = ( pChild ) ? IsOLEAutomationCompliant( pChild ) : FALSE;
        }

    return fConforms;
    }

bool
HasCorrelation( node_skl* pNode )
    {
    if (
        pNode->FInSummary( ATTR_SIZE ) ||
        pNode->FInSummary( ATTR_FIRST ) ||
        pNode->FInSummary( ATTR_BYTE_COUNT ) ||
        pNode->FInSummary( ATTR_LAST ) ||
        pNode->FInSummary( ATTR_LENGTH ) ||
        pNode->FInSummary( ATTR_MAX ) ||
        pNode->FInSummary( ATTR_MIN ) ||
        pNode->FInSummary( ATTR_SIZE ) ||
        pNode->FInSummary( ATTR_IID_IS ) ||
        pNode->FInSummary( ATTR_SWITCH_IS )
       )
        {
        return true;
        }
    return false;
    }

bool
node_skl::CheckContextHandle( SEM_ANALYSIS_CTXT& MyContext )
    {
    bool fSerialize = MyContext.ExtractAttribute( ATTR_SERIALIZE ) != 0;
    bool fNoSerialize = MyContext.ExtractAttribute( ATTR_NOSERIALIZE ) != 0;
    bool fContextHandle = MyContext.ExtractAttribute( ATTR_CONTEXT ) != 0;
    // See if context_handle applied to param reached us
    if ( fContextHandle )
        {
        // not allowed in DCE mode; context handle must be void *
        TypeSemError( this, MyContext, CONTEXT_HANDLE_VOID_PTR, 0 );
        TypeSemError( this, MyContext, CTXT_HDL_NON_PTR, 0 );
        }
    else
        {
        if ( fSerialize || fNoSerialize )
            {
            SemError( this, MyContext, NO_CONTEXT_HANDLE, GetSymName() );
            }
        }
    if ( fSerialize && fNoSerialize )
        {
        SemError( this, MyContext, CONFLICTING_ATTRIBUTES, GetSymName() );
        }
    return fContextHandle;
    }

extern CMessageNumberList   GlobalMainMessageNumberList;

void
node_midl_pragma::SemanticAnalysis( SEM_ANALYSIS_CTXT* )
    {
    ProcessPragma();
    }

void
node_midl_pragma::ProcessPragma()
    {
    LONG_PTR ulMsg = 0;
    m_pMsgList->Init();
    while ( m_pMsgList->GetNext( (void**) &ulMsg ) == STATUS_OK )
        {
        if ( m_PragmaType == mp_MessageDisable )
            {
            GlobalMainMessageNumberList.ResetMessageFlag( (long)ulMsg );
            }
        else
            {
            GlobalMainMessageNumberList.SetMessageFlag( (long)ulMsg );
            }
        }
    }

void
node_decl_guid::SemanticAnalysis( SEM_ANALYSIS_CTXT* )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\procnode.cxx ===
/*****************************************************************************/
/**                     Microsoft LAN Manager                               **/
/**             Copyright(c) Microsoft Corp., 1987-1999                     **/
/*****************************************************************************/
/*****************************************************************************
File                : procnode.cxx
Title               : proc / param semantic analyser routines
History             :
    10-Aug-1991 VibhasC Created

*****************************************************************************/

#pragma warning ( disable : 4514 4710 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
extern  "C" {
    #include <stdio.h>
    
    #include <string.h>
}
#include "allnodes.hxx"
#include "cmdana.hxx"
#include "idict.hxx"

/****************************************************************************
 local defines
 ****************************************************************************/
/****************************************************************************
 externs 
 ****************************************************************************/

extern CMD_ARG              *   pCommand;

extern node_e_status_t      *   pError_status_t;

/****************************************************************************
 extern  procedures
 ****************************************************************************/


/****************************************************************************/

/****************************************************************************
    proc node procedures
 ****************************************************************************/

//
// add extra "hidden" [comm_status] or [fault_status] parameter
//

void
node_proc::AddStatusParam( 
    char * pName, 
    ATTRLIST AList )
{
    // find error_status_t, make pointer, make param
    // add param to end of param list

    node_pointer *      pPtr    = new node_pointer;
    node_param      *   pParam  = new node_param;

    pPtr->SetChild( pError_status_t );
    pParam->SetChild( pPtr );
    pParam->SetSymName( pName );

    // add param to end of MY param list

    AddLastMember( pParam );

    pParam->AddAttributes( AList );

    // Take note that the parameter is "invisible".

    SetHasExtraStatusParam();
    pParam->SetExtraStatusParam();
}

// force a proc to use -Os 
BOOL
node_proc::ForceNonInterpret()
{
    // ndr64 doesn't do -Os.  In theory we've caught all the cases where
    // a switch to -Os is required.  Just in case we missed one, catch it now

    if ( pCommand->NeedsNDR64Run() )
        RpcError( NULL, 0, UNEXPECTED_OS_IN_NDR64, GetSymName() );

    unsigned short      NewOpt  = GetOptimizationFlags();
    unsigned short      OldOpt = NewOpt;

    // remove interpret, set size
    // zero all the possible interpreter flags

    NewOpt  &= ~OPTIMIZE_ALL_I2_FLAGS;
    NewOpt  |=  OPTIMIZE_SIZE;   

    // did anything change?
    BOOL fChanged = OldOpt != NewOpt;
    if (fChanged)
        SetOptimizationFlags( NewOpt );

    fForcedS = TRUE;
    return fChanged;
}

// force a proc to use -Oi2
BOOL
node_proc::ForceInterpret2()
{
    unsigned short      NewOpt  = GetOptimizationFlags();
    unsigned short      OldOpt = NewOpt;

    // remove interpret, set size
    NewOpt  &= ~OPTIMIZE_SIZE;   
    NewOpt  |= OPTIMIZE_ALL_I2_FLAGS;
    
    // did anything change?
    BOOL fChanged = OldOpt != NewOpt;
    if (fChanged)
        SetOptimizationFlags( NewOpt );

    fForcedI2 = TRUE;
    return fChanged;
}

BOOL
node_proc::HasAtLeastOneShipped()
{
    MEM_ITER        MemIter( this );
    node_skl    *   pNode;
    BOOL            f = FALSE;

    while ( ( pNode = MemIter.GetNext() ) != 0 )
        {
        if( pNode->FInSummary( ATTR_IN ) )
            {
            node_skl * pT = pNode->GetBasicType();

            if( pT->NodeKind() == NODE_POINTER )
                pT = pT->GetBasicType();

            if( pT->GetBasicType()->NodeKind() != NODE_HANDLE_T )
                {
                f = TRUE;
                break; // from the while loop.
                }
            }
        }
    return f;
}

// returns ATTR_NONE if none explicitly specified

BOOL            
node_proc::GetCallingConvention( ATTR_T & Attr )
{
    Attr = ATTR_NONE;
    if ( FInSummary( ATTR_STDCALL ) )
        {
        Attr = ATTR_STDCALL;
        }
    if ( FInSummary( ATTR_CDECL ) )
        {
        if ( Attr != ATTR_NONE ) return FALSE;
        Attr = ATTR_CDECL;
        }
    if ( FInSummary( ATTR_FASTCALL ) )
        {
        if ( Attr != ATTR_NONE ) return FALSE;
        Attr = ATTR_FASTCALL;
        }
    if ( FInSummary( ATTR_PASCAL ) )
        {
        if ( Attr != ATTR_NONE ) return FALSE;
        Attr = ATTR_PASCAL;
        }
    if ( FInSummary( ATTR_FORTRAN ) )
        {
        if ( Attr != ATTR_NONE ) return FALSE;
        Attr = ATTR_FORTRAN;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\inc\nulldefs.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#define _far
#define _near
#define _huge
#define _cdecl
#define _pascal
#define far
#define near
#define huge
#define cdecl
#define pascal
#define _syscall
#define _stdcall
#define _based(x)
#define _segment int
#define volatile
#define __far
#define __near
#define __huge
#define __cdecl
#define __pascal
#define __syscall
#define __based(x)
#define __segment int
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\inc\ebase.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef __EBASE_H__
#define __EBASE_H__

typedef struct _sgoto
	{
	short	Goto;
	short	Token;
	} _SGOTO;

#define	SGOTO	const _SGOTO

typedef struct _sgotovector
	{

	short		State;
	SGOTO	*	pSGoto;
	short		Count;

	} _SGOTOVECTOR;

#define SGOTOVECTOR	const _SGOTOVECTOR

typedef struct _tokvsstatevector
	{
	short		Token;
	short	*	pTokenVsState;
	short		Count;
	} _TOKVSSTATEVECTOR;

#define TOKVSSTATEVECTOR	const _TOKVSSTATEVECTOR

#define _DBENTRY_DEFINED

typedef struct _DBENTRY {
	 short State;
	 const char *  pTranslated;
} _DBENTRY;

#define DBENTRY const _DBENTRY
#endif//__EBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\symtable.cxx ===
/**********************************************************************/
/**                      Microsoft LAN Manager                       **/
/**             Copyright(c) Microsoft Corp., 1987-1999              **/
/**********************************************************************/

/*

symtable.cxx
MIDL Compiler Symbol Table Implementation

This class centralizes access to the symbol table throughout the
compiler.

*/

/*

FILE HISTORY :

DonnaLi     08-25-1990      Created.

*/

#pragma warning ( disable : 4514 )

#include "nulldefs.h"
extern "C" {

#include <stdio.h>
#include <string.h>

}
#include "common.hxx"
#include "errors.hxx"
#include "symtable.hxx"
#include "tlgen.hxx"
#include "mbcs.hxx"

BOOL gfCaseSensitive = TRUE; // initialize things under case sensitive mode

CaseStack gCaseStack;

class named_node;

/**********************************************************************\

NAME:		SymEntry

SYNOPSIS:	Defines an entry in the symbol table.

INTERFACE:

CAVEATS:	This is an internal class used by the symbol table only.

NOTES:

HISTORY:
	Donnali			08-25-1990		Initial creation

\**********************************************************************/

class SymEntry : public SymKey
{
	named_node	*	pTypeGraph;	// pointer to type graph associated with entry
	SymTable 	*	pNextScope;	// pointer to next scope associated with entry

public:

	SymEntry(void)
		{
		pTypeGraph = (named_node *)0;
		pNextScope = (SymTable *)0;
		}
	SymEntry( SymKey NewKey )
			: SymKey( &NewKey )
		{
		pTypeGraph = (named_node *)0;
		pNextScope = (SymTable *)0;
		}

	SymEntry(
		SymKey		NewKey,
		SymTable *	pNext,
		named_node *	pNode) : SymKey( &NewKey )
		{
		pTypeGraph = pNode;
		pNextScope = pNext;
		}

	void SetTypeGraph (named_node * pNode)
		{
		pTypeGraph = pNode;
		}

	named_node * GetTypeGraph (void)
		{
		return pTypeGraph;
		}

	void SetNextScope (SymTable * pNext)
		{
		pNextScope = pNext;
		}

	SymTable * GetNextScope (void)
		{
		return pNextScope;
		}

// here is the use of the private memory allocator
private:

	static
	FreeListMgr				MyFreeList;
	

public:


	void		*			operator new (size_t size)
								{
								return (MyFreeList.Get (size));
								}

	void 					operator delete (void * pX)
								{
								MyFreeList.Put (pX);
								}


} ;


// initialize the memory allocator for SymEntry

FreeListMgr
SymEntry::MyFreeList( sizeof ( SymEntry ) );

/**********************************************************************\

NAME:		PrintSymbol

SYNOPSIS:	Prints out the name of a symbol table entry.

ENTRY:		sym	- the key to symbol table entry to be printed.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

void
SymTable::Print(
	void * sym
	)
{
	 printf ("%s", ((SymKey *)sym)->name);
}

/**********************************************************************\

NAME:		CompareSymbol

SYNOPSIS:	Compares keys to two symbol table entries.

ENTRY:		sym1 -	the key to 1st symbol table entry to be compared.
			sym2 -	the key to 2nd symbol table entry to be compared.

EXIT:		Returns a positive number if sym1 > sym2.
			Returns a negative number if sym1 < sym2.
			Returns 0 if sym1 = sym2.

NOTES:

			Since all the strings are in the lex table, we can just compare
			pointers to do the string compares.

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

SSIZE_T
SymTable::Compare(
	void * sym1,
	void * sym2
	)
{
	int	result;

#ifdef unique_lextable
	// compare pointers into lex table
	result = 	( (int)((SymKey *)sym1)->name )
			-	( (int)((SymKey *)sym2)->name );
#else
	// compare names from keys
    // 1 refers to the value for the flag NORM_IGNORECASE
	result = CurrentCharSet.CompareDBCSString( ((SymKey *)sym1)->name,
					                            ((SymKey *)sym2)->name,
                                                gfCaseSensitive ? 0 : 1);
#endif // unique_lextable
	if (!result)
		{
		return ( ( ((SymKey *)sym1)->kind & NAME_MASK )-
				 ( ((SymKey *)sym2)->kind & NAME_MASK ) );
		}
	else
		{
		return result;
		}
}

/**********************************************************************\

NAME:		SymTable::SymInsert

SYNOPSIS:	Inserts a symbol into the symbol table.

ENTRY:		NewKey	- identifies the symbol table entry.
			pNext	- points to the next scope.
			pNode	- points to the type graph.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
SymTable::SymInsert(
	SymKey		NewKey,
	SymTable *	pNext,
	named_node *	pNode
	)
{
	SymEntry *	NewSymbol;
	Dict_Status	Status;

	NewSymbol = new SymEntry(NewKey, pNext, pNode);

    CaselessEntry * NewEntry = new CaselessEntry(NewSymbol);

    if (!gfCaseSensitive)
    {
        if (NULL != caseless_list.Find(NewEntry))
        {
            // it's allready entered into the caseless table
            // and we're in case insensitive mode so we
            // should fail here (duplicate identifier)
            delete NewSymbol;
            delete NewEntry;
            return NULL;
        }
    }

    Status = Dict_Insert(NewSymbol);
	if (Status == SUCCESS)
    {
        caseless_list.Add(NewEntry);
		return pNode;
    }

	delete NewSymbol;
    delete NewEntry;
	return (named_node *)0;
}

/**********************************************************************\

NAME:		SymTable::SymDelete

SYNOPSIS:	Deletes a symbol from the symbol table.

ENTRY:		OldKey	- identifies the symbol table entry.

EXIT:		Returns the type graph associated with the entry.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
SymTable::SymDelete(
	SymKey	OldKey
	)
{
    SymEntry	TempEntry( OldKey );

    CaselessEntry * OldEntry = new CaselessEntry(&TempEntry);
    SymEntry * OldSymbol;

    // make sure we delete the right symbol from both tables
    if (!gfCaseSensitive)
    {
        OldSymbol = (caseless_list.Delete(OldEntry))->pSymEntry;
    }
    else
    {
        OldSymbol = &TempEntry;
        caseless_list.DeleteExact(OldEntry);
    }

	named_node *	pNode;
    Dict_Status	Status;

    Status = Dict_Delete((void ** )&OldSymbol);

	if (Status == SUCCESS)
		{
		pNode = OldSymbol->GetTypeGraph();
		delete OldSymbol;
#ifdef gajdebug3
			printf("\t\t--- deleting name from symbol table: %d - %s\n",
					OldKey.GetKind(), OldKey.GetString());
#endif
		return pNode;
		}
	else
		{
		return (named_node *)0;
		}
}

/**********************************************************************\

NAME:		SymTable::SymSearch

SYNOPSIS:	Searches the symbol table for a symbol.

ENTRY:		OldKey	- identifies the symbol table entry.

EXIT:		Returns the type graph associated with the entry.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
SymTable::SymSearch(
	SymKey	OldKey
	)
{
	Dict_Status	Status;

    if (gfCaseSensitive)
    {
	    Status = Dict_Find(&OldKey);
	    if (Status == SUCCESS)
		    {
    		return ((SymEntry * )Dict_Curr_Item())->GetTypeGraph();
		    }
	    else
		    {						
			return NULL;
		    }
    }
    else
    {
        SymEntry TempEntry(OldKey);
        CaselessEntry OldEntry(&TempEntry);
        CaselessEntry * pFound = caseless_list.Find(&OldEntry);
        if (pFound)
        {
            return pFound->pSymEntry->GetTypeGraph();
        }
        else
        {
			return NULL;
        }
    }
}

/**********************************************************************\

NAME:		SymTable::EnterScope

SYNOPSIS:	Transition from current scope to inner scope.

ENTRY:		key	- identifies the symbol table entry.

EXIT:		ContainedDict	- returns the inner scope.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

STATUS_T
SymTable::EnterScope(
	SymKey		key,
	SymTable **	ContainedDict
	)
{
	SymEntry 	ContainerNode( key );
	Dict_Status	Status;

	if (ContainedDict == (SymTable **)0)
		{
		return I_ERR_NULL_OUT_PARAM;
		}

	Status = Dict_Find(&ContainerNode);
	if (Status != SUCCESS)
		{
		return I_ERR_SYMBOL_NOT_FOUND;
		}
	else if (((SymEntry * )Dict_Curr_Item())->GetNextScope() == (SymTable *)0)
		{
		return I_ERR_NO_NEXT_SCOPE;
		}
	else
		{
		* ContainedDict = ((SymEntry * )Dict_Curr_Item())->GetNextScope();
		(*ContainedDict)->pPrevScope = this;
		return STATUS_OK;
		}
}

/**********************************************************************\

NAME:		SymTable::ExitScope

SYNOPSIS:	Transition from current scope to outer scope.

ENTRY:

EXIT:		ContainerDict	- returns the outer scope.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

STATUS_T
SymTable::ExitScope(
	SymTable **	ContainerDict
	)
{
	if (ContainerDict == (SymTable **)0)
		{
		return I_ERR_NULL_OUT_PARAM;
		}
	else if (pPrevScope == (SymTable *)0)
		{
		return I_ERR_NO_PREV_SCOPE;
		}
	else
		{
		* ContainerDict = pPrevScope;
		pPrevScope = (SymTable *)0;
		return STATUS_OK;
		}
}

/**********************************************************************\

NAME:		SymTable::DiscardScope

SYNOPSIS:	Discard all entries in the current scope (if no fwds).

ENTRY:

EXIT:		.

NOTES:

HISTORY:

\**********************************************************************/

void
SymTable::DiscardScope()
{
	// do nothing if there are forwards
	if ( fHasFwds )
		return;

	SymEntry	*	pCurrent;

	// delete all the SymEntry's in this scope
	while ( ( pCurrent = (SymEntry *) Dict_Delete_One() ) != 0 )
		{
		delete pCurrent;
		}

}

CaselessEntry::CaselessEntry(SymEntry * pItem)
{
    pSymEntry = pItem;
    // compute the hash value
    hash = 0;
    char ch;
    unsigned u = 0;
    while (0 != (ch = pSymEntry->name[u++]))
    {
        hash += ch | 32; // makes sure the hash value is case insensitive
    };
}

int CaselessEntry::Compare(CaselessEntry * pEntry2)
{
    int rval = hash - pEntry2->hash;
    if (0 == rval)
    {
        rval = CurrentCharSet.CompareDBCSString(pSymEntry->name, pEntry2->pSymEntry->name, 1); // ignore case
        if (0 == rval)
        {
            rval = pSymEntry->kind - pEntry2->pSymEntry->kind;
        }
    }
    return rval;
}

CaselessEntry * CaselessList::Add(CaselessEntry * pEl)
{
    CaselessListElement * pNew = new CaselessListElement(pEl);
    pNew->pNext = pHead;
    pHead = pNew;
    return pEl;
}

CaselessEntry * CaselessList::Find(CaselessEntry * pEntry)
{
    CaselessListElement * pThis = pHead;
    while (pThis && 0 != pThis->pEntry->Compare(pEntry))
    {
        pThis = pThis->pNext;
    }
    if (pThis != NULL)
        return pThis->pEntry;
    else
        return NULL;
}

CaselessEntry * CaselessList::Delete(CaselessEntry * pEntry)
{
    CaselessListElement ** ppThis = &pHead;
    while (*ppThis)
    {
        if (0 == (*ppThis)->pEntry->Compare(pEntry))
        {
            CaselessListElement * pFound = *ppThis;
            *ppThis = pFound->pNext;
            CaselessEntry * pReturn = pFound->pEntry;
            delete pFound;
            return pReturn;
        }
        ppThis = &((*ppThis)->pNext);
    }
    return NULL;
}

CaselessList::~CaselessList()
{
    CaselessListElement * pNext;
    while(pHead);
    {
        pNext = pHead->pNext;
        delete pHead;
        pHead = pNext;
    }
}

CaselessEntry * CaselessList::DeleteExact(CaselessEntry * pEntry)
{
    CaselessListElement ** ppThis = &pHead;
    while (*ppThis)
    {
        if ((*ppThis)->pEntry->hash == pEntry->hash)
        {
            if (0 == strcmp((*ppThis)->pEntry->pSymEntry->name, pEntry->pSymEntry->name))
            {
                if ((*ppThis)->pEntry->pSymEntry->kind == pEntry->pSymEntry->kind)
                {
                    CaselessListElement * pFound = *ppThis;
                    *ppThis = pFound->pNext;
                    CaselessEntry * pReturn = pFound->pEntry;
                    delete pFound;
                    return pReturn;
                }
            }
        }
        ppThis = &((*ppThis)->pNext);
    }
    return NULL;
}

SSIZE_T
CaselessDictionary::Compare(void * p1, void *p2)
{
    return ((CaselessEntry *)p1)->Compare((CaselessEntry *) p2);
}

/**********************************************************************\

NAME:		GlobalSymTable::SymInsert

SYNOPSIS:	Inserts a symbol into the symbol table.

ENTRY:		NewKey	- identifies the symbol table entry.
			pNext	- points to the next scope.
			pNode	- points to the type graph.

EXIT:

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
GlobalSymTable::SymInsert(
	SymKey		NewKey,
	SymTable *	pNext,
	named_node *	pNode
	)
{
	SymEntry *	NewSymbol;
	Dict_Status	Status;

	NewSymbol = new SymEntry(NewKey, pNext, pNode);

    CaselessEntry * NewEntry = new CaselessEntry(NewSymbol);

    if (!gfCaseSensitive)
    {
        Status = pCaselessDictionary->Dict_Find(NewEntry);

        if (SUCCESS == Status)
        {
            // it's allready entered into the caseless table
            // and we're in case insensitive mode so we
            // should fail here (duplicate identifier)
            delete NewSymbol;
            delete NewEntry;
            return NULL;
        }
    }

    Status = Dict_Insert(NewSymbol);
	if (Status == SUCCESS)
    {
        Status = pCaselessDictionary->Dict_Insert(NewEntry);
        if (SUCCESS != Status)
        {
            // We must be in case sensitive mode otherwise the
            // Dict_Find above would have succeeded and we would
            // have already returned failure to the caller.
            // Therefore, it doesn't really matter that this name
            // won't have an entry in the caseless table.  Just
            // clean up the new entry and move on.
            delete NewEntry;

        }
		return pNode;
    }

	delete NewSymbol;
    delete NewEntry;
	return (named_node *)0;
}

/**********************************************************************\

NAME:		GlobalSymTable::SymDelete

SYNOPSIS:	Deletes a symbol from the symbol table.

ENTRY:		OldKey	- identifies the symbol table entry.

EXIT:		Returns the type graph associated with the entry.

NOTES:      This operation could potentially mess up the case insensitive
            table because there is no guarantee that the symbol removed
            from the case insensitive table will match the symbol removed
            from the case sensitive table.  However, since MIDL always
            re-adds the symbol to the symbol table immediately after
            deleting it (deletions only serve to replace forward references)
            it will effectively correct any inconsistencies between the
            two tables when it re-adds the symbol.

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
GlobalSymTable::SymDelete(
	SymKey	OldKey
	)
{
    SymEntry	TempEntry( OldKey );

    CaselessEntry * OldEntry = new CaselessEntry(&TempEntry);
    SymEntry * OldSymbol;

    Dict_Status	Status;

    Status = pCaselessDictionary->Dict_Delete((void **)&OldEntry);

    if (!gfCaseSensitive && SUCCESS == Status)
    {
        // make sure we delete the same symbol from the case
        // sensitive table
        OldSymbol = OldEntry->pSymEntry;
    }
    else
    {
        OldSymbol = &TempEntry;
    }

	named_node *	pNode;

    Status = Dict_Delete((void ** )&OldSymbol);

	if (Status == SUCCESS)
		{
		pNode = OldSymbol->GetTypeGraph();
		delete OldSymbol;
#ifdef gajdebug3
			printf("\t\t--- deleting name from symbol table: %d - %s\n",
					OldKey.GetKind(), OldKey.GetString());
#endif
		return pNode;
		}
	else
		{
		return (named_node *)0;
		}
}

/**********************************************************************\

NAME:		GlobalSymTable::SymSearch

SYNOPSIS:	Searches the symbol table for a symbol.

ENTRY:		OldKey	- identifies the symbol table entry.

EXIT:		Returns the type graph associated with the entry.

NOTES:

HISTORY:
	Donnali		08-06-1991		Move to LM/90 UI Coding Style

\**********************************************************************/

named_node *
GlobalSymTable::SymSearch(
	SymKey	OldKey
	)
{
	Dict_Status	Status;

    // DBCSDefaultToCaseSensitive() is introduced to handle the
    // equivalence of full width and half width characters in
    // far east languages; specifically Japanese
    if (gfCaseSensitive || CurrentCharSet.DBCSDefaultToCaseSensitive())
    {
	    Status = Dict_Find(&OldKey);
	    if (Status == SUCCESS)
		    {
    		return ((SymEntry * )Dict_Curr_Item())->GetTypeGraph();
		    }
	    else
		    {
			return NULL;
		    }
        }
        else
    {
        SymEntry TempEntry(OldKey);
        CaselessEntry OldEntry(&TempEntry);
        Status = pCaselessDictionary->Dict_Find(&OldEntry);
        if (Status == SUCCESS)
        {
            return ((CaselessEntry *)(pCaselessDictionary->Dict_Curr_Item()))->pSymEntry->GetTypeGraph();
        }
        else
        {
			return NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\inc\ndr64tkn.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    ndr64tkn.h

Abstract :

    This file defines all the tokens for NDR64
    
Author :

    Mike Zoran  mzoran   May 2000.

Revision History :

  ---------------------------------------------------------------------*/

#ifndef __NDR64TKN_H__
#define __NDR64TKN_H__

// Define the 64bit tokens from the token table.

#define NDR64_BEGIN_TABLE \
typedef enum { 

#define NDR64_TABLE_END \
} NDR64_FORMAT_CHARACTER;

#define NDR64_ZERO_ENTRY \
FC64_ZERO = 0x0

#define NDR64_TABLE_ENTRY( number, tokenname, marshal, embeddedmarshall, unmarshall, embeddedunmarshal, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
, tokenname = number

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, simpletypebuffersize, simpletypememorysize ) \
, tokenname = number

#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) \
, tokenname = number

#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number )

#include "tokntbl.h"

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_END
#undef NDR64_ZERO_ENTRY
#undef NDR64_TABLE_ENTRY
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY_NOSYM

#endif // __NDR64TKN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\inc\midl64types.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1999-2000 Microsoft Corporation

 Module Name:
    
    midl64types.cxx

 Abstract:

    Definitions for the ndr64 transfer syntax.

 Notes:


 History:

 ----------------------------------------------------------------------------*/

#include "ndr64tkn.h"
class FormatFragment;
class CompositeFormatFragment;
class RootFormatFragment;
class MIDL_NDR64_POINTER_FORMAT;
class MIDL_NDR64_CORRELATION_DESCRIPTOR;
class MIDL_NDR64_TRANSMIT_AS_FORMAT;


extern const char *pNDR64FormatCharNames[];
extern const char *pExprFormatCharNames[];
extern const char *pExprOpFormatCharNames[];

                                        
#define NDR64_FORMATINFO_NAME              "NDR64_MIDL_FORMATINFO"
#define NDR64_FORMATINFO_STRUCT_NAME       "__MIDL_NDR64FORMATINFO"


void OutputParamFlagDescription( CCB *pCCB, const NDR64_PARAM_FLAGS &flags );
void OutputFlagDescriptions(
        ISTREAM     *stream, 
        const void  *pvFlags, 
        int          bytes, 
        const PNAME *description);

#define ASSERT_STACKABLE( type ) C_ASSERT( (sizeof(type) % sizeof(PNDR64_FORMAT)) == 0 );

//+--------------------------------------------------------------------------
//
//  Class:      GenNdr64Format
//
//  Synopsis:   The central object to manage generation of Ndr64 format
//              strings
//
//---------------------------------------------------------------------------

class GenNdr64Format
{
private:

    CCB                       *pCCB;
    RootFormatFragment        *pRoot;
    CompositeFormatFragment   *pCurrent;
    CG_VISITOR                *pVisitor;

protected:

    void GenRangeFormat( CG_BASETYPE *pClass );

    // Pointer layout functions
    FormatFragment *GenSimplePtrLayout(CG_STRUCT *pStruct,
                                       bool bGenHeaderFooter = true,
                                       ulong *pPtrInstances  = NULL );

    FormatFragment *GenSimplePtrLayout( CG_NDR *pArray,
                                        bool bGenHeaderFooter = true,
                                        ulong MemoryOffset = 0);

    FormatFragment *GenCmplxPtrLayout( CG_COMPLEX_STRUCT *pStruct );
    

    // Structure generation helpers
    FormatFragment *GenerateStructureMemberLayout( CG_STRUCT *pStruct, bool bIsDebug );  
    void GenerateSimpleStructure( CG_STRUCT *pStruct,
                                  bool IsConformant );
    void GenerateComplexStruct( CG_COMPLEX_STRUCT *pStruct,
                                                bool IsConformant );

    void GenExtendedProcInfo( CompositeFormatFragment *composite );

    void GenerateUnionArmSelector( 
                    CG_UNION                *pUnion, 
                    CompositeFormatFragment *list );

    // Array/Pointer helper functions
    FormatFragment *GenerateArrayElementInfo( CG_CLASS *pChild );
    void GenerateFixBogusArrayCommon( CG_FIXED_ARRAY *pArray, 
                                      bool IsFullBogus );

    MIDL_NDR64_POINTER_FORMAT* GenQualifiedPtrHdr( CG_QUALIFIED_POINTER *pPointer );
    MIDL_NDR64_POINTER_FORMAT* GenQualifiedArrayPtr( CG_ARRAY *pArray );    
    
    void GenerateNonStringQualifiedPtr( CG_QUALIFIED_POINTER *pPointer );
    FormatFragment * GenerateNonStringQualifiedArrayLayout( CG_NDR *pNdr,
                                                            CompositeFormatFragment *pComp );
    void GenerateNonStringQualifiedArray( CG_ARRAY *pArray );

    // String helpers
        
    void InitStringHeader( CG_NDR *pString, NDR64_STRING_HEADER_FORMAT *pHeader,
                           bool bIsConformant, bool IsSized );

    void GenerateStringArray( CG_ARRAY *pArray, bool bIsSized );

    FormatFragment*
    GenerateCorrelationDescriptor(expr_node               *pSizeExpr );

    void GenInterfacePointer( CG_POINTER *pPtr, BOOL IsConstantIID );

    void GenXmitOrRepAsFormat(
            CG_TYPEDEF                     *pXmitNode,
            MIDL_NDR64_TRANSMIT_AS_FORMAT  *format,
            char                           *pPresentedTypeName,
            node_skl                       *pPresentedType,
            node_skl                       *pTransmittedType );

    NDR64_ALIGNMENT ConvertAlignment( unsigned short Alignment )
    {
        MIDL_ASSERT( Alignment <= 0xFF && Alignment > 0);
        return (NDR64_ALIGNMENT)( Alignment - 1);
    }

public:

    static GenNdr64Format * CreateInstance( CCB *pCCB );
    FormatInfoRef Generate( CG_CLASS *pClass ); 
    void Output( );

    FormatInfoRef ContinueGeneration( 
                    CG_CLASS *pClass, 
                    CompositeFormatFragment *pComposite = NULL );
    FormatInfoRef ContinueGenerationInRoot( CG_CLASS *pClass );

    CCB * GetCCB()
        {
        return pCCB;
        }

    RootFormatFragment      * GetRoot()             { return pRoot; }
    CompositeFormatFragment * GetCurrent()          { return pCurrent; }
    CompositeFormatFragment * SetCurrent( CompositeFormatFragment *pNew )       
        { 
        CompositeFormatFragment *pBak = GetCurrent();
        pCurrent = pNew;
        return pBak;
        }
  
    void Visit( CG_CLASS *pClass);
    void Visit( CG_BASETYPE *pClass );
    void Visit( CG_ENCAPSULATED_STRUCT *pUnion );
    void Visit( CG_PARAM *pParam );
    void Visit( CG_PROC *pProc );
    void Visit( CG_UNION *pUnion );
    void Visit( CG_INTERFACE *pInterface );
    void Visit( CG_CONTEXT_HANDLE *pHandle );
    void Visit( CG_GENERIC_HANDLE *pHandle );
    void Visit( CG_TRANSMIT_AS *pTransmitAs );
    void Visit( CG_REPRESENT_AS *pRepresentAs );
    void Visit( CG_USER_MARSHAL *pUserMarshal );
    void Visit( CG_PIPE *pPipe );
    void Visit( CG_STRING_POINTER *pPointer );

    // Pointer types
    void Visit( CG_POINTER *pPointer );
    void Visit( CG_INTERFACE_POINTER *pPtr )       { GenInterfacePointer(pPtr, TRUE); }
    void Visit( CG_IIDIS_INTERFACE_POINTER *pPtr ) { GenInterfacePointer(pPtr, FALSE); }
    
    void Visit( CG_QUALIFIED_POINTER *pPointer )   { pPointer; MIDL_ASSERT(0); }

    void Visit( CG_SIZE_POINTER *pPointer )        { GenerateNonStringQualifiedPtr( pPointer ); }
    void Visit( CG_LENGTH_POINTER *pPointer )      { GenerateNonStringQualifiedPtr( pPointer ); }
    void Visit( CG_SIZE_LENGTH_POINTER *pPointer ) { GenerateNonStringQualifiedPtr( pPointer ); } 

    // Not supported in 64bit transfer syntax
    void Visit( CG_BYTE_COUNT_POINTER *pPointer ) { pPointer; MIDL_ASSERT(0); }

    // Structure types
    void Visit( CG_STRUCT *pStruct )            { GenerateSimpleStructure( pStruct, false ); }
    void Visit( CG_CONFORMANT_STRUCT *pStruct ) { GenerateSimpleStructure( pStruct, true ); }
    void Visit( CG_COMPLEX_STRUCT *pStruct ) 
        { GenerateComplexStruct( pStruct, false ); } 
    void Visit( CG_CONFORMANT_FULL_COMPLEX_STRUCT *pStruct )
        { GenerateComplexStruct( pStruct, true ); }
    void Visit( CG_CONFORMANT_FORCED_COMPLEX_STRUCT *pStruct )
        { GenerateComplexStruct( pStruct, true ); }

    // Array types    
    void Visit( CG_FIXED_ARRAY *pArray );    
    void Visit( CG_FULL_COMPLEX_FIXED_ARRAY *pArray )
        { GenerateFixBogusArrayCommon( pArray, true ); }
    void Visit( CG_FORCED_COMPLEX_FIXED_ARRAY *pArray )
        { GenerateFixBogusArrayCommon( pArray, false ); }

    void Visit( CG_CONFORMANT_ARRAY *pArray )         { GenerateNonStringQualifiedArray( pArray ); }
    void Visit( CG_VARYING_ARRAY *pArray )            { GenerateNonStringQualifiedArray( pArray ); }
    void Visit( CG_CONFORMANT_VARYING_ARRAY *pArray ) { GenerateNonStringQualifiedArray( pArray ); }

    // String types
    void Visit( CG_STRING_ARRAY *pArray )             { GenerateStringArray( pArray, false ); }
    void Visit( CG_CONFORMANT_STRING_ARRAY *pArray )  { GenerateStringArray( pArray, true );  }
};

//+--------------------------------------------------------------------------
//
//  Class:      FormatFragment
//
//  Synopsis:   Contains a fragment of what will become the format string
//              and has functions to compare and output fragments.
//
//  Notes:      Generally derived types are responsible for setting pClass 
//              field.  The FormatInfo class takes care of the Root, Parent,
//              RefID and the Next field.
//
//---------------------------------------------------------------------------

class FormatFragment
{
protected:

    CompositeFormatFragment *   Parent;             // Parent composite
    FormatFragment          *   Next;               // Next fragment
    FormatFragment          *   Prev;               // Previous fragment
    FormatInfoRef               RefID;              // ID of this fragment
    CG_CLASS                *   pClass;             // CG node for this frag
    FormatFragment          *   pNextOptimized;     // Optimization chain
    FormatFragment          *   pPrevOptimized;

    void Init( CG_CLASS *pNewClass )
        {
        Parent         = NULL;
        Next           = NULL; 
        Prev           = NULL;
        RefID          = 0;
        pClass         = pNewClass;
        pNextOptimized = NULL;
        pPrevOptimized = NULL;
        }

public: 

    friend CompositeFormatFragment;
    friend RootFormatFragment;

    FormatFragment( const FormatFragment & Node ) 
        {
        // When copying, 0 out the Next and ID.
        Init( Node.pClass );
        }

    FormatFragment() 
        { 
        Init(NULL);
        }

    FormatFragment( CG_CLASS *pNewClass ) 
        {
        Init( pNewClass );
        }

    virtual bool IsEqualTo( FormatFragment *frag ) = 0;

    virtual void OutputFragmentType(CCB *pCCB) = 0;
    virtual void OutputFragmentData(CCB *pCCB) = 0;

    virtual const char * GetTypeName() = 0;

    FormatInfoRef GetRefID()
        {
        return RefID;
        }

    CG_CLASS * GetCGNode()
        {
        return pClass;
        }

    void SetParent( CompositeFormatFragment *parent )
        {
        Parent = parent;
        }

    CompositeFormatFragment * GetParent()
        {
        return Parent;
        }

    bool WasOptimizedOut() 
        {
        return NULL != pPrevOptimized;
        }    

    void OutputFormatChar( CCB *pCCB, NDR64_FORMAT_CHAR format, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteNumber("0x%x", format);
        if (!nocomma) stream->Write(",");
        stream->Write("    /* ");
        stream->Write(pNDR64FormatCharNames[format]);
        stream->Write(" */");
    }

    void OutputExprFormatChar( CCB *pCCB, NDR64_FORMAT_CHAR format, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteNumber("0x%x", format);
        if (!nocomma) stream->Write(",");
        stream->Write("    /* ");
        stream->Write(pExprFormatCharNames[format]);
        stream->Write(" */");       
    }

    void OutputExprOpFormatChar( CCB *pCCB, NDR64_FORMAT_CHAR format, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteNumber("0x%x", format);
        if (!nocomma) stream->Write(",");
        stream->Write("    /* ");
        stream->Write(pExprOpFormatCharNames[format]);
        stream->Write(" */");       
    }
        
        
    void OutputFormatInfoRef( CCB *pCCB, FormatInfoRef id, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        if ( 0 == id )
            stream->Write( "0" );
        else
            stream->WriteFormat( "&__midl_frag%d", (ulong) (size_t) id );
        if (!nocomma) stream->Write(",");
    }

    void Output( CCB *pCCB, NDR64_UINT8 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_UINT8) %u /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_UINT16 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_UINT16) %u /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_UINT32 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_UINT32) %u /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_UINT64 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_UINT64) %I64u /* 0x%I64x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_INT8 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_INT8) %d /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_INT16 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_INT16) %d /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_INT32 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_INT32) %d /* 0x%x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, NDR64_INT64 n, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("(NDR64_INT64) %I64d /* 0x%I64x */", n, n);
        if (!nocomma) stream->Write(",");
    }
    void Output( CCB *pCCB, StackOffsets &offsets, bool nocomma = false )
    {
        // used only in MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION 

        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat("%d /* 0x%x */", offsets.ia64, offsets.ia64 );
        if (!nocomma) stream->Write(",");
        stream->Write("   /* Stack offset */");
    }

    void OutputMultiType( 
                CCB *           pCCB, 
                const char *    type, 
                NDR64_UINT32    a, 
                char *          pComment,
                bool            nocomma = false)
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( type );
        stream->WriteFormat("%d /* 0x%x */ ", a, a );
        if (!nocomma) stream->Write(", ");
        stream->WriteFormat( pComment );
    }
    void OutputBool( CCB *pCCB, bool val, bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->NewLine();
        stream->WriteFormat( "%d", val ? 1 : 0 );
        if (!nocomma) stream->Write(",");
    }
    void OutputGuid( CCB *pCCB, const GUID &guid, bool nocomma = false )
    {
        // REVIEW: It would be nice to print the name of the interface
        //         (e.g. IDispatch).  That does require linking to ole32
        //         though.
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( "{" );
        stream->IndentInc();
        stream->NewLine();
        stream->WriteFormat( "0x%08x,", guid.Data1 );
        stream->NewLine();
        stream->WriteFormat( "0x%04x,", guid.Data2 );
        stream->NewLine();
        stream->WriteFormat( "0x%04x,", guid.Data3 );
        stream->WriteOnNewLine( "{" );
        for (int i = 0; i < 8; i++)
        {
            if (0 != i) stream->Write( ", " );
            stream->WriteFormat( "0x%02x", guid.Data4[i] );
        }
        stream->Write( "}" );
        stream->IndentDec();
        stream->WriteOnNewLine( "}" );
        if (!nocomma) stream->Write(",");
    }

    void OutputDescription( ISTREAM *stream );

    void OutputStructDataStart( 
                    CCB *pCCB, 
                    const char *comment1 = NULL,
                    const char *comment2 = NULL)
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( "{ " );
        OutputDescription( stream );
        if (comment1)
            {
            stream->Write("      /* ");
            stream->Write( comment1 );
            if (comment2)
                {
                stream->Write(" ");
                stream->Write( comment2 );
                }
            stream->Write( " */" );
            }
        stream->IndentInc();
    }
    void OutputStructDataEnd( CCB *pCCB )
    {
        ISTREAM *stream = pCCB->GetStream();
        stream->IndentDec();
        stream->WriteOnNewLine("}");
    }
    NDR64_ALIGNMENT ConvertAlignment( unsigned short Alignment )
    {
        MIDL_ASSERT( Alignment <= 0xFF && Alignment > 0);
        return (NDR64_ALIGNMENT)( Alignment - 1);
    }
};

//+--------------------------------------------------------------------------
//
//  Class:      CompositeFormatFragment
//
//  Synopsis:   List of fragments and is also a fragment. 
//
//---------------------------------------------------------------------------

class CompositeFormatFragment : public FormatFragment
{
protected:

    FormatFragment *            pHead;
    FormatFragment *            pTail;
    FormatInfoRef               NextRefID;
    const char *                pTypeName;

    void Init( )
    {
        pHead     = NULL;
        pTail     = NULL;
        pTypeName = NULL;
        NextRefID = (FormatInfoRef) 1; // 0 is reserved for an invalid id value
    }

public:

    CompositeFormatFragment( ) : FormatFragment() { Init(); }
    CompositeFormatFragment( CG_CLASS *pClass, const char *pNewTypeName = NULL ) : 
        FormatFragment( pClass )
        { Init(); pTypeName = pNewTypeName; }
    
    virtual bool IsEqualTo( FormatFragment *frag );

    //
    // Container management
    //

    FormatInfoRef   AddFragment( FormatFragment *frag );
    FormatFragment *LookupFragment( CG_CLASS *pClass );

    FormatInfoRef   LookupFragmentID( CG_CLASS *pClass )
                        {
                        FormatFragment *frag = LookupFragment(pClass );
                        return frag ? frag->GetRefID() : INVALID_FRAGMENT_ID;
                        }


    bool            HasClassFragment( CG_CLASS *pClass )
                        {
                        return NULL != LookupFragment( pClass );
                        }

    FormatFragment * GetFirstFragment()
        {
        return pHead;
        }

    // Printing functions
    virtual void OutputFragmentType( CCB *pCCB );
    virtual void OutputFragmentData( CCB *pCCB );
    virtual const char * GetTypeName() { return pTypeName; }

    // Optimization.
    FormatInfoRef OptimizeFragment( FormatFragment *frag );


};



//+--------------------------------------------------------------------------
//
//  Class:      RootFormatFragment
//
//  Synopsis:   Manage a tree of format fragments. Should only be 
//              created for the root.
//
//---------------------------------------------------------------------------

class RootFormatFragment : public CompositeFormatFragment
{
public:

    RootFormatFragment( ) : CompositeFormatFragment( NULL, NDR64_FORMATINFO_STRUCT_NAME )
        {
        }

    void Output( CCB *pCCB );
};



//+--------------------------------------------------------------------------
//
//  Class:      SimpleFormatFragment
//
//  Synopsis:   An intermediary class that brings together a format fragment
//              and some type.  It's also a useful place to hang stuff like
//              generate type handling, etc.
//
//---------------------------------------------------------------------------

template< class T >
class SimpleFormatFragment : public FormatFragment, 
                             public T
{
private:

    void Init() 
        {
        memset( (T*)this, 0, sizeof(T) );
        }

public:

    SimpleFormatFragment( ) : FormatFragment() { Init(); }
    SimpleFormatFragment( CG_CLASS *pClass ) : FormatFragment( pClass ) { Init(); }

    virtual bool IsEqualTo( FormatFragment *frag )
        {
        // Make sure that we're comparing structures of the same type.
        // This should have been checked by the fragment optimizer.
        MIDL_ASSERT( NULL != dynamic_cast<SimpleFormatFragment *> (frag) );
        MIDL_ASSERT( NULL != dynamic_cast<T *>
                           ( dynamic_cast<SimpleFormatFragment *> (frag) ) );

        // Can't compare structures for equality...
//        return *(T*)(SimpleFormatFragment*)frag == *(T*)this ; 

        return (0 == memcmp(
                        (T*) (SimpleFormatFragment*) frag, 
                        (T*) this, 
                        sizeof(T) ) );
        }

    virtual void OutputFragmentType( CCB *pCCB )
        {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( GetTypeName() );
        }

    virtual const char * GetTypeName()
        {
        return typeid(T).name();
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_PROC_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr proc type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_PROC_FORMAT : public SimpleFormatFragment<NDR64_PROC_FORMAT>
{
public:

    // Processor-specific stack sizes.  The field in NDR64_PROC_FORMAT is just
    // a generic placeholder as far as midl is concerned.

    long    ia64StackSize;

    // These fields override the corresponding fields in the NDR_64_PROC_FORMAT
    // structure.  That structure just has integral types to make initializing
    // the structure easier on the C compiler (not to mention more readable)
    // to a human....

    NDR64_PROC_FLAGS    Flags;
    NDR64_RPC_FLAGS     RpcFlags;

public:

    MIDL_NDR64_PROC_FORMAT( CG_PROC *pProc ) :
        SimpleFormatFragment<NDR64_PROC_FORMAT>( pProc )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( 
                pCCB, 
                "procedure", 
                ((CG_PROC *) pClass)->GetSymName() );
        Output( pCCB, * (NDR64_UINT32 *) &Flags );
        OutputProcFlagDescription( pCCB );
        OutputMultiType( 
                pCCB, 
                "(NDR64_UINT32) ", 
                ia64StackSize,
                " /* Stack size */" );
        Output( pCCB, ConstantClientBufferSize );
        Output( pCCB, ConstantServerBufferSize );
        Output( pCCB, * (NDR64_UINT16 *) &RpcFlags );
        Output( pCCB, FloatDoubleMask );
        Output( pCCB, NumberOfParams );
        Output( pCCB, ExtensionSize, true );
        OutputStructDataEnd( pCCB );
        }

    void OutputProcFlagDescription( CCB *pCCB )
        {
        static const PNAME flag_descrip[32] = 
                    {
                    NULL,       // HandleType1
                    NULL,       // HandleType2
                    NULL,       // HandleType3
                    NULL,       // ProcType1
                    NULL,       // ProcType2
                    NULL,       // ProcType3
                    "IsIntrepreted",    
                    NULL,       // Extra intrepreted bit
                    "[object]",
                    "[async]",
                    "[encode]",
                    "[decode]",
                    "[ptr]",
                    "[enable_allocate]",
                    "pipe",
                    "[comm_status] and/or [fault_status]",
                    NULL,       // Reserved for DCOM
                    "ServerMustSize",
                    "ClientMustSize",
                    "HasReturn",
                    "HasComplexReturn",
                    "ServerCorrelation",
                    "ClientCorrelation",
                    "[notify]",
                    "HasExtensions",
                    NULL,       // Reserved
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    };

        static const PNAME handle_type[8] = 
                    {    
                    "explicit handle",
                    "generic handle",
                    "primitive handle",
                    "auto handle",
                    "callback handle",
                    "no handle",
                    NULL,       // Reserved
                    NULL        // Reserved
                    };


        ISTREAM     *stream = pCCB->GetStream();

        MIDL_ASSERT( NULL != handle_type[Flags.HandleType] );
        stream->WriteFormat( "    /* %s */ ", handle_type[Flags.HandleType]) ;

        OutputFlagDescriptions( stream, &Flags, sizeof(Flags), flag_descrip );
        }
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION
//
//  Synopsis:   MIDL abstraction of the ndr proc extenstion containing the
//              notify index and the explicit handle description
//
//---------------------------------------------------------------------------

class MIDL_NDR64_BIND_AND_NOTIFY_EXTENSION 
      : public SimpleFormatFragment<NDR64_BIND_AND_NOTIFY_EXTENSION>
{
public:

    NDR64_BINDINGS  Binding;
    StackOffsets    StackOffsets;

public:

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );

        OutputStructDataStart( pCCB, NULL );
        OutputFormatChar( pCCB, Binding.Context.HandleType );
        Output( pCCB, Binding.Context.Flags );
        Output( pCCB, StackOffsets );
        Output( pCCB, Binding.Context.RoutineIndex );
        Output( pCCB, Binding.Context.Ordinal, true );
        OutputStructDataEnd( pCCB );

        pCCB->GetStream()->Write(",");
        Output( pCCB, NotifyIndex, true );
        pCCB->GetStream()->Write("      /* Notify index */");

        OutputStructDataEnd( pCCB );
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_PARAM_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr param type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_PARAM_FORMAT 
        : public SimpleFormatFragment<NDR64_PARAM_FORMAT>
{
public:

    // Processor-specific stack offsets.

    StackOffsets    StackOffset;

public:

    MIDL_NDR64_PARAM_FORMAT( CG_PARAM *pParam ) :
        SimpleFormatFragment<NDR64_PARAM_FORMAT>( pParam )
        {
        }

    void OutputFlags( CCB *pCCB ) 
        {
        MIDL_ASSERT( 0 == Attributes.Reserved );

        OutputStructDataStart( pCCB );
        
        OutputBool( pCCB, Attributes.MustSize );
        OutputBool( pCCB, Attributes.MustFree );
        OutputBool( pCCB, Attributes.IsPipe );
        OutputBool( pCCB, Attributes.IsIn );
        OutputBool( pCCB, Attributes.IsOut );
        OutputBool( pCCB, Attributes.IsReturn );
        OutputBool( pCCB, Attributes.IsBasetype );
        OutputBool( pCCB, Attributes.IsByValue );
        OutputBool( pCCB, Attributes.IsSimpleRef );
        OutputBool( pCCB, Attributes.IsDontCallFreeInst );
        OutputBool( pCCB, Attributes.SaveForAsyncFinish );
        OutputBool( pCCB, Attributes.IsPartialIgnore );
        OutputBool( pCCB, Attributes.IsForceAllocate ); 
        Output( pCCB, Attributes.Reserved );
        OutputBool( pCCB, Attributes.UseCache, true );
        
        OutputStructDataEnd( pCCB );
        pCCB->GetStream()->Write( ',' );
        
        OutputParamFlagDescription( pCCB, Attributes );
        }        

    void OutputFragmentData( CCB *pCCB )
    {
        MIDL_ASSERT( 0 == Reserved );

        OutputStructDataStart( 
                pCCB,
                "parameter",
                ((CG_PARAM *) pClass)->GetSymName() );

        OutputFormatInfoRef( pCCB, Type );
        OutputFlags( pCCB );
        Output( pCCB, Reserved );
        Output( pCCB, StackOffset );

        OutputStructDataEnd( pCCB );
    }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_FORMAT_SIMPLE_TYPE
//
//  Synopsis:   MIDL abstraction of NDR64_FORMAT_CHAR
//
//---------------------------------------------------------------------------
extern char * _SimpleTypeName[];

template <class T>
class MIDL_NDR64_FORMAT_SIMPLE_TYPE : public FormatFragment
{

public:

    T  Data;
    int Index;

    MIDL_NDR64_FORMAT_SIMPLE_TYPE(){
        int size = sizeof(T);
        for (Index = 0; size; size = size >>= 1 ) Index++; 
        };
    ~MIDL_NDR64_FORMAT_SIMPLE_TYPE(){};

    MIDL_NDR64_FORMAT_SIMPLE_TYPE( CG_CLASS *pClass, T NewFormatCode ) :
        FormatFragment( pClass ),
        Data( NewFormatCode )
        {
        int size = sizeof(T);
        for (Index = 0; size; size >>= 1 ) Index++; 
        
        }
    MIDL_NDR64_FORMAT_SIMPLE_TYPE( T NewFormatCode ) :
        FormatFragment(),
        Data( NewFormatCode )
        {
        int size = sizeof(T);
        for (Index = 0; size; size >>= 1 ) Index++; 
        }

    virtual void OutputFragmentType( CCB *pCCB )
        {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine( _SimpleTypeName[Index] );
        }

    virtual void OutputFragmentData(CCB *pCCB)
        {
        Output( pCCB, Data, true );
        }

    virtual bool IsEqualTo( FormatFragment *frag )
        {
        MIDL_ASSERT( typeid(*frag) == typeid( *this) );
        return Data == ((MIDL_NDR64_FORMAT_SIMPLE_TYPE*)frag)->Data;
        }

    virtual const char * GetTypeName()
        {
        return _SimpleTypeName[Index];
        }

};

class MIDL_NDR_FORMAT_UINT32 : public MIDL_NDR64_FORMAT_SIMPLE_TYPE<NDR64_UINT32>
{
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_FORMAT_CHAR
//
//  Synopsis:   MIDL abstraction of NDR64_FORMAT_CHAR
//
//---------------------------------------------------------------------------

class MIDL_NDR64_FORMAT_CHAR : public FormatFragment
{

public:

    NDR64_FORMAT_CHAR  FormatCode;

    MIDL_NDR64_FORMAT_CHAR( CG_CLASS *pClass, NDR64_FORMAT_CHAR NewFormatCode ) :
        FormatFragment( pClass ),
        FormatCode( NewFormatCode )
        {
        }
    MIDL_NDR64_FORMAT_CHAR( NDR64_FORMAT_CHAR NewFormatCode ) :
        FormatFragment(),
        FormatCode( NewFormatCode )
        {
        }
    MIDL_NDR64_FORMAT_CHAR( CG_BASETYPE *pBase ) :
        FormatFragment( pBase ),
        FormatCode( (NDR64_FORMAT_CHAR) pBase->GetNDR64FormatChar() )
        {
        }
    virtual void OutputFragmentType( CCB *pCCB )
        {
        ISTREAM *stream = pCCB->GetStream();
        stream->WriteOnNewLine("NDR64_FORMAT_CHAR");
        }

    virtual void OutputFragmentData(CCB *pCCB)
        {
        OutputFormatChar( pCCB, FormatCode, true );
        }

    virtual bool IsEqualTo( FormatFragment *frag )
        {
        MIDL_ASSERT( typeid(*frag) == typeid( *this) );
        return FormatCode == ((MIDL_NDR64_FORMAT_CHAR*)frag)->FormatCode;
        }

    virtual const char * GetTypeName()
        {
        return "NDR64_FORMAT_CHAR";
        }

};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_RANGE_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr range type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_RANGE_FORMAT : public SimpleFormatFragment<NDR64_RANGE_FORMAT>
{
public:

    MIDL_NDR64_RANGE_FORMAT( CG_BASETYPE *pRangeCG ) :
        SimpleFormatFragment<NDR64_RANGE_FORMAT>( pRangeCG )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        OutputFormatChar( pCCB, RangeType );
        Output( pCCB, Reserved );
        Output( pCCB, MinValue );
        Output( pCCB, MaxValue, true );
        OutputStructDataEnd( pCCB );
        }
};






//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONTEXT_HANDLE_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr context handle type type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONTEXT_HANDLE_FORMAT 
        : public SimpleFormatFragment<NDR64_CONTEXT_HANDLE_FORMAT>
{
public:

    NDR64_CONTEXT_HANDLE_FLAGS  ContextFlags;

public:

    MIDL_NDR64_CONTEXT_HANDLE_FORMAT( CG_CONTEXT_HANDLE *pHandle ) :
        SimpleFormatFragment<NDR64_CONTEXT_HANDLE_FORMAT>( pHandle )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &ContextFlags );
        Output( pCCB, RundownRoutineIndex );
        Output( pCCB, Ordinal, true );
        OutputStructDataEnd( pCCB );
        }
};



//
//
//  Pointer related items 
//
//

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_POINTER_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr pointer type (including 
//              interface pointers)
//
//---------------------------------------------------------------------------

class MIDL_NDR64_POINTER_FORMAT : public SimpleFormatFragment<NDR64_POINTER_FORMAT>
{ 
public:

    
    MIDL_NDR64_POINTER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_POINTER_FORMAT>( pNdr )
        {
        }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Flags );
        Output( pCCB, Reserved );
        OutputFormatInfoRef( pCCB, Pointee, true );
        OutputStructDataEnd( pCCB );
    }
};

ASSERT_STACKABLE( NDR64_POINTER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_NO_REPEAT_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_NO_REPEAT_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_NO_REPEAT_FORMAT : 
    public SimpleFormatFragment<NDR64_NO_REPEAT_FORMAT>
{
public:
   MIDL_NDR64_NO_REPEAT_FORMAT( )
      {
      FormatCode    = FC64_NO_REPEAT;
      Flags         = 0;
      Reserved1     = 0;
      Reserved2     = 0;
      }

   void OutputFragmentData( CCB *pCCB )
      {
      OutputStructDataStart( pCCB );
      OutputFormatChar( pCCB, FormatCode );
      Output( pCCB, Flags );
      Output( pCCB, Reserved1 );
      Output( pCCB, Reserved2, true );
      OutputStructDataEnd( pCCB );
      }
};

ASSERT_STACKABLE( NDR64_NO_REPEAT_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_REPEAT_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_REPEAT_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_REPEAT_FORMAT :
    public SimpleFormatFragment<NDR64_REPEAT_FORMAT>
{

public:
    MIDL_NDR64_REPEAT_FORMAT( NDR64_UINT32 MemorySize,
                              NDR64_UINT32 Offset,
                              NDR64_UINT32 Pointers,
                              BOOL         SetCorrMark )
    {
        FormatCode          = FC64_VARIABLE_REPEAT;
        Flags.SetCorrMark   = SetCorrMark;
        Flags.Reserved      = 0;
        Reserved            = 0;
        Increment           = MemorySize;
        OffsetToArray       = Offset;
        NumberOfPointers    = Pointers;
    }

    void OutputFragmentData( CCB *pCCB )
       {
       OutputStructDataStart( pCCB );
       OutputFormatChar( pCCB, FormatCode );

       OutputStructDataStart( pCCB );
       Output( pCCB, Flags.SetCorrMark );
       Output( pCCB, Flags.Reserved, true );
       OutputStructDataEnd( pCCB );
       pCCB->GetStream()->Write(",");


       Output( pCCB, Reserved );
       Output( pCCB, Increment );
       Output( pCCB, OffsetToArray );
       Output( pCCB, NumberOfPointers, true );
       OutputStructDataEnd( pCCB );
       }


};

ASSERT_STACKABLE(NDR64_REPEAT_FORMAT) 

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_FIXED_REPEAT_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_FIXED_REPEAT_FORMAT
//
//---------------------------------------------------------------------------


class MIDL_NDR64_FIXED_REPEAT_FORMAT :
    public SimpleFormatFragment<NDR64_FIXED_REPEAT_FORMAT>

{
public:
    MIDL_NDR64_FIXED_REPEAT_FORMAT( NDR64_UINT32 MemorySize,
                                    NDR64_UINT32 Offset,
                                    NDR64_UINT32 Pointers,
                                    NDR64_UINT32 NumberOfIterations,
                                    BOOL SetCorrMark )
    {
        RepeatFormat.FormatCode         = FC64_FIXED_REPEAT;
        RepeatFormat.Flags.SetCorrMark  = SetCorrMark;
        RepeatFormat.Flags.Reserved     = 0;
        RepeatFormat.Reserved           = 0;
        RepeatFormat.Increment          = MemorySize;
        RepeatFormat.OffsetToArray      = Offset;
        RepeatFormat.NumberOfPointers   = Pointers;
        Iterations                      = NumberOfIterations;
        Reserved                        = 0;
    }

    void OutputFragmentData( CCB *pCCB )
       {
       OutputStructDataStart( pCCB );
       
           OutputStructDataStart( pCCB );
           OutputFormatChar( pCCB, RepeatFormat.FormatCode );

           OutputStructDataStart( pCCB );
           Output( pCCB, RepeatFormat.Flags.SetCorrMark );
           Output( pCCB, RepeatFormat.Flags.Reserved, true );
           OutputStructDataEnd( pCCB );
           pCCB->GetStream()->Write(",");

           Output( pCCB, RepeatFormat.Reserved );
           Output( pCCB, RepeatFormat.Increment );
           Output( pCCB, RepeatFormat.OffsetToArray );
           Output( pCCB, RepeatFormat.NumberOfPointers, true );
           OutputStructDataEnd( pCCB );
           pCCB->GetStream()->Write(",");

       Output( pCCB, Iterations, true );
       OutputStructDataEnd( pCCB );
       }
};

ASSERT_STACKABLE( NDR64_FIXED_REPEAT_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_POINTER_INSTANCE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_POINTER_INSTANCE_HEADER_FORMAT>
{
public:
   MIDL_NDR64_POINTER_INSTANCE_HEADER_FORMAT( NDR64_UINT32 OffsetInMemory )
       {
       Offset   = OffsetInMemory;
       Reserved = 0;
       }

   void OutputFragmentData( CCB *pCCB )
       {
       OutputStructDataStart( pCCB );
       Output( pCCB, Offset );
       Output( pCCB, Reserved, true );
       OutputStructDataEnd( pCCB );
       }
};

ASSERT_STACKABLE( NDR64_POINTER_INSTANCE_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_MIDL_CONSTANT_IID_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr constant iid interface pointer 
//              type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONSTANT_IID_FORMAT 
      : public SimpleFormatFragment<NDR64_CONSTANT_IID_FORMAT>
{ 
public:

    NDR64_IID_FLAGS Flags;

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, Reserved );
        OutputGuid( pCCB, Guid, true );
        OutputStructDataEnd( pCCB );
    }
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_MIDL_IID_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr iid_is interface pointer 
//              type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_IID_FORMAT 
      : public SimpleFormatFragment<NDR64_IID_FORMAT>
{ 
public:

    NDR64_IID_FLAGS Flags;

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, Reserved );
        OutputFormatInfoRef( pCCB, IIDDescriptor, true );
        OutputStructDataEnd( pCCB );
    }
};


//
//
// Structure related items
//
//

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_STRUCTURE_UTILITIES
//
//  Synopsis:   Provides utility functions for all the structure types
//
//---------------------------------------------------------------------------


class MIDL_NDR64_STRUCTURE_UTILITIES 
{
public:
    void OutputFlags( FormatFragment *frag, CCB *pCCB, NDR64_STRUCTURE_FLAGS flags, 
                      bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        frag->OutputStructDataStart( pCCB );
        frag->OutputBool( pCCB, flags.HasPointerInfo );
        frag->OutputBool( pCCB, flags.HasMemberInfo );
        frag->OutputBool( pCCB, flags.HasConfArray );
        frag->OutputBool( pCCB, flags.HasOrigMemberInfo );
        frag->OutputBool( pCCB, flags.HasOrigPointerInfo );
        frag->OutputBool( pCCB, flags.Reserved1 );
        frag->OutputBool( pCCB, flags.Reserved2 );
        frag->OutputBool( pCCB, flags.Reserved3, true );
        frag->OutputStructDataEnd( pCCB );
        if (!nocomma) stream->Write(",");
    }
    void ClearFlags( NDR64_STRUCTURE_FLAGS * pFlags )
    {
        memset( pFlags, 0, sizeof( NDR64_STRUCTURE_FLAGS ) );
    }
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_STRUCTURE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_STRUCTURE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_STRUCTURE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_STRUCTURE_HEADER_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    MIDL_NDR64_STRUCTURE_HEADER_FORMAT( CG_STRUCT         *pStruct,
                                        bool bHasPointerLayout,
                                        bool bHasMemberLayout ) :
        SimpleFormatFragment<NDR64_STRUCTURE_HEADER_FORMAT> ( pStruct )
    {
        FormatCode              = (NDR64_FORMAT_CHAR)
                                  ( bHasPointerLayout ? FC64_PSTRUCT : FC64_STRUCT );
        Alignment               = ConvertAlignment( pStruct->GetWireAlignment() );

        ClearFlags( &Flags );
        Flags.HasPointerInfo    = bHasPointerLayout;
        Flags.HasMemberInfo     = bHasMemberLayout;

        Reserve                 = 0;
        MemorySize              = pStruct->GetMemorySize();
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserve );
        Output( pCCB, MemorySize, true );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_STRUCTURE_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_STRUCTURE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_CONF_VAR_STRUCTURE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_STRUCTURE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_CONF_STRUCTURE_HEADER_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    MIDL_NDR64_CONF_STRUCTURE_HEADER_FORMAT( CG_CONFORMANT_STRUCT *pStruct,
                                             bool bHasPointerLayout,
                                             bool bHasMemberLayout,
                                             PNDR64_FORMAT ArrayID ) :
       SimpleFormatFragment<NDR64_CONF_STRUCTURE_HEADER_FORMAT> ( pStruct )
    {
       FormatCode = (NDR64_FORMAT_CHAR) 
                    ( bHasPointerLayout ? FC64_CONF_PSTRUCT : FC64_CONF_STRUCT );
        
       Alignment   = ConvertAlignment( pStruct->GetWireAlignment() );
       
       ClearFlags( &Flags );
       Flags.HasPointerInfo        = bHasPointerLayout;
       Flags.HasMemberInfo         = bHasMemberLayout;
       Flags.HasConfArray          = 1;

       Reserve                     = 0;
       MemorySize                  = pStruct->GetMemorySize();
       ArrayDescription            = ArrayID;
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserve );
        Output( pCCB, MemorySize );
        OutputFormatInfoRef( pCCB, ArrayDescription, true );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_CONF_STRUCTURE_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_BOGUS_STRUCTURE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_BOGUS_STRUCTURE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_BOGUS_STRUCTURE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_BOGUS_STRUCTURE_HEADER_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    MIDL_NDR64_BOGUS_STRUCTURE_HEADER_FORMAT( CG_COMPLEX_STRUCT    *pStruct,
                                              PNDR64_FORMAT        OriginalMemberLayoutID,
                                              PNDR64_FORMAT        OriginalPointerLayoutID,
                                              PNDR64_FORMAT        PointerLayoutID ) :
        SimpleFormatFragment<NDR64_BOGUS_STRUCTURE_HEADER_FORMAT> ( pStruct )
    {
        if ( dynamic_cast<CG_FORCED_COMPLEX_STRUCT*>( pStruct ) != NULL )
            {
            FormatCode = FC64_FORCED_BOGUS_STRUCT; 
            }
        else 
            {
            FormatCode= FC64_BOGUS_STRUCT;
            }
        
        Alignment   = ConvertAlignment( pStruct->GetWireAlignment() );
        
        ClearFlags( &Flags );
        Flags.HasPointerInfo            = ( INVALID_FRAGMENT_ID != PointerLayoutID );
        Flags.HasMemberInfo             = 1;
        Flags.HasOrigPointerInfo        = ( INVALID_FRAGMENT_ID != OriginalPointerLayoutID );
        Flags.HasOrigMemberInfo         = ( INVALID_FRAGMENT_ID != OriginalMemberLayoutID );

        Reserve                         = 0;
        MemorySize                      = pStruct->GetMemorySize();
        OriginalMemberLayout            = OriginalMemberLayoutID;
        OriginalPointerLayout           = OriginalPointerLayoutID;
        PointerLayout                   = PointerLayoutID;

    }
    
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserve );
        Output( pCCB, MemorySize );
        OutputFormatInfoRef( pCCB, OriginalMemberLayout );
        OutputFormatInfoRef( pCCB, OriginalPointerLayout );
        OutputFormatInfoRef( pCCB, PointerLayout );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_BOGUS_STRUCTURE_HEADER_FORMAT ) 

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES

{
public:
    MIDL_NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT( CG_COMPLEX_STRUCT    *pStruct,
                                                   CG_ARRAY             *pArray,
                                                   PNDR64_FORMAT        ConfArrayID,
                                                   PNDR64_FORMAT        OriginalMemberLayoutID,
                                                   PNDR64_FORMAT        OriginalPointerLayoutID,
                                                   PNDR64_FORMAT        PointerLayoutID ) :
        SimpleFormatFragment<NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT>( pStruct )
    {
        if ( dynamic_cast<CG_CONFORMANT_FULL_COMPLEX_STRUCT*>( pStruct ) != NULL )
            {
            FormatCode = FC64_CONF_BOGUS_STRUCT; 
            }
        else if ( dynamic_cast<CG_CONFORMANT_FORCED_COMPLEX_STRUCT*>( pStruct ) != NULL )
            {
            FormatCode= FC64_FORCED_CONF_BOGUS_STRUCT;
            }
        else 
            {
            MIDL_ASSERT(0);
            }

        Alignment   = ConvertAlignment( pStruct->GetWireAlignment() );
        
        ClearFlags( &Flags );
        Flags.HasPointerInfo            = ( INVALID_FRAGMENT_ID != PointerLayoutID );
        Flags.HasMemberInfo             = 1;
        Flags.HasConfArray              = 1;
        Flags.HasOrigPointerInfo        = ( INVALID_FRAGMENT_ID != OriginalPointerLayoutID );
        Flags.HasOrigMemberInfo         = ( INVALID_FRAGMENT_ID != OriginalMemberLayoutID );
        
        MIDL_ASSERT( pArray->GetDimensions() <= 0xFF );
        Dimensions                      = (NDR64_UINT8)pArray->GetDimensions();
        MemorySize                      = pStruct->GetMemorySize();
        ConfArrayDescription            = ConfArrayID;
        OriginalMemberLayout            = OriginalMemberLayoutID;
        OriginalPointerLayout           = OriginalPointerLayoutID;
        PointerLayout                   = PointerLayoutID;

    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );        
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Dimensions );
        Output( pCCB, MemorySize );
        OutputFormatInfoRef( pCCB, OriginalMemberLayout );
        OutputFormatInfoRef( pCCB, OriginalPointerLayout );
        OutputFormatInfoRef( pCCB, PointerLayout );
        OutputFormatInfoRef( pCCB, ConfArrayDescription );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT ) 

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_SIMPLE_MEMBER_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_SIMPLE_MEMBER_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_SIMPLE_MEMBER_FORMAT : 
    public SimpleFormatFragment<NDR64_SIMPLE_MEMBER_FORMAT>, 
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    
    MIDL_NDR64_SIMPLE_MEMBER_FORMAT( NDR64_FORMAT_CHAR NewFormatCode )
        {
        FormatCode = NewFormatCode;
        Reserved1  = 0;
        Reserved2  = 0;
        Reserved3  = 0;
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Reserved1 );
        Output( pCCB, Reserved2 );
        Output( pCCB, Reserved3, true );
        OutputStructDataEnd( pCCB );
        }

};

ASSERT_STACKABLE( NDR64_SIMPLE_MEMBER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_MEMPAD_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_MEMPAD_FORMAT
//
//---------------------------------------------------------------------------
class MIDL_NDR64_MEMPAD_FORMAT : 
    public SimpleFormatFragment<NDR64_MEMPAD_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES
{
public:
    MIDL_NDR64_MEMPAD_FORMAT( unsigned long NewMemPad ) 
        {
        MIDL_ASSERT( NewMemPad <= 0xFFFF );
        FormatCode = FC64_STRUCTPADN;
        Reserve1 = 0;
        MemPad = (NDR64_UINT16)NewMemPad;
        Reserved2 = 0;
        }

    void OutputFragmentData(CCB *pCCB)
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Reserve1 );
        Output( pCCB, MemPad );
        Output( pCCB, Reserved2, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_MEMPAD_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EMBEDDED_COMPLEX_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_EMBEDDED_COMPLEX_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_EMBEDDED_COMPLEX_FORMAT : 
    public SimpleFormatFragment<NDR64_EMBEDDED_COMPLEX_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES

{

public:
    MIDL_NDR64_EMBEDDED_COMPLEX_FORMAT( PNDR64_FORMAT TypeID )
        {
        FormatCode = FC64_EMBEDDED_COMPLEX;
        Reserve1 = 0;
        Reserve2 = 0;
        Type     = TypeID;
        }

    void OutputFragmentData( CCB *pCCB)
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Reserve1 );
        Output( pCCB, Reserve2 );
        OutputFormatInfoRef( pCCB, Type, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_EMBEDDED_COMPLEX_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_BUFFER_ALIGN_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_BUFFER_ALIGN_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_BUFFER_ALIGN_FORMAT : 
    public SimpleFormatFragment<NDR64_BUFFER_ALIGN_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES

{
public:
    MIDL_NDR64_BUFFER_ALIGN_FORMAT( CG_PAD *pPad ) :
        SimpleFormatFragment<NDR64_BUFFER_ALIGN_FORMAT>( pPad ) 
       {
        // BUGBUG: Redo assert to prevent unref'd var warinng
       //unsigned short NewAlignment = pPad->GetWireAlignment();
       //assert( NewAlignment <= 0xFF && NewAlignment > 0 );
       FormatCode   = FC64_BUFFER_ALIGN;
       Alignment    = ConvertAlignment( pPad->GetWireAlignment() );
       Reserved     = 0;
       Reserved2    = 0;
       }

    void OutputFragmentData( CCB *pCCB )
       {
       OutputStructDataStart( pCCB );
       OutputFormatChar( pCCB, FormatCode );
       Output( pCCB, Alignment );
       Output( pCCB, Reserved );
       Output( pCCB, Reserved2, true );
       OutputStructDataEnd( pCCB );
       }
};

ASSERT_STACKABLE( NDR64_BUFFER_ALIGN_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_SIMPLE_REGION_FORMAT
//
//  Synopsis:   MIDL abstraction of NDR64_SIMPLE_REGION_FORMAT
//
//---------------------------------------------------------------------------

class MIDL_NDR64_SIMPLE_REGION_FORMAT : 
    public SimpleFormatFragment<NDR64_SIMPLE_REGION_FORMAT>,
    protected MIDL_NDR64_STRUCTURE_UTILITIES

{
public:
    MIDL_NDR64_SIMPLE_REGION_FORMAT( CG_SIMPLE_REGION *pRegion ) :
        SimpleFormatFragment<NDR64_SIMPLE_REGION_FORMAT>( pRegion )
        {
        FormatCode  = FC64_STRUCT; // BUG BUG, Add new token
        Alignment   = ConvertAlignment( pRegion->GetWireAlignment() );
        MIDL_ASSERT( pRegion->GetWireSize() < 0xFFFF );
        RegionSize  = (NDR64_UINT16)pRegion->GetWireSize();
        Reserved    = 0;
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        Output( pCCB, RegionSize );
        Output( pCCB, Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_SIMPLE_REGION_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_ENCAPSULATED_UNION
//
//  Synopsis:   MIDL abstraction of the ndr encapsulated union type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_ENCAPSULATED_UNION
      : public SimpleFormatFragment<NDR64_ENCAPSULATED_UNION>
{
public:

    MIDL_NDR64_ENCAPSULATED_UNION( CG_ENCAPSULATED_STRUCT *pEncapUnion ) :
        SimpleFormatFragment<NDR64_ENCAPSULATED_UNION>( pEncapUnion )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        Output( pCCB, Flags );
        OutputFormatChar( pCCB, SwitchType );
        Output( pCCB, MemoryOffset );
        Output( pCCB, MemorySize );
        Output( pCCB, Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_ENCAPSULATED_UNION )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_NON_ENCAPSULATED_UNION
//
//  Synopsis:   MIDL abstraction of the ndr non encapsulated union type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_NON_ENCAPSULATED_UNION
      : public SimpleFormatFragment<NDR64_NON_ENCAPSULATED_UNION>
{
public:

    MIDL_NDR64_NON_ENCAPSULATED_UNION( CG_UNION *pUnion ) :
        SimpleFormatFragment<NDR64_NON_ENCAPSULATED_UNION>( pUnion )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        Output( pCCB, Flags );
        OutputFormatChar( pCCB, SwitchType );
        Output( pCCB, MemorySize );
        OutputFormatInfoRef( pCCB, Switch );
        Output( pCCB, Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_NON_ENCAPSULATED_UNION )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_UNION_ARM_SELECTOR
//
//  Synopsis:   MIDL abstraction of the ndr arm selector type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_UNION_ARM_SELECTOR
      : public SimpleFormatFragment<NDR64_UNION_ARM_SELECTOR>
{
public:

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        Output( pCCB, Reserved1 );
        Output( pCCB, Alignment );
        Output( pCCB, Reserved2 );
        Output( pCCB, Arms, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_UNION_ARM_SELECTOR )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_UNION_ARM
//
//  Synopsis:   MIDL abstraction of the ndr arm type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_UNION_ARM : public SimpleFormatFragment<NDR64_UNION_ARM>
{
public:

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        Output( pCCB, CaseValue );
        OutputFormatInfoRef( pCCB, Type );
        Output( pCCB, Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};

ASSERT_STACKABLE( NDR64_UNION_ARM );

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_DEFAULT_CASE
//
//  Synopsis:   MIDL abstraction of a union's default case
//
//---------------------------------------------------------------------------

class MIDL_NDR64_DEFAULT_CASE : public FormatFragment
{
    PNDR64_FORMAT   Type;

    bool ValidType()
        {
        return ( 0 != Type && (FormatInfoRef) -1 != Type);
        }
public:

    MIDL_NDR64_DEFAULT_CASE( PNDR64_FORMAT _Type )
        {
        Type = _Type;
        }

    void OutputFragmentType( CCB *pCCB )
        {
        pCCB->GetStream()->WriteOnNewLine( GetTypeName() );
        }

    void OutputFragmentData( CCB *pCCB )
        {
        if ( ValidType() )
            OutputFormatInfoRef( pCCB, Type, true );
        else
            Output( pCCB, * (NDR64_UINT32 *) &Type, true );
        }

    bool IsEqualTo( FormatFragment *frag )
        {
        return Type == dynamic_cast<MIDL_NDR64_DEFAULT_CASE *>(frag)->Type;
        }

    const char * GetTypeName()
        {
        return ValidType() ? "PNDR64_FORMAT" : "NDR64_UINT32";
        }
};

//
//
//  Array related data
//
//

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_ARRAY_UTILITIES
//
//  Synopsis:   Utility functions for arrays strings.
//
//---------------------------------------------------------------------------

class MIDL_NDR64_ARRAY_UTILITIES
{
public:
    void OutputFlags( FormatFragment *frag, CCB *pCCB, NDR64_ARRAY_FLAGS flags, 
                      bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        frag->OutputStructDataStart( pCCB );
        frag->OutputBool( pCCB, flags.HasPointerInfo );
        frag->OutputBool( pCCB, flags.HasElementInfo );
        frag->OutputBool( pCCB, flags.IsMultiDimensional );
        frag->OutputBool( pCCB, flags.IsArrayofStrings );
        frag->OutputBool( pCCB, flags.Reserved1 );
        frag->OutputBool( pCCB, flags.Reserved2 );
        frag->OutputBool( pCCB, flags.Reserved3 );
        frag->OutputBool( pCCB, flags.Reserved4, true );
        frag->OutputStructDataEnd( pCCB );
        if (!nocomma) stream->Write(",");
    }
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_ARRAY_ELEMENT_INFO
//
//  Synopsis:   MIDL abstraction of an array element description
//
//---------------------------------------------------------------------------

class MIDL_NDR64_ARRAY_ELEMENT_INFO :
    public SimpleFormatFragment<NDR64_ARRAY_ELEMENT_INFO>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        Output( pCCB, ElementMemSize );
        OutputFormatInfoRef( pCCB, Element, true );
        OutputStructDataEnd( pCCB );
    }    
};

ASSERT_STACKABLE( NDR64_ARRAY_ELEMENT_INFO )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of header for a fixed size array
//
//---------------------------------------------------------------------------


class MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_FIX_ARRAY_HEADER_FORMAT>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    MIDL_NDR64_FIX_ARRAY_HEADER_FORMAT( CG_FIXED_ARRAY *pArray ) :
        SimpleFormatFragment<NDR64_FIX_ARRAY_HEADER_FORMAT> ( pArray )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserved );
        Output( pCCB, TotalSize, true );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_FIX_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of header for a conformant array
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_CONF_ARRAY_HEADER_FORMAT>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    MIDL_NDR64_CONF_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_CONF_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserved );
        Output( pCCB, ElementSize );
        OutputFormatInfoRef( pCCB, ConfDescriptor, true );
        OutputStructDataEnd( pCCB );
    }

};

ASSERT_STACKABLE( NDR64_CONF_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of header for a varying array
//
//---------------------------------------------------------------------------


class MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT : 
public SimpleFormatFragment<NDR64_VAR_ARRAY_HEADER_FORMAT>, 
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    MIDL_NDR64_VAR_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_VAR_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserved );
        Output( pCCB, TotalSize );
        Output( pCCB, ElementSize );
        OutputFormatInfoRef( pCCB, VarDescriptor, true );
        OutputStructDataEnd( pCCB );
    }
};

ASSERT_STACKABLE( NDR64_VAR_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of header for a conf varying array
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT :
    public SimpleFormatFragment<NDR64_CONF_VAR_ARRAY_HEADER_FORMAT>, 
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
     
    MIDL_NDR64_CONF_VAR_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
       SimpleFormatFragment<NDR64_CONF_VAR_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, Reserved );
        Output( pCCB, ElementSize );
        OutputFormatInfoRef( pCCB, ConfDescriptor );
        OutputFormatInfoRef( pCCB, VarDescriptor, true );
        OutputStructDataEnd( pCCB );
    }
};

ASSERT_STACKABLE( NDR64_CONF_VAR_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      NDR64_BOGUS_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of a fixed bogus array
//
//---------------------------------------------------------------------------

class MIDL_NDR64_BOGUS_ARRAY_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_BOGUS_ARRAY_HEADER_FORMAT>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    MIDL_NDR64_BOGUS_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_BOGUS_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }
    
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, Alignment );
        OutputFlags( this, pCCB, Flags );
        Output( pCCB, NumberDims );
        Output( pCCB, NumberElements );
        OutputFormatInfoRef( pCCB, Element, true );
        OutputStructDataEnd( pCCB );
    }
};

ASSERT_STACKABLE( NDR64_BOGUS_ARRAY_HEADER_FORMAT )

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT
//
//  Synopsis:   MIDL abstraction of a bogus array
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT : 
    public SimpleFormatFragment<NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT>,
    protected MIDL_NDR64_ARRAY_UTILITIES
{
public:
    
    MIDL_NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT> ( pNdr )
    {
    }

    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );

            OutputStructDataStart( pCCB );
            OutputFormatChar( pCCB, FixedArrayFormat.FormatCode );
            Output( pCCB, FixedArrayFormat.Alignment );
            OutputFlags( this, pCCB, FixedArrayFormat.Flags );
            Output( pCCB, FixedArrayFormat.NumberDims );
            Output( pCCB, FixedArrayFormat.NumberElements );
            OutputFormatInfoRef( pCCB, FixedArrayFormat.Element, true );
            OutputStructDataEnd( pCCB );
            pCCB->GetStream()->Write(",");

        OutputFormatInfoRef( pCCB, ConfDescription );
        OutputFormatInfoRef( pCCB, VarDescription );
        OutputFormatInfoRef( pCCB, OffsetDescription, true );
        
        OutputStructDataEnd( pCCB );
        
    }
};

ASSERT_STACKABLE( NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT )

//
//
//  String types
//
//

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_STRING_UTILITIES
//
//  Synopsis:   Utility functions for string format strings
//
//---------------------------------------------------------------------------


class MIDL_NDR64_STRING_UTILITIES
{
public:
    void OutputFlags( FormatFragment *pFrag,
                      CCB *pCCB,
                      NDR64_STRING_FLAGS Flags,
                      bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        pFrag->OutputStructDataStart( pCCB );
        pFrag->OutputBool( pCCB, Flags.IsSized );
        pFrag->OutputBool( pCCB, Flags.Reserved2 );
        pFrag->OutputBool( pCCB, Flags.Reserved3 );
        pFrag->OutputBool( pCCB, Flags.Reserved4 );
        pFrag->OutputBool( pCCB, Flags.Reserved5 );
        pFrag->OutputBool( pCCB, Flags.Reserved6 );
        pFrag->OutputBool( pCCB, Flags.Reserved7 );
        pFrag->OutputBool( pCCB, Flags.Reserved8, true );        
        pFrag->OutputStructDataEnd( pCCB );
        if ( !nocomma ) stream->Write(",");

    }

    void OutputHeader( FormatFragment *pFrag,
                       NDR64_STRING_HEADER_FORMAT *pHeader, 
                       CCB *pCCB,
                       bool nocomma = false )
    {
        ISTREAM *stream = pCCB->GetStream();
        pFrag->OutputStructDataStart( pCCB );
        pFrag->OutputFormatChar( pCCB, pHeader->FormatCode );
        OutputFlags( pFrag, pCCB, pHeader->Flags );
        pFrag->Output( pCCB, pHeader->ElementSize, true );
        pFrag->OutputStructDataEnd( pCCB );
        if ( !nocomma ) stream->Write(",");
    }
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT
//
//  Synopsis:   MIDL abstraction of a non conformant string
//
//---------------------------------------------------------------------------


class MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT :
    public SimpleFormatFragment<NDR64_NON_CONFORMANT_STRING_FORMAT>,
    protected MIDL_NDR64_STRING_UTILITIES

{
public:
    MIDL_NDR64_NON_CONFORMANT_STRING_FORMAT( CG_ARRAY *pArray ) :
        SimpleFormatFragment<NDR64_NON_CONFORMANT_STRING_FORMAT>( pArray )
    {   
    }
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputHeader( this, &Header, pCCB );
        Output( pCCB, TotalSize, true );
        OutputStructDataEnd( pCCB );
    }

};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONFORMANT_STRING_FORMAT
//
//  Synopsis:   MIDL abstraction of an unsized conformant string
//
//---------------------------------------------------------------------------

class MIDL_NDR64_CONFORMANT_STRING_FORMAT :
    public SimpleFormatFragment<NDR64_CONFORMANT_STRING_FORMAT>,
    protected MIDL_NDR64_STRING_UTILITIES
{
public:
    MIDL_NDR64_CONFORMANT_STRING_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_CONFORMANT_STRING_FORMAT>( pNdr )
    {
    }
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputHeader( this, &Header, pCCB, true );
        OutputStructDataEnd( pCCB );
    }
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_CONFORMANT_STRING_FORMAT
//
//  Synopsis:   MIDL abstraction of a sized conformant string
//
//---------------------------------------------------------------------------

class MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT :
    public SimpleFormatFragment<NDR64_SIZED_CONFORMANT_STRING_FORMAT>,
    protected MIDL_NDR64_STRING_UTILITIES
{
public:
    MIDL_NDR64_SIZED_CONFORMANT_STRING_FORMAT( CG_NDR *pNdr ) :
        SimpleFormatFragment<NDR64_SIZED_CONFORMANT_STRING_FORMAT>( pNdr )
    {
    }
    void OutputFragmentData( CCB *pCCB )
    {
        OutputStructDataStart( pCCB );
        OutputHeader( this, &Header, pCCB );
        OutputFormatInfoRef( pCCB, SizeDescription, true );
        OutputStructDataEnd( pCCB );
    }
};
    
//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EXPR_OPERATOR
//
//  Synopsis:   MIDL abstraction of expression operator
//
//---------------------------------------------------------------------------

class MIDL_NDR64_EXPR_OPERATOR
      : public SimpleFormatFragment<NDR64_EXPR_OPERATOR>
{
public:
    MIDL_NDR64_EXPR_OPERATOR()
    {
    ExprType = FC_EXPR_OPER;
    Reserved = 0;
    CastType = 0;
    }
    
    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        OutputExprOpFormatChar( pCCB,  Operator );
        OutputFormatChar( pCCB, CastType );
        Output( pCCB, * (NDR64_UINT8 *) &Reserved, true );

        OutputStructDataEnd( pCCB );
        }            
};

//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EXPR_CONST32
//
//  Synopsis:   MIDL abstraction of a correlation descriptor
//
//---------------------------------------------------------------------------

class MIDL_NDR64_EXPR_CONST32
      : public SimpleFormatFragment<NDR64_EXPR_CONST32>
{

public:
    MIDL_NDR64_EXPR_CONST32()
    {
    Reserved = 0;
    ExprType = FC_EXPR_CONST32;
    }
    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        OutputFormatChar( pCCB, FC64_INT32 );
        Output( pCCB, * (NDR64_UINT16 *) &Reserved );
        Output( pCCB, * (NDR64_UINT32 *) &ConstValue, true );

        OutputStructDataEnd( pCCB );
        }            
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EXPR_CONST64
//
//  Synopsis:   MIDL abstraction of a 64bit const.
//             
//  Note:       ConstValue will be aligned at 4 but not necessary at 8.
//
//---------------------------------------------------------------------------

class MIDL_NDR64_EXPR_CONST64
      : public SimpleFormatFragment<NDR64_EXPR_CONST64>
{

public:
    MIDL_NDR64_EXPR_CONST64()
    {
    Reserved = 0;
    ExprType = FC_EXPR_CONST64;
    memset( &ConstValue, 0, sizeof( ConstValue ) );
    }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        OutputFormatChar( pCCB, FC64_INT64 );
        Output( pCCB, * (NDR64_UINT16 *) &Reserved1 );
        Output( pCCB, * (NDR64_UINT64 *) &ConstValue,true );

        OutputStructDataEnd( pCCB );
        }            
};


//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_EXPR_VAR
//
//  Synopsis:   MIDL abstraction of an expression variable.
//             
//---------------------------------------------------------------------------

class MIDL_NDR64_EXPR_VAR
      : public SimpleFormatFragment<NDR64_EXPR_VAR>
{
public:

    NDR64_UINT32    ia64Offset;
    // true when in proc, meaning this is stack offset; false when this is 
    // structure. 
    // This can be removed if we'll have only one run per processor
    BOOL            fStackOffset;

public:
    MIDL_NDR64_EXPR_VAR()
    {
    ExprType = FC_EXPR_VAR;
    Reserved = 0;
    ia64Offset = 0;
    Offset = 0;
    fStackOffset = FALSE;
    }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        OutputFormatChar( pCCB, VarType );
        Output( pCCB, * (NDR64_UINT16 *) &Reserved );

        if ( fStackOffset )
            {
            OutputMultiType( 
                    pCCB, 
                    "(NDR64_UINT32) ", 
                    ia64Offset,
                    " /* Offset */",
                    true );
            }
        else
            {
            Output( pCCB, Offset, true );
            }

        OutputStructDataEnd( pCCB );
        }            

    virtual bool IsEqualTo( FormatFragment *_frag )
        {
        MIDL_NDR64_EXPR_VAR *frag = dynamic_cast<MIDL_NDR64_EXPR_VAR *>(_frag);

        MIDL_ASSERT( NULL != frag );

        if ( !SimpleFormatFragment<NDR64_EXPR_VAR>::IsEqualTo( frag ) )
            return false;

        return ( frag->ia64Offset == this->ia64Offset )
               && ( frag->fStackOffset == this->fStackOffset );
        }
};



class MIDL_NDR64_EXPR_NOOP 
        : public SimpleFormatFragment<NDR64_EXPR_NOOP>
{
public:
    MIDL_NDR64_EXPR_NOOP()
        {
        ExprType = FC_EXPR_NOOP;
        Reserved = 0;
        Size = 4;
        }

    void OutputFragmentData( CCB * pCCB)
        {
        OutputStructDataStart( pCCB );
        OutputExprFormatChar( pCCB, ExprType );
        Output( pCCB, * (NDR64_UINT8 *) &Size );
        Output( pCCB, * (NDR64_UINT16 *) &Reserved, true );
        OutputStructDataEnd( pCCB );
        }
};





//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_TRANSMIT_AS_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr trasmit_as / represent_as type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_TRANSMIT_AS_FORMAT
      : public SimpleFormatFragment<NDR64_TRANSMIT_AS_FORMAT>
{
public:

    NDR64_TRANSMIT_AS_FLAGS Flags;

public:

    MIDL_NDR64_TRANSMIT_AS_FORMAT( CG_TYPEDEF *pTransmitAs ) :
        SimpleFormatFragment<NDR64_TRANSMIT_AS_FORMAT>( pTransmitAs )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, RoutineIndex );
        Output( pCCB, TransmittedTypeWireAlignment );
        Output( pCCB, MemoryAlignment );
        Output( pCCB, PresentedTypeMemorySize );
        Output( pCCB, TransmittedTypeBufferSize );
        OutputFormatInfoRef( pCCB, TransmittedType, true );
        OutputStructDataEnd( pCCB );
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_TRANSMIT_AS_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr trasmit_as / represent_as type
//
//  Notes:      transmit_as / represent_as have indentical format info
//              layouts.  We only bother to have a new class so that the
//              type name printing in the stubs is correct.
//
//---------------------------------------------------------------------------

class MIDL_NDR64_REPRESENT_AS_FORMAT : public MIDL_NDR64_TRANSMIT_AS_FORMAT
{
public:

    MIDL_NDR64_REPRESENT_AS_FORMAT( CG_REPRESENT_AS *pRepresentAs ) :
        MIDL_NDR64_TRANSMIT_AS_FORMAT( pRepresentAs )
        {
        }

    virtual const char * GetTypeName()
        {
        return "NDR64_REPRESENT_AS_FORMAT"; // REVIEW: struct _NDR64...
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_USER_MARSHAL_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr user_marshal type
//
//---------------------------------------------------------------------------

class MIDL_NDR64_USER_MARSHAL_FORMAT
      : public SimpleFormatFragment<NDR64_USER_MARSHAL_FORMAT>
{
public:

    NDR64_USER_MARSHAL_FLAGS Flags;

public:

    MIDL_NDR64_USER_MARSHAL_FORMAT( CG_USER_MARSHAL *pUserMarshal) :
        SimpleFormatFragment<NDR64_USER_MARSHAL_FORMAT>( pUserMarshal )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, RoutineIndex );
        Output( pCCB, TransmittedTypeWireAlignment );
        Output( pCCB, MemoryAlignment );
        Output( pCCB, UserTypeMemorySize );
        Output( pCCB, TransmittedTypeBufferSize );
        OutputFormatInfoRef( pCCB, TransmittedType, true );
        OutputStructDataEnd( pCCB );
        }
};



//+--------------------------------------------------------------------------
//
//  Class:      MIDL_NDR64_PIPE_FORMAT
//
//  Synopsis:   MIDL abstraction of the ndr pipe type
//
//  Notes:      There are two ndr pipe types.  One with ranges and one
//              without.  This class derives from the one with ranges but
//              omits them from the output if they aren't necessary.
//
//---------------------------------------------------------------------------

class MIDL_NDR64_PIPE_FORMAT
      : public SimpleFormatFragment<NDR64_RANGE_PIPE_FORMAT>
{
public:

    NDR64_PIPE_FLAGS Flags;

public:

    MIDL_NDR64_PIPE_FORMAT( CG_PIPE *pPipe) :
        SimpleFormatFragment<NDR64_RANGE_PIPE_FORMAT>( pPipe )
        {
        }

    void OutputFragmentData( CCB *pCCB )
        {
        OutputStructDataStart( pCCB );
        OutputFormatChar( pCCB, FormatCode );
        Output( pCCB, * (NDR64_UINT8 *) &Flags );
        Output( pCCB, Alignment );
        Output( pCCB, Reserved );
        OutputFormatInfoRef( pCCB, Type );
        Output( pCCB, MemorySize );
        Output( pCCB, BufferSize, (bool) !Flags.HasRange );

        if ( Flags.HasRange )
            {
            Output( pCCB, MinValue );
            Output( pCCB, MaxValue, true );
            }
        
        OutputStructDataEnd( pCCB );
        }

    const char * GetTypeName()
        {
        return Flags.HasRange 
                        ? "NDR64_RANGE_PIPE_FORMAT" 
                        : "NDR64_PIPE_FORMAT";
        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\yypars.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* SCCSWHAT( "@(#)yypars.c	2.4 88/05/09 15:22:59	" ) */
___a_r_u_start
static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
extern YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
extern short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC short yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

static	void	yy_vc_init();
typedef	void	(*pfn)();
static	pfn	*	pcase_fn_array;
static	int		returnflag = 0;
static	YYSTYPE	*yypvt;
static	int		yym_vc_max = 0;
extern  short	GrammarAct;

extern short	yysavestate;

#define MAX_RECOVERY_ATTEMPTS	(50)
#define MAX_RETRY_COUNT			(3)
static short RetryCount = 0;
static short MaxRecoveryAttempts = 0;
static short fJustDiscarded = 0;

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps, *yysave_yyps;
	YYSTYPE		*yypv,*yysave_yypv;
	YYSTYPE		yysave_yyval;
	short		yyj, yym;
	short		fHaveRecoveredChar	= 0;

	yy_vc_init();
#ifdef YYDEBUG
	yydebug = 1;
#endif /* YYDEBUG */

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

	RetryCount = 0;

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else /* YYDEBUG */
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif /* YYDEBUG */
	if( ++yyps > &yys[YYMAXDEPTH] ) {
/*		yyerror( "yacc stack overflow" ); */
		ParseError(C_STACK_OVERFLOW, (char *)NULL);
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

	yysavestate	= yystate;
	yysave_yypv	= yypv;
	yysave_yyval= yyval;
	yysave_yyps	= yyps;

	yyn = yypact[yystate];

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}

	if( ! fHaveRecoveredChar )
		{
		if( yychar < 0 ) /*  need a lookahead */
			{
			yychar = YYLEX();
			}
		}

	fHaveRecoveredChar	= 0;

	if( ((yyn += yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}

	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = (short *) yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ) /* error */
		{ 

		short yytempchar;


		if( (yychar != EOI ) &&
			 ( RetryCount < MAX_RETRY_COUNT ) &&
			 ( MaxRecoveryAttempts < MAX_RECOVERY_ATTEMPTS ) )
			{ 
			if( RetryCount == 0 )
				SyntaxError( BENIGN_SYNTAX_ERROR, yysavestate );

			if((( yytempchar = PossibleMissingToken( yysavestate, yychar ) ) != -1 ))
				{
				char Buf[ 50 ];


				fHaveRecoveredChar	= 1;
				yyunlex( yychar );
				yychar	= yytempchar;

				if( (yytempchar < 128 ) && isprint( yytempchar ) )
					{
					sprintf( Buf, " %c ", yytempchar );
					}
				else if( yytempchar == IDENTIFIER )
					{
					yylval.yy_pSymName = GenTempName();
					sprintf( Buf, " identifier %s", yylval.yy_pSymName );
					}
				else if( (yytempchar == NUMERICCONSTANT ) ||
						 (yytempchar == NUMERICLONGCONSTANT ) ||
						 (yytempchar == NUMERICULONGCONSTANT ) ||
						 (yytempchar == HEXCONSTANT ) ||
						 (yytempchar == HEXLONGCONSTANT ) ||
						 (yytempchar == HEXULONGCONSTANT ) )
					{
					sprintf( Buf, "a number" );
					yylval.yy_numeric.Val = 0;
					yylval.yy_numeric.pValStr = new char[2];
					strcpy( yylval.yy_numeric.pValStr, "0");
					}

				ParseError( ASSUMING_CHAR, Buf );
				RetryCount = 0;
				MaxRecoveryAttempts++;
				fJustDiscarded = 0;
				}
			else 
				{
				char buf[ 20 ];
				if( (yychar < 128 ) && isprint( yychar ) )
					{
					sprintf( buf, " %c ", yychar );
					}
				else
					{
					sprintf( buf, " the last token " );
					}

				ParseError( DISCARDING_CHAR, buf );
				yychar = -1;
				RetryCount++;
				MaxRecoveryAttempts++;
				fJustDiscarded = 1;
				}

			yystate	= yysavestate;
			yypv	= yysave_yypv;
			yyval	= yysave_yyval;
			yyps	= yysave_yyps;

			goto yynewstate;

			}
		else if( (yychar == EOI ) && (fJustDiscarded == 0 ) )
			{
			SyntaxError( UNEXPECTED_END_OF_FILE, yysavestate );
			return 1;
			}
		else
			{
			SyntaxError( SYNTAX_ERROR, yysavestate );
			return 1;
			}
		}

	/* reduction by production yyn */
/* yyreduce: */
		{
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else /* YYDEBUG */
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif /* YYDEBUG */
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = yyr1[yyn];		/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		returnflag = 0;
		GrammarAct = yym;
		(*(pcase_fn_array[ (yym <= yym_vc_max) ? yym : 0  ]))();
		if(returnflag != 0)
			return returnflag;
		}
		goto yystack;  /* stack new state and value */
	}
___a_r_u_myact
$A
___a_r_u_end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\front\walkctxt.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-1999 Microsoft Corporation

 Module Name:

    walkctxt.cxx

 Abstract:

        typegraph walk context block routines

 Notes:


 Author:

        GregJen Oct-27-1993     Created.

 Notes:


 ----------------------------------------------------------------------------*/

#pragma warning ( disable : 4514 4706 )

/****************************************************************************
 *      include files
 ***************************************************************************/

#include "allnodes.hxx"
#include "walkctxt.hxx"
#include "cmdana.hxx"
#include "semantic.hxx"
#include "control.hxx"

/****************************************************************************
 *      local data
 ***************************************************************************/

/****************************************************************************
 *      externs
 ***************************************************************************/

extern ATTR_SUMMARY                             FieldAttrs;
extern CMD_ARG                          *       pCommand;
extern ccontrol                         *       pCompiler;
extern ATTR_SUMMARY                             RedundantsOk;

/****************************************************************************
 *      definitions
 ***************************************************************************/

// Extract a single attribute from the attribute list (and remove from
// summary).

node_base_attr *
ATTR_ITERATOR::GetAttribute( ATTR_T Attr )
{
    return AllAttrs[ Attr ];
}

// Extract a single attribute from the attribute list (and remove from
// summary).

node_base_attr *
ATTR_ITERATOR::ExtractAttribute( ATTR_T Attr )
{
    node_base_attr  *   pResult = AllAttrs[ Attr ];

    if ( !pResult )
        {
        return pResult;
        }

    // if there were extras of a redundant attr, get the next one from the list
    if ( ( Attr <= REDUNDANT_ATTR_END ) && RedundantAttrExtras[ Attr ].NonNull() )
        {
        RedundantAttrExtras[ Attr ].GetCurrent( (void **)&AllAttrs[Attr] );
        RedundantAttrExtras[ Attr ].RemoveHead();
        }
    else    // no more of this attribute
        {
        AllAttrs[Attr] = NULL;
        RESET_ATTR( Summary, Attr );
        }

    return pResult;
}

void
ATTR_ITERATOR::ExtractFieldAttributes( FIELD_ATTR_INFO * FACtxt )
{
    node_base_attr  *   pAttrNode;
    expr_node       *   pExpr;

    if ( pAttrNode = ExtractAttribute( ATTR_FIRST ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetFirstIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_LAST ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetLastIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_LENGTH ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetLengthIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_MIN ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetMinIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_MAX ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetMaxIs( pExpr );
        }

    if ( pAttrNode = ExtractAttribute( ATTR_SIZE ) )
        {
        pExpr = pAttrNode->GetExpr();
        if ( pExpr )
            FACtxt->SetSizeIs( pExpr );
        }

    // pass iid_is and string attrs on to child
    if ( (FACtxt->Control & FA_CHILD_IS_ARRAY_OR_PTR) == 0 )
        {

        if ( pAttrNode = ExtractAttribute( ATTR_IID_IS ) )
            {
            FACtxt->SetIIDIs( pAttrNode->GetExpr() );
            }

        if ( pAttrNode = ExtractAttribute( ATTR_STRING ) )
            {
            FACtxt->SetString();
            }

        if ( pAttrNode = ExtractAttribute( ATTR_BSTRING ) )
            {
            FACtxt->SetBString();
            }

        }
}


// this routine searches up the context stack looking for a
// matching node

WALK_CTXT   *
WALK_CTXT::FindAncestorContext( NODE_T Kind )
{
    WALK_CTXT   *   pCur    = this;

    while ( pCur )
        {
        if ( (pCur->GetParent())->NodeKind() == Kind )
            return pCur;
        pCur    = pCur->GetParentContext();
        }

    return NULL;
}

// this routine searches up the context stack looking for a
// matching node

WALK_CTXT   *
WALK_CTXT::FindRecursiveContext( node_skl * self )
{
    WALK_CTXT   *   pCur    = this;

    while ( pCur )
        {
        if ( pCur->GetParent() == self )
            return pCur;
        pCur    = pCur->GetParentContext();
        }

    return NULL;
}

// this routine searches up the context stack looking for a
// node other than a typedef

WALK_CTXT   *
WALK_CTXT::FindNonDefAncestorContext( )
{
    WALK_CTXT   *   pCur    = this->GetParentContext();

    while ( pCur )
        {
        if ( (pCur->GetParent())->NodeKind() != NODE_DEF )
            return pCur;
        pCur    = pCur->GetParentContext();
        }

    return NULL;
}


// for my context, find the appropriate pointer kind ( and extract it if needed )
PTRTYPE
WALK_CTXT::GetPtrKind( BOOL * pfExplicitPtrAttr )
{
    PTRTYPE             PtrKind =   PTR_UNKNOWN;
    node_ptr_attr   *   pPtrAttr;
    node_interface  *   pIntf;
    BOOL                fMsExt  =   pCommand->IsSwitchDefined( SWITCH_MS_EXT );
    WALK_CTXT       *   pImportantCtxt = ( fMsExt ) ? FindNonDefAncestorContext() :
                                                                                                          GetParentContext();
    BOOL                fBelowParam = (pImportantCtxt->GetParent()->NodeKind())
                                                                                                        == NODE_PARAM;
    node_interface  *   pItsIntf = GetParent()->GetMyInterfaceNode();

    ////////////////////////////////////////////////////////////////////////
    // process pointer attributes

    if ( pfExplicitPtrAttr )
        *pfExplicitPtrAttr = FALSE;

    if ( FInSummary( ATTR_PTR_KIND ) )
        {
        pPtrAttr = (node_ptr_attr *) ExtractAttribute( ATTR_PTR_KIND );

        PtrKind = pPtrAttr->GetPtrKind();

        if ( pfExplicitPtrAttr  &&
            ( PtrKind == PTR_REF  ||  PtrKind == PTR_FULL ) )
            {
            *pfExplicitPtrAttr = TRUE;
            }
        }
    // top level pointer under param is ref ptr unless explicitly changed
    else if ( fBelowParam )
        {
        PtrKind = PTR_REF;
        }
    // pointer default on defining interface
    else if ( pItsIntf->FInSummary( ATTR_PTR_KIND ) )
        {
        pPtrAttr = (node_ptr_attr *) pItsIntf->GetAttribute( ATTR_PTR_KIND );

        PtrKind = pPtrAttr->GetPtrKind();
        }
    // pointer default on using interface
    else if ( (pIntf=GetInterfaceNode()) ->FInSummary( ATTR_PTR_KIND ) )
        {
        pPtrAttr = (node_ptr_attr *) pIntf->GetAttribute( ATTR_PTR_KIND );

        // semantics verifies that there is exactly one here...
        // ...and adds REF if needed
        PtrKind = pPtrAttr->GetPtrKind();
        }
    else    // global default -- full for DCE, unique for MS_EXT
        {
        if ( fMsExt )
            {
            PtrKind = PTR_UNIQUE;
            }
        else
            {
            PtrKind = PTR_FULL;
            }
        }

    return PtrKind;

}

// get all the operation bits (MAYBE, IDEMPOTENT, BROADCAST, etc.
unsigned short
WALK_CTXT::GetOperationBits()
{
    unsigned short  Bits = 0;

    if ( ExtractAttribute( ATTR_MAYBE ))
        Bits |= OPERATION_MAYBE;

    if ( ExtractAttribute( ATTR_BROADCAST ))
        Bits |= OPERATION_BROADCAST;

    if ( ExtractAttribute( ATTR_IDEMPOTENT ))
        Bits |= OPERATION_IDEMPOTENT;

    if ( ExtractAttribute( ATTR_MESSAGE ))
        Bits |= OPERATION_MESSAGE;

    if ( ExtractAttribute( ATTR_INPUTSYNC ))
        Bits |= OPERATION_INPUT_SYNC;

    return Bits;
}

// add all the attributes to the attribute list; for duplicates, report the duplicate
void
WALK_CTXT::AddAttributes( named_node * pNode )
{
    ATTRLIST            MyAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              CurAttrKind;

    pNode->GetAttributeList( MyAttrs );

    pCurAttr    =   MyAttrs.GetFirst();
    while ( pCurAttr )
        {
        CurAttrKind = pCurAttr->GetAttrID();

        if (   ( pDownAttrList->FInSummary( CurAttrKind ) )
                && ( !IS_ATTR( RedundantsOk , CurAttrKind ) )   )
            {
            ProcessDuplicates( pCurAttr );
            }
        else
            pDownAttrList->Add( pCurAttr );

        pCurAttr        = pCurAttr->GetNext();
        }
}

void
WALK_CTXT::ProcessDuplicates( node_base_attr * pAttr )
{
    if ( pCompiler->GetPassNumber() == SEMANTIC_PASS )
        {
        STATUS_T errnum = ((pAttr->GetAttrID() > NO_DUPLICATES_END)? REDUNDANT_ATTRIBUTE : DUPLICATE_ATTR);

        // it is safe to use SemError on us, since it only uses parts of OUR
        // context that are ready, even though this is called during the constructor
        if ( pAttr->IsAcfAttr() )
            {
            AcfError( (acf_attr *)pAttr,
                NULL,
                *((SEM_ANALYSIS_CTXT *)this),
                errnum,
                NULL);
            }
        else
            {
            char    *   pAttrName = pAttr->GetNodeNameString();
            SemError( NULL, *((SEM_ANALYSIS_CTXT *)this), errnum ,pAttrName);
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\inc\ndrtypes.h ===
/*++

Copyright (c) 1993-1999 Microsoft Corporation

Module Name:

    ndrtypes.h

Abstract:

    Definitions of new NDR format string types.

Revision History:

    DKays    Sep-1993     Created.

--*/

#ifndef __NDRTYPES_H__
#define __NDRTYPES_H__

#include <limits.h>
#ifdef __cplusplus
extern "C" {
#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#ifndef C_ASSERT
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#endif

//
// We use C compiler constants like _I16_MIN or _UI32_MAX from limits.h
// when we need to check for integral boundaries.

#define UNION_OFFSET16_MIN      -32512 /*0x8100*/

// These are pointer sizes used by the compiler.
// As they we do cross-compilation, they cannot be expressed as sizeof(void*).
// The native pointer sizes used by the NDR engine are defined in ndrp.h.

#define NT64_PTR_SIZE       (8)
#define NT32_PTR_SIZE       (4)
#define NDR64_PTR_WIRE_SIZE (8)
#define NDR32_PTR_WIRE_SIZE (4)
#define SIZEOF_PTR( f64 )   ((f64) ? NT64_PTR_SIZE : NT32_PTR_SIZE )
#define SIZEOF_MEM_PTR()    ( ( pCommand->Is64BitEnv() ) ? NT64_PTR_SIZE : NT32_PTR_SIZE )
#define SIZEOF_WIRE_PTR()   ( ( pCommand->IsNDR64Run() && pCommand->Is64BitEnv() ) ? NDR64_PTR_WIRE_SIZE : NDR32_PTR_WIRE_SIZE )
#define SIZEOF_MEM_INT3264() ( ( pCommand->Is64BitEnv() ) ? 8 : 4 )
#define SIZEOF_WIRE_INT3264() ( ( pCommand->Is64BitEnv() && pCommand->IsNDR64Run() ) ? 8 : 4 )

#define MAX_WIRE_ALIGNMENT  (16)

//
// This macro is used to get a pointer to the type description given a 
// FormatInfoRef
//

//
// Ndr versions.  Versions history is as follows :
//
//      1.1 - Windows NT version 3.5
//      1.1 - Windows NT version 3.51
//      2.0 - Windows NT version 4.0
//               2.0 is switched on for Oi2, user_marshal, pipes.
//      5.0 - Windows NT version 5.0, beta1
//               [message], object pipes, async rpc
//      5.2 - Windows NT version 5.0, beta2
//               /robust, [notify] in -Oicf, [async_uuid()]
//               extensions to the format string descriptors.
//      5.3 - Windows 2000 (NT ver. 5.0), beta3 RC1
//               unlimited number of methods with stubless proxies
//      5.4 - Windows 2000 (NT ver. 5.0), beta3
//              pickling with -Oicf
//
// A stub can not be used with an rpcrt4.dll which has a version number
// less than the version number emitted in the stub.  A stub with a lower
// version number than the rpcrt4.dll must work.
//
// Note that the MIDL version is used to choose between -Oi and -Oi2
// interpreters when NDR version is 2.0 or later as now the compiler
// generates an explicit flag indicating the interpreter flavor.
// The compiler version needs to be 3.0.39 or later for that.
//
// Since MIDL 3.3.126, for object interfaces, we have proc header extensions,
// and async uuid supported. Also since the same version, for object interfaces
// the header has a fixed size as we always generate rpcflags into the header
// and always generate an "autohandle" handle. Hence, the oicf interpreter flags
// and also the extended header is always at the fixed position.
//
// The MIDL version history is as follows.
//
//     Windows NT ver. 3.1   - MIDL 1.0
//     Windows NT ver. 3.5   - MIDL 2.0.72              __midl macro
//     Windows NT ver. 3.51  - MIDL 2.0.102 (internally, .104)   vers. in StubDesc
//     Windows NT ver. 4.0   - MIDL 3.0.44              user_marshal, pipes
//     VC 5.0                - MIDL 3.1.75
//     Windows NT ver. 5.0   - MIDL 3.1.76  IDW
//                           - MIDL 3.2.88  IDW
//                           - MIDL 3.3.110 beta1       async rpc
//                           - MIDL 5.0.140             async_uuid, robust
//                           - MIDL 5.1.164 beta2       midl_pragma warning
//     VC 6.0                - MIDL 5.1.164
//     Windows NT 5.0 saga   - MIDL 5.2.204             64b support
//        now WIndows 2000   - MIDL 5.2.235 beta3       netmon 
//                           - MIDL 5.3.266             midl/midlc exe split
//
// The MIDL version is generated into the stub descriptor starting with
// MIDL ver.2.0.96 (pre NT 3.51 beta 2, Feb 95).
// See ndr20\ndrp.h for constants used for specific versions.
//


#define NDR_MAJOR_VERSION   6UL
#define NDR_MINOR_VERSION   0UL
#define NDR_VERSION         ((NDR_MAJOR_VERSION << 16) | NDR_MINOR_VERSION)

#define NDR_VERSION_1_1     ((1UL << 16) | 1UL)
#define NDR_VERSION_2_0     ((2UL << 16) | 0UL)
#define NDR_VERSION_5_0     ((5UL << 16) | 0UL)
#define NDR_VERSION_5_2     ((5UL << 16) | 2UL)
#define NDR_VERSION_5_3     ((5UL << 16) | 3UL)
#define NDR_VERSION_5_4     ((5UL << 16) | 4UL)
#define NDR_VERSION_6_0     ((6UL << 16) | 0UL)

#define NDR_VERSION_6_0     ((6UL << 16) | 0UL)

//
// NOTE: The following stuff now lives in ndrtoken.h (\com\inc\ndrshared):
//       --Format character definitions
//       --interpreter flags
//       --Conformance and Variance constants
//       --Pointer attributes
//       --Interpreter bit flag structures
//
#include <ndrtoken.h>

#define MAX_INTERPRETER_OUT_SIZE        128
#define MAX_INTERPRETER_PARAM_OUT_SIZE  7 * 8

#define INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD  (sizeof(long) * 32)

#define INTERPRETER_PROC_STACK_FRAME_SIZE_THRESHOLD  ( ( 64 * 1024 ) - 1 )

typedef  struct  _NDR_CORRELATION_FLAGS
    {
    unsigned char   Early    : 1;
    unsigned char   Split    : 1;
    unsigned char   IsIidIs  : 1;
    unsigned char   DontCheck: 1;
    unsigned char   Unused   : 4;
    } NDR_CORRELATION_FLAGS;

#define FC_EARLY_CORRELATION            (unsigned char) 0x01
#define FC_SPLIT_CORRELATION            (unsigned char) 0x02
#define FC_IID_CORRELATION              (unsigned char) 0x04
#define FC_NOCHECK_CORRELATION          (unsigned char) 0x08

#define FC_NDR64_EARLY_CORRELATION      (unsigned char) 0x01
#define FC_NDR64_NOCHECK_CORRELATION    (unsigned char) 0x02

typedef struct _NDR_CS_TAG_FLAGS
    {
    unsigned char   STag                : 1;
    unsigned char   DRTag               : 1;
    unsigned char   RTag                : 1;
    } NDR_CS_TAG_FLAGS;

typedef struct _NDR_CS_TAG_FORMAT
    {
    unsigned char       FormatCode;
    NDR_CS_TAG_FLAGS    Flags;
    unsigned short      TagRoutineIndex;
    } NDR_CS_TAG_FORMAT;

C_ASSERT( 4 == sizeof( NDR_CS_TAG_FORMAT ) );

#define NDR_INVALID_TAG_ROUTINE_INDEX 0x7FFF

typedef struct _NDR_CS_ARRAY_FORMAT
    {
    unsigned char   FormatCode;
    unsigned char   Reserved;
    unsigned short  UserTypeSize;
    unsigned short  CSRoutineIndex;
    unsigned short  Reserved2;
    long            DescriptionOffset;
    } NDR_CS_ARRAY_FORMAT;

C_ASSERT( 12 == sizeof( NDR_CS_ARRAY_FORMAT ) );

typedef enum 
{
XFER_SYNTAX_DCE = 0x8A885D04,
XFER_SYNTAX_NDR64 = 0x71710533,
XFER_SYNTAX_TEST_NDR64 = 0xb4537da9,
//XFER_SYNTAX_NONE,
//XFER_SYNTAX_MAX = XFER_SYNTAX_NONE
} SYNTAX_TYPE;

#define LOW_NIBBLE(Byte)            (((unsigned char)Byte) & 0x0f)
#define HIGH_NIBBLE(Byte)           (((unsigned char)Byte) >> 4)

#define INVALID_RUNDOWN_ROUTINE_INDEX   255

//
// internal bits to represent operation bits
//

#define OPERATION_MAYBE         0x0001
#define OPERATION_BROADCAST     0x0002
#define OPERATION_IDEMPOTENT    0x0004
#define OPERATION_INPUT_SYNC    0x0008
#define OPERATION_ASYNC         0x0010
#define OPERATION_MESSAGE       0x0020

//
//  Transmit as / Represent as flag field flags.
//
//     Lower nibble of this byte has an alignment of the transmitted type.
//     Upper nibble keeps flags.
//

#define PRESENTED_TYPE_NO_FLAG_SET  0x00
#define PRESENTED_TYPE_IS_ARRAY     0x10
#define PRESENTED_TYPE_ALIGN_4      0x20
#define PRESENTED_TYPE_ALIGN_8      0x40

//
//  User marshal flags

#define USER_MARSHAL_POINTER        0xc0  /* unique or ref */

#define USER_MARSHAL_UNIQUE         0x80
#define USER_MARSHAL_REF            0x40
#define USER_MARSHAL_IID            0x20  /* user marshal has optional info */


//
//  Handle flags.
//
//  Lower nibble of this byte may have a generic handle size.
//  Upper nibble keeps flags.  ALL FLAGS ARE NOW USED.
//

#define HANDLE_PARAM_IS_VIA_PTR     0x80
#define HANDLE_PARAM_IS_IN          0x40
#define HANDLE_PARAM_IS_OUT         0x20
#define HANDLE_PARAM_IS_RETURN      0x10

// Lower nibble of this byte may have a generic handle size.
// For context handles, it is used for the following flags.

#define NDR_STRICT_CONTEXT_HANDLE             0x08   /* NT5 */
#define NDR_CONTEXT_HANDLE_NOSERIALIZE        0x04   /* NT5 */
#define NDR_CONTEXT_HANDLE_SERIALIZE          0x02   /* NT5 */
#define NDR_CONTEXT_HANDLE_CANNOT_BE_NULL     0x01   /* NT5 */

//  These are old interpreter flags.
//  Oi and pickling per procedure flags.
//

#define Oi_FULL_PTR_USED                        0x01
#define Oi_RPCSS_ALLOC_USED                     0x02
#define Oi_OBJECT_PROC                          0x04
#define Oi_HAS_RPCFLAGS                         0x08

//
// Bits 5, 6 and 7 are overloaded for use by both pickling and
// non-pickling conditions.
//
// Bit 5 (0x20) is overloaded for object interfaces to distinguish
//       between invocations of V1 and V2 intepreters for proxies and stubs.
//       Note that for backward compatibility the bit is actually set
//       for V1 as it is checked only when NDR version is 2 or later.
//

#define Oi_IGNORE_OBJECT_EXCEPTION_HANDLING     0x10

#define ENCODE_IS_USED                          0x10
#define DECODE_IS_USED                          0x20
#define PICKLING_HAS_COMM_OR_FAULT              0x40    // In -Oicf mode only

#define Oi_HAS_COMM_OR_FAULT                    0x20
#define Oi_OBJ_USE_V2_INTERPRETER               0x20

#define Oi_USE_NEW_INIT_ROUTINES                0x40
#define Oi_UNUSED                               0x80

//  The new -Oicf interpreter flags

#define Oif_HAS_ASYNC_UUID                     0x20

//  Extended new interpreter flags


//
// Union arm description types.
//
#define UNION_CONSECUTIVE_ARMS      1
#define UNION_SMALL_ARMS            2
#define UNION_LARGE_ARMS            3

// Pipe flags
#define FC_BIG_PIPE                 0x80
#define FC_OBJECT_PIPE              0x40
#define FC_PIPE_HAS_RANGE           0x20

//
// Union ex. magic union byte, now short
//
#define MAGIC_UNION_SHORT           ((unsigned short) 0x8000)

//
//      NDR64 related data types / definitions
//

typedef enum _operators
	{
	 OP_START
	,OP_ILLEGAL = OP_START

	,OP_UNARY_START

	,OP_UNARY_ARITHMETIC_START	= OP_UNARY_START
	,OP_UNARY_PLUS 				= OP_UNARY_ARITHMETIC_START
	,OP_UNARY_MINUS
	,OP_UNARY_ARITHMETIC_END

	,OP_UNARY_LOGICAL_START		= OP_UNARY_ARITHMETIC_END
	,OP_UNARY_NOT				= OP_UNARY_LOGICAL_START
	,OP_UNARY_COMPLEMENT
	,OP_UNARY_LOGICAL_END

	,OP_UNARY_INDIRECTION		= OP_UNARY_LOGICAL_END
	,OP_UNARY_CAST
	,OP_UNARY_AND
	,OP_UNARY_SIZEOF
        ,OP_UNARY_ALIGNOF
	,OP_PRE_INCR
	,OP_PRE_DECR
	,OP_POST_INCR
	,OP_POST_DECR

	,OP_UNARY_END

	,OP_BINARY_START			= OP_UNARY_END

	,OP_BINARY_ARITHMETIC_START	= OP_BINARY_START
	,OP_PLUS					= OP_BINARY_ARITHMETIC_START
	,OP_MINUS
	,OP_STAR
	,OP_SLASH
	,OP_MOD
	,OP_BINARY_ARITHMETIC_END

	,OP_BINARY_SHIFT_START		= OP_BINARY_ARITHMETIC_END
	,OP_LEFT_SHIFT				= OP_BINARY_SHIFT_START
	,OP_RIGHT_SHIFT
	,OP_BINARY_SHIFT_END

	,OP_BINARY_RELATIONAL_START	= OP_BINARY_SHIFT_END
	,OP_LESS					= OP_BINARY_RELATIONAL_START
	,OP_LESS_EQUAL
	,OP_GREATER_EQUAL
	,OP_GREATER
	,OP_EQUAL
	,OP_NOT_EQUAL
	,OP_BINARY_RELATIONAL_END

	,OP_BINARY_BITWISE_START	= OP_BINARY_RELATIONAL_END
	,OP_AND						= OP_BINARY_BITWISE_START
	,OP_OR
	,OP_XOR
	,OP_BINARY_BITWISE_END

	,OP_BINARY_LOGICAL_START	= OP_BINARY_BITWISE_END
	,OP_LOGICAL_AND				= OP_BINARY_LOGICAL_START
	,OP_LOGICAL_OR
	,OP_BINARY_LOGICAL_END

	,OP_BINARY_TERNARY_START	= OP_BINARY_LOGICAL_END
	,OP_QM						= OP_BINARY_TERNARY_START
	,OP_COLON
	,OP_BINARY_TERNARY_END

	,OP_BINARY_END				= OP_BINARY_TERNARY_END

	,OP_INTERNAL_START			= OP_BINARY_END
	,OP_FUNCTION
	,OP_PARAM

	,OP_POINTSTO
	,OP_DOT
	,OP_INDEX
	,OP_COMMA
	,OP_STMT
	,OP_ASSIGN

	,OP_ASYNCSPLIT
	,OP_CORR_POINTER
	,OP_CORR_TOP_LEVEL
	
	,OP_END
	} OPERATOR;


typedef enum _NDR64_EXPRESSION_TYPE
{
    EXPR_MAXCOUNT,
    EXPR_ACTUALCOUNT,
    EXPR_OFFSET,
    EXPR_IID,
    EXPR_SWITCHIS
} NDR64_EXPRESSION_TYPE;

#ifdef __cplusplus
}
#endif

#endif  // !__NDRTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\support\buffer.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    MIDL Compiler Buffer Manager Definition 

    This class manages a collection of pre-allocated strings.

Author:

    Donna Liu (donnali) 09-Nov-1990

Revision History:

    26-Feb-1992     donnali

        Moved toward NT coding style.

--*/

#pragma warning ( disable : 4514 4710 )


#include "nulldefs.h"
extern "C" {
#include <stdio.h>
#include <malloc.h>
#include <string.h>
}
#include "buffer.hxx"

#ifdef gaj_debug_buf
extern void midl_debug (char *);
#else
#define midl_debug(s)
#endif

BufferManager::BufferManager(
	unsigned short	usBufferSize
	)
/*++

Routine Description:

    This method constructs a BufferManager object.

Arguments:

    usBufferSize - Supplies the size of each managed buffer.

--*/
{
	char **	pTemp = new (char *[usBufferSize]);

	usBufSize = usBufferSize;
	usTabSize = 0;
	pszTable = (char **)0;
	pHead = pTail = pSave = new BufferElement(
							NULL,
							NULL,
							pTemp);
	iHead = iTail = unsigned short(usBufSize - 2);
}

BufferManager::BufferManager(
	unsigned short	usBufferSize,
	unsigned short	usTableSize,
	const char *	aStringTable[]
	)
/*++

Routine Description:

    This method constructs a BufferManager object.

Arguments:

    usBufferSize - Supplies the size of each managed buffer.

    usTableSize - Supplies the size of the table containing string
        constants.

    aStringTable - Supplies the table containing string constants.

--*/
{
	char **	pTemp = new (char *[usBufferSize]);

	usBufSize = usBufferSize;
	usTabSize = usTableSize;
	pszTable = (char**) aStringTable;
	pHead = pTail = pSave = new BufferElement(
							NULL,
							NULL,
							pTemp);
	iHead = iTail = unsigned short(usBufSize - 2);
}


void BufferManager::Print(
	ISTREAM * pStream
	)
/*++

Routine Description:

    This method prints all the strings managed by a BufferManager
    to a file.

Arguments:

    pStream - Supplies the output file handle.

--*/
{
	unsigned short	usCount;
	BufferElement *	pTemp;
	char			BigBuffer[1000];
	char		  * pBigBufferNext;

	if (pHead == pTail)
		{
		pBigBufferNext = &BigBuffer[0];
		*pBigBufferNext = '\0';
		for (usCount = iHead ; usCount < iTail ; usCount++)
			{
			strcpy( pBigBufferNext, pHead->pBuffer[usCount] );
			pBigBufferNext += strlen( pBigBufferNext );
			}
		pStream->Write( BigBuffer );
		}
	else
		{

		pBigBufferNext = &BigBuffer[0];
		*pBigBufferNext = '\0';
		for (usCount = iHead ; usCount < usBufSize ; usCount++)
			{
			strcpy( pBigBufferNext, pHead->pBuffer[usCount] );
			pBigBufferNext += strlen( pBigBufferNext );
			}
		pStream->Write( BigBuffer );

		for (pTemp = pHead->GetNext() ; 
			pTemp != pTail ; 
			pTemp = pTemp->GetNext())
			{
			pBigBufferNext = &BigBuffer[0];
			*pBigBufferNext = '\0';
			for (usCount = 0 ; usCount < usBufSize ; usCount++)
				{
				strcpy( pBigBufferNext, pTemp->pBuffer[usCount] );
				pBigBufferNext += strlen( pBigBufferNext );
				}
			pStream->Write( BigBuffer );
			}

		pBigBufferNext = &BigBuffer[0];
		*pBigBufferNext = '\0';
		for (usCount = 0 ; usCount < iTail ; usCount++)
			{
			strcpy( pBigBufferNext, pTail->pBuffer[usCount] );
			pBigBufferNext += strlen( pBigBufferNext );
			}
		pStream->Write( BigBuffer );
		
		}

	Clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\inc\szbuffer.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       szbuffer.h
//
//  Contents:   simple class for a string buffer that dynamically reallocates
//              space for itself as necessary
//
//  Classes:    CSzBuffer
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef CSZBUFFER
#define CSZBUFFER

//+---------------------------------------------------------------------------
//
//  Class:      CSzBuffer
//
//  Purpose:    string buffer that automatically allocates space as needed
//
//  Interface:  Set        -- resets buffer to new string
//              Append     -- adds string (or number) to end of data
//              Prepend    -- adds string (or number) to front of data
//              GetData    -- gets pointer to string buffer
//              GetLength  -- gets length of string in buffer (in chars)
//
//  History:    4-22-96   stevebl   Created
//
//----------------------------------------------------------------------------

class CSzBuffer
{
public:
    CSzBuffer(const char * sz);
    CSzBuffer();
    ~CSzBuffer();

    void Set(const char * sz);
    void Append(const char * sz);
    void Prepend(const char * sz);
    void Append(const long l);
    void Prepend(const long l);

    char * GetData();

    int GetLength();

    operator char *()
    {
        return GetData();
    };

private:
    int cchLength;
    int cchBufSize;
    char * szData;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\support\memory.cxx ===
/*****************************************************************************/
/**						Microsoft LAN Manager								**/
/**				Copyright(c) Microsoft Corp., 1987-1999						**/
/*****************************************************************************/
/*****************************************************************************
File				: memory.cxx
Title				: new and delete functions for the midl compiler
History				:
	06-Aug-1991	VibhasC	Created

*****************************************************************************/

#pragma warning ( disable : 4514 )

/****************************************************************************
 includes
 ****************************************************************************/

#include "nulldefs.h"
#include <basetsd.h>
extern	"C"	{
	#include <stdio.h>
	#include <stdlib.h>
	#include <malloc.h>
}
#include "errors.hxx"
#include "nodeskl.hxx"
#include "attrnode.hxx"

/****************************************************************************
	extern data
 ****************************************************************************/

extern	unsigned long		TotalAllocation;

extern	char	*		Skl_bufstart;
extern	char	*		Skl_bufend;
extern	unsigned long	Skl_Allocations;
extern	unsigned long	Skl_Bytes;
extern	unsigned long	Skl_Deletions;

/****************************************************************************/

/****************************************************************************
 *** print memory statistics
 ****************************************************************************/

void
print_memstats()
	{
	printf("\t\t***** memory use **************\n");
	printf("\tglobal operator new allocations:\t %ld bytes\n", TotalAllocation);
	printf("\tAllocateOnce allocations: %ld, \t\t(%ld bytes)\n",
			Skl_Allocations, Skl_Bytes);
	printf("\t\tand deletions: %ld\n", Skl_Deletions );


#ifdef print_sizes
	printf("sizes:\n");
	printf("node_skl: %d\n",sizeof(node_skl) );
	printf("named_node: %d\n",sizeof(named_node) );
	printf("tracked_node: %d\n",sizeof(tracked_node) );
	printf("node_id: %d\n",sizeof(node_id) );
	printf("node_label: %d\n",sizeof(node_label) );
	printf("node_param: %d\n",sizeof(node_param) );
	printf("node_file: %d\n",sizeof(node_file) );
	printf("node_proc: %d\n",sizeof(node_proc) );
	printf("node_forward: %d\n",sizeof(node_forward) );
	printf("node_field: %d\n",sizeof(node_field) );
	printf("node_bitfield: %d\n",sizeof(node_bitfield) );
	printf("node_su_base: %d\n",sizeof(node_su_base) );
	printf("node_enum: %d\n",sizeof(node_enum) );
	printf("node_struct: %d\n",sizeof(node_struct) );
	printf("node_en_struct: %d\n",sizeof(node_en_struct) );
	printf("node_union: %d\n",sizeof(node_union) );
	printf("node_en_union: %d\n",sizeof(node_en_union) );
	printf("node_def: %d\n",sizeof(node_def) );
	printf("node_interface: %d\n",sizeof(node_interface) );
	printf("node_source: %d\n",sizeof(node_source) );
	printf("npa_nodes: %d\n",sizeof(npa_nodes) );
	printf("node_pointer: %d\n",sizeof(node_pointer) );
	printf("node_array: %d\n",sizeof(node_array) );
	printf("node_e_status_t: %d\n",sizeof(node_e_status_t) );
	printf("node_error: %d\n",sizeof(node_error) );
	printf("node_base_type: %d\n",sizeof(node_base_type) );
	printf("node_wchar_t: %d\n",sizeof(node_wchar_t) );
	printf("\n");
#endif // print_sizes

	};

/****************************************************************************
 *** the special memory functions for allocate once and never delete objects
 ***
 *** No space is returned on delete
 ****************************************************************************/

// Round all allocations up to the nearest long and/or pointer alignment
#define	ROUNDING	(sizeof(LONG_PTR)-1)

// The buffer size appears to be picked out of thin air
#define BUFSIZE (32748 & ~ROUNDING)

void * 
AllocateOnceNew(
	size_t	size )
	{
	char * _last_allocation;

	// check for enough free space

	if ( ((SIZE_T) Skl_bufend) -
		 ((SIZE_T) Skl_bufstart ) < size )
		{

		// get a new big block of memory
		if ( (_last_allocation = (char *) malloc( BUFSIZE ) )== 0)
			{
	
			RpcError( (char *)NULL,
					  	0,
					  	OUT_OF_MEMORY,
					  	(char *)NULL );
	
			exit( OUT_OF_MEMORY );
			}
		else
			{
			Skl_bufstart	= _last_allocation;
			Skl_bufend		= Skl_bufstart  + BUFSIZE;
			}
		
		}

	_last_allocation = Skl_bufstart ;
	Skl_bufstart  += (size + ROUNDING) & ~ROUNDING;

#ifndef NDEBUG
	Skl_Allocations ++;
	Skl_Bytes += size;
#endif

	return _last_allocation;

	};


void  
AllocateOnceDelete( void* )
	{
#ifndef NDEBUG
	Skl_Deletions ++;
#endif
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\typelib\implib.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       implib.cxx
//
//  Contents:   import lib functions
//
//  Classes:    NODE_MANAGER
//
//  Functions:  TypelibError
//              TypeinfoError
//              GetStringFromGuid
//              AddTypeLibraryMembers
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

#pragma warning ( disable : 4514 )

#include "tlcommon.hxx"
#include "tlgen.hxx"
#include "tllist.hxx"
#include "becls.hxx"
#include "walkctxt.hxx"

// Initialize an instance of a type library list.
// This way it will clean itself up as necessary.
CTypeLibraryList gtllist;

extern short ImportLevel;

//+---------------------------------------------------------------------------
//
//  Function:   TypelibError
//
//  Synopsis:   Report generic type library error and exit.
//
//  Arguments:  [szFile] - file associated with the error
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void TypelibError(char * szFile, HRESULT /* UNREF hr */)
{
    RpcError(NULL, 0, ERR_TYPELIB, szFile);
    exit(ERR_TYPELIB);
}

//+---------------------------------------------------------------------------
//
//  Function:   TypeinfoError
//
//  Synopsis:   Report generic type info error and exit.
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void TypeinfoError(HRESULT /* UNREF hr */)
{
    RpcError(NULL, 0, ERR_TYPEINFO, NULL);
    exit(ERR_TYPEINFO);
}

//+---------------------------------------------------------------------------
//
//  Function:   AddToGuidString
//
//  Synopsis:   Private helper function for GetStringFromGuid.
//              Adds exactly cch hex characters to the string pch.
//
//  Arguments:  [pch]  - pointer to the next available position in the string
//                       buffer
//              [cch]  - number of characters to add to the string buffer
//              [uVal] - value to be converted to text representation
//
//  History:    5-02-95   stevebl   Created
//
//  Modifies:   pch is advanced by cch characters (i.e. left pointing to the
//              next available position in the buffer).
//
//  Notes:      pch must be large enough to accept the characters.
//              The resulting string is not null terminated.
//
//----------------------------------------------------------------------------

void AddToGuidString(char * &pch, unsigned cch, unsigned long uVal)
{
    char bVal;
    unsigned long uMask = 0xf << ((cch - 1) * 4);
    while (cch)
    {
        bVal = (char)((uVal & uMask) >> ((cch - 1) * 4));
        if (bVal < 10)
            *(pch++) = char( '0' + bVal );
        else
            *(pch++) = char ( 'a' + bVal - 10 );
        uMask >>= 4;
        cch--;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStringFromGuid
//
//  Synopsis:   returns the string representation of a guid
//
//  Arguments:  [g] - guid
//
//  Returns:    pointer to a newly allocated string
//
//  History:    5-02-95   stevebl   Created
//
//  Notes:      It is up to the caller to free the resulting string.
//
//----------------------------------------------------------------------------

char * GetStringFromGuid(GUID &g)
{
    char * sz = new char [37];
    char * pch = sz;
    AddToGuidString(pch, 8, g.Data1);
    *(pch++) = '-';
    AddToGuidString(pch, 4, g.Data2);
    *(pch++) = '-';
    AddToGuidString(pch, 4, g.Data3);
    *(pch++) = '-';
    int i;
    for (i = 0; i < 2; i++)
    {
        AddToGuidString(pch, 2, g.Data4[i]);
    }
    *(pch++) = '-';
    for (; i < 8; i++)
    {
        AddToGuidString(pch, 2, g.Data4[i]);
    }
    *(pch++) = '\0';
    return sz;
}

struct NODE_MANAGER_ELEMENT
{
    ITypeInfo * pti;
    named_node * pskl;
    NODE_MANAGER_ELEMENT * pNext;
};

//+---------------------------------------------------------------------------
//
//  Class:      NODE_MANAGER
//
//  Purpose:    Maintains an ordered list of every ITypeInfo for which a
//              node_skl has been generated.
//
//  Interface:  GetNode -- retrieve a node_skl * from a type library
//
//  History:    5-02-95   stevebl   Created
//
//  Notes:      A client can call GetNode() to get a node_skl * from an
//              ITypeInfo pointer.  If one has previously been generated then
//              the caller will get a pointer to the previously generated
//              node.  Otherwise, GetNode() will call ExpandTI to generate one.
//
//              This class exists as a mechanism to avoid infinite recursion
//              when importing type infos with cyclic type dependencies.
//
//----------------------------------------------------------------------------

class NODE_MANAGER
{
private:
    NODE_MANAGER_ELEMENT * pHead;
    void ExpandTI(named_node * &pNode, ITypeInfo * pti);
    node_skl * GetNodeFromTYPEDESC(TYPEDESC tdesc, ITypeInfo * pti);
    named_node * GetNodeFromVARDESC(VARDESC vdesc, ITypeInfo * pti);
    named_node * GetNodeFromFUNCDESC(FUNCDESC fdesc, ITypeInfo *pti);
    void SetIDLATTRS(named_node * pNode, IDLDESC idldesc);
    void AddMembers(MEMLIST * pNode, TYPEATTR * ptattr, ITypeInfo * pti);
    expr_node * GetValueOfConstant(VARIANT * pVar);
public:
    NODE_MANAGER()
    {
        pHead = NULL;
    }

    ~NODE_MANAGER()
    {
        NODE_MANAGER_ELEMENT * pNext;
        while (pHead)
        {
            pHead->pti->Release();
            pNext = pHead->pNext;
            delete(pHead);
            pHead = pNext;
        };
    }

    node_skl * GetNode(ITypeInfo * pti);

} gNodeManager;

BOOL FAddImportLib(char * szLibraryFileName)
{
    return gtllist.Add(szLibraryFileName);
}

BOOL FIsLibraryName(char * szName)
{
    return (NULL != gtllist.FindLibrary(szName));
}

extern SymTable * pBaseSymTbl;

node_href::~node_href()
{
    if (pTypeInfo)
        ((ITypeInfo *)pTypeInfo)->Release();
}

extern IINFODICT * pInterfaceInfoDict;
char * GenIntfName();

//+---------------------------------------------------------------------------
//
//  Member:     node_href::Resolve
//
//  Synopsis:   Expands a referenced type info into a complete type graph.
//
//  Returns:    Pointer to the expanded typegraph.
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

named_node * node_href::Resolve()
{
    char *          sz;
    named_node * pReturn = (named_node *)GetChild();
    if (!pReturn)
    {
        pInterfaceInfoDict->StartNewInterface();

        // start a dummy interface for intervening stuff
        node_interface * pOuter = new node_interface;
        pOuter->SetSymName( GenIntfName() );
        pOuter->SetFileNode( GetDefiningFile() );
        pInterfaceInfoDict->SetInterfaceNode( pOuter );

        pReturn = (named_node *)gNodeManager.GetNode((ITypeInfo*)pTypeInfo);
        SetChild(pReturn);
        sz = pReturn->GetSymName();
        if ( sz )
            SetSymName(sz);

        pInterfaceInfoDict->EndNewInterface();
    }
    return pReturn;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetNode
//
//  Synopsis:   Gets a type graph node from a type info pointer.
//
//  Arguments:  [pti] - type info pointer
//
//  Returns:    pointer to the type graph described by the type info
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

node_skl * NODE_MANAGER::GetNode(ITypeInfo * pti)
{
    NODE_MANAGER_ELEMENT ** ppThis = &pHead;
    while (*ppThis && (*ppThis)->pti <= pti)
    {
        if ((*ppThis)->pti == pti)
            return (*ppThis)->pskl;
        ppThis = &((*ppThis)->pNext);
    }
    NODE_MANAGER_ELEMENT * pNew = new NODE_MANAGER_ELEMENT;
    pNew->pti = pti;
    // Make sure no one can release this ITypeInfo pointer out from under us.
    // The corresponding release() occurs in NODE_MANAGER's destructor.
    pti->AddRef();
    // insert the new node into the table
    pNew->pNext = *ppThis;
    *ppThis = pNew;
    // expand the node
    ExpandTI(pNew->pskl, pti);
    ((named_node*)(pNew->pskl))->SetFileNode(pInterfaceInfoDict->GetInterfaceNode()->GetDefiningFile() );
    ((named_node*)(pNew->pskl))->SetDefiningTLB(pInterfaceInfoDict->GetInterfaceNode()->GetDefiningFile() );
    return pNew->pskl;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::ExpandTI
//
//  Synopsis:   This is where all the work gets done.
//              Takes a type info pointer and expands it into a type graph.
//
//  Arguments:  [pti] - pointer to the type info
//
//  Returns:    pointer to the type graph
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void NODE_MANAGER::ExpandTI(named_node * &pNode, ITypeInfo * pti)
{
    TYPEATTR *  ptattr;
    HRESULT     hr;
    BSTR        bstrName;

    pNode = NULL;
    hr = pti->GetTypeAttr(&ptattr);
    pti->GetDocumentation(-1, &bstrName, NULL, NULL, NULL);
    char * szName = TranscribeO2A( bstrName );
    LateBound_SysFreeString(bstrName);
    BOOL fExtractGuid = TRUE;

    switch(ptattr->typekind)
    {
    case TKIND_MODULE:
        pNode = new node_module();
        pNode->SetSymName(szName);
        // Add properties and methods
        AddMembers((MEMLIST *)((node_module *)pNode), ptattr, pti);
        break;

    case TKIND_DISPATCH:
        // The code under the if has never been run due to the bug in the condition.
        // The condition according to the comment below should read as in the next line.
        //
        // if ( ! (ptattr->wTypeFlags & (TYPEFLAG_FOLEAUTOMATION | TYPEFLAG_FDUAL)) )
        //
        // However, fixing the line according to the original intentions brought in 
        // a regression because the code paths have changed.
        // Hence, this has been commented out as a workaround for the VC 5.0 release
        // to force the code to execute like previously.
        //
/*
      if ( 0 == ptattr->wTypeFlags & (TYPEFLAG_FOLEAUTOMATION | TYPEFLAG_FDUAL) )
            {
            pNode = new node_dispinterface();
            pNode->SetSymName(szName);
            // Ignore impltypes, add properties and methods
            AddMembers((MEMLIST *)((node_dispinterface *)pNode), ptattr, pti);
            break;
            }
*/

        // if TYPEFLAG_FOLEAUTOMATION or TYPEFLAG_FDUAL is set,
        // erase it's impltype (which will be IDispatch since it is
        // really a dispinterface) then fall through and treat it as a
        // normal interface

        ptattr->cImplTypes = 0;

        // fall through

    case TKIND_INTERFACE:
        {
            pNode = new node_interface();

            // consider processing all attributes
            if ( ( ptattr->wTypeFlags & ( TYPEFLAG_FOLEAUTOMATION | TYPEFLAG_FDUAL ) ) != 0 )
                {
                ( ( node_interface* ) pNode )->HasOLEAutomation( TRUE );
                }
            pNode->SetSymName(szName);
            // Add impltype as base interface reference
            if (ptattr->cImplTypes)
            {
                ITypeInfo * ptiRef;
                HREFTYPE hrt;
                hr = pti->GetRefTypeOfImplType(0, &hrt);
                hr = pti->GetRefTypeInfo(hrt, &ptiRef);
                if (FAILED(hr))
                {
                    TypeinfoError(hr);
                }
                node_interface_reference * pir =
                    new node_interface_reference((node_interface *)GetNode(ptiRef));
                int implflags;
                hr = pti->GetImplTypeFlags(0, &implflags);
                if (implflags & IMPLTYPEFLAG_FDEFAULT)
                {
                    pir->SetAttribute(ATTR_DEFAULT);
                }
                if (implflags & IMPLTYPEFLAG_FSOURCE)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_SOURCE));
                }
                if (implflags & IMPLTYPEFLAG_FDEFAULTVTABLE)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_DEFAULTVTABLE));
                }
                if (implflags & IMPLTYPEFLAG_FRESTRICTED)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_RESTRICTED));
                }
                ((node_interface *)pNode)->SetMyBaseInterfaceReference(pir);
                ptiRef->Release();
                // NOTE - Multiple inheritance is not supported.
            }
            else
            {
                if (0 == _stricmp(szName, "IUnknown"))
                    ((node_interface *)pNode)->SetValidRootInterface();
            }
            // Add properties and methods as children
            AddMembers((MEMLIST *)((node_interface *)pNode), ptattr, pti);
        }
        break;

    case TKIND_COCLASS:
        pNode = new node_coclass();
        pNode->SetSymName(szName);
        // Add impltypes
        {
            unsigned cImplTypes = ptattr->cImplTypes;
            while (cImplTypes--)
            {
                ITypeInfo * ptiRef;
                HREFTYPE hrt;
                hr = pti->GetRefTypeOfImplType(cImplTypes, &hrt);
                hr = pti->GetRefTypeInfo(hrt, &ptiRef);
                if (FAILED(hr))
                {
                    TypeinfoError(hr);
                }
                node_interface_reference * pir =
                    new node_interface_reference((node_interface *)GetNode(ptiRef));
                int implflags;
                hr = pti->GetImplTypeFlags(cImplTypes, &implflags);
                if (implflags & IMPLTYPEFLAG_FDEFAULT)
                {
                    pir->SetAttribute(ATTR_DEFAULT);
                }
                if (implflags & IMPLTYPEFLAG_FSOURCE)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_SOURCE));
                }
                if (implflags & IMPLTYPEFLAG_FDEFAULTVTABLE)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_DEFAULTVTABLE));
                }
                if (implflags & IMPLTYPEFLAG_FRESTRICTED)
                {
                    pir->SetAttribute(new node_member_attr(MATTR_RESTRICTED));
                }
                ((node_coclass *)pNode)->AddFirstMember(pir);
                ptiRef->Release();
            }
        }
        break;

    case TKIND_ALIAS:
        pNode = new node_def(szName);
        // add the type as a child
        pNode->SetChild(GetNodeFromTYPEDESC(ptattr->tdescAlias, pti));
        pNode->SetAttribute(new node_type_attr(TATTR_PUBLIC));
        fExtractGuid = FALSE;
        break;

    case TKIND_ENUM:
        pNode = new node_enum(szName);
        // add enumeration fields
        AddMembers((MEMLIST *)((node_enum *)pNode), ptattr, pti);
        fExtractGuid = FALSE;
        ( ( node_enum * ) pNode )->SetZeePee( ptattr->cbAlignment );
        break;

    case TKIND_RECORD:
        pNode = new node_struct(szName);
        // add members
        AddMembers((MEMLIST *)((node_struct *)pNode), ptattr, pti);
        fExtractGuid = FALSE;
        ( ( node_struct * ) pNode )->SetZeePee( ptattr->cbAlignment );
        break;

    case TKIND_UNION:
        pNode = new node_union(szName);
        // add members
        AddMembers((MEMLIST *)((node_union *)pNode), ptattr, pti);
        fExtractGuid = FALSE;
        ( ( node_union * ) pNode )->SetZeePee( ptattr->cbAlignment );
        break;

    default:
        MIDL_ASSERT(!"Illegal TKIND");
        break;
    }
    // make sure that all the TYPEDESC flags are preserved
    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(ptattr->wTypeFlags), ATTR_TYPEDESCATTR));
    // and set each individual flag that we know about as of this writing
    if (ptattr->wTypeFlags & TYPEFLAG_FLICENSED)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_LICENSED));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FAPPOBJECT)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_APPOBJECT));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FCONTROL)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_CONTROL));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FDUAL)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_DUAL));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FPROXY)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_PROXY));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FNONEXTENSIBLE)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_NONEXTENSIBLE));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FOLEAUTOMATION)
    {
        pNode->SetAttribute(new node_type_attr(TATTR_OLEAUTOMATION));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FRESTRICTED)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_RESTRICTED));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FPREDECLID)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_PREDECLID));
    }
    if (ptattr->wTypeFlags & TYPEFLAG_FHIDDEN)
    {
        pNode->SetAttribute(ATTR_HIDDEN);
    }
    if (fExtractGuid)
    {
        char * szGuid = GetStringFromGuid(ptattr->guid);
        pNode->SetAttribute(new node_guid(szGuid));
    }
    pti->ReleaseTypeAttr(ptattr);
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetNodeFromTYPEDESC
//
//  Synopsis:   Returns part of a type graph from a TYPEDESC structure.
//
//  Arguments:  [tdesc] - the TYPEDESC
//              [pti]   - the type info from which the TYPEDESC was retrieved
//
//  Returns:    type graph node
//
//  History:    5-02-95   stevebl   Created
//
//  Notes:      There are currently a couple of problem base types:
//              VT_CY, VT_BSTR, VT_VARIANT, VT_DISPATCH, and VT_UNKNOWN.
//
//              These types are currently expanded by looking them up in the
//              global symbol table.  This works because currently oaidl.idl
//              is always imported when an ODL library statement is
//              ecountered.  It would be nice to be able to remove our
//              dependancy on oaidl.idl but before we can do that, we need to
//              reimplement this code to expand these types in another way.
//              (NOTE that because these are BASE TYPES in ODL, there is no
//              way to place their definitions in a type library.  This means
//              that it is not sufficient to simply get their definitions
//              from some standard type library such as STDLIB.TLB.)
//
//----------------------------------------------------------------------------

node_skl * NODE_MANAGER::GetNodeFromTYPEDESC(TYPEDESC tdesc, ITypeInfo * pti)
{
    node_skl * pReturn = NULL;
    switch (tdesc.vt)
    {
    // base types
    case VT_I2:
        pReturn = new node_base_type(NODE_SHORT, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("short");
        break;
    case VT_I4:
        pReturn = new node_base_type(NODE_LONG, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("long");
        break;
    case VT_R4:
        pReturn = new node_base_type(NODE_FLOAT, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("float");
        break;
    case VT_R8:
        pReturn = new node_base_type(NODE_DOUBLE, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("double");
        break;
    case VT_I1:
        pReturn = new node_base_type(NODE_CHAR, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("char");
        break;
    case VT_UI1:
        pReturn = new node_base_type(NODE_CHAR, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("char");
        break;
    case VT_UI2:
        pReturn = new node_base_type(NODE_SHORT, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("short");
        break;
    case VT_UI4:
        pReturn = new node_base_type(NODE_LONG, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("long");
        break;
    case VT_I8:
        pReturn = new node_base_type(NODE_INT64, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("int64");
        break;
    case VT_UI8:
        pReturn = new node_base_type(NODE_INT64, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("int64");
        break;
    case VT_INT:
        pReturn = new node_base_type(NODE_INT, ATTR_SIGNED);
        ((named_node *)pReturn)->SetSymName("INT");
        break;
    case VT_UINT:
        pReturn = new node_base_type(NODE_INT, ATTR_UNSIGNED);
        ((named_node *)pReturn)->SetSymName("UINT");
        break;
    case VT_VOID:
        pReturn = new node_base_type(NODE_VOID, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("void");
        break;
    case VT_BOOL:
        pReturn = new node_base_type(NODE_BOOLEAN, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("BOOLEAN");
        break;
    // simple ODL base types (not base types in IDL)
    case VT_HRESULT:
        pReturn = new node_base_type(NODE_SHORT, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("HRESULT");
        break;
    case VT_DATE:
        pReturn = new node_base_type(NODE_LONGLONG, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("DATE");
        break;
    case VT_LPSTR:
        pReturn = new node_base_type(NODE_LONGLONG, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("LPSTR");
        break;
    case VT_LPWSTR:
        pReturn = new node_base_type(NODE_LONGLONG, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("LPWSTR");
        break;
    case VT_ERROR:
        pReturn = new node_base_type(NODE_INT64, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("SCODE");
        break;
    // complex ODL base types
    case VT_DECIMAL:
        {
            SymKey key("DECIMAL", NAME_DEF);
            pReturn = pBaseSymTbl->SymSearch(key);
        }
        break;
    case VT_CY:
        {
            SymKey key("CURRENCY", NAME_DEF);
            pReturn = pBaseSymTbl->SymSearch(key);
        }
        break;
    case VT_BSTR:
        {
            SymKey key("BSTR", NAME_DEF);
            pReturn = pBaseSymTbl->SymSearch(key);
        }
        break;
    case VT_VARIANT:
        {
            SymKey key("VARIANT", NAME_DEF);
            pReturn = pBaseSymTbl->SymSearch(key);
        }
        break;
    case VT_DISPATCH:
        {
            SymKey key("IDispatch", NAME_DEF);
            pReturn = new node_pointer(pBaseSymTbl->SymSearch(key));
        }
        break;
    case VT_UNKNOWN:
        {
            SymKey key("IUnknown", NAME_DEF);
            pReturn = new node_pointer(pBaseSymTbl->SymSearch(key));
        }
        break;
    // complex types
    case VT_PTR:
        pReturn = new node_pointer(GetNodeFromTYPEDESC(*(tdesc.lptdesc), pti));
        break;
    case VT_SAFEARRAY:
        pReturn = new node_safearray(GetNodeFromTYPEDESC(*(tdesc.lptdesc), pti));
        break;
    case VT_CARRAY:
        {
            node_skl * pCurrent = NULL;
            node_skl * pPrev = NULL;
            for (int i = 0; i < tdesc.lpadesc->cDims; i++)
            {
                pCurrent = new node_array(
                    new expr_constant(tdesc.lpadesc->rgbounds[i].lLbound),
                    new expr_constant((tdesc.lpadesc->rgbounds[i].cElements
                                      + tdesc.lpadesc->rgbounds[i].lLbound) - 1 )
                    );
                if (pPrev)
                {
                    pPrev->SetChild(pCurrent);
                }
                else
                {
                    pReturn = pCurrent;
                }
                pPrev = pCurrent;
            }
            if (pCurrent)
                (pCurrent)->SetChild(GetNodeFromTYPEDESC(tdesc.lpadesc->tdescElem, pti));
        }
        break;
    case VT_USERDEFINED:
        {
            ITypeInfo * pRef;
            HRESULT hr = pti->GetRefTypeInfo(tdesc.hreftype, &pRef);
            if (FAILED(hr))
            {
                TypeinfoError(hr);
            }
            node_skl* pNode = GetNode(pRef);
            NODE_T nk = pNode->NodeKind();
            if ( nk == NODE_INTERFACE_REFERENCE || nk == NODE_INTERFACE )
                {
                pReturn = new node_interface_reference( (node_interface *) pNode );
                }
            else
               {
               pReturn = pNode;
               }
            pRef->Release();
        }
        break;
    default:
        MIDL_ASSERT(!"Illegal variant type found in a TYPEDESC");
        break;
    }
    if (pReturn && (pReturn->NodeKind() == NODE_DEF) &&
        pReturn->GetChild() &&
        (pReturn->GetChild()->NodeKind() == NODE_FORWARD))
    {
        node_forward * pFwd = (node_forward *) pReturn->GetChild();
        node_skl * pNewSkl = pFwd->ResolveFDecl();
        if (pNewSkl)
        {
            pReturn = new node_def_fe(pReturn->GetSymName(), pNewSkl);
        }
    }
    return pReturn;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::AddMembers
//
//  Synopsis:   Generic routine to add type graph elements for variables and
//              functions to a type graph element.
//
//  Arguments:  [pNode]  - pointer to the parent type graph node's MEMLIST
//              [ptattr] - pointer to the parent type info's TYPEATTR struct
//              [pti]    - pointer to the parent type info
//
//  Returns:    nothing
//
//  Modifies:   adds each new node to the MEMLIST referred to by pNode
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void NODE_MANAGER::AddMembers(MEMLIST * pNode, TYPEATTR * ptattr, ITypeInfo * pti)
{
    HRESULT hr;
    named_node * pNew;
    unsigned i = ptattr->cFuncs;
    while (i--)
    {
        FUNCDESC *pfdesc;
        hr = pti->GetFuncDesc(i, &pfdesc);
        pNew = GetNodeFromFUNCDESC(*pfdesc, pti);
        pNode->AddFirstMember(pNew);
        pti->ReleaseFuncDesc(pfdesc);
    }
    i = ptattr->cVars;
    while (i--)
    {
        VARDESC * pvdesc;
        hr = pti->GetVarDesc(i, &pvdesc);
        pNew = GetNodeFromVARDESC(*pvdesc, pti);
        pNode->AddFirstMember(pNew);
        pti->ReleaseVarDesc(pvdesc);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetNodeFromVARDESC
//
//  Synopsis:   gets a type graph node from a VARDESC
//
//  Arguments:  [vdesc] - VARDESC describing the variable
//              [pti]   - type info containing the VARDESC
//
//  Returns:    type graph node describing the varible
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

named_node * NODE_MANAGER::GetNodeFromVARDESC(VARDESC vdesc, ITypeInfo * pti)
{
    BSTR        bstrName;
    unsigned    cNames;

    pti->GetNames(vdesc.memid, &bstrName, 1, &cNames);
    char *  szName = TranscribeO2A( bstrName );
    LateBound_SysFreeString(bstrName);

    named_node *pNode;
    if (vdesc.varkind == VAR_CONST)
    {
        expr_node * pExpr = GetValueOfConstant(vdesc.lpvarValue);
        pNode = new node_label(szName, pExpr);
    }
    else
    {
        pNode = new node_field(szName);
    }
    pNode->SetBasicType(GetNodeFromTYPEDESC(vdesc.elemdescVar.tdesc, pti));
    SetIDLATTRS(pNode, vdesc.elemdescVar.idldesc);
    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(vdesc.wVarFlags), ATTR_VARDESCATTR));
    if (vdesc.wVarFlags == VARFLAG_FREADONLY)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_READONLY));
    }
    if (vdesc.wVarFlags == VARFLAG_FSOURCE)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_SOURCE));
    }
    if (vdesc.wVarFlags == VARFLAG_FBINDABLE)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_BINDABLE));
    }
    if (vdesc.wVarFlags == VARFLAG_FDISPLAYBIND)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_DISPLAYBIND));
    }
    if (vdesc.wVarFlags == VARFLAG_FDEFAULTBIND)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_DEFAULTBIND));
    }
    if (vdesc.wVarFlags == VARFLAG_FREQUESTEDIT)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_REQUESTEDIT));
    }
    if (vdesc.wVarFlags == VARFLAG_FHIDDEN)
    {
        pNode->SetAttribute(ATTR_HIDDEN);
    }

    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(vdesc.memid), ATTR_ID ));

    return pNode;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetNodeFromFUNCDESC
//
//  Synopsis:   gets a type graph node from a FUNCDESC
//
//  Arguments:  [fdesc] - FUNCDESC describing the function
//              [pti]   - type info containing the FUNCDESC
//
//  Returns:    type graph node describing the function
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

named_node * NODE_MANAGER::GetNodeFromFUNCDESC(FUNCDESC fdesc, ITypeInfo *pti)
{
    node_proc * pNode = new node_proc(ImportLevel, FALSE);

    BSTR  * rgbstrName = new BSTR [fdesc.cParams + 1];

    unsigned cNames;
    pti->GetNames(fdesc.memid, rgbstrName, fdesc.cParams + 1, &cNames);
    char *   szName = TranscribeO2A( rgbstrName[0] );
    LateBound_SysFreeString( rgbstrName[0] );
    pNode->SetSymName(szName);

    if (fdesc.invkind == DISPATCH_PROPERTYGET 
        || fdesc.funckind == FUNC_DISPATCH 
        || (fdesc.elemdescFunc.paramdesc.wParamFlags & PARAMFLAG_FRETVAL) != 0)
    {
        /*
         * Functions with the DISPATCH_PROPERTYGET attribute are special cases.
         * Their return values in the type graph are always of type HRESULT.
         * The last parameter of the function (after those listed in the fdesc)
         * is a pointer to the return type listed in the fdesc and it has
         * the OUT and RETVAL attributes.
         */
        node_skl* pChild = new node_pointer(GetNodeFromTYPEDESC(fdesc.elemdescFunc.tdesc, pti));
        node_param * pParam = new node_param();
        pChild->GetModifiers().SetModifier( ATTR_TAGREF );
        pParam->SetSymName("retval");
        pParam->SetChild( pChild );
        pParam->SetAttribute(ATTR_OUT);
        pParam->SetAttribute(new node_member_attr(MATTR_RETVAL));
        // add the [retval] parameter at the end of the parameter list
        // (the parameter list is currently empty and the other parameters
        // will be added in front of this one in reverse order so that's why
        // we use AddFirstMember)
        pNode->AddFirstMember(pParam);
        node_skl * pReturn = new node_base_type(NODE_SHORT, ATTR_NONE);
        ((named_node *)pReturn)->SetSymName("HRESULT");
        pNode->SetChild(pReturn);
    }
    else
    {
        node_skl* pChild = GetNodeFromTYPEDESC(fdesc.elemdescFunc.tdesc, pti);
        pNode->SetChild( pChild );
        NODE_T nk = pChild->NodeKind();
        if (nk == NODE_POINTER || nk == NODE_DEF)
            {
            pChild->GetModifiers().SetModifier( ATTR_TAGREF );
            }
    }
    unsigned cParams = fdesc.cParams;
    unsigned cParamsOpt = fdesc.cParamsOpt;
    while (cParams--)
    {
        node_param * pParam = new node_param();
        if (cParams + 1 < cNames)
        {
            szName = TranscribeO2A( rgbstrName[ cParams + 1] );
            pParam->SetSymName(szName);
            LateBound_SysFreeString(rgbstrName[cParams + 1]);
        }
        else
            pParam->SetSymName("noname");

        pParam->SetChild(GetNodeFromTYPEDESC(fdesc.lprgelemdescParam[cParams].tdesc, pti));
        SetIDLATTRS(pParam, fdesc.lprgelemdescParam[cParams].idldesc);
        if (cParamsOpt)
        {
            cParamsOpt--;
            pParam->SetAttribute(new node_member_attr(MATTR_OPTIONAL));
        }
        if (pParam && pParam->GetChild())
            {
            NODE_T nk = pParam->GetChild()->NodeKind();
            if (nk == NODE_POINTER || nk == NODE_DEF)
                {
                pParam->GetChild()->GetModifiers().SetModifier( ATTR_TAGREF );
                }
            }
        pNode->AddFirstMember(pParam);
    }

    delete[]rgbstrName;

    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(fdesc.wFuncFlags), ATTR_FUNCDESCATTR));
    if (fdesc.wFuncFlags == FUNCFLAG_FRESTRICTED)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_RESTRICTED));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FSOURCE)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_SOURCE));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FBINDABLE)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_BINDABLE));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FDISPLAYBIND)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_DISPLAYBIND));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FDEFAULTBIND)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_DEFAULTBIND));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FREQUESTEDIT)
    {
        pNode->SetAttribute(new node_member_attr(MATTR_REQUESTEDIT));
    }
    if (fdesc.wFuncFlags == FUNCFLAG_FHIDDEN)
    {
        pNode->SetAttribute(ATTR_HIDDEN);
    }
    if (fdesc.invkind == DISPATCH_PROPERTYGET)
    {
        szName = pNode->GetSymName();
        char * szNewName = new char[strlen(szName) + 5];
        sprintf(szNewName , "get_%s", szName);
        pNode->SetSymName(szNewName);
        pNode->SetAttribute(new node_member_attr(MATTR_PROPGET));
    }
    else if (fdesc.invkind == DISPATCH_PROPERTYPUT)
    {
        szName = pNode->GetSymName();
        char * szNewName = new char[strlen(szName) + 5];
        sprintf(szNewName , "put_%s", szName);
        pNode->SetSymName(szNewName);
        pNode->SetAttribute(new node_member_attr(MATTR_PROPPUT));
    }
    else if (fdesc.invkind == DISPATCH_PROPERTYPUTREF)
    {
        szName = pNode->GetSymName();
        char * szNewName = new char[strlen(szName) + 8];
        sprintf(szNewName , "putref_%s", szName);
        pNode->SetSymName(szNewName);
        pNode->SetAttribute(new node_member_attr(MATTR_PROPPUTREF));
    }

    pNode->GetModifiers().SetModifier( ATTR_TAGREF );
    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(fdesc.memid), ATTR_ID ));

    return pNode;
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::SetIDLATTRS
//
//  Synopsis:   Adds IDL attributes to a type graph node
//
//  Arguments:  [pNode]   - pointer to the type graph node
//              [idldesc] - IDLDESC containing the IDL attributes
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

void NODE_MANAGER::SetIDLATTRS(named_node * pNode, IDLDESC idldesc)
{
    pNode->SetAttribute(new node_constant_attr(
        new expr_constant(idldesc.wIDLFlags), ATTR_IDLDESCATTR));
    if (idldesc.wIDLFlags & IDLFLAG_FIN)
    {
        pNode->SetAttribute(ATTR_IN);
    }
    if (idldesc.wIDLFlags & IDLFLAG_FOUT)
    {
        pNode->SetAttribute(ATTR_OUT);
    }
    if (idldesc.wIDLFlags & IDLFLAG_FLCID)
    {
        pNode->SetAttribute(ATTR_FLCID);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     NODE_MANAGER::GetValueOfConstant
//
//  Synopsis:   creates an expr_constant node from a VARIANT
//
//  Arguments:  [pVar] - pointer to the variant containing the constant
//
//  Returns:    expr_node describing the constant expression
//
//  History:    5-02-95   stevebl   Created
//
//----------------------------------------------------------------------------

expr_node * NODE_MANAGER::GetValueOfConstant(VARIANT * pVar)
{
    expr_node * pReturn;
    switch(pVar->vt)
    {
    case VT_UI1:
        pReturn = new expr_constant(pVar->bVal);
        break;
    case VT_BOOL:
    case VT_I2:
        pReturn = new expr_constant(pVar->iVal);
        break;
    case VT_I4:
        pReturn = new expr_constant(pVar->lVal);
        break;
    case VT_R4:
        pReturn = new expr_constant(pVar->fltVal);
        break;
    case VT_R8:
        pReturn = new expr_constant(pVar->dblVal);
        break;
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_ERROR:
    case VT_UNKNOWN:
    case VT_VARIANT:
    case VT_DISPATCH:
    default:
        // This case is currently illegal in every situation that I am
        // aware of.  However, just in case this ever changes, (and since
        // it is possible to handle this situation even though it may be
        // illeagal) I'll go ahead and allow it anyway.  The alternative
        // would be to choke on it and put out an error message.

        // FUTURE - perhaps display a warning here

        pReturn = new expr_constant(pVar->lVal);
        break;
    }
    return pReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTypeLibraryList::AddTypeLibraryMembers
//
//  Synopsis:   Adds each of a type library's members to the global symbol
//              table as a node_href.  If another symbol with the same name
//              already exists in the table, then no node will be added
//              for that member.
//
//  Arguments:  [ptl]        - type library pointer
//              [szFileName] - name of the file containing the type library
//
//  History:    5-02-95   stevebl   Created
//
//  Notes:      Typeinfos added to the global symbol table in this manner are
//              not parsed and expanded into their type graphs at this time;
//              type info expansion occurs during the semantic pass.
//
//----------------------------------------------------------------------------

void CTypeLibraryList::AddTypeLibraryMembers(ITypeLib * ptl, char * szFileName)
{
    unsigned int    nMem = ptl->GetTypeInfoCount();
    BSTR            bstrName;
    HRESULT         hr;
    ITypeInfo *     pti;
    char *          sz;
    node_file *     pFile = new node_file(szFileName, 1);

    while (nMem--)
    {
        hr = ptl->GetDocumentation(nMem, &bstrName, NULL, NULL, NULL);
        if (FAILED(hr))
        {
            TypelibError(szFileName, hr);
        }

        sz = TranscribeO2A( bstrName );
        LateBound_SysFreeString(bstrName);

        NAME_T type;
        TYPEKIND tkind;
        hr = ptl->GetTypeInfoType(nMem, &tkind);
        if (FAILED(hr))
       {
            TypelibError(szFileName, hr);
        }

        if (!pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        {        
            switch (tkind)
            {
            case TKIND_ENUM:
                type = NAME_ENUM;
                break;
            case TKIND_UNION:
                type = NAME_UNION;
                break;
            case TKIND_RECORD:
                type = NAME_TAG;
                break;
            default:
                type = NAME_DEF;
                break;
            }
        }
        else
        {    
            type = NAME_DEF;
        }
        SymKey key(sz, type);
        if (!pBaseSymTbl->SymSearch(key))
        {
            hr = ptl->GetTypeInfo(nMem, &pti);
            if (FAILED(hr))
            {
                TypelibError(szFileName, hr);
            }
            pItfList->Add(pti, sz);
            node_href * pref = new node_href(key, pBaseSymTbl, pti, pFile);
            pref->SetSymName(sz);
            pBaseSymTbl->SymInsert(key, NULL, pref);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   AddQualifiedReferenceToType
//
//  Synopsis:   Verifies that a library contains a given type and returns
//              a typegraph node pointer to the type.
//
//  Arguments:  [szLibrary] - name of the library (_NOT_ the TLB file)
//              [szType]    - name of the type to be referenced
//
//  Returns:    a node_href * to the referenced type.
//              If the type isn't found to exist in the given library then
//              this routine returns NULL.
//
//  History:    12-20-95   stevebl   Created
//
//  Notes:      These types are not added to the global symbol table.
//              They are also not parsed and expanded into their complete
//              type graphs at this time; type info expansion occurs
//              during the semantic pass.
//
//----------------------------------------------------------------------------

void * AddQualifiedReferenceToType(char * szLibrary, char * szType)
{
    return gtllist.AddQualifiedReferenceToType(szLibrary, szType);
}

void * CTypeLibraryList::AddQualifiedReferenceToType(char * szLibrary, char * szType)
{
    ITypeLib * pTL = FindLibrary(szLibrary);
    if (NULL != pTL)
    {
        node_file * pFile = new node_file(szLibrary, 1);
        WCHAR *     wsz = TranscribeA2O( szType );
        ITypeInfo * ptiFound;
        SYSKIND sk = ( SYSKIND ) ( pCommand->Is64BitEnv() ? SYS_WIN64 : SYS_WIN32 );
        ULONG       lHashVal = LateBound_LHashValOfNameSys(sk, NULL, wsz);
        HRESULT     hr;
        MEMBERID    memid;
        unsigned short c;
        c = 1;
        hr = pTL->FindName(wsz, lHashVal, &ptiFound, &memid, &c);
        if (SUCCEEDED(hr))
        {
            if (c)
            {
                if (-1 == memid)
                {
                    // found a matching name
                    NAME_T type;
                    TYPEATTR * ptattr;
                    hr = ptiFound->GetTypeAttr(&ptattr);
                    if (FAILED(hr))
                    {
                        TypeinfoError(hr);
                    }

                    if (!pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
                    {        
                        switch (ptattr->typekind)
                        {
                        case TKIND_ENUM:
                            type = NAME_ENUM;
                            break;
                        case TKIND_UNION:
                            type = NAME_UNION;
                            break;
                        case TKIND_RECORD:
                            type = NAME_TAG;
                            break;
                        default:
                            type = NAME_DEF;
                        break;
                        }
                    }
                    else
                    {
                        type = NAME_DEF;
                    }
                    ptiFound->ReleaseTypeAttr(ptattr);
                    pItfList->Add(ptiFound, szType);
                    SymKey key(szType, type);
                    node_href * pref = new node_href(key, pBaseSymTbl, ptiFound, pFile);
                    return pref;
                }
                // found a parameter name or some other non-global name
                ptiFound->Release();
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\inc\tokntbl.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    tokntbl.h

Abstract :

    This file contains the template for the token tables used in marshalling,
    unmarshalling, memsizeing, buffersizing, freeing, and type attributes.
    
Author :

    Mike Zoran  mzoran   March 2000.

Revision History :

  ---------------------------------------------------------------------*/

// The following macros need to be defined by users of this table
// 
// NDR64_BEGIN_TABLE -- Begining of the table
// NDR64_TABLE_END   -- End of table
// NDR64_ZERO_ENTRY  -- First entry in the table
// NDR64_TABLE_ENTRY( number, tokenname,
//                    marshal, embeddedmarshal,
//                    unmarshal, embeddedunmarshal,
//                    buffersize, embeddedbuffersize,
//                    memsize, embeddedmemsize,
//                    free, embeddedfree,
//                    typeflags )
// NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname,
//                                simpletypebuffersize,
//                                simpletypememorysize )
// NDR64_UNUSED_TABLE_ENTRY( number, tokenname )
// NDR64_UNUSED_TABLE_ENTRY_NOSYM( number )
// 

NDR64_BEGIN_TABLE

// Simple Types

NDR64_ZERO_ENTRY
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x1, FC64_UINT8, 1, 1 )
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x2, FC64_INT8, 1, 1 ) 
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x3, FC64_UINT16, 2, 2 )
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x4, FC64_INT16, 2, 2 )          
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x5, FC64_INT32, 4, 4 )          
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x6, FC64_UINT32, 4, 4  )          
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x7, FC64_INT64, 8, 8  )          
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x8, FC64_UINT64, 8, 8 )
NDR64_UNUSED_TABLE_ENTRY( 0x9, FC64_INT128 )       
NDR64_UNUSED_TABLE_ENTRY( 0xA, FC64_UINT128 )
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0xB, FC64_FLOAT32, 4, 4 )
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0xC, FC64_FLOAT64, 8, 8 )
NDR64_UNUSED_TABLE_ENTRY( 0xD, FC64_FLOAT80 )
NDR64_UNUSED_TABLE_ENTRY( 0xE, FC64_FLOAT128 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF )

NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x10, FC64_CHAR, 1, 1 )                                   
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x11, FC64_WCHAR, 2, 2 )               
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x12, FC64_IGNORE, sizeof(NDR64_PTR_WIRE_TYPE), PTR_MEM_SIZE ) 
NDR64_SIMPLE_TYPE_TABLE_ENTRY( 0x13, FC64_ERROR_STATUS_T, 4, 4 ) 
NDR64_UNUSED_TABLE_ENTRY( 0x14, FC64_POINTER )               
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x15 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x16 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x17 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x18 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x19 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x1F )

// Pointers

NDR64_TABLE_ENTRY( 0x20, FC64_RP,
                   Ndr64TopLevelPointerMarshall,   Ndr64EmbeddedPointerMarshall,
                   Ndr64TopLevelPointerUnmarshall, Ndr64EmbeddedPointerUnmarshall,
                   Ndr64TopLevelPointerBufferSize, Ndr64EmbeddedPointerBufferSize,
                   Ndr64TopLevelPointerMemorySize, Ndr64EmbeddedPointerMemorySize,
                   Ndr64TopLevelPointerFree,       Ndr64EmbeddedPointerFree,     
                   _BASIC_POINTER_ | _POINTER_ )
NDR64_TABLE_ENTRY( 0x21, FC64_UP,
                   Ndr64TopLevelPointerMarshall,   Ndr64EmbeddedPointerMarshall,
                   Ndr64TopLevelPointerUnmarshall, Ndr64EmbeddedPointerUnmarshall,
                   Ndr64TopLevelPointerBufferSize, Ndr64EmbeddedPointerBufferSize,
                   Ndr64TopLevelPointerMemorySize, Ndr64EmbeddedPointerMemorySize,
                   Ndr64TopLevelPointerFree,       Ndr64EmbeddedPointerFree,     
                   _BASIC_POINTER_ | _POINTER_ )
NDR64_TABLE_ENTRY( 0x22, FC64_OP,
                   Ndr64TopLevelPointerMarshall,   Ndr64EmbeddedPointerMarshall, 
                   Ndr64TopLevelPointerUnmarshall, Ndr64EmbeddedPointerUnmarshall,
                   Ndr64TopLevelPointerBufferSize, Ndr64EmbeddedPointerBufferSize,
                   Ndr64TopLevelPointerMemorySize, Ndr64EmbeddedPointerMemorySize,
                   Ndr64TopLevelPointerFree,       Ndr64EmbeddedPointerFree,     
                   _BASIC_POINTER_ | _POINTER_ )
NDR64_TABLE_ENTRY( 0x23, FC64_FP,
                   Ndr64TopLevelPointerMarshall,   Ndr64EmbeddedPointerMarshall, 
                   Ndr64TopLevelPointerUnmarshall, Ndr64EmbeddedPointerUnmarshall,
                   Ndr64TopLevelPointerBufferSize, Ndr64EmbeddedPointerBufferSize,
                   Ndr64TopLevelPointerMemorySize, Ndr64EmbeddedPointerMemorySize,
                   Ndr64TopLevelPointerFree,       Ndr64EmbeddedPointerFree,     
                   _BASIC_POINTER_ | _POINTER_ )
NDR64_TABLE_ENTRY(  0x24, FC64_IP,
                    Ndr64TopLevelPointerMarshall,  Ndr64EmbeddedPointerMarshall,
                    Ndr64TopLevelPointerUnmarshall,Ndr64EmbeddedPointerUnmarshall,
                    Ndr64TopLevelPointerBufferSize,Ndr64EmbeddedPointerBufferSize,
                    Ndr64TopLevelPointerMemorySize,Ndr64EmbeddedPointerMemorySize,
                    Ndr64TopLevelPointerFree,      Ndr64EmbeddedPointerFree,
                    _POINTER_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x25 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x26 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x27 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x28 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x29 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x2F )

// Structures

NDR64_TABLE_ENTRY( 0x30, FC64_STRUCT,
                   Ndr64SimpleStructMarshall,      Ndr64SimpleStructMarshall,
                   Ndr64SimpleStructUnmarshall,    Ndr64SimpleStructUnmarshall,
                   Ndr64SimpleStructBufferSize,    Ndr64SimpleStructBufferSize,
                   Ndr64SimpleStructMemorySize,    Ndr64SimpleStructMemorySize,
                   Ndr64pNoopFree,                 Ndr64pNoopFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY( 0x31, FC64_PSTRUCT,
                   Ndr64SimpleStructMarshall,      Ndr64SimpleStructMarshall,
                   Ndr64SimpleStructUnmarshall,    Ndr64SimpleStructUnmarshall,
                   Ndr64SimpleStructBufferSize,    Ndr64SimpleStructBufferSize,
                   Ndr64SimpleStructMemorySize,    Ndr64SimpleStructMemorySize,
                   Ndr64SimpleStructFree,          Ndr64SimpleStructFree,
                   _STRUCT_ | _BY_VALUE_ )

NDR64_TABLE_ENTRY( 0x32, FC64_CONF_STRUCT,
                   Ndr64ConformantStructMarshall,      Ndr64ConformantStructMarshall,
                   Ndr64ConformantStructUnmarshall,    Ndr64ConformantStructUnmarshall,
                   Ndr64ConformantStructBufferSize,    Ndr64ConformantStructBufferSize,
                   Ndr64ConformantStructMemorySize,    Ndr64ConformantStructMemorySize,
                   Ndr64ConformantStructFree,          Ndr64ConformantStructFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY( 0x33, FC64_CONF_PSTRUCT,
                   Ndr64ConformantStructMarshall,      Ndr64ConformantStructMarshall,
                   Ndr64ConformantStructUnmarshall,    Ndr64ConformantStructUnmarshall,
                   Ndr64ConformantStructBufferSize,    Ndr64ConformantStructBufferSize,
                   Ndr64ConformantStructMemorySize,    Ndr64ConformantStructMemorySize,
                   Ndr64ConformantStructFree,          Ndr64ConformantStructFree,
                   _STRUCT_ | _BY_VALUE_ )

NDR64_TABLE_ENTRY( 0x34, FC64_BOGUS_STRUCT,
                   Ndr64ComplexStructMarshall,     Ndr64ComplexStructMarshall,
                   Ndr64ComplexStructUnmarshall,   Ndr64ComplexStructUnmarshall,
                   Ndr64ComplexStructBufferSize,   Ndr64ComplexStructBufferSize,
                   Ndr64ComplexStructMemorySize,   Ndr64ComplexStructMemorySize,
                   Ndr64ComplexStructFree,         Ndr64ComplexStructFree,
                   _STRUCT_ | _BY_VALUE_ )

NDR64_TABLE_ENTRY( 0x35, FC64_FORCED_BOGUS_STRUCT,
                   Ndr64ComplexStructMarshall,         Ndr64ComplexStructMarshall,
                   Ndr64ComplexStructUnmarshall,       Ndr64ComplexStructUnmarshall,
                   Ndr64ComplexStructBufferSize,       Ndr64ComplexStructBufferSize,
                   Ndr64ComplexStructMemorySize,       Ndr64ComplexStructMemorySize,
                   Ndr64ComplexStructFree,             Ndr64ComplexStructFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY( 0x36, FC64_CONF_BOGUS_STRUCT,
                   Ndr64ComplexStructMarshall,         Ndr64ComplexStructMarshall,
                   Ndr64ComplexStructUnmarshall,       Ndr64ComplexStructUnmarshall,
                   Ndr64ComplexStructBufferSize,       Ndr64ComplexStructBufferSize,
                   Ndr64ComplexStructMemorySize,       Ndr64ComplexStructMemorySize,
                   Ndr64ComplexStructFree,             Ndr64ComplexStructFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY( 0x37, FC64_FORCED_CONF_BOGUS_STRUCT,
                   Ndr64ComplexStructMarshall,         Ndr64ComplexStructMarshall,
                   Ndr64ComplexStructUnmarshall,       Ndr64ComplexStructUnmarshall,
                   Ndr64ComplexStructBufferSize,       Ndr64ComplexStructBufferSize,
                   Ndr64ComplexStructMemorySize,       Ndr64ComplexStructMemorySize,
                   Ndr64ComplexStructFree,             Ndr64ComplexStructFree,
                   _STRUCT_ | _BY_VALUE_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x38 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x39 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x3F )

// Arrays

NDR64_TABLE_ENTRY( 0x40, FC64_FIX_ARRAY,
                   Ndr64FixedArrayMarshall,        Ndr64FixedArrayMarshall,
                   Ndr64FixedArrayUnmarshall,      Ndr64FixedArrayUnmarshall,
                   Ndr64FixedArrayBufferSize,      Ndr64FixedArrayBufferSize,
                   Ndr64FixedArrayMemorySize,      Ndr64FixedArrayMemorySize,
                   Ndr64FixedArrayFree,            Ndr64FixedArrayFree,
                   _ARRAY_ )

NDR64_TABLE_ENTRY( 0x41, FC64_CONF_ARRAY,
                   Ndr64ConformantArrayMarshall,   Ndr64ConformantArrayMarshall,
                   Ndr64ConformantArrayUnmarshall, Ndr64ConformantArrayUnmarshall,
                   Ndr64ConformantArrayBufferSize, Ndr64ConformantArrayBufferSize,
                   Ndr64ConformantArrayMemorySize, Ndr64ConformantArrayMemorySize,
                   Ndr64ConformantArrayFree,       Ndr64ConformantArrayFree,
                   _ARRAY_ )

NDR64_TABLE_ENTRY( 0x42, FC64_VAR_ARRAY,
                   Ndr64VaryingArrayMarshall,      Ndr64VaryingArrayMarshall,
                   Ndr64VaryingArrayUnmarshall,    Ndr64VaryingArrayUnmarshall,
                   Ndr64VaryingArrayBufferSize,    Ndr64VaryingArrayBufferSize,
                   Ndr64VaryingArrayMemorySize,    Ndr64VaryingArrayMemorySize,
                   Ndr64VaryingArrayFree,          Ndr64VaryingArrayFree,
                   _ARRAY_ )

NDR64_TABLE_ENTRY( 0x43, FC64_CONFVAR_ARRAY,
                   Ndr64ConformantVaryingArrayMarshall,    Ndr64ConformantVaryingArrayMarshall,
                   Ndr64ConformantVaryingArrayUnmarshall,  Ndr64ConformantVaryingArrayUnmarshall,
                   Ndr64ConformantVaryingArrayBufferSize,  Ndr64ConformantVaryingArrayBufferSize,
                   Ndr64ConformantVaryingArrayMemorySize,  Ndr64ConformantVaryingArrayMemorySize,
                   Ndr64ConformantVaryingArrayFree,        Ndr64ConformantVaryingArrayFree,
                   _ARRAY_ )
NDR64_TABLE_ENTRY( 0x44, FC64_FIX_FORCED_BOGUS_ARRAY,
                   Ndr64ComplexArrayMarshall,        Ndr64ComplexArrayMarshall,
                   Ndr64ComplexArrayUnmarshall,      Ndr64ComplexArrayUnmarshall,
                   Ndr64ComplexArrayBufferSize,      Ndr64ComplexArrayBufferSize,
                   Ndr64ComplexArrayMemorySize,      Ndr64ComplexArrayMemorySize,
                   Ndr64ComplexArrayFree,            Ndr64ComplexArrayFree,
                   _ARRAY_ )
NDR64_TABLE_ENTRY( 0x45, FC64_FIX_BOGUS_ARRAY,
                   Ndr64ComplexArrayMarshall,        Ndr64ComplexArrayMarshall,
                   Ndr64ComplexArrayUnmarshall,      Ndr64ComplexArrayUnmarshall,
                   Ndr64ComplexArrayBufferSize,      Ndr64ComplexArrayBufferSize,
                   Ndr64ComplexArrayMemorySize,      Ndr64ComplexArrayMemorySize,
                   Ndr64ComplexArrayFree,            Ndr64ComplexArrayFree,
                   _ARRAY_ )
NDR64_TABLE_ENTRY( 0x46, FC64_FORCED_BOGUS_ARRAY,
                   Ndr64ComplexArrayMarshall,        Ndr64ComplexArrayMarshall,
                   Ndr64ComplexArrayUnmarshall,      Ndr64ComplexArrayUnmarshall,
                   Ndr64ComplexArrayBufferSize,      Ndr64ComplexArrayBufferSize,
                   Ndr64ComplexArrayMemorySize,      Ndr64ComplexArrayMemorySize,
                   Ndr64ComplexArrayFree,            Ndr64ComplexArrayFree,
                   _ARRAY_ )
NDR64_TABLE_ENTRY(  0x47, FC64_BOGUS_ARRAY,
                    Ndr64ComplexArrayMarshall,     Ndr64ComplexArrayMarshall,
                    Ndr64ComplexArrayUnmarshall,   Ndr64ComplexArrayUnmarshall,
                    Ndr64ComplexArrayBufferSize,   Ndr64ComplexArrayBufferSize,
                    Ndr64ComplexArrayMemorySize,   Ndr64ComplexArrayMemorySize,
                    Ndr64ComplexArrayFree,         Ndr64ComplexArrayFree,
                    _ARRAY_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x48 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x49 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x4F )

// Unions

NDR64_TABLE_ENTRY(  0x50, FC64_ENCAPSULATED_UNION,
                    Ndr64UnionMarshall,            Ndr64UnionMarshall,  
                    Ndr64UnionUnmarshall,          Ndr64UnionUnmarshall,
                    Ndr64UnionBufferSize,          Ndr64UnionBufferSize,
                    Ndr64UnionMemorySize,          Ndr64UnionMemorySize,
                    Ndr64UnionFree,                Ndr64UnionFree,
                    _UNION_ | _BY_VALUE_, )                                   
NDR64_TABLE_ENTRY(  0x51, FC64_NON_ENCAPSULATED_UNION,
                    Ndr64UnionMarshall,            Ndr64UnionMarshall,
                    Ndr64UnionUnmarshall,          Ndr64UnionUnmarshall,
                    Ndr64UnionBufferSize,          Ndr64UnionBufferSize,
                    Ndr64UnionMemorySize,          Ndr64UnionMemorySize,
                    Ndr64UnionFree,                Ndr64UnionFree,
                    _UNION_ | _BY_VALUE_, )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x52 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x53 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x54 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x55 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x56 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x57 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x58 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x59 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x5F )

// Strings

NDR64_TABLE_ENTRY( 0x60, FC64_CHAR_STRING,
                   Ndr64NonConformantStringMarshall,   Ndr64NonConformantStringMarshall,
                   Ndr64NonConformantStringUnmarshall, Ndr64NonConformantStringUnmarshall,
                   Ndr64NonConformantStringBufferSize, Ndr64NonConformantStringBufferSize,
                   Ndr64NonConformantStringMemorySize, Ndr64NonConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )
NDR64_TABLE_ENTRY( 0x61, FC64_WCHAR_STRING,
                   Ndr64NonConformantStringMarshall,   Ndr64NonConformantStringMarshall,
                   Ndr64NonConformantStringUnmarshall, Ndr64NonConformantStringUnmarshall,
                   Ndr64NonConformantStringBufferSize, Ndr64NonConformantStringBufferSize,
                   Ndr64NonConformantStringMemorySize, Ndr64NonConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )

NDR64_TABLE_ENTRY( 0x62, FC64_STRUCT_STRING,
                   Ndr64NonConformantStringMarshall,   Ndr64NonConformantStringMarshall,
                   Ndr64NonConformantStringUnmarshall, Ndr64NonConformantStringUnmarshall,
                   Ndr64NonConformantStringBufferSize, Ndr64NonConformantStringBufferSize,
                   Ndr64NonConformantStringMemorySize, Ndr64NonConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )

NDR64_TABLE_ENTRY( 0x63, FC64_CONF_CHAR_STRING,
                   Ndr64ConformantStringMarshall,      Ndr64ConformantStringMarshall,
                   Ndr64ConformantStringUnmarshall,    Ndr64ConformantStringUnmarshall,
                   Ndr64ConformantStringBufferSize,    Ndr64ConformantStringBufferSize,
                   Ndr64ConformantStringMemorySize,    Ndr64ConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )
NDR64_TABLE_ENTRY( 0x64, FC64_CONF_WCHAR_STRING,
                   Ndr64ConformantStringMarshall,      Ndr64ConformantStringMarshall,
                   Ndr64ConformantStringUnmarshall,    Ndr64ConformantStringUnmarshall,
                   Ndr64ConformantStringBufferSize,    Ndr64ConformantStringBufferSize,
                   Ndr64ConformantStringMemorySize,    Ndr64ConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )
NDR64_TABLE_ENTRY( 0x65, FC64_CONF_STRUCT_STRING,
                   Ndr64ConformantStringMarshall,      Ndr64ConformantStringMarshall,
                   Ndr64ConformantStringUnmarshall,    Ndr64ConformantStringUnmarshall,
                   Ndr64ConformantStringBufferSize,    Ndr64ConformantStringBufferSize,
                   Ndr64ConformantStringMemorySize,    Ndr64ConformantStringMemorySize,
                   Ndr64pNoopFree,                     Ndr64pNoopFree,
                   _STRING_ )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x66 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x67 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x68 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x69 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x6F )

// Handles

NDR64_TABLE_ENTRY(  0x70, FC64_BIND_CONTEXT,
                    Ndr64MarshallHandle,           Ndr64MarshallHandle,
                    Ndr64UnmarshallHandle,         Ndr64UnmarshallHandle,
                    Ndr64ContextHandleSize,        Ndr64ContextHandleSize,
                    NULL,                          NULL,
                    Ndr64pNoopFree,                Ndr64pNoopFree,
                    _HANDLE_ )                     
NDR64_TABLE_ENTRY(  0x71, FC64_BIND_GENERIC,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    Ndr64pNoopFree,                Ndr64pNoopFree,
                    _HANDLE_ )
NDR64_TABLE_ENTRY(  0x72, FC64_BIND_PRIMITIVE,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    NULL,                          NULL,
                    Ndr64pNoopFree,                Ndr64pNoopFree,
                    _HANDLE_ )

NDR64_UNUSED_TABLE_ENTRY( 0x73, FC64_AUTO_HANDLE )
NDR64_UNUSED_TABLE_ENTRY( 0x74, FC64_CALLBACK_HANDLE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x75 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x76 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x77 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x78 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x79 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x7F )

// Pointer Layout

NDR64_UNUSED_TABLE_ENTRY( 0x80, FC64_NO_REPEAT )
NDR64_UNUSED_TABLE_ENTRY( 0x81, FC64_FIXED_REPEAT )
NDR64_UNUSED_TABLE_ENTRY( 0x82, FC64_VARIABLE_REPEAT )
NDR64_UNUSED_TABLE_ENTRY( 0x83, FC64_FIXED_OFFSET )
NDR64_UNUSED_TABLE_ENTRY( 0x84, FC64_VARIABLE_OFFSET )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x85 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x86 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x87 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x88 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x89 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x8F )


// Member layout
NDR64_UNUSED_TABLE_ENTRY( 0x90, FC64_STRUCTPADN )
NDR64_UNUSED_TABLE_ENTRY( 0x91, FC64_EMBEDDED_COMPLEX )
NDR64_UNUSED_TABLE_ENTRY( 0x92, FC64_BUFFER_ALIGN )
NDR64_UNUSED_TABLE_ENTRY( 0x93, FC64_END )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x94 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x95 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x96 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x97 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x98 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x99 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9A )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9B )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9C )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9D )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9E )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0x9F )

// Misc
NDR64_TABLE_ENTRY(  0xA0, FC64_TRANSMIT_AS,
                    Ndr64TopLevelXmitOrRepAsMarshall,      Ndr64EmbeddedXmitOrRepAsMarshall,
                    Ndr64TopLevelXmitOrRepAsUnmarshall,    Ndr64EmbeddedXmitOrRepAsUnmarshall,
                    Ndr64TopLevelXmitOrRepAsBufferSize,    Ndr64EmbeddedXmitOrRepAsBufferSize,
                    Ndr64TopLevelXmitOrRepAsMemorySize,    Ndr64EmbeddedXmitOrRepAsMemorySize,
                    Ndr64XmitOrRepAsFree,                  Ndr64XmitOrRepAsFree,
                    _XMIT_AS_ | _BY_VALUE_ )
NDR64_TABLE_ENTRY(  0xA1, FC64_REPRESENT_AS,
                    Ndr64TopLevelXmitOrRepAsMarshall,      Ndr64EmbeddedXmitOrRepAsMarshall,
                    Ndr64TopLevelXmitOrRepAsUnmarshall,    Ndr64EmbeddedXmitOrRepAsUnmarshall,
                    Ndr64TopLevelXmitOrRepAsBufferSize,    Ndr64EmbeddedXmitOrRepAsBufferSize, 
                    Ndr64TopLevelXmitOrRepAsMemorySize,    Ndr64EmbeddedXmitOrRepAsMemorySize,
                    Ndr64XmitOrRepAsFree,                  Ndr64XmitOrRepAsFree,
                    _XMIT_AS_ | _BY_VALUE_ )

NDR64_TABLE_ENTRY( 0xA2, FC64_USER_MARSHAL,
                   Ndr64TopLevelUserMarshalMarshall,    Ndr64EmbeddedUserMarshalMarshall,
                   Ndr64TopLevelUserMarshalUnmarshall,  Ndr64EmbeddedUserMarshalUnmarshall,
                   Ndr64TopLevelUserMarshalBufferSize,  Ndr64EmbeddedUserMarshallBufferSize,
                   Ndr64TopLevelUserMarshalMemorySize,  Ndr64EmbeddedUserMarshalMemorySize,
                   Ndr64UserMarshalFree,                Ndr64UserMarshalFree,
                   _XMIT_AS_ | _BY_VALUE_ )
NDR64_UNUSED_TABLE_ENTRY( 0xA3, FC64_PIPE, )
NDR64_TABLE_ENTRY( 0xA4, FC64_RANGE,
                   Ndr64pRangeMarshall,            Ndr64pRangeMarshall,
                   Ndr64RangeUnmarshall,           Ndr64RangeUnmarshall,
                   Ndr64pRangeBufferSize,          Ndr64pRangeBufferSize,
                   Ndr64pRangeMemorySize,          Ndr64pRangeMemorySize,
                   Ndr64pRangeFree,                Ndr64pRangeFree,
                   0 )
NDR64_UNUSED_TABLE_ENTRY( 0xA5, FC64_PAD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xA6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xA7 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xA8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xA9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xAF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xB9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xBF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xC9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xCF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xD9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xDF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xE9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xED )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xEF )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF0 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF1 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF2 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF3 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF4 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF5 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF6 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF7 )

NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF8 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xF9 )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFA )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFB )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFC )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFD )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFE )
NDR64_UNUSED_TABLE_ENTRY_NOSYM( 0xFF )

NDR64_TABLE_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\support\freelist.cxx ===
/*************************************************************************/
/**             Copyright(c) Microsoft Corp., 1993-1999                 **/
/*************************************************************************/
/**************************************************************************
File            FreeListMgr.cxx
Title       :Get and Put functions for the MIDL compiler
History     :
    13-Apr-94   GregJen Created from freelist.hxx
**************************************************************************/

#pragma warning ( disable : 4201 )  // Unnamed struct/union
#pragma warning ( disable : 4514 )  // Unreferenced inline function

/************************************************************************* 
 ** includes                                                
 *************************************************************************/

#include "freelist.hxx"
#include <windef.h>         // REVIEW: Just give up and include windows.h?
#include <basetsd.h>

// checked compiler has list checking
#ifndef NDEBUG

// turn on the below flag to get checked freelist
#define LIST_CHECK

#endif

/************************************************************************* 
 ** definitions
 *************************************************************************/

// The user should see allocated memory aligned at LONG_PTR alignment.
// The allocator returns us memory with this alignment so make sure the
// signature preserves it.
typedef LONG_PTR HeapSignature;


#define USED_SIGNATURE( pMgr, pNode )       \
                 ( ((HeapSignature) pMgr) % ((HeapSignature) pNode) )

#define FREE_SIGNATURE( pMgr, pNode )       \
                 ( ((HeapSignature) pMgr) - ((HeapSignature) pNode) )
        
void * 
FreeListMgr::Get (size_t size)
    {
    void *  pEntry;
#ifdef LIST_CHECK
    HeapSignature   *   pSignature;
#endif
 
    /* Count this call (even if it fails).
     */

#ifndef NDEBUG
    GetCount++;
#endif

    /* Make sure the "size" requested is the same as the previous 
     * requests.
     */

    MIDL_ASSERT (size == element_size);

    /* Get an entry from the free-list, if the free-list is not empty */

    if (pHead != NULL)
        {
        pEntry  = pHead;
        pHead   = pHead->next;
#ifdef LIST_CHECK
        // check to make sure the entry is really OK
        // signature is before entry pointer
        // signature of free nodes is ( &mgr - &node )
        // signature of used nodes is ( &mgr % &node )
        pSignature = ((HeapSignature *)pEntry)-1;

        MIDL_ASSERT( *pSignature == FREE_SIGNATURE( this, pEntry ) );

        *pSignature = USED_SIGNATURE( this, pEntry );
        memset( pEntry, 0xB3, size );
#endif
        return (void *) pEntry;
        }

    /* Get it from the allocator, since the free-list is empty */

    else
        {
#ifdef LIST_CHECK
        pSignature  = (HeapSignature *)
                            AllocateOnceNew( size + sizeof( *pSignature ) );
        pEntry  = ( (char *) pSignature ) + sizeof( *pSignature );

        *pSignature = USED_SIGNATURE( this, pEntry );
        memset( pEntry, 0xB2, size );
        return pEntry;
#else
        return AllocateOnceNew(size);
#endif
        }

    } /* Get */

    /*********************************************************************/ 
    // This routine "releases" the given element, by putting it on
    // the free-list for later re-use.  The given element, must be 
    // the same size as the elements provided by the "Get" function.
    /*********************************************************************/ 
        
void    
FreeListMgr::Put (void * pEntry)
    {
#ifdef LIST_CHECK
    HeapSignature   *   pSignature;
#endif
    // Count this call.

#ifndef NDEBUG
    PutCount++;
#endif

    // Put the given element on the head of the free-list.

#ifdef LIST_CHECK
    // check to make sure the entry is really OK
    // signature is before entry pointer
    // signature of free nodes is ( &mgr - &node )
    // signature of used nodes is ( &mgr % &node )
    pSignature = ((HeapSignature *)pEntry)-1;

    MIDL_ASSERT( *pSignature == USED_SIGNATURE( this, pEntry ) );

    *pSignature = FREE_SIGNATURE( this, pEntry );

    memset( pEntry, 0xA1, element_size );
#endif
    ( (FreeListType *) pEntry ) -> next = pHead;
    pHead = (FreeListType *) pEntry;


    }; /* Put */




#ifdef example



// 
// Example of use...
//
// copy the following into a class definition and replace the X's with 
// the name of the class
//

/*********************************************************************/ 
// here is the free list manager for a particular class.  it should
// NOT be inherited unless the derived classes have no extra data members.
// 
// Otherwise, the derived classes should have their own new and delete
// elsewhere.
/*********************************************************************/ 
private:

    static
    FreeListMgr         MyFreeList( sizeof( X ) );
    

public:

/*********************************************************************/ 
// Return a new element of the specified size.
// 
// The FreeListMgr "Get" routine is used, so that the element may be
// retrieved from a free-list, if possible, and extra get-memory calls
// can thus be avoided.  
/*********************************************************************/ 

X *
operator new (size_t size)
    {
    return (MyFreeList.Get (size));
    } 

/*********************************************************************/ 
// Release an element allocated by the "New" routine.
//
/*********************************************************************/ 
void operator delete (X* pX)
    {
    MyFreeList.Put (pX);
    } 

#endif // example
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\typelib\tlgen.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       tlgen.cxx
//
//  Contents:   type library generation methods
//
//  Classes:    various
//
//  Functions:  various
//
//  History:    4-10-95   stevebl   Created
//
//----------------------------------------------------------------------------

#pragma warning ( disable : 4514 4706 )

#include "tlcommon.hxx"
#include "tlgen.hxx"
#include "tllist.hxx"
#include "becls.hxx"
#include "walkctxt.hxx"
#include "ilxlat.hxx"
#include "midlvers.h"
#include <time.h>

#define SHOW_ERROR_CODES 1
extern "C"
BOOL
Is64BitEnv()
    {
    return pCommand->Is64BitEnv();
    }

//+---------------------------------------------------------------------------
//
//  Notes on CG_STATUS return types:
//
//  CG_STATUS is an enumeration which can have the following values:
//  CG_OK, CG_NOT_LAYED_OUT, and CG_REF_NOT_LAYED_OUT.  The type generation
//  methods assign the following meanings to these values:
//
//  CG_OK                => success
//  CG_NOT_LAYED_OUT     => the type info was created but (due to cyclic
//                          dependencies) LayOut() could not be called on it.
//  CG_REF_NOT_LAYED_OUT => same as CG_NOT_LAYED_OUT except that the type
//                          is a referenced type: in other words, it is a
//                          pointer type or an array type.
//
//  The methods in this file use the CG_STATUS value to help detect and
//  correct errors that occur due to cyclic dependencies like this one:
//
//      struct foo {
//          int x;
//          union bar * pBar;   // the type (union bar *) is a referenced type
//      };
//
//      union bar {
//          struct foo;
//      }
//
//  This creates a problem because ICreateTypeInfo::LayOut() will fail on any
//  structure or union which contains another structure or union which has not
//  already been layed out.
//
//  If a structure (or union) receives a CG_STATUS value of CG_NOT_LAYED_OUT
//  from any of its members, then it knows that it will not be able to call
//  LayOut on itself and it will have to return CG_NOT_LAYED_OUT to tell
//  its dependents that it hasn't been layed out.
//
//  If (on the other hand) the structure (or union) receives
//  CG_REF_NOT_LAYED_OUT from one or more of its members and CG_OK from all
//  the others then it knows that there is a cyclic dependency somewhere,
//  but that it WILL be able to call LayOut() because all of the members that
//  encountered difficulty were references (pointers or arrays) to a cyclicly
//  dependent type.  Calling LayOut() may break the dependency (they may be
//  waiting on this structure) and so LayOut must be called, and then all of
//  the structure's members should be told to try again.
//
//  If the structure receives CG_OK from all of its members, then there is
//  no cyclic depency (or the cycle has already been broken), LayOut()
//  may be called and CG_OK may be returned to the caller.
//
//  Note that it is impossible to get in an unbreakable cyclic dependency
//  because at some point in the cycle one of the members must be a
//  referenced type.
//
//----------------------------------------------------------------------------

// Maintain a global pointer to the list of open ICreateTypeInfo pointers.
CObjHolder * gpobjholder;

// global pointer to the root ICreateTypeLibrary
ICreateTypeLib * pMainCTL = NULL;

char* szErrTypeFlags   = "Could not set type flags";
char* szErrHelpString  = "Could not set help string";
char* szErrHelpContext = "Could not set help context";
char* szErrVersion     = "Could not set version";
char* szErrUUID        = "Could not set UUID";

//+---------------------------------------------------------------------------
//
//  Function:   ReportTLGenError
//
//  Synopsis:   Generic routine for reporting typelib generation errors.
//              Reports typelib generation error and then exits.
//
//  Arguments:  [szText]     - description of failure
//              [error_code] - typically an HRESULT
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      The error code is only displayed if the
//              SHOW_ERROR_CODES macro is defined.
//
//              It is assumed that szText will never exceed 100 characters
//              (minus space for the string representation of error_code).
//              Since this is a local function, this is a safe assumption.
//
//----------------------------------------------------------------------------

void ReportTLGenError( char * szText, char * szName, long error_code)
{
    char szBuffer [512];
    // there are places we don't have an error_code, and pass in 0.
    if ( error_code != 0 )
        sprintf(szBuffer, ": %s : %s (0x%0X)", szText, szName, error_code);
    else
        sprintf(szBuffer, ": %s : %s", szText, szName);

    RpcError("midl\\oleaut32.dll", 0, ERR_TYPELIB_GENERATION, szBuffer);

    delete gpobjholder;

    if (pMainCTL)
        pMainCTL->Release();
    exit(ERR_TYPELIB_GENERATION);
}

void ReportTLGenWarning( char * szText, char * szName, long error_code )
{
    char szBuffer [512];
#ifdef SHOW_ERROR_CODES
    sprintf(szBuffer, ": %s : %s (0x%0X)", szText, szName, error_code);
#else
    sprintf(szBuffer, ": %s : %s", szText, szName);
#endif
    RpcError("midl\\oleaut32.dll", 0, WARN_TYPELIB_GENERATION, szBuffer);
}


OLECHAR wszScratch [MAX_PATH];

extern CTypeLibraryList gtllist;

extern BOOL IsTempName( char * );

void GetValueFromExpression(VARIANT & var, TYPEDESC tdesc, expr_node * pExpr, LCID lcid, char * szSymName);
void ConvertToVariant(VARIANT & var, expr_node * pExpr, LCID lcid);

BOOL IsVariantBasedType(TYPEDESC tdesc)
{
    while (tdesc.vt >= VT_PTR && tdesc.vt <= VT_CARRAY)
    {
        // This simplification works for VT_CARRAY as well as VT_PTR because
        // the ARRAYDESC structure's first member is a TYPEDESC.
        tdesc = *tdesc.lptdesc;
    };
    return tdesc.vt == VT_VARIANT;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteTypedescChildren
//
//  Synopsis:   deletes all structures pointed to by a TYPEDESC so that the
//              TYPEDESC can be safely deleted.
//
//  Arguments:  [ptd] - pointer to a TYEPDESC
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      ptd is not deleted
//
//----------------------------------------------------------------------------

void DeleteTypedescChildren(TYPEDESC * ptd)
{
    if (VT_CARRAY == ptd->vt)
        {
            DeleteTypedescChildren(&ptd->lpadesc->tdescElem);
            delete ptd->lpadesc;
        }
    else if (VT_PTR == ptd->vt)
        {
            DeleteTypedescChildren(ptd->lptdesc);
            delete ptd->lptdesc;
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTypeFlags
//
//  Synopsis:   extracts TYPEFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to the context
//
//  Returns:    TYPEFLAGS built from attributes found in the context
//
//  Modifies:   ATTR_TYPEDESCATTR, all ATTR_TYPE and all ATTR_MEMBER
//              attributes are consumed from the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

UINT GetTypeFlags(WALK_CTXT * pctxt)
{
    UINT rVal = 0;
    node_constant_attr * pTdescAttr = (node_constant_attr *) pctxt->ExtractAttribute(ATTR_TYPEDESCATTR);
    if (pTdescAttr)
        rVal = (short) pTdescAttr->GetExpr()->GetValue();

    node_type_attr * pTA;
    while (pTA = (node_type_attr *)pctxt->ExtractAttribute(ATTR_TYPE))
    {
        switch (pTA->GetAttr())
        {
        case TATTR_LICENSED:
            rVal |= TYPEFLAG_FLICENSED;
            break;
        case TATTR_APPOBJECT:
            rVal |= TYPEFLAG_FAPPOBJECT;
            break;
        case TATTR_CONTROL:
            rVal |= TYPEFLAG_FCONTROL;
            break;
        case TATTR_DUAL:
            rVal |= TYPEFLAG_FDUAL | TYPEFLAG_FOLEAUTOMATION;
            break;
        case TATTR_PROXY:
            rVal |= TYPEFLAG_FPROXY;
            break;
        case TATTR_NONEXTENSIBLE:
            rVal |= TYPEFLAG_FNONEXTENSIBLE;
            break;
        case TATTR_OLEAUTOMATION:
            rVal |= TYPEFLAG_FOLEAUTOMATION;
            break;
        case TATTR_AGGREGATABLE:
            rVal |= TYPEFLAG_FAGGREGATABLE;
            break;
        case TATTR_PUBLIC:
        default:
            break;
        }
    }
    node_member_attr * pMA;
    while (pMA = (node_member_attr *)pctxt->ExtractAttribute(ATTR_MEMBER))
    {
        switch (pMA->GetAttr())
        {
        case MATTR_RESTRICTED:
            rVal |= TYPEFLAG_FRESTRICTED;
            break;
        case MATTR_PREDECLID:
            rVal |= TYPEFLAG_FPREDECLID;
            break;
        case MATTR_REPLACEABLE:
            rVal |= TYPEFLAG_FREPLACEABLE;
            break;
        default:
            break;
        }
    }

    if (pctxt->AttrInSummary(ATTR_HIDDEN))
    {
        rVal |= TYPEFLAG_FHIDDEN;
    }
    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetImplTypeFlags
//
//  Synopsis:   extracts IMPLTYPEFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to the context
//
//  Returns:    IMPLTYPEFLAGS build from attributes found in the context
//
//  Modifies:   ATTR_DEFAULT, and all ATTR_MEMBER attributes are consumed from
//              the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

unsigned short GetImplTypeFlags(WALK_CTXT * pctxt)
{
    unsigned short rVal = 0;
    if (pctxt->ExtractAttribute(ATTR_DEFAULT))
        rVal |= IMPLTYPEFLAG_FDEFAULT;
    node_member_attr * pMA;
    while (pMA = (node_member_attr *)pctxt->ExtractAttribute(ATTR_MEMBER))
    {
        switch(pMA->GetAttr())
        {
        case MATTR_SOURCE:
            rVal |= IMPLTYPEFLAG_FSOURCE;
            break;
        case MATTR_RESTRICTED:
            rVal |= IMPLTYPEFLAG_FRESTRICTED;
            break;
        case MATTR_DEFAULTVTABLE:
            rVal |= IMPLTYPEFLAG_FDEFAULTVTABLE;
            break;
        default:
            break;
        }
    }
    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetIDLFlags
//
//  Synopsis:   extracts IDLFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to a context
//
//  Returns:    IDLFLAGS built from attributes found in the context
//
//  Modifies:   ATTR_IDLDESCATTR, ATTR_OUT, and ATTR_IN attributes are
//              consumed from the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

unsigned short GetIDLFlags(WALK_CTXT * pctxt)
{
    unsigned short rVal = 0;
    node_constant_attr * pIDLDescAttr = (node_constant_attr *) pctxt->ExtractAttribute(ATTR_IDLDESCATTR);
    if (pIDLDescAttr)
        rVal = (short) pIDLDescAttr->GetExpr()->GetValue();

    if (pctxt->AttrInSummary(ATTR_OUT))
        rVal |= IDLFLAG_FOUT;

    if (pctxt->AttrInSummary(ATTR_IN))
        rVal |= IDLFLAG_FIN;

    if (pctxt->AttrInSummary(ATTR_FLCID))
        rVal |= IDLFLAG_FLCID;

    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetVarFlags
//
//  Synopsis:   extracts VARFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to a context
//
//  Returns:    VARFLAGS built from attributes found in the context
//
//  Modifies:   ATTR_VDESCATTR, ATTR_HIDDEN and all ATTR_MEMBER attributes
//              are consumed from the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

UINT GetVarFlags(WALK_CTXT * pctxt)
{
    unsigned short rVal = 0;
    node_constant_attr * pVdescAttr = (node_constant_attr *) pctxt->ExtractAttribute(ATTR_VARDESCATTR);
    if (pVdescAttr)
        rVal = (short) pVdescAttr->GetExpr()->GetValue();

    node_member_attr * pMA;
    while (pMA = (node_member_attr *)pctxt->ExtractAttribute(ATTR_MEMBER))
    {
        switch (pMA->GetAttr())
        {
        case MATTR_READONLY:
            rVal |= VARFLAG_FREADONLY;
            break;
        case MATTR_SOURCE:
            rVal |= VARFLAG_FSOURCE;
            break;
        case MATTR_BINDABLE:
            rVal |= VARFLAG_FBINDABLE;
            break;
        case MATTR_DISPLAYBIND:
            rVal |= VARFLAG_FDISPLAYBIND;
            break;
        case MATTR_DEFAULTBIND:
            rVal |= VARFLAG_FDEFAULTBIND;
            break;
        case MATTR_REQUESTEDIT:
            rVal |= VARFLAG_FREQUESTEDIT;
            break;
        case MATTR_UIDEFAULT:
            rVal |= VARFLAG_FUIDEFAULT;
            break;
        case MATTR_NONBROWSABLE:
            rVal |= VARFLAG_FNONBROWSABLE;
            break;
        case MATTR_DEFAULTCOLLELEM:
            rVal |= VARFLAG_FDEFAULTCOLLELEM;
            break;
        case MATTR_IMMEDIATEBIND:
            rVal |= VARFLAG_FIMMEDIATEBIND;
            break;
        case MATTR_REPLACEABLE:
            rVal |= VARFLAG_FREPLACEABLE;
            break;
        case MATTR_RESTRICTED:
            rVal |= VARFLAG_FRESTRICTED;
            break;
        default:
            break;
        }
    }

    if (pctxt->AttrInSummary(ATTR_HIDDEN))
    {
        rVal |= VARFLAG_FHIDDEN;
    }
    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetFuncFlags
//
//  Synopsis:   extracts FUNCFLAGS from a context
//
//  Arguments:  [pctxt] - pointer to a context
//
//  Returns:    FUNCFLAGS built from attributes found in the context
//
//  Modifies:   ATTR_FUNCDESCATTR, ATTR_HIDDEN and all ATTR_MEMBER attributes
//              are consumed from the context.
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

UINT GetFuncFlags(WALK_CTXT * pctxt, BOOL * pfPropGet, BOOL * pfPropPut, BOOL * pfPropPutRef, BOOL * pfVararg)
{
    unsigned short rVal = 0;
    node_constant_attr * pVdescAttr = (node_constant_attr *) pctxt->ExtractAttribute(ATTR_FUNCDESCATTR);
    if (pVdescAttr)
        rVal = (short) pVdescAttr->GetExpr()->GetValue();

    * pfPropGet = * pfPropPut = * pfPropPutRef = * pfVararg = FALSE;

    node_member_attr * pMA;
    while (pMA = (node_member_attr *)pctxt->ExtractAttribute(ATTR_MEMBER))
    {
         switch (pMA->GetAttr())
        {
        case MATTR_RESTRICTED:
            rVal |= FUNCFLAG_FRESTRICTED;
            break;
        case MATTR_SOURCE:
            rVal |= FUNCFLAG_FSOURCE;
            break;
        case MATTR_BINDABLE:
            rVal |= FUNCFLAG_FBINDABLE;
            break;
        case MATTR_REQUESTEDIT:
            rVal |= FUNCFLAG_FREQUESTEDIT;
            break;
        case MATTR_DISPLAYBIND:
            rVal |= FUNCFLAG_FDISPLAYBIND;
            break;
        case MATTR_DEFAULTBIND:
            rVal |= FUNCFLAG_FDEFAULTBIND;
            break;
        case MATTR_UIDEFAULT:
            rVal |= FUNCFLAG_FUIDEFAULT;
            break;
        case MATTR_NONBROWSABLE:
            rVal |= FUNCFLAG_FNONBROWSABLE;
            break;
        case MATTR_DEFAULTCOLLELEM:
            rVal |= FUNCFLAG_FDEFAULTCOLLELEM;
            break;
        case MATTR_PROPGET:
            *pfPropGet = TRUE;
            break;
        case MATTR_PROPPUT:
            *pfPropPut = TRUE;
            break;
        case MATTR_PROPPUTREF:
            *pfPropPutRef = TRUE;
            break;
        case MATTR_VARARG:
            *pfVararg = TRUE;
            break;
        case MATTR_IMMEDIATEBIND:
            rVal |= FUNCFLAG_FIMMEDIATEBIND;
            break;
        case MATTR_USESGETLASTERROR:
            rVal |= FUNCFLAG_FUSESGETLASTERROR;
            break;
        case MATTR_REPLACEABLE:
            rVal |= FUNCFLAG_FREPLACEABLE;
            break;
        default:
            break;
        }
    }

// What about FUNCFLAG_FUSEGETLASTERROR?

    if (pctxt->AttrInSummary(ATTR_HIDDEN))
    {
        rVal |= FUNCFLAG_FHIDDEN;
    }
    return rVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     node_guid::GetGuid
//
//  Synopsis:   method to retrieve a GUID from a node_guid
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

void node_guid::GetGuid(_GUID & guid)
{
    guid.Data1 = cStrs.Value.Data1;
    guid.Data2 = cStrs.Value.Data2;
    guid.Data3 = cStrs.Value.Data3;
    memmove(guid.Data4, cStrs.Value.Data4, 8);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_NDR::CheckImportLib
//
//  Synopsis:   Checks to see if a particular CG node has a definition in
//              an imported type libaray.
//
//  Returns:    NULL  => the node has no imported definition
//              !NULL => ITypeInfo pointer for the imported type definition
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      It is possible that the CG node may have been created from
//              an IDL file and yet this routine may stil return a pointer to
//              an imported ITypeInfo.
//
//              This is desirable.
//
//              Because type libraries cannot represent as rich a set of
//              information as IDL files can, the user may wish to directly
//              include an IDL file containing a definintion of the type,
//              thereby making the full IDL definition available for reference
//              by other types.   At the same time the user may wish to
//              IMPORTLIB a type library describing the same type so that the
//              new type library will be able to link directly to the imported
//              ODL definition, rather than forcing the new type library to
//              contain a definition of the imported type.
//
//              This makes the assumption that although two definitions with
//              the same name may exist in the global namespace, they will
//              both refer to the same type.
//
//----------------------------------------------------------------------------

void * CG_NDR::CheckImportLib()
{
    node_skl * pn = GetType();
    node_file * pf = NULL;
    void * pReturn;

    for(;;)
    {
        if (pn->GetMyInterfaceNode())
        {
            pf = pn->GetDefiningFile();
        }
        else
        {
            pf = pn->GetDefiningTLB();
        }
        if (pf)
        {
            if (pf->GetImportLevel() > 0)
            {
                A2O(wszScratch, pn->GetSymName(), MAX_PATH);

                pReturn = gtllist.FindName(pf->GetFileName(), wszScratch);
                if (pReturn)
                    return pReturn;
            }
            else
                return NULL;
        }

        NODE_T kind = pn->NodeKind();
        if (kind != NODE_DEF && kind != NODE_HREF)
            return NULL;
        pn = pn->GetChild();      
    }
}

void * CG_TYPEDEF::CheckImportLib()
{
    node_skl * pn = GetType();
    node_file * pf = NULL;
    void * pReturn;
    if (pn->GetMyInterfaceNode())
    {
        pf = pn->GetDefiningFile();
    }
    else
    {
        pf = pn->GetDefiningTLB();
    }
    if (pf)
    {
        if (pf->GetImportLevel() > 0)
        {
            A2O(wszScratch, pn->GetSymName(), MAX_PATH);

            pReturn = gtllist.FindName(pf->GetFileName(), wszScratch);
            if (pReturn)
                return pReturn;
        }
    }
    return NULL;
}

typedef struct tagINTRINSIC
{
    char * szType;
    VARTYPE vt;
} INTRINSIC;

INTRINSIC rgIntrinsic [] =
{
    "DATE",         VT_DATE,
    "HRESULT",      VT_HRESULT,
    "LPSTR",        VT_LPSTR,
    "LPWSTR",       VT_LPWSTR,
    "SCODE",        VT_ERROR,
    "VARIANT_BOOL", VT_BOOL,
    "wireBSTR",     VT_BSTR,
    "BSTR",         VT_BSTR,
    "VARIANT",      VT_VARIANT,
    "wireVARIANT",  VT_VARIANT,
    "CURRENCY",     VT_CY,
    "CY",           VT_CY,
    "DATE",         VT_DATE,
    "DECIMAL",      VT_DECIMAL,
};


//+---------------------------------------------------------------------------
//
//  Member:     CG_CLASS::GetTypeDesc
//
//  Synopsis:   Default implementation of GetTypeDesc.
//              Creates a TYPEDESC from a CG node.
//
//  Arguments:  [ptd]  - reference of a pointer to a TYPEDESC
//              [pCCB] - CG control block pointer
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//
//  Modifies:   ptd points to a new TYPEDESC
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      Except for the special cases listed below, this method
//              calls GenTypeInfo to generate an ICreateTypeInfo for this
//              node.  Then it creates a TYPEDESC of type VT_USERDEFINED
//              which contains an HREFTYPE to the new type info.
//
//              The special casses are the ODL base types: CURRENCY, and
//              VARIANT, which simply generate the appropriate TYPEDESC and
//              do not need to create any additional type infos.
//
//----------------------------------------------------------------------------

CG_STATUS CG_CLASS::GetTypeDesc(TYPEDESC * &ptd, CCB *pCCB)
{
    node_skl * pskl = GetType();
    char * szName;
    int iIntrinsicType;
    if (ID_CG_TYPEDEF != GetCGID())
    {
        while (NODE_DEF == pskl->NodeKind())
        {
            szName = pskl->GetSymName();
            iIntrinsicType = 0;
            if ( szName )
            {
                while (iIntrinsicType < (sizeof(rgIntrinsic) / sizeof(INTRINSIC)))
                {
                    int i = _stricmp(szName, rgIntrinsic[iIntrinsicType].szType);
                    if (i == 0)
                    {
                        ptd = new TYPEDESC;
                        ptd->lptdesc = NULL;
                        ptd->vt = rgIntrinsic[iIntrinsicType].vt;
                        return CG_OK;
                    }
                    iIntrinsicType++;
                }
            }
            pskl = pskl->GetChild();
        }
    }
    szName = pskl->GetSymName();
    iIntrinsicType = 0;
    if ( szName )
        while (iIntrinsicType < (sizeof(rgIntrinsic) / sizeof(INTRINSIC)))
        {
            int i = _stricmp(szName, rgIntrinsic[iIntrinsicType].szType);
            if (i == 0)
            {
                ptd = new TYPEDESC;
                ptd->lptdesc = NULL;
                ptd->vt = rgIntrinsic[iIntrinsicType].vt;
                return CG_OK;
            }
            iIntrinsicType++;
        }

    // remember the current ICreateTypeInfo
    ICreateTypeInfo * pCTI = pCCB->GetCreateTypeInfo();
    MIDL_ASSERT(NULL != pCTI);

    ITypeInfo * pTI;
    HRESULT hr;
    CG_STATUS cgs = CG_OK;

    // make sure this typedef has been generated
    if (NULL == (pTI = (ITypeInfo *)CheckImportLib()))
    {
        BOOL fRemember = pCCB->IsInDispinterface();
        pCCB->SetInDispinterface(FALSE);
        cgs = GenTypeInfo(pCCB);
        pCCB->SetInDispinterface(fRemember);
        ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
        MIDL_ASSERT(NULL != pNewCTI);
        // get an ITypeInfo so we can create a reference to it
        hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
        if FAILED(hr)
        {
            ReportTLGenError(  "QueryInterface failed", szName, hr);
        }
    }

    // restore the current ICreateTypeInfo pointer
    pCCB->SetCreateTypeInfo(pCTI);

    // get an HREFTYPE for it
    HREFTYPE hrt = 0;
    hr = pCTI->AddRefTypeInfo(pTI, &hrt);
    // DO NOT CHECK THIS HRESULT FOR ERRORS
    // If we get here after pCTI has been layed out (which is possible on
    // structures or unions with circular references) then this will fail.

    // TYPE_E_TYPEMISMATCH will be returned if pTI is TKIND_MODULE
    // the above comment is in @v1, and I don't want to get rid of it, even
    // though oleaut32 is not reporting error in above scenario now. 
    if ( TYPE_E_TYPEMISMATCH == hr )
    {
        ReportTLGenError("AddRefTypeInfo failed", szName, hr );
    }

    // release the ITypeInfo.
    pTI->Release();

    ptd = new TYPEDESC;
    ptd->vt = VT_USERDEFINED;
    ptd->hreftype = hrt;
    return cgs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_TYPELIBRARY_FILE::GenCode
//
//  Synopsis:   generates the type library file
//
//  Arguments:  [pCCB] - CG controller block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_TYPELIBRARY_FILE::GenCode(CCB * pCCB)
{
    CG_ITERATOR I;
    CG_INTERFACE *  pCG;

    //
    // Create the ICreateTypeLibrary
    //

    char * szName = GetFileName();

    // don't generate tlb if /notlb is specified (don't have a filename)
    if (NULL == szName)
        return CG_OK;

    A2O(wszScratch, szName, MAX_PATH);

    //
    // initialize the open ICreateTypeInfo list
    //
    gpobjholder = new CObjHolder;
    
    SYSKIND syskind;
    switch(pCommand->GetEnv())
    {
    case ENV_WIN64:
        syskind = ( SYSKIND ) SYS_WIN64;
        break;
    case ENV_WIN32:
        syskind = SYS_WIN32;
        break;
    default:
        syskind = SYS_WIN32;
        ReportTLGenError(  "invalid syskind", szName, 0);
        break;
    }

    HRESULT hr = LateBound_CreateTypeLib(syskind, wszScratch, &pMainCTL);
    if FAILED(hr)
    {
        ReportTLGenError(  "CreateTypeLibFailed", szName, hr);
    }
    else
    {
        pCCB->SetCreateTypeLib(pMainCTL);

        //
        // Find the CG_LIBRARY node and use it to populate the type library
        //

        GetMembers( I );

        I.Init();
        while( ITERATOR_GETNEXT( I, pCG ) )
            {
            switch(pCG->GetCGID())
            {
            case ID_CG_LIBRARY:
                pCG->GenTypeInfo(pCCB);
                break;
            default:
                break;
            }
        }

        hr = pMainCTL->SaveAllChanges();
        if FAILED(hr)
        {
            ReportTLGenError(  "SaveAllChanges Failed", szName, hr);
        }

        //
        // free all the object pointers in the object holder
        //
        delete gpobjholder;

        pMainCTL->Release();
    }

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_LIBRARY::GenTypeInfo
//
//  Synopsis:   sets a type library's attributes and generates its type infos
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_LIBRARY::GenTypeInfo(CCB * pCCB)
{
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();


    // Set the type library attributes

    node_library * pType = (node_library *) GetType();

    char * szName = pType->GetSymName();
    if (szName)
    {
        A2O(wszScratch, szName, MAX_PATH);
        pCTL->SetName(wszScratch);
    }

    node_guid * pGuid = (node_guid *) pType->GetAttribute( ATTR_GUID );
    if (pGuid)
    {
        GUID guid;
        pGuid->GetGuid(guid);
        pCTL->SetGuid(guid);
    }

    node_text_attr * pTA;
    if (pTA = (node_text_attr *) pType->GetAttribute(ATTR_HELPFILE))
    {
        char * szHelpFile = pTA->GetText();
        A2O(wszScratch, szHelpFile, MAX_PATH);
        pCTL->SetHelpFileName(wszScratch);
    }

    if (pTA = (node_text_attr *)pType->GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        pCTL->SetDocString(wszScratch);
    }

    HRESULT hr = ResultFromScode(S_OK);
    if (pTA = (node_text_attr *)pType->GetAttribute(ATTR_HELPSTRINGDLL))
    {
        char * szHelpStringDll = pTA->GetText();
        A2O(wszScratch, szHelpStringDll, MAX_PATH);
        hr = ((ICreateTypeLib2*)pCTL)->SetHelpStringDll(wszScratch);
    }

    node_constant_attr *pCA;
    if (pCA = (node_constant_attr *) pType->GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        pCTL->SetHelpContext(hc);
    }

    if (pCA = (node_constant_attr *) pType->GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeLib2 *)pCTL)->SetHelpStringContext(hc);
    }

    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    VARIANT             var;
    GUID                guid;

    ((named_node*)GetType())->GetAttributeList( myAttrs );

    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeLib2 *)pCTL)->SetCustData(guid,
                                                    &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    // set compiler version and time stamp
    if ( !pCommand->IsSwitchDefined( SWITCH_NO_STAMP ) )
        {
        CHAR szBuffer[MAX_PATH];  // long enough for the readable data
        // {DE77BA63-517C-11d1-A2DA-0000F8773CE9}
        const GUID TimeStampGuid =
        { 0xde77ba63, 0x517c, 0x11d1, { 0xa2, 0xda, 0x0, 0x0, 0xf8, 0x77, 0x3c, 0xe9 } };

        // {DE77BA64-517C-11d1-A2DA-0000F8773CE9}
        const GUID CompilerVersionGuid =
        { 0xde77ba64, 0x517c, 0x11d1, { 0xa2, 0xda, 0x0, 0x0, 0xf8, 0x77, 0x3c, 0xe9 } };

        // {DE77BA65-517C-11d1-A2DA-0000F8773CE9}
        const GUID ReadableMIDLInfoGuid = { 0xde77ba65, 0x517c, 0x11d1, { 0xa2, 0xda, 0x0, 0x0, 0xf8, 0x77, 0x3c, 0xe9 } };

        strcpy(szBuffer, "Created by MIDL version ");
        strcat(szBuffer,pCommand->GetCompilerVersion());
        strcat(szBuffer, " at ");
        strcat(szBuffer,pCommand->GetCompileTime() );
        A2O(wszScratch, szBuffer, MAX_PATH);

        var.vt = VT_BSTR;
        var.bstrVal = LateBound_SysAllocString( wszScratch );
        ( ( ICreateTypeLib2* ) pCTL )->SetCustData( ReadableMIDLInfoGuid, &var );
        LateBound_SysFreeString( var.bstrVal );
        
        ZeroMemory( &var, sizeof( VARIANT ) );

        time( ( time_t* ) &var.lVal );
        var.vt = VT_UI4;
        ( ( ICreateTypeLib2* ) pCTL )->SetCustData( TimeStampGuid, &var );

        var.lVal = ( rmj << 24 ) + ( rmm << 16 ) + rup;
        ( ( ICreateTypeLib2* ) pCTL )->SetCustData( CompilerVersionGuid, &var );
       
        }

    unsigned short Maj;
    unsigned short Min;
    pType->GetVersionDetails(&Maj, &Min);
    pCTL->SetVersion(Maj, Min);

    if (pCA = (node_constant_attr *) pType->GetAttribute(ATTR_LCID))
    {
        DWORD lcid = (DWORD) pCA->GetExpr()->GetValue();
        pCTL->SetLcid(pCCB->SetLcid(lcid));
    }
    else
    {
        pCTL->SetLcid(pCCB->SetLcid(0));
    }

    UINT libflags = 0;
    if (pType->FMATTRInSummary(MATTR_RESTRICTED))
        libflags |= LIBFLAG_FRESTRICTED;
    if (pType->FTATTRInSummary(TATTR_CONTROL))
        libflags |= LIBFLAG_FCONTROL;
    if (pType->FInSummary(ATTR_HIDDEN))
        libflags |= LIBFLAG_FHIDDEN;
    pCTL->SetLibFlags(libflags);

    CG_ITERATOR I;
    CG_INTERFACE *  pCG;

    GetMembers( I );

    I.Init();
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        ITypeInfo * pTI;
        char*       sz = pCG->GetSymName();
        if (0 != _stricmp(sz, "IDispatch") &&
            0 != _stricmp(sz, "IUnknown"))
            {
            if (!(pTI = (ITypeInfo *)pCG->CheckImportLib()))
                {
                // we postpone the creation of typeinfo for interface reference
                // (which actually results in the creation of typeinfo for an
                // interface) to maintain the equivalence in the order of 
                // definition in the source file and the resulting type library.
                ID_CG cgId = pCG->GetCGID();
                if ( cgId != ID_CG_INTERFACE_REFERENCE )
                    {
                    pCG->GenTypeInfo(pCCB);
                    }
                }
            else
                {
                pTI->Release();
                }
            }
        }

    I.Init();
    while( ITERATOR_GETNEXT( I, pCG ) )
        {
        ITypeInfo * pTI;
        char*       sz = pCG->GetSymName();
        if (0 != _stricmp(sz, "IDispatch") &&
            0 != _stricmp(sz, "IUnknown"))
            {
            if (!(pTI = (ITypeInfo *)pCG->CheckImportLib()))
                {
                // this trict ensures that type info for the base interface is created
                // before the typeinfo for the derived interface. This is important for
                // utilities that generate .H .TLH and .TLI from the .TLB
                ID_CG cgId = pCG->GetCGID();
                if ( cgId == ID_CG_INTERFACE_REFERENCE )
                    {
                    pCG->GenTypeInfo(pCCB);
                    }
                }
            else
                {
                pTI->Release();
                }
            }
        }

    CG_CLASS*           pCGI = 0;
    ICreateTypeInfo*    pCTI = 0;

    pCCB->InitVTableLayOutList();
    while (pCCB->GetNextVTableLayOutInfo(&pCGI, &pCTI))
        {
        szName = pCGI->GetType()->GetSymName();
        if (pCGI && pCTI)
            {
            HRESULT hr = (HRESULT)pCGI->LayOut();
            if FAILED(hr)
                {
                ReportTLGenError(  "LayOut failed", szName, hr);
                }
            pCTI->Release();
            }
        else
            {
            ReportTLGenError(  "LayOut failed", szName, hr);
            }
        }
    pCCB->DiscardVTableLayOutList();

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_LIBRARY::GenHeader
//
//  Synopsis:   generates header file information for a type library
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_LIBRARY::GenHeader(CCB * pCCB)
{
    CG_ITERATOR I;
    CG_NDR *  pCG;
    node_library * pLibrary = (node_library *) GetType();
    char * szName = pLibrary->GetSymName();

    ISTREAM * pStream = pCCB->GetStream();
    pStream->Write("\n\n#ifndef __");
    pStream->Write(szName);
    pStream->Write("_LIBRARY_DEFINED__\n");
    pStream->Write("#define __");
    pStream->Write(szName);
    pStream->Write("_LIBRARY_DEFINED__\n");
    GetMembers( I );

    // dump all of the types
    pStream->NewLine();
    pLibrary->PrintType((PRT_INTERFACE | PRT_BOTH_PREFIX), pStream, 0);

    pStream->NewLine();
    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
    {
        node_guid * pGuid = (node_guid *) pLibrary->GetAttribute( ATTR_GUID );
        if (pGuid)
            Out_MKTYPLIB_Guid(pCCB, pGuid->GetStrs(), "LIBID_", szName);
    }
    else
    {
        pStream->Write("EXTERN_C const IID LIBID_");
        pStream->Write(szName);
        pStream->Write(';');
        pStream->NewLine();
    }


    // now dump all of the interfaces, dispinterfaces, etc.
    I.Init();
    while( ITERATOR_GETNEXT( I, pCG ) )
    {
        pCG->GenHeader(pCCB);
    }

    pStream->Write("#endif /* __");
    pStream->Write(szName);
    pStream->Write("_LIBRARY_DEFINED__ */\n");
    return CG_OK;
}

// create the typeinfo but do not populate it.
// helps preserve the order or interface declaration.
CG_STATUS  CG_INTERFACE::CreateTypeInfo( CCB * pCCB )
{
    ICreateTypeLib*     pCTL = pCCB->GetCreateTypeLib();
    char*               szName = GetType()->GetSymName();

    A2O(wszScratch, szName, MAX_PATH);
    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_INTERFACE, ( ICreateTypeInfo ** )&_pCTI);
    if (SUCCEEDED(hr))
        {
        gpobjholder->Add( ( IUnknown* ) _pCTI);
        }
    else
        {
        ReportTLGenError(  "CreateTypeInfo failed", szName, hr);
        }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE::GenTypeInfo
//
//  Synopsis:   generates a type info for an interface
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been initialized.
    if ( fTypeInfoInitialized )
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    // if typeinfo was not created, create it.
    if ( _pCTI == 0 )
        {
        CreateTypeInfo( pCCB );
        if ( _pCTI == 0 )
            {
            return CG_OK;
            }
        }
    fTypeInfoInitialized = TRUE;

    HRESULT             hr      = S_OK;
    node_interface*     pItf    = (node_interface *) GetType();
    char*               szName  = pItf->GetSymName();
    ICreateTypeInfo*    pCTI    = ( ICreateTypeInfo * ) _pCTI;

    pCCB->SetCreateTypeInfo(pCTI);
    BOOL fRemember = pCCB->IsInDispinterface();
    pCCB->SetInDispinterface(FALSE);

    WALK_CTXT ctxt(GetType());
    UINT uTypeFlags = GetTypeFlags(&ctxt);
    if (FNewTypeLib())
    {
        if ( IsDispatchable(TRUE) )
        {
            uTypeFlags |= TYPEFLAG_FDISPATCHABLE;
        }        
    }
    hr = pCTI->SetTypeFlags(uTypeFlags);
    if ( FAILED( hr ) )
        {
        ReportTLGenError( szErrTypeFlags, szName, hr);
        }

    node_guid * pGuid = (node_guid *) ctxt.GetAttribute( ATTR_GUID );
    if (pGuid)
    {
        GUID guid;
        pGuid->GetGuid(guid);
        hr = pCTI->SetGuid(guid);
        if ( FAILED( hr ) )
            {
            ReportTLGenError(  "Could not add UUID, STDOLE2.TLB probably needs to be imported", szName, hr);
            }
    }
    node_text_attr * pTA;
    if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        hr = pCTI->SetDocString(wszScratch);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpString, szName, hr);
            }
    }

    node_constant_attr *pCA;
    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        hr = pCTI->SetHelpContext(hc);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpContext, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
    }


    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    VARIANT             var;
    GUID                guid;

    ((named_node*)GetType())->GetAttributeList( myAttrs );

    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                    &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    unsigned short Maj;
    unsigned short Min;
    pItf->GetVersionDetails(&Maj, &Min);
    hr = pCTI->SetVersion(Maj, Min);
    if ( FAILED( hr ) )
        {
        ReportTLGenError( szErrVersion, szName, hr);
        }

    // CONSIDER - may still need to check for MATTR_RESTRICTED

    CG_CLASS *  pCG;
    named_node * pBaseIntf;

    node_skl * pType = GetType();
    if (pBaseIntf = ((node_interface *)(pType))->GetMyBaseInterfaceReference())
    {
        node_interface_reference * pRef = (node_interface_reference *)pBaseIntf;
        // skip forward reference if necessary
        if (pRef->NodeKind() == NODE_FORWARD)
        {
            pRef = (node_interface_reference *)pRef->GetChild();
        }
        pCG = ((node_interface *)(pRef->GetChild()))->GetCG( TRUE);

        ITypeInfo * pTI;
        if (NULL == (pTI = (ITypeInfo *)pCG->CheckImportLib()))
        {
            pCG->GenTypeInfo(pCCB);
            ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
            hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
            if FAILED(hr)
            {
                ReportTLGenError(  "QueryInterface failed", szName, hr);
            }
        }
        // get an HREFTYPE for it
        HREFTYPE hrt;
        hr = pCTI->AddRefTypeInfo(pTI, &hrt);
        if FAILED(hr)
        {
            ReportTLGenError(  "AddRefTypeInfo failed", szName, hr);
        }

        // release the ITypeInfo.
        pTI->Release();

        // add the impltype
        hr = pCTI->AddImplType(0, hrt);
        if FAILED(hr)
        {
            ReportTLGenError(  "AddImplType failed", szName, hr);
        }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }
        }
    // restore current type info pointer
    pCCB->SetCreateTypeInfo(pCTI);

    CG_ITERATOR I;
    GetMembers( I );

    I.Init();

    unsigned uRememberPreviousFuncNum = pCCB->GetProcNum();
    unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
    pCCB->SetProcNum(0);
    pCCB->SetVarNum(0);

    // walk members, adding them to the type info
    while (ITERATOR_GETNEXT(I, pCG))
    {
        pCG->GenTypeInfo(pCCB);
    }
    pCCB->SetInDispinterface(fRemember);
    
    pCCB->SetProcNum((unsigned short)uRememberPreviousFuncNum);
    pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);

    // the complementary Release() is called in CG_LIBRARY::GenTypeInfo()
    pCTI->AddRef();

    // add this node to the list of nodes to be laid out.
    pCCB->SaveVTableLayOutInfo(this, pCTI);
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_REFERENCE::GenTypeInfo
//
//  Synopsis:   generates type info for an interface reference
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE_REFERENCE::GenTypeInfo(CCB *pCCB)
{
    CG_INTERFACE * pCG = (CG_INTERFACE *)((node_interface_reference *)GetType())->GetRealInterface()->GetCG(TRUE);
    return pCG->GenTypeInfo(pCCB);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_REFERENCE::GenHeader
//
//  Synopsis:   generates header information for an interface reference
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE_REFERENCE::GenHeader(CCB * pCCB)
{
    CG_INTERFACE * pCG = (CG_INTERFACE *)((node_interface_reference *)GetType())->GetRealInterface()->GetCG(TRUE);
    return pCG->GenHeader(pCCB);
}

#if 0 // code disabled but retained in case it's ever needed again
//+---------------------------------------------------------------------------
//
//  Function:   AddInheritedMembers
//
//  Synopsis:   helper function used by a dispinterface to add entries for all
//              of the members in all of the interfaces from which it inherits
//
//  Arguments:  [pcgInterface] - pointer to an inherited interface
//              [pCCB]         - CG control block
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      Members are added to the current ICreateTypeInfo which is
//              found in the CG control block.
//
//----------------------------------------------------------------------------

void AddInheritedMembers(CG_INTERFACE * pcgInterface, CCB * pCCB)
{
    // do any base interfaces first
    named_node * pBase = ((node_interface *)(pcgInterface->GetType()))->GetMyBaseInterfaceReference();
    if (pBase)
    {
        node_interface_reference * pRef = (node_interface_reference *) pBase;
        if (pRef->NodeKind() == NODE_FORWARD)
        {
            pRef = (node_interface_reference *)pRef->GetChild();
        }
        AddInheritedMembers((CG_INTERFACE *)((node_interface *)(pRef->GetChild()))->GetCG(TRUE), pCCB);
    }

    CG_CLASS * pCG;
    CG_ITERATOR I;
    pcgInterface->GetMembers(I);
    I.Init();
    while (ITERATOR_GETNEXT(I,pCG))
    {
        // add this interface's members to the type info
        pCG->GenTypeInfo(pCCB);
    }
}
#endif // end of disabled code


//+---------------------------------------------------------------------------
//
//  Member:     CG_DISPINTERFACE::GenTypeInfo
//
//  Synopsis:   generates a type info for a dispinterface
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_DISPINTERFACE::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    node_dispinterface * pDispItf = (node_dispinterface *) GetType();

    char * szName = pDispItf->GetSymName();

    A2O(wszScratch, szName, MAX_PATH);

    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_DISPATCH, &pCTI);

    if (SUCCEEDED(hr))
    {
        _pCTI = pCTI;
        pCCB->SetCreateTypeInfo(pCTI);
        gpobjholder->Add(pCTI);

        WALK_CTXT ctxt(GetType());

        UINT uTypeFlags = GetTypeFlags(&ctxt);
        if (FNewTypeLib())
        {
            uTypeFlags |= TYPEFLAG_FDISPATCHABLE;
        }
        hr = pCTI->SetTypeFlags(uTypeFlags);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( "SetTypeFlags() failed", szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *) ctxt.GetAttribute( ATTR_GUID );
        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }
        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        pDispItf->GetVersionDetails(&Maj, &Min);
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        // CONSIDER - may still need to check for MATTR_RESTRICTED
        CG_CLASS * pCG;
        // Put in the impltype to IDispatch
        pCG = GetCGDispatch();
        ITypeInfo * pTI;

        if (NULL == (pTI = (ITypeInfo *)pCG->CheckImportLib()))
        {
            pCG->GenTypeInfo(pCCB);
            ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
            hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
            if FAILED(hr)
            {
                ReportTLGenError(  "QueryInterface failed", szName, hr);
            }
        }
        // get an HREFTYPE for it
        HREFTYPE hrt;
        hr = pCTI->AddRefTypeInfo(pTI, &hrt);
        if FAILED(hr)
        {
            ReportTLGenError(  "AddRefTypeInfo failed", szName, hr);
        }
        
        // release the ITypeInfo.
        pTI->Release();

        // add the impltype
        hr = pCTI->AddImplType(0, hrt);
        if FAILED(hr)
        {
            ReportTLGenError(  "AddImplType failed", szName, hr);
        }
        // restore current type info pointer
        pCCB->SetCreateTypeInfo(pCTI);

        CG_ITERATOR I;
        GetMembers( I );

        I.Init();

        unsigned uRememberPreviousFuncNum = pCCB->GetProcNum();
        unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
        pCCB->SetProcNum(0);
        pCCB->SetVarNum(0);
        BOOL fRemember = pCCB->IsInDispinterface();
        pCCB->SetInDispinterface(TRUE);

        BOOL fContinue = ITERATOR_GETNEXT(I,pCG);

        if (fContinue)
        {
            if (ID_CG_INTERFACE_PTR == pCG->GetCGID())
            {
                // syntax 1
                // get the first base interface
                node_interface * pI = (node_interface *)((CG_INTERFACE_POINTER *)pCG)->GetTheInterface();
                CG_INTERFACE * pcgInterface = (CG_INTERFACE *)(pI->GetCG(TRUE));
                // Put in the impltype to inherited interface
                ITypeInfo * pTI;

                if (NULL == pcgInterface)
                {
                    // This must be an imported definition.
                    // Call ILxlate to manufacture a CG node for it
                    XLAT_CTXT ctxt(GetType());
                    ctxt.SetAncestorBits(IL_IN_LIBRARY);
                    pcgInterface = (CG_INTERFACE *)(pI->ILxlate(&ctxt));
                    // make sure we get the right CG node
                    if (pI->GetCG(TRUE))
                       pcgInterface = (CG_INTERFACE *)(pI->GetCG(TRUE));
                }

                if (NULL == (pTI = (ITypeInfo *)pcgInterface->CheckImportLib()))
                {
                    pcgInterface->GenTypeInfo(pCCB);
                    ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
                    hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
                    if FAILED(hr)
                    {
                        ReportTLGenError(  "QueryInterface failed", szName, hr);
                    }
                }
                // get an HREFTYPE for it
                HREFTYPE hrt;
                hr = pCTI->AddRefTypeInfo(pTI, &hrt);
                if FAILED(hr)
                {
                    ReportTLGenError(  "AddRefTypeInfo failed", szName, hr);
                }

                // release the ITypeInfo.
                pTI->Release();

                // add the impltype
                hr = pCTI->AddImplType(1, hrt);
                if FAILED(hr)
                {
                    ReportTLGenError(  "AddImplType failed", szName, hr);
                }
                // restore current type info pointer
                pCCB->SetCreateTypeInfo(pCTI);
            }
            else
            {
                // syntax 2
                // walk members, adding them to the type info
                while (fContinue)
                {
                    pCG->GenTypeInfo(pCCB);
                    fContinue = ITERATOR_GETNEXT(I,pCG);
                }
            }
        }

        pCCB->SetProcNum((unsigned short)uRememberPreviousFuncNum);
        pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);
        pCCB->SetInDispinterface(fRemember);
        
        // the complementary Release() is called in CG_LIBRARY::GenTypeInfo()
        pCTI->AddRef();

        // add this node to the list of nodes to be laid out.
        pCCB->SaveVTableLayOutInfo(this, pCTI);
    }
    else
    {
        ReportTLGenError(  "CreateTypeInfo failed", szName, hr);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_DISPINTERFACE::GenHeader
//
//  Synopsis:   generates header file information for a dispinterface
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_DISPINTERFACE::GenHeader(CCB * pCCB)
{
    node_interface *    pInterface = (node_interface *) GetType();
    ISTREAM *           pStream = pCCB->GetStream();
        char                    *       pName   = pInterface->GetSymName();
    CG_OBJECT_INTERFACE * pCGDispatch = (CG_OBJECT_INTERFACE *)GetCGDispatch();

    //Initialize the CCB for this interface.
    InitializeCCB(pCCB);

        // put out the interface guards
        pStream->Write("\n#ifndef __");
        pStream->Write( pName );
        pStream->Write( "_DISPINTERFACE_DEFINED__\n" );

        pStream->Write( "#define __");
        pStream->Write( pName );
        pStream->Write( "_DISPINTERFACE_DEFINED__\n" );

    // Print out the declarations of the types
    pStream->NewLine();
    pInterface->PrintType( PRT_INTERFACE | PRT_OMIT_PROTOTYPE, pStream, 0);

    pStream->NewLine();
    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
    {
        node_guid * pGuid = (node_guid *) pInterface->GetAttribute( ATTR_GUID );
        if (pGuid)
            Out_MKTYPLIB_Guid(pCCB, pGuid->GetStrs(), "DIID_", pName);
    }
    else
    {
        pStream->Write("EXTERN_C const IID DIID_");
        pStream->Write(pName);
        pStream->Write(';');
        pStream->NewLine();
    }

    // print out the vtable/class definitions
    pStream->NewLine();
    pStream->Write("#if defined(__cplusplus) && !defined(CINTERFACE)");

    pStream->IndentInc();
    pStream->NewLine(2);

    // put out the declspec for the uuid
    if ( pCommand->GetMSCVer() >= 1100 )
        {
        pStream->Write("MIDL_INTERFACE(\"");
        pStream->Write(GuidStrs.str1);
        pStream->Write('-');
        pStream->Write(GuidStrs.str2);
        pStream->Write('-');
        pStream->Write(GuidStrs.str3);
        pStream->Write('-');
        pStream->Write(GuidStrs.str4);
        pStream->Write('-');
        pStream->Write(GuidStrs.str5);
        pStream->Write("\")");
        }
    else
        {
        pStream->Write(" struct ");
        }

    pStream->NewLine();
    pStream->Write(pName);
    pStream->Write(" : public IDispatch");
    pStream->NewLine();
    pStream->Write('{');
    pStream->NewLine();
    pStream->Write("};");
    pStream->NewLine();
    pStream->IndentDec();

    pStream->NewLine();
    pStream->Write("#else \t/* C style interface */");

    pStream->IndentInc();
    pCGDispatch->CLanguageBinding(pCCB);
    pStream->IndentDec();

        // print out the C Macros
        pCGDispatch->CLanguageMacros( pCCB );
    pStream->NewLine( 2 );

    pStream->Write("#endif \t/* C style interface */");
    pStream->NewLine( 2 );

    // print out the commented prototypes for the dispatch methods and procedures

        // put out the trailing interface guard
        pStream->Write( "\n#endif \t/* __");
        pStream->Write( pName );
        pStream->Write( "_DISPINTERFACE_DEFINED__ */\n" );

    pStream->NewLine();
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_MODULE::GenTypeInfo
//
//  Synopsis:   generates a type info for a module
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_MODULE::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    node_coclass * pCC = (node_coclass *) GetType();

    char * szName = pCC->GetSymName();

    A2O(wszScratch, szName, MAX_PATH);

    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_MODULE, &pCTI);

    if (SUCCEEDED(hr))
    {
        _pCTI = pCTI;
        pCCB->SetCreateTypeInfo(pCTI);
        gpobjholder->Add(pCTI);

        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *) ctxt.GetAttribute( ATTR_GUID );
        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_DLLNAME))
        {
            pCCB->SetDllName(pTA->GetText());
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        pCC->GetVersionDetails(&Maj, &Min);
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        // CONSIDER - may still need to check for MATTR_RESTRICTED

        CG_CLASS *  pCG;

        CG_ITERATOR I;
        GetMembers( I );

        I.Init();

        unsigned uRememberPreviousFuncNum = pCCB->GetProcNum();
        unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
        pCCB->SetProcNum(0);
        pCCB->SetVarNum(0);

        // walk members, adding them to the type info
        while (ITERATOR_GETNEXT(I, pCG))
        {
            pCG->GenTypeInfo(pCCB);
        }

        pCCB->SetProcNum((unsigned short)uRememberPreviousFuncNum);
        pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);

        // the complementary Release() is called in CG_LIBRARY::GenTypeInfo()
        pCTI->AddRef();

        // add this node to the list of nodes to be laid out.
        pCCB->SaveVTableLayOutInfo(this, pCTI);
    }
    else
    {
        ReportTLGenError(  "CreateTypeInfo failed", szName, hr);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_MODULE::GenHeader
//
//  Synopsis:   generates header information for a module
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_MODULE::GenHeader(CCB * pCCB)
{
    CG_ITERATOR I;
    node_module * pModule = (node_module *) GetType();
    char * szName = pModule->GetSymName();

    ISTREAM * pStream = pCCB->GetStream();
    pStream->Write("\n\n#ifndef __");
    pStream->Write(szName);
    pStream->Write("_MODULE_DEFINED__\n");
    pStream->Write("#define __");
    pStream->Write(szName);
    pStream->Write("_MODULE_DEFINED__\n");
    pStream->NewLine();

    // Print out the declarations of the types
    pStream->NewLine();
    pModule->PrintType( PRT_DECLARATION , pStream, 0);

    pStream->Write("#endif /* __");
    pStream->Write(szName);
    pStream->Write("_MODULE_DEFINED__ */\n");
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_COCLASS::GenTypeInfo
//
//  Synopsis:   generates a type info for a coclass
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_COCLASS::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    node_coclass * pCC = (node_coclass *) GetType();

    char * szName = pCC->GetSymName();

    A2O(wszScratch, szName, MAX_PATH);

    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_COCLASS, &pCTI);

    if (SUCCEEDED(hr))
    {
        _pCTI = pCTI;
        pCCB->SetCreateTypeInfo(pCTI);
        gpobjholder->Add(pCTI);

        WALK_CTXT ctxt(GetType());
        UINT uTypeFlags = GetTypeFlags(&ctxt);
        if (!pCC->IsNotCreatable())
        {
            uTypeFlags |= TYPEFLAG_FCANCREATE;
        }
        hr = pCTI->SetTypeFlags(uTypeFlags);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *) ctxt.GetAttribute( ATTR_GUID );
        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }
        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        pCC->GetVersionDetails(&Maj, &Min);
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( "SetTypeFlags() failed", szName, hr);
            }

        // CONSIDER - may still need to check for MATTR_RESTRICTED
        CG_CLASS *  pCG;
        CG_ITERATOR I;
        GetMembers( I );

        I.Init();
        MEM_ITER MemIter(pCC);

        unsigned nImpltype = 0;
        // walk members, adding them to the type info
        while (ITERATOR_GETNEXT(I, pCG))
        {
            ITypeInfo * pTI;
//            if (ID_CG_INTERFACE_POINTER == pCG->GetCGID())
//                pCG= pCG->GetChild();
            if (NULL == (pTI = (ITypeInfo *)pCG->CheckImportLib()))
            {
                pCG->GenTypeInfo(pCCB);
                ICreateTypeInfo * pNewCTI = pCCB->GetCreateTypeInfo();
                hr = pNewCTI->QueryInterface(IID_ITypeInfo, (void **)&pTI);
                if FAILED(hr)
                {
                    ReportTLGenError(  "QueryInterface failed", szName, hr);
                }
            }
            // get an HREFTYPE for it
            HREFTYPE hrt;
            hr = pCTI->AddRefTypeInfo(pTI, &hrt);
            if FAILED(hr)
            {
                ReportTLGenError(  "AddRefTypeInfo failed", szName, hr);
            }
            
            // release the ITypeInfo.
            pTI->Release();
            
            // add the impltype
            hr = pCTI->AddImplType(nImpltype, hrt);
            if FAILED(hr)
            {
                ReportTLGenError(  "AddImplType failed", szName, hr);
            }

            // Get the ipltype attributes from the node_forward
            WALK_CTXT ctxt(MemIter.GetNext());
            hr = pCTI->SetImplTypeFlags(nImpltype, GetImplTypeFlags(&ctxt));
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrTypeFlags, szName, hr);
                }

            node_custom_attr * pC;

            if (pC = (node_custom_attr *) ctxt.GetAttribute(ATTR_CUSTOM))
            {
                VARIANT var;
                memset(&var, 0, sizeof(VARIANT));
                ConvertToVariant(var, pC->GetVal(), pCCB->GetLcid());
                GUID guid;
                pC->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetImplTypeCustData(nImpltype, guid, &var);
            }

            pCCB->SetCreateTypeInfo(pCTI);

            nImpltype++;
        }

        // the complementary Release() is called in CG_LIBRARY::GenTypeInfo()
        pCTI->AddRef();

        // add this node to the list of nodes to be laid out.
        pCCB->SaveVTableLayOutInfo(this, pCTI);
    }
    else
    {
        ReportTLGenError(  "CreateTypeInfo failed", szName, hr);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_COCLASS::GenHeader
//
//  Synopsis:   generates header information for a coclass
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_COCLASS::GenHeader(CCB * pCCB)
{
    node_coclass *    pCoclass = (node_coclass *) GetType();
    ISTREAM *           pStream = pCCB->GetStream();
        char                    *       pName   = pCoclass->GetSymName();
    node_guid * pGuid = (node_guid *) pCoclass->GetAttribute(ATTR_GUID);

    pStream->NewLine();
    if (pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
    {
        if (pGuid)
            Out_MKTYPLIB_Guid(pCCB, pGuid->GetStrs(), "CLSID_", pName);
    }
    else
    {
        pStream->Write("EXTERN_C const CLSID CLSID_");
        pStream->Write(pName);
        pStream->Write(';');
        pStream->NewLine();
    }
    
    pStream->Write("\n#ifdef __cplusplus");
    pStream->NewLine();
    pStream->Write("\nclass ");

    if (pGuid)
    {
        GUID_STRS         GuidStrs = pGuid->GetStrs();
        // put out the declspec for the uuid
        pStream->Write("DECLSPEC_UUID(\"");
        pStream->Write(GuidStrs.str1);
        pStream->Write('-');
        pStream->Write(GuidStrs.str2);
        pStream->Write('-');
        pStream->Write(GuidStrs.str3);
        pStream->Write('-');
        pStream->Write(GuidStrs.str4);
        pStream->Write('-');
        pStream->Write(GuidStrs.str5);
        pStream->Write("\")");
    }

    pStream->NewLine();
    pStream->Write(pName);

    pStream->Write(";\n#endif");
    pStream->NewLine();

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_ID::GenTypeInfo
//
//  Synopsis:   adds a constant variable to a type info
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Created
//
//  Notes:      Because of the way the CG tree is constructed, this method
//              can only be called from within a module.
//
//              CONSIDER - might want to add an assert to check this
//
//----------------------------------------------------------------------------

CG_STATUS CG_ID::GenTypeInfo(CCB *pCCB)
{
    VARDESC vdesc;
    memset(&vdesc, 0, sizeof(VARDESC));
    vdesc.memid = DISPID_UNKNOWN;

    TYPEDESC * ptdesc;
    GetChild()->GetTypeDesc(ptdesc, pCCB);
    memcpy(&vdesc.elemdescVar.tdesc, ptdesc, sizeof(TYPEDESC));
    vdesc.varkind = VAR_CONST;

    WALK_CTXT ctxt(GetType());
    vdesc.elemdescVar.idldesc.wIDLFlags = GetIDLFlags(&ctxt);
    vdesc.wVarFlags = (unsigned short)GetVarFlags(&ctxt);

    VARIANT var;
    memset(&var, 0, sizeof(VARIANT));
    vdesc.lpvarValue = &var;

    node_id * pId = (node_id *) GetType();

    GetValueFromExpression(var, vdesc.elemdescVar.tdesc, pId->GetExpr(), pCCB->GetLcid(), GetSymName());

    ICreateTypeInfo * pCTI = pCCB->GetCreateTypeInfo();

    char * szName = GetSymName();
    unsigned uVar = pCCB->GetVarNum();
    HRESULT hr = pCTI->AddVarDesc(uVar, &vdesc);
    if (FAILED(hr))
    {
        ReportTLGenError(  "AddVarDesc failed", szName, hr);
    }
    DeleteTypedescChildren(ptdesc);
    delete ptdesc;

    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    GUID                guid;

    ((named_node*)GetType())->GetAttributeList( myAttrs );

    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeInfo2 *)pCTI)->SetVarCustData( uVar,
                                                        guid,
                                                        &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    if (szName)
    {
        A2O(wszScratch, szName, MAX_PATH);
        hr = pCTI->SetVarName(uVar, wszScratch);
        if (FAILED(hr))
        {
            ReportTLGenError(  "SetVarName failed", szName, hr);
        }
    }

    node_text_attr * pTA;
    if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        hr = pCTI->SetVarDocString(uVar,wszScratch);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpString, szName, hr);
            }
    }

    node_constant_attr *pCA;
    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        hr = pCTI->SetVarHelpContext(uVar, hc);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpContext, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeInfo2 *)pCTI)->SetVarHelpStringContext( uVar, hc );
    }

    // bump the variable number
    pCCB->SetVarNum(unsigned short(uVar + 1));

    return CG_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CG_ENUM::GenTypeInfo
//
//  Synopsis:   generates a type info for an ENUM
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_ENUM::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        return CG_OK;
    }

    char * szName = ((node_su_base *)GetBasicType())->GetTypeInfoName();
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    A2O(wszScratch, szName, MAX_PATH);

    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_ENUM, &pCTI);
    if SUCCEEDED(hr)
    {
        _pCTI = pCTI;
        gpobjholder->Add(pCTI, szName);
        pCCB->SetCreateTypeInfo(pCTI);
        node_enum * pEnum = (node_enum *) GetType()->GetBasicType();

        // walk members, adding them to the type info
        MEM_ITER MemIter( pEnum );
        node_label * pLabel;

        unsigned uIndex = 0;

        VARDESC vdElem;
        memset(&vdElem, 0, sizeof(VARDESC));
        vdElem.memid = DISPID_UNKNOWN;
        vdElem.varkind = VAR_CONST;

        VARIANT var;
        memset(&var, 0, sizeof(VARIANT));
/*
 * It appears that MKTYPLIB always uses the VT_INT/VT_I4 combination
 * regardless of the target platform.  For now I'll duplicate this
 * behavior but the commented out code below is what I
 * would have expected to be correct.
        unsigned uSize = pEnum->GetSize(0, 0);
        switch (uSize)
        {
        case 2:
            vdElem.elemdescVar.tdesc.vt = VT_I2;
            var.vt = VT_I2;
            break;
        case 4:
            vdElem.elemdescVar.tdesc.vt = VT_I4;
            var.vt = VT_I4;
            break;
        default:
            vdElem.elemdescVar.tdesc.vt = VT_I2;
            var.vt = VT_I2;
            break;
        }
 */
        vdElem.elemdescVar.tdesc.vt = VT_INT;
        var.vt = VT_I4;

        vdElem.lpvarValue = &var;

        while ( pLabel = (node_label *) MemIter.GetNext() )
        {
            WALK_CTXT ctxt(pLabel);
            vdElem.wVarFlags = (unsigned short)GetVarFlags(&ctxt);
            vdElem.elemdescVar.idldesc.wIDLFlags = GetIDLFlags(&ctxt);

/* see previous comment
            switch (uSize)
            {
            case 2:
                vdElem.lpvarValue->iVal = (short) pLabel->GetValue();
                break;
            case 4:
 */
                vdElem.lpvarValue->lVal = (long) pLabel->GetValue();
 /*
                break;
            default:
                vdElem.lpvarValue->iVal = (short) pLabel->GetValue();
                break;
            }
 */
            hr = pCTI->AddVarDesc(uIndex, &vdElem);
            if (FAILED(hr))
            {
                ReportTLGenError( "AddVarDesc failed", szName, hr);
            }

            szName = pLabel->GetSymName();

            A2O(wszScratch, szName, MAX_PATH);

            hr = pCTI->SetVarName(uIndex, wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( "Could not set name", szName, hr);
                }

            node_text_attr * pTA;
            if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
            {
                char * szHelpString = pTA->GetText();
                A2O(wszScratch, szHelpString, MAX_PATH);
                hr = pCTI->SetVarDocString(uIndex, wszScratch);
                if ( FAILED( hr ) )
                    {
                    ReportTLGenError( szErrHelpString, szName, hr);
                    }
            }

            node_constant_attr *pCA;
            if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
            {
                DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
                hr = pCTI->SetVarHelpContext(uIndex, hc);
                if ( FAILED( hr ) )
                    {
                    ReportTLGenError( szErrHelpContext, szName, hr);
                    }
            }

            if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
            {
                DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
                ((ICreateTypeInfo2 *)pCTI)->SetVarHelpStringContext( uIndex, hc );
            }
            ATTRLIST            myAttrs;
            node_base_attr  *   pCurAttr;
            VARIANT             variant;
            ATTR_T              curAttrID;
            GUID                guid;

            ((named_node*)pLabel)->GetAttributeList( myAttrs );

            pCurAttr    =   myAttrs.GetFirst();
            while ( pCurAttr )
                {
                curAttrID = pCurAttr->GetAttrID();

                if (curAttrID == ATTR_CUSTOM)
                    {
                    ZeroMemory( &variant,
                                sizeof(variant));
                    ConvertToVariant(   variant,
                                        ((node_custom_attr*)pCurAttr)->GetVal(), 
                                        pCCB->GetLcid());
                    ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                    ((ICreateTypeInfo2 *)pCTI)->SetVarCustData( uIndex,
                                                                guid,
                                                                &variant);
                    }
                pCurAttr = pCurAttr->GetNext();
                }
            uIndex++;
        };

        // Set all common type attributes
        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        VARIANT             variant;
        ATTR_T              curAttrID;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );
        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &variant,
                            sizeof(variant));
                ConvertToVariant(   variant,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &variant);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *)ctxt.ExtractAttribute(ATTR_GUID);

        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) && hr != 0x800288C6L )
                {
                // do not report duplicate UUID errors. Duplicate UUIDs
                // are caught by the front end. They only way they can
                // occur here is because tries to set the UUID on both
                // the typedef and the enum. This is benign.
                ReportTLGenWarning( szErrUUID, pEnum->GetSymName(), hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        node_version * pVer = (node_version *) ctxt.GetAttribute(ATTR_VERSION);
        if (pVer)
            pVer->GetVersion(&Maj, &Min);
        else
        {
            Maj = Min = 0;
        }
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        hr = pCTI->SetAlignment( GetMemoryAlignment() );
        hr = pCTI->LayOut();
        if FAILED(hr)
        {
            ReportTLGenError( "LayOut failed on enum", szName, hr);
        }
        LayedOut();
    }
    else
    {
        // It's possible that this type has already been created.
        if (NULL == (pCTI = (ICreateTypeInfo *)gpobjholder->Find(szName)))
            ReportTLGenError( "CreateTypeInfo failed", szName, hr);
        pCCB->SetCreateTypeInfo(pCTI);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_STRUCT::GenTypeInfo
//
//  Synopsis:   generates a type info for a struct
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      see note at beginning of this file about CG_STATUS return
//              codes and cyclic dependencies
//
//----------------------------------------------------------------------------

CG_STATUS CG_STRUCT::GenTypeInfo(CCB *pCCB)
{
    HRESULT hr;

    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        // we have
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        if (!IsReadyForLayOut())
        {
            return CG_NOT_LAYED_OUT;
        }
        if (!AreDepsLayedOut())
        {
            // avoid infinite loops
            DepsLayedOut();

            // give dependents a chance to be layed out
            CG_ITERATOR I;
            CG_CLASS *pCG;
            GetMembers(I);
            I.Init();
            CG_STATUS cgs = CG_OK;
            while(ITERATOR_GETNEXT(I, pCG))
            {
                switch(pCG->GenTypeInfo(pCCB))
                {
                case CG_NOT_LAYED_OUT:
                    cgs = CG_NOT_LAYED_OUT;
                    break;
                case CG_REF_NOT_LAYED_OUT:
                    if (CG_OK == cgs)
                        cgs = CG_REF_NOT_LAYED_OUT;
                    break;
                default:
                    break;
                }
            }
            if (cgs != CG_OK)
            {
                ClearDepsLayedOut();
                return cgs;
            }
        }

        // SetAlignment()
        hr = ((ICreateTypeInfo *)_pCTI)->SetAlignment( GetMemoryAlignment() );
        hr = ((ICreateTypeInfo *)_pCTI)->LayOut();
        LayedOut();
        return CG_OK;
    }
    BOOL fDependentsLayedOut = TRUE;
    BOOL fICanLayOut = TRUE;

    char * szName = ((node_su_base *)GetBasicType())->GetTypeInfoName();
    // HACK HACK HACK: special case to keep the base types 
    //                 CY and DECIMAL from getting entered into the library
    if (0 == _stricmp(szName, "CY") || 0 == _stricmp(szName, "DECIMAL"))
        return CG_OK;
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    A2O(wszScratch, szName, MAX_PATH);
    hr = pCTL->CreateTypeInfo(wszScratch, TKIND_RECORD, &pCTI);
    if SUCCEEDED(hr)
    {
        // remember the ICreateTypeInfo pointer
        _pCTI = pCTI;
        gpobjholder->Add(pCTI);
        pCCB->SetCreateTypeInfo(pCTI);

        CG_ITERATOR I;
        CG_CLASS * pCG;

        GetMembers(I);
        I.Init();

        unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
        pCCB->SetVarNum(0);

        // walk members, adding them to the type info
        while (ITERATOR_GETNEXT(I, pCG))
        {
            CG_STATUS cgs = pCG->GenTypeInfo(pCCB);
            switch (cgs)
            {
            case CG_NOT_LAYED_OUT:
                fICanLayOut = FALSE;
                // fall through
            case CG_REF_NOT_LAYED_OUT:
                fDependentsLayedOut = FALSE;
                // fall through
            default:
                break;
            }
        }

        pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);

        // Set all common type attributes
        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *)ctxt.ExtractAttribute(ATTR_GUID);

        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        node_version * pVer = (node_version *) ctxt.GetAttribute(ATTR_VERSION);
        if (pVer)
            pVer->GetVersion(&Maj, &Min);
        else
        {
            Maj = Min = 0;
        }
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        ReadyForLayOut();
        if (fICanLayOut)
        {
            // SetAlignment()
            hr = pCTI->SetAlignment( GetMemoryAlignment() );
            hr = pCTI->LayOut();
            if FAILED(hr)
            {
                ReportTLGenError( "LayOut failed on struct",szName, hr);
            }
            LayedOut();
            if (!fDependentsLayedOut)
            {
                // The only way I can get here is if my dependents were either blocked by me
                // or blocked by one of my ancestors.
                // Now that I've been layed out, they may no longer be blocked.
                BOOL fSucceeded = TRUE;
                I.Init();
                while (ITERATOR_GETNEXT(I, pCG))
                {
                    CG_STATUS cgs = pCG->GenTypeInfo(pCCB);
                    if (CG_OK != cgs)
                        fSucceeded = FALSE;
                }
                if (fSucceeded)
                {
                    DepsLayedOut();
                    return CG_OK;
                }
                return CG_REF_NOT_LAYED_OUT;
            }
            DepsLayedOut();
            return CG_OK;
        }
    }
    else
    {
        ReportTLGenError( "CreateTypeInfo failed", szName, hr);
    }
    return CG_NOT_LAYED_OUT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_UNION::GenTypeInfo
//
//  Synopsis:   generates a type info for a union
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      see note at beginning of this file about CG_STATUS return
//              codes and cyclic dependencies
//
//----------------------------------------------------------------------------

CG_STATUS CG_UNION::GenTypeInfo(CCB *pCCB)
{
    HRESULT hr;

    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        // we have
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        if (!IsReadyForLayOut())
        {
            return CG_NOT_LAYED_OUT;
        }
        if (!AreDepsLayedOut())
        {
            // avoid infinite loops
            DepsLayedOut();

            // give dependents a chance to be layed out
            CG_ITERATOR I;
            CG_CLASS *pCG;
            GetMembers(I);
            I.Init();
            CG_STATUS cgs = CG_OK;
            while(ITERATOR_GETNEXT(I, pCG))
            {
                switch(pCG->GenTypeInfo(pCCB))
                {
                case CG_NOT_LAYED_OUT:
                    cgs = CG_NOT_LAYED_OUT;
                    break;
                case CG_REF_NOT_LAYED_OUT:
                    if (CG_OK == cgs)
                        cgs = CG_REF_NOT_LAYED_OUT;
                    break;
                default:
                    break;
                }
            }
            if (cgs != CG_OK)
            {
                ClearDepsLayedOut();
                return cgs;
            }
        }

        hr = ((ICreateTypeInfo *)_pCTI)->SetAlignment( GetMemoryAlignment() );
        hr = ((ICreateTypeInfo *)_pCTI)->LayOut();
        if FAILED(hr)
        {
            char * szName = ((node_su_base *)GetBasicType())->GetTypeInfoName();
            if ( !szName )
                szName = GetSymName();
            ReportTLGenError( "LayOut failed on union", szName, hr);
        }
        LayedOut();
        return CG_OK;
    }
    BOOL fDependentsLayedOut = TRUE;
    BOOL fICanLayOut = TRUE;
    char * szName = ((node_su_base *)GetBasicType())->GetTypeInfoName();
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    A2O(wszScratch, szName, MAX_PATH);
    hr = pCTL->CreateTypeInfo(wszScratch, TKIND_UNION, &pCTI);
    if SUCCEEDED(hr)
    {
        // remember the ICreateTypeInfo pointer
        _pCTI = pCTI;
        gpobjholder->Add(pCTI);
        pCCB->SetCreateTypeInfo(pCTI);

        CG_ITERATOR I;
        CG_CLASS * pCG;

        GetMembers(I);
        I.Init();

        unsigned uRememberPreviousVarNum = pCCB->GetVarNum();
        pCCB->SetVarNum(0);

        // walk members, adding them to the type info
        while (ITERATOR_GETNEXT(I, pCG))
        {
            CG_STATUS cgs = pCG->GenTypeInfo(pCCB);
            switch (cgs)
            {
            case CG_NOT_LAYED_OUT:
                fICanLayOut = FALSE;
                // fall through
            case CG_REF_NOT_LAYED_OUT:
                fDependentsLayedOut = FALSE;
                // fall through
            default:
                break;
            }
        }

        pCCB->SetVarNum((unsigned short)uRememberPreviousVarNum);

        // Set all common type attributes
        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *)ctxt.ExtractAttribute(ATTR_GUID);

        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        node_version * pVer = (node_version *) ctxt.GetAttribute(ATTR_VERSION);
        if (pVer)
            pVer->GetVersion(&Maj, &Min);
        else
        {
            Maj = Min = 0;
        }
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        ReadyForLayOut();
        if (fICanLayOut)
        {
            hr = pCTI->SetAlignment( GetMemoryAlignment() );
            hr = pCTI->LayOut();
            if FAILED(hr)
            {
                ReportTLGenError( "LayOut failed on union", szName, hr);
            }
            LayedOut();
            if (!fDependentsLayedOut)
            {
                // The only way I can get here is if my dependents were either blocked by me
                // or blocked by one of my ancestors.
                // Now that I've been layed out, they may no longer be blocked.
                BOOL fSucceeded = TRUE;
                I.Init();
                while (ITERATOR_GETNEXT(I, pCG))
                {
                    CG_STATUS cgs = pCG->GenTypeInfo(pCCB);
                    if (CG_OK != cgs)
                        fSucceeded = FALSE;
                }
                if (fSucceeded)
                {
                    DepsLayedOut();
                    return CG_OK;
                }
                return CG_REF_NOT_LAYED_OUT;
            }
            DepsLayedOut();
            return CG_OK;
        }
    }
    else
    {
        ReportTLGenError( "CreateTypeInfo failed", szName, hr);
    }
    return CG_NOT_LAYED_OUT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_PROC::GenTypeInfo
//
//  Synopsis:   generates a type info for a procedure
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_PROC::GenTypeInfo(CCB *pCCB)
{
    OLECHAR ** rgwsz = NULL;
    FUNCDESC fdesc;
    memset(&fdesc, 0, sizeof(FUNCDESC));
    fdesc.memid = DISPID_UNKNOWN;
    CG_RETURN * pRet = GetReturnType();
    TYPEDESC * ptdesc = NULL;
    CG_CLASS * pComplexReturnType = NULL;

    // 
    // If the function has a complex return type, it get's transformed such
    // that the return type is represented as an extra parameter which is a
    // simple ref pointer to the type.  The actual return type is void.  
    // Oleaut doesn't like this however so mangle things around.
    //

    if ( HasComplexReturnType() )
        {
        CG_CLASS *pPrev = NULL;
        CG_CLASS *pCur  = GetChild();

        // Find the last param

        while ( NULL != pCur->GetSibling() )
            {
            pPrev = pCur;
            pCur = pCur->GetSibling();
            }

        MIDL_ASSERT( NULL == pRet );
        pRet = (CG_RETURN *) pCur;
        
        // Make the return type the actual type, not a pointer to the type
        pComplexReturnType = pRet->GetChild();
        pRet->SetChild( pComplexReturnType->GetChild() );

        SetReturnType( pRet );

        // Remove the extra "return type" param

        if ( NULL == pPrev )
            SetChild( NULL );
        else
            pPrev->SetSibling( NULL );
        }

    if (pRet)
    {
        pRet->GetTypeDesc(ptdesc, pCCB);
        if (!ptdesc)
        {
            ReportTLGenError( "return type has no type", GetSymName(), 0);
        }
        memcpy(&fdesc.elemdescFunc.tdesc, ptdesc, sizeof(TYPEDESC));
    }
    else
    {
        // no return type specified
        // CONSIDER - emit warning?
        fdesc.elemdescFunc.tdesc.vt = VT_VOID;
    }

    node_proc * pProc = (node_proc *)GetType();
    WALK_CTXT ctxt(pProc);
    fdesc.elemdescFunc.idldesc.wIDLFlags = GetIDLFlags(&ctxt);
    BOOL fPropGet, fPropPut, fPropPutRef, fVararg;
    fdesc.wFuncFlags = (unsigned short)GetFuncFlags(&ctxt, &fPropGet, &fPropPut, &fPropPutRef, &fVararg);

    ICreateTypeInfo * pCTI = pCCB->GetCreateTypeInfo();

    CG_ITERATOR I;
    CG_PARAM * pCG;
    GetMembers(I);
    int cParams = I.GetCount();
    fdesc.cParams = (unsigned short)cParams;
    fdesc.lprgelemdescParam = new ELEMDESC [fdesc.cParams];
    memset(fdesc.lprgelemdescParam, 0, sizeof(ELEMDESC) * fdesc.cParams);
    rgwsz = new WCHAR * [fdesc.cParams + 1];
    memset(rgwsz, 0, sizeof (WCHAR *) * (fdesc.cParams + 1));

    I.Init();

    int nParam = 0;

    while (ITERATOR_GETNEXT(I, pCG))
    {
        rgwsz[nParam + 1] = TranscribeA2O( pCG->GetSymName() );

        TYPEDESC * ptdesc;
        pCG->GetTypeDesc(ptdesc, pCCB);
        memcpy(&fdesc.lprgelemdescParam[nParam].tdesc, ptdesc, sizeof (TYPEDESC));
        delete ptdesc;

        node_constant_attr * pCA;
        WALK_CTXT ctxt(pCG->GetType());
        fdesc.lprgelemdescParam[nParam].idldesc.wIDLFlags = GetIDLFlags(&ctxt);

        if (pCG->IsOptional())
        {
            fdesc.cParamsOpt++;
            fdesc.lprgelemdescParam[nParam].paramdesc.wParamFlags |= PARAMFLAG_FOPT;
            if (pCA = (node_constant_attr *)ctxt.GetAttribute(ATTR_DEFAULTVALUE))
            {
                fdesc.cParamsOpt = 0;
                fdesc.lprgelemdescParam[nParam].paramdesc.wParamFlags |= PARAMFLAG_FHASDEFAULT;
                fdesc.lprgelemdescParam[nParam].paramdesc.pparamdescex = new PARAMDESCEX;
                fdesc.lprgelemdescParam[nParam].paramdesc.pparamdescex->cBytes = sizeof(PARAMDESCEX);
                TYPEDESC tdesc = fdesc.lprgelemdescParam[nParam].tdesc;
                if (tdesc.vt == VT_PTR && (fdesc.lprgelemdescParam[nParam].idldesc.wIDLFlags & IDLFLAG_FOUT) != 0)
                {
                    // handle OUT parameters correctly
                    tdesc = *tdesc.lptdesc;
                }
                GetValueFromExpression(
                fdesc.lprgelemdescParam[nParam].paramdesc.pparamdescex->varDefaultValue,
                tdesc,
                pCA->GetExpr(),
                pCCB->GetLcid(),
                GetSymName());
            }
            else
            {
                if (!IsVariantBasedType(fdesc.lprgelemdescParam[nParam].tdesc))
                {
                fdesc.cParamsOpt = 0;
                }
            }
        }
        else
        {
            if (!pCG->IsRetval())
            {
                fdesc.cParamsOpt = 0;
            }
        }

        nParam++;
        if (pCG->IsRetval())
        {
            fdesc.lprgelemdescParam[nParam - 1].paramdesc.wParamFlags |= PARAMFLAG_FRETVAL;
        }
    }

    unsigned cchPrefixString = 0;
    if (fVararg)
    {
        fdesc.cParamsOpt = -1;
    }
    if (fPropGet)
    {
        fdesc.invkind = INVOKE_PROPERTYGET;
        cchPrefixString = 4;
    }
    else if (fPropPut)
    {
        fdesc.invkind = INVOKE_PROPERTYPUT;
        cchPrefixString = 4;
    }
    else if (fPropPutRef)
    {
        fdesc.invkind = INVOKE_PROPERTYPUTREF;
        cchPrefixString = 7;
    }
    else
    {
        fdesc.invkind = INVOKE_FUNC;
    }

    switch(GetProckind())
    {
    case PROC_STATIC:
        fdesc.funckind = FUNC_STATIC;
        break;
    case PROC_PUREVIRTUAL:
    default:
        fdesc.funckind = FUNC_PUREVIRTUAL;
        break;
    }

    node_constant_attr *pCA;

    unsigned uFunc = pCCB->GetProcNum();
    if (pCCB->IsInDispinterface())
    {
        fdesc.funckind = FUNC_DISPATCH;
        fdesc.memid = 0x60000000 + uFunc;
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_ID))
    {
        fdesc.memid = (ulong) pCA->GetExpr()->GetValue();
    }

    ATTR_T cc;
    pProc->GetCallingConvention(cc);
    switch(cc)
    {
    case ATTR_STDCALL:
        fdesc.callconv = CC_STDCALL;
        break;
    case ATTR_CDECL:
        fdesc.callconv = CC_CDECL;
        break;
    case ATTR_PASCAL:
        fdesc.callconv = CC_PASCAL;
        break;
    case ATTR_FASTCALL:
    case ATTR_FORTRAN:
        // There is no appropriate CC setting for FASTCALL or FORTRAN
        // CONSIDER - consider displaying a warning
    default:
        fdesc.callconv = CC_STDCALL;
        break;
    }

    char * szName = GetSymName();

    HRESULT hr = pCTI->AddFuncDesc(uFunc, &fdesc);
    if (FAILED(hr))
    {
        ReportTLGenError( "AddFuncDesc failed", szName, hr);
    }

    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    VARIANT             var;
    GUID                guid;

    // process custom attributes for function
    ((named_node*)GetType())->GetAttributeList( myAttrs );
    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeInfo2 *)pCTI)->SetFuncCustData(uFunc,
                                                        guid,
                                                        &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    // process custom attributes for each param.
    I.Init();
    nParam = 0;
    while (ITERATOR_GETNEXT(I, pCG))
        {
        ((named_node*)(pCG->GetType()))->GetAttributeList( myAttrs );
        pCurAttr    =   myAttrs.GetFirst();

        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetParamCustData(   uFunc,
                                                                nParam,
                                                                guid,
                                                                &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }
        pCA = (node_constant_attr *) ctxt.GetAttribute( ATTR_HELPSTRINGCONTEXT );
        if ( pCA )
            {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetVarHelpStringContext( nParam, hc );
            }
        nParam++;
        }

    if (ptdesc)
    {
        DeleteTypedescChildren(ptdesc);
        delete ptdesc;
    }

    if (szName)
    {
        rgwsz[0] = TranscribeA2O( szName + cchPrefixString );
        hr = pCTI->SetFuncAndParamNames(uFunc, rgwsz, fdesc.cParams + (fPropPut | fPropPutRef ? 0 : 1));
        if (FAILED(hr))
        {
            ReportTLGenError( "SetFuncAndParamNames failed", szName, hr);
        }
    }

    node_text_attr * pTA;
    if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        hr = pCTI->SetFuncDocString(uFunc, wszScratch);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpString, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        hr = pCTI->SetFuncHelpContext(uFunc, hc);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpContext, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeInfo2 *)pCTI)->SetFuncHelpStringContext(uFunc, hc);
    }

    node_entry_attr * pEA;
    if (pEA = (node_entry_attr *)ctxt.GetAttribute(ATTR_ENTRY))
    {
        if (!pCCB->GetDllName())
            {
            RpcError(NULL, 0, DLLNAME_REQUIRED, szName);
            exit(ERR_TYPELIB_GENERATION);
            }

        A2O(wszScratch, pCCB->GetDllName(), MAX_PATH);

        WCHAR * wszEntry;
        if (pEA->IsNumeric())
        {
            wszEntry = (WCHAR *)pEA->GetID();
            MIDL_ASSERT(HIWORD(wszEntry) == 0);
        }
        else
        {
            char * szEntry = pEA->GetSz();
            MIDL_ASSERT(HIWORD(szEntry) != 0);
            wszEntry = TranscribeA2O( szEntry );
        }
        hr = pCTI->DefineFuncAsDllEntry(uFunc, wszScratch, wszEntry);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( "Could not set entry point", szName, hr);
            }
        if (HIWORD(wszEntry))
            delete [] wszEntry;
    }

    // clean up allocated stuff:
    unsigned n;
    // use cParams sinc fdesc.cParams might have been decrimented
    for (n = cParams; n--; )
    {
        DeleteTypedescChildren(&fdesc.lprgelemdescParam[n].tdesc);
    }
    delete [] fdesc.lprgelemdescParam;
    for (n = cParams + 1; n--; )
    {
        delete [] rgwsz[n];
    }
    delete [] rgwsz;

    // bump the variable number
    pCCB->SetProcNum(unsigned short(uFunc + 1));

    // Undo the complex return type changes from above

    if ( HasComplexReturnType() )
        {
        pRet->SetChild( pComplexReturnType );

        CG_CLASS *pCur = GetChild();

        if ( !pCur )
            {
            SetChild( pRet );
            }
        else
            {
            while ( NULL != pCur->GetSibling() )
                pCur = pCur->GetSibling();

            pCur->SetSibling( pRet );
            }
        }

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_PARAM::GetTypeDesc
//
//  Synopsis:   generates a TYPEDESC for a parameter
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_PARAM::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    return(GetChild()->GetTypeDesc(ptd, pCCB));
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_CASE::GenTypeInfo
//
//  Synopsis:   generates type information for a union member
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//  Notes:      CG_CASE nodes are not interesting for type info generation
//              since case information can't be stored in type libraries.
//              However, CG_CASE nodes are often found between CG_UNION nodes
//              and CG_FIELD nodes.  This method just forwards the method
//              call on down the chain.
//
//----------------------------------------------------------------------------

CG_STATUS CG_CASE::GenTypeInfo(CCB *pCCB)
{
    return(GetChild()->GenTypeInfo(pCCB));
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_FIELD::GenTypeInfo
//
//  Synopsis:   adds a Vardesc to the current type info for this union or
//              structure field
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-13-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_FIELD::GenTypeInfo(CCB *pCCB)
{
    if (IsReadyForLayOut())
    {
        // this node has been visited before, just make sure its dependents
        // get the chance to lay themselves out
        CG_CLASS * pCG = GetChild();
        if (NULL == pCG)
            return CG_OK;
        TYPEDESC * ptdesc;
        CG_STATUS cgs = pCG->GetTypeDesc(ptdesc, pCCB);
        if (ptdesc)
        {
            DeleteTypedescChildren(ptdesc);
            delete ptdesc;
        }
        return cgs;
    }
    VARDESC vdesc;
    memset(&vdesc, 0, sizeof(VARDESC));
    CG_CLASS * pCG = GetChild();
    if (NULL == pCG)
        return CG_OK;
    char * szName = GetSymName();
    TYPEDESC * ptdesc;
    CG_STATUS cgs = pCG->GetTypeDesc(ptdesc, pCCB);
    if (!ptdesc)
    {
        ReportTLGenError( "field has no type", szName, 0);
    }
    memcpy(&vdesc.elemdescVar.tdesc, ptdesc, sizeof(TYPEDESC));

    WALK_CTXT ctxt(GetType());
    vdesc.elemdescVar.idldesc.wIDLFlags = GetIDLFlags(&ctxt);
    vdesc.wVarFlags = (unsigned short)GetVarFlags(&ctxt);

    ICreateTypeInfo * pCTI = pCCB->GetCreateTypeInfo();

    unsigned uVar = pCCB->GetVarNum();
    node_constant_attr *pCA;
    if (pCCB->IsInDispinterface())
    {
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_ID))
        {
            vdesc.memid = (ulong) pCA->GetExpr()->GetValue();
        }
        else
        {
            vdesc.memid = 0x30000000 + uVar;
        }
        vdesc.varkind = VAR_DISPATCH;
    }
    else
    {
        vdesc.memid = DISPID_UNKNOWN;
        vdesc.varkind = VAR_PERINSTANCE;
    }

    HRESULT hr = pCTI->AddVarDesc(uVar, &vdesc);
    if (FAILED(hr))
    {
        ReportTLGenError( "AddVarDesc failed", szName, hr);
    }
    DeleteTypedescChildren(ptdesc);
    delete ptdesc;


    ATTRLIST            myAttrs;
    node_base_attr  *   pCurAttr;
    ATTR_T              curAttrID;
    VARIANT             var;
    GUID                guid;

    ((named_node*)GetType())->GetAttributeList( myAttrs );

    pCurAttr    =   myAttrs.GetFirst();
    while ( pCurAttr )
        {
        curAttrID = pCurAttr->GetAttrID();

        if (curAttrID == ATTR_CUSTOM)
            {
            ZeroMemory( &var,
                        sizeof(VARIANT));
            ConvertToVariant(   var,
                                ((node_custom_attr*)pCurAttr)->GetVal(), 
                                pCCB->GetLcid());
            ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
            ((ICreateTypeInfo2 *)pCTI)->SetVarCustData( uVar,
                                                        guid,
                                                        &var);
            }
        pCurAttr = pCurAttr->GetNext();
        }

    if (szName)
    {
        A2O(wszScratch, szName, MAX_PATH);
        hr = pCTI->SetVarName(uVar, wszScratch);
        if (FAILED(hr))
        {
            ReportTLGenError( "SetVarName failed", szName, hr);
        }
    }

    node_text_attr * pTA;
    if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
    {
        char * szHelpString = pTA->GetText();
        A2O(wszScratch, szHelpString, MAX_PATH);
        hr = pCTI->SetVarDocString(uVar,wszScratch);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpString, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        hr = pCTI->SetVarHelpContext(uVar, hc);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrHelpContext, szName, hr);
            }
    }

    if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
    {
        DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
        ((ICreateTypeInfo2 *)pCTI)->SetVarHelpStringContext( uVar, hc );
    }

    // bump the variable number
    pCCB->SetVarNum(unsigned short(uVar + 1));

    ReadyForLayOut();
    return cgs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CG_TYPEDEF::GenTypeInfo
//
//  Synopsis:   generates a type info for a TYPEDEF
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_TYPEDEF::GenTypeInfo(CCB *pCCB)
{
    // check to see if we've already been created
    if (NULL != _pCTI)
    {
        pCCB->SetCreateTypeInfo((ICreateTypeInfo *) _pCTI);
        if (!IsLayedOut())
        {
            if (!IsReadyForLayOut())
            {
                return CG_NOT_LAYED_OUT;
            }
            // give dependents a chance to be layed out

            TYPEDESC * ptdesc;
            CG_STATUS cgs = GetChild()->GetTypeDesc(ptdesc, pCCB);
            if (ptdesc)
            {
                DeleteTypedescChildren(ptdesc);
                delete ptdesc;
            }

            if (cgs == CG_OK)
            {
                HRESULT hr;
                unsigned short MemAlignment = GetMemoryAlignment();

                if ( MemAlignment )
                    hr = ((ICreateTypeInfo *)_pCTI )->SetAlignment( MemAlignment);
                hr = ((ICreateTypeInfo *)_pCTI)->LayOut();
                if (SUCCEEDED(hr))
                {
                    LayedOut();
                    return CG_OK;
                }
            }
            return cgs;
        }
        return CG_OK;
    }
    char * szName = GetSymName();
    // Due to the nature of the MIDL compiler, it is possible that
    // certain OLE Automation base types may show up here.  The following
    // test makes sure that type info isn't created for these types.
    if ((0 == strcmp(szName, "VARIANT")) || (0 == strcmp(szName, "wireVARIANT"))
        || (0 == strcmp(szName, "DATE")) || (0 == strcmp(szName, "HRESULT"))
        || (0 == strcmp(szName, "CURRENCY")) || (0 == strcmp(szName, "CY"))
        || (0 == strcmp(szName, "DECIMAL")) 
        || (0 == strcmp(szName, "wireBSTR")))
    {
        return CG_OK;
    }
    // SPECIAL CASE: If both the typedef and it's child share the same name, then
    // we MUST NOT enter a TKIND_ALIAS for the typedef.  Otherwise we will get name
    // conflicts.
    node_skl * pBasicType = GetBasicType();
    NODE_T type = pBasicType->NodeKind();
    if (type == NODE_STRUCT || type == NODE_ENUM || type == NODE_UNION)
    {    
        char * szChildName = ((node_su_base *)pBasicType)->GetTypeInfoName();
        if (szChildName)
        {
            if ( 0 == strcmp(szName, szChildName) && !GetChild()->IsInterfacePointer() )
            {
                return GetChild()->GenTypeInfo(pCCB);
            }
        }
    }
    ICreateTypeLib * pCTL = pCCB->GetCreateTypeLib();
    ICreateTypeInfo * pCTI;

    A2O(wszScratch, szName, MAX_PATH);
    HRESULT hr = pCTL->CreateTypeInfo(wszScratch, TKIND_ALIAS, &pCTI);
    if SUCCEEDED(hr)
    {
        // remember the ICreateTypeInfo pointer
        _pCTI = pCTI;
        gpobjholder->Add(pCTI, szName);
        pCCB->SetCreateTypeInfo(pCTI);
        TYPEDESC * ptdesc;

        // Set all common type attributes
        WALK_CTXT ctxt(GetType());
        hr = pCTI->SetTypeFlags(GetTypeFlags(&ctxt));
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrTypeFlags, szName, hr);
            }

        ATTRLIST            myAttrs;
        node_base_attr  *   pCurAttr;
        ATTR_T              curAttrID;
        VARIANT             var;
        GUID                guid;

        ((named_node*)GetType())->GetAttributeList( myAttrs );

        pCurAttr    =   myAttrs.GetFirst();
        while ( pCurAttr )
            {
            curAttrID = pCurAttr->GetAttrID();

            if (curAttrID == ATTR_CUSTOM)
                {
                ZeroMemory( &var,
                            sizeof(VARIANT));
                ConvertToVariant(   var,
                                    ((node_custom_attr*)pCurAttr)->GetVal(), 
                                    pCCB->GetLcid());
                ((node_custom_attr*)pCurAttr)->GetGuid()->GetGuid(guid);
                ((ICreateTypeInfo2 *)pCTI)->SetCustData(guid,
                                                        &var);
                }
            pCurAttr = pCurAttr->GetNext();
            }

        node_guid * pGuid = (node_guid *)ctxt.ExtractAttribute(ATTR_GUID);

        if (pGuid)
        {
            GUID guid;
            pGuid->GetGuid(guid);
            hr = pCTI->SetGuid(guid);
            if ( FAILED( hr ) )
                {
                ReportTLGenWarning( szErrUUID, szName, hr);
                }
        }

        node_text_attr * pTA;
        if (pTA = (node_text_attr *)ctxt.GetAttribute(ATTR_HELPSTRING))
        {
            char * szHelpString = pTA->GetText();
            A2O(wszScratch, szHelpString, MAX_PATH);
            hr = pCTI->SetDocString(wszScratch);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpString, szName, hr);
                }
        }

        node_constant_attr *pCA;
        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            hr = pCTI->SetHelpContext(hc);
            if ( FAILED( hr ) )
                {
                ReportTLGenError( szErrHelpContext, szName, hr);
                }
        }

        if (pCA = (node_constant_attr *) ctxt.GetAttribute(ATTR_HELPSTRINGCONTEXT))
        {
            DWORD hc = (DWORD) pCA->GetExpr()->GetValue();
            ((ICreateTypeInfo2 *)pCTI)->SetHelpStringContext(hc);
        }

        unsigned short Maj;
        unsigned short Min;
        node_version * pVer = (node_version *) ctxt.GetAttribute(ATTR_VERSION);
        if (pVer)
            pVer->GetVersion(&Maj, &Min);
        else
        {
            Maj = Min = 0;
        }
        hr = pCTI->SetVersion(Maj, Min);
        if ( FAILED( hr ) )
            {
            ReportTLGenError( szErrVersion, szName, hr);
            }

        CG_STATUS cgs = GetChild()->GetTypeDesc(ptdesc, pCCB);
        if (ptdesc)
        {
            hr = pCTI->SetTypeDescAlias(ptdesc);
            if FAILED(hr)
            {
                ReportTLGenError( "SetTypeDescAlias failed", szName, hr);
            }
            DeleteTypedescChildren(ptdesc);
            delete ptdesc;
        }

        ReadyForLayOut();
        if (CG_NOT_LAYED_OUT != cgs)
        {
            if ( GetMemoryAlignment() )
                hr = pCTI->SetAlignment( GetMemoryAlignment() );

            hr = pCTI->LayOut();
            if FAILED(hr)
            {
                ReportTLGenError( "LayOut failed on typedef",szName, hr);
            }
            LayedOut();
            if (CG_REF_NOT_LAYED_OUT == cgs)
            {
                // The only way I can get here is if my dependents were either blocked by me
                // or blocked by one of my ancestors.
                // Now that I've been layed out, they may no longer be blocked.
                TYPEDESC * ptdesc;
                cgs = GetChild()->GetTypeDesc(ptdesc, pCCB);
                if (ptdesc)
                {
                    DeleteTypedescChildren(ptdesc);
                    delete ptdesc;
                }
                return (CG_OK == cgs ? CG_OK : CG_REF_NOT_LAYED_OUT);
            }
        }
        return cgs;
    }
    else
    {
        // It's possible that this type has already been created.
        if (NULL == (pCTI = (ICreateTypeInfo *)gpobjholder->Find(szName)))
            ReportTLGenError( "CreateTypeInfo failed", szName, hr);
        pCCB->SetCreateTypeInfo(pCTI);
    }
    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_FIXED_ARRAY::GetTypeDesc
//
//  Synopsis:   generates a TYPEDESC for an array
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_FIXED_ARRAY::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    ptd = new TYPEDESC;
    CG_CLASS * pElement = this;
    unsigned short cDims = GetDimensions();

    MIDL_ASSERT(cDims > 0);

    ptd->vt = VT_CARRAY;
    ptd->lpadesc = (ARRAYDESC *) new BYTE [ sizeof(ARRAYDESC) +
                                            (cDims - 1) * sizeof (SAFEARRAYBOUND)
                                          ];
    ptd->lpadesc->cDims = cDims;
    int i;
    for (i = 0; i<cDims; i++)
    {
        ptd->lpadesc->rgbounds[i].lLbound = 0;
        ptd->lpadesc->rgbounds[i].cElements = ((CG_FIXED_ARRAY *)pElement)->GetNumOfElements();
        pElement = pElement->GetChild();
    }

    TYPEDESC * ptdElem;
    CG_STATUS cgs = pElement->GetTypeDesc(ptdElem, pCCB);
    memcpy(&ptd->lpadesc->tdescElem, ptdElem, sizeof(TYPEDESC));
    delete ptdElem;

    return cgs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_CONFORMANT_ARRAY::GetTypeDesc
//
//  Synopsis:   generates a TYPEDESC for a conformant array
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      Conformant arrays are not directly representable in type
//              info, so they get converted to pointers.
//
//----------------------------------------------------------------------------

CG_STATUS CG_CONFORMANT_ARRAY::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    ptd = new TYPEDESC;
    MIDL_ASSERT(1 == GetDimensions());
    ptd->vt = VT_PTR;
    CG_CLASS * pElement = GetChild();
    CG_STATUS cgs = pElement->GetTypeDesc(ptd->lptdesc, pCCB);
    return (CG_OK == cgs ? CG_OK : CG_REF_NOT_LAYED_OUT);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_POINTER::CheckImportLib
//
//  Synopsis:   Checks to see if a particular CG node has a definition in
//              an imported type libaray.
//
//  Returns:    NULL  => the node has no imported definition
//              !NULL => ITypeInfo pointer for the imported type definition
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      see description of CG_NDR::CheckImportLib
//
//----------------------------------------------------------------------------

void * CG_INTERFACE_POINTER::CheckImportLib()
{
    node_skl * pn = GetTheInterface();
    node_file * pf = pn->GetDefiningFile();
    if (pf && (pf->GetImportLevel() > 0) )
    {
        A2O(wszScratch, pn->GetSymName(), MAX_PATH);

        return(gtllist.FindName(pf->GetFileName(), wszScratch));
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_IIDIS_INTERFACE_POINTER::CheckImportLib
//
//  Synopsis:   Checks to see if a particular CG node has a definition in
//              an imported type libaray.
//
//  Returns:    NULL  => the node has no imported definition
//              !NULL => ITypeInfo pointer for the imported type definition
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      see description of CG_NDR::CheckImportLib
//
//----------------------------------------------------------------------------

void * CG_IIDIS_INTERFACE_POINTER::CheckImportLib()
{
    node_skl * pn = GetBaseInterface();
    node_file * pf = pn->GetDefiningFile();
    if (pf && (pf->GetImportLevel() > 0) )
    {
        A2O(wszScratch, pn->GetSymName(), MAX_PATH);

        return(gtllist.FindName(pf->GetFileName(), wszScratch));
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_POINTER::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for an interface pointer
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      IDispatch* and IUnknown* are treated as special cases since
//              they are base types in ODL.
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE_POINTER::GetTypeDesc(TYPEDESC * &ptd, CCB *pCCB)
{
    ptd = new TYPEDESC;
    named_node* pPointee = GetTheInterface();

    if ( pPointee && pPointee->NodeKind() == NODE_INTERFACE_REFERENCE )
        {
        pPointee = ( ( node_interface_reference* ) pPointee )->GetRealInterface();
        }

    node_interface * pI = (node_interface*) pPointee;
    char * sz = pI->GetSymName();
    CG_STATUS cgs = CG_OK;

    if (0 == _stricmp(sz, "IDispatch"))
    {
        ptd->vt = VT_DISPATCH;
    }
    else if (0 == _stricmp(sz, "IUnknown"))
    {
        ptd->vt = VT_UNKNOWN;
    }
    else
    {
        CG_CLASS * pCG = GetTypeAlias();

        if (!pCG)
            {
            pCG = pI->GetCG(TRUE);
            if (!pCG)
                {
                // This must be an imported definition.
                // Call ILxlate to manufacture a CG node for it
                XLAT_CTXT ctxt(GetType());
                ctxt.SetAncestorBits(IL_IN_LIBRARY);
                pCG = pI->ILxlate(&ctxt);
                // make sure we get the right CG node
                if (pI->GetCG(TRUE))
                    pCG = pI->GetCG(TRUE);
                }
            }
        ptd->vt = VT_PTR;
        cgs = pCG->GetTypeDesc(ptd->lptdesc, pCCB);
    }
    return cgs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_IIDIS_INTERFACE_POINTER::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for an interface pointer
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      IDispatch* and IUnknown* are treated as special cases since
//              they are base types in ODL.
//
//----------------------------------------------------------------------------

CG_STATUS CG_IIDIS_INTERFACE_POINTER::GetTypeDesc(TYPEDESC * &ptd, CCB *pCCB)
{
    ptd = new TYPEDESC;
    pCCB;

    node_interface * pI = (node_interface*) GetBaseInterface();
    char * sz = pI->GetSymName();
    CG_STATUS cgs = CG_OK;

    if (0 == _stricmp(sz, "IDispatch"))
    {
        ptd->vt = VT_DISPATCH;
    }
    else if (0 == _stricmp(sz, "IUnknown"))
    {
        ptd->vt = VT_UNKNOWN;
    }
    else if ( pI->NodeKind() == NODE_VOID )
    {
        // this node is void * forced into interface because iid_is. 
        ptd->vt = VT_PTR ;
        ptd->lptdesc = new TYPEDESC;
        ptd->lptdesc->vt = VT_VOID;
    }
    else
    {
        // although it doesn't make sense to have (iid_is(riid), [out] IBar ** ppv),
        // I still have the tlb preserves what user specified.
        CG_CLASS * pCG = GetTypeAlias();

        if (!pCG)
            {
            pCG = pI->GetCG(TRUE);
            if (!pCG)
                {
                // This must be an imported definition.
                // Call ILxlate to manufacture a CG node for it
                XLAT_CTXT ctxt(GetType());
                ctxt.SetAncestorBits(IL_IN_LIBRARY);
                pCG = pI->ILxlate(&ctxt);
                // make sure we get the right CG node
                if (pI->GetCG(TRUE))
                    pCG = pI->GetCG(TRUE);
                }
            }
        ptd->vt = VT_PTR;
        cgs = pCG->GetTypeDesc(ptd->lptdesc, pCCB);
    }
    return cgs;
}



//+---------------------------------------------------------------------------
//
//  Member:     CG_INTERFACE_POINTER::GenTypeInfo
//
//  Synopsis:   generates type info for an interface pointer
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_INTERFACE_POINTER::GenTypeInfo(CCB * pCCB)
{
    node_interface * pI = GetTheInterface();
    char * sz = pI->GetSymName();

    if (0 == _stricmp(sz, "IDispatch"))
    {
        return CG_OK;
    }
    else if (0 == _stricmp(sz, "IUnknown"))
    {
        return CG_OK;
    }

    CG_CLASS * pCG = pI->GetCG(TRUE);
    if (!pCG)
    {
        // This must be an imported definition.
        // Call ILxlate to manufacture a CG node for it
        XLAT_CTXT ctxt(GetType());
        ctxt.SetAncestorBits(IL_IN_LIBRARY);
        pCG = pI->ILxlate(&ctxt);
        // make sure we get the right CG node
        pCG = pI->GetCG(TRUE);
    }
    return pCG->GenTypeInfo(pCCB);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_IIDIS_INTERFACE_POINTER::GenTypeInfo
//
//  Synopsis:   generates type info for an interface pointer
//
//  Arguments:  [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_NOT_LAYED_OUT
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_IIDIS_INTERFACE_POINTER::GenTypeInfo(CCB * pCCB)
{
    node_skl * pBase = GetBaseInterface();
    node_interface *pI;
    char * sz = pBase->GetSymName();

    // base can be void *
    if ( 0 == _stricmp(sz, "IDispatch") || 
         0 == _stricmp(sz, "IUnknown") ||
         pBase->NodeKind() == NODE_VOID  )
    {
        return CG_OK;
    }

    // semantic checking has forced the base to be either void ** 
    // or interface
    pI = (node_interface *)pBase;
    
    //preserve what's in the idl
    CG_CLASS * pCG = pI->GetCG(TRUE);
    if (!pCG)
    {
        // This must be an imported definition.
        // Call ILxlate to manufacture a CG node for it
        XLAT_CTXT ctxt(GetType());
        ctxt.SetAncestorBits(IL_IN_LIBRARY);
        pCG = pI->ILxlate(&ctxt);
        // make sure we get the right CG node
        pCG = pI->GetCG(TRUE);
    }
    return pCG->GenTypeInfo(pCCB);

}

//+---------------------------------------------------------------------------
//
//  Member:     CG_STRING_POINTER::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for a string pointer
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_REF_NOT_LAYED_OUT
//
//  History:    10-26-95  stevebl   Created
//
//  Notes:      BSTR, LPSTR and LPWSTR are handled as special cases because
//              they are base types in ODL.
//
//----------------------------------------------------------------------------

CG_STATUS CG_STRING_POINTER::GetTypeDesc(TYPEDESC * &ptd, CCB* )
{
    ptd = new TYPEDESC;
    ptd->lptdesc = NULL;

    if (((CG_STRING_POINTER *)this)->IsBStr())
    {
        ptd->vt = VT_BSTR;
    }
    else if (1 == ((CG_NDR *)GetChild())->GetMemorySize())
    {
        ptd->vt = VT_LPSTR;
    }
    else
    {
        ptd->vt = VT_LPWSTR;
    }

    return CG_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_POINTER::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for a pointer
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_POINTER::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    ptd = new TYPEDESC;
    ptd->vt = VT_PTR;
    CG_CLASS * pCG = GetChild();
    CG_STATUS cgs = pCG->GetTypeDesc(ptd->lptdesc, pCCB);
    return (CG_OK == cgs ? CG_OK : CG_REF_NOT_LAYED_OUT);
}

//+---------------------------------------------------------------------------
//
//  Member:     CG_SAFEARRAY::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for a SAFEARRAY
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//              CG_REF_NOT_LAYED_OUT
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

CG_STATUS CG_SAFEARRAY::GetTypeDesc(TYPEDESC * &ptd, CCB * pCCB)
{
    ptd = new TYPEDESC;
    ptd->vt = VT_SAFEARRAY;
    CG_STATUS cgs = GetChild()->GetTypeDesc(ptd->lptdesc, pCCB);
    return (CG_OK == cgs ? CG_OK : CG_REF_NOT_LAYED_OUT);
}

//+---------------------------------------------------------------------------
//
// The order of the items in this table must match the order of the items 
// in the node_t enumeration defined in midlnode.hxx.
//
// To make the dependency visible to C++ the browser, the third column has 
// explicit node_t enums that otherwise are not used for any purpose. (rkk).
//
// There is a VT_INT_PTR in the public headers that corresponds to __int3264.
// However, it is defined currently to VT_I4 or VT_I8, and definition can
// change on us unexpectedly. /use_vt_int_ptr switch addresses that problem.
//

// This table is used for Win32 with VT_INT_PTR being represented as VT_I4.
//
VARTYPE rgMapOldBaseTypeToVARTYPE[][3] =  // This table used for Win32.
    {
    //  unsigned        signed          not used
        {VT_R4,         VT_R4,          (VARTYPE) NODE_FLOAT },
        {VT_R8,         VT_R8,          (VARTYPE) NODE_DOUBLE },
        {0,             0,              (VARTYPE) NODE_FLOAT80 }, //not in TLB
        {0,             0,              (VARTYPE) NODE_FLOAT128 }, //not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_HYPER },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT64 },
        {0,             0,              (VARTYPE) NODE_INT128 },  //not in TLB
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT3264 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT32 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_LONG },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_LONGLONG },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_SHORT },
        {VT_UINT,       VT_INT,         (VARTYPE) NODE_INT },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_SMALL },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_CHAR },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BOOLEAN },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BYTE },
        {VT_VOID,       VT_VOID,        (VARTYPE) NODE_VOID },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_HANDLE_T },
        {0,             0,              (VARTYPE) NODE_FORWARD },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_WCHAR_T }
    };

// This table used for Win32 with VT_INT_PTR being represented as VT_INT_PTR.
// The table is used when the -use_vt_int_ptr is used.

VARTYPE rgMapBaseTypeToVARTYPE[][3] =  // This table used for Win32.
    {
    //  unsigned        signed          not used
        {VT_R4,         VT_R4,          (VARTYPE) NODE_FLOAT },
        {VT_R8,         VT_R8,          (VARTYPE) NODE_DOUBLE },
        {0,             0,              (VARTYPE) NODE_FLOAT80 }, //not in TLB
        {0,             0,              (VARTYPE) NODE_FLOAT128 }, //not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_HYPER },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT64 },
        {0,             0,              (VARTYPE) NODE_INT128 }, //not in TLB
        {VT_UINT_PTR,   VT_INT_PTR,     (VARTYPE) NODE_INT3264 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT32 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_LONG },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_LONGLONG },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_SHORT },
        {VT_UINT,       VT_INT,         (VARTYPE) NODE_INT },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_SMALL },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_CHAR },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BOOLEAN },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BYTE },
        {VT_VOID,       VT_VOID,        (VARTYPE) NODE_VOID },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_HANDLE_T },
        {0,             0,              (VARTYPE) NODE_FORWARD },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_WCHAR_T }
    };

// This table used for Win64 with VT_INT_PTR being represented as VT_I8.

VARTYPE rgMapOld64BaseTypeToVARTYPE[][3] =  
    {
    //  unsigned        signed          not used
        {VT_R4,         VT_R4,          (VARTYPE) NODE_FLOAT },
        {VT_R8,         VT_R8,          (VARTYPE) NODE_DOUBLE },
        {0,             0,              (VARTYPE) NODE_FLOAT80 },  //not in TLB
        {0,             0,              (VARTYPE) NODE_FLOAT128 }, //not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_HYPER },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT64 },
        {0,             0,              (VARTYPE) NODE_INT128 },   //not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT3264 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT32 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_LONG },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_LONGLONG },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_SHORT },
        {VT_UINT,       VT_INT,         (VARTYPE) NODE_INT },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_SMALL },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_CHAR },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BOOLEAN },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BYTE },
        {VT_VOID,       VT_VOID,        (VARTYPE) NODE_VOID },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_HANDLE_T },
        {0,             0,              (VARTYPE) NODE_FORWARD },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_WCHAR_T }
    };

// This table used for Win64 with VT_INT_PTR being represented as VT_INT_PTR.
// The table is used when the -use_vt_int_ptr is used.

VARTYPE rgMap64BaseTypeToVARTYPE[][3] =  // This table used for Win64.
    {
    //  unsigned        signed          not used
        {VT_R4,         VT_R4,          (VARTYPE) NODE_FLOAT },
        {VT_R8,         VT_R8,          (VARTYPE) NODE_DOUBLE },
        {0,             0,              (VARTYPE) NODE_FLOAT80 },  // not in TLB
        {0,             0,              (VARTYPE) NODE_FLOAT128 }, // not in TLB
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_HYPER },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_INT64 },
        {0,             0,              (VARTYPE) NODE_INT128 },   // not in TLB
        {VT_UINT_PTR,   VT_INT_PTR,     (VARTYPE) NODE_INT3264 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_INT32 },
        {VT_UI4,        VT_I4,          (VARTYPE) NODE_LONG },
        {VT_UI8,        VT_I8,          (VARTYPE) NODE_LONGLONG },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_SHORT },
        {VT_UINT,       VT_INT,         (VARTYPE) NODE_INT },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_SMALL },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_CHAR },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BOOLEAN },
        {VT_UI1,        VT_I1,          (VARTYPE) NODE_BYTE },
        {VT_VOID,       VT_VOID,        (VARTYPE) NODE_VOID },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_HANDLE_T },
        {0,             0,              (VARTYPE) NODE_FORWARD },
        {VT_UI2,        VT_I2,          (VARTYPE) NODE_WCHAR_T }
    };

//+---------------------------------------------------------------------------
//
//  Member:     CG_BASETYPE::GetTypeDesc
//
//  Synopsis:   creates a TYPEDESC for a base type
//
//  Arguments:  [ptd]  - reference to a TYPEDESC pointer
//              [pCCB] - CG control block
//
//  Returns:    CG_OK
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      rgIntrinsic contains an array of types which are intrinsic
//              types in ODL but are not INTRINSIC types in IDL, therefore
//              they must be treated as a special case.
//
//----------------------------------------------------------------------------

CG_STATUS CG_BASETYPE::GetTypeDesc(TYPEDESC * &ptd, CCB* )
{
    node_skl * pskl = GetType();
    while (NODE_DEF == pskl->NodeKind())
    {
        char * szName = pskl->GetSymName();
        int iIntrinsicType = 0;
        while (iIntrinsicType < (sizeof(rgIntrinsic) / sizeof(INTRINSIC)))
        {
            int i = _stricmp(szName, rgIntrinsic[iIntrinsicType].szType);
            if (i == 0)
            {
                ptd = new TYPEDESC;
                ptd->lptdesc = NULL;
                ptd->vt = rgIntrinsic[iIntrinsicType].vt;
                return CG_OK;
            }
            iIntrinsicType++;
        }
        pskl = pskl->GetChild();
    }

    NODE_T type = pskl->NodeKind();
    unsigned short Option = pCommand->GetCharOption ();

    // CONSIDER - perhaps this should be an assertion
    if (type < BASE_NODE_START || type >= BASE_NODE_END || NODE_FORWARD == type)
    {
        ReportTLGenError( "bad type", GetSymName(), 0);
    }
    int iTable = 1;
    if (pskl->FInSummary(ATTR_UNSIGNED) || type == NODE_BYTE || type == NODE_WCHAR_T )
    {
        iTable = 0;
    }
    else if (pskl->FInSummary(ATTR_SIGNED))
    {
        iTable = 1;
    }
    else if (NODE_CHAR == type || NODE_SMALL == type)
    {
        iTable = (CHAR_SIGNED == Option) ? 1 : 0;
    }

    /*
    INT_PTR problem
    Old .tlb and old oleaut32.dll don't support VT_INT_PTR. Adding 32bit
    support for the new VT code creates backward compatibility problem.
    To work aroud the problem, we define a new switch -use_vt_int_ptr. 
    If this is not defined, we'll save VT_INT_PTR as VT_I4.
    */
    
    VARTYPE vt;
    if (NODE_BOOLEAN == type && pCommand->IsSwitchDefined(SWITCH_MKTYPLIB))
        vt = VT_BOOL;
    else
        if ( pCommand->Is64BitEnv() )
        {
            if ( pCommand->IsSwitchDefined(SWITCH_USE_VT_INT_PTR) )
                vt = rgMap64BaseTypeToVARTYPE[type - BASE_NODE_START][iTable];
            else
                vt = rgMapOld64BaseTypeToVARTYPE[type - BASE_NODE_START][iTable];
        }
        else
        {
            if ( pCommand->IsSwitchDefined(SWITCH_USE_VT_INT_PTR) )
                vt = rgMapBaseTypeToVARTYPE[type - BASE_NODE_START][iTable];
            else
                vt = rgMapOldBaseTypeToVARTYPE[type - BASE_NODE_START][iTable];
        }

    ptd = new TYPEDESC;
    ptd->lptdesc = NULL;
    ptd->vt = vt;
    return CG_OK;
}

// The following two functions are necessary because this information
// is needed within TYPELIB.CXX and pCommand isn't visible to
// that module.

int FOldTlbSwitch(void)
{
    return (pCommand->IsSwitchDefined(SWITCH_OLD_TLB));
}

int FNewTlbSwitch(void)
{
    return (pCommand->IsSwitchDefined(SWITCH_NEW_TLB));
}

/*
This routine returns TRUE if the expression is evaluated as a floating point expression.
The results of the evaluation are returned in var.
*/
BOOL EvaluateFloatExpr( VARIANT& var, expr_node* pExpr )
    {
    BOOL    fIsFloat = FALSE;
    if ( pExpr->IsConstant() )
        {
        SExprValue  v           = {VALUE_TYPE_UNDEFINED, 0};
        BOOL        fSuccess    = pExpr->GetExprValue( v );
    
        if (fSuccess)
            {
            if ( v.format == VALUE_TYPE_FLOAT )
                {
                var.vt = VT_R4;
                var.fltVal = v.f;
                fIsFloat = TRUE;
                }
            else if ( v.format == VALUE_TYPE_DOUBLE )
                {
                var.vt = VT_R8;
                var.dblVal = v.d;
                fIsFloat = TRUE;
                }
            }
        else if ( v.format != VALUE_TYPE_UNDEFINED )
            {
            RpcError(NULL, 0, INVALID_FLOAT, 0);
            }
        }
    return fIsFloat;
    }

//=============================================================================
//=============================================================================
//=============================================================================

void ConvertToVariant(VARIANT & var, expr_node * pExpr, LCID lcid)
{
    if ( EvaluateFloatExpr( var, pExpr) )
        {
        // this is a floating point expression.
        return;
        }

    EXPR_VALUE val = pExpr->GetValue();
    if (pExpr->IsStringConstant() && !IsBadStringPtr((char *)val, 256))
    {
        char * sz = (char *) val;
        TranslateEscapeSequences(sz);
        WCHAR * wsz = TranscribeA2O( sz );

        VARIANT varTemp;
        varTemp.bstrVal = LateBound_SysAllocString(wsz);
        varTemp.vt = VT_BSTR;

        HRESULT hr;
        // try floating point numeric types first
        hr = LateBound_VariantChangeTypeEx(&var, &varTemp, lcid, 0, VT_R8);
        if (FAILED(hr))
        {
            // if it can't be coerced into a floating point type, then just stuff the BSTR value
            var.bstrVal = LateBound_SysAllocString(wsz);
            var.vt = VT_BSTR;
        }
        LateBound_SysFreeString(varTemp.bstrVal);
        delete [] wsz;
    }
    else
    {
        var.vt = VT_I4;
        var.lVal = (long) val;
    }
}

void GetValueFromExpression(VARIANT & var, TYPEDESC tdesc, expr_node * pExpr, LCID lcid, char * szSymName)
{
    memset(&var, 0, sizeof(VARIANT));
    if ( EvaluateFloatExpr( var, pExpr) )
        {
        // this is a floating point expression.
        return;
        }

    if (tdesc.vt == VT_PTR && (tdesc.lptdesc->vt == VT_I1 || tdesc.lptdesc->vt == VT_VARIANT))
    {
        // Fool switch into realizing that the data should be in string form.
        tdesc.vt = VT_LPSTR;
    }
    // set the value
    switch (tdesc.vt)
    {
    case VT_BOOL:
//        var.vt = VT_BOOL;
//        var.boolVal = (pExpr->GetValue() ? VARIANT_TRUE : VARIANT_FALSE);
//        break;
    case VT_I1:
    case VT_UI1:
//        var.vt = VT_UI1;
//        var.bVal = (unsigned char) pExpr->GetValue();
//        break;
    case VT_UI2:
//        var.vt = VT_UI4;
//        var.ulVal = (unsigned short) pExpr->GetValue();
//        break;
    case VT_I2:
        var.vt = VT_I2;
        var.iVal = (short) pExpr->GetValue();
        break;
    case VT_UI4:
//        var.vt = VT_UI4;
//        var.ulVal = (unsigned long) pExpr->GetValue();
//        break;
    case VT_UINT:
//        var.vt = VT_UI4;
//        var.ulVal = (unsigned int) pExpr->GetValue();
//        break;
    case VT_INT:
    case VT_I4:
        var.vt = VT_I4;
        var.lVal = (long) pExpr->GetValue();
        break;
    case VT_DISPATCH:
    case VT_UNKNOWN:
        //var.vt = vt;
        var.vt = VT_I4;
        if (pExpr->GetValue())
        {
            RpcError(NULL, 0, ILLEGAL_CONSTANT, szSymName);
            exit(ERR_TYPELIB_GENERATION);
        }
        var.ppunkVal = NULL;    // the only supported value for constants of this type
        break;
    case VT_ERROR:
        var.vt = VT_I4;
//        var.vt = VT_ERROR;
        var.lVal = (long) pExpr->GetValue();
//        var.scode = (SCODE) pExpr->GetValue();
        break;
    case VT_LPSTR:
    case VT_LPWSTR:
        {
        var.vt = VT_BSTR;
        var.bstrVal = 0;
        EXPR_VALUE val = pExpr->GetValue();
        if (pExpr->IsStringConstant() && !IsBadStringPtr((char *)val, 256))
            {
            // Constants of these types may be defined as a string.
            // Convert the string to a BSTR and use VariantChangeType to
            // coerce the BSTR to the appropriate variant type.
            char * sz = (char *) val;
            TranslateEscapeSequences(sz);
            WCHAR * wsz = TranscribeA2O( sz );

            var.bstrVal = LateBound_SysAllocString(wsz);
            delete [] wsz;
            }
        else
            {
            // get the value as a LONG and coerce it to the correct type.
            // If the value is not a string then it should be NULL.
            if (pExpr->GetValue())
                {
                // value wasn't NULL
                // convert it to a string
                char sz[40];
                WCHAR wsz [40];
                sprintf(sz,"%li",val);
                A2O(wsz, sz, 40);
                var.bstrVal = LateBound_SysAllocString(wsz);
                }
            }
        }
        break;
    case VT_R4:
    case VT_R8:
    case VT_I8:
    case VT_UI8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_DECIMAL:
        {
            VARIANT varTemp;
            HRESULT hr;
            EXPR_VALUE val = pExpr->GetValue();
            if (pExpr->IsStringConstant() && !IsBadStringPtr((char *)val, 256))
            {
                // Constants of these types may be defined as a string.
                // Convert the string to a BSTR and use VariantChangeType to
                // coerce the BSTR to the appropriate variant type.
                char *  sz = (char *) val;
                WCHAR * wsz = TranscribeA2O( sz );

                varTemp.bstrVal = LateBound_SysAllocString(wsz);
                varTemp.vt = VT_BSTR;
                delete [] wsz;

                hr = LateBound_VariantChangeTypeEx(&var, &varTemp, lcid, 0, tdesc.vt);
                if (FAILED(hr))
                {
                    RpcError(NULL, 0, CONSTANT_TYPE_MISMATCH, szSymName);
                    exit(ERR_TYPELIB_GENERATION);
                }

                LateBound_SysFreeString(varTemp.bstrVal);
            }
            else
            {
                // get the value as a LONG and coerce it to the correct type.
                varTemp.vt = VT_I4;
                varTemp.lVal = (long) val;
                hr = LateBound_VariantChangeTypeEx(&var, &varTemp, lcid, 0, tdesc.vt);
                if (FAILED(hr))
                {
                    RpcError(NULL, 0, CONSTANT_TYPE_MISMATCH, szSymName);
                    exit(ERR_TYPELIB_GENERATION);
                }
            }
        }
        break;
    case VT_VARIANT:
        ConvertToVariant(var, pExpr, lcid);
        break;
    case VT_VOID:
    case VT_HRESULT:
    case VT_SAFEARRAY:
    case VT_CARRAY:
    case VT_USERDEFINED:
    case VT_PTR:
    default:
        ConvertToVariant(var, pExpr, lcid);
        // assert(!"Illegal constant value");
        // var.vt = VT_I4; // put us in a legal state just to keep code from crashing
    }
}

unsigned long CG_INTERFACE::LayOut()
    {
    unsigned long ulRet = 0;
    if (!IsLayedOut())
        {
        if (GetBaseInterfaceCG())
            {
            GetBaseInterfaceCG()->LayOut();
            }
#ifdef __TRACE_LAYOUT__
        printf("LayOut, %s\n", GetType()->GetSymName());
#endif
        ICreateTypeInfo* pCTI = (ICreateTypeInfo*)_pCTI;
        // ulRet = (pCTI) ? pCTI->LayOut() : TYPE_E_INVALIDSTATE;
        if (pCTI)
            {
            HRESULT  hr;

            // Alignment is not defined for interfaces, so we set it
            // to an arbitrary value, same as mktplib.

            hr    = pCTI->SetAlignment( pCommand->GetZeePee() );
            ulRet = pCTI->LayOut();
            }
        LayedOut();
        }
    return ulRet;
    }

unsigned long CG_COCLASS::LayOut()
    {
    unsigned long ulRet = 0;
    if (!IsLayedOut())
        {
#ifdef __TRACE_LAYOUT__
        printf("LayOut, %s\n", GetType()->GetSymName());
#endif
        ICreateTypeInfo* pCTI = (ICreateTypeInfo*)_pCTI;
        // ulRet = (pCTI) ? pCTI->LayOut() : TYPE_E_INVALIDSTATE;
        if (pCTI)
            {
            HRESULT  hr;

            // Alignment is not defined for coclasses, so we set it
            // to an arbitrary value, same as mktplib.

            hr    = pCTI->SetAlignment( pCommand->GetZeePee() );
            ulRet = pCTI->LayOut();
            }
        LayedOut();
        }
    return ulRet;
    }

unsigned long CG_MODULE::LayOut()
    {
    unsigned long ulRet = 0;
    if (!IsLayedOut())
        {
#ifdef __TRACE_LAYOUT__
        printf("LayOut, %s\n", GetType()->GetSymName());
#endif
        ICreateTypeInfo* pCTI = (ICreateTypeInfo*)_pCTI;
        // ulRet = (pCTI) ? pCTI->LayOut() : TYPE_E_INVALIDSTATE;
        if (pCTI)
            {
            HRESULT  hr;

            // Alignment is not defined for modules, so we set it
            // to an arbitrary value, same as mktplib.

            hr    = pCTI->SetAlignment( pCommand->GetZeePee() );
            ulRet = pCTI->LayOut();
            }
        LayedOut();
        }
    return ulRet;
    }


WCHAR * 
TranscribeA2O( char * sz )
//+---------------------------------------------------------------------------
//
//  Synopsis:   creates a unicode string corresponding to a multibyte string.
//
//  Arguments:  sz - multibyte string
//
//  Returns:    the unicode string
//
//  History:    1-3-97   ryszardk   Created
//
//----------------------------------------------------------------------------
{
    // The length includes the terminating character.

    unsigned long cc  = (unsigned long) strlen(sz)+1;
    unsigned long cw  = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cc, 0, 0);
    WCHAR *       wsz = new WCHAR [cw];

    wsz[0] = 0;
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, sz, cc, wsz, cw );

    return wsz;
}

char *  
TranscribeO2A( BSTR bstr )
//+---------------------------------------------------------------------------
//
//  Synopsis:   creates a multibyte string corresponding to a unicode string.
//
//  Arguments:  bstr - the unicode string
//
//  Returns:    the multibyte string
//
//  History:    1-3-97   ryszardk   Created
//
//----------------------------------------------------------------------------
{
    // The length includes the terminating character.

    unsigned long cw = (unsigned long) wcslen(bstr)+1;
    unsigned long cc = WideCharToMultiByte( CP_ACP, 0, bstr, cw, 0, 0, 0, 0);
    char *        sz = new char [cc];
            
    sz[0] = 0;
    WideCharToMultiByte( CP_ACP, 0, bstr, cw, sz, cc, 0, 0 );

    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\async.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name :

    async.c

Abstract :

    This file contains the ndr async implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Nov 1996

Revision History :

---------------------------------------------------------------------*/



#define USE_STUBLESS_PROXY

#define CINTERFACE

#include "ndrp.h"
#include "ndrole.h"
#include "rpcproxy.h"
#include "hndl.h"
#include "interp.h"
#include "interp2.h"
#include "pipendr.h"
#include "mulsyntx.h"
#include "asyncndr.h"
#include "attack.h"
#include <stdarg.h>

#pragma code_seg(".orpc")

#ifdef _PPC_
#error PPC code has been removed
#endif



CLIENT_CALL_RETURN  RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    )
/*
    This entry is used for raw rpc only.
    No support for OLE [async] attribute anymore.
*/
{
    va_list             ArgList;
    unsigned char  *    StartofStack;
    CLIENT_CALL_RETURN  Ret;
    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    // Then get the address of the stack where the parameters are.
    //

    RPC_ASYNC_HANDLE            AsyncHandle;
    PNDR_ASYNC_MESSAGE          pAsyncMsg;

    RPC_MESSAGE *               pRpcMsg;
    MIDL_STUB_MESSAGE *         pStubMsg;
    ulong                       ProcNum, RpcFlags;

    handle_t                    Handle;
    uchar                       HandleType;
    INTERPRETER_FLAGS           OldOiFlags;
    INTERPRETER_OPT_FLAGS       NewOiFlags;
    PPARAM_DESCRIPTION          Params;

    RPC_STATUS                  Status;
    NDR_PROC_CONTEXT            *pContext; 

    Ret.Simple = 0;

    INIT_ARG( ArgList, pFormat);
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *) GET_STACK_START(ArgList);

    pAsyncMsg = (NDR_ASYNC_MESSAGE*) I_RpcBCacheAllocate( sizeof( NDR_ASYNC_MESSAGE) );
    if ( ! pAsyncMsg )
        Status = RPC_S_OUT_OF_MEMORY;
    else
        {
        memset( pAsyncMsg, 0, sizeof( NDR_ASYNC_MESSAGE ) );
        ProcNum = MulNdrpInitializeContextFromProc( 
                                     XFER_SYNTAX_DCE, 
                                     pFormat,
                                    &pAsyncMsg->ProcContext,
                                     NULL );    // server StartofStack
                                     
        Status = NdrpInitializeAsyncMsg( 
                                     StartofStack,
                                     pAsyncMsg );
        }
        
    if ( Status )
        {
        // if something is wrong during setup, we need to cleanup 
        // immediately. We have to process format string here explicitly
        NDR_PROC_CONTEXT TempContext;
        MIDL_STUB_MESSAGE      StubMsgTemp;
        ProcNum = MulNdrpInitializeContextFromProc( 
                                     XFER_SYNTAX_DCE, 
                                     pFormat,
                                    &TempContext,
                                     NULL );    // server StartofStack

        OldOiFlags = TempContext.NdrInfo.InterpreterFlags;
        if ( OldOiFlags.HasCommOrFault )
            {

            // It's easier to map the error here than to go through the error
            // recovery and normal cleanup without valid handle etc.

            StubMsgTemp.StubDesc = pStubDescriptor;
            StubMsgTemp.StackTop = StartofStack;

            NdrClientMapCommFault( & StubMsgTemp,
                                   ProcNum,
                                   Status,
                                   (ULONG_PTR*) &Ret.Simple );
            return Ret;
            }
        else
            RpcRaiseException( Status );
        }

    pContext = &pAsyncMsg->ProcContext;
    HandleType = pContext->HandleType;
    NewOiFlags = pContext->NdrInfo.pProcDesc->Oi2Flags;
    OldOiFlags = pContext->NdrInfo.InterpreterFlags;
    Params = (PARAM_DESCRIPTION *)pContext->Params;

    // We need to switch to our copy of the stack everywhere, including pStubMsg.

    StartofStack = pAsyncMsg->ProcContext.StartofStack;

    // We abstract the level of indirection here.

    AsyncHandle = pAsyncMsg->AsyncHandle;

    pRpcMsg   = & pAsyncMsg->RpcMsg;
    pStubMsg  = & pAsyncMsg->StubMsg;

    //
    // Set Params and NumberParams before a call to initialization.
    //

    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        // Use a nested try-except pair to support [comm_status][fault_status].
        //
        RpcTryExcept
            {
            BOOL fRaiseExcFlag;

            NdrClientInitializeNew( pRpcMsg,
                                    pStubMsg,
                                    pStubDescriptor,
                                    (uint) ProcNum );

            if ( HandleType )
                {
                //
                // We have an implicit handle.
                //
                Handle = ImplicitBindHandleMgr( pStubDescriptor,
                                                HandleType,
                                                &pContext->SavedGenericHandle);
                }
            else
                {
                Handle = ExplicitBindHandleMgr( pStubDescriptor,
                                                StartofStack,
                                                (PFORMAT_STRING)pContext->pHandleFormatSave,
                                                &pContext->SavedGenericHandle );
                }

            pStubMsg->pAsyncMsg = pAsyncMsg;

            NdrpClientInit( pStubMsg, 
                            NULL );     // return value

            
            //
            // Skip buffer size pass if possible.
            //
            if ( NewOiFlags.ClientMustSize )
                {
                NdrpSizing( pStubMsg,
                            TRUE );     // isclient
                }

            pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

            if ( NewOiFlags.HasPipes )
                NdrGetPipeBuffer( pStubMsg,
                                  pStubMsg->BufferLength,
                                  Handle );
            else
                NdrGetBuffer( pStubMsg,
                              pStubMsg->BufferLength,
                              Handle );

            NDR_ASSERT( pStubMsg->fBufferValid, "Invalid buffer" );

            // Let runtime associate async handle with the call.

            NdrpRegisterAsyncHandle( pStubMsg, AsyncHandle );

            pAsyncMsg->StubPhase = NDR_ASYNC_SET_PHASE;

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            NdrpClientMarshal( pStubMsg,
                         FALSE );   // IsObject
                         
            pAsyncMsg->StubPhase = NDR_ASYNC_CALL_PHASE;

            NdrAsyncSend( pStubMsg,
                          NewOiFlags.HasPipes && pContext->pPipeDesc->InPipes );

            pAsyncMsg->Flags.ValidCallPending = 1;
            }
        RpcExcept( OldOiFlags.HasCommOrFault )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            // Actually dismantle the call.
            // This is a request call and there is nothing left at the runtime.

            pAsyncMsg->StubPhase = NDR_ASYNC_ERROR_PHASE;

            NdrClientMapCommFault( pStubMsg,
                                   ProcNum,
                                   ExceptionCode,
                                   (ULONG_PTR*) &Ret.Simple );
            }
        RpcEndExcept
        }
    RpcFinally
        {
        if ( pAsyncMsg->Flags.ValidCallPending )
            {
            if ( NewOiFlags.HasPipes )
                {
                NdrMarkNextActivePipe( pContext->pPipeDesc );
                pContext->pPipeDesc->Flags.NoBufferCallPending = 1;
                }
            }
        else
            {
            // Cleanup everything but the user's handle.

            NdrpFreeAsyncMsg( pAsyncMsg );

            AsyncHandle->StubInfo = 0;
            }

        InterlockedDecrement( & AsyncHandle->Lock );
        }
    RpcEndFinally

    return Ret;
}


RPC_STATUS
NdrpCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    )
{
    RPC_MESSAGE *               pRpcMsg   = & pAsyncMsg->RpcMsg;
    MIDL_STUB_MESSAGE *         pStubMsg  = & pAsyncMsg->StubMsg;

    PFORMAT_STRING              pFormatParam;
    NDR_PROC_CONTEXT        *   pContext   = &pAsyncMsg->ProcContext;
    NDR_PROC_INFO           *   pNdrInfo  = &pContext->NdrInfo;
    INTERPRETER_FLAGS           OldOiFlags       = pNdrInfo->InterpreterFlags;
    INTERPRETER_OPT_FLAGS       NewOiFlags       = pNdrInfo->pProcDesc->Oi2Flags;
    PPARAM_DESCRIPTION          Params           = (PPARAM_DESCRIPTION )pContext->Params;
    uchar *                     StartofStack     = pContext->StartofStack ;

    PMIDL_STUB_DESC             pStubDescriptor  = pStubMsg->StubDesc;
    ulong                       RpcFlags         = pRpcMsg->RpcFlags;

    ULONG_PTR                   RetVal           = 0;

    long                        NumberParams     = pContext->NumberParams;
    long                        n;
    NDR_ASYNC_CALL_FLAGS        CallFlags = pAsyncMsg->Flags;
                                            
    RpcTryFinally
        {
        // Use a nested try-except pair to support [comm_status][fault_status].
        //
        RpcTryExcept
            {

            if ( ! CallFlags.ValidCallPending )
                RpcRaiseException( RPC_S_INVALID_ASYNC_HANDLE );

            CallFlags.ValidCallPending = 0;

            // Non-pipe case or after pipe args case.

            if ( NewOiFlags.HasPipes )
                NdrIsAppDoneWithPipes( pContext->pPipeDesc );

            NdrLastAsyncReceive( pStubMsg );

            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //

            NdrpClientUnMarshal( pStubMsg, 
                           (CLIENT_CALL_RETURN *)pReturnValue  );
                           

            }
        RpcExcept( OldOiFlags.HasCommOrFault )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            CallFlags.ValidCallPending = ExceptionCode == RPC_S_ASYNC_CALL_PENDING;

                NdrClientMapCommFault( pStubMsg,
                                       pRpcMsg->ProcNum,
                                       ExceptionCode,
                                       &RetVal );

                if ( ExceptionCode == RPC_S_ASYNC_CALL_PENDING )
                    {
                    // If the call is just pending, force the pending error code
                    // to show up in the return value of RpcAsyncCallComplete.

                    RetVal = RPC_S_ASYNC_CALL_PENDING;
                    }
            }
        RpcEndExcept

        }
    RpcFinally
        {
        // There is only one way a valid call may be pending at this stage:
        // that is the receive call returned with RPC_S_CALL_PENDING.

        if ( ! CallFlags.ValidCallPending )
            {
            // Cleanup everything. However, don't free user's handle.

            NdrpFreeAsyncMsg( pAsyncMsg );

            AsyncHandle->StubInfo = 0;
            }

        InterlockedDecrement( & AsyncHandle->Lock );
        }
    RpcEndFinally

    return (RPC_STATUS)RetVal;
}


void RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE    pRpcMsg
    )
/*++
Routine Description :

    The server side entry point for regular asynchronous RPC procs.

Arguments :

    pRpcMsg         - The RPC message.

Return :

    None.
--*/
{
    RPC_ASYNC_HANDLE        AsyncHandle = 0;
    PNDR_ASYNC_MESSAGE      pAsyncMsg;

    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    PMIDL_STUB_DESC         pStubDesc;
    const SERVER_ROUTINE  * DispatchTable;
    ushort                  ProcNum;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pFormatParam;

    PMIDL_STUB_MESSAGE      pStubMsg;

    uchar *                 pArgBuffer;
    uchar **                ppArg;

    PPARAM_DESCRIPTION      Params;
    INTERPRETER_FLAGS       OldOiFlags;
    INTERPRETER_OPT_FLAGS   NewOiFlags;
    long                    NumberParams;


    ushort                  ClientBufferSize;
    BOOL                    HasExplicitHandle;
    long                    n;
    NDR_PROC_CONTEXT        * pContext;

    RPC_STATUS              Status = RPC_S_OK;


    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    // The handle table is part of the async handle.

    ProcNum = (ushort) pRpcMsg->ProcNum;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
    pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
    DispatchTable = pServerInfo->DispatchTable;

    pStubDesc = pServerInfo->pStubDesc;

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat = &((pServerInfo->ProcString)[FormatOffset]);

    
    AsyncHandle = 0;
    pAsyncMsg = (NDR_ASYNC_MESSAGE*) I_RpcBCacheAllocate( sizeof( NDR_ASYNC_MESSAGE) );
    if ( ! pAsyncMsg )
        Status = RPC_S_OUT_OF_MEMORY;
    else
        {
        memset( pAsyncMsg, 0, sizeof( NDR_ASYNC_MESSAGE ) );
        MulNdrpInitializeContextFromProc( 
                                     XFER_SYNTAX_DCE, 
                                     pFormat,
                                    &pAsyncMsg->ProcContext,
                                     NULL );    // server StartofStack

        Status = NdrpInitializeAsyncMsg( 0,                 // StartofStack, server
                                         pAsyncMsg
                                    );
        }
        
    if ( Status )
        RpcRaiseException( Status );

    pAsyncMsg->StubPhase = STUB_UNMARSHAL;

    pStubMsg = & pAsyncMsg->StubMsg;

    // from Kamen: 
    // we don't need to copy RpcMsg : it's provided by runtime in server side
    pContext = &pAsyncMsg->ProcContext;
    // setup the type format string in old code.
    pContext->DceTypeFormatString = pStubDesc->pFormatTypes;

    pStubMsg->RpcMsg = pRpcMsg;
    pStubMsg->SavedContextHandles = pAsyncMsg->CtxtHndl;

    // The arg buffer is zeroed out already.
    pArgBuffer = pAsyncMsg->ProcContext.StartofStack;

    OldOiFlags = pContext->NdrInfo.InterpreterFlags;
    NewOiFlags = pContext->NdrInfo.pProcDesc->Oi2Flags;
    NumberParams = pContext->NumberParams;
    Params = ( PPARAM_DESCRIPTION ) pContext->Params;
    //
    // Wrap the unmarshalling and the invoke call in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    BOOL        fManagerCodeInvoked = FALSE;
    BOOL        fErrorInInvoke = FALSE;
    RPC_STATUS  ExceptionCode = 0;

    // We abstract the level of indirection here.

    AsyncHandle = pAsyncMsg->AsyncHandle;

    RpcTryFinally
    {
        RpcTryExcept
        {
        // Put the async handle on stack.
        ((void **)pArgBuffer)[0] = AsyncHandle;  

        NdrpServerInit( pStubMsg, 
                        pRpcMsg, 
                        pStubDesc, 
                        NULL,       // pThis
                        NULL,       // pChannel
                        pAsyncMsg ); 

        // Let runtime associate async handle with the call.

        NdrpRegisterAsyncHandle( pStubMsg, AsyncHandle );

        pAsyncMsg->StubPhase = NDR_ASYNC_SET_PHASE;
            
        NdrpServerUnMarshal( pStubMsg  ); 

            if ( pRpcMsg->BufferLength  <
                 (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
                {
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
                }


            }
        RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
            {
            ExceptionCode = RpcExceptionCode();

            if( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
                {
                ExceptionCode = RPC_X_BAD_STUB_DATA;
                }

            // we always free the memory list if exception happened 
            // during unmarshalling. Exception code will tell if this
            // is really RPC_X_BAD_STUB_DATA;
            NdrpFreeMemoryList( pStubMsg );
            pAsyncMsg->Flags.BadStubData = 1;
            pAsyncMsg->ErrorCode = ExceptionCode;
            RpcRaiseException( ExceptionCode );
            }
        RpcEndExcept

        // Two separate blocks because the filters are different.
        // We need to catch exception in the manager code separately
        // as the model implies that there will be no other call from
        // the server app to clean up.

        RpcTryExcept
            {
            //
            // Do [out] initialization before the invoke.
            //

            NdrpServerOutInit( pStubMsg );

            //
            // Unblock the first pipe; this needs to be after unmarshalling
            // because the buffer may need to be changed to the secondary one.
            // In the out only pipes case this happens immediately.
            //
            if ( NewOiFlags.HasPipes )
                NdrMarkNextActivePipe( pContext->pPipeDesc );

            pAsyncMsg->StubPhase = STUB_CALL_SERVER;

            //
            // Check for a thunk.  Compiler does all the setup for us.
            //
            if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
                {
                pAsyncMsg->Flags.ValidCallPending = 1;
                InterlockedDecrement( & AsyncHandle->Lock );

                fManagerCodeInvoked = TRUE;
                fErrorInInvoke = TRUE;
                pServerInfo->ThunkTable[ProcNum]( pStubMsg );
                }
            else
                {
                //
                // Note that this ArgNum is not the number of arguments declared
                // in the function we called, but really the number of
                // REGISTER_TYPEs occupied by the arguments to a function.
                //
                long                ArgNum;
                MANAGER_FUNCTION    pFunc;
                REGISTER_TYPE       returnValue;

                if ( pRpcMsg->ManagerEpv )
                    pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
                else
                    pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

                ArgNum = (long) pContext->StackSize / sizeof(REGISTER_TYPE);

                //
                // The StackSize includes the size of the return. If we want
                // just the number of REGISTER_TYPES, then ArgNum must be reduced
                // by 1 when there is a return value AND the current ArgNum count
                // is greater than 0.
                //
                if ( ArgNum && NewOiFlags.HasReturn )
                    ArgNum--;

                // Being here means that we can expect results. Note that the user
                // can call RpcCompleteCall from inside of the manager code.

                pAsyncMsg->Flags.ValidCallPending = 1;

                // Unlock the handle - the app is allowed to call RpCAsyncManager
                //  or RpcAsyncAbort from the manager code.

                InterlockedDecrement( & AsyncHandle->Lock );

                fManagerCodeInvoked = TRUE;
                fErrorInInvoke = TRUE;

                returnValue = Invoke( pFunc,
                                      (REGISTER_TYPE *)pArgBuffer,
                            #if defined(_IA64_)
                                      NewOiFlags.HasExtensions ? ((PNDR_PROC_HEADER_EXTS64)&pContext->NdrInfo.pProcDesc->NdrExts)->FloatArgMask
                                                               : 0,
                            #endif
                                      ArgNum);

                // We are discarding the return value as it is not the real one.
                // The real return value is passed in the complete call.
                }

            fErrorInInvoke = FALSE;
            }
        RpcExcept( 1 )
            {
            ExceptionCode = RpcExceptionCode();

            if ( ExceptionCode == 0 )
                ExceptionCode = ERROR_INVALID_PARAMETER;

            // We may not have the async message around anymore.

            RpcRaiseException( ExceptionCode );
            }
        RpcEndExcept

        }
    RpcFinally
        {
        if ( fManagerCodeInvoked  &&  !fErrorInInvoke )
            {
            // Success. Just skip everything if the manager code was invoked
            // and returned successfully.
            // Note that manager code could have called Complete or Abort by now
            // and so the async handle may not be valid anymore.
            }
        else
            {
            // See if we can clean up;

            Status = RPC_S_OK;
            if ( fErrorInInvoke )
                {
                // After an exception in invoking, let's see if we can get a hold
                // of the handle. If so, we will be able to clean up.
                // If not, there may be a leak there that we can do nothing about.
                // The rule is: after an exception the app cannot call Abort or
                // Complete. So, we need to force complete if we can.

                Status = NdrValidateBothAndLockAsyncHandle( AsyncHandle );
                }

            if ( Status == RPC_S_OK )
                {
                // Something went wrong but we are able to do the cleanup.

                // Cleanup parameters and async message/handle.
                // propagate the exception.

                NdrpCleanupServerContextHandles( pStubMsg,
                                                 pArgBuffer,
                                                 TRUE ); // die in manager routine 
                
                if (!pAsyncMsg->Flags.BadStubData)
                   {
                   NdrpFreeParams( pStubMsg,
                                   NumberParams,
                                   Params,
                                   pArgBuffer );
                   }

                NdrpFreeAsyncHandleAndMessage( AsyncHandle );
                }

            // else manager code invoked and we could not recover.
            // Exception will be raised by the EndFinally below.
            }

        }
    RpcEndFinally
}


RPC_STATUS
NdrpCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    )
/*++

Routine Description :

    Complete an async call on the server side.  If an exception occurs, the
    asynchronous rpc call is aborted with the exception code and the server side
    caller is returned S_OK.

Arguments :

    AsyncHandle  - validated asynchronous handle,
    pAsyncMsg    - pointer to async msg structure,
    pReturnValue - pointer to the return value to be passed to the client.

Return :

    Status of S_OK.

--*/
{
    // in the server side, we don't use pAsyncMsg->RpcMsg. for Kamen 
    MIDL_STUB_MESSAGE *     pStubMsg       = & pAsyncMsg->StubMsg;
    RPC_MESSAGE *           pRpcMsg        = pStubMsg->RpcMsg;

    PFORMAT_STRING          pFormatParam;
    NDR_PROC_CONTEXT   *    pContext       = & pAsyncMsg->ProcContext;
    
    INTERPRETER_FLAGS       OldOiFlags     = pContext->NdrInfo.InterpreterFlags;
    INTERPRETER_OPT_FLAGS   NewOiFlags     = pContext->NdrInfo.pProcDesc->Oi2Flags;
    PPARAM_DESCRIPTION      Params         = ( PPARAM_DESCRIPTION )pContext->Params;
    uchar *                 pArgBuffer     = pContext->StartofStack;
    unsigned long           StackSize      = pContext->StackSize;
    PMIDL_STUB_DESC         pStubDesc      = pStubMsg->StubDesc;

    long                    NumberParams   = pContext->NumberParams;
    long                    n;
    boolean                 fParamsFreed   = FALSE;

    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-except. Put the call to abort in the except clause.
    //
    RpcTryExcept
    {
        // At this point, this is a valid RPC call since the asynchronous handle
        // is owned by NDR on the server side and NDR passes the handle
        // to the server during the invoke call.  During invoke
        // the parameters have already been unmarshalled.

        pAsyncMsg->StubPhase = STUB_MARSHAL;

        if( NewOiFlags.HasReturn )
            {
            // Put user's return value on the stack as usual.
            // See the invoke for comments on folding return into the arg satck.

            NDR_ASSERT( !pContext->HasComplexReturn, "complex return is not supported in async" );

            long  ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);

            if ( ArgNum )
                ArgNum--;

            if ( ! pReturnValue )
                RpcRaiseException( RPC_S_INVALID_ARG );

            // We don't support return value larger than register_type,
            // and memcpy avoid alignment issue.
            if ( Params[NumberParams-1].ParamAttr.IsBasetype )
                memcpy( &((REGISTER_TYPE *)pArgBuffer)[ArgNum], 
                    pReturnValue, 
                    (size_t)SIMPLE_TYPE_MEMSIZE( Params[NumberParams-1].SimpleType.Type ) );
            else
                ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = *(REGISTER_TYPE*)pReturnValue;
            }

        //
        // Buffer size pass.
        //
        ushort  ConstantBufferSize = pContext->NdrInfo.pProcDesc->ServerBufferSize;

        if ( NewOiFlags.HasPipes )
            {
            NdrIsAppDoneWithPipes( pContext->pPipeDesc );
            pStubMsg->BufferLength += ConstantBufferSize;
            }
        else
            pStubMsg->BufferLength = ConstantBufferSize;

        if ( NewOiFlags.ServerMustSize )
            {
            NdrpSizing( pStubMsg,
                        FALSE );    // this is server
            }

        // Get buffer.

        if ( NewOiFlags.HasPipes && pContext->pPipeDesc->OutPipes )
            {
            NdrGetPartialBuffer( pStubMsg );
            pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
            }
        else
            {
            NdrGetBuffer( pStubMsg,
                          pStubMsg->BufferLength,
                          0 );
            }

        //
        // Marshall pass.
        //
        NdrpServerMarshal( pStubMsg,
                     FALSE );   // IsObject

        pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

        // We don't drop to the runtime like for synchronous calls,
        // we send the last buffer explicitly.

        // set the freed flag.
        fParamsFreed = TRUE;
        /*
            we have to do release twice here:
                After the last piece of data is sent via NdrAsyncSend, dispatch buffer
            will be freed by runtime. We'll have problem calling ndr free routines to
            free unique pointers (where both pointer and pointee are in the buffer). So
            we call ndr free routines BEFORE the send, because it won't free anything
            inside dispatch buffer, and runtime send only cares about dispatch buffer.
                We still have to call ndr free routines in RpcFinally for exception cleanup. we
            check the flag to avoid calling free twice.
        */
        NdrpFreeParams( pStubMsg,
                        NumberParams,
                        Params,
                        pArgBuffer );

        NdrAsyncSend( pStubMsg,
                      FALSE );    // the last call is always non-partial
        }
    RpcExcept(1)
        {

        // Abort the call which will result in the exception being propagated to
        // the client.

        NdrpAsyncAbortCall( AsyncHandle,
                            pAsyncMsg,
                            RpcExceptionCode(),
                            !fParamsFreed ); // Do not free if second attempt.
        return S_OK;
        }
    RpcEndExcept

    NdrpFreeAsyncHandleAndMessage( AsyncHandle );
    return S_OK;
}



RPC_STATUS
NdrpInitializeAsyncMsg(
    void *              StartofStack,
    PNDR_ASYNC_MESSAGE  pAsyncMsg )
/*
    This method creates and initializes async msg.
    Additionally, it creates the handle itself in object case.

    pHandleArg      - pointer to the proc's async handle argument.
                      Note the handle arg semantics on the client:
                      *pHandleArg is
                        raw: a handle (arg is a *)
                                - the handle cannot be 0
                        obj: a pHandle (arg is a **)
                                pHandle ==0 means a "don't care" call
                               *pHandle ==0 means "create handle while calling"
                               *pHandle !=0 means a handle created by the app.

    StartofStack    - side marker as well:
                        != 0 - client
                        == 0 - server
*/
{
    RPC_STATUS          Status = 0;
    BOOL                fIsClient = StartofStack != 0;
    BOOL                fHandleCreated = FALSE;
    RPC_ASYNC_HANDLE    AsyncHandle = 0;
    RPC_ASYNC_HANDLE *  pHandleArg = (RPC_ASYNC_HANDLE *)StartofStack;

    // Do this first to simplify error conditions.


    ulong  StackSize =  pAsyncMsg->ProcContext.StackSize;

    
    if ( fIsClient )
        {
        // Client always supplies a handle.

        if ( *pHandleArg )
            {
            AsyncHandle = *pHandleArg;
            Status = NdrpValidateAndLockAsyncHandle( AsyncHandle );
            }
        else
            Status = RPC_S_INVALID_ASYNC_HANDLE;
        }
    else
        {
        // Server - the stub creates the handle.

        AsyncHandle = (RPC_ASYNC_STATE *)I_RpcAllocate( sizeof(RPC_ASYNC_STATE) );
        if ( ! AsyncHandle )
            Status = RPC_S_OUT_OF_MEMORY;
        else
            {
            MIDL_memset( AsyncHandle, 0x0, sizeof( RPC_ASYNC_STATE) );
            RpcAsyncInitializeHandle( AsyncHandle, RPC_ASYNC_VERSION_1_0 );
            AsyncHandle->Lock = 1;
            fHandleCreated = TRUE;
            }
        }

    if ( Status )
        {
        I_RpcBCacheFree( pAsyncMsg );
        return Status;
        }

    // Initialize the async message properly

    pAsyncMsg->Signature = NDR_ASYNC_SIGNATURE;
    pAsyncMsg->Version   = NDR_ASYNC_VERSION;
    pAsyncMsg->StubMsg.pContext = & pAsyncMsg->ProcContext;

    pAsyncMsg->ProcContext.StartofStack = (uchar *) NdrpAlloca( 
                & pAsyncMsg->ProcContext.AllocateContext, 
                StackSize );

    // Must do this before the sizing pass!
    pAsyncMsg->StubMsg.StackTop = (uchar *)StartofStack;
    
    pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

    if ( fIsClient )
        {
        // Client: copy stack from the app's request call.
        RpcpMemoryCopy( pAsyncMsg->ProcContext.StartofStack, StartofStack, StackSize );
        }
    else
        {
        // Server: zero out stack for allocs.
        MIDL_memset( pAsyncMsg->ProcContext.StartofStack, 0x0, StackSize );
        }

    MIDL_memset( pAsyncMsg->AsyncGuard,
                 0x71,
                 NDR_ASYNC_GUARD_SIZE );

    AsyncHandle->StubInfo  = pAsyncMsg;
    pAsyncMsg->AsyncHandle = AsyncHandle;

    return RPC_S_OK;
}


void
NdrpFreeAsyncMsg(
    PNDR_ASYNC_MESSAGE  pAsyncMsg )
/*
    This routine would free the AsyncMsg but not the AsyncHandle, as on the server
    the user may need it and on the client it is user's to begin with.
*/
{
    NDR_PROC_CONTEXT    * pContext = & pAsyncMsg->ProcContext;
    if ( pAsyncMsg )
        {
        PMIDL_STUB_MESSAGE  pStubMsg  = & pAsyncMsg->StubMsg;

        NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

        NdrCorrelationFree( pStubMsg );

        // Free the RPC buffer.

        if ( pStubMsg->IsClient )
            {
            if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
                NdrFreeBuffer( pStubMsg );
            }


        RPC_STATUS Status = 0;

        if ( pStubMsg->IsClient )
            {
            if ( pContext->SavedGenericHandle )
                {
                // Note that we cannot unbind after freeing the handle as the stack would be gone.

                RpcTryExcept
                    {
                    GenericHandleUnbind( pStubMsg->StubDesc,
                                         pContext->StartofStack,
                                         pContext->pHandleFormatSave,
                                         (pContext->HandleType) ? IMPLICIT_MASK : 0,
                                         & pContext->SavedGenericHandle );
                    }
                RpcExcept(1)
                    {
                    Status = RpcExceptionCode();
                    }
                RpcEndExcept;
                }
            }

        NdrpAllocaDestroy( &pContext->AllocateContext );

        // Prevent reusing of a handle that has been freed;
        pAsyncMsg->Signature = NDR_FREED_ASYNC_SIGNATURE;

        I_RpcBCacheFree( pAsyncMsg );

        if ( Status )
            RpcRaiseException( Status );
        }
}


VOID
NdrpFreeAsyncHandleAndMessage(
    PRPC_ASYNC_STATE  AsyncHandle)
/*++

Routine Description:
    Frees an async handle and its associated async message.

Arguments:
    AsyncHandle - Supplies the async handle to be freed.

Return Value:
    None.
--*/
{
    PNDR_ASYNC_MESSAGE pAsyncMsg = (PNDR_ASYNC_MESSAGE)AsyncHandle->StubInfo;
    NdrpFreeAsyncMsg( pAsyncMsg );

    AsyncHandle->StubInfo = 0;
    AsyncHandle->Signature = RPC_FREED_ASYNC_SIGNATURE;
    I_RpcFree( AsyncHandle );
}


void
NdrAsyncSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    BOOL                fPartialSend )
{
    pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

    if ( fPartialSend )
        NdrPartialSend( pStubMsg->pContext->pPipeDesc,
                        pStubMsg );
    else
        {
        NdrSend( 0,         // not used
                 pStubMsg,
                 FALSE );   // not partial
        }
}


void
NdrLastAsyncReceive(
    PMIDL_STUB_MESSAGE  pStubMsg )
{
    pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

    // A complete call.
    // We may have a complete buffer already when pipes are involved.

    if ( pStubMsg->pContext->pPipeDesc )
        {
        if ( pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE )
            return;
        
        if ( pStubMsg->pContext->pPipeDesc->OutPipes ) 
            {
            pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_EXTRA;
            }
        else 
            {
            pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_EXTRA;
            }

        }
           

    NdrReceive( pStubMsg->pContext->pPipeDesc,
                pStubMsg,
                0,         // size, ignored for complete calls
                FALSE );   // complete buffer
}


void
NdrpRegisterAsyncHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    void *              AsyncHandle )
{
    RPC_STATUS Status;

    Status = I_RpcAsyncSetHandle( pStubMsg->RpcMsg,
                                  (RPC_ASYNC_STATE *)AsyncHandle );

    if ( Status )
        RpcRaiseException( Status );
}


RPC_STATUS
NdrpValidateAsyncMsg(
    PNDR_ASYNC_MESSAGE  pAsyncMsg )
{
    if ( ! pAsyncMsg  )
        return RPC_S_INVALID_ASYNC_HANDLE;

    if ( 0 != IsBadWritePtr( pAsyncMsg, sizeof(NDR_ASYNC_MESSAGE)) )
        return RPC_S_INVALID_ASYNC_HANDLE;

    if ( pAsyncMsg->Signature != NDR_ASYNC_SIGNATURE ||
         pAsyncMsg->Version   != NDR_ASYNC_VERSION )
        return RPC_S_INVALID_ASYNC_HANDLE;

    return RPC_S_OK;
}


RPC_STATUS
NdrpValidateAndLockAsyncHandle(
    IN PRPC_ASYNC_STATE AsyncHandle )
{
    if ( 0 != IsBadWritePtr( AsyncHandle, sizeof(RPC_ASYNC_STATE)) )
        return RPC_S_INVALID_ASYNC_HANDLE;

    // Prevent multiple simultanous abort and complete calls.

    if ( 0 != InterlockedCompareExchange( & AsyncHandle->Lock, 1, 0 ) )
        {
        return RPC_S_INVALID_ASYNC_CALL;
        }
    else
        {
        if ( AsyncHandle->Signature != RPC_ASYNC_SIGNATURE ||
             AsyncHandle->Size != RPC_ASYNC_VERSION_1_0 )
            {
            InterlockedDecrement( & AsyncHandle->Lock );
            return RPC_S_INVALID_ASYNC_HANDLE;
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
NdrValidateBothAndLockAsyncHandle(
    IN PRPC_ASYNC_STATE AsyncHandle )
{
    RPC_STATUS Status = NdrpValidateAndLockAsyncHandle( AsyncHandle );

    if ( Status != RPC_S_OK )
        return Status;

    Status =  NdrpValidateAsyncMsg( (PNDR_ASYNC_MESSAGE) AsyncHandle->StubInfo );

    if ( Status != RPC_S_OK )
        InterlockedDecrement( & AsyncHandle->Lock );

    return Status;
}


RPC_STATUS
NdrpAsyncAbortCall (
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    )
/*++
Routine Description:

    Aborts the asynchronous RPC call indicated by AsyncHandle on the server and
    frees memory allocated for the parameters, message, and handle.

Arguments:
    AsyncHandle   - supplies the async handle for the call
    AsyncMessage  - supplies the async message for the call
    ExceptionCode - supplies the exception code to send to the client.
    bFreeParams   - TRUE if the parameters should be freed.

Return Value:
    NONE.

--*/
{

    RPC_STATUS Status = RPC_S_OK;

    // If the async call is aborted, see if context handles are fine.
    // We know there is no manager routine exception. 
    NdrpCleanupServerContextHandles( &pAsyncMsg->StubMsg, 
                                     pAsyncMsg->ProcContext.StartofStack, 
                                     FALSE ); 

    if (bFreeParams)
        {
        NdrpFreeParams( & pAsyncMsg->StubMsg,
                        pAsyncMsg->ProcContext.NumberParams,  //Number of parameters
                        ( PPARAM_DESCRIPTION )pAsyncMsg->ProcContext.Params,
                        pAsyncMsg->ProcContext.StartofStack );
        }

    if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
        Status = I_RpcAsyncAbortCall( AsyncHandle, ExceptionCode);

    NdrpFreeAsyncHandleAndMessage( AsyncHandle );

    return Status;
}


RPC_STATUS
Ndr64pCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
Ndr64pCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
Ndr64pAsyncAbortCall(
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    );

//////////////////////////////////////////////////////////////////////////////
//
//                          Runtime APIs
//
//////////////////////////////////////////////////////////////////////////////

RPC_STATUS RPC_ENTRY
RpcAsyncInitializeHandle (
    IN PRPC_ASYNC_STATE AsyncHandle,
    IN unsigned int     Size
    )
/*++

Routine Description:
    Initializes an async handle.

Arguments:
    AsyncHandle - the async handle directing the call

Return Value:
    RPC_S_OK - the call succeeded.
    RPC_S_INVALID_HANDLE - the handle was bad.

--*/

{
    if ( ! AsyncHandle  ||
         Size < RPC_ASYNC_VERSION_1_0  ||  Size > RPC_ASYNC_CURRENT_VERSION )
        return RPC_S_INVALID_ARG;

    if ( 0 != IsBadWritePtr( AsyncHandle, sizeof(RPC_ASYNC_STATE)) )
        return RPC_S_INVALID_ASYNC_HANDLE;

    AsyncHandle->Size      = RPC_ASYNC_CURRENT_VERSION;
    AsyncHandle->Signature = RPC_ASYNC_SIGNATURE;
    AsyncHandle->Flags     = 0;
    AsyncHandle->Lock      = 0;
    AsyncHandle->StubInfo  = 0;
    AsyncHandle->RuntimeInfo = 0;
    AsyncHandle->Reserved[0] = 0;
    AsyncHandle->Reserved[1] = 0;
    AsyncHandle->Reserved[2] = 0;
    AsyncHandle->Reserved[3] = 0;

    return RPC_S_OK;
}


RPC_STATUS RPC_ENTRY
RpcAsyncAbortCall (
    IN PRPC_ASYNC_STATE   AsyncHandle,
    IN unsigned long      ExceptionCode
    )
/*++

Routine Description:
    This API is valid only on the server side and is a request to abort
    the call. The asynchronous handle is deleted and no additional API calls
    on that handle are permitted.

    Note that RpcCancelAsyncCall is a different API that is used on the client
    side only.

Arguments:
    AsyncHandle - the async handle directing the call

Return Value:
    RPC_S_OK - the call succeeded.
    RPC_S_INVALID_HANDLE - the handle was bad.
    RPC_S_INVALID_ASYNC_CALL - May not be called on the client.
    Other errors from the RPC runtime layer.

Note: This API cannot be called on the client side.

--*/

{
    RPC_STATUS  Status;
    PNDR_ASYNC_MESSAGE pAsyncMsg;

    Status = NdrValidateBothAndLockAsyncHandle( AsyncHandle );
    if (RPC_S_OK != Status)
       {
       return Status;
       }

    pAsyncMsg = (PNDR_ASYNC_MESSAGE)AsyncHandle->StubInfo;
    if ( pAsyncMsg->StubMsg.IsClient )
       {
       // Abort is not valid on the client.
       InterlockedDecrement( & AsyncHandle->Lock );
       return RPC_S_INVALID_ASYNC_CALL;
       }

#if defined(BUILD_NDR64)
    if ( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE )
        return NdrpAsyncAbortCall( AsyncHandle,
                               pAsyncMsg,
                               ExceptionCode,
                               TRUE ); // Free parameters
    else                
        return Ndr64pAsyncAbortCall( AsyncHandle,
                               pAsyncMsg,
                               ExceptionCode,
                               TRUE ); // Free parameters
#else

    return NdrpAsyncAbortCall( AsyncHandle,
                               pAsyncMsg,
                               ExceptionCode,
                               TRUE ); // Free parameters
#endif                                
}



RPC_STATUS
Ndr64pCompleteAsyncCall (
    IN PRPC_ASYNC_STATE     AsyncHandle,
    IN PNDR_ASYNC_MESSAGE   pAsyncMsg,
    IN void *               pReply
    )
/*++

Routine Description:

    Completes the virtual async call on server or client side.

Arguments:

    AsyncHandle - the async handle controlling the call
    Reply       - return value:
                    on server - passed in
                    on client - returned out

Return Value:

    RPC_S_OK - Function succeeded
    RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS  Status;

    RpcTryExcept
        {
        if ( pAsyncMsg->StubMsg.IsClient )
            {
#if defined(BUILD_NDR64)
            if ( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE )
                Status = NdrpCompleteAsyncClientCall( AsyncHandle, pAsyncMsg, pReply );
            else                
                Status = Ndr64pCompleteAsyncClientCall( AsyncHandle, pAsyncMsg, pReply );
#else
            NDR_ASSERT( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE,
                        "Invalid transfer syntax" );
            Status = NdrpCompleteAsyncClientCall( AsyncHandle, pAsyncMsg, pReply );
#endif
            }
        else
            {
#if defined(BUILD_NDR64)
            if ( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE )
                Status = NdrpCompleteAsyncServerCall ( AsyncHandle, pAsyncMsg, pReply );
            else
                Status = Ndr64pCompleteAsyncServerCall( AsyncHandle, pAsyncMsg, pReply );
#else
            NDR_ASSERT( pAsyncMsg->ProcContext.CurrentSyntaxType == XFER_SYNTAX_DCE,
                    "Invalid transfer Syntax" );
            Status = NdrpCompleteAsyncServerCall ( AsyncHandle, pAsyncMsg, pReply );
#endif            
            }
        }
    RpcExcept( !(RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept

    return Status;
}

RPC_STATUS RPC_ENTRY
RpcAsyncCompleteCall (
    IN PRPC_ASYNC_STATE AsyncHandle,
    IN void *           pReply
    )
/*++

Routine Description:

    Completes the virtual async call on server or client side.

Arguments:

    AsyncHandle - the async handle controlling the call
    Reply       - return value:
                    on server - passed in
                    on client - returned out

Return Value:

    RPC_S_OK - Function succeeded
    RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS  Status = NdrValidateBothAndLockAsyncHandle( AsyncHandle );

    if ( Status == RPC_S_OK )
        {
        Status = Ndr64pCompleteAsyncCall( AsyncHandle,
                                        (PNDR_ASYNC_MESSAGE) AsyncHandle->StubInfo,
                                        pReply );
        }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\typelib\tllist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       tllist.cxx
//
//  Contents:   type library list class
//              and IUnknown holder
//
//  Classes:    CTypeLibraryList
//              CObjHolder
//
//  Functions:
//
//  History:    4-10-95   stevebl   Created
//
//----------------------------------------------------------------------------

#pragma warning ( disable : 4514 )

#include "tlcommon.hxx"
#include "tllist.hxx"
#include "filehndl.hxx"

class TLNODE{
public:
    char * szName;
    ITypeLib * pTL;
    class TLNODE * pNext;

    TLNODE()
    {
        pNext = NULL;
        pTL = NULL;
        szName = NULL;
    }

    ~TLNODE()
    {
        if (NULL != pTL)
        {
            pTL->Release();
        }
    }
};

CTypeLibraryList::~CTypeLibraryList()
{
    delete pItfList;
    TLNODE * pNext;
    while (NULL != pHead)
    {
        pNext = pHead->pNext;
        delete(pHead);
        pHead = pNext;
    }
    // make sure OLE gets uninitialized at the right time
    TLUninitialize();
}

#define _MAX_FILE_NAME (_MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT)
extern NFA_INFO* pImportCntrl;

BOOL CTypeLibraryList::Add(char *sz)
{
    TLNODE * pThis = new TLNODE;
    WCHAR * wsz = new WCHAR[MAX_PATH + 1];

    if (NULL == wsz || NULL == pThis)
        return FALSE;

    	// We need to find details of the file name. We need to see if the user
	// has already specified path, if so, override the current paths.
	// if the user has specified a file extension, get the extension. We
	// need to do that in order to have uniformity with the case where
	// a preprocessed file is input with a different extension

	char			agDrive[_MAX_DRIVE];
	char			agPath[_MAX_DIR];
	char			agName[_MAX_FNAME];
	char			agExt[_MAX_EXT];
    char            szFileName[ _MAX_PATH ];

    _splitpath( sz, agDrive, agPath, agName, agExt );

	// if file is specified with a path, the user knows fully the location
	// else search for the path of the file

	if( !agPath[0] && !agDrive[0] )
		{
	    char			agNameBuf[ _MAX_FILE_NAME + 1];
        char*           pPath;

		sprintf(agNameBuf, "%s%s", agName, agExt);
		
        if( ( pPath = pImportCntrl->SearchForFile(agNameBuf) ) == 0 )
			{
            // TLB not found in the search paths.
            // it might be a system TLB <stdole2.tlb> which does not 
            // require a path. If TLB is not found, the error is caught
            // trying to load a non-existent TLB.
		    strcpy( szFileName, sz );
			}
        else
            {
            // TLB is found in the search path. Form the entire path to filename.
		    strcpy( szFileName, pPath );
		    strcat( szFileName, agNameBuf );
            }
		}
    else
        {
		strcpy( szFileName, sz );
        }

    A2O(wsz, szFileName, MAX_PATH);
    HRESULT hr = LateBound_LoadTypeLib(wsz, &(pThis->pTL));

    if SUCCEEDED(hr)
    {
        BSTR bstrName;
        // Add new libraries to the END of the list

        TLNODE ** ppTail = &pHead;
        while (*ppTail)
            ppTail = &((*ppTail)->pNext);

        pThis->pTL->GetDocumentation(-1, &bstrName, NULL, NULL, NULL);
        pThis->szName = TranscribeO2A( bstrName );
        LateBound_SysFreeString(bstrName);

        AddTypeLibraryMembers(pThis->pTL, sz);
        pThis->pNext = NULL;
        (*ppTail) = pThis;
        return TRUE;
    }
    else
        return FALSE;
}

ITypeLib * CTypeLibraryList::FindLibrary(char * sz)
{
    TLNODE * pThis = pHead;
    while (pThis)
    {
        if (0 == _stricmp(sz, pThis->szName))
            return pThis->pTL;
        pThis = pThis->pNext;
    }
    return NULL;
}

ITypeInfo * CTypeLibraryList::FindName(char * szFileHint, WCHAR * wsz)
{
    if (pHead)
    {
        if (0 == _stricmp(szFileHint, "unknwn.idl") || 0 == _stricmp(szFileHint, "oaidl.idl"))
        {
            szFileHint = "stdole";
        }
        BOOL fFirst = TRUE;
        TLNODE * pThis = pHead;
        while (pThis && szFileHint)
        {
            if (0 == _stricmp(szFileHint, pThis->szName))
                break;
            pThis = pThis->pNext;
        }
        if (!pThis)
        {
            pThis = pHead;
            fFirst = FALSE;
        }
        ITypeInfo * ptiFound;
        SYSKIND sk = ( SYSKIND ) ( pCommand->Is64BitEnv() ? SYS_WIN64 : SYS_WIN32 );
        ULONG lHashVal = LateBound_LHashValOfNameSys(sk, NULL, wsz);
        HRESULT hr;
        MEMBERID memid;
        unsigned short c;
        while (pThis)
        {
            c = 1;
            hr = pThis->pTL->FindName(wsz, lHashVal, &ptiFound, &memid, &c);
            if (SUCCEEDED(hr))
            {
                if (c)
                {
                    // found a matching name
                    if (-1 == memid)
                    {
                        return ptiFound;
                    }
                    // found a parameter name or some other non-global name
                    ptiFound->Release();
                }
            }
            if (fFirst)
            {
                pThis = pHead;
                fFirst = FALSE;
            }
            else
                pThis = pThis->pNext;
        }
    }
    return NULL;
}

class IUNKNODE
{
public:
    IUnknown * pUnk;
    char * szName;
    IUNKNODE * pNext;

    IUNKNODE()
    {
        pUnk = NULL;
        szName = NULL;
        pNext = NULL;
    }

    ~IUNKNODE()
    {
        if (NULL != pUnk)
        {
            pUnk->Release();
        }
    }
};

CObjHolder::~CObjHolder()
{
    IUNKNODE * pNext;
    while (pHead)
    {
        pNext = pHead->pNext;
        delete pHead;
        pHead = pNext;
    }
}

void CObjHolder::Add(IUnknown * pUnk, char * szName)
{
    IUNKNODE ** ppNext = &pHead;
    while (*ppNext && (*ppNext)->pUnk > pUnk)
    {
        ppNext = &((*ppNext)->pNext);
    }
    if (*ppNext && (*ppNext)->pUnk == pUnk)
    {
        // We already have this one ref-counted.
        pUnk->Release();
    }
    else
    {
        IUNKNODE * pNew = new IUNKNODE;
        pNew->szName = szName;
        pNew->pUnk = pUnk;
        pNew->pNext = *ppNext;
        *ppNext = pNew;
    }
}

IUnknown * CObjHolder::Find(char * szName)
{
    IUNKNODE * pThis = pHead;
    while (pThis)
    {
        if (NULL != pThis->szName && 0 == _stricmp(pThis->szName, szName))
            return pThis->pUnk;
        pThis = pThis->pNext;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\asyncu.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 2000 Microsoft Corporation

Module Name :

    asyncu.c

Abstract :

    This file contains the ndr async uuid implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Oct 1997

Revision History :

---------------------------------------------------------------------*/



#define USE_STUBLESS_PROXY
#define CINTERFACE

#include "ndrp.h"
#include "ndrole.h"
#include "rpcproxy.h"
#include "mulsyntx.h"
#include "hndl.h"
#include "interp2.h"
#include "asyncu.h"
#include "attack.h"
#include <stddef.h>

#include <stdarg.h>

#pragma code_seg(".orpc")


RPC_STATUS
NdrpBeginDcomAsyncClientCall(
                            PMIDL_STUB_DESC     pStubDescriptor,
                            PFORMAT_STRING      pFormat,
                            unsigned char  *    StartofStack
                            );

RPC_STATUS
NdrpFinishDcomAsyncClientCall(
                             PMIDL_STUB_DESC     pStubDescriptor,
                             PFORMAT_STRING      pFormat,
                             unsigned char  *    StartofStack
                             );

const IID * RPC_ENTRY
NdrGetProxyIID(
    const void *pThis);



VOID
NdrpAsyncDCOMFreeParams(
                       PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg )
{
/*++

Routine Description:
    Frees the parameters for both the begin and finish calls.

Arguments:
    pAsyncMsg - Supplies a pointer to the async message.

Return Value:
    None.

--*/

   if ( pAsyncMsg->BeginStack )
      {

      if ( pAsyncMsg->FinishStack )
         {

         // Clear out the IN OUT parameters on the begin stack
         // so that they are not freed twice.
         int n;
         REGISTER_TYPE       *pBeginStack      = (REGISTER_TYPE *)pAsyncMsg->BeginStack;
         PPARAM_DESCRIPTION  BeginParams       = (PPARAM_DESCRIPTION)pAsyncMsg->BeginParams;
         int                 BeginNumberParams = (int)pAsyncMsg->nBeginParams;

         for( n = 0; n < BeginNumberParams; n++ ) 
            {

            if ( BeginParams[n].ParamAttr.IsIn  &&
                 BeginParams[n].ParamAttr.IsOut )
               {

               pBeginStack[ BeginParams[ n ].StackOffset / sizeof(REGISTER_TYPE) ] = 0;
               
               }
                  
            }
         }

      NdrpFreeParams( & (pAsyncMsg->StubMsg),
                      pAsyncMsg->nBeginParams,
                      (PPARAM_DESCRIPTION)pAsyncMsg->BeginParams,
                      pAsyncMsg->BeginStack );
      }

   if ( pAsyncMsg->FinishStack )
      {

      NdrpFreeParams( & (pAsyncMsg->StubMsg),
                      pAsyncMsg->nFinishParams,
                      (PPARAM_DESCRIPTION)pAsyncMsg->FinishParams,
                      pAsyncMsg->FinishStack );
      }

}


CLIENT_CALL_RETURN  RPC_VAR_ENTRY
NdrDcomAsyncClientCall(
                      PMIDL_STUB_DESC     pStubDescriptor,
                      PFORMAT_STRING      pFormat,
                      ...
                      )
/*
    This entry is used by the stubless proxy invoker and also by OLE thunks.
    Sync stubless proxies would invoke to NdrClientCall2.
    On ia64, this entry would be used by -Oic generated code.

    Note that signaling on the client happens behind the async proxy's back
    as channel effectively signals to the app and the app issues the Finish.
*/

{
   va_list                 ArgList;
   unsigned char  *        StartofStack;
   CLIENT_CALL_RETURN      Ret;
   ulong                   ProcNum;
   //
   // Get address of argument to this function following pFormat. This
   // is the address of the address of the first argument of the function
   // calling this function.
   // Then get the address of the stack where the parameters are.
   //
   INIT_ARG( ArgList, pFormat);
   GET_FIRST_IN_ARG(ArgList);
   StartofStack = (uchar *) GET_STACK_START(ArgList);

   // Object proc layout is fixed for anything that can show up here.

   ProcNum = *(ushort *)(pFormat+6);

   if ( ProcNum & 0x1 )
      {
      // An odd proc number means a Begin call (0,1,2,Begin,Finish, ...).

      Ret.Simple = NdrpBeginDcomAsyncClientCall( pStubDescriptor,
                                                 pFormat,
                                                 StartofStack );
      }
   else
      {
      Ret.Simple = NdrpFinishDcomAsyncClientCall( pStubDescriptor,
                                                  pFormat,
                                                  StartofStack );
      }

   return Ret;
}


#if defined(_IA64_)
CLIENT_CALL_RETURN  RPC_ENTRY
NdrpDcomAsyncClientCall(
                       PMIDL_STUB_DESC     pStubDescriptor,
                       PFORMAT_STRING      pFormat,
                       unsigned char  *    StartofStack
                       )
/*
    Used only on ia64,
    this entry is used by the stubless proxy invoker and also by OLE thunks.
    Sync stubless proxies would invoke to NdrpClientCall2.

    Note that signaling on the client happens behind the async proxy's back
    as channel effectively signals to the app and the app issues the Finish.
*/

{
   CLIENT_CALL_RETURN      Ret;
   ulong                   ProcNum;

   // Object proc layout is fixed for anything that can show up here.

   ProcNum = *(ushort *)(pFormat+6);

   if ( ProcNum & 0x1 )
      {
      // An odd proc number means a Begin call (0,1,2,Begin,Finish, ...).

      Ret.Simple = NdrpBeginDcomAsyncClientCall( pStubDescriptor,
                                                 pFormat,
                                                 StartofStack );
      }
   else
      {
      Ret.Simple = NdrpFinishDcomAsyncClientCall( pStubDescriptor,
                                                  pFormat,
                                                  StartofStack );
      }

   return Ret;
}
#endif


HRESULT
NdrpBeginDcomAsyncClientCall(
                            PMIDL_STUB_DESC     pStubDescriptor,
                            PFORMAT_STRING      pFormat,
                            unsigned char  *    StartofStack
                            )
/*
    Notes: OLE Refcounting.
    The model for async_uuid() is that async proxies or stubs
    are created with RefCount==1 and should never ever be
    addrefed by the engine.
    What the engine does is only the AsyncMsg clean up when done.

    The decision to destroy the AsyncPB or AsyncSB object is
    up to the client side PM or channel's SM for the server side.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;
   PFORMAT_STRING              pFormatParam;

   uchar *                     pArg;
   void *                      pThis = *(void **)StartofStack;
   INTERPRETER_FLAGS           OldOiFlags;
   INTERPRETER_OPT_FLAGS       NewOiFlags;
   PPARAM_DESCRIPTION          Params;
   long                        NumberParams;
   long                        n;

   RPC_STATUS                  Status;
   PNDR_DCOM_OI2_PROC_HEADER   pProcHeader = (PNDR_DCOM_OI2_PROC_HEADER)pFormat;
   PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;
   CStdAsyncProxyBuffer    *   pAsyncPB;
   const IID *                 piid;
   HRESULT                     hr = S_OK;
   BOOL                        fSendCalled = FALSE;
   NDR_PROC_CONTEXT *          pContext = NULL;

   pAsyncPB = (CStdAsyncProxyBuffer*)
              ((uchar*)pThis - offsetof(CStdProxyBuffer, pProxyVtbl));

   piid = NdrGetProxyIID( pThis );

   Status = NdrpSetupBeginClientCall( pAsyncPB,
                                      StartofStack,
                                      pProcHeader->StackSize,
                                      *piid );
   if ( !SUCCEEDED(Status) )
      return Status;

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncPB->CallState.pAsyncMsg;

   // We need to switch to our copy of the stack everywhere, including pStubMsg.

   StartofStack = pAsyncMsg->ProcContext.StartofStack;

   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pContext = ( NDR_PROC_CONTEXT * ) &pAsyncMsg->ProcContext;
   pStubMsg->pContext = pContext;
   pContext->StartofStack = StartofStack;

   pStubMsg->FullPtrXlatTables = 0;

   OldOiFlags   = pProcHeader->OldOiFlags;
   NewOiFlags   = pProcHeader->Oi2Flags;
   NumberParams = pProcHeader->NumberParams;

   //
   // Parameter descriptions are nicely spit out by MIDL.
   //
   Params = (PPARAM_DESCRIPTION)(pFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

   // Proc header extentions, from NDR ver. 5.2, MIDL 5.0.+
   // Params must be set correctly here because of exceptions.

   if ( NewOiFlags.HasExtensions )
      {
      pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
      Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
      }

   pAsyncMsg->nBeginParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->BeginParams = pContext->Params = Params;
   pAsyncMsg->pThis       = pThis;
   pContext->DceTypeFormatString = pStubDescriptor->pFormatTypes;

   // This is OLE only code path - use a single TryExcept.
   // After catching it just map it to OLE exception.

   RpcTryExcept
   {
      ulong  RpcFlags;

      // Note, pProcHeader->ProcNum is the async proc number.

      NdrProxyInitialize( pThis,
                          pRpcMsg,
                          pStubMsg,
                          pStubDescriptor,
                          (pProcHeader->ProcNum + 3)/2   // sync proc number
                        );

      pStubMsg->pAsyncMsg = (struct _NDR_ASYNC_MESSAGE *) pAsyncMsg;

      if ( OldOiFlags.FullPtrUsed )
         pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );

      // Set Rpc flags after the call to client initialize.
      RpcFlags= *(ulong UNALIGNED *)(pFormat + 2);
      pStubMsg->RpcMsg->RpcFlags = RpcFlags;

      // Must do this before the sizing pass!
      pStubMsg->StackTop = pContext->StartofStack = StartofStack;

      if ( NewOiFlags.HasExtensions )
         {
         pStubMsg->fHasExtensions  = 1;
         pStubMsg->fHasNewCorrDesc = pHeaderExts->Flags2.HasNewCorrDesc;
         if ( pHeaderExts->Flags2.ClientCorrCheck )
            {
            void * pCache = NdrpAlloca( &pAsyncMsg->ProcContext.AllocateContext, NDR_DEFAULT_CORR_CACHE_SIZE );
            
            NdrCorrelationInitialize( pStubMsg,
                                      pCache,
                                      NDR_DEFAULT_CORR_CACHE_SIZE,
                                      0 /* flags */ );
            }
         }

      //
      // ----------------------------------------------------------------
      // Sizing Pass.
      // ----------------------------------------------------------------
      //

      //
      // Get the compile time computed buffer size.
      //
      pStubMsg->BufferLength = pProcHeader->ClientBufferSize;

      //
      // Check ref pointers and do object proc [out] zeroing.
      //

      for ( n = 0; n < NumberParams; n++ )
         {
         pArg = StartofStack + Params[n].StackOffset;

         if ( Params[n].ParamAttr.IsSimpleRef )
            {
            // We can raise the exception here as there is no out only args.

            if ( ! *((uchar **)pArg) )
               RpcRaiseException( RPC_X_NULL_REF_POINTER );
            }

         // [out] only argument on the Begin call.
         if ( ! Params[n].ParamAttr.IsIn &&
              Params[n].ParamAttr.IsOut  &&
              ! Params[n].ParamAttr.IsReturn)
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
         }

      //
      // Skip buffer size pass if possible.
      //
      if ( NewOiFlags.ClientMustSize )
         {
         NdrpSizing( pStubMsg, 
                     TRUE );    // IsObject
         }

      //
      // Do the GetBuffer.
      //

      pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

      NdrProxyGetBuffer( pThis, pStubMsg );

      NDR_ASSERT( pStubMsg->fBufferValid, "Invalid buffer" );

      pAsyncMsg->StubPhase = STUB_MARSHAL;

      //
      // ----------------------------------------------------------
      // Marshall Pass.
      // ----------------------------------------------------------
      //

      NdrpClientMarshal ( pStubMsg,
                          TRUE );   // IsObject
      //
      // Make the RPC call.
      //

      pAsyncMsg->StubPhase = NDR_ASYNC_CALL_PHASE;

      fSendCalled = NdrpDcomAsyncClientSend( pStubMsg,
                                             pAsyncPB->punkOuter );  // PM's entry
      if ( fSendCalled )
         hr = S_OK;
   }
   RpcExcept( 1 )
   {
      RPC_STATUS ExceptionCode = RpcExceptionCode();

      pAsyncPB->CallState.Flags.BeginError = 1;

      // Actually dismantle the call.
      // This is a request call and there is nothing left at the runtime.

      pAsyncMsg->StubPhase = NDR_ASYNC_ERROR_PHASE;
      pAsyncMsg->ErrorCode = ExceptionCode;

      hr = NdrHrFromWin32Error(ExceptionCode);
      pAsyncPB->CallState.Hr = hr;

      // Async call in request phase: don't touch [out] params.
   }
   RpcEndExcept

   // "Finally"
   // Dont touch anything, the client has to call the Finish method anyway.

   pAsyncPB->CallState.Flags.BeginDone = 1;
   if ( SUCCEEDED(hr) )
      {
      NdrpCloneInOnlyCorrArgs( pAsyncMsg, pAsyncMsg->StubMsg.StubDesc->pFormatTypes );
      // Channel will prompt signal
      }
   else
      if (!fSendCalled )
      NdrpAsyncProxySignal( pAsyncPB );

   // No need to release, our refcount should be 1 at this point.

   return hr;
}


void
NdrpCloneInOnlyCorrArgs(
                       NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg,
                       PFORMAT_STRING           pTypeFormat
                       )
/*
    Walk the client stack looking for an in only argument flagged to clone.
    For each one, replace the arg with a clone that we control.
    Assumption is, we do it before returning to the user from the Begin call
    and also we clone walking the copy of the app's stack not the app stack.

    The stack modified in this way will be the one to access for the weird
    crossreferenced correlated args.

    This issue doesn't happen on the server, as we keep the Begin stack around
    when the Finish call is processed.

*/
{
   unsigned char  *    pBeginStack  = pAsyncMsg->BeginStack;
   PPARAM_DESCRIPTION  Params       = (PPARAM_DESCRIPTION)pAsyncMsg->BeginParams;
   int                 NumberParams = (int)pAsyncMsg->nBeginParams;
   unsigned char  *    pArg;
   int                 n;

   for ( n = 0; n < NumberParams; n++ )
      {
      if ( Params[n].ParamAttr.SaveForAsyncFinish )
         {
         // Note that the arguments that need cloning come from top level size_is,
         // length_is etc, switch_is and iid_is attributes.
         // Hence, the only types of interest are uuid clones and integral types
         // different from hyper.
         // On top of it, we deal with stack-slot chunks of memory, so we don't
         // have to care about mac issues.

         pArg = pBeginStack + Params[n].StackOffset;

         if ( Params[n].ParamAttr.IsBasetype )
            {
            if ( Params[n].ParamAttr.IsSimpleRef )
               {
               void * pPointee = AsyncAlloca( pAsyncMsg, 8 );

               // The assignment needs to follow the type.
               RpcpMemoryCopy( pPointee, *(void **)pArg, 
                               SIMPLE_TYPE_MEMSIZE( Params[n].SimpleType.Type ) );  
               *(void**)pArg = pPointee;
               }
            // else the stack slot has the simple value already.
            }
         else
            {
            // If it's not a base type, then it cannot be by value.
            // It has to be a pointer to a simple type or to an iid.

            PFORMAT_STRING  pParamFormat;

            pParamFormat = pTypeFormat +
                           Params[n].TypeOffset;

            if ( IS_BASIC_POINTER(*pParamFormat) )  // not FC_IP
               {
               if ( SIMPLE_POINTER(pParamFormat[1]) )
                  {
                  // Covers things like a unique pointer to a size
                  // Essentially the same as for the simple ref above.

                  void * pPointee = AsyncAlloca( pAsyncMsg, 8 );

                  // The assignment needs to follow the type.
                  RpcpMemoryCopy( pPointee, *(void **)pArg, 
                                  SIMPLE_TYPE_MEMSIZE( pParamFormat[2] ) );
                  *(void**)pArg = pPointee;
                  }
               else
                  {
                  // has to be the riid case.
                  // REFIID* comes out as FC_?P -> FC_?P -> FC_STRUCT

                  PFORMAT_STRING  pFormat;

                  pFormat = pParamFormat + *(short *)(pParamFormat + 2);

                  if ( IS_BASIC_POINTER(*pFormat)  &&
                       ! SIMPLE_POINTER(pParamFormat[1]) )
                     {
                     pParamFormat = pFormat + *(short *)(pFormat + 2);

                     if ( *pParamFormat == FC_STRUCT )
                        {
                        // one alloc for REFIID and IID itself.
                        IID** ppIID = 
                            (IID**)AsyncAlloca( pAsyncMsg,
                                                sizeof(IID *) + sizeof(IID));
                        IID* pIID = (IID *)(ppIID + 1);


                        *ppIID = pIID; //set pointer
                        RpcpMemoryCopy( pIID, **(IID ***)pArg, sizeof(IID));
                        *(IID ***)pArg = ppIID;
                        }
                     else
                        RpcRaiseException( RPC_S_INTERNAL_ERROR );
                     }
                  else
                     RpcRaiseException( RPC_S_INTERNAL_ERROR );
                  }
               }
            else
               {
               // has to be the riid case.
               // REFIID comes out as FC_STRUCT

               if ( *pParamFormat == FC_STRUCT )
                  {
                  IID *pIID = (IID*)AsyncAlloca( pAsyncMsg, sizeof(IID) );

                  RpcpMemoryCopy( pIID, *(IID **)pArg, sizeof(IID));
                  *(IID **)pArg = pIID;
                  }
               else
                  RpcRaiseException( RPC_S_INTERNAL_ERROR );
               }

            }

         }
      }
}


HRESULT
NdrpFinishDcomAsyncClientCall(
                             PMIDL_STUB_DESC     pStubDescriptor,
                             PFORMAT_STRING      pFormat,
                             unsigned char  *    StartofStack
                             )
{
   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   PFORMAT_STRING              pFormatParam;

   uchar *                     pArg;
   void *                      pThis = *(void **)StartofStack;
   CLIENT_CALL_RETURN          ReturnValue;

   INTERPRETER_FLAGS           OldOiFlags;      // Finish proc flags
   INTERPRETER_OPT_FLAGS       NewOiFlags;      //
   PPARAM_DESCRIPTION          Params;          //
   long                        NumberParams;
   long                        n;
   NDR_ASYNC_CALL_FLAGS        CallFlags;

   PNDR_DCOM_OI2_PROC_HEADER   pProcHeader = (PNDR_DCOM_OI2_PROC_HEADER)pFormat;
   PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;
   CStdAsyncProxyBuffer    *   pAsyncPB;
   const IID *                 piid;
   HRESULT                     hr = S_OK;
   NDR_PROC_CONTEXT *          pContext = NULL;

   ReturnValue.Simple = 0;

   pAsyncPB = (CStdAsyncProxyBuffer*)
              ((uchar*)pThis - offsetof(CStdProxyBuffer, pProxyVtbl));

   piid = NdrGetProxyIID( pThis );

   hr = NdrpSetupFinishClientCall( pAsyncPB,
                                   StartofStack,
                                   pProcHeader->StackSize,
                                   *piid,
                                   pProcHeader->ProcNum );
   if ( !SUCCEEDED(hr) )
      return hr;

   // Note that we cant call to NdrProxyInitialize again.

   PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg = 
       (PNDR_DCOM_ASYNC_MESSAGE)pAsyncPB->CallState.pAsyncMsg;

   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pContext = ( NDR_PROC_CONTEXT * )pStubMsg->pContext;

   OldOiFlags   = pProcHeader->OldOiFlags;
   NewOiFlags   = pProcHeader->Oi2Flags;
   NumberParams = pProcHeader->NumberParams;

   //
   // Parameter descriptions are nicely spit out by MIDL.
   //
   Params = (PPARAM_DESCRIPTION)(pFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));
   if ( NewOiFlags.HasExtensions )
      {
      pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
      Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
      }

   CallFlags = pAsyncMsg->Flags;

   // Initialize the stack top in the stub msg to be
   // this stack, the stack for the finish call parameters.
   pAsyncMsg->nFinishParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->FinishParams = pContext->Params = Params;
   pStubMsg->StackTop = pContext->StartofStack = StartofStack;

   // OLE only code path - single RpcTryExcept.
   //
   RpcTryExcept
   {
      BOOL fRaiseExcFlag = FALSE;

      if ( CallFlags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // We need to zero out the [out] parameters and to check
      // the ref pointers.

      for ( n = 0; n < NumberParams; n++ )
         {
         pArg = StartofStack + Params[n].StackOffset;

         if ( Params[n].ParamAttr.IsSimpleRef )
            {
            // We cannot raise the exception here,
            // as some out args may not be zeroed out yet.

            if ( ! *((uchar **)pArg) )
               {
               fRaiseExcFlag = TRUE;
               continue;
               }
            }

         // We do the basetype check to cover the
         // [out] simple ref to basetype case.
         //
         if ( Params[n].ParamAttr.IsPartialIgnore ||
              ( ! Params[n].ParamAttr.IsIn &&
                ! Params[n].ParamAttr.IsReturn ) )
            {
            if ( Params[n].ParamAttr.IsBasetype )
               {
               // [out] only arg can only be ref, we checked that above.
               MIDL_memset( *(uchar **)pArg, 
                            0, 
                            (size_t)SIMPLE_TYPE_MEMSIZE( Params[n].SimpleType.Type ));
               }
            else
               {
               pFormatParam = pStubDescriptor->pFormatTypes +
                              Params[n].TypeOffset;

               NdrClientZeroOut(
                               pStubMsg,
                               pFormatParam,
                               *(uchar **)pArg );
               }
            }
         }

      if ( fRaiseExcFlag )
         RpcRaiseException( RPC_X_NULL_REF_POINTER );


      NdrDcomAsyncReceive( pStubMsg );

      //
      // ----------------------------------------------------------
      // Unmarshall Pass.
      // ----------------------------------------------------------
      //

      NdrpClientUnMarshal( pStubMsg,
                           &ReturnValue );
                           
                           

      // DCOM interface must have HRESULT as return value.
      hr = (HRESULT) ReturnValue.Simple;
   }
   RpcExcept( 1 )
   {
      RPC_STATUS ExceptionCode = RpcExceptionCode();

      //
      // In OLE, since they don't know about error_status_t and wanted to
      // reinvent the wheel, check to see if we need to map the exception.
      // In either case, set the return value and then try to free the
      // [out] params, if required.
      //
      hr = NdrHrFromWin32Error(ExceptionCode);

      //
      // Set the Buffer endpoints so the NdrFree routines work.
      //
      pStubMsg->BufferStart = 0;
      pStubMsg->BufferEnd   = 0;

      for ( n = 0; n < NumberParams; n++ )
         {
         //
         // Skip everything but [out] only parameters.  We make
         // the basetype check to cover [out] simple ref pointers
         // to basetypes.
         //
         if ( !Params[n].ParamAttr.IsPartialIgnore )
             {
             if ( Params[n].ParamAttr.IsIn ||
                  Params[n].ParamAttr.IsReturn ||
                  Params[n].ParamAttr.IsBasetype )
                continue;
             }

         pArg = StartofStack + Params[n].StackOffset;

         pFormatParam = pStubDescriptor->pFormatTypes +
                        Params[n].TypeOffset;

         NdrClearOutParameters( pStubMsg,
                                pFormatParam,
                                *((uchar **)pArg) );
         }
   }
   RpcEndExcept

   // Finish
   // Cleanup everything. However, don't free pAsyncPB itself.

   NdrpAsyncProxyMsgDestructor( pAsyncPB );

   //  Never addref or release async proxy object, this is app's/PM's job.

   return hr;
}


HRESULT RPC_ENTRY
NdrDcomAsyncStubCall(
                    struct IRpcStubBuffer *     pThis,
                    struct IRpcChannelBuffer *  pChannel,
                    PRPC_MESSAGE                pRpcMsg,
                    ulong *                     pdwStubPhase
                    )
/*++

Routine Description :

    Server Interpreter entry point for DCOM async procs.
    This is the Begin entry for channel (regular dispatch entry from stub.c).
    The Finish happen when the channel calls stub's Synchronize::Signal method
    on the stub object. The call then comes to NdrpAsyncStubSignal later below.

Arguments :

    pThis           - Object proc's 'this' pointer.
    pChannel        - Object proc's Channel Buffer.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

Notes :
    The engine never calls a signal on behalf of the user, regardless what kind of
    errors happen during begin (cannot setup begin, cannot unmarshal, app dies in invoke).
    In each of these cases, the engine simply returns an error code to the channel.

    The only time the engine would call FreeBuffer on the server is if the engine died
    between a successful GetBuffer and the final Send.

Notes on OLE Refcounting.
    The model for async_uuid() is that async proxies or stubs are created
    with RefCount==1 and should never ever be addrefed by the engine.
    What the engine does is only the AsyncMsg clean up when done.

    The decision to destroy the AsyncPB or AsyncSB object is
    up to the client side PM or channel's SM for the server side.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   PMIDL_SERVER_INFO           pServerInfo;
   PMIDL_STUB_DESC             pStubDesc;
   const SERVER_ROUTINE  *     DispatchTable;
   unsigned long               ProcNum;

   ushort                      FormatOffset;
   PFORMAT_STRING              pFormat;
   PFORMAT_STRING              pFormatParam;

   PMIDL_STUB_MESSAGE          pStubMsg;

   uchar *                     pArgBuffer;
   uchar *                     pArg;
   uchar **                    ppArg;

   PPARAM_DESCRIPTION          Params;
   INTERPRETER_FLAGS           OldOiFlags;
   INTERPRETER_OPT_FLAGS       NewOiFlags;
   long                        NumberParams;

   BOOL                        fBadStubDataException = FALSE;
   BOOL                        fManagerCodeInvoked = FALSE;
   long                        n;
   PNDR_DCOM_OI2_PROC_HEADER   pProcHeader;
   PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;

   CStdAsyncStubBuffer *       pAsyncSB;

   HRESULT                     hr;

   const IID *                 piid = 0;
   BOOL                        fErrorInInvoke = FALSE;
   BOOL                        fRecoverableErrorInInvoke = FALSE;

   IUnknown *                  pSrvObj;
   CInterfaceStubVtbl *        pStubVTable;
   NDR_PROC_CONTEXT *          pContext = NULL ;
   RPC_STATUS                  ExceptionCode = 0;

   NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
               "marshaling buffer misaligned at server" );

   // The channel dispatches to the engine with the sync proc num.
   // We need only async proc num at the engine level.
   ProcNum = pRpcMsg->ProcNum;
   ProcNum = 2 * ProcNum - 3;  // Begin method #

   pSrvObj = (IUnknown *)((CStdStubBuffer *)pThis)->pvServerObject;
   DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

   pStubVTable = (CInterfaceStubVtbl *)
                 (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

   piid        = pStubVTable->header.piid;
   pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

   pStubDesc    = pServerInfo->pStubDesc;
   FormatOffset = pServerInfo->FmtStringOffset[ ProcNum ];
   pFormat   = &((pServerInfo->ProcString)[FormatOffset]);

   // The proc header has a fixed layout now.

   pProcHeader = (PNDR_DCOM_OI2_PROC_HEADER) pFormat;

   pAsyncSB = (CStdAsyncStubBuffer *)
              ((uchar *)pThis - offsetof(CStdAsyncStubBuffer,lpVtbl));

   hr = NdrpSetupBeginStubCall( pAsyncSB,
                                pProcHeader->StackSize,
                                *piid );
   if ( FAILED(hr) )
      return hr;

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncSB->CallState.pAsyncMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pContext = &pAsyncMsg->ProcContext;

   // Both rpc runtime and channel require that we use a copy of the rpc message.

   RpcpMemoryCopy( & pAsyncMsg->RpcMsg, pRpcMsg, sizeof(RPC_MESSAGE) );
   pRpcMsg = & pAsyncMsg->RpcMsg;

   pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

   // The arg buffer is zeroed out already.
   pArgBuffer = pAsyncMsg->ProcContext.StartofStack;

   //
   // Get new interpreter info.
   //
   OldOiFlags   = pProcHeader->OldOiFlags;
   NewOiFlags   = pProcHeader->Oi2Flags;
   NumberParams = pProcHeader->NumberParams;

   Params = (PPARAM_DESCRIPTION)(pFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

   if ( NewOiFlags.HasExtensions )
      {
      pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
      Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
      }

   pAsyncMsg->nBeginParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->BeginParams  = pContext->Params     = Params;
   pAsyncMsg->pThis            = pThis;
   pContext->DceTypeFormatString = pStubDesc->pFormatTypes;

   //
   // Wrap the unmarshalling and the invoke call in the try block of
   // a try-finally. Put the free phase in the associated finally block.
   //
   // We abstract the level of indirection here.

   RpcTryFinally
   {
      // OLE: put pThis in first dword of stack.
      //
      ((void **)pArgBuffer)[0] = ((CStdStubBuffer *)pThis)->pvServerObject;

      // Initialize the Stub message.
      //
      NdrStubInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDesc,
                         pChannel );

      pStubMsg->pAsyncMsg     = (struct _NDR_ASYNC_MESSAGE *) pAsyncMsg;

      pAsyncMsg->pdwStubPhase = pdwStubPhase;    // the phase is STUB_UNMARSHAL

      // Raise exceptions after initializing the stub.

      if ( OldOiFlags.FullPtrUsed )
         pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );
      else
         pStubMsg->FullPtrXlatTables = 0;

      //
      // Set StackTop AFTER the initialize call, since it zeros the field
      // out.
      //
      pStubMsg->StackTop  = pArgBuffer;

      if ( NewOiFlags.HasExtensions )
         {
         pStubMsg->fHasExtensions  = 1;
         pStubMsg->fHasNewCorrDesc = pHeaderExts->Flags2.HasNewCorrDesc;

         if ( pHeaderExts->Flags2.ServerCorrCheck )
            {
            void * pCache = NdrpAlloca( &pAsyncMsg->ProcContext.AllocateContext, NDR_DEFAULT_CORR_CACHE_SIZE );
            
            NdrCorrelationInitialize( pStubMsg,
                                      pCache,
                                      NDR_DEFAULT_CORR_CACHE_SIZE,
                                      0 /* flags */ );
            }
         }

      // StubPhase set up by invoke is STUB_UNMARSHAL

      RpcTryExcept
      {

         // --------------------------------
         // Unmarshall all of our parameters.
         // --------------------------------

        NdrpServerUnMarshal( pStubMsg );   
                             

      }

      // Last ditch checks.

      if ( pRpcMsg->BufferLength  <
           (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
         {
         RpcRaiseException( RPC_X_BAD_STUB_DATA );
         }


      RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
      {
         ExceptionCode = RpcExceptionCode();
         // Filter set in rpcndr.h to catch one of the following
         //     STATUS_ACCESS_VIOLATION
         //     STATUS_DATATYPE_MISALIGNMENT
         //     RPC_X_BAD_STUB_DATA

         fBadStubDataException = TRUE;

         pAsyncMsg->Flags.BadStubData  = 1;
         pAsyncMsg->Flags.ErrorPending = 1;

         if ( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
            {
            ExceptionCode = RPC_X_BAD_STUB_DATA;
            }
         pAsyncMsg->ErrorCode = ExceptionCode;

         NdrpFreeMemoryList( pStubMsg );
         pAsyncSB->CallState.Flags.BeginError = 1;
         pAsyncSB->CallState.Hr = NdrHrFromWin32Error( ExceptionCode);

         RpcRaiseException( ExceptionCode );

      }
      RpcEndExcept

      //
      // Do [out] initialization before the invoke.
      //
      for ( n = 0; n < NumberParams; n++ )
         {
         if ( Params[n].ParamAttr.IsIn     ||
              Params[n].ParamAttr.IsReturn )
            continue;

         // This is a Begin call, there cannot be any [out] only args.

         RpcRaiseException( RPC_S_INTERNAL_ERROR );
         }


      //
      // OLE interfaces use pdwStubPhase in the exception filter.
      // See CStdStubBuffer_Invoke in stub.c.
      //
      *pdwStubPhase = STUB_CALL_SERVER;

      // We need to catch exception in the manager code separately
      // as the model implies that there will be no other call from
      // the server app to clean up.

      pAsyncSB->CallState.Flags.BeginDone = 1;

      RpcTryExcept
      {
         //
         // Check for a thunk.  Compiler does all the setup for us.
         //
         if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ ProcNum ] )
            {
            fManagerCodeInvoked = TRUE;
            pServerInfo->ThunkTable[ ProcNum ]( pStubMsg );
            }
         else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       ReturnValue;

            pFunc  = (MANAGER_FUNCTION) DispatchTable[ ProcNum ];
            ArgNum = (long)pProcHeader->StackSize  / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && NewOiFlags.HasReturn )
               ArgNum--;

            // Being here means that we can expect results. Note that the user
            // can call RpcCompleteCall from inside of the manager code.

            fManagerCodeInvoked = TRUE;
            ReturnValue = Invoke( pFunc,
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_IA64_)
                                  NewOiFlags.HasExtensions ? ((PNDR_PROC_HEADER_EXTS64)pHeaderExts)->FloatArgMask
                                  : 0,
#endif
                                  ArgNum);

            if ( NewOiFlags.HasReturn )
               {
               // Pass the app's HR from Begin call to the channel.
               (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                            NULL,   // reserved
                                            (HRESULT) ReturnValue);
               }

            // We are discarding the return value as it is not the real one.
            }
      }
      RpcExcept( 1 )
      {
         fErrorInInvoke = TRUE;

         pAsyncMsg->Flags.ErrorPending = 1;
         pAsyncMsg->ErrorCode = RpcExceptionCode();

         pAsyncSB->CallState.Flags.BeginError = 1;
         pAsyncSB->CallState.Hr = NdrHrFromWin32Error( RpcExceptionCode());
      }
      RpcEndExcept

      //  Done with invoking Begin
   }
   RpcFinally
   {
      if ( !fManagerCodeInvoked )
         {
         // Failed without invoking Begin - return an error. Remember the error.

         if ( fBadStubDataException )
            pAsyncMsg->ErrorCode = RPC_X_BAD_STUB_DATA;

         pAsyncSB->CallState.Flags.BeginDone = 1;
         hr = pAsyncSB->CallState.Hr;
         }
      else // fManagerCodeInvoked
         {
         hr = S_OK;

         if ( fErrorInInvoke )
            hr = pAsyncSB->CallState.Hr;
         }
   }
   RpcEndFinally

   return hr;
}



void
NdrpCloneInOutStubArgs(
                      NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg )
/*
    Walk the second stack looking for an in-out argument.
    For each one, find the corresponding in-out atgument from the first stack
    and clone it to the second stack.

    Note, we need to do it only on the server side where we preserver the first
    stack, the dispatch buffer and all the arguments from the first stack. 

    On the client, this is the app's task to supply meaningful in-out arguments
    for the second stack.
*/
{
   REGISTER_TYPE *   pBeginStack  = (REGISTER_TYPE *)pAsyncMsg->BeginStack;
   REGISTER_TYPE *   pFinishStack = (REGISTER_TYPE *)pAsyncMsg->FinishStack;

   PPARAM_DESCRIPTION  BeginParams       = (PPARAM_DESCRIPTION)pAsyncMsg->BeginParams;
   int                 BeginNumberParams = (int)pAsyncMsg->nBeginParams;

   PPARAM_DESCRIPTION  FinishParams       = (PPARAM_DESCRIPTION)pAsyncMsg->FinishParams;
   int                 FinishNumberParams = pAsyncMsg->nFinishParams;

   int FirstIO = 0;
   int n;

   for ( n = 0; n < FinishNumberParams; n++ )
      {
      // Find in-out arg that needs cloning.

      if ( FinishParams[n].ParamAttr.IsIn  &&
           FinishParams[n].ParamAttr.IsOut )
         {
         // Find the first IO on the first stack

         while ( FirstIO < BeginNumberParams )
            {
            if ( BeginParams[ FirstIO ].ParamAttr.IsIn  &&
                 BeginParams[ FirstIO ].ParamAttr.IsOut )
               {
               break;
               }

            FirstIO++;
            }

         if ( BeginNumberParams <= FirstIO )
            RpcRaiseException( RPC_S_INTERNAL_ERROR );

         // Clone it to the second stack

         pFinishStack[ FinishParams[n].StackOffset / sizeof(REGISTER_TYPE) ] =
         pBeginStack[ BeginParams[ FirstIO ].StackOffset / sizeof(REGISTER_TYPE) ];
         FirstIO++;
         }
      }
}


HRESULT
NdrpCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             )
/*++

Routine Description :

    Complete an async call on the server side.

Arguments :

    AsyncHandle  - raw or object handle (if pointer) as appropriate,
    pAsyncMsg    - pointer to async msg structure,
    pReturnValue - from the user to pass back to caller.

Return :

    Status of S_OK.

--*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   PMIDL_SERVER_INFO           pServerInfo;
   PMIDL_STUB_DESC             pStubDesc;      // should be the same
   const SERVER_ROUTINE  *     DispatchTable;  // should be the same
   unsigned long               ProcNum;        // should be 1+

   ushort                      FormatOffset;
   PFORMAT_STRING              pFormat;
   PFORMAT_STRING              pFormatParam;

   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   INTERPRETER_FLAGS           OldOiFlags;     // Finish flags
   INTERPRETER_OPT_FLAGS       NewOiFlags;     // Finish flags
   PPARAM_DESCRIPTION          Params;         // Finish params
   uchar *                     pArgBuffer;     // new stack
   
   // MZ, BUG BUG, Fix after ship
   // ulong *                     pdwStubPhase;
 
   uchar *                     pArg;

   long                        NumberParams;
   long                        n;
   PNDR_DCOM_OI2_PROC_HEADER   pProcHeader;
   PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;

   IUnknown *                  pSrvObj;
   CInterfaceStubVtbl *        pStubVTable;
   void *                      pThis;

   HRESULT                     hr;
   const IID *                 piid;           // should be the same

   BOOL                        fManagerCodeInvoked = FALSE;
   BOOL                        fErrorInInvoke = FALSE;
   RPC_STATUS                  ExceptionCode = 0;
   boolean                     fParamsFreed = FALSE;
   NDR_PROC_CONTEXT *          pContext = NULL;

   // We validated both the stub and the async context in the signal call.

   // We validated the pAsyncSB in the Signal call.
   // Do additional checks.

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncSB->CallState.pAsyncMsg;
   pThis     = pAsyncMsg->pThis;

   // See if channel calls on the right stub
   if ( & pAsyncSB->lpVtbl != pThis)
      return E_INVALIDARG;


   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   // We have preserved the sync proc num that the channel used.
   // We need only async proc num at the engine level.
   //

   ProcNum = pRpcMsg->ProcNum;
   ProcNum = 2 * ProcNum - 3 + 1;  // Finish method #

   pSrvObj = (IUnknown *)((CStdStubBuffer *)pThis)->pvServerObject;
   DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

   pStubVTable = (CInterfaceStubVtbl *)
                 (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

   piid        = pStubVTable->header.piid;
   pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

   pStubDesc    = pServerInfo->pStubDesc;
   FormatOffset = pServerInfo->FmtStringOffset[ ProcNum ];
   pFormat   = &((pServerInfo->ProcString)[ FormatOffset ]);

   // The proc header has a fixed layout now.

   pProcHeader = (PNDR_DCOM_OI2_PROC_HEADER) pFormat;

   // Validate and setup for finish.

   hr = NdrpSetupFinishStubCall( pAsyncSB,
                                 pProcHeader->StackSize,
                                 *piid );
   if ( hr )
      return hr;

   // The arg buffer is zeroed out already. Note, this is the second stack.

   pContext = &pAsyncMsg->ProcContext;
   pArgBuffer = pContext->StartofStack;
   pStubMsg->StackTop = pArgBuffer;
   
   //
   // Get new interpreter info.
   //
   OldOiFlags   = pProcHeader->OldOiFlags;
   NewOiFlags   = pProcHeader->Oi2Flags;
   NumberParams = pProcHeader->NumberParams;

   Params = (PPARAM_DESCRIPTION)(pFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

   if ( NewOiFlags.HasExtensions )
      {
      pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
      Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
      }

   pAsyncMsg->nFinishParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->FinishParams = pContext->Params = Params;
   pContext->DceTypeFormatString = pStubDesc->pFormatTypes;
   pStubMsg->pContext = pContext;

   // Wrap the unmarshalling, mgr call and marshalling in the try block of
   // a try-finally. Put the free phase in the associated finally block.
   //
   RpcTryFinally
   {
      if ( pAsyncMsg->Flags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // Initialize the args of the new stack.

      // OLE: put pThis in first dword of stack.
      //
      ((void **)pArgBuffer)[0] = ((CStdStubBuffer *)pThis)->pvServerObject;

      //
      // Do [out] initialization before invoking Finish
      //

      NdrpCloneInOutStubArgs( pAsyncMsg );
      NdrpServerOutInit( pStubMsg );


      //
      // OLE interfaces use pdwStubPhase in the exception filter.
      // See CStdStubBuffer_Invoke in stub.c.
      //

      // MZ, BUG BUG, fix after ship
      // *pdwStubPhase = STUB_CALL_SERVER;

      // We need to catch exception in the manager code separately
      // as the model implies that there will be no other call from
      // the server app to clean up.

      RpcTryExcept
      {
         //
         // Check for a thunk.  Compiler does all the setup for us.
         //
         if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            fManagerCodeInvoked = TRUE;
            pServerInfo->ThunkTable[ProcNum]( pStubMsg );
            }
         else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       ReturnValue;

            pFunc  = (MANAGER_FUNCTION) DispatchTable[ProcNum];
            ArgNum = (long)pProcHeader->StackSize / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && NewOiFlags.HasReturn )
               ArgNum--;

            fManagerCodeInvoked = TRUE;
            ReturnValue = Invoke( pFunc,
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_IA64_)
                                  NewOiFlags.HasExtensions ? ((PNDR_PROC_HEADER_EXTS64)pHeaderExts)->FloatArgMask
                                  : 0,
#endif
                                  ArgNum);

            // This is the return value that should be marshaled back.
            if ( NewOiFlags.HasReturn )
               {
               ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = ReturnValue;
               // Pass the app's HR to the channel.
               (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                            NULL,   // reserved
                                            (HRESULT) ReturnValue);
               }
            }
      }
      RpcExcept( 1 )
      {
         pAsyncMsg->Flags.ErrorPending = 1;

         pAsyncMsg->ErrorCode = RpcExceptionCode();
         fErrorInInvoke = TRUE;
      }
      RpcEndExcept

      //  Done with invoking Finish

      if ( pAsyncMsg->Flags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      //
      // Buffer size pass.
      //
      pStubMsg->BufferLength = pProcHeader->ServerBufferSize;

      if ( NewOiFlags.ServerMustSize )
         {
         NdrpSizing( pStubMsg, 
                     FALSE );       // IsClient
         }

      // Get buffer.

      NdrStubGetBuffer( (IRpcStubBuffer*)pAsyncMsg->pThis,
                        pStubMsg->pRpcChannelBuffer,
                        pStubMsg );

      //
      // Marshall pass.
      //
      NdrpServerMarshal( pStubMsg, 
                         TRUE );    // IsObject
                         

      if ( pRpcMsg->BufferLength <
           (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
         {
         NDR_ASSERT( 0, "NdrStubCall2 marshal: buffer overflow!" );
         RpcRaiseException( RPC_X_BAD_STUB_DATA );
         }

      pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

      // We don't drop to the runtime like for synchronous calls,
      // we send the last buffer explicitly.

      fParamsFreed = TRUE;
      // see comment on async.cxx on why we call this twice.

      NdrpAsyncDCOMFreeParams( pAsyncMsg );

      NdrpDcomAsyncSend( pStubMsg,
                         0 );  // server doesn't pass pSynchronize back to channel.
   }
   RpcFinally
   {
      // Don't free parameters if we died because of bad stub data in unmarshaling.

      if ( ! pAsyncMsg->Flags.BadStubData && !fParamsFreed)
         {

         NdrpAsyncDCOMFreeParams( pAsyncMsg );

         }

      if ( pAsyncMsg->Flags.ErrorPending )
         hr = NdrHrFromWin32Error( pAsyncMsg->ErrorCode );
      else
         hr = S_OK;

      // If we are here, error or not, it means that we can (and need to) dispose of
      // the async context information

      NdrpAsyncStubMsgDestructor( pAsyncSB );

      // The engine never addrefs or releases the call object.
   }
   RpcEndFinally

   return hr;
}


HRESULT
NdrpAsyncProxyMsgConstructor(
                            CStdAsyncProxyBuffer * pAsyncPB )
{
   NdrDcomAsyncCallState * pCallState = & pAsyncPB->CallState;

   pCallState->Lock = 0;
   pCallState->Signature = NDR_ASYNC_PROXY_SIGNATURE;
   pCallState->pAsyncMsg = 0;
   *((long*)&pCallState->Flags) = 0;
   pCallState->Hr = 0;

   return S_OK;
}

HRESULT
NdrpAsyncStubMsgConstructor(
                           CStdAsyncStubBuffer * pAsyncSB )
{
   NdrDcomAsyncCallState * pCallState = & pAsyncSB->CallState;

   pCallState->Lock = 0;
   pCallState->Signature = NDR_ASYNC_STUB_SIGNATURE;
   pCallState->pAsyncMsg = 0;
   *((long*)&pCallState->Flags) = 0;
   pCallState->Hr = 0;

   return S_OK;
}


HRESULT
NdrpAsyncProxyMsgDestructor(
                           CStdAsyncProxyBuffer * pAsyncPB )
{
   NdrDcomAsyncCallState * pCallState = & pAsyncPB->CallState;

   if ( pCallState->pAsyncMsg )
      {
      NdrpFreeDcomAsyncMsg( (PNDR_DCOM_ASYNC_MESSAGE)pCallState->pAsyncMsg );
      pCallState->pAsyncMsg = 0;
      }
   *((long*)&pCallState->Flags) = 0;
   pCallState->Hr = 0;

   return S_OK;
}

HRESULT
NdrpAsyncStubMsgDestructor(
                          CStdAsyncStubBuffer * pAsyncSB )
{
   NdrDcomAsyncCallState * pCallState = & pAsyncSB->CallState;

   if ( pCallState->pAsyncMsg )
      {
      NdrpFreeDcomAsyncMsg( (PNDR_DCOM_ASYNC_MESSAGE)pCallState->pAsyncMsg );
      pCallState->pAsyncMsg = 0;
      }
   *((long*)&pCallState->Flags) = 0;
   pCallState->Hr = 0;

   return S_OK;
}


HRESULT
NdrpValidateAsyncProxyCall(
                          CStdAsyncProxyBuffer *  pAsyncPB
                          )
{
   HRESULT  hr = S_OK;

   RpcTryExcept
   {
      NdrDcomAsyncCallState * pCallState = & pAsyncPB->CallState;

      if ( pCallState->Signature != NDR_ASYNC_PROXY_SIGNATURE )
         hr = E_INVALIDARG;
   }
   RpcExcept(1)
   {
      hr = E_INVALIDARG;
   }
   RpcEndExcept;

   return hr;
}

HRESULT
NdrpValidateAsyncStubCall(
                         CStdAsyncStubBuffer *  pAsyncSB
                         )
{
   HRESULT  hr = S_OK;

   RpcTryExcept
   {
      NdrDcomAsyncCallState * pCallState = & pAsyncSB->CallState;

      if ( pCallState->Signature != NDR_ASYNC_STUB_SIGNATURE )
         hr = E_INVALIDARG;
   }
   RpcExcept(1)
   {
      hr = E_INVALIDARG;
   }
   RpcEndExcept;

   return hr;
}

HRESULT
NdrpValidateDcomAsyncMsg(
                        PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg )
{
   HRESULT  hr = RPC_S_OK;

   RpcTryExcept
   {
      if ( pAsyncMsg->Signature != NDR_DCOM_ASYNC_SIGNATURE ||
           pAsyncMsg->Version   != NDR_DCOM_ASYNC_VERSION )
         {
         hr = E_INVALIDARG;
         }
   }
   RpcExcept(1)
   {
      hr = E_INVALIDARG;
   }
   RpcEndExcept;

   return hr;
}


HRESULT
NdrpSetupBeginClientCall(
                        CStdAsyncProxyBuffer *  pAsyncPB,
                        void *                  StartofStack,
                        unsigned short          StackSize,
                        REFIID                  riid )
/*
    This method creates and initializes async msg.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;
   HRESULT                     hr = S_OK;

   hr = NdrpValidateAsyncProxyCall( pAsyncPB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( pAsyncPB->CallState.pAsyncMsg != 0  ||
        pAsyncPB->CallState.Flags.BeginStarted )
      return E_FAIL;

   // Do this first to simplify error conditions.

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)
               I_RpcBCacheAllocate( sizeof(NDR_DCOM_ASYNC_MESSAGE) +
                                    StackSize + NDR_ASYNC_GUARD_SIZE );
   if ( ! pAsyncMsg )
      {
      NdrpAsyncProxySignal( pAsyncPB );
      return E_OUTOFMEMORY;
      }

   // Initialize the async message properly

   MIDL_memset( pAsyncMsg, 0x0, sizeof( NDR_DCOM_ASYNC_MESSAGE) );

   pAsyncMsg->Signature = NDR_DCOM_ASYNC_SIGNATURE;
   pAsyncMsg->Version   = NDR_DCOM_ASYNC_VERSION;
   pAsyncMsg->SyntaxType = XFER_SYNTAX_DCE;

   pAsyncMsg->ProcContext.StartofStack = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStack   = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStackSize = StackSize;
   pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

   NdrpAllocaInit( &pAsyncMsg->ProcContext.AllocateContext );

   // Client: copy stack from the app's request call.
   RpcpMemoryCopy( & pAsyncMsg->AppStack, StartofStack, StackSize );

   MIDL_memset( ((char *)& pAsyncMsg->AppStack) + StackSize,
                0x71,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncMsg->pAsyncPB = pAsyncPB;
   pAsyncPB->CallState.Flags.BeginStarted = 1;
   pAsyncPB->CallState.pAsyncMsg          = pAsyncMsg;

   return S_OK;
}


HRESULT
NdrpSetupFinishClientCall(
                         CStdAsyncProxyBuffer *  pAsyncPB,
                         void *                  StartofStack,
                         unsigned short          StackSize,
                         REFIID                  riid,
                         unsigned long           FinishProcNum )
/*
    This method creates and initializes async msg.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg;
   HRESULT                  hr = S_OK;

   hr = NdrpValidateAsyncProxyCall( pAsyncPB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( !pAsyncPB->CallState.Flags.BeginStarted  ||
        !pAsyncPB->CallState.Flags.BeginDone     ||
        pAsyncPB->CallState.Flags.FinishStarted )
      return E_FAIL;

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncPB->CallState.pAsyncMsg;

   hr = NdrpValidateDcomAsyncMsg( pAsyncMsg );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( (FinishProcNum + 3)/2  != (pAsyncMsg->RpcMsg.ProcNum & 0x7fff) )
      return E_FAIL;

   // Initialize the async message properly

   pAsyncMsg->ProcContext.StartofStack = (uchar *) StartofStack;
   pAsyncMsg->FinishStack  = (uchar *) StartofStack;
   pAsyncMsg->FinishStackSize = StackSize;
   pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

   // Dont allocate or copy the new stack anywhere.

   pAsyncPB->CallState.Flags.FinishStarted = 1;

   return S_OK;
}


HRESULT
NdrpSetupBeginStubCall(
                      CStdAsyncStubBuffer *   pAsyncSB,
                      unsigned short          StackSize,
                      REFIID                  riid )
/*
    This method creates and initializes async msg.

*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;
   HRESULT                     hr = S_OK;

   hr = NdrpValidateAsyncStubCall( pAsyncSB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( pAsyncSB->CallState.pAsyncMsg != 0  ||
        pAsyncSB->CallState.Flags.BeginStarted )
      hr = E_FAIL;
   else
      {
      pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)
                  I_RpcBCacheAllocate( sizeof( NDR_DCOM_ASYNC_MESSAGE) +
                                       StackSize + NDR_ASYNC_GUARD_SIZE );
      if ( ! pAsyncMsg )
         hr = E_OUTOFMEMORY;
      }

   if ( ! SUCCEEDED(hr) )
      {
      // The stub never signals.

      pAsyncSB->CallState.Flags.BeginError = 1;
      pAsyncSB->CallState.Hr = hr;
      return hr;
      }

   // Initialize the async message properly

   MIDL_memset( pAsyncMsg, 0x0, sizeof( NDR_DCOM_ASYNC_MESSAGE) );

   pAsyncMsg->Signature = NDR_DCOM_ASYNC_SIGNATURE;
   pAsyncMsg->Version   = NDR_DCOM_ASYNC_VERSION;
   pAsyncMsg->SyntaxType = XFER_SYNTAX_DCE;

   pAsyncMsg->ProcContext.StartofStack = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStack   = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStackSize = StackSize;
   pAsyncMsg->StubPhase    = STUB_UNMARSHAL;
   pAsyncMsg->StubMsg.pContext = &pAsyncMsg->ProcContext;

   NdrpAllocaInit( &pAsyncMsg->ProcContext.AllocateContext );

   // Server: zero out stack for allocs.
   MIDL_memset( & pAsyncMsg->AppStack, 0x0, StackSize );

   MIDL_memset( ((char *)& pAsyncMsg->AppStack) + StackSize,
                0x71,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncSB->CallState.pAsyncMsg = pAsyncMsg;
   pAsyncSB->CallState.Flags.BeginStarted = 1;
   pAsyncMsg->pAsyncSB = pAsyncSB;

   return S_OK;
}


HRESULT
NdrpSetupFinishStubCall(
                       CStdAsyncStubBuffer *   pAsyncSB,
                       unsigned short          StackSize,
                       REFIID                  riid )
/*
    This method creates and initializes async msg.

*/
{
   PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg;
   uchar *                  pFinishStack;
   HRESULT                     hr = S_OK;

   hr = NdrpValidateAsyncStubCall( pAsyncSB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( !pAsyncSB->CallState.Flags.BeginStarted  ||
        !pAsyncSB->CallState.Flags.BeginDone     ||
        pAsyncSB->CallState.Flags.FinishStarted )
      return E_FAIL;

   if ( pAsyncSB->CallState.Hr != 0 )
      return pAsyncSB->CallState.Hr;

   pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE)pAsyncSB->CallState.pAsyncMsg;

   hr = NdrpValidateDcomAsyncMsg( pAsyncMsg );
   if ( ! SUCCEEDED(hr) )
      return hr;

   // We need to create the second stack for the app invoke.
   // Do this first to simplify error conditions.

   RpcTryExcept 
   {
      pFinishStack = (uchar*) AsyncAlloca( pAsyncMsg, 
                                           StackSize + NDR_ASYNC_GUARD_SIZE );
   }
   RpcExcept( 1 )
   {
      NdrpAsyncStubMsgDestructor( pAsyncSB );
      return E_OUTOFMEMORY;
   }
   RpcEndExcept

   // Initialize the async message properly

   pAsyncMsg->ProcContext.StartofStack = (uchar *) pFinishStack;
   pAsyncMsg->FinishStack  = (uchar *) pFinishStack;
   pAsyncMsg->FinishStackSize    = StackSize;
   pAsyncMsg->StubMsg.pContext = &pAsyncMsg->ProcContext;

   // Server: zero out stack for allocs.
   MIDL_memset( pFinishStack, 0x0, StackSize );

   MIDL_memset( (char *)pFinishStack + StackSize,
                0x72,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncSB->CallState.Flags.FinishStarted = 1;

   return S_OK;
}


HRESULT
NdrpAsyncProxySignal(
                    CStdAsyncProxyBuffer *  pAsyncPB )
{
   ISynchronize *  pSynchronize;
   HRESULT         hr;
   IUnknown *      punkOuter = pAsyncPB->punkOuter;

   hr = punkOuter->lpVtbl->QueryInterface( punkOuter,
                                           IID_ISynchronize,
                                           (void**)&pSynchronize );

   if ( SUCCEEDED(hr) )
      {
      pSynchronize->lpVtbl->Signal( pSynchronize );
      pSynchronize->lpVtbl->Release( pSynchronize );
      }

   return hr;
}



_inline
HRESULT
NdrpCallStateLock(
                 NdrDcomAsyncCallState *  pCallState )
{
   if ( 0 != InterlockedCompareExchange( (long*)& pCallState->Lock, 1, 0 ) )
      {
      return E_FAIL;
      }

   return RPC_S_OK;
}

_inline
void
NdrpCallStateUnlock(
                   NdrDcomAsyncCallState *  pCallState )
{
   InterlockedDecrement( (long*)& pCallState->Lock );
   return;
}


HRESULT
NdrpAsyncProxyLock(
                  CStdAsyncProxyBuffer *  pAsyncPB )
{
   return NdrpCallStateLock( & pAsyncPB->CallState );
}


void
NdrpAsyncProxyUnlock(
                    CStdAsyncProxyBuffer *  pAsyncPB )
{
   NdrpCallStateUnlock( & pAsyncPB->CallState );
}

HRESULT
NdrpAsyncStubLock(
                 CStdAsyncStubBuffer *  pAsyncSB )
{
   return NdrpCallStateLock( & pAsyncSB->CallState );
}

void
NdrpAsyncStubUnlock(
                   CStdAsyncStubBuffer *  pAsyncSB )
{
   NdrpCallStateUnlock( & pAsyncSB->CallState );
}



void
NdrpFreeDcomAsyncMsg(
                    PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg )
/*
    This routine would free the AsyncMsg but not the AsyncHandle, as on the server
    the user may need it and on the client it is user's to begin with.
*/
{
   if ( pAsyncMsg )
      {
      PMIDL_STUB_MESSAGE  pStubMsg  = & pAsyncMsg->StubMsg;

      NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

      // in NDR64, we are using allocacontext to hold corr info, so we don't
      // want to free it there.
      if ( pAsyncMsg->SyntaxType == XFER_SYNTAX_DCE )
         NdrCorrelationFree( pStubMsg );

      // Free the RPC buffer.

      if ( pStubMsg->IsClient )
         {
         if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
            {
            void * pThis = *(void **)pAsyncMsg->ProcContext.StartofStack;

            NdrProxyFreeBuffer( pThis, pStubMsg );
            }
         }

      NdrpAllocaDestroy( &pAsyncMsg->ProcContext.AllocateContext );

      // Prevent reusing of a handle that has been freed;
      pAsyncMsg->Signature = NDR_FREED_ASYNC_SIGNATURE;

      I_RpcBCacheFree( pAsyncMsg );

      }
}


BOOL
NdrpDcomAsyncSend(
                 PMIDL_STUB_MESSAGE  pStubMsg,
                 ISynchronize *      pSynchronize )
/*
    Call the channel to send.
    On the client, pass the app's pSynchronize to it, such that channel can signal
    the app.
    On the server, pass NULL instead of a pSynchronize.

*/
{
   PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;
   HRESULT         hr = S_OK;
   RPC_STATUS      Status = RPC_S_OK;
   BOOL            fSendCalled = FALSE;

   pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

   if ( pStubMsg->pRpcChannelBuffer )
      {
      IAsyncRpcChannelBuffer * pAsChannel;
      IRpcChannelBuffer *      pChannel = (IRpcChannelBuffer *)
                                          pStubMsg->pRpcChannelBuffer;

      hr = pChannel->lpVtbl->QueryInterface( pChannel,
                                             IID_IAsyncRpcChannelBuffer,
                                             (void**)& pAsChannel );
      if ( SUCCEEDED(hr) )
         {
         fSendCalled = TRUE;
         hr = pAsChannel->lpVtbl->Send( pAsChannel,
                                        (RPCOLEMESSAGE *)pRpcMsg,
                                        pSynchronize,
                                        (ulong*)& Status );

         pAsChannel->lpVtbl->Release( pAsChannel );

         // The channel never returns this code now for new async.
         NDR_ASSERT( Status != RPC_S_SEND_INCOMPLETE, "Unexpected channel error" );
         }
      }
   else
      hr = E_NOINTERFACE;

// Alex:
   if ( SUCCEEDED(hr)  &&  Status == RPC_S_OK )
      pStubMsg->fBufferValid = TRUE;
   else
      RpcRaiseException( Status );

   return fSendCalled;
}


BOOL
NdrpDcomAsyncClientSend(
                       PMIDL_STUB_MESSAGE  pStubMsg,
                       IUnknown *          punkOuter )
/*
    Call the channel to send.
    On the client pass app's pSynchronize to it, such that channel can signal
    the app.
    On the server pass NULL instead of a pSynchronize.

*/
{
   PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;
   HRESULT         hr = S_OK;
   BOOL            fSendCalled = FALSE;

   ISynchronize * pSynchronize = 0;

   // Channel needs somebody to signal to, this will be the app.

   hr = punkOuter->lpVtbl->QueryInterface( punkOuter,
                                           IID_ISynchronize,
                                           (void**) &pSynchronize );
   if ( SUCCEEDED(hr) )
      fSendCalled = NdrpDcomAsyncSend( pStubMsg, pSynchronize );

   if ( pSynchronize )
      pSynchronize->lpVtbl->Release( pSynchronize );

   return fSendCalled;
}


void
NdrDcomAsyncReceive(
                   PMIDL_STUB_MESSAGE  pStubMsg )
{
   PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;
   RPC_STATUS      Status = RPC_S_OK;
   HRESULT         hr;

   pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;
   pRpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;

   // A complete call.

   if ( pStubMsg->pRpcChannelBuffer )
      {
      IAsyncRpcChannelBuffer * pAsyncChannel = (IAsyncRpcChannelBuffer *)
                                               pStubMsg->pRpcChannelBuffer;

      hr = pAsyncChannel->lpVtbl->Receive( pAsyncChannel,
                                           (PRPCOLEMESSAGE) pRpcMsg,
                                           (unsigned long *)&Status );
      }

   if ( Status )
      {
      // No pending, the call would have blocked, real bug happened.

      if ( pStubMsg->pAsyncMsg )
         ((PNDR_DCOM_ASYNC_MESSAGE)pStubMsg->pAsyncMsg)->Flags.RuntimeCleanedUp = 1;

      RpcRaiseException(Status);
      }
   else
      {
      pStubMsg->Buffer = (uchar*) pRpcMsg->Buffer;

      pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
      pStubMsg->BufferEnd   = (uchar*)pRpcMsg->Buffer + pRpcMsg->BufferLength;
      pStubMsg->fBufferValid = TRUE;
      }
}

HRESULT
Ndr64pCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             );

HRESULT
NdrpAsyncStubSignal(
                   CStdAsyncStubBuffer * pAsyncSB )
/*
    Signal on the async stub object:
    The channel signals that the Finish call should be executed.

    See if the stub object is active (or find one that is).
    If the stub object is not active then the call fails.
*/
{
   HRESULT hr = S_OK;
   BOOL    fFoundActiveCall = FALSE;

   while ( SUCCEEDED(hr)  &&  ! fFoundActiveCall )
      {
      hr = NdrpValidateAsyncStubCall( pAsyncSB );
      if ( SUCCEEDED(hr) )
         {
         if ( pAsyncSB->CallState.Flags.BeginStarted )
            {
            fFoundActiveCall = TRUE;
            }
         else
            {
            // Switch to the base interface call object. In case of
            // delegation one of the base interface objects would be active.

            IRpcStubBuffer * pBaseStubBuffer = pAsyncSB->pBaseStubBuffer;

            if ( pBaseStubBuffer )
               {
               pAsyncSB = (CStdAsyncStubBuffer *) ((uchar *)pBaseStubBuffer
                                                   - offsetof(CStdAsyncStubBuffer,lpVtbl));
               }
            else
               {
               // None of the stubs active and a signal came.
               hr = E_FAIL;
               }
            }
         }
      }

   if ( SUCCEEDED(hr) )
      {
      PNDR_DCOM_ASYNC_MESSAGE   pAsyncMsg = 
          (PNDR_DCOM_ASYNC_MESSAGE)pAsyncSB->CallState.pAsyncMsg;
      hr = NdrpValidateDcomAsyncMsg( pAsyncMsg );
      if ( SUCCEEDED(hr) )
         {
#if defined(BUILD_NDR64)
         if ( pAsyncMsg->SyntaxType == XFER_SYNTAX_DCE )
             hr = NdrpCompleteDcomAsyncStubCall( pAsyncSB );
         else
             hr = Ndr64pCompleteDcomAsyncStubCall( pAsyncSB );
#else
         hr = NdrpCompleteDcomAsyncStubCall( pAsyncSB );
#endif
         }
      }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\midl\typelib\typelib.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       typelib.cxx
//
//  Contents:   Run-time linking support for OLEAUT32.DLL
//
//  Functions:  TLError
//              TLUnintialize
//              InitOleOnce
//              LoadOleAut32Once
//              LateBound_SysFreeString
//              LateBound_LHashValOfNameSysA
//              LateBound_LHashValOfNameSys
//              LateBound_LoadTypeLib
//              LateBound_QueryPathOfRegTypeLib
//              LateBound_RegisterTypeLib
//              LateBound_DeregisterTypeLib
//              LateBound_CreateTypeLib
//
//  History:    4-10-95   stevebl   Created
//
//----------------------------------------------------------------------------

#pragma warning ( disable : 4514 )

#include "tlcommon.hxx"
#include "typelib.hxx"
#include <stdio.h>
#include "errors.hxx"
#include "tlgen.hxx"
#include "ndrtypes.h"

extern "C" BOOL Is64BitEnv();

// Uncomment the following #define to remove the OleInitialize and
// OleUninitialize calls from the code.
//
// Experimentation has proven that it really isn't necessary to initialize
// OLE before using the type library creation functions in OleAut32.DLL;
// however, I have been told that it is not safe.  Therefore, I will go
// ahead and leave in the calls to OleInitialize etc.
//
// This mechanism is left in place to allow for further experimentation.
//
//#define NO_OLE_INITIALIZE

#ifndef NO_OLE_INITIALIZE
static BOOL fOleInitialized = FALSE;

HINSTANCE hInstOle = NULL;
#endif // NO_OLE_INITIALIZE

//+---------------------------------------------------------------------------
//
//  Function:   TLError
//
//  Synopsis:   Generic error reporting mechanism.
//              Reports error and exits.
//
//  Arguments:  [err]     - error code (see notes)
//              [sz]      - descriptive string (generally the DLL or API name)
//              [errInfo] - further error information
//                          (generally an extended error code retrieved by
//                          GetLastError())
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      Any of the error codes in errors.hxx are potentially legal but
//              the only codes really expected here are: ERR_BIND, ERR_INIT
//              and ERR_LOAD.
//
//              If the SHOW_ERROR_CODES macro is defined, then the errInfo
//              value is appended to the end of the input string.  Otherwise,
//              errInfo is ignored.  This is intended to be used for debugging
//              purposes.
//
//              It is assumed that the length of the input string will not
//              exceed 100 characters (minus the number of characters needed
//              for the string representation of the errInfo value).  Since
//              this is a local function, this is a safe assumption.
//
//----------------------------------------------------------------------------

void TLError(STATUS_T err, char * sz, DWORD )
{
#ifdef SHOW_ERROR_CODES
    char szBuffer[100];
    sprintf(szBuffer, "%s (0x%X)", sz, errInfo);
    RpcError(NULL, 0, err, szBuffer);
#else
    RpcError(NULL, 0, err, sz);
#endif
    exit(err);
}

#ifndef NO_OLE_INITIALIZE
typedef HRESULT (STDAPICALLTYPE * LPOLEINITIALIZE)(LPVOID);
typedef void (STDAPICALLTYPE * LPOLEUNINITIALIZE)(void);
#endif // NO_OLE_INITIALIE

//+---------------------------------------------------------------------------
//
//  Function:   TLUninitialize
//
//  Synopsis:   general function for unintializing anything to do with type
//              library generation
//
//  Returns:    FALSE - success
//
//  Modifies:   fOleInitialized
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      Uninitializes OLE
//
//----------------------------------------------------------------------------

int __cdecl TLUninitialize(void)
{
#ifndef NO_OLE_INITIALIZE
    if (fOleInitialized)
        {
            LPOLEUNINITIALIZE pFunc = (LPOLEUNINITIALIZE) GetProcAddress(hInstOle, "OleUninitialize");
            if (NULL == pFunc )
                {
                TLError(ERR_BIND, "OleUninitialize", GetLastError());
                }
            pFunc();
            fOleInitialized = FALSE;
        }

    return fOleInitialized;
#else
    return FALSE;
#endif // NO_OLE_INITIALIZE
}

#ifndef NO_OLE_INITIALIZE
//+---------------------------------------------------------------------------
//
//  Function:   InitOleOnce
//
//  Synopsis:   Makes sure that OLE gets initialized once and only once.
//
//  Modifies:   fOleInitialized, hInstOle
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      OleInitialize is called by dynamically linking to the
//              procedure in OLE32.DLL.  This ensures that MIDL doesn't
//              perform the expensive operations of loading OLE32.DLL and
//              initializing OLE unless it absolutely has to (there is a
//              library statement in the input file).
//
//----------------------------------------------------------------------------

void InitOleOnce(void)
{
    if (!fOleInitialized)
    {
        hInstOle = LoadLibrary("ole32.dll");
        if (NULL == hInstOle)
        {
            TLError(ERR_LOAD, "ole32.dll", GetLastError());
        }
        LPOLEINITIALIZE pFunc = (LPOLEINITIALIZE) GetProcAddress(hInstOle, "OleInitialize");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "OleInitialize", GetLastError());
        }
        HRESULT hr = pFunc(NULL);
        if (FAILED(hr))
        {
            TLError(ERR_INIT, "", hr);
        }
        fOleInitialized = TRUE;
    }
}
#endif // NO_OLE_INITIALIZE

//+---------------------------------------------------------------------------
//
//  Function:   LoadOleAut32Once
//
//  Synopsis:   Makes sure that oleaut32.dll gets loaded once and only once
//
//  Returns:    pointer to the HINSTANCE for oleaut32.dll
//
//  History:    6-14-95   stevebl   Commented
//
//  Notes:      Returning the HINSTANCE enables dynamic binding to functions
//              within oleaut32.dll.
//
//----------------------------------------------------------------------------

HINSTANCE LoadOleAut32Once(void)
{
    static HINSTANCE hInst = NULL;
    if (NULL == hInst)
    {
#ifndef NO_OLE_INITIALIZE
        InitOleOnce();
#endif // NO_OLE_INITIALIZE
        hInst = LoadLibrary("oleaut32.dll");
        if (NULL == hInst)
        {
            TLError(ERR_LOAD, "oleaut32.dll", GetLastError());
        }
    }
    return(hInst);
}

BOOL fNewTypeLibChecked = FALSE;
BOOL fNewTypeLib = FALSE;

typedef HRESULT (STDAPICALLTYPE * LPFNCREATETYPELIB)(SYSKIND, const OLECHAR FAR *, ICreateTypeLib FAR * FAR *);

//+---------------------------------------------------------------------------
//
//  Function:   BindToCreateTypeLib
//
//  Synopsis:   Binds to CreateTypeLib2 or CreateTypeLib as appropriate.
//
//  Returns:    pointer to the appropriate CreateTypeLib function
//
//  Notes:      This will actually first attempt to bind to CreateTypeLib2 
//              if the user does not specify that he wants to create old type 
//              libraries.
//
//              We can get away with mapping CreateTypeLib2 to CreateTypeLib
//              because, with the exception of the ICreateTypeLib2 pointer,
//              they have the same signiture.  
//
//              This scheme will prevent us from using any of the extended
//              methods provided by ICreateTypeLib2 (unless we explicitly 
//              cast the interface pointer) but that's OK because we don't
//              need any of those functions, we simply want to make sure
//              that the new type library format is used where appropriate.
//
//              If the user explicitly requests new type libraries on a system
//              that doesn't support it, this routine generates the error
//              message.  
//
//              If the user does not explicitly request one version over the
//              other, this routine binds to the latest supported version.
//
//  History:    1-11-96    stevebl   Created
//
//----------------------------------------------------------------------------

LPFNCREATETYPELIB BindToCreateTypeLib(void)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPFNCREATETYPELIB pFunc = NULL;
    // we don't need to go through the check again if it's initialized already.
    if (NULL != pFunc)
        return pFunc;
        
    if ( !FOldTlbSwitch() )   
    // If the user hasn't specifically requested old type lib support
    {
        pFunc = (LPFNCREATETYPELIB) GetProcAddress(hInst, "CreateTypeLib2");
    }
    if (NULL == pFunc)
    {
        // If the user has specifically requested new type lib support
        if ( FNewTlbSwitch() )
        {
            TLError(ERR_BIND, "CreateTypeLib2", GetLastError());
        }
        pFunc = (LPFNCREATETYPELIB) GetProcAddress(hInst, "CreateTypeLib");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "CreateTypeLib", GetLastError());
        }
        else
        {
            fNewTypeLib = FALSE;
            fNewTypeLibChecked = TRUE;
        }
    }
    else
    {
        fNewTypeLib = TRUE;
        fNewTypeLibChecked = TRUE;
    }
    return pFunc;
}

//+---------------------------------------------------------------------------
//
//  Function:   FNewTypeLib
//
//  Synopsis:   Detects if the new type library support is available to MIDL.
//              For the new support to be available, two things must be
//              satisfied: the new oleaut32.dll must be installed in the
//              user's machine, and the user must not have specifically
//              requested the old type library support via the -old option.
//
//  Returns:    TRUE  - new type lib support available
//              FALSE - new type lib support not available
//
//  History:    1-11-96    stevebl   Created
//
//----------------------------------------------------------------------------
BOOL FNewTypeLib(void)
{
    if (!fNewTypeLibChecked)
    {
        // force a bind to CreateTypeLib or CreateTypeLib2
        BindToCreateTypeLib();
    }
    return fNewTypeLib;
}

//+---------------------------------------------------------------------------
//
//  Function:   LateBound_<Function Name>
//
//  Synopsis:   Each of these functions performs the same function as its
//              namesake.
//
//              The difference is that these functions are dynamically bound.
//              They cause the DLL to be loaded when the first one of them
//              is called, and they bind to the appropriate code upon demand.
//
//              This ensures that MIDL only loads OLEAUT32.DLL when the
//              input stream needs to generate type information.
//
//  History:    6-14-95   stevebl   Commented
//
//----------------------------------------------------------------------------

typedef BSTR (STDAPICALLTYPE * LPSYSALLOCSTRING) (OLECHAR FAR *);

BSTR LateBound_SysAllocString(OLECHAR FAR * sz)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPSYSALLOCSTRING pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPSYSALLOCSTRING) GetProcAddress(hInst, "SysAllocString");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "SysAllocString", GetLastError());
        }
    }
    return(pFunc(sz));
}

typedef void (STDAPICALLTYPE * LPSYSFREESTRING) (BSTR);

void LateBound_SysFreeString(BSTR bstr)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPSYSFREESTRING pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPSYSFREESTRING) GetProcAddress(hInst, "SysFreeString");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "SysFreeString", GetLastError());
        }
    }
    pFunc(bstr);
}

typedef HRESULT (STDAPICALLTYPE * LPVARIANTCHANGETYPEEX) (VARIANTARG FAR * , VARIANTARG FAR *, LCID, unsigned short, VARTYPE);

HRESULT LateBound_VariantChangeTypeEx(
    VARIANTARG FAR * pvargDest, 
    VARIANTARG FAR * pvargSrc, 
    LCID lcid,
    unsigned short wFlags,
    VARTYPE vtNew)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPVARIANTCHANGETYPEEX pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPVARIANTCHANGETYPEEX) GetProcAddress(hInst, "VariantChangeTypeEx");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "VariantChangeTypeEx", GetLastError());
        }
    }
    return(pFunc(pvargDest, pvargSrc, lcid, wFlags, vtNew));
}

typedef ULONG (STDAPICALLTYPE * LPHASHVALOFNAMESYSA)(SYSKIND, LCID, const char FAR *);

ULONG LateBound_LHashValOfNameSysA(SYSKIND syskind, LCID lcid, const char FAR* szName)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPHASHVALOFNAMESYSA pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPHASHVALOFNAMESYSA) GetProcAddress(hInst, "LHashValOfNameSysA");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "LHashValOfNameSysA", GetLastError());
        }
    }
    return(pFunc(syskind, lcid, szName));
}

typedef ULONG (STDAPICALLTYPE * LPHASHVALOFNAMESYS)(SYSKIND, LCID, const OLECHAR FAR *);

ULONG LateBound_LHashValOfNameSys(SYSKIND syskind, LCID lcid, const OLECHAR FAR* szName)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPHASHVALOFNAMESYS pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPHASHVALOFNAMESYS) GetProcAddress(hInst, "LHashValOfNameSys");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "LHashValOfNameSys", GetLastError());
        }
    }
    return(pFunc(syskind, lcid, szName));
}

typedef HRESULT (STDAPICALLTYPE * LPLOADTYPELIBEX)(LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib);

// from oleauto.h:
// Constants for specifying format in which TLB should be loaded
// (the default format is 32-bit on WIN32 and 64-bit on WIN64)
//  #define LOAD_TLB_AS_32BIT   0x20
//  #define LOAD_TLB_AS_64BIT   0x40
HRESULT LateBound_LoadTypeLib(const OLECHAR FAR *szFile, ITypeLib FAR* FAR* pptlib)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPLOADTYPELIBEX pFunc = NULL;
    REGKIND Kind;
    HRESULT hr;
    
    if (NULL == pFunc)
    {
        pFunc = (LPLOADTYPELIBEX) GetProcAddress(hInst, "LoadTypeLibEx");
        if (NULL == pFunc)
            {
            TLError(ERR_BIND, "LoadTypeLibEx", GetLastError());
            }
    }
// we don't need to set the flag on 32bit     
#ifdef _WIN64    
    Kind = ( REGKIND ) ( REGKIND_NONE | ( Is64BitEnv() ? LOAD_TLB_AS_64BIT  : LOAD_TLB_AS_32BIT ) );
#else
    Kind = ( REGKIND ) ( REGKIND_NONE | ( Is64BitEnv() ? LOAD_TLB_AS_64BIT : 0 ) );
#endif

    hr = pFunc(szFile, Kind, pptlib);

    // cleanup the bit if we failed: it's likely we are using an old oleaut32.dll that
    // doesn't support these two bits. 
    if ( hr == E_INVALIDARG )
        {
        MIDL_ASSERT( Kind != REGKIND_NONE );
            // UGLY UGLY 
            // issue warning when we are really generating tlb: this code is 
            // called during grammar check and we might not generate tlb in 
            // the current run
#ifdef _WIN64
            bool fGenTypeLib = pCommand->Is64BitEnv() || ( pCommand->Is32BitEnv() && pCommand->IsSwitchDefined( SWITCH_ENV ) );
#else
            bool fGenTypeLib = pCommand->Is32BitEnv() || ( pCommand->Is64BitEnv() && pCommand->IsSwitchDefined( SWITCH_ENV ) );
#endif
            // in w2k and before, there is oleaut bug that doesn't check SYS_WIN
            // so while midl read/write 32bit tlb, the syskind is set to SYS_WIN64
            // and oleaut32.dll in 64bit got confused and generate wrong vtbl.
            // We decided to disallow generating 64bit tlb on w2k and before.
            if ( fGenTypeLib && pCommand->GenerateTypeLibrary() )
                RpcError(NULL, 0, OLEAUT_NO_CROSSPLATFORM_TLB, "");
        Kind = REGKIND_NONE;
        hr = pFunc(szFile, Kind, pptlib);
        }

    return hr;
}


typedef HRESULT (STDAPICALLTYPE * LPQUERYPATHOFREGTYPELIB)(REFGUID, unsigned short, unsigned short, LCID, LPBSTR);

HRESULT LateBound_QueryPathOfRegTypeLib(
    REFGUID guid,
    unsigned short wMaj,
    unsigned short wMin,
    LCID lcid,
    LPBSTR lpbstrPathName)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPQUERYPATHOFREGTYPELIB pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPQUERYPATHOFREGTYPELIB) GetProcAddress(hInst, "QueryPathOfRegTypeLib");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "QueryPathOfRegTypeLib", GetLastError());
        }
    }
    return(pFunc(guid, wMaj, wMin, lcid, lpbstrPathName));
}

typedef HRESULT (STDAPICALLTYPE * LPREGISTERTYPELIB)(ITypeLib FAR *, OLECHAR FAR *, OLECHAR FAR *);

HRESULT LateBound_RegisterTypeLib(ITypeLib FAR* ptlib, OLECHAR FAR *szFullPath,
            OLECHAR FAR *szHelpDir)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPREGISTERTYPELIB pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPREGISTERTYPELIB) GetProcAddress(hInst, "RegisterTypeLib");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "RegisterTypeLib", GetLastError());
        }
    }
    return(pFunc(ptlib, szFullPath, szHelpDir));
}

typedef HRESULT (STDAPICALLTYPE * LPDEREGISTERTYPELIB)(REFGUID, WORD, WORD, LCID);

HRESULT LateBound_DeregisterTypeLib(REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid)
{
    HINSTANCE hInst = LoadOleAut32Once();
    static LPDEREGISTERTYPELIB pFunc = NULL;
    if (NULL == pFunc)
    {
        pFunc = (LPDEREGISTERTYPELIB) GetProcAddress(hInst, "DeregisterTypeLib");
        if (NULL == pFunc)
        {
            TLError(ERR_BIND, "DeregisterTypeLib", GetLastError());
        }
    }
    return(pFunc(rguid, wVerMajor, wVerMinor, lcid));
}

HRESULT LateBound_CreateTypeLib(SYSKIND syskind, const OLECHAR FAR *szFile,
            ICreateTypeLib FAR* FAR* ppctlib)
{
    LPFNCREATETYPELIB pFunc = BindToCreateTypeLib();
    return(pFunc(syskind, szFile, ppctlib));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\asyncu.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name :

    asyncu.h

Abstract :

    This file contains the ndr async uuid implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Oct 1997

Revision History :

---------------------------------------------------------------------*/

#ifndef  __ASYNCU_H__
#define  __ASYNCU_H__

#define NDR_ASYNC_PROXY_SIGNATURE   0x78507341  /* AsPx */
#define NDR_ASYNC_STUB_SIGNATURE    0x74537341  /* AsSt */

#define NDR_DCOM_ASYNC_SIGNATURE    0x734d7341  /* AsMs */
#define NDR_FREED_ASYNC_SIGNATURE   0x65656561  /* aeee */
#define NDR_FREED_DCOM_SIGNATURE    0x65656564  /* deee */


#define NDR_DCOM_ASYNC_VERSION      sizeof( NDR_DCOM_ASYNC_MESSAGE )
#define NDR_ASYNC_GUARD_SIZE        (0x10)

#define NDR_ASYNC_PREP_PHASE        1
#define NDR_ASYNC_SET_PHASE         2
#define NDR_ASYNC_CALL_PHASE        3
#define NDR_ASYNC_ERROR_PHASE       4


typedef struct _Flags
    {                      
        unsigned short          ValidCallPending    : 1;
        unsigned short          ErrorPending        : 1;
        unsigned short          BadStubData         : 1;
        unsigned short          RuntimeCleanedUp    : 1;
        unsigned short          ClientHandleCreated : 1;
        unsigned short          HandlelessObjCall   : 1;
        unsigned short          ClientDcomPipeCall  : 1;
        unsigned short          Unused              : 9;
    } NDR_ASYNC_CALL_FLAGS;

typedef struct _NDR_DCOM_ASYNC_MESSAGE
{
    long                        Version;
    long                        Signature;
    SYNTAX_TYPE                 SyntaxType;
    
    long                        nBeginParams;
    void *                      BeginParams;
    long                        nFinishParams;
    void *                      FinishParams;

    uchar *                     BeginStack;
    uchar *                     FinishStack;
    ulong 		                BeginStackSize;
    ulong 		                FinishStackSize;
    NDR_ASYNC_CALL_FLAGS        Flags;

    
    void   *                    pThis;
    CStdAsyncProxyBuffer  *     pAsyncPB;
    CStdAsyncStubBuffer  *      pAsyncSB;

    ulong *                     pdwStubPhase;
    unsigned short              StubPhase;

    unsigned long               ErrorCode;
    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    NDR_PROC_CONTEXT            ProcContext;

    uchar *                     pArg;

    // Note: the correlation cache needs to be sizeof(pointer) aligned
    unsigned _int64             AppStack;  // stack continues on                  
}   NDR_DCOM_ASYNC_MESSAGE, *PNDR_DCOM_ASYNC_MESSAGE;

#define AsyncAlloca( msg, size )           \
    NdrpAlloca( &msg->ProcContext.AllocateContext, size )

HRESULT
NdrpSetupBeginClientCall( 
    CStdAsyncProxyBuffer *  pAsyncPB,
    void *                  StartofStack,
    unsigned short          StackSize,
    REFIID                  riid );

HRESULT
NdrpSetupFinishClientCall( 
    CStdAsyncProxyBuffer *  pAsyncPB,
    void *                  StartofStack,
    unsigned short          StackSize,
    REFIID                  riid,
    unsigned long           AsyncProcNum );

HRESULT
NdrpSetupBeginStubCall( 
    CStdAsyncStubBuffer *   pAsyncSB,
    unsigned short          StackSize,
    REFIID                  riid );

HRESULT
NdrpSetupFinishStubCall( 
    CStdAsyncStubBuffer *   pAsyncSB,
    unsigned short          StackSize,
    REFIID                  riid );

HRESULT
NdrpBeginDcomAsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase );

ULONG STDMETHODCALLTYPE
NdrpAsyncProxyAddRef( 
    CStdAsyncProxyBuffer *  pAsyncPB );

ULONG STDMETHODCALLTYPE
NdrpAsyncProxyRelease( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
NdrpAsyncProxyLock( 
    CStdAsyncProxyBuffer *  pAsyncPB );

void
NdrpAsyncProxyUnlock( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
NdrpAsyncProxyCleanup( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
NdrpSetupBeginServerCall( 
    CStdAsyncStubBuffer *   pAsyncPB,
    void *                  StartofStack,
    unsigned short          StackSize,
    REFIID                  riid );


void
NdrpCloneInOutArgs( 
    NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg, 
    PPARAM_DESCRIPTION       FinishParams,
    int                      FinishParamCount ); 

void
NdrpFreeDcomAsyncMsg( 
    PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg );


HRESULT
NdrpAsyncStubSignal(
    CStdAsyncStubBuffer *  pAsyncSB );


HRESULT
NdrpAsyncStubAddRef( 
    CStdAsyncStubBuffer *  pAsyncSB );

ULONG STDMETHODCALLTYPE
NdrpAsyncStubRelease( 
    CStdAsyncStubBuffer *  pAsyncSB );

HRESULT
NdrpAsyncStubLock( 
    CStdAsyncStubBuffer *  pAsyncSB );

void
NdrpAsyncStubUnlock( 
    CStdAsyncStubBuffer *  pAsyncSB );

HRESULT
NdrpAsyncStubCleanup( 
    CStdAsyncStubBuffer *  pAsyncSB );


BOOL
NdrpDcomAsyncSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    ISynchronize *      pSynchronize );

BOOL
NdrpDcomAsyncClientSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    IUnknown *          punkOuter );

void
NdrDcomAsyncReceive(
    PMIDL_STUB_MESSAGE  pStubMsg );


HRESULT
NdrpValidateDcomAsyncMsg(
                        PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg );

HRESULT
NdrpValidateDcomAsyncMsg(
                        PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg
                        );
HRESULT
NdrpCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             );

HRESULT
NdrpValidateAsyncStubCall(
                         CStdAsyncStubBuffer *  pAsyncSB
                         );
void
NdrpCloneInOnlyCorrArgs(
                       NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg,
                       PFORMAT_STRING           pTypeFormat
                       );

HRESULT
NdrpValidateAsyncProxyCall(
                          CStdAsyncProxyBuffer *  pAsyncPB
                          );
                         

#define NdrHrFromWin32Error( exc )  NdrStubErrorHandler( exc )

#endif  // __ASYNCU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\asyncndr.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 2000 Microsoft Corporation

Module Name :

    asyncndr.h

Abstract :

    This file contains the ndr async related definitions.

Author :

    Ryszard K. Kott     (ryszardk)    Nov 1996

Revision History :

---------------------------------------------------------------------*/

#ifndef  __ASYNCNDR_H__
#define  __ASYNCNDR_H__

#define RPC_ASYNC_CURRENT_VERSION     RPC_ASYNC_VERSION_1_0


#define RPC_ASYNC_SIGNATURE         0x43595341  /* ASNC */
#define NDR_ASYNC_SIGNATURE         0x63797341  /* Asnc */
#define RPC_FREED_ASYNC_SIGNATURE   0x45454541  /* AEEE */
#define NDR_FREED_ASYNC_SIGNATURE   0x65656561  /* aeee */

#define RPC_ASYNC_HANDLE            PRPC_ASYNC_STATE

#define NDR_ASYNC_VERSION           sizeof( NDR_ASYNC_MESSAGE )

#define NDR_ASYNC_GUARD_SIZE        (0x10)

#define NDR_ASYNC_PREP_PHASE        1
#define NDR_ASYNC_SET_PHASE         2
#define NDR_ASYNC_CALL_PHASE        3
#define NDR_ASYNC_ERROR_PHASE       4

typedef struct _Flags
    {                      
        unsigned short          ValidCallPending    : 1;
        unsigned short          ErrorPending        : 1;
        unsigned short          BadStubData         : 1;
        unsigned short          RuntimeCleanedUp    : 1;
        unsigned short          ClientHandleCreated : 1;
        unsigned short          HandlelessObjCall   : 1;
        unsigned short          Unused              : 10;
    } NDR_ASYNC_CALL_FLAGS;

typedef struct _NDR_ASYNC_MESSAGE
{
    long                        Version;
    long                        Signature;
    RPC_ASYNC_HANDLE            AsyncHandle;    // raw and CAsyncMgr *
    NDR_ASYNC_CALL_FLAGS        Flags;
    unsigned short              StubPhase;

    unsigned long               ErrorCode;
    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    NDR_SCONTEXT                CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    ulong *                     pdwStubPhase;

    // Note: the correlation cache needs to be sizeof(pointer) aligned
    NDR_PROC_CONTEXT            ProcContext;

    // guard at the end of the message
    unsigned char               AsyncGuard[NDR_ASYNC_GUARD_SIZE]; 
}   NDR_ASYNC_MESSAGE, *PNDR_ASYNC_MESSAGE;

#define AsyncAlloca( msg, size )           \
    NdrpAlloca( &msg->ProcContext.AllocateContext, size )

RPC_STATUS
NdrpCompleteAsyncCall (
    IN PRPC_ASYNC_STATE     AsyncHandle,
    IN PNDR_ASYNC_MESSAGE   pAsyncMsg,
    IN void *               pReply
    );

RPC_STATUS
NdrpCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
NdrpCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
NdrpAsyncAbortCall(
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    );
 
RPC_STATUS 
NdrpInitializeAsyncMsg( 
    void *                      StartofStack,
    PNDR_ASYNC_MESSAGE          pAsyncMsg );

void
NdrpFreeAsyncMsg( 
    PNDR_ASYNC_MESSAGE          pAsyncMsg );

void
NdrpFreeAsyncHandleAndMessage(
    PRPC_ASYNC_STATE AsyncHandle);

void
NdrAsyncSend(
    PMIDL_STUB_MESSAGE          pStubMsg,
    BOOL                        fPartial );

void
NdrLastAsyncReceive(
    PMIDL_STUB_MESSAGE          pStubMsg );

RPC_STATUS
NdrValidateBothAndLockAsyncHandle(
    RPC_ASYNC_HANDLE            AsyncHandle );

RPC_STATUS
NdrpValidateAndLockAsyncHandle(
    RPC_ASYNC_HANDLE            AsyncHandle );

RPC_STATUS
NdrUnlockHandle(
    RPC_ASYNC_HANDLE            AsyncHandle );

RPC_STATUS
NdrpValidateAsyncMsg(
    PNDR_ASYNC_MESSAGE          pAsyncMsg  );

void
NdrpRegisterAsyncHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    void *              AsyncHandle );

#endif  // __ASYNCNDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\attack.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name :

    attack.c

Abstract :

    This file contains the ndr correlation check for denial of attacks.

Author :

    Ryszard K. Kott     (ryszardk)    Sep 1997

Revision History :

---------------------------------------------------------------------*/

#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"
#include "attack.h"
#include "interp.h"
#include "interp2.h"
#include "mulsyntx.h"
#include "asyncu.h"

extern "C" {
extern const GUID CLSID_RpcHelper;
}

inline
PFORMAT_STRING
GetConformanceDescriptor(
    PFORMAT_STRING      pFormat )
{

    static uchar    
    ConformanceDescIncrements[] = 
                            { 
                            4,              // Conformant array.
                            4,              // Conformant varying array.
                            0, 0,           // Fixed arrays - unused.
                            0, 0,           // Varying arrays - unused.
                            4,              // Complex array.

                            2,              // Conformant char string. 
                            2,              // Conformant byte string.
                            4,              // Conformant stringable struct. 
                            2,              // Conformant wide char string.

                            0, 0, 0, 0,     // Non-conformant strings - unused.

                            0,              // Encapsulated union - unused. 
                            2,              // Non-encapsulated union.
                            2,              // Byte count pointer.
                            0, 0,           // Xmit/Rep as - unused.
                            2               // Interface pointer.
                            };

    ASSERT( FC_CARRAY <= *pFormat  &&  *pFormat < FC_END);

    return pFormat + ConformanceDescIncrements[ *pFormat - FC_CARRAY ];
}

inline
PFORMAT_STRING
GetVarianceDescriptor(
    PFORMAT_STRING      pFormat )
{
    // The array gives offset according to the size of the new correlation descriptors.
    

    static uchar    
    VarianceDescIncrements[] =     
            { 8 + NDR_CORR_EXTENSION_SIZE,    // Conformant varying array.
              0, 0,                           // Fixed arrays - unsed.
              8, 12,                          // Varying array.
              8 + NDR_CORR_EXTENSION_SIZE,    // Complex array. 
            };

    ASSERT( FC_CVARRAY <= *pFormat  &&  *pFormat <= FC_BOGUS_ARRAY );

    return pFormat + VarianceDescIncrements[ *pFormat - FC_CVARRAY ];
}


void 
NdrpCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    LONG_PTR            Value,
    PFORMAT_STRING      pFormat,
    int                 CheckKind )
/*
    Checks if a correlation check can be performed or needs postponing.
    For early correlations it performs the check.
    For late correlations it adds an entry in the late correlatrion data base.

  Parameters
    Value  - conformant value related to the descriptor
    pFormat - array, string etc object with the descriptor

    pStubMsg->pCorrMemory - current memory context like struct
*/
{
    // pStubMsg->pCorrelationInfo->pCorrFstr   - descriptor for the current object

//    ASSERT( pStubMsg->pCorrInfo );

    // TBD performance: index through 2 dim table could be faster.

    if ( ( CheckKind & ~NDR_RESET_VALUE ) == NDR_CHECK_CONFORMANCE )
        pFormat = GetConformanceDescriptor( pFormat );
    else
        pFormat = GetVarianceDescriptor( pFormat );

    // See if we can actually check it out or whether we have to postpone it
    // till the correlation pass.

    NDR_FCDEF_CORRELATION * pConf = (NDR_FCDEF_CORRELATION *)pFormat;

    if ( pConf->CorrFlags.DontCheck )
        return;

    unsigned char * pMemory = pStubMsg->pCorrMemory;

    if ( pConf->CorrFlags.Early )
        {
        ULONG_PTR MaxCountSave = pStubMsg->MaxCount;
        ulong OffsetSave   = pStubMsg->Offset;

        pStubMsg->Offset = 0;
        // this call overwrites pStubMsg->MaxCount

        NdrpValidateCorrelatedValue( pStubMsg, pMemory, pFormat, Value, CheckKind );

        pStubMsg->MaxCount = MaxCountSave;
        pStubMsg->Offset   = OffsetSave;
        }
    else 
        {
        // Create correlation data base entry for the correlation pass.
        NdrpAddCorrelationData( pStubMsg, pMemory, pFormat, Value, CheckKind );
        }
}

//
void
NdrpValidateCorrelatedValue ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    LONG_PTR            Value,
    int                 CheckKind 
    )
/*++

Routine Description :

    This routine computes the conformant size for an array or the switch_is
    value for a union.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding entity: a struct or a stack top.
    pFormat     - Format string description of the correlation (at old).
                  It indicates the correlated argument value.
    Value       - value from the array etc, i.e. from the buffer, to be checked against

Return :

    The array or string size or the union switch_is.

--*/
{
    void          * pCount = 0;
    LONG_PTR        Count;

    unsigned char   FormatCopy[4];
    BOOL            fAsyncSplit = FALSE;

    BOOL            fResetValue;

    fResetValue = CheckKind & NDR_RESET_VALUE;
    CheckKind = CheckKind & ~NDR_RESET_VALUE;

     // Ignore top level checks for -Os stubs.
    if ( !pMemory )
        return;

    PNDR_FCDEF_CORRELATION   pFormatCorr = (PNDR_FCDEF_CORRELATION) pFormat;

    //
    // First check if this is a callback to an expression evaluation routine.
    //
    if ( pFormatCorr->Operation == FC_CALLBACK ) 
        {
        uchar *     pOldStackTop;
        ushort      Index;

        // Index into expression callback routines table.
        Index = (ushort) pFormatCorr->Offset;

        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval != 0,
                   "NdrpComputeConformance : no expr eval routines");
        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval[Index] != 0,
                   "NdrpComputeConformance : bad expr eval routine index");

        pOldStackTop = pStubMsg->StackTop;

        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        if ( (*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE ) 
            {
            pStubMsg->StackTop = pMemory;
            }

        //
        // This call puts the result in pStubMsg->MaxCount.
        //
        (*pStubMsg->StubDesc->apfnExprEval[Index])( pStubMsg );

        pStubMsg->StackTop = pOldStackTop;

        if ( CheckKind == NDR_CHECK_OFFSET )
            pStubMsg->MaxCount = pStubMsg->Offset;

        goto ValidateValue;
        }

    if ( CheckKind == NDR_CHECK_OFFSET )
        {
        // Checking offset without a call to expr eval routine -
        // this means that the offset should be zero.

        pStubMsg->MaxCount = 0;
        goto ValidateValue;
        }

    if ( (*pFormat & 0xf0) == FC_NORMAL_CONFORMANCE )
        {
        // Get the address where the conformance variable is in the struct.
        pCount = pMemory + pFormatCorr->Offset;
        goto ComputeConformantGetCount;
        }

    // See if this is an async split

    if ( pFormat[1] & 0x20 )
        {
        fAsyncSplit = TRUE;
        RpcpMemoryCopy( & FormatCopy[0], pFormat, 4 );
        pFormat = (PFORMAT_STRING) & FormatCopy[0];

        // Remove the async marker
        FormatCopy[1] = pFormat[1] & 0xdf; // ~0x20
        }

     //
    // Get a pointer to the conformance describing variable.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_CONFORMANCE ) 
        {
        //
        // Top level conformance.  For /Os stubs, the stubs put the max
        // count in the stub message.  For /Oi stubs, we get the max count
        // via an offset from the stack top.
        //
        if ( pStubMsg->StackTop ) 
            {
            if ( fAsyncSplit )
                {
                PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg;

                pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE) pStubMsg->pAsyncMsg;

                pCount = pAsyncMsg->BeginStack + (ushort)pFormatCorr->Offset;
                }
            else
                pCount = pStubMsg->StackTop + (ushort)pFormatCorr->Offset;
            goto ComputeConformantGetCount;
            }
        else
            {
            // Top level conformance with -Os - not supported yet.
            //
            // If this is top level conformance with /Os then 
            // a) For early correlation, the compiler should generate the code to
            //    assign appropriate value to pStubMsg->MaxCount.
            //    goto ValideValue
            // b) For late correlation, we should have a registration call generated,
            //    so there would be nothing to do.
            //
            return;
            }
        }

    //
    // If we're computing the size of an embedded sized pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    if ( (*pFormat & 0xf0) == FC_POINTER_CONFORMANCE )
        {
        pCount = pMemory + pFormatCorr->Offset;
        goto ComputeConformantGetCount;
        }

    //
    // Check for constant size/switch.
    //
    if ( (*pFormat & 0xf0) == FC_CONSTANT_CONFORMANCE )
        {
        //
        // The size/switch is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        Count =  (ULONG_PTR)pFormat[1] << 16;
        Count |= (ULONG_PTR) *((ushort *)(pFormat + 2));

        goto ComputeConformanceEnd;
        }

    //
    // Check for conformance of a multidimensional array element in 
    // a -Os stub.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE )
        {
        long Dimension;

        if ( fAsyncSplit )
            RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

        //
        // If pArrayInfo is non-null than we have a multi-D array.  If it
        // is null then we have multi-leveled sized pointers.
        //
        if ( pStubMsg->pArrayInfo ) 
            {
            Dimension = pStubMsg->pArrayInfo->Dimension;
            pStubMsg->MaxCount = pStubMsg->pArrayInfo->MaxCountArray[Dimension];
            }
        else
            {
            Dimension = *((ushort *)(pFormat + 2));
            pStubMsg->MaxCount = pStubMsg->SizePtrCountArray[Dimension];
            }

        goto ValidateValue;
        }

    NDR_ASSERT(0, "NdrpValidateCorrelatedValue:, Invalid Correlation type");
    RpcRaiseException( RPC_S_INTERNAL_ERROR );
    return;

ComputeConformantGetCount:

    //
    // Must check now if there is a dereference op.
    //
    if ( pFormatCorr->Operation == FC_DEREFERENCE )
        {
        pCount = *(void **)pCount;
        }

    //
    // If we're supposed to whack the value instead of checking it do it 
    // and quit
    //

    if ( fResetValue )
        {
        // hypers are not legal types for cs_char size/length_is expressions

        if ( FC_HYPER == pFormatCorr->Type )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );

        CHECK_BOUND( (long)Value, pFormatCorr->Type );

        switch ( pFormatCorr->Type )
            {
            case FC_ULONG:
                * (ulong *) pCount = (ulong) Value;
                return;

            case FC_LONG:
                * (ulong *) pCount = (long) Value;
                return;

            case FC_ENUM16 :
            case FC_USHORT :
                * (ushort *) pCount = (ushort) Value;
                return;

            case FC_SHORT :
                * (short *) pCount = (short) Value;
                return;

            case FC_USMALL :
                * (uchar *) pCount = (uchar) Value;
                return;

            case FC_SMALL :
                * (char *) pCount = (char) Value;
                return;

            default :
                NDR_ASSERT(0,"NdrpValidateCorrelatedValue : bad reset type");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
            }        
        }

    //
    // Now get the conformance count.
    //
    switch ( pFormatCorr->Type ) 
        {
        case FC_HYPER :
            // iid_is on 64b platforms only.
            Count = *((LONG_PTR *)pCount);
            break;

        case FC_ULONG :
            Count = (LONG_PTR)*((ulong *)pCount);
            break;

        case FC_LONG :
            Count = *((long *)pCount);
            break;

        case FC_ENUM16:
        case FC_USHORT :
            Count = (long) *((ushort *)pCount);
            break;

        case FC_SHORT :
            Count = (long) *((short *)pCount);
            break;

        case FC_USMALL :
            Count = (long) *((uchar *)pCount);
            break;

        case FC_SMALL :
            Count = (long) *((char *)pCount);
            break;

        default :
            NDR_ASSERT(0,"NdrpValidateCorrelatedValue : bad count type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
        } 

    //
    // Check the operator.
    //
    switch ( pFormatCorr->Operation ) 
        {
        case FC_DIV_2 :
            Count /= 2;
            break;
        case FC_MULT_2 :
            Count *= 2;
            break;
        case FC_SUB_1 :
            Count -= 1;
            break;
        case FC_ADD_1 :
            Count += 1;
            break;
        default :
            // OK
            break;
        }

ComputeConformanceEnd:

    pStubMsg->MaxCount = (ulong) Count;

ValidateValue:

    // Compare pStubMsg->MaxCount with the value

    BOOL            fValueOK = FALSE;
    LONG_PTR        ArgValue = (LONG_PTR) pStubMsg->MaxCount;
    unsigned char   FcType   = (uchar)pFormatCorr->Type;

    if ( (*pFormat & 0xf0) == FC_CONSTANT_CONFORMANCE  || 
          pFormatCorr->Operation == FC_CALLBACK ) 
        FcType = FC_ULONG;

    switch ( FcType ) 
        {
        case FC_HYPER :
            fValueOK = ArgValue == (LONG_PTR)Value;
            break;

        case FC_ULONG :
            fValueOK = ArgValue == (LONG_PTR)(ulong)Value;
            break;

        case FC_LONG :
            fValueOK = ArgValue == (LONG_PTR)(long)Value;
            break;

        case FC_ENUM16:
        case FC_USHORT :
            fValueOK = ArgValue == (LONG_PTR)(ushort)Value;
            break;

        case FC_SHORT :
            fValueOK = ArgValue == (LONG_PTR)(short)Value;
            break;

        case FC_USMALL :
            fValueOK = ArgValue == (LONG_PTR)(uchar)Value;
            break;

        case FC_SMALL :
            fValueOK = ArgValue == (LONG_PTR)(char)Value;
            break;

        default :
            NDR_ASSERT(0,"NdrpValidateCorrelatedValue : bad count type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
        } 

    if ( ! fValueOK )
        {
        if ( ! pFormatCorr->CorrFlags.IsIidIs )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
        else
            {
            // For interface pointers the check is more complicated.
            // Value is in this case a pointer to the value, actually.

            IID * piidValue = (IID *)Value;
            IID * piidArg   = (IID *)ArgValue;

            if ( 0 != memcmp( piidValue, piidArg, sizeof( IID )))
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }
        }

    return;
}

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationInitialize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    void *              pCache,
    unsigned long       CacheSize,
    unsigned long       Flags
    )
/* 
    Initializes the correlation package for -Os stubs.
*/  
{
    PNDR_CORRELATION_INFO  pCorrInfo = (PNDR_CORRELATION_INFO)pCache;

    if ( CacheSize == 0xffffffff )
        CacheSize = NDR_DEFAULT_CORR_CACHE_SIZE;

    pCorrInfo->Header.pCache = (NDR_CORRELATION_INFO *)pCache;
    pCorrInfo->Header.pInfo  = (NDR_CORRELATION_INFO *)pCache;
    pCorrInfo->Header.DataLen  = 0;
    pCorrInfo->Header.DataSize = (CacheSize - sizeof(NDR_CORRELATION_INFO)) 
                                     / sizeof(NDR_CORRELATION_INFO_DATA);

    pStubMsg->pCorrMemory = pStubMsg->StackTop;
    pStubMsg->pCorrInfo   = (NDR_CORRELATION_INFO *)pCache;

    pStubMsg->fHasExtensions  = 1;
    pStubMsg->fHasNewCorrDesc = 1;
}


void
NdrpAddCorrelationData( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    LONG_PTR            Value,
    int                 CheckKind 
    )
/* 
    Adds a check data to the correlation data base for a later evaluation.
*/  
{
    ASSERT( pStubMsg->pCorrInfo );

    PNDR_CORRELATION_INFO  pCorrInfo = (PNDR_CORRELATION_INFO)pStubMsg->pCorrInfo;

    if ( pCorrInfo->Header.DataSize <= pCorrInfo->Header.DataLen )
        {
        // Not enough space, need to realloc.

        unsigned long           NewDataSize;
        PNDR_CORRELATION_INFO   pCorrInfoNew;

        NewDataSize = 2 * pCorrInfo->Header.DataSize;
        pCorrInfoNew = (PNDR_CORRELATION_INFO) I_RpcAllocate( 
                            sizeof(NDR_CORRELATION_INFO_HEADER) + 
                                NewDataSize * sizeof(NDR_CORRELATION_INFO_DATA) );
        if ( ! pCorrInfoNew )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        RpcpMemoryCopy( pCorrInfoNew, 
                        pCorrInfo, 
                        sizeof(NDR_CORRELATION_INFO_HEADER) + 
                            pCorrInfo->Header.DataSize * sizeof(NDR_CORRELATION_INFO_DATA) );

        pCorrInfoNew->Header.pInfo    = pCorrInfoNew;
        pCorrInfoNew->Header.DataSize = NewDataSize;
        pStubMsg->pCorrInfo           = pCorrInfoNew;

        if ( pCorrInfo->Header.pInfo != pCorrInfo->Header.pCache )
            I_RpcFree( pCorrInfo->Header.pInfo );

        pCorrInfo = pCorrInfoNew;
        }

    pCorrInfo->Data[ pCorrInfo->Header.DataLen ].pMemoryObject = pMemory; 
    pCorrInfo->Data[ pCorrInfo->Header.DataLen ].Value         = Value; 
    pCorrInfo->Data[ pCorrInfo->Header.DataLen ].pCorrDesc     = pFormat; 
    pCorrInfo->Data[ pCorrInfo->Header.DataLen ].CheckKind     = CheckKind;
    pCorrInfo->Header.DataLen++;
}

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationPass( 
    PMIDL_STUB_MESSAGE  pStubMsg
    )
/* 
    Walks the data base to check all the correlated values that could not be checked 
    on fly.
*/  
{
    ASSERT( pStubMsg->pCorrInfo );
    if ( pStubMsg->pCorrInfo->Header.DataLen == 0 )
        return;

    PNDR_CORRELATION_INFO  pCorrInfo = (PNDR_CORRELATION_INFO)pStubMsg->pCorrInfo;

    for ( int i = 0; i < pCorrInfo->Header.DataLen; i++ )
        {
        NdrpValidateCorrelatedValue( pStubMsg,
                                     pCorrInfo->Data[ i ].pMemoryObject,
                                     pCorrInfo->Data[ i ].pCorrDesc,
                                     pCorrInfo->Data[ i ].Value,
                                     pCorrInfo->Data[ i ].CheckKind );
        }
}

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationFree( 
    PMIDL_STUB_MESSAGE  pStubMsg
    )
/* 
    Releases the correlation data structures.
    In /Os stub, NdrCorrelationInitialize is called after fullpointer initialization
    and NdrCorrelationFree is called without checking pStubMsg->pCorrInfo. changing
    ndr might be better in this case. 
*/  
{
//    ASSERT( pStubMsg->pCorrInfo );

    PNDR_CORRELATION_INFO  pCorrInfo = (PNDR_CORRELATION_INFO)pStubMsg->pCorrInfo;
    if ( NULL == pCorrInfo )
        return;

    if ( pCorrInfo->Header.pInfo != pCorrInfo->Header.pCache )
        {
        I_RpcFree( pCorrInfo->Header.pInfo );
        }        
}


HRESULT
NdrpGetRpcHelper(
    IRpcHelper **     ppRpcHelper )
/*++

    This routine attempts to get hold of an IRpcHelper interface pointer.
    We cache the one IP on each process and never release it. This is an inproc server
    and interface will be cleanup when process exit. 
--*/
{
    HRESULT     hr;
    static IRpcHelper  *pRpcHelper = NULL;   

    *ppRpcHelper = NULL;
    if (pRpcHelper)
    {
        *ppRpcHelper = pRpcHelper;
        hr = S_OK;
    }
    else
    {
        hr = NdrLoadOleRoutines();

        if (SUCCEEDED(hr))
            hr = (*pfnCoCreateInstance)( CLSID_RpcHelper, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER,
            	                 IID_IRpcHelper, 
                                 (void **)&pRpcHelper );

        if (SUCCEEDED(hr))
            *ppRpcHelper = pRpcHelper;
    }
        
    return hr;
}

void
NdrpGetIIDFromBuffer( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    IID **              ppIID
    )
/*
    The routine recovers an interface pointer IID from the marshaling buffer.
    The IID stays in the buffer, an IID* is returned by the routine.
*/
{
    IRpcHelper *    pRpcHelper = 0;
    HRESULT         hr;
    
    *ppIID = 0;

    hr = NdrpGetRpcHelper( & pRpcHelper );

    if(FAILED(hr))
        RpcRaiseException(hr);
    
    hr = pRpcHelper->GetIIDFromOBJREF(  pStubMsg->Buffer,
                                       ppIID );
    if (FAILED(hr))
        RpcRaiseException( RPC_X_BAD_STUB_DATA );

    // The IRpcHelper is cached in NdrpGetRpcHelper so we don't need to release it.
    //    pRpcHelper->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\attack.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    attack.c

Abstract :

    This file contains code for the ndr correlation checks related to attacks
    on the marshaling buffer.

Author :

    Ryszard K. Kott     (ryszardk)    Sep 1997

Revision History :

---------------------------------------------------------------------*/

#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"

#if !defined(__ATTACK_H__)
#define  __ATTACK_H__

#define NO_CORRELATION

#define CORRELATION_RESOURCE_SAVE   \
            uchar *         pCorrMemorySave;

#define F_CORRELATION_CHECK         (pStubMsg->pCorrInfo != 0)

#define SAVE_CORRELATION_MEMORY()  \
            pCorrMemorySave = pStubMsg->pCorrMemory;

#define SET_CORRELATION_MEMORY( pMem )  \
            pCorrMemorySave = pStubMsg->pCorrMemory; \
            pStubMsg->pCorrMemory = pMem; 

#define RESET_CORRELATION_MEMORY()  \
            pStubMsg->pCorrMemory = pCorrMemorySave;  

#define NDR_CORR_EXTENSION_SIZE  2

#define CORRELATION_DESC_INCREMENT( pFormat ) \
            if ( pStubMsg->fHasNewCorrDesc ) \
                pFormat += NDR_CORR_EXTENSION_SIZE;

#define FC_CORR_NORMAL_CONFORMANCE           (FC_NORMAL_CONFORMANCE    >> 4  /* 0 */)
#define FC_CORR_POINTER_CONFORMANCE          (FC_TOP_LEVEL_CONFORMANCE >> 4  /* 1 */)
#define FC_CORR_TOP_LEVEL_CONFORMANCE        (FC_TOP_LEVEL_CONFORMANCE >> 4  /* 2 */)
#define FC_CORR_CONSTANT_CONFORMANCE         (FC_TOP_LEVEL_CONFORMANCE >> 4  /* 4 */)
#define FC_CORR_TOP_LEVEL_MULTID_CONFORMANCE (FC_TOP_LEVEL_MULTID_CONFORMANCE >> 4 /* 8 */)

#define NDR_CHECK_CONFORMANCE   0
#define NDR_CHECK_VARIANCE      1
#define NDR_CHECK_OFFSET        2
#define NDR_RESET_VALUE         8   // This can be or'd with one of the above

typedef  struct  _NDR_FCDEF_CORRELATION
    {
    unsigned short          Type      : 4;
    unsigned short          Kind      : 4;
    unsigned short          Operation : 8;
             short          Offset;
    NDR_CORRELATION_FLAGS   CorrFlags;
    unsigned short          Reserved  : 8;
    } NDR_FCDEF_CORRELATION, *PNDR_FCDEF_CORRELATION;


typedef struct _NDR_CORRELATION_INFO_HEADER
    {
    struct _NDR_CORRELATION_INFO *  pCache;
    struct _NDR_CORRELATION_INFO *  pInfo;
    long                            DataSize;
    long                            DataLen;
    } NDR_CORRELATION_INFO_HEADER;

typedef struct _NDR_CORRELATION_INFO_DATA
    {
    unsigned char *                 pMemoryObject;
    PFORMAT_STRING                  pCorrDesc;
    LONG_PTR                        Value;
    long                            CheckKind;
#if defined(__RPC_WIN64__)
    long                            Reserve64;
#endif
    } NDR_CORRELATION_INFO_DATA;

typedef struct _NDR_CORRELATION_INFO
    {
    NDR_CORRELATION_INFO_HEADER         Header;
    NDR_CORRELATION_INFO_DATA           Data[1];
    } NDR_CORRELATION_INFO, *PNDR_CORRELATION_INFO;


typedef  struct  _NDR_DEF_FC_RANGE
    {
    unsigned char           FcToken;
    unsigned char           Type      : 4;
    unsigned char           ConfFlags : 4;
    unsigned long           Low;
    unsigned long           High;
    } NDR_DEF_FC_RANGE, *PNDR_DEF_FC_RANGE;



void 
NdrpCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    LONG_PTR            Value,
    PFORMAT_STRING      pFormat,
    int                 CheckKind );

void
NdrpAddCorrelationData( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    LONG_PTR            Value,
    int                 CheckKind );

void
NdrpValidateCorrelatedValue ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    LONG_PTR            Value,
    int                 CheckKind );

#endif // __ATTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\auxilary.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    auxilary.h

Abstract :

Author :

Revision History :

  ---------------------------------------------------------------------*/

#ifndef _AUXILARY_H
#define _AUXILARY_H

typedef
RPC_STATUS ( RPC_ENTRY *RPC_NS_GET_BUFFER_ROUTINE)(
    IN PRPC_MESSAGE         Message
    );

typedef
RPC_STATUS ( RPC_ENTRY *RPC_NS_SEND_RECEIVE_ROUTINE)(
    IN PRPC_MESSAGE          Message,
    OUT RPC_BINDING_HANDLE * Handle
    );

typedef
RPC_STATUS ( RPC_ENTRY *RPC_NS_NEGOTIATETRANSFERSYNTAX_ROUTINE) (
    IN OUT PRPC_MESSAGE     Message
    );



EXTERN_C void
NdrpSetRpcSsDefaults( RPC_CLIENT_ALLOC *pfnAlloc,
                      RPC_CLIENT_FREE *pfnFree);

extern RPC_NS_GET_BUFFER_ROUTINE       pRpcNsGetBuffer;
extern RPC_NS_SEND_RECEIVE_ROUTINE     pRpcNsSendReceive;
extern RPC_NS_NEGOTIATETRANSFERSYNTAX_ROUTINE  pRpcNsNegotiateTransferSyntax;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\bufsizep.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    sizep.h

Abtract :

    Contains private sizing routine definitions.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

typedef     void	(RPC_ENTRY * PSIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
						uchar *				pMemory,
                        PFORMAT_STRING		pFormat
                    );

typedef     void	(* PPRIVATE_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
						uchar *				pMemory,
                        PFORMAT_STRING		pFormat
                    );

IMPORTSPEC
extern const PSIZE_ROUTINE * pfnSizeRoutines;

void
NdrpPointerBufferSize ( 
	PMIDL_STUB_MESSAGE  pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpConformantArrayBufferSize ( 
	PMIDL_STUB_MESSAGE  pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpConformantVaryingArrayBufferSize ( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpComplexArrayBufferSize ( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpConformantStringBufferSize ( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar * 			pMemory,
    PFORMAT_STRING		pFormat
	);

void
NdrpUnionBufferSize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar *       		pMemory,
    PFORMAT_STRING		pFormat,
	long				SwitchIs,
	uchar				SwitchType
    );

void
NdrpEmbeddedPointerBufferSize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar *       		pMemory,
    PFORMAT_STRING		pFormat
    );

void
NdrpEmbeddedRepeatPointerBufferSize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    uchar *         	pMemory,
    PFORMAT_STRING *	ppFormat
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cltcall.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    cltcall.c

Abstract :

    This file contains the single call Ndr routine for the client side.

Author :

    David Kays    dkays    October 1993.

Revision History :

    brucemc     11/15/93    Added struct by value support, corrected
                            varargs use.
    brucemc     12/20/93    Binding handle support
    ryszardk    3/12/94     handle optimization and fixes

---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"
#include "attack.h"

#include "ndrole.h"
#include "rpcproxy.h"

#pragma code_seg(".orpc")

#if defined ( DEBUG_142065 )

#define    _STUB_CALCSIZE           0x1
#define    _STUB_GETBUFFER          0x2
#define    _STUB_MARSHAL            0x4
#define    _STUB_SENDRECEIVE        0x8
#define    _STUB_UNMARSHAL          0x10
#define    _STUB_EXCEPTION          0x20
#define    _STUB_AFTER_EXCEPTION    0x40
#define    _STUB_FREE               0x80

typedef struct _STUB_TRACKING_INFO
    {
    PMIDL_STUB_MESSAGE      pStubMsg;
    RPC_MESSAGE             RpcMsg;
    ulong                   StubPhase;
    ulong                   ExceptionCode;    
    }   STUB_TRACKING_INFO;

#endif


CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    );

#if ! defined(__RPC_WIN64__)
// The old interpreter is not supported on 64b platforms.

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    )
{
    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    PFORMAT_STRING              pFormatParam, pFormatParamSaved;
    PFORMAT_STRING              pHandleFormatSave;
    ulong                       ProcNum;
    ulong                       RpcFlags;
    long                        StackSize;
    long                        TotalStackSize;
    CLIENT_CALL_RETURN          ReturnValue;
    va_list                     ArgList;
    void *                      pArg;
    void **                     ppArg;
    uchar *                     StartofStack;
    handle_t                    Handle;
    handle_t                    SavedGenericHandle = NULL;
    uchar                       HandleType;
    void *                      pThis;
    INTERPRETER_FLAGS           InterpreterFlags;

    ARG_QUEUE                   ArgQueue;
    ARG_QUEUE_ELEM              QueueElements[QUEUE_LENGTH];
    PARG_QUEUE_ELEM             pQueue;
    long                        Length;

    ArgQueue.Length = 0;
    ArgQueue.Queue = QueueElements;

    HandleType = *pFormat++;

    InterpreterFlags = *((PINTERPRETER_FLAGS)pFormat++);

    StubMsg.FullPtrXlatTables = 0;

    if ( InterpreterFlags.HasRpcFlags )
        RpcFlags = *((ulong UNALIGNED *&)pFormat)++;
    else
        RpcFlags = 0;

    ProcNum = *((ushort *&)pFormat)++;

    TotalStackSize = *((ushort *&)pFormat)++;

    if ( (TotalStackSize / sizeof(REGISTER_TYPE)) > QUEUE_LENGTH )
        {
        ArgQueue.Queue = (PARG_QUEUE_ELEM)
            I_RpcAllocate( (unsigned int)
                           (((TotalStackSize / sizeof(REGISTER_TYPE)) + 1) *
                           sizeof(ARG_QUEUE_ELEM) ) );
        }

    ReturnValue.Pointer = 0;

    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    //
    INIT_ARG( ArgList, pFormat);

    //
    // Get the address of the first argument of the function calling this
    // function. Save this in a local variable and in the main data structure.
    //
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar*)GET_STACK_START(ArgList);

    //
    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        //
        // Use a nested try-except pair to support OLE. In OLE case, test the
        // exception and map it if required, then set the return value. In
        // nonOLE case, just reraise the exception.
        //
        RpcTryExcept
            {
            //
            // Stash away the place in the format string describing the handle.
            //
            pHandleFormatSave = pFormat;

            // Bind the client to the server. Check for an implicit or
            // explicit generic handle.
            //

            if ( InterpreterFlags.ObjectProc )
                {
                pThis = *(void **)StartofStack;
                NdrProxyInitialize( pThis,
                                    &RpcMsg,
                                    &StubMsg,
                                    pStubDescriptor,
                                    ProcNum );
                }
            else
                {
                if ( InterpreterFlags.UseNewInitRoutines )
                    {
                    NdrClientInitializeNew( &RpcMsg,
                                            &StubMsg,
                                            pStubDescriptor,
                                            (uint) ProcNum );
                    }
                else
                    {
                    NdrClientInitialize( &RpcMsg,
                                         &StubMsg,
                                         pStubDescriptor,
                                         (uint) ProcNum );
		            }

                if ( HandleType )
                    {
                    //
                    // We have an implicit handle.
                    //
                    Handle = ImplicitBindHandleMgr( pStubDescriptor,
                                                    HandleType,
                                                    &SavedGenericHandle);
                    }
                else
                    {
                    Handle = ExplicitBindHandleMgr( pStubDescriptor,
                                                    StartofStack,
                                                    pFormat,
                                                    &SavedGenericHandle );

                    pFormat += (*pFormat == FC_BIND_PRIMITIVE) ?  4 :  6;
                    }
                }

            if ( InterpreterFlags.RpcSsAllocUsed )
                NdrRpcSmSetClientToOsf( &StubMsg );

            // Set Rpc flags after the call to client initialize.
            StubMsg.RpcMsg->RpcFlags = RpcFlags;

            // Must do this before the sizing pass!
            StubMsg.StackTop = StartofStack;

            //
            // Make ArgQueue check after all setup/binding is finished.
            //
            if ( ! ArgQueue.Queue )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );

            if ( InterpreterFlags.FullPtrUsed )
                StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );

            // Save beginning of param description.
            pFormatParamSaved = pFormat;

            //
            // ----------------------------------------------------------------
            // Sizing Pass.
            // ----------------------------------------------------------------
            //

            //
            // If it's an OLE interface, then the this pointer will occupy
            // the first dword on the stack. For each loop hereafter, skip
            // the first dword.
            //
            if ( InterpreterFlags.ObjectProc )
                {
		        GET_NEXT_C_ARG(ArgList,long);
                GET_STACK_POINTER(ArgList,long);
                }

            for ( pQueue = ArgQueue.Queue; ; ArgQueue.Length++, pQueue++ )
                {
                //
                // Clear out flags IsReturn, IsBasetype, IsIn, IsOut,
                // IsOutOnly, IsDeferredFree, IsDontCallFreeInst.
                //
                *((long *)(((char *)pQueue) + 0xc)) = 0;

                switch ( *pFormat )
                    {
                    case FC_IN_PARAM_BASETYPE :
                        pQueue->IsIn = TRUE;
                        pQueue->IsBasetype = TRUE;

                        SIMPLE_TYPE_BUF_INCREMENT(StubMsg.BufferLength,
                                                  pFormat[1]);

                        //
                        // Increment arg list pointer correctly.
                        //
                        switch ( pFormat[1] )
                            {
                            case FC_HYPER :
                                pArg = GET_STACK_POINTER(ArgList,hyper);
                                GET_NEXT_C_ARG(ArgList,hyper);
                                break;

                            case FC_LONG:
                                pArg = GET_STACK_POINTER(ArgList,long);
                                GET_NEXT_C_ARG(ArgList,long);
                                break;

                            default :
                                pArg = GET_STACK_POINTER(ArgList,int);
                                GET_NEXT_C_ARG(ArgList,int);
                                break;
                            }

                        pQueue->pFormat = &pFormat[1];
                        pQueue->pArg = (uchar*)pArg;

                        pFormat += 2;
                        continue;

                    case FC_IN_PARAM :
                    case FC_IN_PARAM_NO_FREE_INST :
                        pQueue->IsIn = TRUE;
                        break;

                    case FC_IN_OUT_PARAM :
                        pQueue->IsIn = TRUE;
                        pQueue->IsOut = TRUE;
                        break;

                    case FC_OUT_PARAM :
                        pQueue->IsOut = TRUE;
                        pQueue->IsOutOnly = TRUE;

                        //
                        // An [out] param ALWAYS eats up at 4 bytes of stack
                        // space on x86, MIPS and PPC and 8 bytes on axp
                        // because it must be a pointer or an array.
                        //
                        ppArg = (void **) GET_STACK_POINTER(ArgList,long);
			            GET_NEXT_C_ARG(ArgList,long);

                        pFormat += 2;
                        pFormatParam = pStubDescriptor->pFormatTypes +
                                       *((short *)pFormat);
                        pFormat += 2;

                        pQueue->pFormat = pFormatParam;
                        pQueue->ppArg = (uchar **)ppArg;

                        if ( InterpreterFlags.ObjectProc )
                            {
                            NdrClientZeroOut( &StubMsg,
                                              pFormatParam,
                                              (uchar*)*ppArg );
                            }

                        continue;

                    case FC_RETURN_PARAM_BASETYPE :
                        pQueue->IsOut = TRUE;
                        pQueue->IsBasetype = TRUE;

                        pQueue->pFormat = &pFormat[1];
                        pQueue->pArg = (uchar *)&ReturnValue;

                        ArgQueue.Length++;
                        goto SizeLoopExit;

                    case FC_RETURN_PARAM :
                        pQueue->IsOut = TRUE;

                        pFormat += 2;
                        pFormatParam = pStubDescriptor->pFormatTypes +
                                       *((short *)pFormat);

                        pQueue->pFormat = pFormatParam;

                        if ( IS_BY_VALUE(*pFormatParam) )
                            {
                            pQueue->pArg = (uchar *)&ReturnValue;
                            pQueue->ppArg = &(pQueue->pArg);
                            }
                        else
                            {
                            pQueue->ppArg = (uchar **)&ReturnValue;
                            }

                        ArgQueue.Length++;
                        goto SizeLoopExit;

                    default :
                        goto SizeLoopExit;
                    }

                //
                // Get the paramter's format string description.
                //
                pFormat += 2;
                pFormatParam = pStubDescriptor->pFormatTypes +
                               *((short *)pFormat);

                pQueue->pFormat = pFormatParam;

                // Increment main format string past offset field.
                pFormat += 2;

                pArg = (uchar *) GET_STACK_POINTER(ArgList, int);
		        GET_NEXT_C_ARG(ArgList, int);

                if ( IS_BY_VALUE( *pFormatParam ) )
                    {
                    pQueue->pArg = (uchar*)pArg;
                    // Only transmit as will ever need this.
                    pQueue->ppArg = &pQueue->pArg;
                    }
                else
                    {
                    pQueue->pArg = *((uchar **)pArg);
                    pQueue->ppArg = (uchar**)pArg;

                    pArg = *((uchar **)pArg);
                    }

                //
                // The second byte of a param's description gives the number of
                // ints occupied by the param on the stack.
                //
                StackSize = pFormat[-3] * sizeof(int);

		        if ( StackSize > sizeof(REGISTER_TYPE) )
                    {

                    StackSize -= sizeof(REGISTER_TYPE);
                    SKIP_STRUCT_ON_STACK(ArgList, StackSize);
                    }

                (*pfnSizeRoutines[ROUTINE_INDEX(*pFormatParam)])
		        ( &StubMsg,
		          (uchar*)pArg,
		          pFormatParam );

                } // for(;;) sizing pass

SizeLoopExit:

            //
            // Make the new GetBuffer call.
            //
            if ( (HandleType == FC_AUTO_HANDLE) &&
                 (! InterpreterFlags.ObjectProc) )
                {
                NdrNsGetBuffer( &StubMsg,
                                StubMsg.BufferLength,
                                Handle );
                }
            else
                {
                if ( InterpreterFlags.ObjectProc )
                    NdrProxyGetBuffer( pThis,
                                       &StubMsg );
                else
                    NdrGetBuffer( &StubMsg,
                                  StubMsg.BufferLength,
                                  Handle );
                }

            NDR_ASSERT( StubMsg.fBufferValid, "Invalid buffer" );

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            for ( Length = ArgQueue.Length, pQueue = ArgQueue.Queue;
                  Length--;
                  pQueue++ )
                {
                if ( pQueue->IsIn )
                    {
                    if ( pQueue->IsBasetype )
                        {
                        NdrSimpleTypeMarshall( &StubMsg,
                                              pQueue->pArg,
                                              *(pQueue->pFormat) );
                        }
                    else
                        {
                        pFormatParam = pQueue->pFormat;

                        (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormatParam)])
                        ( &StubMsg,
                          pQueue->pArg,
                          pFormatParam );
                        }
                    }
                }

            //
            // Make the RPC call.
            //
            if ( (HandleType == FC_AUTO_HANDLE) &&
                 (!InterpreterFlags.ObjectProc) )
                {
                NdrNsSendReceive( &StubMsg,
                                  StubMsg.Buffer,
                                  (RPC_BINDING_HANDLE *) pStubDescriptor->
                                      IMPLICIT_HANDLE_INFO.pAutoHandle );
                }
            else
                {
                if ( InterpreterFlags.ObjectProc )
                    NdrProxySendReceive( pThis, &StubMsg );
                else
                    NdrSendReceive( &StubMsg, StubMsg.Buffer );
                }

            //
            // Do endian/floating point conversions.
            //
            if ( (RpcMsg.DataRepresentation & 0X0000FFFFUL) !=
                  NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( &StubMsg, pFormatParamSaved );

            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //

            for ( Length = ArgQueue.Length, pQueue = ArgQueue.Queue;
                  Length--;
                  pQueue++ )
                {
                if ( pQueue->IsOut )
                    {
                    if ( pQueue->IsBasetype )
                        {
                        NdrSimpleTypeUnmarshall( &StubMsg,
                                                 pQueue->pArg,
                                                 *(pQueue->pFormat) );
                        }
                    else
                        {
                        pFormatParam = pQueue->pFormat;

                        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatParam)])
                        ( &StubMsg,
                          pQueue->ppArg,
                          pFormatParam,
                          FALSE );
                        }
                    }
                }
            }
        RpcExcept( EXCEPTION_FLAG )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            //
            // In OLE, since they don't know about error_status_t and wanted to
            // reinvent the wheel, check to see if we need to map the exception.
            // In either case, set the return value and then try to free the
            // [out] params, if required.
            //
            if ( InterpreterFlags.ObjectProc )
                {
                ReturnValue.Simple = NdrProxyErrorHandler(ExceptionCode);

                //
                // Set the Buffer endpoints so the NdrFree routines work.
                //
                StubMsg.BufferStart = 0;
                StubMsg.BufferEnd   = 0;

                for ( Length = ArgQueue.Length, pQueue = ArgQueue.Queue;
                      Length--;
                      pQueue++ )
                    {
                    if ( pQueue->IsOutOnly )
                        {
                        NdrClearOutParameters( &StubMsg,
                                               pQueue->pFormat,
                                               *(pQueue->ppArg) );
                        }
                    }
                }
            else
                {
                if ( InterpreterFlags.HasCommOrFault )
                    {
                    NdrClientMapCommFault( &StubMsg,
                                           ProcNum,
                                           ExceptionCode,
                                           (ulong*)&ReturnValue.Simple );
                    }
                else
                    {
                    RpcRaiseException(ExceptionCode);
                    }
                }
            }
        RpcEndExcept
        }
    RpcFinally
        {
        NdrFullPointerXlatFree(StubMsg.FullPtrXlatTables);

        //
        // Free the RPC buffer.
        //
        if ( InterpreterFlags.ObjectProc )
            {
            NdrProxyFreeBuffer( pThis, &StubMsg );
            }
        else
            NdrFreeBuffer( &StubMsg );

        //
        // Unbind if generic handle used.  We do this last so that if the
        // the user's unbind routine faults, then all of our internal stuff
        // will already have been freed.
        //
        if ( SavedGenericHandle )
            {
            GenericHandleUnbind( pStubDescriptor,
                                 StartofStack,
                                 pHandleFormatSave,
                                 (HandleType) ? IMPLICIT_MASK : 0,
                                 &SavedGenericHandle );
            }

        if ( ((TotalStackSize / sizeof(REGISTER_TYPE)) > QUEUE_LENGTH) &&
             ArgQueue.Queue )
            {
            I_RpcFree( ArgQueue.Queue );
            }
        }
    RpcEndFinally

    return ReturnValue;
}

#endif  // ! defined(__RPC_WIN64__)


void
NdrClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar *             pArg
    )
{
    LONG_PTR   Size;

    //
    // In an object proc, we must zero all [out] unique and interface
    // pointers which occur as the referent of a ref pointer or embedded in a
    // structure or union.
    //

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    //
    // The only top level [out] type allowed is a ref pointer or an array.
    //
    if ( *pFormat == FC_RP )
        {
        // Double pointer.
        if ( POINTER_DEREF(pFormat[1]) )
            {
            *((void **)pArg) = 0;
            return;
            }

        // we need to zero out basetype because it might be conformant/
        // varying descriptor.
        if ( SIMPLE_POINTER(pFormat[1]) )
            {
            MIDL_memset( pArg, 0, (uint) SIMPLE_TYPE_MEMSIZE(pFormat[2]) );
            return;
            }

        // Pointer to struct, union, or array.
        pFormat += 2;
        pFormat += *((short *)pFormat);
        }

    Size = (LONG_PTR)NdrpMemoryIncrement( pStubMsg,
                                          0,
                                          pFormat );

    MIDL_memset( pArg, 0, (size_t)Size );
}

void RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    void  *             pArgVoid
    )
/*++

Routine Description :

    Free and clear an [out] parameter in case of exceptions for object
    interfaces.

Arguments :

    pStubMsg    - pointer to stub message structure
    pFormat     - The format string offset
    pArg        - The [out] pointer to clear.

Return :

    NA

Notes:

--*/
{
    uchar *     pArgSaved;
    ULONG_PTR   Size;
    uchar *     pArg = (uchar*)pArgVoid;

    if( pStubMsg->dwStubPhase != PROXY_UNMARSHAL)
        return;

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    Size = 0;

    pArgSaved = pArg;

    //
    // Look for a non-Interface pointer.
    //
    if ( IS_BASIC_POINTER(*pFormat) )
        {
        // Pointer to a basetype.
        if ( SIMPLE_POINTER(pFormat[1]) )
            {
            //
            // It seems wierd to zero an [out] pointer to a basetypes, but this
            // is what we did in NT 3.5x and I wouldn't be surprised if
            // something broke if we changed this behavior.
            //
            Size = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoZero;
            }

        // Pointer to a pointer.
        if ( POINTER_DEREF(pFormat[1]) )
            {
            Size = PTR_MEM_SIZE;
            pArg = *((uchar **)pArg);
            }

        pFormat += 2;
        pFormat += *((short *)pFormat);

        if ( *pFormat == FC_BIND_CONTEXT )
            {
            *((NDR_CCONTEXT *)pArg) = (NDR_CCONTEXT) 0;
            return;
            }
        }

    (*pfnFreeRoutines[ROUTINE_INDEX(*pFormat)])
    ( pStubMsg,
      pArg,
      pFormat );


    if ( ! Size )
        {
        Size = (ULONG_PTR)NdrpMemoryIncrement( pStubMsg,
                                               0,
                                               pFormat );
        }

DoZero:

    MIDL_memset( pArgSaved, 0, (size_t)Size );
}

void
NdrClientMapCommFault(
    PMIDL_STUB_MESSAGE  pStubMsg,
    long                ProcNum,
    RPC_STATUS          ExceptionCode,
    ULONG_PTR *         pReturnValue
    )
/*
    This routine will map exception code to the related placeholder in the app.

    The mapping is based on the information generated by the compiler into
    the CommFaultOffset table.
    The table may have the following entries in the comm and fault cells:
        -2    - not mapped
        -1    - mapped to the returned value
        0<=   - mapped to an out parameter, the value is the param stack offset.

    Mapping to a parameter is not allowed in the handle-less asynchronous calls.
    For handle-less async calls, the exception doesn't come from the server, 
    it is just a way for the client stub to signal if the dispatch was succesful.

    Note for 64b platforms. error_status_t has a size of a long and so that is 
    why we leave pReturnValue as well as pComm and pFault as long pointers.

*/
{
    PMIDL_STUB_DESC             pStubDescriptor;
    RPC_STATUS                  Status;
    uchar *                     StartofStack;
    void **                     ppArg;
    const COMM_FAULT_OFFSETS *  Offsets;
    ulong *                     pComm;
    ulong *                     pFault;

    pStubDescriptor = pStubMsg->StubDesc;
    StartofStack = pStubMsg->StackTop;

    Offsets = pStubDescriptor->CommFaultOffsets;

    switch ( Offsets[ProcNum].CommOffset )
        {
        case -2 :
            pComm = 0;
            break;
        case -1 :
            pComm = (ulong*)pReturnValue;
            break;
        default :
            ppArg = (void **)(StartofStack + Offsets[ProcNum].CommOffset);
            pComm = (ulong *) *ppArg;
            break;
        }

    switch ( Offsets[ProcNum].FaultOffset )
        {
        case -2 :
            pFault = 0;
            break;
        case -1 :
            pFault = (ulong*)pReturnValue;
            break;
        default :
            ppArg = (void **)(StartofStack + Offsets[ProcNum].FaultOffset);
            pFault = (ulong *) *ppArg;
            break;
        }

    Status = NdrMapCommAndFaultStatus(
                pStubMsg,
                pComm,
                pFault,
                ExceptionCode
                );

    if ( Status )
        RpcRaiseException(Status);
}

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    )
/*
    This routine is called from the object stubless proxy dispatcher.
*/
{
    va_list                     ArgList;

#if defined(_IA64_)
    // Get address of the virtual stack as forced on the ia64 C compiler.
    // On ia64 the call takes the actual args, not the address to args as usual,
    // so we split the code path with NdrpClientCall2. That is needed for calls
    // from the stubless proxy codepath. This routine is used for call_as.
    //
    INIT_ARG( ArgList, pFormat);
    GET_FIRST_IN_ARG(ArgList);
    uchar *StartofStack = (uchar*)GET_STACK_START(ArgList);

    return NdrpClientCall2( pStubDescriptor, pFormat, StartofStack );
}

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    )
{
#endif // _IA64_

    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    CLIENT_CALL_RETURN          ReturnValue;
    ulong                       ProcNum, RpcFlags;
    uchar *                     pArg;
    void *                      pThis = NULL;
    handle_t                    Handle;
    NDR_PROC_CONTEXT            ProcContext;
#if defined ( DEBUG_142065 )
    ulong                       TrackStubPhase = 0;
    STUB_TRACKING_INFO *        pTrackInfo = 0;

#endif

    ReturnValue.Pointer = 0;

#if !defined(_IA64_)
    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    //
    INIT_ARG( ArgList, pFormat);

    //
    // Get the address of the stack where the parameters are.
    //
    GET_FIRST_IN_ARG(ArgList);
    uchar *StartofStack = (uchar*)GET_STACK_START(ArgList);
#endif

    // StartofStack points to the virtual stack at this point.
    ProcNum = MulNdrpInitializeContextFromProc( XFER_SYNTAX_DCE, 
                                                pFormat, 
                                                &ProcContext, 
                                                StartofStack );
    //
    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        //
        // Use a nested try-except pair to support OLE. In OLE case, test the
        // exception and map it if required, then set the return value. In
        // nonOLE case, just reraise the exception.
        //
        RpcTryExcept
            {
            // Do this for the sake of the -Os client stubs.
            StubMsg.FullPtrXlatTables = 0;
            StubMsg.pContext = &ProcContext;
            StubMsg.StackTop = ProcContext.StartofStack;

            if ( ProcContext.IsObject )
                {
                pThis = *(void **)StartofStack;

                NdrProxyInitialize( pThis,
                                    &RpcMsg,
                                    &StubMsg,
                                    pStubDescriptor,
                                    ProcNum );
                }
            else
                {
                NdrClientInitializeNew( &RpcMsg,
                                        &StubMsg,
                                        pStubDescriptor,
                                        (uint) ProcNum );

                if ( ProcContext.HandleType )
                    {
                    //
                    // We have an implicit handle.
                    //
                    Handle = ImplicitBindHandleMgr( pStubDescriptor,
                                                    ProcContext.HandleType,
                                                    &ProcContext.SavedGenericHandle);
                    }
                else
                    {
                    Handle = ExplicitBindHandleMgr( pStubDescriptor,
                                                    StartofStack,
                                                    ProcContext.pHandleFormatSave,
                                                    &ProcContext.SavedGenericHandle );
                    }
                }

            NdrpClientInit( &StubMsg, &ReturnValue );

#if defined ( DEBUG_142065 )
    pTrackInfo = ( STUB_TRACKING_INFO *) I_RpcGetTrackSlot();   
    TrackStubPhase |= _STUB_CALCSIZE;
    if ( pTrackInfo )
        {
        memset( pTrackInfo, 0, sizeof( STUB_TRACKING_INFO ) );
        pTrackInfo->StubPhase |= _STUB_CALCSIZE;
        }
#endif


            //
            // Skip buffer size pass if possible.
            //
            if ( ProcContext.NdrInfo.pProcDesc->Oi2Flags.ClientMustSize  )
                {
                NdrpSizing( &StubMsg, TRUE );   // IsClient
                }
                // Compiler prevents variable size non-pipe args for NT v.4.0.


#if defined ( DEBUG_142065 )
    TrackStubPhase |= _STUB_GETBUFFER;
    if ( pTrackInfo )
        pTrackInfo->StubPhase |= _STUB_GETBUFFER;
#endif
            //
            // Do the GetBuffer.
            //
            if ( ProcContext.HasPipe )
                NdrGetPipeBuffer( &StubMsg,
                                  StubMsg.BufferLength,
                                  Handle );
            else
                {
                if ( ProcContext.IsObject )
                    NdrProxyGetBuffer( pThis,
                                       &StubMsg );
                else
                    {
                    if ( ProcContext.HandleType != FC_AUTO_HANDLE )
                        {
                        NdrGetBuffer( &StubMsg,
                                      StubMsg.BufferLength,
                                      Handle );
                        }
                    else
                        NdrNsGetBuffer( &StubMsg,
                                        StubMsg.BufferLength,
                                        Handle );
                    }
                }

#if defined ( DEBUG_142065 )
            if ( !pTrackInfo )
                {
                pTrackInfo = (STUB_TRACKING_INFO *)I_RpcGetTrackSlot();
                NDR_ASSERT( pTrackInfo, "thread info should be available now" );
                memset( pTrackInfo, 0, sizeof( STUB_TRACKING_INFO ) );
                }

            // pTrackInfo should be available unless this is OLE inproc case, even
            // that it's most likely rpc thread is initialized. 
            if ( pTrackInfo )
                {
                pTrackInfo->StubPhase = TrackStubPhase | _STUB_MARSHAL;
                pTrackInfo->pStubMsg = &StubMsg;
                memcpy( &pTrackInfo->RpcMsg, StubMsg.RpcMsg, sizeof( RPC_MESSAGE ) );           
                }
#endif
            NdrRpcSetNDRSlot( &StubMsg );

            NDR_ASSERT( StubMsg.fBufferValid, "Invalid buffer" );

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            NdrpClientMarshal( &StubMsg, ProcContext.IsObject );

#ifdef DEBUG_142065 
    if ( pTrackInfo )
        pTrackInfo->StubPhase |= _STUB_SENDRECEIVE;
#endif

            //
            // Make the RPC call.
            //

            if ( ProcContext.HasPipe )
                NdrPipeSendReceive( & StubMsg, ProcContext.pPipeDesc );
            else
                {
                if ( ProcContext.IsObject )
                    NdrProxySendReceive( pThis, &StubMsg );
                else
                    if ( ProcContext.HandleType != FC_AUTO_HANDLE )

                        NdrSendReceive( &StubMsg, StubMsg.Buffer );
                    else
                        NdrNsSendReceive( &StubMsg,
                                          StubMsg.Buffer,
                                          (RPC_BINDING_HANDLE*) pStubDescriptor
                                            ->IMPLICIT_HANDLE_INFO.pAutoHandle );
                }

#if defined ( DEBUG_142065 )
    if ( pTrackInfo )
        pTrackInfo->StubPhase |= _STUB_UNMARSHAL;
#endif

            NdrpClientUnMarshal( &StubMsg, &ReturnValue ); 

            }
        RpcExcept(  ProcContext.ExceptionFlag  )
            {

#if defined ( DEBUG_142065 )
    if ( pTrackInfo )
        {
        pTrackInfo->StubPhase |= _STUB_EXCEPTION;
        pTrackInfo->ExceptionCode = RpcExceptionCode();
        }
#endif
            
            if ( ProcContext.IsObject ) 
                NdrpDcomClientExceptionHandling( &StubMsg, ProcNum, RpcExceptionCode(), &ReturnValue);
            else
                NdrpClientExceptionHandling( &StubMsg, ProcNum, RpcExceptionCode(), &ReturnValue );

#if defined ( DEBUG_142065 )
    if ( pTrackInfo )
        pTrackInfo->StubPhase |= _STUB_AFTER_EXCEPTION;
#endif
            }
        RpcEndExcept
        }
    RpcFinally
        {
#if defined ( DEBUG_142065 )
    if ( pTrackInfo )
        pTrackInfo->StubPhase |= _STUB_FREE;
#endif
        
        NdrpClientFinally( &StubMsg, pThis );
        }
    RpcEndFinally

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cssup.cxx ===
/************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    cssup.cxx

Abstract :

    Support routines for international character (cs) support.

Author :

    Mike Warning    MikeW   August 1999.

Revision History :

  ***********************************************************************/

#include "ndrp.h"
#include "cssup.h"



BOOL GetThreadACP(
        unsigned long  *cp, 
        error_status_t *pStatus)
/*++

Routine Description :

    Get the current codepage of this thread.

Arguments :

    cp          -- Pointer to where to return the codepage
    pStatus     -- Pointer to where to return the status of the operation

Return :

    TRUE and RPC_S_OK if we we're able to determine the codepage, FALSE
    and a Win32 derived error code if not.

--*/
{
    CPINFOEX    info;

    if ( ! GetCPInfoEx( CP_THREAD_ACP, 0, &info ) )
        {
        *pStatus = HRESULT_FROM_WIN32( GetLastError() );
        return FALSE;
        }

    *pStatus = RPC_S_OK;
    *cp = info.CodePage;
    return TRUE;
}



ulong TranslateCodeset(
        ulong   Codeset)
/*++

Routine Description :

    Translate the given generic codeset value (CP_ACP, CP_OEMCP, or
    CP_THREAD_ACP) to it's true value.

Arguments :

    Codeset     -- The value to translate

Return :

    The true value.

--*/
{
    CPINFOEX    info;

    if ( ! GetCPInfoEx( Codeset, 0, &info ) )
        RpcRaiseException( HRESULT_FROM_WIN32( GetLastError () ) );

    return info.CodePage;
}


ulong
NdrpGetSetCSTagMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    NDR_CS_TAG_FORMAT * pTagFormat)
/*++

Routine Description :

    Extract the codeset referred to by pTagFormat and save it in the stub
    message for later buffer sizing / marshalling.

Arguments :

    pStubMsg        -- The stub message
    pMemory         -- (possibly) The pointer to the tag value
    pTagFormat      -- Pointer to FC_CS_TAG in the format string

Return :

    The codeset

--*/
{
    ulong               Codeset;

    InitializeStubCSInfo( pStubMsg );

    //
    // If there is no tag getting routine then the value of the tag is on
    // the stack like a normal parameter.  If there is a tag routine, then
    // the parameter is NOT on the stack (pMemory is invalid) and we need
    // to call the tag routine to get the value.
    //

    if ( NDR_INVALID_TAG_ROUTINE_INDEX == pTagFormat->TagRoutineIndex )
        {
        Codeset = * (ulong *) pMemory;
        }
    else
        {
        CS_TAG_GETTING_ROUTINE *TagRoutines;
        CS_TAG_GETTING_ROUTINE  GetTagRoutine;
        ulong                   SendingCodeset;
        ulong                   DesiredReceivingCodeset;
        ulong                   ReceivingCodeset;
        error_status_t          status;

        if ( ! pStubMsg->IsClient )

            DesiredReceivingCodeset = 
                            pStubMsg->pCSInfo->DesiredReceivingCodeset;

        TagRoutines = pStubMsg->StubDesc->CsRoutineTables->pTagGettingRoutines;

        GetTagRoutine = TagRoutines[ pTagFormat->TagRoutineIndex ];

        GetTagRoutine(
                pStubMsg->RpcMsg->Handle,
                ! pStubMsg->IsClient,
                &SendingCodeset,
                &DesiredReceivingCodeset,
                &ReceivingCodeset,
                &status );

        if ( RPC_S_OK != status )
            RpcRaiseException( status );

        if ( pTagFormat->Flags.STag )
            Codeset = SendingCodeset;
        else if ( pTagFormat->Flags.DRTag )
            Codeset = DesiredReceivingCodeset;
        else
            Codeset = ReceivingCodeset;
        }

    //
    // Don't allow generic psuedo codesets on the wire.  Translate them to
    // thier real values
    //
    // REVIEW: The is true for the standard sizing/translation routines but
    //         for user specified ones they should ideally be able to do
    //          anything they want.
    //

    if ( CP_ACP == Codeset || CP_OEMCP == Codeset || CP_THREAD_ACP == Codeset )
        Codeset = TranslateCodeset( Codeset );

    //
    // Save the values away in the stub message for array size/marshal/etc.
    //

    if ( pTagFormat->Flags.STag )
        pStubMsg->pCSInfo->WireCodeset = Codeset;

    if (pTagFormat->Flags.DRTag )
        pStubMsg->pCSInfo->DesiredReceivingCodeset = Codeset;

    return Codeset;
}


ulong
NdrpGetSetCSTagUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_CS_TAG_FORMAT * pTagFormat)
/*++

Routine Description :

    Extract the codeset in the buffer and save it in the stub
    message for later memory sizing / unmarshalling.

Arguments :

    pStubMsg        -- The stub message
    pTagFormat      -- Pointer to FC_CS_TAG in the format string

Return :

    The codeset

--*/
{
    ulong               Codeset;

    InitializeStubCSInfo( pStubMsg );

    Codeset = * (ulong *) pStubMsg->Buffer;

    if ( pTagFormat->Flags.STag && ! pStubMsg->IsClient )
        pStubMsg->pCSInfo->WireCodeset = Codeset;

    if ( pTagFormat->Flags.DRTag )
        pStubMsg->pCSInfo->DesiredReceivingCodeset = Codeset;

    if ( pTagFormat->Flags.RTag && pStubMsg->IsClient )
        pStubMsg->pCSInfo->WireCodeset = Codeset;

    return Codeset;
}


void GenericBufferSize(
        unsigned long     DestCodeSet,
        unsigned long     SourceCodeSet,
        unsigned long     SourceBufferSize,
        IDL_CS_CONVERT *  ConversionType,
        unsigned long  *  DestBufferSize,
        error_status_t *  status)
/*++

Routine Description :

    Estimate the length of the buffer needed to hold [SourceBufferSize]
    characters if they we're translated into [DestCodeSet].

Arguments :

    DestCodeSet         - The codeset that the data will be translated to
    SourceCodeSet       - The source codeset
    SourceBufferSize    - The number of characters in the source codeset
    ConversionType      - Returns whether or not conversion is needed
    DestBufferSize      - Where to put the estimated buffer size
    status              - The return status

--*/
{
    int DestMaxCharSize;

    *status = NO_ERROR;

    // Determine the maximum size of a character on the wire in bytes

    if ( CP_UNICODE == DestCodeSet )
        {
        DestMaxCharSize = 2;
        }
    else
        {
        CPINFO cpinfo;

        if ( ! GetCPInfo( DestCodeSet, &cpinfo ) )
            {
            *status = HRESULT_FROM_WIN32( GetLastError() );
            return;
            }
        DestMaxCharSize = cpinfo.MaxCharSize;
        }

    // Worst case: each char in the local buffer expands to the maximum number
    // of bytes for a char in the network codeset

    if ( NULL != DestBufferSize )
        *DestBufferSize = SourceBufferSize * DestMaxCharSize;

    if ( SourceCodeSet == DestCodeSet )
        *ConversionType = IDL_CS_NO_CONVERT;
    else
        *ConversionType = IDL_CS_NEW_BUFFER_CONVERT;
}



void RPC_ENTRY
cs_byte_net_size(
        RPC_BINDING_HANDLE  hBinding,
        unsigned long       NetworkCodeSet,
        unsigned long       LocalBufferSize,
        IDL_CS_CONVERT  *   ConversionType,
        unsigned long   *   NetworkBufferSize,
        error_status_t  *   status)
/*++

Routine Description :

    Estimate the length of the buffer needed to hold [LocalBufferSize]
    characters if they are translated from the current thread codeset 
    into [NetworkCodeSet].

Arguments :

    hBinding            - The RPC binding handle 
    NetworkCodeSet      - The codeset that the data will be translated to
    LocalBufferSize     - The number of bytes in the data
    ConversionType      - Returns whether the conversion can be done inplace
    NetworkBufferSize   - Where to put the estimated buffer size
    status              - The return status

--*/
{
    ulong   LocalCP;

    if ( ! GetThreadACP( &LocalCP, status ) )
        return;

    // No conversion is necessary if the local and destination codesets are
    // the same.

    GenericBufferSize(
            NetworkCodeSet,
            LocalCP,
            LocalBufferSize,
            ConversionType,
            NetworkBufferSize,
            status);
}



void RPC_ENTRY
wchar_t_net_size(
        RPC_BINDING_HANDLE  hBinding,
        unsigned long       NetworkCodeSet,
        unsigned long       LocalBufferSize,
        IDL_CS_CONVERT  *   ConversionType,
        unsigned long   *   NetworkBufferSize,
        error_status_t  *   status)
/*++

Routine Description :

    Estimate the length of the buffer needed to hold [LocalBufferSize]
    characters if they are translated from the current thread codeset 
    into [NetworkCodeSet].

Arguments :

    hBinding            - The RPC binding handle 
    NetworkCodeSet      - The codeset that the data will be translated to
    LocalBufferSize     - The number of bytes in the data
    ConversionType      - Returns whether the conversion can be done inplace
    NetworkBufferSize   - Where to put the estimated buffer size
    status              - The return status

--*/
{
    ulong   LocalCP = CP_UNICODE;

    GenericBufferSize(
            NetworkCodeSet,
            LocalCP,
            LocalBufferSize,
            ConversionType,
            NetworkBufferSize,
            status);
}



void RPC_ENTRY
cs_byte_local_size(
        RPC_BINDING_HANDLE  hBinding,
        unsigned long       NetworkCodeSet,
        unsigned long       NetworkBufferSize,
        IDL_CS_CONVERT  *   ConversionType,
        unsigned long   *   LocalBufferSize,
        error_status_t  *   status)
/*++

Routine Description :

    Estimate the length of the buffer needed to hold [NetworkBufferSize]
    characters if they are translated from [NetworkCodeSet] to the local
    thread codeset.

Arguments :

    hBinding            - The RPC binding handle 
    NetworkCodeSet      - The codeset that the data will be translated to
    NetworkBufferSize   - The number of bytes in the data
    ConversionType      - Returns whether the conversion can be done inplace
    LocalBufferSize     - Where to put the estimated buffer size
    status              - The return status

--*/
{
    ulong       LocalCP;

    if ( ! GetThreadACP(&LocalCP, status) )
        return;

    // In Unicode the minimum character size is 2 so we can save a bit of 
    // memory cutting the apparent source buffer size

    if ( CP_UNICODE == NetworkCodeSet )
        NetworkBufferSize /= 2;

    GenericBufferSize(
                LocalCP,
                NetworkCodeSet,
                NetworkBufferSize,
                ConversionType,
                LocalBufferSize,
                status);    
}


void RPC_ENTRY
wchar_t_local_size(
        RPC_BINDING_HANDLE  hBinding,
        unsigned long       NetworkCodeSet,
        unsigned long       NetworkBufferSize,
        IDL_CS_CONVERT  *   ConversionType,
        unsigned long   *   LocalBufferSize,
        error_status_t  *   status)
/*++

Routine Description :

    Estimate the length of the buffer needed to hold [NetworkBufferSize]
    characters if they are translated from [NetworkCodeSet] to the local
    thread codeset.

Arguments :

    hBinding            - The RPC binding handle 
    NetworkCodeSet      - The codeset that the data will be translated to
    NetworkBufferSize   - The number of bytes in the data
    ConversionType      - Returns whether the conversion can be done inplace
    LocalBufferSize     - Where to put the estimated buffer size
    status              - The return status

--*/
{
    ulong       LocalCP = CP_UNICODE;

    // In Unicode the minimum character size is 2 so we can save a bit of
    // memory cutting the apparent source buffer size

    if ( CP_UNICODE == NetworkCodeSet )
        NetworkBufferSize /= 2;

    // No conversion is necessary if the local and destination codesets are
    // the same.

    GenericBufferSize(
                LocalCP,
                NetworkCodeSet,
                NetworkBufferSize,
                ConversionType,
                LocalBufferSize,
                status);
}



void GenericCSConvert(
            unsigned long       DestCodeSet,
            void               *DestData,
            unsigned long       DestBufferSize,
            unsigned long       SourceCodeSet,
            void               *SourceData,
            unsigned long       SourceBufferSize,
            unsigned long      *BytesWritten,
            error_status_t     *status)
/*++

Routine Description :

    Convert data from one character encoding to another.

Arguments :

    DestCodeSet         - The target encoding
    DestData            - The target buffer
    DestBufferSize      - The size of the target buffer in bytes
    SourceCodeset       - The source encoding
    SourceData          - The source data
    SourceBufferSize    - The size of the source data in bytes
    BytesWritten        - The number of bytes written to the target buffer
    status              - The return status

--*/
{
    wchar_t        *TempBuffer = NULL;
    ulong           BytesWrittenBuffer;

    *status = RPC_S_OK;

    // BytesWritten can be NULL in various circumstances.  Make the following
    // code a bit more generic by making sure it always points at something.

    if ( NULL == BytesWritten )
        BytesWritten = &BytesWrittenBuffer;

    // If the source and destination code sets are the same, just memcpy.
    // If there are 0 bytes in the source we don't need to do anything.

    if ( DestCodeSet == SourceCodeSet || 0 == SourceBufferSize)
        {
        if ( DestBufferSize < SourceBufferSize )
            {
            *status = RPC_S_BUFFER_TOO_SMALL;
            return;
            }

        CopyMemory( DestData, SourceData, SourceBufferSize );
        *BytesWritten = SourceBufferSize;
        return;
        }

    // We can't convert from a non-Unicode codeset to a different non-Unicode
    // codeset in one go, we have to convert to Unicode first.  So regardless
    // of what the destionation is supposed to be make the source Unicode.

    if ( CP_UNICODE != SourceCodeSet )
        {
        ulong   TempBufferSize;

        if ( CP_UNICODE != DestCodeSet )
            {
            TempBufferSize = SourceBufferSize * 2;
            TempBuffer = (wchar_t *) I_RpcAllocate( TempBufferSize );

            if ( NULL == TempBuffer )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );
            }
        else
            {
            TempBufferSize = DestBufferSize;
            TempBuffer = (wchar_t *) DestData;
            }

        *BytesWritten = MultiByteToWideChar(
                                    SourceCodeSet,
                                    0,
                                    (char *) SourceData,
                                    SourceBufferSize,
                                    TempBuffer,
                                    TempBufferSize / 2 );

        if ( 0 == *BytesWritten )
            *status = GetLastError();

        *BytesWritten    *= 2;
        SourceData        = TempBuffer;
        SourceBufferSize  = *BytesWritten;
        }

    // Convert to the destination codeset if it's not Unicode.  

    if ( RPC_S_OK == *status && CP_UNICODE != DestCodeSet )
        {
        *BytesWritten = WideCharToMultiByte(
                                DestCodeSet,
                                0,
                                (wchar_t *) SourceData,
                                SourceBufferSize / 2,
                                (char *) DestData,
                                DestBufferSize,
                                NULL,
                                NULL);

        if ( 0 == *BytesWritten )
            *status = HRESULT_FROM_WIN32( GetLastError() );
    }

    if ( TempBuffer != DestData )
        I_RpcFree( TempBuffer );
}


void RPC_ENTRY
cs_byte_to_netcs(
        RPC_BINDING_HANDLE  hBinding,
        unsigned long       NetworkCodeSet,
        cs_byte         *   LocalData,
        unsigned long       LocalDataLength,
        byte            *   NetworkData,
        unsigned long   *   NetworkDataLength,
        error_status_t  *   status)
/*++

Routine Description :

    Convert data from the current thread codeset to the network codeset

Arguments :

    hBinding            - The RPC binding handle
    NetworkCodeSet      - The target codeset
    LocalData           - The source data
    LocalDataLength     - The size of the source data in bytes
    NetworkData         - The target buffer
    NetworkDataLength   - The number of bytes written to the target buffer
    status              - The return status

--*/
{
    unsigned long   LocalCP;

    if ( ! GetThreadACP( &LocalCP, status ) )
        return;

    // 
    // For reasons known only to the gods, DCE didn't think it important to
    // include the size of the destination buffer as a parameter.  It 
    // *shouldn't* be an issue because in theory XXX_net_size was called to
    // properly size the buffer.  Just to be inconsistent, they did include
    // it in XXX_from_netcs. 
    //

    GenericCSConvert(
            NetworkCodeSet,
            NetworkData,
            INT_MAX,
            LocalCP,
            LocalData,
            LocalDataLength,         
            NetworkDataLength,
            status);
}



void RPC_ENTRY
wchar_t_to_netcs(
        RPC_BINDING_HANDLE  hBinding,
        unsigned long       NetworkCodeSet,
        wchar_t         *   LocalData,
        unsigned long       LocalDataLength,
        byte            *   NetworkData,
        unsigned long   *   NetworkDataLength,
        error_status_t  *   status)
/*++

Routine Description :

    Convert data from Unicode to the network codeset

Arguments :

    hBinding            - The RPC binding handle
    NetworkCodeSet      - The target codeset
    LocalData           - The source data
    LocalDataLength     - The size of the source data in bytes
    NetworkData         - The target buffer
    NetworkDataLength   - The number of bytes written to the target buffer
    status              - The return status

--*/
{
    unsigned long   LocalCP = CP_UNICODE;

    // 
    // For reasons known only to the gods, DCE didn't think it important to
    // include the size of the destination buffer as a parameter.  It 
    // *shouldn't* be an issue because in theory XXX_net_size was called to
    // properly size the buffer.  Just to be inconsistent, they did include
    // it in XXX_from_netcs. 
    //

    GenericCSConvert(
            NetworkCodeSet,
            NetworkData,
            INT_MAX,
            LocalCP,
            LocalData,
            LocalDataLength * 2,         // We want bytes not chars
            NetworkDataLength,
            status);
}



void RPC_ENTRY
cs_byte_from_netcs(
        RPC_BINDING_HANDLE  hBinding,
        unsigned long       NetworkCodeSet,
        cs_byte         *   NetworkData,
        unsigned long       NetworkDataLength,
        unsigned long       LocalDataBufferSize,
        byte            *   LocalData,
        unsigned long   *   LocalDataLength,
        error_status_t  *   status)
/*++

Routine Description :

    Convert data from the network codeset to the current thread codeset 

Arguments :

    hBinding            - The RPC binding handle
    NetworkCodeSet      - The source codeset
    NetworkData         - The source data
    NetworkDataLength   - The size of the source data in bytes
    LocalDataBufferSize - the size of the target buffer in bytes
    LocalData           - The target buffer
    LocalDataLength     - The number written to the target buffer
    status              - The return status

--*/
{
    unsigned long   LocalCP;

    if ( ! GetThreadACP( &LocalCP, status ) )
        return;

    GenericCSConvert(
            LocalCP,
            LocalData,
            LocalDataBufferSize,         
            NetworkCodeSet,
            NetworkData,
            NetworkDataLength,
            LocalDataLength,
            status);
}



void RPC_ENTRY
wchar_t_from_netcs(
        RPC_BINDING_HANDLE  hBinding,
        unsigned long       NetworkCodeSet,
        wchar_t         *   NetworkData,
        unsigned long       NetworkDataLength,
        unsigned long       LocalDataBufferSize,
        byte            *   LocalData,
        unsigned long   *   LocalDataLength,
        error_status_t  *   status)
/*++

Routine Description :

    Convert data from the network codeset to the current thread codeset 

Arguments :

    hBinding            - The RPC binding handle
    NetworkCodeSet      - The source codeset
    NetworkData         - The source data
    NetworkDataLength   - The size of the source data in bytes
    LocalDataBufferSize - the size of the target buffer in bytes
    LocalData           - The target buffer
    LocalDataLength     - The number written to the target buffer
    status              - The return status

--*/
{
    unsigned long   LocalCP = CP_UNICODE;

    GenericCSConvert(
            LocalCP,
            LocalData,
            LocalDataBufferSize * 2,    // Bytes not chars
            NetworkCodeSet,
            NetworkData,
            NetworkDataLength,
            LocalDataLength,
            status);

    if ( LocalDataLength )
        *LocalDataLength /= 2;          // Chars not bytes
}



void RPC_ENTRY
RpcCsGetTags(
     handle_t         hBinding,
     int              ServerSide,
     unsigned long *  SendingTag,
     unsigned long *  DesiredReceivingTag,
     unsigned long *  ReceivingTag,
     error_status_t * status)
/*++

Routine Description :

    Determine the codesets to use

Arguments :

    hBinding            - The RPC binding handle
    ServerSide          - FALSE if this is the client
    SendingTag          - Pointer to the returned sending tag
    DesiredReceivingTag - Pointer to the returned desired receiving tag
    ReceivingTag        - Pointer to the returned receiving tag
    status              - The return status

Notes :

    On the server side, DesiredReceivingTag is an input instead of an output.
    The ReceivingTag will be set to this value.

--*/
{
    ulong   Codeset;

    if ( ! GetThreadACP( &Codeset, status ) )
        return;

    if ( SendingTag )
        * SendingTag = Codeset;

    if ( DesiredReceivingTag && ! ServerSide )
        * DesiredReceivingTag = Codeset;

    if ( ReceivingTag )
        {
        if ( ServerSide && DesiredReceivingTag )
            * ReceivingTag = * DesiredReceivingTag;
        else
            * ReceivingTag = Codeset;
        }
    
    * status = RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\bufsize.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    bufsize.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the 
    interpreter for computing the buffer size needed for a parameter.  

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

RPCRTAPI
void RPC_ENTRY
NdrUDTSimpleTypeSize( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char *         pMemory,
    PFORMAT_STRING          pFormat
    );

extern const
PSIZE_ROUTINE   SizeRoutinesTable[] =
                {
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                NdrUDTSimpleTypeSize,
                
                NdrPointerBufferSize,
                NdrPointerBufferSize,
                NdrPointerBufferSize,
                NdrPointerBufferSize,

                NdrSimpleStructBufferSize,
                NdrSimpleStructBufferSize,
                NdrConformantStructBufferSize,
                NdrConformantStructBufferSize,
                NdrConformantVaryingStructBufferSize,

                NdrComplexStructBufferSize,

                NdrConformantArrayBufferSize,
                NdrConformantVaryingArrayBufferSize,
                NdrFixedArrayBufferSize,
                NdrFixedArrayBufferSize,
                NdrVaryingArrayBufferSize,
                NdrVaryingArrayBufferSize,

                NdrComplexArrayBufferSize,

                NdrConformantStringBufferSize,
                NdrConformantStringBufferSize,
                NdrConformantStringBufferSize,
                NdrConformantStringBufferSize,

                NdrNonConformantStringBufferSize,
                NdrNonConformantStringBufferSize,
                NdrNonConformantStringBufferSize,
                NdrNonConformantStringBufferSize,

                NdrEncapsulatedUnionBufferSize,
                NdrNonEncapsulatedUnionBufferSize,
    
                NdrByteCountPointerBufferSize,

                NdrXmitOrRepAsBufferSize,  // transmit as
                NdrXmitOrRepAsBufferSize,  // represent as

                NdrPointerBufferSize,

                NdrContextHandleSize,

                // New Post NT 3.5 token serviced from here on.

                0,                         // NdrHardStructBufferSize,

                NdrXmitOrRepAsBufferSize,  // transmit as ptr
                NdrXmitOrRepAsBufferSize,  // represent as ptr

                NdrUserMarshalBufferSize,

                0,   // FC_PIPE 
                0,   // FC_BLK_HOLE

                NdrpRangeBufferSize,

                0,   // FC_INT3264
                0,   // FC_UINT3264

                0, // NdrCsArrayBufferSize,
                0, // NdrCsTagBufferSize
                };

const
PSIZE_ROUTINE * pfnSizeRoutines = SizeRoutinesTable;

void
NdrpInterfacePointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat );

RPCRTAPI
void RPC_ENTRY
NdrTypeSize( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char *         pMemory,
    PFORMAT_STRING          pFormat
    )
{
    (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                 pMemory,
                                                 pFormat );
}


void RPC_ENTRY
NdrUDTSimpleTypeSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Get the size a top level or embedded simple type.

    Used for VT_USERDEFINED but in fact simple types,
    like TKIND_ENUM and TKIND_ALIAS

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN( pStubMsg->BufferLength,
                  SIMPLE_TYPE_ALIGNMENT(*pFormat) );

    pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE(*pFormat);

    pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
}



void RPC_ENTRY
NdrPointerBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the needed buffer size for a top level pointer to anything.
    Pointers embedded in structures, arrays, or unions call 
    NdrpPointerBufferSize directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    //
    // Add 4 bytes for a unique or full pointer.
    //
    if ( *pFormat != FC_RP )
        {
        LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

        pStubMsg->BufferLength += PTR_WIRE_SIZE;
        }

    NdrpPointerBufferSize( pStubMsg,
                           pMemory,
                           pFormat );
}
    

__forceinline void 
NdrpPointerBufferSizeInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for sizing a pointee.  This is the entry
    point for pointers embedded in structures, arrays, or unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.
    
    pStubMsg->BufferLength - ready for the pointee.

Return :

    None.

--*/
{

    if ( FC_IP == *pFormat )
        {

        if ( IS_BROKEN_INTERFACE_POINTER(pStubMsg->uFlags) )
            {
            // The pointee is effectivly both the pointer
            // and the pointee.

            NdrInterfacePointerBufferSize( 
                pStubMsg,
                pMemory,
                pFormat );
            return;
            }

        if ( ! pMemory )
            return;

        NdrpInterfacePointerBufferSize( pStubMsg,
                                        pMemory,
                                        pFormat );
        return;
        }

    uchar   uFlagsSave;

    if ( ! pMemory )
        return;

    if ( *pFormat == FC_FP )
        {
        //
        // Check if we have already sized this full pointer.
        //
        if ( NdrFullPointerQueryPointer( pStubMsg->FullPtrXlatTables,
                                         pMemory,
                                         FULL_POINTER_BUF_SIZED,
                                         0 ) )
            return;
        }

    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        //
        // Pointer to complex type.
        //
        if ( POINTER_DEREF(pFormat[1]) )
            pMemory = *((uchar **)pMemory);

        pFormat += 2;

        pFormat += *((signed short *)pFormat);
        }
    else
        {
        switch ( pFormat[2] )
            {
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :
                // Increment to the string description.
                pFormat += 2;
                break;
    
            default :
                //
                // Pointer to simple type.  Make an upper bound estimate.
                //
                SIMPLE_TYPE_BUF_INCREMENT(pStubMsg->BufferLength, pFormat[2]);
                return;
            }
        }

    uFlagsSave = pStubMsg->uFlags;
    RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                 pMemory,
                                                 pFormat );
    pStubMsg->uFlags = uFlagsSave;
}

NDR_BUFSIZE_POINTER_QUEUE_ELEMENT::NDR_BUFSIZE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :

        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags)
{

}

void 
NDR_BUFSIZE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0\n");

    NdrpPointerBufferSizeInternal( pStubMsg,
                                   pMemory,
                                   pFormat );
}                          

#if defined(DBG)
void 
NDR_BUFSIZE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );
}
#endif

void
NdrpEnquePointerBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
   NDR32_POINTER_CONTEXT PointerContext( pStubMsg );

   RpcTryFinally
   {
       NDR_BUFSIZE_POINTER_QUEUE_ELEMENT *pElement = 
           new(PointerContext.GetActiveState()) 
               NDR_BUFSIZE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                 pMemory,
                                                 pFormat);
       PointerContext.Enque( pElement );
       PointerContext.DispatchIfRequired();

   }
   RpcFinally
   {
       PointerContext.EndContext();
   }
   RpcEndFinally

}

void
NdrpPointerBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{

    if ( !NdrIsLowStack( pStubMsg ) )
        {
        NdrpPointerBufferSizeInternal( pStubMsg,
                                       pMemory,
                                       pFormat );
        return;
        }

    NdrpEnquePointerBufferSize(
        pStubMsg,
        pMemory,
        pFormat );

}


void RPC_ENTRY
NdrpRangeBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a simple type with range on it.
    Used for FC_RANGE.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    // This routine is needed because the precomputed buf size is missing in some cases.
    // So it is cheaper to have the routine than to change code paths elsewhere.

    FORMAT_CHARACTER    FcType = (FORMAT_CHARACTER)(pFormat[1] & 0x0f);

    LENGTH_ALIGN( pStubMsg->BufferLength, SIMPLE_TYPE_ALIGNMENT(FcType) );
    pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE(FcType);
}


void RPC_ENTRY
NdrSimpleStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,pFormat[1]);

    // Add size of the structure.
    pStubMsg->BufferLength += (ulong) *((ushort *)(pFormat + 2));  

    //
    // Add size of embedded pointers.
    //
    if ( *pFormat == FC_PSTRUCT ) 
        {
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory, 
                                       pFormat + 4 );
        }
}


void RPC_ENTRY
NdrConformantStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a conformant structure.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatArray;
    ulong           FlatSize;

    // set by the embedding complex struct
    uchar           fIsEmbeddedStructSave = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    // accounted for by the outermost embedding complex struct
    if ( !fIsEmbeddedStructSave )
        {
        // Align and add size for conformance count.
        LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

        pStubMsg->BufferLength += 4;
        }
    
    // Align 
    LENGTH_ALIGN(pStubMsg->BufferLength, pFormat[1] );

    FlatSize = (ulong) *((ushort *)(pFormat + 2));

    pStubMsg->BufferLength += FlatSize;

    // Increment to the offset to array description.
    pFormat += 4;

    pFormatArray = pFormat + *((signed short *)pFormat);

    //
    // Size our array - pass a memory pointer to the conformant array.
    //
    NdrpConformantArrayBufferSize( pStubMsg,
                                   pMemory + FlatSize,
                                   pFormatArray );

    pFormat += 2;

    if ( *pFormat == FC_PP )  
        {
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }

    // Set the reverse flag to signal that array has been marshaled.

    if ( fIsEmbeddedStructSave )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
}


void RPC_ENTRY
NdrConformantVaryingStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a conformant varying structure.

    Used for FC_CVSTRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    PPRIVATE_SIZE_ROUTINE   pfnSize;
    PFORMAT_STRING          pFormatArray;
    ulong                   FlatSize;

    // set by the outermost embedding complex struct
    uchar                   fIsEmbeddedStructSave = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    // accounted for by the outermost embedding complex struct
    if ( !fIsEmbeddedStructSave )
        {
        // Align
        LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

        pStubMsg->BufferLength += 4;
        }

    // Align 
    LENGTH_ALIGN(pStubMsg->BufferLength, pFormat[1] );

    FlatSize = (ulong) *((ushort *)(pFormat + 2));

    pStubMsg->BufferLength += FlatSize;

    // Increment to the offset to array description.
    pFormat += 4;

    pFormatArray = pFormat + *((signed short *)pFormat);

    switch ( *pFormatArray ) 
        {
        case FC_CVARRAY :
            pfnSize = NdrpConformantVaryingArrayBufferSize;
            break;
        default :
            pfnSize = NdrpConformantStringBufferSize;
            break;
        }

    (*pfnSize)( pStubMsg,
                pMemory + FlatSize,
                pFormatArray );

    pFormat += 2;

    if ( *pFormat == FC_PP ) 
        {
        pStubMsg->MaxCount = pStubMsg->ActualCount;
        
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }

    // Set the reverse flag to signal that array has been marshaled.

    if ( fIsEmbeddedStructSave )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
}


#if 0
void RPC_ENTRY
NdrHardStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a hard structure.

    Used for FC_HARD_STRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,pFormat[1]);

    pStubMsg->BufferLength += *((ushort *)&pFormat[10]);

    if ( *((short *)&pFormat[14]) )
        {
        pFormat += 12;

        pMemory += *((ushort *)pFormat)++;

        pFormat += *((short *)pFormat);

        (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
        }
}
#endif // 0

void RPC_ENTRY
NdrComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{

    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatComplex;
    long            Alignment;
    long            Align8Mod;
    BOOL            fEmbedConfStructContext;
    uchar*          pMemoryLoop;
    PFORMAT_STRING  pFormatLoop;

    uchar           fIsEmbeddedStructSave = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    uchar *         pMemorySave = pStubMsg->Memory;

    //
    // If were not ignoring pointees and the the stub message PointerBufferMark field is 0, 
    // then determine the position in the buffer where pointees will be marshalled.
    //
    // We have to do this to handle embedded pointers.
    //

    bool  fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                  !pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {

        pStubMsg->IgnoreEmbeddedPointers = TRUE;
        ulong BufferLengthSave = pStubMsg->BufferLength;
        
        NdrComplexStructBufferSize( pStubMsg,
                                    pMemory,
                                    pFormat );

        // If the size of the flat part is zero and this is the first item to be
        // marshalled, add a small offset to the buffer so that we can continue
        // to use PointerBufferMark as an is embedded flag.
        if ( !pStubMsg->BufferLength) 
            {
            pStubMsg->BufferLength      += NDR_MAX_BUFFER_ALIGNMENT;
            BufferLengthSave            += NDR_MAX_BUFFER_ALIGNMENT;
            }

        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        pStubMsg->PointerBufferMark = (uchar *) UlongToPtr(pStubMsg->BufferLength);
        pStubMsg->BufferLength = BufferLengthSave;
        
        }

    //
    // This is used when computing the count(s) for size_is or length_is
    // pointers.
    //
    pStubMsg->Memory = pMemory;

    Alignment = pFormat[1];

    //
    // This is used for support of structs with doubles passed on an
    // i386 stack, and of struct with longs on 16 bit platforms.
    //
    // A cast to long is what we need.
    Align8Mod = 0x7 & PtrToLong( pMemory );

    pFormat += 4;

    fEmbedConfStructContext = fIsEmbeddedStructSave;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        {
        pFormatArray = pFormat + *((signed short *)pFormat);

        // mark Complex struct embedding Conformant struct case
        if ( FixWireRepForDComVerGTE54( pStubMsg ) )
            fEmbedConfStructContext = TRUE;

        // accounted for by the outermost embedding complex struct
        if ( !fIsEmbeddedStructSave )
            {
            //
            // Align and add size of conformance count(s).
            //
            LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
        
            pStubMsg->BufferLength += 4 * NdrpArrayDimensions( pStubMsg,
                                                              pFormatArray,
                                                              FALSE);
            }
        }
    else
        pFormatArray = 0;

    RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    // save variables for second loop
    pMemoryLoop = pMemory;
    pFormatLoop = pFormat;

    LENGTH_ALIGN(pStubMsg->BufferLength,Alignment);
    //
    // size the structure member by member.
    //
    for ( ; *pFormat != FC_END; pFormat++ ) 
        {
        switch ( *pFormat ) 
            {
            //
            // simple types
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264:
            case FC_UINT3264:
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
            case FC_IGNORE :
                LENGTH_ALIGN( pStubMsg->BufferLength,
                              SIMPLE_TYPE_ALIGNMENT(*pFormat) );
                pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE(*pFormat);
                pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_POINTER :
                LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
                pStubMsg->BufferLength += PTR_WIRE_SIZE;
                
                if ( !pStubMsg->IgnoreEmbeddedPointers )
                    {
                    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

                    NdrpPointerBufferSize( pStubMsg,
                                           *((uchar **)pMemory),
                                           pFormatPointers );
                    }

                pFormatPointers += 4;
                pMemory += PTR_MEM_SIZE;
                break;

            //
            // Embedded complex types.
            //
            case FC_EMBEDDED_COMPLEX :
                // Add padding.
                pMemory += pFormat[1];

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( FC_IP == *pFormatComplex ) 
                    {
                    // Treat embedded interface pointers the same as regular pointers.

                    LENGTH_ALIGN( pStubMsg->BufferLength, 0x3 );
                    pStubMsg->BufferLength += PTR_WIRE_SIZE;

                    if ( !pStubMsg->IgnoreEmbeddedPointers ) 
                        {
                        POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

                        NdrpPointerBufferSize( pStubMsg,
                                               *((uchar **)pMemory),
                                               pFormatComplex);
                        }
                    pMemory += PTR_MEM_SIZE;
                    pFormat++;
					break;

                    }

                // Needed for embedded conf structs
                //
                if ( fEmbedConfStructContext )
                    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                (*pfnSizeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  pMemory,
                  pFormatComplex );

                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormatComplex );

                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                //
                // Increment the main format string one byte.  The loop 
                // will increment it one more byte past the offset field.
                //
                pFormat++;

                break;

            case FC_ALIGNM2 :
                ALIGN( pMemory, 0x1 );
                break;

            case FC_ALIGNM4 :
                ALIGN( pMemory, 0x3 );
                break;

            case FC_ALIGNM8 :
                //
                // We have to play some tricks for the i386 to handle the case
                // when an 8 byte aligned structure is passed by value.  The
                // alignment of the struct on the stack is not guaranteed to be
                // on an 8 byte boundary.
                //
                pMemory -= Align8Mod;
                ALIGN( pMemory, 0x7 );
                pMemory += Align8Mod;

                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                pMemory += (*pFormat - FC_STRUCTPAD1) + 1; 
                break;
            
            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pMemory += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;


            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                break;

            default :
                NDR_ASSERT(0,"NdrComplexStructBufferSize : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            } // switch 
        } // for

    //
    // Size any conformant array.
    //
    // accounted for by the outermost embedding complex struct
    // .. but not when embedded and not when array done by an embeded conf struct.

    if ( pFormatArray && !fIsEmbeddedStructSave  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PPRIVATE_SIZE_ROUTINE   pfnSize;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnSize = NdrpConformantArrayBufferSize;
                break;

            case FC_CVARRAY :
                pfnSize = NdrpConformantVaryingArrayBufferSize;
                break;

            case FC_BOGUS_ARRAY :
                pfnSize = NdrpComplexArrayBufferSize;
                break;

            // case FC_C_WSTRING :
            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_SSTRING :
            default :
                pfnSize = NdrpConformantStringBufferSize;
                break;
            }

        (*pfnSize)( pStubMsg,
                    pMemory,
                    pFormatArray );
        }

    if ( fIsEmbeddedStructSave )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    pStubMsg->Memory = pMemorySave;

    if ( fSetPointerBufferMark )
        {
        pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
        pStubMsg->PointerBufferMark = NULL;
        }
}


void RPC_ENTRY
NdrFixedArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a fixed array of any number of 
    dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,pFormat[1]);

    if ( *pFormat == FC_SMFARRAY )  
        {
        pFormat += 2;
        pStubMsg->BufferLength += *((ushort *&)pFormat)++; 
        }
    else
        {
        pFormat += 2;
        pStubMsg->BufferLength += *((ulong UNALIGNED *&)pFormat)++;
        }

    if ( *pFormat == FC_PP ) 
        {
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }
}


void RPC_ENTRY
NdrConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level one dimensional conformant 
    array.

    Used for FC_CARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    //
    // Align and add size for conformance count.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 4;

    NdrpConformantArrayBufferSize( pStubMsg,
                                   pMemory,
                                   pFormat );
}


void 
NdrpConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a one dimensional 
    conformant array.  This is the entry point for unmarshalling an embedded 
    conformant array.

    Used for FC_CARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ulong   ConformanceCount;

    ConformanceCount = (ulong) NdrpComputeConformance( pStubMsg, 
                                                       pMemory, 
                                                       pFormat );

    if ( ((long)ConformanceCount) < 0 )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if ( ! ConformanceCount ) 
        return;

    LENGTH_ALIGN(pStubMsg->BufferLength,pFormat[1]);

    pFormat += 2;

    // Add array size.
    pStubMsg->BufferLength += *((ushort *)pFormat) * ConformanceCount;

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP ) 
        {
        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }
}


void RPC_ENTRY
NdrConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level one dimensional conformant
    varying array.

    Used for FC_CVARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    //
    // Align and add size for conformance count.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 4;

    NdrpConformantVaryingArrayBufferSize( pStubMsg,
                                          pMemory,
                                          pFormat );
}


void
NdrpConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a one dimensional 
    conformant varying array. This is the entry point for buffer sizing an 
    embedded conformant varying array.

    Used for FC_CVARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ulong   ConformanceCount;

    //
    // Align and add size for offset and actual count.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 8;

    NdrpComputeVariance( pStubMsg, 
                         pMemory, 
                         pFormat );

    // Check if the bounds are valid

    ConformanceCount = (ulong) NdrpComputeConformance( pStubMsg, 
                                                       pMemory, 
                                                       pFormat );

    if ( ( ((long)ConformanceCount) < 0 ) ||
         ( ((long)pStubMsg->ActualCount) < 0 ) ||
         ( ((long)pStubMsg->Offset) < 0 ) ||
         ( (pStubMsg->Offset + pStubMsg->ActualCount) > ConformanceCount ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if ( ! pStubMsg->ActualCount ) 
        return;

    LENGTH_ALIGN(pStubMsg->BufferLength, pFormat[1]);

    pFormat += 2;

    // Add array size.
    pStubMsg->BufferLength += *((ushort *)pFormat) * pStubMsg->ActualCount;

    pFormat += 10;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP ) 
        {
        //
        // MaxCount must contain the number of shipped elements in the array
        // before sizing embedded pointers.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }
}


void RPC_ENTRY
NdrVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level or embedded one 
    dimensional varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

Arguments : 

    pMemory     - pointer to the parameter to size
    pFormat     - pointer to the format string description of the parameter

--*/
{
    ulong   Elements;
    ulong   ElementSize;

    //
    // Align and add size for offset and actual count.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 8;

    NdrpComputeVariance( pStubMsg, 
                         pMemory, 
                         pFormat );

    // Check if the bounds are valid

    Elements = 
        (*pFormat == FC_SMVARRAY) ? 
        *((ushort *)(pFormat + 4)) : *((ulong UNALIGNED *)(pFormat + 6));

    if ( ( ((long)pStubMsg->ActualCount) < 0 ) ||
         ( ((long)pStubMsg->Offset) < 0 ) ||
         ( (pStubMsg->Offset + pStubMsg->ActualCount) > Elements ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if ( ! pStubMsg->ActualCount )
        return;

    LENGTH_ALIGN(pStubMsg->BufferLength, pFormat[1]);

    if (*pFormat == FC_SMVARRAY) 
        {
        ElementSize = *((ushort *)(pFormat + 6));
        pFormat += 12;
        }
    else
        {
        ElementSize = *((ushort *)(pFormat + 10));
        pFormat += 16;
        }
    CORRELATION_DESC_INCREMENT( pFormat );

    pStubMsg->BufferLength += ElementSize * pStubMsg->ActualCount;

    if ( *pFormat == FC_PP ) 
        {
        //
        // MaxCount must contain the number of shipped elements in the array
        // before sizing embedded pointers.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerBufferSize( pStubMsg,
                                       pMemory,
                                       pFormat );
        }
}


void RPC_ENTRY
NdrComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

Note.

    Array of ref pointers does not have wire representation for the pointers
    themselves, regardless whether array is top level or embedded in a struct.
    
--*/
{
    bool fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                 (! pStubMsg->PointerBufferMark );

    if ( fSetPointerBufferMark )
        {
        //
        // Save the current conformance and variance fields.  The sizing
        // routine can overwrite them.
        //
        ULONG_PTR MaxCountSave = pStubMsg->MaxCount;
        ulong OffsetSave = pStubMsg->Offset;
        ulong ActualCountSave = pStubMsg->ActualCount;
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        NdrComplexArrayBufferSize( pStubMsg,
                                   pMemory,
                                   pFormat );


        // If the size of the flat part is zero and this is the first item to be
        // marshalled, add a small offset to the buffer so that we can continue
        // to use PointerBufferMark as an is embedded flag.
        if ( !pStubMsg->BufferLength) 
            {
            pStubMsg->BufferLength      += NDR_MAX_BUFFER_ALIGNMENT;
             BufferLengthSave           += NDR_MAX_BUFFER_ALIGNMENT;
            }

        pStubMsg->PointerBufferMark = (uchar *) UlongToPtr(pStubMsg->BufferLength);
        
        pStubMsg->IgnoreEmbeddedPointers = FALSE;

        // Restore conformance and variance fields.
        pStubMsg->MaxCount = MaxCountSave;
        pStubMsg->Offset = OffsetSave;
        pStubMsg->ActualCount = ActualCountSave;
        pStubMsg->BufferLength = BufferLengthSave;

        }

    //
    // Add in conformance sizes if we are the outermost dimension.
    //
    if ( pStubMsg->pArrayInfo == 0 )
        {
        //
        // Align and add size for any conformance count(s).
        //
        if ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff )
            {
            LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    
            pStubMsg->BufferLength += NdrpArrayDimensions( pStubMsg, pFormat, FALSE ) * 4;
            }
        }

    NdrpComplexArrayBufferSize( pStubMsg,
                                pMemory,
                                pFormat );
    
    if ( fSetPointerBufferMark )
        {
        pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
        pStubMsg->PointerBufferMark = NULL;
        }

}


void 
NdrpComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for determing the buffer size of a complex array.  This 
    is the entry point for buffer sizing an embedded complex array.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO     pArrayInfo;
    PSIZE_ROUTINE   pfnSize;
    PFORMAT_STRING  pFormatStart;
    ulong           Elements;
    ulong           Offset, Count;
    ulong           MemoryElementSize;
    long            Dimension;
    uchar           Alignment;
    
    //
    // Lots of setup if we are the outer dimension.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        pStubMsg->pArrayInfo = &ArrayInfo;

        ArrayInfo.Dimension = 0;

        //
        // Set this to 0 so that NdrpMemoryIncrement will know to call 
        // NdrpComputeConformance when computing our size.
        //
        ArrayInfo.BufferConformanceMark = 0;

        ArrayInfo.MaxCountArray = (unsigned long *) pStubMsg->MaxCount;
        ArrayInfo.OffsetArray = (ulong *) UlongToPtr( pStubMsg->Offset );
        ArrayInfo.ActualCountArray = (ulong *) UlongToPtr( pStubMsg->ActualCount );
        }

    pFormatStart = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    // Get the array alignment.
    Alignment = pFormat[1];

    pFormat += 2;

    // Get the number of elements (0 if conformance present). 
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = (ulong) NdrpComputeConformance( pStubMsg,
                                                   pMemory,
                                                   pFormatStart );
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormatStart );

        Offset = pStubMsg->Offset;
        Count = pStubMsg->ActualCount;

        if ( Dimension == 0 )
            {
            //
            // Align and add in size of variance count(s).
            //
            LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    
            pStubMsg->BufferLength += 
                    NdrpArrayDimensions( pStubMsg, pFormatStart, TRUE ) * 8;
            }
        }
    else
        {
        Offset = 0;
        Count = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Check bounds

    if ( ( ((long)Elements) < 0 ) ||
         ( ((long)Count) < 0 ) ||
         ( ((long)Offset) < 0 ) ||
         ( (Offset + Count) > Elements ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if ( Count )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, Alignment );

        if ( *pFormat == FC_EMBEDDED_COMPLEX )
            {
            ulong           CountSave;
            uchar*          pMemorySave;
            PFORMAT_STRING  pFormatSave;

            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ( FC_IP == *pFormat )
                goto PointerSizing;

            pfnSize = pfnSizeRoutines[ROUTINE_INDEX(*pFormat)];

            pArrayInfo->Dimension = Dimension + 1;

            MemoryElementSize = (ulong) ( NdrpMemoryIncrement( pStubMsg,
                                                               pMemory,
                                                               pFormat ) - pMemory );
            if ( ! IS_ARRAY_OR_STRING(*pFormat) )
                pStubMsg->pArrayInfo = 0;

            //
            // If there is variance then increment the memory pointer to the first
            // element actually being sized.
            //
            if ( Offset )
                pMemory += Offset * MemoryElementSize;

            pFormatSave = pFormat;
            pMemorySave = pMemory;
            CountSave = Count;

            for ( ; Count--; )
                {
                // Keep track of multidimensional array dimension.
                if ( IS_ARRAY_OR_STRING(*pFormat) )
                    pArrayInfo->Dimension = Dimension + 1;

                (*pfnSize)( pStubMsg,
                            pMemory,
                            pFormat );

                pMemory += MemoryElementSize;
                }

            pMemory += MemoryElementSize;

            }
        else if ( *pFormat == FC_UP || *pFormat == FC_FP || *pFormat == FC_OP || *pFormat == FC_RP ||
                  *pFormat == FC_IP ) 
            {
PointerSizing:
            //
            // Shallow size the array
            //
            if ( *pFormat != FC_RP ) 
                 {
                 pStubMsg->BufferLength += Count * PTR_WIRE_SIZE;
                 }

            //
            // If there is variance then increment the memory pointer to the first
            // element actually being sized.
            //
            if ( Offset )
                pMemory += Offset * PTR_MEM_SIZE;

            //
            // size the pointees
            //
            if ( !pStubMsg->IgnoreEmbeddedPointers ) 
                {
                bool UseBrokenInterfacePointerRep = 
                    (FC_IP == *pFormat) && !FixWireRepForDComVerGTE54( pStubMsg );
                
                // If this is the broken interface pointer format, make sure we
                // have enough space for both the pointer and pointee where
                // the pointer should have been.

                if ( UseBrokenInterfacePointerRep )
                    SET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

                // Need this in case we have a variant offset.
                pStubMsg->pArrayInfo = 0;
                
                // Switch to the pointee buffer.
                POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

                for ( ; Count--; )
                     {
                     NdrpPointerBufferSize( 
                         pStubMsg,
                         *((uchar **&)pMemory)++,
                         pFormat );
                    }
                
                if ( UseBrokenInterfacePointerRep )
                   RESET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );
                
                }

            }
        else if (*pFormat == FC_RANGE )
            {
            pStubMsg->BufferLength += Count * SIMPLE_TYPE_BUFSIZE( pFormat[1] );
            }
        else
            {
            NDR_ASSERT( IS_SIMPLE_TYPE(*pFormat), "NdrpComplexArrayBufferSize : bad format char" );
            pStubMsg->BufferLength += Count * SIMPLE_TYPE_BUFSIZE(*pFormat);
            }
        }

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;
}


void RPC_ENTRY
NdrNonConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a non conformant string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, and FC_BSTRING (NT Beta2
    compatability only).

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    long    MaxSize;
    long    Length;

    // Align and add size for variance counts.
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 8;

    switch ( *pFormat )
        {
        case FC_CSTRING : 
        case FC_BSTRING : 
            Length = strlen((char*)pMemory) + 1;
            break;
        case FC_WSTRING : 
            Length = (wcslen((wchar_t *)pMemory) + 1) * sizeof(wchar_t);
            break;
        case FC_SSTRING : 
            Length = NdrpStringStructLen( pMemory, pFormat[1] ) + 1;
            Length *= pFormat[1];
            break;
        default :
            NDR_ASSERT(0,"NdrNonConformantStringBufferSize : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Check bounds

    MaxSize = *((ushort *)(pFormat + 2));

    switch ( *pFormat ) 
        {
        case FC_WSTRING : 
            MaxSize *= sizeof(wchar_t);
            break;
        case FC_SSTRING : 
            MaxSize *= pFormat[1];
            break;
        default :
            break;
        }

    if ( Length > MaxSize )
        RpcRaiseException(RPC_X_INVALID_BOUND);

    pStubMsg->BufferLength += Length;
}


void RPC_ENTRY
NdrConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING 
    (NT Beta2 compatability only).

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    //
    // Add in size for conformance marshalling only if this string is not
    // in a multidimensional array.
    //
    if ( pStubMsg->pArrayInfo == 0 )
        {
        // Align and add size for conformance count.
        LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

        pStubMsg->BufferLength += 4;
        }

    NdrpConformantStringBufferSize( pStubMsg,
                                    pMemory,
                                    pFormat );
}


void 
NdrpConformantStringBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a conformant 
    string.  This is the entry point for an embedded conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    long    MaxSize;
    long    Length;

    // Align and add size for variance.
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);

    pStubMsg->BufferLength += 8;

    switch ( *pFormat )
        {
        case FC_C_CSTRING : 
        case FC_C_BSTRING : 
            Length = strlen((char*)pMemory) + 1;
            break;
        case FC_C_WSTRING : 
            Length = (wcslen((wchar_t *)pMemory) + 1) * sizeof(wchar_t);
            break;
        case FC_C_SSTRING : 
            Length = NdrpStringStructLen( pMemory, pFormat[1] ) + 1;
            Length *= pFormat[1];
            break;
        default :
            NDR_ASSERT(0,"NdrpConformantStringBufferSize : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Do bounds checking.
    //
    if ( ((*pFormat != FC_C_SSTRING) && (pFormat[1] == FC_STRING_SIZED)) ||
         ((*pFormat == FC_C_SSTRING) && (pFormat[2] == FC_STRING_SIZED)) )
        {
        MaxSize = (ulong) NdrpComputeConformance( pStubMsg,
                                                  pMemory,
                                                  pFormat );
    
        switch ( *pFormat )
            {
            case FC_C_WSTRING : 
                MaxSize *= sizeof(wchar_t);
                break;
            case FC_C_SSTRING : 
                MaxSize *= pFormat[1];
                break;
            default :
                break;
            }

        if ( (MaxSize < 0) || (Length > MaxSize) )
            RpcRaiseException(RPC_X_INVALID_BOUND);
        }   

    pStubMsg->BufferLength += Length;
}


void RPC_ENTRY
NdrEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for an encapsulated union.

    Used for FC_ENCAPSULATED_UNION.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being sized.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;
    uchar   SwitchType;

    NO_CORRELATION;

    SwitchType = LOW_NIBBLE(pFormat[1]);

    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *)pMemory);
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *)pMemory);
            break;

        case FC_ENUM16 :
        case FC_SHORT :
            SwitchIs = (long) *((short *)pMemory);
            break;

        case FC_USHORT :
        case FC_WCHAR :
            SwitchIs = (long) *((ushort *)pMemory);
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 is mapped to FC_LONG.
            SwitchIs = *((long *)pMemory);
            break;
        default :
            NDR_ASSERT(0,"NdrEncapsulatedBufferSize : bad switch type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Increment memory pointer to the union.
    pMemory += HIGH_NIBBLE(pFormat[1]);

    NdrpUnionBufferSize( pStubMsg,
                         pMemory,
                         pFormat + 2,
                         SwitchIs,
                         SwitchType );
}


void RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a non encapsulated union.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being sized.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;
    uchar   SwitchType;

    SwitchType = pFormat[1];

    SwitchIs = (ulong) NdrpComputeSwitchIs( pStubMsg,
                                            pMemory,
                                            pFormat );

    //
    // Set the format string to the memory size and arm description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    NdrpUnionBufferSize( pStubMsg,
                         pMemory,
                         pFormat,
                         SwitchIs,
                         SwitchType );
}


void 
NdrpUnionBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                SwitchIs,
    uchar               SwitchType )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a union.  This
    routine is used for sizing both encapsulated and non-encapsulated unions.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being sized.
    pFormat     - Union's format string description.
    SwitchIs    - The union's switch is.
    SwitchType  - The union's switch type.

Return :

    None.

--*/
{
    long    Arms;
    long    Alignment;

    //
    // Size the switch_is.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength,SIMPLE_TYPE_ALIGNMENT(SwitchType));
    
    pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE(SwitchType);

    // Skip the memory size field.
    pFormat += 2;

    //
    // Get the union alignment (0 if this is a DCE union) and align the 
    // buffer on this alignment.
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    LENGTH_ALIGN(pStubMsg->BufferLength,Alignment);

    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff );

    //
    // Search for the arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm is empty.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        // Re-align again, only does something usefull for DCE unions.

        unsigned char FcType = pFormat[0];

        LENGTH_ALIGN( pStubMsg->BufferLength, SIMPLE_TYPE_ALIGNMENT( FcType ));
        pStubMsg->BufferLength += SIMPLE_TYPE_BUFSIZE( FcType );
        }
    else
        {
        pFormat += *((signed short *)pFormat);

        //
        // If the union arm we take is a pointer, we have to dereference the
        // current memory pointer since we're passed a pointer to the union
        // (regardless of whether the actual parameter was a by-value union
        // or a pointer to a union).
        //
        if ( IS_POINTER_TYPE(*pFormat) )
            {

            if ( pStubMsg->IgnoreEmbeddedPointers )
                {
                // 
                // If we're ignoring pointers then just add in the size of a pointer
                // here and return.
                //
                LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
                pStubMsg->BufferLength += PTR_WIRE_SIZE;
                
                return;
                }

            pMemory = *((uchar **)pMemory);

            if ( pStubMsg->PointerBufferMark )
                {
                
                // If the union is embedded, tread it specially
                LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
                pStubMsg->BufferLength += PTR_WIRE_SIZE;

                if ( !pStubMsg->IgnoreEmbeddedPointers )
                    {
                    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext(pStubMsg);

                    NdrpPointerBufferSize( pStubMsg,
                                           pMemory,
                                           pFormat );                    
                    }

                return;
                }

            }

        // Call the appropriate sizing routine
        (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
        }
}


void RPC_ENTRY
NdrByteCountPointerBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a byte count pointer.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - The byte count pointer being sized.
    pFormat     - Byte count pointer's format string description.

Return :

    None.

--*/
{
    //
    // We don't do anything special here.  Just pass things on to the
    // right sizing routine.
    //
    if ( pFormat[1] != FC_PAD )
        {
        SIMPLE_TYPE_BUF_INCREMENT(pStubMsg->BufferLength, pFormat[1]);
        }
    else
        {
        pFormat += 6;
        CORRELATION_DESC_INCREMENT( pFormat );
        pFormat += *((signed short *)pFormat);

        (*pfnSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
        }
}


void RPC_ENTRY
NdrXmitOrRepAsBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat ) 
/*++

Routine Description :

    Computes the buffer size needed for a transmit as or represent as object.

    See mrshl.c for the description of the FC layout.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the transmit/represent as object being sized.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple;
    unsigned short                 QIndex, XmitTypeSize;
    BOOL                           fXmitByPtr = *pFormat == FC_TRANSMIT_AS_PTR ||
                                                *pFormat == FC_REPRESENT_AS_PTR;
    
    // Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);

    // We size the transmitted object, of course.

    pFormat += 6;
    XmitTypeSize = *((unsigned short *)pFormat);

    pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;

    if ( XmitTypeSize )
        {
        // lower nibble of the flag word has the alignment

        unsigned long Align = LOW_NIBBLE(*(pFormat - 5));

        LENGTH_ALIGN( pStubMsg->BufferLength, Align );
        pStubMsg->BufferLength += XmitTypeSize;
        }
    else
        {
        // We have to create an object to size it.

        unsigned char *  pTransmittedType;

        // First translate the presented type into the transmitted type.
        // This includes an allocation of a transmitted type object.
    
        pStubMsg->pPresentedType = pMemory;
        pStubMsg->pTransmitType = NULL;
        pQuintuple[ QIndex ].pfnTranslateToXmit( pStubMsg );
    
        // bufsize the transmitted type.
    
        pFormat += 2;
        pFormat = pFormat + *(short *)pFormat;
    
        pTransmittedType = pStubMsg->pTransmitType;

        // If transmitted type is a pointer, dereference it.
        {
            // Set the current queue to NULL so that all the embedded
            // pointers in the transmitted type will be sized together
            uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
            pStubMsg->PointerBufferMark = 0;
            NDR_POINTER_QUEUE *pOldQueue = NULL;

            if ( pStubMsg->pPointerQueueState )
                {
                pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
                pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
                }
            RpcTryFinally
                {
                (*pfnSizeRoutines[ ROUTINE_INDEX(*pFormat) ])
                    ( pStubMsg,
                      fXmitByPtr ? *(uchar **)pTransmittedType
                                 : pTransmittedType,
                      pFormat );
                }
            RpcFinally
                {
                pStubMsg->PointerBufferMark = PointerBufferMarkSave;
                if ( pStubMsg->pPointerQueueState )
                    {
                    pStubMsg->pPointerQueueState->SetActiveQueue(pOldQueue);
                    }
                }
            RpcEndFinally
        }

        pStubMsg->pTransmitType = pTransmittedType;
    
        // Free the temporary transmitted object (it was alloc'ed by the user).
    
        pQuintuple[ QIndex ].pfnFreeXmit( pStubMsg );
        }
}

void
NdrpUserMarshalBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat ) 
/*++

Routine Description :

    Computes the buffer size needed for a usr_marshall object.
    See mrshl.c for the description of the FC layout and wire layout.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the usr_marshall object to buffer size.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    const USER_MARSHAL_ROUTINE_QUADRUPLE *  pQuadruple;
    unsigned short                          QIndex;
    unsigned long                           UserOffset;
    USER_MARSHAL_CB                         UserMarshalCB;

    
	if ( pFormat[1] & USER_MARSHAL_POINTER )
	{
        // This is an overestimate to correct the size generated
        // by MIDL's state machine for sizing arguments.
        // The maximum alignment gap VARIANT might consume is 11:
        // 4 for the leading pad between unique pointer and wireVARIANT,
        // and 7 bytes if variant is a BSTR, and following parameter is
        // a CY (stuff that's aligned to 8).

        // MZ: Since were overcompensating here, just make this something
        // reasonable like 0x10 which is probably a good max alignment.
        pStubMsg->BufferLength += 0x10;

	}
 

    // We are here to size a flat object or a pointee object.
    // Optimization: if we know the wire size, don't call the user to size it.

    if ( *(unsigned short *)(pFormat + 6) != 0 )
        {
        pStubMsg->BufferLength += *(unsigned short *)(pFormat + 6);
        }
    else
        {
        // Unknown wire size: Call the user to size his stuff.
        NdrpInitUserMarshalCB( pStubMsg,
                               pFormat,
                               USER_MARSHAL_CB_BUFFER_SIZE,
                               & UserMarshalCB);

        UserOffset = pStubMsg->BufferLength;

        QIndex     = *(unsigned short *)(pFormat + 2);
        pQuadruple = pStubMsg->StubDesc->aUserMarshalQuadruple;

        UserOffset = pQuadruple[ QIndex ].pfnBufferSize( (ulong*) &UserMarshalCB,
                                                         UserOffset,
                                                         pMemory );
        pStubMsg->BufferLength = UserOffset;
        }
}

void 
NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    NdrpUserMarshalBufferSize( pStubMsg,
                               pMemory,
                               pFormat );
}
#if defined(DBG)
void 
NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


void RPC_ENTRY
NdrUserMarshalBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{

    // Check if the object is embedded.
    // Pointer buffer mark is set only when in a complex struct or array.
    // For unions, when the union is embedded in a complex struct or array.
    // If the union is top level, it's the same like a top level object.

    // For unique pointers we don't have to check embedding, we always add 4.
    // For ref pointer we need to check embedding.

    // Align for the flat object or a pointer to the user object.
    LENGTH_ALIGN( pStubMsg->BufferLength, LOW_NIBBLE(pFormat[1]) );

    if ( pFormat[1] & USER_MARSHAL_POINTER )
        {
        if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  ||
             ((pFormat[1] & USER_MARSHAL_REF) && pStubMsg->PointerBufferMark) )
            {
            pStubMsg->BufferLength += PTR_WIRE_SIZE;
            }

        if ( pStubMsg->IgnoreEmbeddedPointers )
            return;
        
        POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

        if ( !pStubMsg->pPointerQueueState ||
             !pStubMsg->pPointerQueueState->GetActiveQueue() )
            {
            NdrpUserMarshalBufferSize( 
                pStubMsg,
                pMemory,
                pFormat );

            }
        else
            {
            NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT*pElement = 
                new(pStubMsg->pPointerQueueState) 
                    NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT(pMemory,
                                                                pFormat);
            pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
            }

        return;
        }

   NdrpUserMarshalBufferSize( pStubMsg,
                              pMemory,
                              pFormat );
}


void
NdrpInterfacePointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the buffer size needed for an interface pointer.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - The interface pointer being sized.
    pFormat     - Interface pointer's format string description.

Return :

    None.

--*/
{
    IID iid;
    IID *piid;
    unsigned long size = 0;
    HRESULT hr;

    //
    // Get an IID pointer.
    //
    if ( pFormat[1] != FC_CONSTANT_IID )
        {
        //
        // We do it same way as we compute variance with a long.
        //
        piid = (IID *) NdrpComputeIIDPointer( pStubMsg,
                                               pMemory,
                                               pFormat );

        if(piid == 0)
            RpcRaiseException( RPC_S_INVALID_ARG );
        }
    else
        {
        // 
        // The IID may not be aligned properly in the format string,
        // so we copy it to a local variable.
        //

        piid = &iid;
        RpcpMemoryCopy( &iid, &pFormat[2], sizeof(iid) );
        }

    // Allocate space for the length and array bounds.

    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    pStubMsg->BufferLength += sizeof(unsigned long) + sizeof(unsigned long);

    hr = (*pfnCoGetMarshalSizeMax)(&size, *piid, (IUnknown *)pMemory, pStubMsg->dwDestContext, pStubMsg->pvDestContext, 0);
    if(FAILED(hr))
        {
        RpcRaiseException(hr);
        }

    pStubMsg->BufferLength += size;
}

void RPC_ENTRY
NdrInterfacePointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    // This function is called only for toplevel interface pointers and 
    // backward compatibity

    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    pStubMsg->BufferLength += PTR_WIRE_SIZE;

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    // If the pointer is null, we counted everything.

    if ( pMemory == 0 )
        return;

    NdrpInterfacePointerBufferSize( pStubMsg,
                                    pMemory,
                                    pFormat );
}


void 
NdrpEmbeddedPointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for a structure's
    or array's embedded pointers.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding structure or array. 
    pFormat     - Format string pointer layout description.

Return :

    None.

--*/
{

    if ( pStubMsg->IgnoreEmbeddedPointers ) 
        return;

    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );
    void **     ppMemPtr;
    uchar *     pMemorySave;
    ULONG_PTR   MaxCountSave;
    long        OffsetSave;

    MaxCountSave = pStubMsg->MaxCount;
    OffsetSave = pStubMsg->Offset;
    pMemorySave = pStubMsg->Memory;

    // Set new memory context.
    pStubMsg->Memory = pMemory;

    // 
    // Increment past the FC_PP and pad.
    //
    pFormat += 2;

    for (;;)
        {

        if ( *pFormat == FC_END )
            {
            pStubMsg->Memory = pMemorySave;
            break;
            }

        //
        // Check for FC_FIXED_REPEAT or FC_VARIABLE_REPEAT.
        //
        if ( *pFormat != FC_NO_REPEAT )
            {
            pStubMsg->MaxCount = MaxCountSave;
            pStubMsg->Offset = OffsetSave;

            NdrpEmbeddedRepeatPointerBufferSize( pStubMsg,
                                                 pMemory,
                                                 &pFormat );

            // Continue to the next pointer.
            continue;
            }

        // Compute the pointer to the pointer in memory to size.
        ppMemPtr = (void **) (pMemory + *((signed short *)(pFormat + 2)));

        // Increment to the pointer description.
        pFormat += 6;

        NdrpPointerBufferSize( 
            pStubMsg,
            (uchar*)*ppMemPtr,
            pFormat );
        
        // Increment past pointer description.
        pFormat += 4;
        }


}


void 
NdrpEmbeddedRepeatPointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING *    ppFormat )
/*++

Routine Description :

    Private routine for computing the buffer size needed for an array's 
    embedded pointers.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding array.
    pFormat     - The array's format string pointer layout description.

Return :

    None.

--*/
{
    uchar **        ppMemPtr;
    PFORMAT_STRING  pFormat;
    PFORMAT_STRING  pFormatSave;
    uchar *         pMemorySave;
    ulong           RepeatCount,RepeatIncrement, Pointers, PointersSave;

    pMemorySave = pStubMsg->Memory;

    // Get current format string pointer.
    pFormat = *ppFormat;

    switch ( *pFormat )
        {
        case FC_FIXED_REPEAT :
            // Increment past the FC_FIXED_REPEAT and FC_PAD.
            pFormat += 2;

            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = *((ushort *&)pFormat)++;

            break;

        case FC_VARIABLE_REPEAT :
            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = (ulong)pStubMsg->MaxCount;

            //
            // Check if this variable repeat instance also has a variable
            // offset (this would be the case for a conformant varying array
            // of pointers).  If so then increment the memory pointer to point
            // to the actual first array element which is being marshalled.
            //
            if ( pFormat[1] == FC_VARIABLE_OFFSET )
                pMemory += *((ushort *)(pFormat + 2)) * pStubMsg->Offset;

            // else pFormat[1] == FC_FIXED_OFFSET - do nothing

            // Increment past the FC_VARIABLE_REPEAT and FC_PAD.
            pFormat += 2;

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Get the increment amount between successive pointers.
    RepeatIncrement = *((ushort *&)pFormat)++;

    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from any currently embedding structure
    // to the array whose pointers we're marshalling.
    //
    pStubMsg->Memory += *((ushort *&)pFormat)++;

    // Get the number of pointers in this repeat instance.
    PointersSave = Pointers = *((ushort *&)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop over the number of elements in the array.
    //
    for ( ; RepeatCount--;
            pMemory += RepeatIncrement,
            pStubMsg->Memory += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        //
        // Loop over the number of pointers in each array element (this can
        // be greater than one if we have an array of structures).
        //
        for ( ; Pointers--; )
            {
            // Pointer to the pointer in memory.
            ppMemPtr = (uchar **)(pMemory + *((signed short *)pFormat));

            // Increment to pointer description.
            pFormat += 4;

            NdrpPointerBufferSize( 
                pStubMsg,
                (uchar*)*ppMemPtr,
                pFormat );

            // Increment to the next pointer description.
            pFormat += 4;
            }
        }

    // Update format string pointer past this repeat pointer description.
    *ppFormat = pFormatSave + PointersSave * 8;

    pStubMsg->Memory = pMemorySave;
}


void RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE     pStubMsg,
    uchar *                pMemory,
    PFORMAT_STRING         pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a context handle.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Ignored.
    pFormat     - Ignored.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    pStubMsg->BufferLength += CONTEXT_HANDLE_WIRE_SIZE;
}

#ifdef _CS_CHAR_
void RPC_ENTRY
NdrCsTagBufferSize(
    PMIDL_STUB_MESSAGE     pStubMsg,
    uchar *                pMemory,
    PFORMAT_STRING         pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a cs tag param.  Also copies the 
    sending tag value to the stub message for use by NdrCsArrayXXX.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding array.
    pFormat     - Pointer to the FC_CSTAG entry in the format string.

Return :

    None.

--*/
{
    // We need to set the tag in the stub message so that we can properly
    // size subsequent cs_char arrays.

    NdrpGetSetCSTagMarshall( pStubMsg, pMemory, (NDR_CS_TAG_FORMAT *) pFormat);

    LENGTH_ALIGN( pStubMsg->BufferLength, 3 );
    pStubMsg->BufferLength += sizeof( unsigned long );
}
 

void RPC_ENTRY
NdrCsArrayBufferSize(
    PMIDL_STUB_MESSAGE     pStubMsg,
    uchar *                pMemory,
    PFORMAT_STRING         pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a cs_char array

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the embedding array.
    pFormat     - Pointer to the FC_CSARRAY entry in the format string.

Return :

    None.

--*/
{
    NDR_CS_ARRAY_FORMAT        *pCSFormat = (NDR_CS_ARRAY_FORMAT *) pFormat;
    ulong                       Size;
    ulong                       Length;
    ulong                       WireSize;

    NDR_ASSERT( NULL != pStubMsg->pCSInfo, "cs_char stub info not set up");

    // Skip pFormat to the underlying array descriptor

    pFormat += pCSFormat->DescriptionOffset;

    // Leave room for the max count / offset / actual count

    if ( NdrpIsVaryingArray( pFormat ) )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, 3 );
        pStubMsg->BufferLength += 8;
        }
    if ( NdrpIsConformantArray( pFormat ) )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, 3 );
        pStubMsg->BufferLength += 4;
        }

    // Get the base size and length

    NdrpGetArraySizeLength (
            pStubMsg,
            pMemory,
            pFormat,
            1,
            (long*)&Size,
            (long*)&Length,
            (long*)&WireSize );

    // Call XXX_net_size to estimate the buffer space required to store this
    // array after conversion.  For fixed or varying arrays the buffer
    // space is equal to the fixed upper bound specified in the idl file.


    if ( !NdrpIsVaryingArray( pFormat ) )
        {
        NDR_CS_SIZE_CONVERT_ROUTINES   *CSRoutines;
        CS_TYPE_NET_SIZE_ROUTINE        SizingRoutine;
        IDL_CS_CONVERT                  ConversionType;
        error_status_t                  Status;

        CSRoutines = pStubMsg->StubDesc->CsRoutineTables->pSizeConvertRoutines;
        SizingRoutine = CSRoutines[ pCSFormat->CSRoutineIndex ].pfnNetSize;

        SizingRoutine(
            NULL,
            pStubMsg->pCSInfo->WireCodeset,
            Size,
            (IDL_CS_CONVERT*)&ConversionType,
            &Size,
            &Status);
                
        if (RPC_S_OK != Status)
            RpcRaiseException(Status);
        }

    pStubMsg->BufferLength += Size;
}
#endif // _CS_CHAR_


void
NdrPartialIgnoreClientBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    void *                              pMemory 
    )
{
     LENGTH_ALIGN( pStubMsg->BufferLength, 0x3 );
     pStubMsg->Buffer += PTR_WIRE_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\auxilary.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    auxilary.c

Abstract :

    This file contains auxilary routines used for initialization of the
    RPC and stub messages and the offline batching of common code sequences
    needed by the stubs.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/
#define _OLE32_
#include "ndrp.h"
#include "ndrole.h"
#include "ndrtypes.h"
#include "limits.h"
#include "interp.h"
#include "mulsyntx.h"
#include "pipendr.h"
#include "asyncndr.h"
#include "auxilary.h"

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Static data for NS library operations
  ---------------------------------------------------------------------*/

int NsDllLoaded = 0;


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    OLE routines for interface pointer marshalling
  ---------------------------------------------------------------------*/

STDAPI NdrpCoCreateInstance(
    REFCLSID    rclsid,
    LPUNKNOWN   pUnkOuter,
    DWORD       dwClsContext, 
    REFIID      riid, 
    LPVOID *    ppv);

STDAPI NdrpCoReleaseMarshalData(
    IStream *pStm);

STDAPI NdrpDcomChannelSetHResult(
        PRPC_MESSAGE    pmsg,
        ULONG *         pulReserved,
        HRESULT         appsHR );

STDAPI NdrCoGetPSClsid(
    REFIID  iid,
    LPCLSID lpclsid);

HINSTANCE       hOle32 = 0;

RPC_GET_CLASS_OBJECT_ROUTINE        NdrCoGetClassObject;
RPC_GET_CLASS_OBJECT_ROUTINE     *  pfnCoGetClassObject = &NdrCoGetClassObject;

RPC_GET_MARSHAL_SIZE_MAX_ROUTINE    NdrCoGetMarshalSizeMax;
RPC_GET_MARSHAL_SIZE_MAX_ROUTINE *  pfnCoGetMarshalSizeMax = &NdrCoGetMarshalSizeMax;

RPC_MARSHAL_INTERFACE_ROUTINE       NdrCoMarshalInterface;
RPC_MARSHAL_INTERFACE_ROUTINE    *  pfnCoMarshalInterface = &NdrCoMarshalInterface;

RPC_UNMARSHAL_INTERFACE_ROUTINE     NdrCoUnmarshalInterface;
RPC_UNMARSHAL_INTERFACE_ROUTINE  *  pfnCoUnmarshalInterface = &NdrCoUnmarshalInterface;

RPC_STRING_FROM_IID                 OleStringFromIID;
RPC_STRING_FROM_IID              *  pfnStringFromIID = &OleStringFromIID;

RPC_GET_PS_CLSID                    NdrCoGetPSClsid;
RPC_GET_PS_CLSID                 *  pfnCoGetPSClsid = &NdrCoGetPSClsid;

RPC_CO_CREATE_INSTANCE              NdrpCoCreateInstance;
RPC_CO_CREATE_INSTANCE           *  pfnCoCreateInstance = &NdrpCoCreateInstance;

RPC_CLIENT_ALLOC                    NdrCoTaskMemAlloc;
RPC_CLIENT_ALLOC                 *  pfnCoTaskMemAlloc = &NdrCoTaskMemAlloc;

RPC_CLIENT_FREE                     NdrCoTaskMemFree;
RPC_CLIENT_FREE                  *  pfnCoTaskMemFree = &NdrCoTaskMemFree;

RPC_CO_RELEASEMARSHALDATA           NdrpCoReleaseMarshalData;
RPC_CO_RELEASEMARSHALDATA        *  pfnCoReleaseMarshalData = &NdrpCoReleaseMarshalData;

RPC_DCOMCHANNELSETHRESULT           NdrpDcomChannelSetHResult;
RPC_DCOMCHANNELSETHRESULT        *  pfnDcomChannelSetHResult = &NdrpDcomChannelSetHResult;

RPC_NS_GET_BUFFER_ROUTINE        pRpcNsGetBuffer;
RPC_NS_SEND_RECEIVE_ROUTINE      pRpcNsSendReceive;
RPC_NS_NEGOTIATETRANSFERSYNTAX_ROUTINE  pRpcNsNegotiateTransferSyntax;


HRESULT    NdrLoadOleRoutines()
{
    void * pTempRoutine;

    //Load ole32.dll
    if(hOle32 == 0)
    {
#ifdef DOSWIN32RPC
        hOle32 = LoadLibraryA("OLE32");
#else
        hOle32 = LoadLibraryW(L"OLE32");
#endif // DOSWIN32C
        if(hOle32 == 0)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    pTempRoutine = GetProcAddress(hOle32, "CoGetClassObject");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoGetClassObject = (RPC_GET_CLASS_OBJECT_ROUTINE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoGetMarshalSizeMax");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoGetMarshalSizeMax = (RPC_GET_MARSHAL_SIZE_MAX_ROUTINE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoMarshalInterface");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoMarshalInterface = (RPC_MARSHAL_INTERFACE_ROUTINE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoUnmarshalInterface");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoUnmarshalInterface = (RPC_UNMARSHAL_INTERFACE_ROUTINE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "StringFromIID");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnStringFromIID = (RPC_STRING_FROM_IID*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoGetPSClsid");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoGetPSClsid = (RPC_GET_PS_CLSID*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoTaskMemAlloc");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoTaskMemAlloc = (RPC_CLIENT_ALLOC*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoTaskMemFree");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoTaskMemFree = (RPC_CLIENT_FREE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoCreateInstance");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoCreateInstance = (RPC_CO_CREATE_INSTANCE*) pTempRoutine;

    pTempRoutine = GetProcAddress(hOle32, "CoReleaseMarshalData");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnCoReleaseMarshalData = (RPC_CO_RELEASEMARSHALDATA*) pTempRoutine;
    pTempRoutine = GetProcAddress(hOle32, "DcomChannelSetHResult");
    if(pTempRoutine == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    else
        pfnDcomChannelSetHResult = (RPC_DCOMCHANNELSETHRESULT*) pTempRoutine;

    return( (HRESULT)0 );
}

HRESULT STDAPICALLTYPE
NdrCoGetClassObject(
    REFCLSID    rclsid,
    DWORD       dwClsContext,
    void       *pvReserved,
    REFIID      riid,
    void      **ppv)
/*++

Routine Description:
    Loads a class factory.  This function forwards the call to ole32.dll.

Arguments:
    rclsid          - Supplies the CLSID of the class to be loaded.
    dwClsContext    - Supplies the context in which to load the code.
    pvReserved      - Must be NULL.
    riid            - Supplies the IID of the desired interface.
    ppv             - Returns a pointer to the class factory.

Return Value:
    S_OK


--*/
{

    HRESULT hr;

    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoGetClassObject)(rclsid, dwClsContext, pvReserved, riid, ppv);
}

HRESULT STDAPICALLTYPE
NdrCoGetMarshalSizeMax(
    ULONG *     pulSize,
    REFIID      riid,
    LPUNKNOWN   pUnk,
    DWORD       dwDestContext,
    LPVOID      pvDestContext,
    DWORD       mshlflags)
/*++

Routine Description:
    Calculates the maximum size of a marshalled interface pointer.
    This function forwards the call to ole32.dll.

Arguments:
    pulSize         - Returns an upper bound for the size of a marshalled interface pointer.
    riid            - Supplies the IID of the interface to be marshalled.
    pUnk            - Supplies a pointer to the object to be marshalled.
    dwDestContext   - Supplies the destination of the marshalled interface pointer.
    pvDestContext
    mshlflags       - Flags.  See the MSHFLAGS enumeration.

Return Value:
    S_OK

--*/
{

    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoGetMarshalSizeMax)(pulSize, riid, pUnk, dwDestContext, pvDestContext, mshlflags);

}

RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion(
    PMIDL_STUB_MESSAGE   pStubMsg,
    RPC_VERSION *        pVersion )
/*

    This is a helper routine for OLEAUT guys.
    It returns the actually negotiated protocol version for the connection,
    i.e. a "common denominator" - lower of the two.

*/
{
    HRESULT Hr = E_FAIL;

    if ( pStubMsg->pRpcChannelBuffer )
        {
        IRpcChannelBuffer2 * pBuffer2 = 0;

        Hr = ((IRpcChannelBuffer*)pStubMsg->pRpcChannelBuffer)->
                  QueryInterface( IID_IRpcChannelBuffer2,
                                  (void**) & pBuffer2 );
        if ( Hr == S_OK )
            {
            Hr = pBuffer2->GetProtocolVersion( (DWORD *) pVersion );
            pBuffer2->Release( );
            }
        }
    return Hr;
}

unsigned long
FixWireRepForDComVerGTE54(
    PMIDL_STUB_MESSAGE   pStubMsg )
/*
    Compares the current DCOM protocol version with the desired version ( 5.4 )
    Specific to interface pointer array and embedded conf struct wire rep fix.
*/
{
    if ( pStubMsg->pRpcChannelBuffer )
        {
        RPC_VERSION currRpcVersion = { 0, 0 };

        if ( SUCCEEDED ( NdrGetDcomProtocolVersion( pStubMsg, &currRpcVersion ) ) )
            {
            if ( currRpcVersion.MajorVersion > 5 )
                {
                return TRUE;
                }
            else
                {
                return currRpcVersion.MinorVersion >= 4;
                }
            }
        }
    return TRUE;
}

HRESULT STDAPICALLTYPE
NdrCoMarshalInterface(
    LPSTREAM    pStm,
    REFIID      riid,
    LPUNKNOWN   pUnk,
    DWORD       dwDestContext,
    LPVOID      pvDestContext,
    DWORD       mshlflags)
/*++

Routine Description:
    Marshals an interface pointer.
    This function forwards the call to ole32.dll.

Arguments:
    pStm            - Supplies the target stream.
    riid            - Supplies the IID of the interface to be marshalled.
    pUnk            - Supplies a pointer to the object to be marshalled.
    dwDestContext   - Specifies the destination context
    pvDestContext
    mshlflags       - Flags.  See the MSHFLAGS enumeration.

Return Value:
    S_OK

--*/
{
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoMarshalInterface)(pStm, riid, pUnk, dwDestContext, pvDestContext, mshlflags);
}

HRESULT STDAPICALLTYPE
NdrCoUnmarshalInterface(
    LPSTREAM    pStm,
    REFIID      riid,
    void **     ppv)
/*++

Routine Description:
    Unmarshals an interface pointer from a stream.
    This function forwards the call to ole32.dll.

Arguments:
    pStm    - Supplies the stream containing the marshalled interface pointer.
    riid    - Supplies the IID of the interface pointer to be unmarshalled.
    ppv     - Returns the unmarshalled interface pointer.

Return Value:
    S_OK

--*/
{
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoUnmarshalInterface)(pStm, riid, ppv);
}

STDAPI NdrpCoCreateInstance(
    REFCLSID    rclsid,
    LPUNKNOWN   pUnkOuter,
    DWORD       dwClsContext, 
    REFIID      riid, 
    LPVOID *    ppv)
{
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoCreateInstance) (rclsid, pUnkOuter, dwClsContext, riid, ppv );
}

STDAPI NdrpCoReleaseMarshalData(
    IStream *pStm)
{
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoReleaseMarshalData) (pStm );
}

STDAPI NdrpDcomChannelSetHResult(
        PRPC_MESSAGE    pmsg,
        ULONG *         pulReserved,
        HRESULT         appsHR )
{
    HRESULT hr;

    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnDcomChannelSetHResult)( pmsg, pulReserved, appsHR );
}


HRESULT STDAPICALLTYPE OleStringFromIID(
    REFIID rclsid,
    LPOLESTR FAR* lplpsz)
/*++

Routine Description:
    Converts an IID into a string.
    This function forwards the call to ole32.dll.

Arguments:
    rclsid  - Supplies the clsid to convert to string form.
    lplpsz  - Returns the string form of the clsid (with "{}" around it).

Return Value:
    S_OK

--*/
{
    HRESULT hr;
    
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnStringFromIID)(rclsid, lplpsz);
}

STDAPI NdrCoGetPSClsid(
    REFIID  iid,
    LPCLSID lpclsid)
/*++

Routine Description:
    Converts an IID into a string.
    This function forwards the call to ole32.dll.

Arguments:
    rclsid  - Supplies the clsid to convert to string form.
    lplpsz  - Returns the string form of the clsid (with "{}" around it).

Return Value:
    S_OK

--*/
{
    
    HRESULT hr;
    if ( FAILED(hr = NdrLoadOleRoutines()) )
        return hr;

    return (*pfnCoGetPSClsid)(iid, lpclsid);
}


void * STDAPICALLTYPE
NdrCoTaskMemAlloc(
    size_t cb)
/*++

Routine Description:
    Allocate memory using OLE task memory allocator.
    This function forwards the call to ole32.dll.

Arguments:
    cb - Specifies the amount of memory to be allocated.

Return Value:
    This function returns a pointer to the allocated memory.
    If an error occurs, this function returns zero.

--*/
{
    if ( FAILED(NdrLoadOleRoutines()) )
        return 0;

    return (*pfnCoTaskMemAlloc)(cb);
}

void STDAPICALLTYPE
NdrCoTaskMemFree(
    void * pMemory)
/*++

Routine Description:
    Free memory using OLE task memory allocator.
    This function forwards the call to ole32.dll.

Arguments:
    pMemory - Supplies a pointer to the memory to be freed.

Return Value:
    None.

--*/
{
    if ( FAILED(NdrLoadOleRoutines()) )
        return;

   (*pfnCoTaskMemFree)(pMemory);
}


void * RPC_ENTRY NdrOleAllocate(size_t size)
/*++

Routine Description:
    Allocate memory via OLE task allocator.

Arguments:
    size - Specifies the amount of memory to be allocated.

Return Value:
    This function returns a pointer to the allocated memory.
    If an error occurs, this function raises an exception.

--*/
{
    void *pMemory;

    pMemory = (*pfnCoTaskMemAlloc)(size);

    if(pMemory == 0)
        RpcRaiseException(E_OUTOFMEMORY);

    return pMemory;
}

void RPC_ENTRY NdrOleFree(void *pMemory)
/*++

Routine Description:
    Free memory using OLE task allocator.

Arguments:
    None.

Return Value:
    None.

--*/
{
    (*pfnCoTaskMemFree)(pMemory);
}


HRESULT STDAPICALLTYPE NdrStringFromIID(
    REFIID rclsid,
    char * lpsz)
/*++

Routine Description:
    Converts an IID into a string.
    This function forwards the call to ole32.dll.

Arguments:
    rclsid  - Supplies the clsid to convert to string form.
    lplpsz  - Returns the string form of the clsid (with "{}" around it).

Return Value:
    S_OK

--*/
{
    HRESULT   hr;
    wchar_t * olestr;

    hr = (*pfnStringFromIID)(rclsid, &olestr);

    if(SUCCEEDED(hr))
    {
        WideCharToMultiByte(CP_ACP,
                            0,
                            (LPCWSTR)olestr,
                            -1,
                            (LPSTR)lpsz,
                            50,
                            NULL,
                            NULL);
        NdrOleFree(olestr);
    }

    return hr;
}



void RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE             pRpcMsg,
    PMIDL_STUB_MESSAGE         pStubMsg,
    PMIDL_STUB_DESC            pStubDescriptor,
    unsigned int            ProcNum
    )
/*++

Routine Description :

    This routine is called by client side stubs to initialize the RPC message
    and stub message, and to get the RPC buffer.

Arguments :

    pRpcMsg            - pointer to RPC message structure
    pStubMsg        - pointer to stub message structure
    pStubDescriptor    - pointer to stub descriptor structure
    HandleType        - type of binding handle
    ProcNum            - remote procedure number

--*/
{
    NdrClientInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor,
                         ProcNum );

    if ( pStubDescriptor->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pStubDescriptor->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ClientInitialize : Bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    //
    // This is where we initialize fields behind the NT3.5 - NT5.0 field set.
    //
#ifdef _CS_CHAR_
    if ( NDR_VERSION_6_0 <= pStubDescriptor->Version )
        {
        pStubMsg->pCSInfo = 0;
        }
#endif // _CS_CHAR_
}

void RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum )
/*++

Routine Description :

    This routine is called by client side stubs to initialize the RPC message
    and stub message, and to get the RPC buffer.

Arguments :

    pRpcMsg          - pointer to RPC message structure
    pStubMsg         - pointer to stub message structure
    pStubDescriptor  - pointer to stub descriptor structure
    ProcNum          - remote procedure number
    
Notes:

    This routine has to be backward compatible with the old binaries built from
    -Os stubs. In particular, it cannot touch StubMsg fields outside of 
    the NT3.5 - NT5.0 field set, i.e. set of fields present since NT3.5 release.

--*/
{
    //
    // Initialize RPC message fields.
    //
    // The leftmost bit of the procnum field is supposed to be set to 1 inr
    // order for the runtime to know if it is talking to the older stubs or
    // not.
    //

    pRpcMsg->RpcInterfaceInformation = pStubDescriptor->RpcInterfaceInformation;
//#if !defined(__RPC_WIN64__)
    
    pRpcMsg->ProcNum = ProcNum | RPC_FLAGS_VALID_BIT;
//#endif     
    pRpcMsg->RpcFlags = 0;
    pRpcMsg->Handle = 0;

    //
    // Initialize the Stub messsage fields.
    //

    pStubMsg->RpcMsg = pRpcMsg;

    pStubMsg->StubDesc = pStubDescriptor;

    pStubMsg->pfnAllocate = pStubDescriptor->pfnAllocate;
    pStubMsg->pfnFree     = pStubDescriptor->pfnFree;

    pStubMsg->fInDontFree       = 0;
    pStubMsg->fDontCallFreeInst = 0;
    pStubMsg->fInOnlyParam      = 0;
    pStubMsg->fHasReturn        = 0;
    pStubMsg->fHasExtensions    = 0;
    pStubMsg->fHasNewCorrDesc   = 0;
    pStubMsg->fUnused           = 0;

    pStubMsg->IsClient = TRUE;

    pStubMsg->BufferLength = 0;
    pStubMsg->BufferStart = 0;
    pStubMsg->BufferEnd = 0;
    pStubMsg->uFlags    = 0;

    pStubMsg->fBufferValid = FALSE;
    pStubMsg->ReuseBuffer = FALSE;

    pStubMsg->StackTop = 0;

    pStubMsg->IgnoreEmbeddedPointers = FALSE;
    pStubMsg->PointerBufferMark = 0;
    pStubMsg->pAllocAllNodesContext = 0;
    pStubMsg->pPointerQueueState = 0;

    pStubMsg->FullPtrRefId = 0;
    pStubMsg->PointerLength = 0;

    pStubMsg->dwDestContext = MSHCTX_DIFFERENTMACHINE;
    pStubMsg->pvDestContext = 0;
    pStubMsg->pRpcChannelBuffer = 0;

    pStubMsg->pArrayInfo = 0;

    pStubMsg->dwStubPhase = 0;

    NdrSetupLowStackMark( pStubMsg );
    pStubMsg->pAsyncMsg = 0;
    pStubMsg->pCorrInfo = 0;
    pStubMsg->pCorrMemory = 0;
    pStubMsg->pMemoryList = 0;
}


void
MakeSureWeHaveNonPipeArgs(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferSize )
/*

Routine description:

    This routine is called for pipe calls at the server.
    After the runtime dispatched to the stub with the first packet,
    it makes sure that we have a portion of the buffer big enough
    to keep all the non-pipe args.

Arguments:

    BufferSize - a pipe call: addtional number of bytes over what we have.

Note:

    The buffer location may change from before to after the call.

*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;

    if ( !(pRpcMsg->RpcFlags & RPC_BUFFER_COMPLETE ) )
        {
        // May be the args fit into the first packet.

        if ( BufferSize <= pRpcMsg->BufferLength )
            return;

        // Set the partial flag to get the non-pipe args.
        // For a partial call with the "extra", the meaning of the size
        // arg is the addition required above what we have already.

        pRpcMsg->RpcFlags |= (RPC_BUFFER_PARTIAL |  RPC_BUFFER_EXTRA);

        // We will receive at least BufferSize.
        // (buffer location may change)

        BufferSize -= pRpcMsg->BufferLength;

        Status = I_RpcReceive( pRpcMsg, (unsigned int) BufferSize );

        if ( Status != RPC_S_OK )
            {
            // Note, that for this particular error case, i.e. non-pipe
            // data receive failing, we don't want to restore the 
            // original dispatch buffer into the rpc message.
            // In case of an error the buffer coming back here would be 0.
            //
            RpcRaiseException( Status );
            }

        NDR_ASSERT( 0 == BufferSize ||
                    NULL != pRpcMsg->Buffer,
                    "Rpc runtime returned an invalid buffer.");

        // In case this is a new buffer

        pStubMsg->Buffer      = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;
        }
}


unsigned char * RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    )
/*++

Routine Description :

    This routine is called by the server stubs before unmarshalling.
    It initializes the stub message fields.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure

Note.
    NdrServerInitializeNew is almost identical to NdrServerInitializePartial.
    NdrServerInitializeNew is generated for non-pipes and is backward comp.
    NdrServerInitializePartial is generated for routines with pipes args.

--*/
{
    NdrServerInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor );

    if ( pStubDescriptor->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pStubDescriptor->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ServerInitializeNew : bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    //
    // This is where we initialize fields behind the NT3.5 - NT5.0 field set.
    //
#ifdef _CS_CHAR_
    if ( NDR_VERSION_6_0 <= pStubDescriptor->Version )
        {
        pStubMsg->pCSInfo = 0;
        }
#endif // _CS_CHAR_
    if ( !(pRpcMsg->RpcFlags & RPC_BUFFER_COMPLETE ) )
        {
        // A non-pipe call with an incomplete buffer.
        // This can happen only for non-pipe calls in an interface that
        // has some pipe calls. 

        RPC_STATUS Status;

        pRpcMsg->RpcFlags = RPC_BUFFER_EXTRA;

        // The size argument is ignored, we will get everything.

        Status = I_RpcReceive( pRpcMsg, 0 );

        if ( Status != RPC_S_OK )
            {
            // This is the same behavior (and comment) as in MakeSure..
            //    routine above for non-pipe data case in a pipe call.
            // For this particular error case, i.e. a call to Receive to get 
            // all (non-pipe) data failing, we don't want to restore the 
            // original dispatch buffer into the rpc message.
            // In case of an error the buffer coming back here would be 0.
            //
            RpcRaiseException( Status );
            }

        NDR_ASSERT( 0 == pRpcMsg->BufferLength ||
                    NULL != pRpcMsg->Buffer,
                    "Rpc runtime returned an invalid buffer.");

        // In case this is a new buffer

        pStubMsg->Buffer      = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;
        }

    return 0;
}

unsigned char * RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor )
/*++

Routine Description :

    This routine is called by the server stubs before unmarshalling.
    It initializes the stub message fields.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure

Note :

    This is a core server-side initializer, called by everybody.
    
    This routine has to be backward compatible with the old binaries built from
    -Os stubs. In particular, it cannot touch StubMsg fields outside of 
    the NT3.5 - NT5.0 field set, i.e. set of fields present since NT3.5 release.

--*/
{
    pStubMsg->IsClient = FALSE;
    pStubMsg->pAllocAllNodesContext = 0;
    pStubMsg->pPointerQueueState = 0;
    pStubMsg->IgnoreEmbeddedPointers = FALSE;
    pStubMsg->PointerBufferMark = 0;
    pStubMsg->BufferLength = 0;
    pStubMsg->StackTop = 0;

    pStubMsg->FullPtrXlatTables = 0;
    pStubMsg->FullPtrRefId = 0;
    pStubMsg->PointerLength = 0;

    pStubMsg->fDontCallFreeInst = 0;
    pStubMsg->fInDontFree       = 0;
    pStubMsg->fInOnlyParam      = 0;
    pStubMsg->fHasReturn        = 0;
    pStubMsg->fHasExtensions    = 0;
    pStubMsg->fHasNewCorrDesc   = 0;
    pStubMsg->fUnused           = 0;

    pStubMsg->dwDestContext = MSHCTX_DIFFERENTMACHINE;
    pStubMsg->pvDestContext = 0;
    pStubMsg->pRpcChannelBuffer = 0;

    pStubMsg->pArrayInfo = 0;

    pStubMsg->RpcMsg = pRpcMsg;
    pStubMsg->Buffer = (uchar*)pRpcMsg->Buffer;

    //
    // Set BufferStart and BufferEnd before unmarshalling.
    // NdrPointerFree uses these values to detect pointers into the
    // rpc message buffer.
    //
    pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;
    pStubMsg->uFlags      = 0;

    pStubMsg->pfnAllocate = pStubDescriptor->pfnAllocate;
    pStubMsg->pfnFree     = pStubDescriptor->pfnFree;

    pStubMsg->StubDesc = pStubDescriptor;
    pStubMsg->ReuseBuffer = FALSE;

    pStubMsg->dwStubPhase = 0;

    NdrSetupLowStackMark( pStubMsg );
    pStubMsg->pAsyncMsg = 0;
    pStubMsg->pCorrInfo = 0;
    pStubMsg->pCorrMemory = 0;
    pStubMsg->pMemoryList = 0;

    NdrRpcSetNDRSlot( pStubMsg );
    return(0);
}

void RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned long           RequestedBufferSize )
/*++

Routine Description :

    This routine is called by the server stubs for pipes.
    It is almost identical to NdrServerInitializeNew, except that
    it calls NdrpServerInitialize.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure
    pBuffer         - pointer to the beginning of the RPC message buffer

--*/
{
    NdrServerInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor );

    if ( pStubDescriptor->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pStubDescriptor->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ServerInitializePartial : bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    //
    // This is where we initialize fields behind the NT3.5 - NT5.0 field set.
    //
#ifdef _CS_CHAR_
    if ( NDR_VERSION_6_0 <= pStubDescriptor->Version )
        {
        pStubMsg->pCSInfo = 0;
        }
#endif _CS_CHAR_    
    // Last but not least...

    MakeSureWeHaveNonPipeArgs( pStubMsg, RequestedBufferSize );
}


unsigned char * RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle )
/*++

Routine Description :

    Performs an RpcGetBuffer.

Arguments :

    pStubMsg        - Pointer to stub message structure.
    BufferLength    - Length of requested rpc message buffer.
    Handle          - Bound handle.

--*/
{
    RPC_STATUS    Status;

    if ( pStubMsg->IsClient )
        pStubMsg->RpcMsg->Handle = pStubMsg->SavedHandle = Handle;

    pStubMsg->RpcMsg->BufferLength = BufferLength;

    Status = I_RpcGetBuffer( pStubMsg->RpcMsg );

    if ( Status )
        {
        // For raw rpc, if async, don't call abort later.

        if ( pStubMsg->pAsyncMsg )
            pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;

        RpcRaiseException( Status );
        }

    NDR_ASSERT( 0 == BufferLength ||
                NULL != pStubMsg->RpcMsg->Buffer,
                "Rpc runtime returned an invalid buffer.");

    NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}


void
EnsureNSLoaded()
/*++

Routine Description :

    Guarantee that the RpcNs4 DLL is loaded.  Throw exception if unable
    to load it.
    Will load the RpcNs4 DLL if not already loaded

Arguments :


--*/
{
    HINSTANCE   DllHandle;
    LPSTR       EntryName;


    if ( NsDllLoaded )
        return;

#ifdef DOSWIN32RPC
    DllHandle    = LoadLibraryA( "RPCNS4" );
#else
    DllHandle    = LoadLibraryW( L"RPCNS4" );
#endif // DOSWIN32RPC

    if ( DllHandle == 0 )
        {
        RpcRaiseException (RPC_S_INVALID_BINDING);
        }

    EntryName = "I_RpcNsGetBuffer";


    pRpcNsGetBuffer = (RPC_NS_GET_BUFFER_ROUTINE)
                      GetProcAddress( DllHandle,
                                      EntryName);

    if ( pRpcNsGetBuffer == 0 )
        {
        RpcRaiseException (RPC_S_INVALID_BINDING);
        }

    EntryName = "I_RpcNsSendReceive";


    pRpcNsSendReceive = (RPC_NS_SEND_RECEIVE_ROUTINE)
                        GetProcAddress( DllHandle,
                                        EntryName);

    if ( pRpcNsSendReceive == 0 )
        {
        RpcRaiseException (RPC_S_INVALID_BINDING);
        }


    EntryName = "I_RpcNsNegotiateTransferSyntax";
    pRpcNsNegotiateTransferSyntax = ( RPC_NS_NEGOTIATETRANSFERSYNTAX_ROUTINE )
                                    GetProcAddress( DllHandle,
                                                    EntryName );
                                                    
    if ( pRpcNsNegotiateTransferSyntax == 0 )
        {
        RpcRaiseException (RPC_S_INVALID_BINDING);
        }

    NsDllLoaded = 1;
}


unsigned char * RPC_ENTRY
NdrNsGetBuffer( PMIDL_STUB_MESSAGE    pStubMsg,
                unsigned long         BufferLength,
                RPC_BINDING_HANDLE    Handle )
/*++

Routine Description :

    Performs an RpcNsGetBuffer.
    Will load the RpcNs4 DLL if not already loaded

Arguments :

    pStubMsg        - Pointer to stub message structure.
    BufferLength    - Length of requested rpc message buffer.
    Handle          - Bound handle

--*/
{
    RPC_STATUS    Status;

    if( pStubMsg->IsClient == TRUE )
        pStubMsg->RpcMsg->Handle = pStubMsg->SavedHandle = Handle;

    EnsureNSLoaded();

    pStubMsg->RpcMsg->BufferLength = BufferLength;

    Status = (*pRpcNsGetBuffer)( pStubMsg->RpcMsg );

    if ( Status )
        RpcRaiseException( Status );

    NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}

unsigned char * RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferEnd )
/*++

Routine Description :

    Performs an RpcSendRecieve.
    This routine is executed for the non-pipe calls only.
    It returns a whole marshaling buffer.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - End of the rpc message buffer being sent.

Return :

    The new message buffer pointer returned from the runtime after the
    SendReceive call to the server.

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg;

    pRpcMsg = pStubMsg->RpcMsg;

    if ( pRpcMsg->BufferLength <
                    (uint)(pBufferEnd - (uchar *)pRpcMsg->Buffer))
        {
        NDR_ASSERT( 0, "NdrSendReceive : buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    pRpcMsg->BufferLength = (ulong)(pBufferEnd - (uchar *)pRpcMsg->Buffer);

    pStubMsg->fBufferValid = FALSE;

    Status = I_RpcSendReceive( pRpcMsg );

    if ( Status )
        RpcRaiseException(Status);

    NDR_ASSERT( 0 == pRpcMsg->BufferLength ||
                NULL != pRpcMsg->Buffer,
                "Rpc runtime returned an invalid buffer.");  

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferStart = pStubMsg->Buffer;
    pStubMsg->BufferEnd   = pStubMsg->Buffer + pRpcMsg->BufferLength;
    pStubMsg->fBufferValid = TRUE;

    return 0;
}


unsigned char * RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar *                 pBufferEnd,
    RPC_BINDING_HANDLE *    pAutoHandle )
/*++

Routine Description :

    Performs an RpcNsSendRecieve for a procedure which uses an auto handle.
    Will load the RpcNs4 DLL if not already loaded

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - End of the rpc message buffer being sent.
    pAutoHandle - Pointer to the auto handle used in the call.

Return :

    The new message buffer pointer returned from the runtime after the
    SendReceive call to the server.

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg;

    EnsureNSLoaded();

    pRpcMsg = pStubMsg->RpcMsg;

    if ( pRpcMsg->BufferLength <
                    (uint)(pBufferEnd - (uchar *)pRpcMsg->Buffer) )
        {
        NDR_ASSERT( 0, "NdrNsSendReceive : buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    pRpcMsg->BufferLength = (ulong)(pBufferEnd - (uchar *)pRpcMsg->Buffer);

    pStubMsg->fBufferValid = FALSE;

    Status = (*pRpcNsSendReceive)( pRpcMsg, pAutoHandle );

    if ( Status )
        RpcRaiseException(Status);

    pStubMsg->SavedHandle = *pAutoHandle;

    pStubMsg->Buffer = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferStart = pStubMsg->Buffer;
    pStubMsg->BufferEnd   = pStubMsg->Buffer + pRpcMsg->BufferLength;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}

void RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE pStubMsg )
/*++

Routine Description :

    Performs an RpcFreeBuffer.

Arguments :

    pStubMsg    - pointer to stub message structure

Return :

    None.

--*/
{
    RPC_STATUS    Status;

    if ( ! pStubMsg->fBufferValid )
        return;

    if( ! pStubMsg->RpcMsg->Handle )
        return;

    Status = I_RpcFreeBuffer( pStubMsg->RpcMsg );

    pStubMsg->fBufferValid = FALSE;

    if ( Status )
        RpcRaiseException(Status);
}

void *  RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE  pStubMsg,
    size_t              Len )
/*++

Routine Description :

    Private allocator.  Handles allocate all nodes cases.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    Len         - Number of bytes to allocate.

Return :

    Valid memory pointer.

--*/
{
    void * pMemory;

    if ( pStubMsg->pAllocAllNodesContext )
        {
        //
        // We must guarantee 4 byte alignment on NT and MAC.
        //
#if defined(__RPC_WIN64__)
        ALIGN(pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory,7);
#else
        ALIGN(pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory,3);
#endif

        // Get the pointer.
        pMemory = pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory;

        // Increment the block pointer.
        pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory += Len;

        //
        // Check for memory allocs past the end of our allocated buffer.
        //
        if ( pStubMsg->pAllocAllNodesContext->AllocAllNodesMemoryEnd < 
             pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory )
            {
            NDR_ASSERT( pStubMsg->pAllocAllNodesContext->AllocAllNodesMemory <=
                        pStubMsg->pAllocAllNodesContext->AllocAllNodesMemoryEnd,
                        "Not enough alloc all nodes memory!" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            }

        return pMemory;
        }
    else
        {
        size_t NodeOffset, FullSize;
        PNDR_MEMORY_LIST_TAIL_NODE pMemoryList;

        // Add linked list node to tail of allocation. Ensure that the tail
        // is at a 8 byte alignment so that the same code will work in 64bits.
        NodeOffset = Len;

        LENGTH_ALIGN(NodeOffset, 7); 
        
        FullSize = NodeOffset + sizeof(NDR_MEMORY_LIST_TAIL_NODE);

        if ( ! (pMemory = (*pStubMsg->pfnAllocate)( FullSize )) )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        pMemoryList = (PNDR_MEMORY_LIST_TAIL_NODE)((char *)pMemory + NodeOffset);

        pMemoryList->Signature = NDR_MEMORY_LIST_SIGNATURE;
        pMemoryList->pMemoryHead = pMemory;
        pMemoryList->pNextNode = (PNDR_MEMORY_LIST_TAIL_NODE)pStubMsg->pMemoryList;
        pStubMsg->pMemoryList =  pMemoryList; 

        return pMemory;
        }
}

void
NdrpFreeMemoryList(
    MIDL_STUB_MESSAGE *     pStubMsg)
/*++

Routine Description :

    Freeing the list of memory allocated by NdrAllocate.

Arguments :

    pStubMsg    - Pointer to stub message structure.

Return :

    None.

--*/
{
  RpcTryExcept
      {
         while(pStubMsg->pMemoryList) 
              {
              PNDR_MEMORY_LIST_TAIL_NODE pMemoryList = 
                  (PNDR_MEMORY_LIST_TAIL_NODE)pStubMsg->pMemoryList;

              if (pMemoryList->Signature != NDR_MEMORY_LIST_SIGNATURE) 
                 {
                 NDR_ASSERT( 0 , "bad rpc allocated memory signature" );
                 return;
                 }

              pStubMsg->pMemoryList = pMemoryList->pNextNode;
              (*pStubMsg->pfnFree)(pMemoryList->pMemoryHead); 
              }
      }
  RpcExcept(1)
      {
         // Something is wrong and perhaps memory has been corrupted.   If this happens,
         // just ignore the exception and stop freeing memory.   This will duplicate the 
         // behavior of NDR without the linked list.

      }
  RpcEndExcept
}
    

unsigned char * RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    PRPC_MESSAGE            pRpcMsg )
/*++

Routine Description :

    Old NT Beta2 (build 683) server stub initialization routine.  Used for
    backward compatability only.

Aruguments :

    pStubMsg        - Pointer to the stub message structure.
    pStubDescriptor    - Pointer to the stub descriptor structure.
    pBuffer            - Pointer to the beginning of the RPC message buffer.

--*/
{
    return NdrServerInitialize( pRpcMsg,
                                pStubMsg,
                                pStubDescriptor );
}

void RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg )
/*++

Routine Description :

    Old NT Beta2 (build 683) server stub initialization routine.  Used for
    backward compatability only.

Arguments :

    pRpcMsg         - Pointer to the RPC message structure.
    pStubMsg        - Pointer to the stub message structure.

--*/
{
}

//
// Functions to simulate a alloca across a function call.
// Note that this code is optimized for simplicity and speed.  It does 
// not attempt to search a list on each allocation to reuse partially full
// blocks as much as it could.  This gives max speed, but hurts space
// utilization when allocations of significantly different sizes are requested.
//
// This code can easily be optimized more in the future.

#if defined(NDR_PROFILE_ALLOCA)

VOID
NdrpAllocaWriteLog( CHAR *pChar, DWORD Size )
{

    HANDLE hMutex = NULL;
    HANDLE hLogFile = INVALID_HANDLE_VALUE;
    BOOL bHasMutex = FALSE;   

    RpcTryFinally
       {

       
       // Open and acquire the log mutex
       hMutex = CreateMutex( NULL, FALSE, "NDR_ALLOCA_LOG_MUTEX");
       if ( !hMutex) return;

       DWORD dwWaitResult = WaitForSingleObject( hMutex, INFINITE );
       if ( WAIT_FAILED == dwWaitResult ) return;
       bHasMutex = TRUE;         
 
       CHAR LogFile[MAX_PATH];
       UINT DirResult = 
           GetSystemDirectoryA( LogFile, sizeof(LogFile) );

       if ( !DirResult) return;

       strcat( LogFile, "\\ndralloca.log" );

       hLogFile = CreateFileA( LogFile, 
                               GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                               NULL );

       SetFilePointer( hLogFile, 0, NULL, FILE_END );

       DWORD dwBytesWritten;
       WriteFile( hLogFile, pChar, Size, &dwBytesWritten, NULL ); 

       }
   RpcFinally
       {
       if ( bHasMutex ) ReleaseMutex( hMutex );
       if ( NULL != hMutex) CloseHandle( hMutex );
       if ( INVALID_HANDLE_VALUE != hLogFile )  CloseHandle( hLogFile );
       }
   RpcEndFinally

}

VOID
NdrpAllocaDumpStatistics(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    )
{

   // Produce a record suitable for entry into Excel.
   CHAR DataBuffer[4048];
   CHAR AppName[MAX_PATH];
   memset(AppName, 0, sizeof(AppName ) );

   GetModuleFileNameA( NULL, AppName, sizeof(AppName ) ); 

   sprintf( DataBuffer, "EXE,%s,PID,0x%X,TID,0x%x,CS,%d,AB,%d,AA,%d,MB,%d,MA,%d\r\n",
            AppName,
            GetCurrentProcessId(),
            GetCurrentThreadId(),
            (long)NDR_ALLOCA_PREALLOCED_BLOCK_SIZE,
            pAllocaContext->AllocaBytes,
            pAllocaContext->AllocaAllocations,
            pAllocaContext->MemoryBytes,
            pAllocaContext->MemoryAllocations );

   NdrpAllocaWriteLog( DataBuffer, strlen( DataBuffer ) );

}

#endif

VOID
NdrpAllocaInit(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    )
/*++

Routine Description :

    Initiaizes the alloca context. 

Arguments :

    pAllocaContext  - Pointer to the Alloca context..

Return :

    None.

--*/
{

    pAllocaContext->pBlockPointer = pAllocaContext->PreAllocatedBlock;
    pAllocaContext->BytesRemaining = NDR_ALLOCA_PREALLOCED_BLOCK_SIZE;

#if defined(NDR_PROFILE_ALLOCA)
    pAllocaContext->AllocaBytes = 0;
    pAllocaContext->AllocaAllocations = 0;
    pAllocaContext->MemoryBytes = 0;
    pAllocaContext->MemoryAllocations = 0;
#endif
    
    InitializeListHead( &pAllocaContext->MemoryList );

}

VOID
NdrpAllocaDestroy(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    )
/*++

Routine Description :

    Deinitializes this Alloca context and frees all memory
    from the allocation calls that were associated with this context. 

Arguments :

    pAllocaContext  - Pointer to the Alloca context.

Return :

    None.

--*/
{

#if defined(NDR_PROFILE_ALLOCA)
    NdrpAllocaDumpStatistics( pAllocaContext );
#endif

    PLIST_ENTRY pMemoryList = pAllocaContext->MemoryList.Flink; 

    while( pMemoryList != &pAllocaContext->MemoryList ) 
       {
       PLIST_ENTRY pMemoryListNext = pMemoryList->Flink;
       
       I_RpcFree( pMemoryList );
       
       pMemoryList = pMemoryListNext;
       }

    InitializeListHead( &pAllocaContext->MemoryList );

}

PVOID 
NdrpAlloca(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    UINT Size 
    )
/*++

Routine Description :

    Allocates memory from the allocation context. If no memory is available 
    in the cache, more memory is added.  If more memory can not be
    added, a RPC_S_NO_MEMORY exception is raised.     

Arguments :

    pAllocaContext  - Pointer to the Alloca context.
    Size            - Size of the memory to allocate.

Return :

    Newly allocated memory.

--*/
{
    PVOID pReturnedBlock;

    LENGTH_ALIGN( Size, 15 );

#if defined(NDR_PROFILE_ALLOCA)
    pAllocaContext->AllocaAllocations++;
    pAllocaContext->AllocaBytes += Size;
#endif

    // Check if the current block has enough memory to handle the request.
    if (Size > pAllocaContext->BytesRemaining) 
       {

       // Allocate a new block
       ULONG NewBlockSize = max( Size + sizeof(LIST_ENTRY), 
                                 NDR_ALLOCA_MIN_BLOCK_SIZE );

#if defined(NDR_PROFILE_ALLOCA)
       pAllocaContext->MemoryAllocations++;
       pAllocaContext->MemoryBytes += NewBlockSize;
#endif

       PBYTE pNewBlock = (PBYTE)I_RpcAllocate( NewBlockSize );

       if ( !pNewBlock ) 
          {
          
          RpcRaiseException( RPC_S_OUT_OF_MEMORY );
          return NULL; // keep the compiler happy
          }

       InsertHeadList( &pAllocaContext->MemoryList, (PLIST_ENTRY) pNewBlock);
       pAllocaContext->pBlockPointer = pNewBlock + sizeof(LIST_ENTRY);
       pAllocaContext->BytesRemaining = NewBlockSize - sizeof(LIST_ENTRY);

       }

    // alloc memory from an existing block.
    pReturnedBlock = pAllocaContext->pBlockPointer;
    pAllocaContext->pBlockPointer += Size;
    pAllocaContext->BytesRemaining -= Size;

    return pReturnedBlock;

}

PVOID
NdrpPrivateAllocate(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    UINT Size 
    )
/*++

Routine Description :

    Allocates memory using I_RpcAllocate and adds the memory to the
    memory list block.  If no memory is available, and RPC_S_OUT_OF_MEMORY exception
    is thrown.     

Arguments :

    pAllocaContext  - Pointer to the Alloca context.
    Size            - Size of the memory to allocate.

Return :

    Newly allocated memory.

--*/
{
    UINT AllocSize = sizeof(LIST_ENTRY) + Size;

    PBYTE pNewBlock = (PBYTE)I_RpcAllocate( AllocSize );

    if ( !pNewBlock ) 
       {
       RpcRaiseException( RPC_S_OUT_OF_MEMORY );
       return NULL; // keep the compiler happy
       }

    InsertHeadList( &pAllocaContext->MemoryList, (PLIST_ENTRY) pNewBlock);
    return ((uchar *)pNewBlock) + sizeof(PLIST_ENTRY);

}

void
NdrpPrivateFree(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    void *pMemory 
    )
/*++

Routine Description :

    Frees memory allocated with NdrpPrivateAllocate     

Arguments :

    pAllocaContext  - Pointer to the Alloca context.
    pMemory         - Memory allocated with NdrpPrivateAllocate.

Return :

    None.

--*/
{
    PLIST_ENTRY pListEntry;

    if (NULL == pMemory) 
        return;

    pListEntry = (PLIST_ENTRY)( ((uchar *)pMemory) - sizeof(LIST_ENTRY) );

    RemoveEntryList( pListEntry );
    I_RpcFree( pListEntry );
}

void
NdrpInitUserMarshalCB(
    MIDL_STUB_MESSAGE   *   pStubMsg,
    PFORMAT_STRING          pFormat,
    USER_MARSHAL_CB_TYPE    CBType,
    USER_MARSHAL_CB     *   pUserMarshalCB
    )
/*++

Routine Description :

    Initialize a user marshall callback structure.
    
Arguments :

    pStubMsg         - Supplies the stub message for the call.
    pFormat          - Supplies the format string for the type(FC_USER_MARSHAL). 
    CBType           - Supplies the callback type.   
    pUserMarshalCB   - Pointer to the callback to be initialized.

Return :

    None.

--*/
{

    pUserMarshalCB->Flags    = USER_CALL_CTXT_MASK( pStubMsg->dwDestContext );
    if ( USER_MARSHAL_CB_UNMARSHALL == CBType )
        {
        pUserMarshalCB->Flags |=
            (((pStubMsg->RpcMsg->DataRepresentation & (ulong)0x0000FFFF)) << 16 );  
        }
    if ( pStubMsg->pAsyncMsg )
        pUserMarshalCB->Flags |= USER_CALL_IS_ASYNC;
    if ( pStubMsg->fHasNewCorrDesc )
        pUserMarshalCB->Flags |= USER_CALL_NEW_CORRELATION_DESC;
    
    pUserMarshalCB->pStubMsg = pStubMsg;
    pUserMarshalCB->pReserve = (pFormat[1] & USER_MARSHAL_IID)  ? pFormat + 10
                                                                : 0;
    pUserMarshalCB->Signature = USER_MARSHAL_CB_SIGNATURE;
    pUserMarshalCB->CBType = CBType;

    pUserMarshalCB->pFormat = pFormat;
    pUserMarshalCB->pTypeFormat = pFormat + 8;
    pUserMarshalCB->pTypeFormat = pUserMarshalCB->pTypeFormat +
                                  *(short *)pUserMarshalCB->pTypeFormat;

}

RPC_STATUS
RPC_ENTRY
NdrGetUserMarshalInfo (
    IN unsigned long          * pFlags,
    IN unsigned long            InformationLevel,
    OUT NDR_USER_MARSHAL_INFO * pMarshalInfo
    )
/*++

Routine Description :

    The NdrGetUserMarshalInfo function is called by a application provided
    wire_marshal or user_marshal helper function to receive extra information
    in addition to the pFlags parameter.
    
Arguments :

    pFlags           - Supplies the pFlags pointer that rpc passed to the helper function.
    InformationLevel - Supplies the desired level of detail to be received. The amount of
                       information increases as the level increases.  
    pMarshalInfo     - Points to the buffer that is to receive the extra information.   

Return :

    On sucesss - RPC_S_OK.

--*/
{

    MIDL_STUB_MESSAGE *pStubMsg;
    USER_MARSHAL_CB * pCBInfo = (USER_MARSHAL_CB *)pFlags; 

    if ( InformationLevel != 1)
       {
       return RPC_S_INVALID_ARG;
       }

    RpcTryExcept
       {
       if ( USER_MARSHAL_CB_SIGNATURE != pCBInfo->Signature )
          {
          return RPC_S_INVALID_ARG;    
          }
       MIDL_memset( pMarshalInfo, 0, sizeof(NDR_USER_MARSHAL_INFO) ); 
       }
    RpcExcept(1)
        {
        return RPC_S_INVALID_ARG;
        }
    RpcEndExcept   

       
    pMarshalInfo->InformationLevel = InformationLevel;
    pStubMsg = pCBInfo->pStubMsg;

    // The buffer pointer and the buffer length only
    // make sense if the callback is for marshalling
    // and unmarshalling.
    if ( USER_MARSHAL_CB_MARSHALL == pCBInfo->CBType ||
         USER_MARSHAL_CB_UNMARSHALL == pCBInfo->CBType )
       {

       char *CurrentBuffer = (char *)pStubMsg->Buffer;
       char *BufferStart = (char *)pStubMsg->RpcMsg->Buffer;
       unsigned long BufferUsed = (unsigned long)(ULONG_PTR)(CurrentBuffer 
                                                             - BufferStart);   
       unsigned long BufferLength = pStubMsg->RpcMsg->BufferLength - BufferUsed;

       if ( CurrentBuffer < BufferStart ||
            CurrentBuffer > (BufferStart + pStubMsg->RpcMsg->BufferLength ) )
          {
             return RPC_X_INVALID_BUFFER;
          }
       
       pMarshalInfo->Level1.Buffer = pStubMsg->Buffer;
       pMarshalInfo->Level1.BufferSize = BufferLength;
       }
    
    pMarshalInfo->Level1.pfnAllocate = pStubMsg->pfnAllocate;
    pMarshalInfo->Level1.pfnFree = pStubMsg->pfnFree;
    pMarshalInfo->Level1.pRpcChannelBuffer = pStubMsg->pRpcChannelBuffer;
    pMarshalInfo->Level1.Reserved[0] = (ULONG_PTR)pCBInfo->pFormat;
    pMarshalInfo->Level1.Reserved[1] = (ULONG_PTR)pCBInfo->pTypeFormat;

    return RPC_S_OK;    

}



void RPC_ENTRY
RpcUserFree( HANDLE AsyncHandle, void * pBuffer )
{
    PMIDL_STUB_MESSAGE pStubMsg;
    RPC_STATUS Status;
    PRPC_ASYNC_STATE pHandle = ( PRPC_ASYNC_STATE) AsyncHandle;
    // User passes in NULL in sync case.
    if ( NULL == pHandle )
        {
        pStubMsg = (PMIDL_STUB_MESSAGE )I_RpcGetNDRSlot();
        Status = S_OK;
        }
    else
        {
        Status = NdrValidateBothAndLockAsyncHandle( pHandle);
        if ( Status == RPC_S_OK )
            {
            PNDR_ASYNC_MESSAGE pAsyncMsg = (PNDR_ASYNC_MESSAGE) pHandle->StubInfo;
            pStubMsg = &pAsyncMsg->StubMsg;
            }
        }

    // REVIEW: default behavior is not to raise exception?
    if ( Status != RPC_S_OK )
        {
        NDR_ASSERT( 0, "invalid rpc handle" );
        return ;
        }
        
    // validate the stubmsg.
    NDR_ASSERT( pStubMsg, "invalid stub message" );

    // We'll call into user's free routine to free the buffer if it's not 
    // part of dispatch buffer. 
    // We don't care about allocate_on_stack: it can only happen on top level
    // out ref pointer or ref pointer to pointer case, and freeing that is 
    // very much shooting self on the foot.
    if (  (pBuffer < pStubMsg->BufferStart) || (pBuffer > pStubMsg->BufferEnd))
        {
        pStubMsg->pfnFree( pBuffer );
        }
    else
        return;
        
}


BOOL
IsWriteAV (

    IN struct _EXCEPTION_POINTERS *ExceptionPointers

    )

{

    EXCEPTION_RECORD *ExceptionRecord;

 

    ExceptionRecord = ExceptionPointers->ExceptionRecord;

    if ((ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION)

        && (ExceptionRecord->ExceptionInformation[0]))

        {

        return TRUE;

        }

    else

        return FALSE;

}


int RPC_ENTRY
NdrServerUnmarshallExceptionFlag(
    IN struct _EXCEPTION_POINTERS *ExceptionPointers
)
{
    RPC_STATUS ExceptCode = ExceptionPointers->ExceptionRecord->ExceptionCode;
    if ( ( ExceptCode != STATUS_POSSIBLE_DEADLOCK )  && 
        ( ExceptCode != STATUS_INSTRUCTION_MISALIGNMENT )   && 
        ( ExceptCode != STATUS_DATATYPE_MISALIGNMENT )  && 
        ( ExceptCode != STATUS_PRIVILEGED_INSTRUCTION )  && 
        ( ExceptCode != STATUS_ILLEGAL_INSTRUCTION )  && 
        ( ExceptCode != STATUS_BREAKPOINT ) && 
        ( ExceptCode != STATUS_STACK_OVERFLOW ) && 
        !IsWriteAV(ExceptionPointers) ) 
        return EXCEPTION_EXECUTE_HANDLER;
    else
        return EXCEPTION_CONTINUE_SEARCH;
                
}



// check for overflow when calculating the total size. 
#if defined(_X86_)
ULONG MultiplyWithOverflowCheck( ULONG_PTR Count, ULONG_PTR ELemSize )
{
    register UINT32 IsOverFlowed = 0;
    NDR_ASSERT(  Count < 0x80000000, "invalid count" );
    NDR_ASSERT(  ELemSize < 0x80000000 , "invalid element size" );
    ULONG res = Count * ELemSize;
    __asm 
        {
        jno skip;
        mov IsOverFlowed, 1;
        skip:
        }
    if ( IsOverFlowed || res > 0x7fffffff )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    return res;
}
#else   // we only have ia64 & amd64 here.
ULONG MultiplyWithOverflowCheck( ULONG_PTR Count, ULONG_PTR ElemSize )
{
    NDR_ASSERT( Count < 0x80000000, "invalid count" );
    NDR_ASSERT( ElemSize < 0x80000000 , "invalid element size" );
    UINT64 res = (UINT64)Count * ElemSize;
    if ( res > 0x7fffffff )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    return (ULONG) res ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cssup.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name :

    cssup.h

Abstract :

    Declarations of private international (cs) support stuff

Author :

    Mike Warning    MikeW   August 1999.

Revision History :

---------------------------------------------------------------------*/

#ifndef _CSSUP_H_
#define _CSSUP_H_


#define CP_UNICODE 1200


BOOL GetThreadACP(
        unsigned long      *cp, 
        error_status_t     *pStatus);


ulong TranslateCodeset(ulong Codeset);


__inline
void InitializeStubCSInfo(PMIDL_STUB_MESSAGE pStubMsg)
{
    if ( NULL == pStubMsg->pCSInfo )
        {
        pStubMsg->pCSInfo = (CS_STUB_INFO *) 
                                    I_RpcAllocate( sizeof(CS_STUB_INFO) );
        
        if ( NULL == pStubMsg->pCSInfo )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        ZeroMemory( pStubMsg->pCSInfo, sizeof(CS_STUB_INFO) );
        }
}


__inline 
void UninitializeStubCSInfo(PMIDL_STUB_MESSAGE pStubMsg)
{
    I_RpcFree( pStubMsg->pCSInfo );
}

        
ulong
NdrpGetSetCSTagMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    NDR_CS_TAG_FORMAT * pTagFormat);

ulong 
NdrpGetSetCSTagUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_CS_TAG_FORMAT * pTagFormat);


void
NdrpGetArraySizeLength (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                ElementSize,
    long *              pSize,
    long *              pLength,
    long *              pWireSize );


// Note: The flag value is also the length of the prolog for the array on
//       the wire.  Bogus arrays being the exception of course.
#define MARSHALL_CONFORMANCE    0x01
#define MARSHALL_VARIANCE       0x02
#define MARSHALL_BOGUS          0x04

extern const byte NdrpArrayMarshallFlags[];


__inline
int
NdrpArrayPrologLength(
    PFORMAT_STRING      pFormat )
{
    int PrologLength;

    NDR_ASSERT( *pFormat >= FC_CARRAY,  "Invalid array descriptor" );
    NDR_ASSERT( *pFormat <= FC_WSTRING, "Invalid array descriptor" );

    // We don't support bogus arrays for now
    NDR_ASSERT( *pFormat != FC_BOGUS_ARRAY, "Bogus arrays are not supported" );

    PrologLength = NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ];

    // The PrologLength (actually the array type flags) are equal to the number
    // of DWORDs in the prolog

    return PrologLength * 4;
}


__inline
BOOL
NdrpIsConformantArray(
    PFORMAT_STRING  pFormat )
{
    int flags;

    NDR_ASSERT( *pFormat >= FC_CARRAY,  "Invalid array descriptor" );
    NDR_ASSERT( *pFormat <= FC_WSTRING, "Invalid array descriptor" );

    // We don't support bogus arrays for now
    NDR_ASSERT( *pFormat != FC_BOGUS_ARRAY, "Bogus arrays are not supported" );

    flags = NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ];

    return flags & MARSHALL_CONFORMANCE;
}

__inline
BOOL
NdrpIsVaryingArray(
    PFORMAT_STRING  pFormat )
{
    int flags;

    NDR_ASSERT( *pFormat >= FC_CARRAY,  "Invalid array descriptor" );
    NDR_ASSERT( *pFormat <= FC_WSTRING, "Invalid array descriptor" );

    // We don't support bogus arrays for now
    NDR_ASSERT( *pFormat != FC_BOGUS_ARRAY, "Bogus arrays are not supported" );

    flags = NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ];

    return flags & MARSHALL_VARIANCE;
}

__inline
BOOL
NdrpIsFixedArray(
    PFORMAT_STRING  pFormat )
{
    int flags;

    NDR_ASSERT( *pFormat >= FC_CARRAY,  "Invalid array descriptor" );
    NDR_ASSERT( *pFormat <= FC_WSTRING, "Invalid array descriptor" );

    // We don't support bogus arrays for now
    NDR_ASSERT( *pFormat != FC_BOGUS_ARRAY, "Bogus arrays are not supported" );

    flags = NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ];

    return ( 0 == flags );
}

#endif // !_CSSUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cvt.h ===
/* file: cvt.h */

/*
**
**                         COPYRIGHT (c) 1989, 1990 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains the public include file for the cvt_* routines.
**      This module contains rountine interfaces as well as necessary
**      definitions.
**
**  Author:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.       MRTL 5-Dec-1989.
**      1-002   Add GEM FORTRAN stuff.  TS 27-Mar-1990.
**
**--
*/


#ifndef CVT
#define CVT 1

/*
 *
 *    Type Definitions
 *
 */

typedef unsigned char CVT_BYTE;
typedef CVT_BYTE *CVT_BYTE_PTR;

typedef CVT_BYTE CVT_VAX_F[4];
typedef CVT_BYTE CVT_VAX_D[8];
typedef CVT_BYTE CVT_VAX_G[8];
typedef CVT_BYTE CVT_VAX_H[16];
typedef CVT_BYTE CVT_IEEE_SINGLE[4];
typedef CVT_BYTE CVT_IEEE_DOUBLE[8];
typedef CVT_BYTE CVT_IBM_SHORT[4];
typedef CVT_BYTE CVT_IBM_LONG[8];
typedef CVT_BYTE CVT_CRAY[8];
typedef float    CVT_SINGLE;
typedef double   CVT_DOUBLE;
typedef long     CVT_SIGNED_INT;
typedef unsigned long CVT_UNSIGNED_INT;
typedef unsigned long CVT_STATUS;


/*
 *
 *    Constant Definitions
 *
 */

#define CVT_C_ROUND_TO_NEAREST               1
#define CVT_C_TRUNCATE                       2
#define CVT_C_ROUND_TO_POS                   4
#define CVT_C_ROUND_TO_NEG                   8
#define CVT_C_VAX_ROUNDING                  16
#define CVT_C_BIG_ENDIAN                    32
#define CVT_C_ERR_UNDERFLOW                 64
#define CVT_C_ZERO_BLANKS                  128
#define CVT_C_SKIP_BLANKS                  256
#define CVT_C_SKIP_UNDERSCORES             512
#define CVT_C_SKIP_UNDERSCORE              512
#define CVT_C_SKIP_TABS                   1024
#define CVT_C_ONLY_E                      2048
#define CVT_C_EXP_LETTER_REQUIRED         4096
#define CVT_C_FORCE_SCALE                 8192
#define CVT_C_EXPONENTIAL_FORMAT         16384
#define CVT_C_FORCE_PLUS                 32768
#define CVT_C_FORCE_EXPONENT_SIGN        65536
#define CVT_C_SUPPRESS_TRAILING_ZEROES  131072
#define CVT_C_FORCE_EXPONENTIAL_FORMAT  262144
#define CVT_C_FORCE_FRACTIONAL_FORMAT   524288
#define CVT_C_EXPONENT_D                1048576
#define CVT_C_EXPONENT_E                2097152
#define CVT_C_SEMANTICS_FORTRAN         4194304
#define CVT_C_SEMANTICS_PASCAL          8388608


#define cvt__normal                     1
#define cvt__invalid_character          2
#define cvt__invalid_option             3
#define cvt__invalid_radix              4
#define cvt__invalid_size               5
#define cvt__invalid_value              6
#define cvt__neg_infinity               7
#define cvt__output_conversion_error    8
#define cvt__overflow                   9
#define cvt__pos_infinity               10
#define cvt__underflow                  11
#define cvt__input_conversion_error     12

#define cvt_s_normal                    cvt__normal
#define cvt_s_invalid_character         cvt__invalid_character
#define cvt_s_invalid_option            cvt__invalid_option
#define cvt_s_invalid_radix             cvt__invalid_radix
#define cvt_s_invalid_size              cvt__invalid_size
#define cvt_s_invalid_value             cvt__invalid_value
#define cvt_s_neg_infinity              cvt__neg_infinity
#define cvt_s_input_conversion_error    cvt__input_conversion_error
#define cvt_s_output_conversion_error   cvt__output_conversion_error
#define cvt_s_overflow                  cvt__overflow
#define cvt_s_pos_infinity              cvt__pos_infinity
#define cvt_s_underflow                 cvt__underflow

#define CVT_C_BIN  2
#define CVT_C_OCT  8
#define CVT_C_DEC 10
#define CVT_C_HEX 16


/*
 *
 *    Routine interfaces
 *
 */

#ifndef PCC

extern void cvt_cray_to_vax_f (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_F output_value
                );

extern void cvt_cray_to_vax_d (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_D output_value
                );

extern void cvt_cray_to_vax_g (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_G output_value
                );

extern void cvt_cray_to_vax_h (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_H output_value
                );

extern void cvt_cray_to_ieee_single (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_SINGLE output_value
                );

extern void cvt_cray_to_ieee_double (
                CVT_CRAY input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_DOUBLE output_value
                );




extern void cvt_ibm_short_to_vax_f (
                CVT_IBM_SHORT input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_F output_value
                );

extern void cvt_ibm_short_to_ieee_single (
                CVT_IBM_SHORT input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_SINGLE output_value
                );




extern void cvt_ibm_long_to_vax_d (
                CVT_IBM_LONG input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_D output_value
                );

extern void cvt_ibm_long_to_vax_g (
                CVT_IBM_LONG input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_G output_value
                );

extern void cvt_ibm_long_to_vax_h (
                CVT_IBM_LONG input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_H output_value
                );

extern void cvt_ibm_long_to_ieee_double (
                CVT_IBM_LONG input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_DOUBLE output_value
                );




extern void cvt_ieee_single_endian (
                CVT_IEEE_SINGLE input_value,
                CVT_IEEE_SINGLE output_value
                );

extern void cvt_ieee_single_to_cray (
                CVT_IEEE_SINGLE input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_ieee_single_to_ibm_short (
                CVT_IEEE_SINGLE input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_SHORT output_value
                );

extern void cvt_ieee_single_to_vax_f (
                CVT_IEEE_SINGLE input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_F output_value
                );




extern void cvt_ieee_double_endian (
                CVT_IEEE_DOUBLE input_value,
                CVT_IEEE_DOUBLE output_value
                );

extern void cvt_ieee_double_to_cray (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_ieee_double_to_ibm_long (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_LONG output_value
                );

extern void cvt_ieee_double_to_vax_d (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_D output_value
                );

extern void cvt_ieee_double_to_vax_g (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_G output_value
                );

extern void cvt_ieee_double_to_vax_h (
                CVT_IEEE_DOUBLE input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_H output_value
                );




extern void cvt_vax_f_to_cray (
                CVT_VAX_F input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_vax_f_to_ibm_short (
                CVT_VAX_F input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_SHORT output_value
                );

extern void cvt_vax_f_to_ieee_single (
                CVT_VAX_F input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_SINGLE output_value
                );




extern void cvt_vax_d_to_cray (
                CVT_VAX_D input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_vax_d_to_ibm_long (
                CVT_VAX_D input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_LONG output_value
                );

extern void cvt_vax_d_to_ieee_double (
                CVT_VAX_D input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_DOUBLE output_value
                );




extern void cvt_vax_g_to_cray (
                CVT_VAX_G input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_vax_g_to_ibm_long (
                CVT_VAX_G input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_LONG output_value
                );

extern void cvt_vax_g_to_ieee_double (
                CVT_VAX_G input_value,
                CVT_SIGNED_INT options,
                CVT_IEEE_DOUBLE output_value
                );




extern void cvt_vax_h_to_cray (
                CVT_VAX_H input_value,
                CVT_SIGNED_INT options,
                CVT_CRAY output_value
                );

extern void cvt_vax_h_to_ibm_long (
                CVT_VAX_H input_value,
                CVT_SIGNED_INT options,
                CVT_IBM_LONG output_value
                );

extern void cvt_vax_h_to_ieee_double (
                CVT_VAX_H input_value,
                CVT_SIGNED_INT options,
                CVT_VAX_H output_value
                );




extern CVT_SINGLE cvt_integer_to_single(
                        CVT_SIGNED_INT,         /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );

extern CVT_DOUBLE cvt_integer_to_double(
                        CVT_SIGNED_INT          /* input_value */
                        );

#ifdef VAX
extern CVT_SIGNED_INT cvt_single_to_integer(
                        CVT_DOUBLE,             /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );
#else
extern CVT_SIGNED_INT cvt_single_to_integer(
                        CVT_SINGLE,             /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );
#endif

extern CVT_SIGNED_INT cvt_double_to_integer(
                        CVT_DOUBLE,             /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );

#ifdef VAX
extern CVT_DOUBLE cvt_single_to_double(
                        CVT_DOUBLE              /* input_value */
                        );
#else
extern CVT_DOUBLE cvt_single_to_double(
                        CVT_SINGLE              /* input_value */
                        );
#endif

extern CVT_SINGLE cvt_double_to_single(
                        CVT_DOUBLE,             /* input_value */
                        CVT_SIGNED_INT          /* options     */
                        );



extern void cvt_integer_endian (
                CVT_UNSIGNED_INT,               /* input_value     */
                CVT_UNSIGNED_INT *              /* output_value    */
                );

extern void cvt_data_endian (
                unsigned char *,                /* input_value     */
                CVT_SIGNED_INT,                 /* value_size      */
                unsigned char *                 /* output_value    */
                );

extern CVT_STATUS cvt_text_to_integer(
                        char *,                 /* input_string    */
                        CVT_SIGNED_INT,         /* string_size     */
                        CVT_SIGNED_INT,         /* options         */
                        CVT_SIGNED_INT *        /* resultant value */
                        );

extern CVT_STATUS cvt_text_to_unsigned(
                        char *,                 /* input_string    */
                        CVT_SIGNED_INT,         /* string_size     */
                        CVT_SIGNED_INT,         /* radix           */
                        CVT_SIGNED_INT,         /* options         */
                        CVT_UNSIGNED_INT *      /* resultant value */
                        );

extern CVT_STATUS cvt_integer_to_text(
                        CVT_SIGNED_INT,         /* input_value      */
                        CVT_SIGNED_INT,         /* string_size      */
                        CVT_SIGNED_INT,         /* number_of_digits */
                        CVT_SIGNED_INT,         /* options          */
                        char *                  /* resultant_string */
                        );

extern CVT_STATUS cvt_unsigned_to_text(
                        CVT_UNSIGNED_INT,       /* input_value      */
                        CVT_SIGNED_INT,         /* string_size      */
                        CVT_SIGNED_INT,         /* radix            */
                        CVT_SIGNED_INT,         /* number_of_digits */
                        char *                  /* resultant_string */
                        );

extern CVT_STATUS cvt_text_to_data(
                        char *,                 /* input_string */
                        CVT_SIGNED_INT,         /* string_size  */
                        CVT_SIGNED_INT,         /* value_size   */
                        CVT_SIGNED_INT,         /* radix        */
                        CVT_SIGNED_INT,         /* options      */
                        unsigned char *);       /* resultant value */

extern CVT_STATUS cvt_data_to_text(
                        unsigned char *,        /* input_value */
                        CVT_SIGNED_INT,         /* string_size */
                        CVT_SIGNED_INT,         /* value_size   */
                        CVT_SIGNED_INT,         /* radix */
                        CVT_SIGNED_INT,         /* number_of_digits */
                        char *);                /* resultant_string */

extern CVT_STATUS cvt_text_to_boolean (
                        char *,                 /* input_string */
                        CVT_SIGNED_INT,         /* string_size  */
                        CVT_SIGNED_INT,         /* options      */
                        CVT_SIGNED_INT *);      /* resultant value */

extern CVT_STATUS cvt_boolean_to_text (
                        CVT_SIGNED_INT,         /* input_value */
                        CVT_SIGNED_INT,         /* string_size */
                        CVT_SIGNED_INT,         /* options */
                        char *);                /* resultant_string */

#else // PCC

extern void cvt_cray_to_vax_f ();
extern void cvt_cray_to_vax_d ();
extern void cvt_cray_to_vax_g ();
extern void cvt_cray_to_vax_h ();
extern void cvt_cray_to_ieee_single ();
extern void cvt_cray_to_ieee_double ();

extern void cvt_ibm_short_to_vax_f ();
extern void cvt_ibm_short_to_ieee_single ();

extern void cvt_ibm_long_to_vax_d ();
extern void cvt_ibm_long_to_vax_g ();
extern void cvt_ibm_long_to_vax_h ();
extern void cvt_ibm_long_to_ieee_double ();

extern void cvt_ieee_single_endian ();
extern void cvt_ieee_single_to_cray ();
extern void cvt_ieee_single_to_ibm_short ();
extern void cvt_ieee_single_to_vax_f ();

extern void cvt_ieee_double_endian ();
extern void cvt_ieee_double_to_cray ();
extern void cvt_ieee_double_to_ibm_long ();
extern void cvt_ieee_double_to_vax_d ();
extern void cvt_ieee_double_to_vax_g ();
extern void cvt_ieee_double_to_vax_h ();

extern void cvt_vax_f_to_cray ();
extern void cvt_vax_f_to_ibm_short ();
extern void cvt_vax_f_to_ieee_single ();

extern void cvt_vax_d_to_cray ();
extern void cvt_vax_d_to_ibm_long ();
extern void cvt_vax_d_to_ieee_double ();

extern void cvt_vax_g_to_cray ();
extern void cvt_vax_g_to_ibm_long ();
extern void cvt_vax_g_to_ieee_double ();

extern void cvt_vax_h_to_cray ();
extern void cvt_vax_h_to_ibm_long ();
extern void cvt_vax_h_to_ieee_double ();

extern void cvt_integer_endian ();
extern void cvt_data_endian ();

extern CVT_SINGLE cvt_integer_to_single();
extern CVT_DOUBLE cvt_integer_to_double();

extern CVT_SIGNED_INT cvt_single_to_integer();
extern CVT_SIGNED_INT cvt_double_to_integer();

extern CVT_DOUBLE cvt_single_to_double();
extern CVT_SINGLE cvt_double_to_single();

extern CVT_STATUS cvt_text_to_integer();
extern CVT_STATUS cvt_text_to_unsigned();

extern CVT_STATUS cvt_integer_to_text();
extern CVT_STATUS cvt_unsigned_to_text();

extern CVT_STATUS cvt_text_to_boolean();
extern CVT_STATUS cvt_text_to_data();

extern CVT_STATUS cvt_boolean_to_text();
extern CVT_STATUS cvt_data_to_text();

#endif
#endif                  /* end of CVT.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cvtg.cxx ===
/* file:  cvt_vax_g.c */

/*
**
**                         COPYRIGHT (c) 1989, 1990 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains routines to convert VAX G_Float floating
**      point data into other supported floating point formats.
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.       MRTL 5-Dec-1989.
**      1-002   Add VMS and F77 bindings.  TS 26-Mar-1990.
**
**--
*/

/*
**
**  TABLE OF CONTENTS
**
**      cvt_vax_g_to_cray
**      cvt_vax_g_to_ibm_long
**      cvt_vax_g_to_ieee_double
**
*/


#include <stdio.h>
#include <sysinc.h>
#include <rpc.h>
#include "cvt.h"
#include "cvtpvt.h"

//
// Added for the MS NT environment
//

#include <stdlib.h>


/*
**
**  Routine:
**
**      cvt_vax_g_to_ieee_double
**
**  Functional Description:
**
**      This routine converts a VAX G_Float floating point number
**      into an IEEE double precision floating point number.
**
**  Formal Parameters:
**
**      input_value     A VAX G_Float floating point number.
**
**      options         An integer bit mask.  Set bits in the mask represent
**                      selected routine options.  Applicable options are:
**
**                           CVT_C_BIG_ENDIAN       - default is little endian
**                           CVT_C_ERR_UNDERFLOW    - Raise underflows
**                           CVT_C_TRUNCATE         - truncate
**                           CVT_C_ROUND_TO_POS     - round to +infinity
**                           CVT_C_ROUND_TO_NEG     - round to -infinity
**                           CVT_C_ROUND_TO_NEAREST - round to nearest
**                           CVT_C_VAX_ROUNDING     - VAX rounding
**
**                      NOTE: If no rounding mode is selected the following
**                      default rounding mode is assumed:
**
**                              CVT_C_ROUND_TO_NEAREST.
**
**      output_value    The IEEE double precision representation of the VAX
**                      G_Float number.
**
**  Side Effects/Signaled Errors:
**
**      cvt__invalid_value      - an invalid input value was specified.
**      cvt__invalid_option     - an invalid option was specified.
**      cvt__underflow          - an underlow occurred during conversion while
**                                Raise underflow was set.
**
*/

/*
 * C binding
 */
void cvt_vax_g_to_ieee_double( 
    CVT_VAX_G input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_DOUBLE output_value )
{
    int i, round_bit_position;
    UNPACKED_REAL r;

    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(cvt__invalid_option);
    }

//  ===========================================================================
//
// This file used to be included as a separate file.
//#include "unp_vaxg.c"
//
//  ===========================================================================

/* file: unpack_vax_g.c */


/*
**
**			   COPYRIGHT (c) 1989 BY
**	     DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**			    ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/


/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains code to extract information from a VAX
**      g_floating number and to initialize an UNPACKED_REAL structure
**      with those bits.
**
**		This module is meant to be used as an include file.
**
**  Author: Math RTL
**
**  Creation Date:  November 24, 1989.
**
**  Modification History:
**
**--
*/


/*
**++
**  Functional Description:
**
**  This module contains code to extract information from a VAX
**  g_floating number and to initialize an UNPACKED_REAL structure
**  with those bits.
**
**  See the header files for a description of the UNPACKED_REAL
**  structure.
** 
**  A VAX g_floating number in (16 bit words) looks like:
** 
**      [0]: Sign bit, 11 exp bits (bias 1024), 4 fraction bits
**      [1]: 16 more fraction bits
**      [2]: 16 more fraction bits
**      [3]: 16 more fraction bits
**
**      0.5 <= fraction < 1.0, MSB implicit
**
**
**  Implicit parameters:
**
**  	input_value: a pointer to the input parameter.
**
**  	r: an UNPACKED_REAL structure
**
**--
*/


	RpcpMemoryCopy(&r[1], input_value, 8);

	/* Initialize FLAGS and perhaps set NEGATIVE bit */

	r[U_R_FLAGS] = (r[1] >> 15) & U_R_NEGATIVE;

	/* Extract VAX biased exponent */

	r[U_R_EXP] = (r[1] >> 4) & 0x000007FFL;

	if (r[U_R_EXP] == 0) {

		if (r[U_R_FLAGS])
			r[U_R_FLAGS] |= U_R_INVALID;
		else
			r[U_R_FLAGS] = U_R_ZERO;

	} else {

		/* Adjust for VAX 16 bit floating format */

		r[1] = ((r[1] << 16) | (r[1] >> 16));
		r[2] = ((r[2] << 16) | (r[2] >> 16));

		/* Add unpacked real bias and subtract VAX bias */

		r[U_R_EXP] += (U_R_BIAS - 1024);

		/* Set hidden bit */

		r[1] |= 0x00100000L;

		/* Left justify fraction bits */

		r[1] <<= 11;
		r[1] |= (r[2] >> 21);
		r[2] <<= 11;

		/* Clear uninitialized part of unpacked real */

		r[3] = 0;
		r[4] = 0;

	}

// end of file: unpack_vax_g.c
//
//  ===========================================================================
//
// This file used to be included as a separate file.
//#include "pack_iet.c"
//
//  ===========================================================================

/* file: pack_ieee_t.c */


/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/


/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains code to extract information from an
**      UNPACKED_REAL structure and to create an IEEE double floating number
**      with those bits.
**
**              This module is meant to be used as an include file.
**
**  Author: Math RTL
**
**  Creation Date:  November 24, 1989.
**
**  Modification History:
**
**--
*/


/*
**++
**  Functional Description:
**
**  This module contains code to extract information from an
**  UNPACKED_REAL structure and to create an IEEE double floating number
**  with those bits.
**
**  See the header files for a description of the UNPACKED_REAL
**  structure.
**
**  A normalized IEEE double precision floating number looks like:
**
**      [0]: 32 low order fraction bits
**      [1]: Sign bit, 11 exp bits (bias 1023), 20 fraction bits
**
**      1.0 <= fraction < 2.0, MSB implicit
**
**  For more details see "Mips R2000 Risc Architecture"
**  by Gerry Kane, page 6-8 or ANSI/IEEE Std 754-1985.
**
**
**  Implicit parameters:
**
**      options: a word of flags, see include files.
**
**      output_value: a pointer to the input parameter.
**
**      r: an UNPACKED_REAL structure.
**
**              i: a temporary integer variable
**
**--
*/



    if (r[U_R_FLAGS] & U_R_UNUSUAL) {

        if (r[U_R_FLAGS] & U_R_ZERO)

                if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        RpcpMemoryCopy(output_value, IEEE_T_NEG_ZERO, 8);
                else
                        RpcpMemoryCopy(output_value, IEEE_T_POS_ZERO, 8);

        else if (r[U_R_FLAGS] & U_R_INFINITY) {

                if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        RpcpMemoryCopy(output_value, IEEE_T_NEG_INFINITY, 8);
                else
                        RpcpMemoryCopy(output_value, IEEE_T_POS_INFINITY, 8);

        } else if (r[U_R_FLAGS] & U_R_INVALID) {

                RpcpMemoryCopy(output_value, IEEE_T_INVALID, 8);
                RAISE(cvt__invalid_value);

        }

    } else {

        /* Precision varies if value will be a denorm */
        /* So, figure out where to round (0 <= i <= 53). */

        round_bit_position = r[U_R_EXP] - ((U_R_BIAS - 1022) - 52);
        if (round_bit_position < 0)
                round_bit_position = 0;
        else if (round_bit_position > 53)
                round_bit_position = 53;

#include "round.cxx"

        if (r[U_R_EXP] < (U_R_BIAS - 1021)) {

                /* Denorm or underflow */

                if (r[U_R_EXP] < ((U_R_BIAS - 1021) - 52)) {

                        /* Value is too small for a denorm, so underflow */

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                                RpcpMemoryCopy(output_value, IEEE_T_NEG_ZERO, 8);
                        else
                               RpcpMemoryCopy(output_value, IEEE_T_POS_ZERO, 8);
                        if (options & CVT_C_ERR_UNDERFLOW) {
                                RAISE(cvt__underflow);
                        }

                } else {

                        /* Figure leading zeros for denorm and right-justify fraction */

                        i = 64 - (r[U_R_EXP] - ((U_R_BIAS - 1022) - 52));

                        if (i > 31) {
                                i -= 32;
                                r[2] = (r[1] >> i);
                                r[1] = 0;
                        } else {
                                r[2] >>= i;
                                r[2] |= (r[1] << (32 - i));
                                r[1] >>= i;
                        }

                        /* OR in sign bit */

                        r[1] |= (r[U_R_FLAGS] << 31);

                        if (options & CVT_C_BIG_ENDIAN) {

                                r[0]  = ((r[1] << 24) | (r[1] >> 24));
                                r[0] |= ((r[1] << 8) & 0x00FF0000L);
                                r[0] |= ((r[1] >> 8) & 0x0000FF00L);
                                r[1]  = ((r[2] << 24) | (r[2] >> 24));
                                r[1] |= ((r[2] << 8) & 0x00FF0000L);
                                r[1] |= ((r[2] >> 8) & 0x0000FF00L);

                        } else {

                                r[0] = r[2];

                        }

                        RpcpMemoryCopy(output_value, r, 8);
                }

        } else if (r[U_R_EXP] > (U_R_BIAS + 1024)) {

                /* Overflow */

                if (options & CVT_C_TRUNCATE) {

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                                RpcpMemoryCopy(output_value, IEEE_T_NEG_HUGE, 8);
                        else
                                RpcpMemoryCopy(output_value, IEEE_T_POS_HUGE, 8);

                } else if ((options & CVT_C_ROUND_TO_POS)
                                        && (r[U_R_FLAGS] & U_R_NEGATIVE)) {

                                RpcpMemoryCopy(output_value, IEEE_T_NEG_HUGE, 8);

                } else if ((options & CVT_C_ROUND_TO_NEG)
                                        && !(r[U_R_FLAGS] & U_R_NEGATIVE)) {

                                RpcpMemoryCopy(output_value, IEEE_T_POS_HUGE, 8);

                } else {

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                                RpcpMemoryCopy(output_value, IEEE_T_NEG_INFINITY, 8);
                        else
                                RpcpMemoryCopy(output_value, IEEE_T_POS_INFINITY, 8);

                }

                RAISE(cvt__overflow);

        } else {

                /* Adjust bias of exponent */

                r[U_R_EXP] -= (U_R_BIAS - 1022);

                /* Make room for exponent and sign bit */

                r[2] >>= 11;
                r[2] |= (r[1] << 21);
                r[1] >>= 11;

                /* Clear implicit bit */

                r[1] &= 0x000FFFFFL;

                /* OR in exponent and sign bit */

                r[1] |= (r[U_R_EXP] << 20);
                r[1] |= (r[U_R_FLAGS] << 31);

                if (options & CVT_C_BIG_ENDIAN) {

                        r[0]  = ((r[1] << 24) | (r[1] >> 24));
                        r[0] |= ((r[1] << 8) & 0x00FF0000L);
                        r[0] |= ((r[1] >> 8) & 0x0000FF00L);
                        r[1]  = ((r[2] << 24) | (r[2] >> 24));
                        r[1] |= ((r[2] << 8) & 0x00FF0000L);
                        r[1] |= ((r[2] >> 8) & 0x0000FF00L);

                } else {

                        r[0] = r[2];

                }

                RpcpMemoryCopy(output_value, r, 8);
        }

    }

// end of file: pack_iet.c
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cvtglo.cxx ===
/* file: cvt__globals.c */

/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.
**              MRTL 5-Dec-1989.
**
**--
*/


#include "cvt.h"
#include "cvtpvt.h"


unsigned long vax_c[] = {

        0x00008000, 0x00000000, 0x00000000, 0x00000000,         /* ROPs */
        0x00000000, 0x00000000, 0x00000000, 0x00000000,         /* zeros */
        0xffff7fff, 0xffffffff, 0xffffffff, 0xffffffff,         /* +huge */
        0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,         /* -huge */

};


unsigned long ieee_s[] = {

        0x7fbfffff,             /* little endian ieee s nan */
        0xffffbf7f,             /* big endian ieee s nan */
        0x00000000,             /* le ieee s +zero */
        0x00000000,             /* be ieee s +zero */
        0x80000000,             /* le ieee s -zero */
        0x00000080,             /* be ieee s -zero */
        0x7f7fffff,             /* le ieee s +huge */
        0xffff7f7f,             /* be ieee s +huge */
        0xff7fffff,             /* le ieee s -huge */
        0xffff7fff,             /* be ieee s -huge */
        0x7f800000,             /* le ieee s +infinity */
        0x0000807f,             /* be ieee s +infinity */
        0xff800000,             /* le ieee s -infinity */
        0x000080ff,             /* be ieee s -infinity */

};

unsigned long ieee_t[] = {

        0xffffffff, 0x7ff7ffff,         /* le ieee t nan */
        0xfffff77f, 0xffffffff,         /* be ieee t nan */
        0x00000000, 0x00000000,         /* le ieee t +zero */
        0x00000000, 0x00000000,         /* be ieee t +zero */
        0x00000000, 0x80000000,         /* le ieee t -zero */
        0x00000080, 0x00000000,         /* be ieee t -zero */
        0xffffffff, 0x7fefffff,         /* le ieee s +huge */
        0xffffef7f, 0xffffffff,         /* be ieee s +huge */
        0xffffffff, 0xffefffff,         /* le ieee s -huge */
        0xffffefff, 0xffffffff,         /* be ieee s -huge */
        0x00000000, 0x7ff00000,         /* le ieee t +infinity */
        0x0000f07f, 0x00000000,         /* be ieee t +infinity */
        0x00000000, 0xfff00000,         /* le ieee t -infinity */
        0x0000f0ff, 0x00000000,         /* be ieee t -infinity */

};


unsigned long ibm_s[] = {

   0x000000ff,          /* ibm s invalid */
   0x00000000,          /* ibm s +zero */
   0x00000080,          /* ibm s -zero */
   0xffffff7f,          /* ibm s +huge */
   0xffffffff,          /* ibm s -huge */
   0xffffff7f,          /* ibm s +infinity */
   0xffffffff,          /* ibm s -infinity */

};

unsigned long ibm_l[] = {

   0x000000ff, 0x00000000,              /* ibm t invalid */
   0x00000000, 0x00000000,              /* ibm t +zero */
   0x00000080, 0x00000000,              /* ibm t -zero */
   0xffffff7f, 0xffffffff,              /* ibm t +huge */
   0xffffffff, 0xffffffff,              /* ibm t -huge */
   0xffffff7f, 0xffffffff,              /* ibm t +infinity */
   0xffffffff, 0xffffffff,              /* ibm t -infinity */

};


unsigned long cray[] = {

        0x00000060, 0x00000000,         /* cray invalid */
        0x00000000, 0x00000000,         /* cray +zero */
        0x00000080, 0x00000000,         /* cray -zero */
        0xffffff5f, 0xffffffff,         /* cray +huge */
        0xffffffdf, 0xffffffff,         /* cray -huge */
        0x00000060, 0x00000000,         /* cray +infinity */
        0x000000e0, 0x00000000,         /* cray -infinity */

};


unsigned long int_c[] = {

        0x00000000,             /* le int nan */
        0x00000000,             /* be int nan */
        0x00000000,             /* le int zero */
        0x00000000,             /* be int zero */
        0x7fffffff,             /* le int +huge */
        0xffffff7f,             /* be int +huge */
        0x80000000,             /* le int -huge */
        0x00000080,             /* be int -huge */
        0x7fffffff,             /* le int +infinity */
        0xffffff7f,             /* be int +infinity */
        0x80000000,             /* le int -infinity */
        0x00000080,             /* be int -infinity */

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cvtpvt.h ===
/* file: cvt__private.h */

/*
**
**                         COPYRIGHT (c) 1989, 1990 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains the private include file for the cvt_* routines.
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.       MRTL 5-Dec-1989.
**      1-002   Add GEM FORTRAN stuff.  TS 27-Mar-1990.
**
**--
*/


#ifndef CVT__PRIVATE
#define CVT__PRIVATE

#define F77_BINDING

#ifndef VMS
#define VMS_BINDING
#endif

#include "descrip.h"

#define C_TAB           '\t'
#define C_BLANK         ' '
#define C_PLUS          '+'
#define C_MINUS         '-'
#define C_ASTERISK      '*'
#define C_UNDERSCORE    '_'
#define C_DECIMAL_POINT '.'
#define C_DOT           '.'
#define C_ZERO          '0'
#define C_ONE           '1'
#define C_TWO           '2'
#define C_THREE         '3'
#define C_FOUR          '4'
#define C_FIVE          '5'
#define C_SIX           '6'
#define C_SEVEN         '7'
#define C_EIGHT         '8'
#define C_NINE          '9'
#define C_A             'A'
#define C_B             'B'
#define C_C             'C'
#define C_D             'D'
#define C_E             'E'
#define C_F             'F'
#define C_L             'L'
#define C_R             'R'
#define C_S             'S'
#define C_T             'T'
#define C_U             'U'
#define C_W             'W'
#define C_a             'a'
#define C_b             'b'
#define C_c             'c'
#define C_d             'd'
#define C_e             'e'
#define C_f             'f'
#define C_t             't'


#define RAISE(i) \
        { \
           RpcRaiseException(i); \
        }



/*
UNPACKED REAL:

[0]: excess 2147483648 (2 ^ 31) binary exponent
[1]: mantissa: msb ------>
[2]: -------------------->
[3]: -------------------->
[4]: ----------------> lsb
[5]: 28 unused bits, invalid bit, infinity bit, zero bit, negative bit

All fraction bits are explicit and are normalized s.t. 0.5 <= fraction < 1.0

*/

typedef struct dsc_descriptor_s DESC_S;
typedef unsigned long  UNPACKED_REAL[6];
typedef UNPACKED_REAL *UNPACKED_REAL_PTR;

#define U_R_EXP 0
#define U_R_FLAGS 5

#define U_R_NEGATIVE 1
#define U_R_ZERO 2
#define U_R_INFINITY 4
#define U_R_INVALID  8
#define U_R_UNUSUAL (U_R_ZERO | U_R_INFINITY | U_R_INVALID)

#define U_R_BIAS 2147483648L




extern unsigned long vax_c[];

#define VAX_F_INVALID &vax_c[0]
#define VAX_D_INVALID &vax_c[0]
#define VAX_G_INVALID &vax_c[0]
#define VAX_H_INVALID &vax_c[0]

#define VAX_F_ZERO &vax_c[4]
#define VAX_D_ZERO &vax_c[4]
#define VAX_G_ZERO &vax_c[4]
#define VAX_H_ZERO &vax_c[4]

#define VAX_F_POS_HUGE &vax_c[8]
#define VAX_D_POS_HUGE &vax_c[8]
#define VAX_G_POS_HUGE &vax_c[8]
#define VAX_H_POS_HUGE &vax_c[8]

#define VAX_F_NEG_HUGE &vax_c[12]
#define VAX_D_NEG_HUGE &vax_c[12]
#define VAX_G_NEG_HUGE &vax_c[12]
#define VAX_H_NEG_HUGE &vax_c[12]


extern unsigned long ieee_s[];

#define IEEE_S_INVALID ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[1] : &ieee_s[0])
#define IEEE_S_POS_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[3] : &ieee_s[2])
#define IEEE_S_NEG_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[5] : &ieee_s[4])
#define IEEE_S_POS_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[7] : &ieee_s[6])
#define IEEE_S_NEG_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[9] : &ieee_s[8])
#define IEEE_S_POS_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[11] : &ieee_s[10])
#define IEEE_S_NEG_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_s[13] : &ieee_s[12])


extern unsigned long ieee_t[];

#define IEEE_T_INVALID ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[2] : &ieee_t[0])
#define IEEE_T_POS_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[6] : &ieee_t[4])
#define IEEE_T_NEG_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[10] : &ieee_t[8])
#define IEEE_T_POS_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[14] : &ieee_t[12])
#define IEEE_T_NEG_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[18] : &ieee_t[16])
#define IEEE_T_POS_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[22] : &ieee_t[20])
#define IEEE_T_NEG_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &ieee_t[26] : &ieee_t[24])


extern unsigned long ibm_s[];

#define IBM_S_INVALID   &ibm_s[0]
#define IBM_S_POS_ZERO  &ibm_s[1]
#define IBM_S_NEG_ZERO  &ibm_s[2]
#define IBM_S_POS_HUGE  &ibm_s[3]
#define IBM_S_NEG_HUGE  &ibm_s[4]
#define IBM_S_POS_INFINITY  &ibm_s[5]
#define IBM_S_NEG_INFINITY  &ibm_s[6]


extern unsigned long ibm_l[];

#define IBM_L_INVALID   &ibm_l[0]
#define IBM_L_POS_ZERO  &ibm_l[2]
#define IBM_L_NEG_ZERO  &ibm_l[4]
#define IBM_L_POS_HUGE  &ibm_l[6]
#define IBM_L_NEG_HUGE  &ibm_l[8]
#define IBM_L_POS_INFINITY  &ibm_l[10]
#define IBM_L_NEG_INFINITY  &ibm_l[12]


extern unsigned long cray[];

#define CRAY_INVALID    &cray[0]
#define CRAY_POS_ZERO   &cray[2]
#define CRAY_NEG_ZERO   &cray[4]
#define CRAY_POS_HUGE   &cray[6]
#define CRAY_NEG_HUGE   &cray[8]
#define CRAY_POS_INFINITY  &cray[10]
#define CRAY_NEG_INFINITY  &cray[12]


extern unsigned long int_c[];

#define INT_INVALID ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[1] : &int_c[0])
#define INT_ZERO ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[3] : &int_c[2])
#define INT_POS_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[5] : &int_c[4])
#define INT_NEG_HUGE ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[7] : &int_c[6])
#define INT_POS_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[9] : &int_c[8])
#define INT_NEG_INFINITY ((options & CVT_C_BIG_ENDIAN) ? \
        &int_c[11] : &int_c[10])


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cvtibm.cxx ===
/*-----------------------------------------------------------------------------
 *
 * cvtibmf.c : IBM float/double <-> IEEE float/double conversion
 *
 *+++
 *
 * Copyright (c) Software AG 1996,1998. All rights reserved.
 *
 *---
 *
 * License:
 *
 * "According to the DCOM Porting Agreement Software AG grants to Microsoft
 *  an irrevocable, unlimited, royalty free license to use and market the
 *  enclosed piece of software code in source and object format for
 *  the purposes of Microsoft. 17-April-1998."
 *
 *----------------------------------------------------------------------------*/

#include <float.h>

#include <rpc.h>
#include <rpcndr.h>
#include "winerror.h"

/*
 * Convert floating point numbers from IBM/370 to IEEE representation or vice versa.
 *
 * Synopsis:
 *
 * void cvt_ibm_f_to_ieee_single(ULONG *ulFP);
 * void cvt_ibm_d_to_ieee_double(ULONG *ulFP);
 * void cvt_ieee_single_to_ibm_f(ULONG *ulFP);
 * void cvt_ieee_double_to_ibm_d(ULONG *ulFP);
 *
 * Note:
 *
 *  Overflow/Underflow during conversion results in RpcRaiseException(RPC_S_FP_OVERFLOW/
 *  RPC_S_FP_UNDERFLOW).
 *
 */

/* *******************************************************************************
 *
 * Floating point representations:
 *
 * ------------------------
 * IBM/370 single precision
 * ------------------------
 *
 * xxxx.xxxx xxxx.xxxx xxxx.xxxx xxxx.xxxx
 * s|-exp--| |--------fraction-----------|
 *    (7)               (24)
 *
 * value = (-1)**s * 16**(e - 64) * .f     range = 5.4E-79 ... 7.2E+75
 *
 * *******************************************************************************
 *
 * ---------------------
 * IEEE single precision
 * ---------------------
 *
 * xxxx.xxxx xxxx.xxxx xxxx.xxxx xxxx.xxxx
 * s|--exp---||-------fraction-----------|
 *     (8)              (23)
 *
 * value = (-1)**s * 2**(e - 127) * 1.f    range = 1.2E-38 ... 3.4E+38
 *
 * *******************************************************************************
 *
 * ------------------------
 * IBM/370 double precision
 * ------------------------
 *
 * xxxx.xxxx xxxx.xxxx xxxx.xxxx xxxx.xxxx yyyy.yyyy yyyy.yyyy yyyy.yyyy yyyy.yyyy
 * s|-exp--| |-------------------------------fraction----------------------------|
 *    (7)                                      (56)
 *
 * value = (-1)**s * 16**(e - 64) * .f     range = 5.4E-79 ... 7.2E+75
 *
 * *******************************************************************************
 *
 * ---------------------
 * IEEE double precision
 * ---------------------
 *
 * xxxx.xxxx xxxx.xxxx xxxx.xxxx xxxx.xxxx yyyy.yyyy yyyy.yyyy yyyy.yyyy yyyy.yyyy
 * s|--exponent-| |-------------------------fraction-----------------------------|
 *       (11)                                 (52)
 *
 *   value = (-1)**s * 2**(e - 1023) * 1.f   range = 2.2E-308 ... 1.8+308
 *
 * *******************************************************************************/

#if 1 /* We assume little endian for NT, this does not work: NDR_LOCAL_ENDIAN == NDR_LITTLE_ENDIAN */
#  define HI 1 /* index of high order LONG */
#  define LO 0 /* index of low order LONG */
#else
#  define HI 0 /* index of high order LONG */
#  define LO 1 /* index of low order LONG */
#endif

static float floatMin = FLT_MIN;
static float floatMax = FLT_MAX;

#define SIGN(src) 	(src[HI] & 0x80000000)

/* Convert IBM/370 "float" to IEEE "single" */
void cvt_ibm_f_to_ieee_single ( ULONG *ulFP )
{
   ULONG ulFraction ;
   LONG lExponent ;

   /* in this special case we just keep the sign */
   if ( ( *ulFP & 0x7fffffff ) == 0 )
   {
      return ;
   }

   /* fetch the exponent (excess-64 notation) and fraction */
   lExponent = ( (*ulFP & 0x7f000000) >> 24) - 64 ;
   ulFraction = *ulFP & 0x00ffffff ;

   /* convert from "16**exponent" to "2**exponent" */
   if ( lExponent >= 0 ) lExponent <<= 2 ;
   else                  lExponent = -((-lExponent) << 2) ;

   /* convert exponent for 24 bit fraction to 23 bit fraction */
   lExponent -= 1;

   /* normalize fraction */
   if ( ulFraction )
   {
	while ( (ulFraction & 0x00800000) == 0 )
        {
            ulFraction <<= 1 ;
            lExponent -= 1 ;
        }
   }

   /* remove the implied '1' preceeding the binary point */
   ulFraction &= 0x007fffff ;

   /* convert exponent to excess-127 notation and store the number if the exponent is not out of range */
   if ( (lExponent += 127) >= 255 )
     *ulFP = SIGN(ulFP) | *((ULONG *)&floatMax) ; /* floating overflow */
   else if ( lExponent <= 0 )
    *ulFP = SIGN(ulFP) | *((ULONG *)&floatMin) ;	 /* floating underflow */
   else
     *ulFP = SIGN(ulFP) | (lExponent << 23) | ulFraction ;
}

/* Convert IBM/370 "double" to IEEE "double" */
void cvt_ibm_d_to_ieee_double ( ULONG* ulFP )
{
   ULONG ulFraction[2] ;
   LONG  lExponent ;

   /* in this special case we just keep the sign */
   if ( (ulFP[HI] & 0x7fffffff) == 0 )
   {
      return ;
   }

   /* fetch the exponent (removing excess 64) and fraction */
   lExponent = ( (ulFP[HI] & 0x7f000000) >> 24 ) - 64 ;
   ulFraction[HI] = ulFP[HI] & 0x00ffffff ;
   ulFraction[LO] = ulFP[LO] ;

   /* convert from "16**exponent" to "2**exponent" */
   if ( lExponent >= 0 ) lExponent <<= 2 ;
   else                  lExponent = -((-lExponent) << 2);

   /* normalize the fraction (to 57 bits) */
   if ( ulFraction[HI] )
   {
       while ((ulFraction[HI] & 0x01000000) == 0)
       {
             ulFraction[HI] = ( ulFraction[HI] << 1 ) | ( ulFraction[LO] >> 31 ) ;
             ulFraction[LO] = ulFraction[LO] << 1 ;
             lExponent -= 1 ;
       }
   }

   /* convert 57 bit fraction to 53 bit fraction and remove the implied '1' preceeding the binary point */
   ulFraction[LO] = ( ulFraction[LO] >> 4 ) | ( ulFraction[HI] << 28 ) ;
   ulFraction[HI] = ( ulFraction[HI] >> 4 ) & 0x000fffff ;

   /* convert exponent to excess-1023 notation and store the number if the exponent is not out of range */
   if ( (lExponent += 1023) >= 2047 )
     RpcRaiseException ( RPC_S_FP_OVERFLOW ) ; /* should never happen */
   else if ( lExponent <= 0 )
     RpcRaiseException ( RPC_S_FP_UNDERFLOW ) ; /* should never happen */
   else
   {
      ulFP[HI] = SIGN(ulFP) | (lExponent << 20) | ulFraction[HI] ;
      ulFP[LO] = ulFraction[LO] ;
   }
}

/* The following is not used in Windows NT */

#if 0

/* Convert IEEE "single" to IBM/370 "float" */
void cvt_ieee_single_to_ibm_f ( ULONG* ulFP )
{
   ULONG ulFraction ;
   LONG	 lExponent ;

   /* in this special case we just keep the sign */
   if ( (*ulFP & 0x7fffffff) == 0 )
   {
      return ;
   }

   lExponent = ((*ulFP & 0x7f800000) >> 23) - 127 ;
   ulFraction = *ulFP & 0x007fffff ;

   /* convert 23 bit fraction to 24 bit fraction */
   ulFraction <<= 1 ;

   /* restore the implied '1' which preceeded the IEEE binary point */
   ulFraction |= 0x01000000 ; 

   /* convert from "2**exponent" to "16**exponent" (fraction is not normalized) */
   if ( lExponent >= 0 )
   {
      ulFraction <<= (lExponent & 3) ;
      lExponent >>= 2 ;
   }
   else
   {
      ulFraction >>= ((-lExponent) & 3) ; 
      lExponent = -((-lExponent) >> 2) ;
   }

   /* reduce fraction to 24 bits or less */
   if ( ulFraction & 0x0f000000 )
   {
      ulFraction >>= 4 ;
      lExponent += 1 ;
   }

   /* convert exponent to excess-64 notation and store the number if the exponent is not out of range */
   if ( (lExponent += 64) > 127 )
     RpcRaiseException ( RPC_S_FP_OVERFLOW ) ; /* should never happen */
   else if ( lExponent < 0 )
     RpcRaiseException ( RPC_S_FP_UNDERFLOW ) ; /* should never happen */
   else
     *ulFP = SIGN(ulFP) | (lExponent << 24) | ulFraction ;
}

/* Convert IEEE "double" to IBM/370 "double" */
void cvt_ieee_double_to_ibm_d ( ULONG* ulFP )
{
   ULONG 	ulFraction[2] ;
   LONG 	lExponent ;
   LONG		shift ;

   /* in this special case we just keep the sign and the low word */
   if ( (ulFP[HI] & 0x7fffffff) == 0 )
   {
      return ;
   }

   /* fetch the exponent (excess-1023 notation) and fraction */
   lExponent =  ((ulFP[HI] & 0x7ff00000) >> 20) - 1023 ;
   ulFraction[HI] = ulFP[HI] & 0x000fffff ;
   ulFraction[LO] = ulFP[LO] ;

   /* convert 52 bit fraction to 56 bit fraction and restore the '1' which preceeds the IEEE binary point*/
   ulFraction[HI] = ( ulFraction[HI] << 4 ) | ( ulFraction[LO] >> 28 ) | 0x01000000 ;
   ulFraction[LO] = ulFraction[LO] << 4 ;

   /* convert from "2**exponent" to "16**exponent" (fraction is not normalized) */
   if ( lExponent >= 0 )
   {
      shift = lExponent & 3 ;
      ulFraction[HI] = ( ulFraction[HI] << shift ) | ( ulFraction[LO] >> (32 - shift) ) ;
      ulFraction[LO] = ulFraction[LO] << shift ;
      lExponent >>= 2 ;
   }
   else
   {
      shift = (-lExponent) & 3 ;
      ulFraction[LO] = ( ulFraction[LO] >> shift ) | ( ulFraction[HI] << (32 - shift) ) ;
      ulFraction[HI] = ( ulFraction[HI] >> shift ) ;
      lExponent = -((-lExponent) >> 2) ;
   }

   /* reduce fraction to 56 bits or less */
   if ( ulFraction[HI] & 0x0f000000 )
   {
      ulFraction[LO] = ( ulFraction[LO] >> 4 ) | ( ulFraction[HI] << 28 ) ;
      ulFraction[HI] = ( ulFraction[HI] >> 4 ) ;
      lExponent += 1 ;
   }

   /* convert exponent to excess-64 notation and store the number */
   if ( (lExponent += 64) > 127 ) 
   {  /* we store the highest IBM float but we keep the sign ! */ 
      ulFP[HI] = SIGN(ulFP) | 0x7FFFFFFF ;
      ulFP[LO] = 0xFFFFFFFF ;
   }
   else if ( lExponent < 0 )      
   {  /* we store 0 but we keep the sign ! */
      ulFP[HI] = SIGN(ulFP) ;
      ulFP[LO] = 0 ;
   }
   else
   {
      ulFP[HI] = SIGN(ulFP) | (lExponent << 24) | ulFraction[HI] ;
      ulFP[LO] = ulFraction[LO] ;
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\cvtf.cxx ===
/* file:  cvt_vax_f.c */

/*
**
**                         COPYRIGHT (c) 1989, 1990 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains routines to convert VAX F_Float floating
**      point data into other supported floating point formats.
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.       MRTL 5-Dec-1989.
**      1-002   Add VMS and F77 bindings.  TS 26-Mar-1990.
**
**--
*/

/*
**
**  TABLE OF CONTENTS
**
**      cvt_vax_f_to_cray
**      cvt_vax_f_to_ibm_short
**      cvt_vax_f_to_ieee_single
**
*/


#include <stdio.h>
#include <sysinc.h>
#include <rpc.h>
#include "cvt.h"
#include "cvtpvt.h"


//
// Added for the MS NT environment
//

#include <stdlib.h>


/*
 * C binding
 */
void cvt_vax_f_to_ieee_single(
    CVT_VAX_F input_value,
    CVT_SIGNED_INT options,
    CVT_IEEE_SINGLE output_value
    )
{
    int i, round_bit_position;
    UNPACKED_REAL r;


    switch ( options & ~(CVT_C_BIG_ENDIAN | CVT_C_ERR_UNDERFLOW) ) {
        case 0                      : options |= CVT_C_ROUND_TO_NEAREST;
        case CVT_C_ROUND_TO_NEAREST :
        case CVT_C_TRUNCATE         :
        case CVT_C_ROUND_TO_POS     :
        case CVT_C_ROUND_TO_NEG     :
        case CVT_C_VAX_ROUNDING     : break;
        default : RAISE(cvt__invalid_option);
    }


//  ===========================================================================
//
// This file used to be included as a separate file.
//#include "unp_vaxf.c"
//
//  ===========================================================================

/* file: unpack_vax_f.c */


/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/


/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains code to extract information from a VAX
**      f_floating number and to initialize an UNPACKED_REAL structure
**      with those bits.
**
**              This module is meant to be used as an include file.
**
**  Author: Math RTL
**
**  Creation Date:  November 24, 1989.
**
**  Modification History:
**
**--
*/


/*
**++
**  Functional Description:
**
**  This module contains code to extract information from a VAX
**  f_floating number and to initialize an UNPACKED_REAL structure
**  with those bits.
**
**  See the header files for a description of the UNPACKED_REAL
**  structure.
**
**  A VAX f_floating number in (16 bit words) looks like:
**
**      [0]: Sign bit, 8 exp bits (bias 128), 7 fraction bits
**      [1]: 16 more fraction bits
**
**      0.5 <= fraction < 1.0, MSB implicit
**
**
**  Implicit parameters:
**
**      input_value: a pointer to the input parameter.
**
**      r: an UNPACKED_REAL structure
**
**--
*/



        RpcpMemoryCopy(&r[1], input_value, 4);

        /* Initialize FLAGS and perhaps set NEGATIVE bit */

        r[U_R_FLAGS] = (r[1] >> 15) & U_R_NEGATIVE;

        /* Extract VAX biased exponent */

        r[U_R_EXP] = (r[1] >> 7) & 0x000000FFL;

        if (r[U_R_EXP] == 0) {

                if (r[U_R_FLAGS])
                        r[U_R_FLAGS] |= U_R_INVALID;
                else
                        r[U_R_FLAGS] = U_R_ZERO;

        } else {

                /* Adjust for VAX 16 bit floating format */

                r[1] = ((r[1] << 16) | (r[1] >> 16));

                /* Add unpacked real bias and subtract VAX bias */

                r[U_R_EXP] += (U_R_BIAS - 128);

                /* Set hidden bit */

                r[1] |= 0x00800000L;

                /* Left justify fraction bits */

                r[1] <<= 8;

                /* Clear uninitialized parts for unpacked real */

                r[2] = 0;
                r[3] = 0;
                r[4] = 0;

        }

// end of file: unpack_vax_f.c
//
//  ===========================================================================
//
// This file used to be included as a separate file.
//#include "pack_ies.c"
//
//  ===========================================================================

/* file: pack_ieee_s.c */


/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/


/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module contains code to extract information from an
**      UNPACKED_REAL structure and to create an IEEE single floating number
**      with those bits.
**
**              This module is meant to be used as an include file.
**
**  Author: Math RTL
**
**  Creation Date:  November 24, 1989.
**
**  Modification History:
**
**--
*/


/*
**++
**  Functional Description:
**
**  This module contains code to extract information from an
**  UNPACKED_REAL structure and to create an IEEE single number
**  with those bits.
**
**  See the header files for a description of the UNPACKED_REAL
**  structure.
**
**  A normalized IEEE single precision floating number looks like:
**
**      Sign bit, 8 exp bits (bias 127), 23 fraction bits
**
**      1.0 <= fraction < 2.0, MSB implicit
**
**  For more details see "Mips R2000 Risc Architecture"
**  by Gerry Kane, page 6-8 or ANSI/IEEE Std 754-1985.
**
**
**  Implicit parameters:
**
**      options: a word of flags, see include files.
**
**      output_value: a pointer to the input parameter.
**
**      r: an UNPACKED_REAL structure.
**
**--
*/


    if (r[U_R_FLAGS] & U_R_UNUSUAL) {

        if (r[U_R_FLAGS] & U_R_ZERO)

                if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        RpcpMemoryCopy(output_value, IEEE_S_NEG_ZERO, 4);
                else
                        RpcpMemoryCopy(output_value, IEEE_S_POS_ZERO, 4);

        else if (r[U_R_FLAGS] & U_R_INFINITY) {

                if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        RpcpMemoryCopy(output_value, IEEE_S_NEG_INFINITY, 4);
                else
                        RpcpMemoryCopy(output_value, IEEE_S_POS_INFINITY, 4);

        } else if (r[U_R_FLAGS] & U_R_INVALID) {

                RpcpMemoryCopy(output_value, IEEE_S_INVALID, 4);
                RAISE(cvt__invalid_value);

        }

    } else {

        /* Precision varies if value will be a denorm */
        /* So, figure out where to round (0 <= i <= 24). */

        round_bit_position = r[U_R_EXP] - ((U_R_BIAS - 126) - 23);
        if (round_bit_position < 0)
                round_bit_position = 0;
        else if (round_bit_position > 24)
                round_bit_position = 24;

#include "round.cxx"

        if (r[U_R_EXP] < (U_R_BIAS - 125)) {

                /* Denorm or underflow */

                if (r[U_R_EXP] < ((U_R_BIAS - 125) - 23)) {

                        /* Value is too small for a denorm, so underflow */

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                              RpcpMemoryCopy(output_value, IEEE_S_NEG_ZERO, 4);
                        else
                              RpcpMemoryCopy(output_value, IEEE_S_POS_ZERO, 4);
                        if (options & CVT_C_ERR_UNDERFLOW) {
                                RAISE(cvt__underflow);
                        }

                } else {

                        /* Figure leading zeros for denorm and right-justify fraction */

                        i = 32 - (r[U_R_EXP] - ((U_R_BIAS - 126) - 23));
                        r[1] >>= i;

                        /* Set sign bit */

                        r[1] |= (r[U_R_FLAGS] << 31);

                        if (options & CVT_C_BIG_ENDIAN) {

                                r[0]  = ((r[1] << 24) | (r[1] >> 24));
                                r[0] |= ((r[1] << 8) & 0x00FF0000L);
                                r[0] |= ((r[1] >> 8) & 0x0000FF00L);
                                RpcpMemoryCopy(output_value, r, 4);

                        } else {

                                RpcpMemoryCopy(output_value, &r[1], 4);

                        }
                }

        } else if (r[U_R_EXP] > (U_R_BIAS + 128)) {

                /* Overflow */

                if (options & CVT_C_TRUNCATE) {

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                               RpcpMemoryCopy(output_value, IEEE_S_NEG_HUGE, 4);
                        else
                               RpcpMemoryCopy(output_value, IEEE_S_POS_HUGE, 4);

                } else if ((options & CVT_C_ROUND_TO_POS)
                                        && (r[U_R_FLAGS] & U_R_NEGATIVE)) {

                              RpcpMemoryCopy(output_value, IEEE_S_NEG_HUGE, 4);

                } else if ((options & CVT_C_ROUND_TO_NEG)
                                        && !(r[U_R_FLAGS] & U_R_NEGATIVE)) {

                              RpcpMemoryCopy(output_value, IEEE_S_POS_HUGE, 4);

                } else {

                        if (r[U_R_FLAGS] & U_R_NEGATIVE)
                              RpcpMemoryCopy(output_value, IEEE_S_NEG_INFINITY, 4);
                        else
                              RpcpMemoryCopy(output_value, IEEE_S_POS_INFINITY, 4);

                }

                RAISE(cvt__overflow);

        } else {

                /* Adjust bias of exponent */

                r[U_R_EXP] -= (U_R_BIAS - 126);

                /* Make room for exponent and sign bit */

                r[1] >>= 8;

                /* Clear implicit bit */

                r[1] &= 0x007FFFFFL;

                /* OR in exponent and sign bit */

                r[1] |= (r[U_R_EXP] << 23);
                r[1] |= (r[U_R_FLAGS] << 31);

                if (options & CVT_C_BIG_ENDIAN) {

                        r[0]  = ((r[1] << 24) | (r[1] >> 24));
                        r[0] |= ((r[1] << 8) & 0x00FF0000L);
                        r[0] |= ((r[1] >> 8) & 0x0000FF00L);
                        RpcpMemoryCopy(output_value, r, 4);

                } else {

                        RpcpMemoryCopy(output_value, &r[1], 4);

                }
        }

    }

// end of file: pack_ies.c

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\descrip.h ===
#ifndef DESCRIP_H_DEFINED
/*
 *      DESCRIP.H - V3.0-003 - Argument Descriptor Formats
 *      Copyright (c) 1993-1999 Microsoft Corporation
 *      (Based on the VAX Procedure Calling and Condition Handling Standard, Revision 9.4 [13 March 1984];
 *       see the "Introduction to VMS System Routines" manual for further information.)
 */


/*
 *      Descriptor Prototype - each class of descriptor consists of at least the following fields:
 */
struct  dsc_descriptor
{
        unsigned short  dsc_w_length;   /* specific to descriptor class;  typically a 16-bit (unsigned) length */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code */
        char            *dsc_a_pointer; /* address of first byte of data element */
};


/*
 *      Fixed-Length Descriptor:
 */
struct  dsc_descriptor_s
{
        unsigned short  dsc_w_length;   /* length of data item in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_S */
        char            *dsc_a_pointer; /* address of first byte of data storage */
};


/*
 *      Dynamic String Descriptor:
 */
struct  dsc_descriptor_d
{
        unsigned short  dsc_w_length;   /* length of data item in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_D */
        char            *dsc_a_pointer; /* address of first byte of data storage */
};


/*
 *      Array Descriptor:
 */
struct  dsc_descriptor_a
{
        unsigned short  dsc_w_length;   /* length of an array element in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_A */
        char            *dsc_a_pointer; /* address of first actual byte of data storage */
        char            dsc_b_scale;    /* signed power-of-two or -ten multiplier, as specified by
                                             dsc_v_fl_binscale, to convert from internal to external form */
        unsigned char   dsc_b_digits;   /* if nonzero, number of decimal digits in internal representation */
#ifdef vms
        struct
        {
                unsigned                 : 3;   /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* if set, dsc_b_scale is a power-of-two, otherwise, -ten */
                unsigned dsc_v_fl_redim  : 1;   /* if set, indicates the array can be redimensioned */
                unsigned dsc_v_fl_column : 1;   /* if set, indicates column-major order (FORTRAN) */
                unsigned dsc_v_fl_coeff  : 1;   /* if set, indicates the multipliers block is present */
                unsigned dsc_v_fl_bounds : 1;   /* if set, indicates the bounds block is present */
        }               dsc_b_aflags;   /* array flag bits */
#else
        unsigned char dsc_b_aflags;
#endif
        unsigned char   dsc_b_dimct;    /* number of dimensions */
        unsigned long   dsc_l_arsize;   /* total size of array in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        /*
         * One or two optional blocks of information may follow contiguously at this point;
         * the first block contains information about the dimension multipliers (if present,
         * dsc_b_aflags.dsc_v_fl_coeff is set), the second block contains information about
         * the dimension bounds (if present, dsc_b_aflags.dsc_v_fl_bounds is set).  If the
         * bounds information is present, the multipliers information must also be present.
         *
         * The multipliers block has the following format:
         *      char    *dsc_a_a0;              Address of the element whose subscripts are all zero
         *      long    dsc_l_m [DIMCT];        Addressing coefficients (multipliers)
         *
         * The bounds block has the following format:
         *      struct
         *      {
         *              long    dsc_l_l;        Lower bound
         *              long    dsc_l_u;        Upper bound
         *      } dsc_bounds [DIMCT];
         *
         * (DIMCT represents the value contained in dsc_b_dimct.)
         */
};


/*
 *      Procedure Descriptor:
 */
struct  dsc_descriptor_p
{
        unsigned short  dsc_w_length;   /* length associated with the function value */
        unsigned char   dsc_b_dtype;    /* function value data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_P */
        int             (*dsc_a_pointer)();     /* address of function entry mask */
};


/*
 *      Decimal String Descriptor:
 */
struct  dsc_descriptor_sd
{
        unsigned short  dsc_w_length;   /* length of data item in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_SD */
        char            *dsc_a_pointer; /* address of first byte of data storage */
        char            dsc_b_scale;    /* signed power-of-two or -ten multiplier, as specified by
                                             dsc_v_fl_binscale, to convert from internal to external form */
        unsigned char   dsc_b_digits;   /* if nonzero, number of decimal digits in internal representation */
        struct
        {
                unsigned                : 3;    /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* if set, dsc_b_scale is a power-of-two, otherwise, -ten */
                unsigned                : 4;    /* reserved;  must be zero */
        }               dsc_b_sflags;   /* scalar flag bits */
        unsigned        : 8;            /* reserved;  must be zero */
};


/*
 *      Noncontiguous Array Descriptor:
 */
struct  dsc_descriptor_nca
{
        unsigned short  dsc_w_length;   /* length of an array element in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_V, bits,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        unsigned char   dsc_b_dtype;    /* data type code */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_NCA */
        char            *dsc_a_pointer; /* address of first actual byte of data storage */
        char            dsc_b_scale;    /* signed power-of-two or -ten multiplier, as specified by
                                             dsc_v_fl_binscale, to convert from internal to external form */
        unsigned char   dsc_b_digits;   /* if nonzero, number of decimal digits in internal representation */
        struct
        {
                unsigned                 : 3;   /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* if set, dsc_b_scale is a power-of-two, otherwise, -ten */
                unsigned dsc_v_fl_redim  : 1;   /* must be zero */
                unsigned                 : 3;   /* reserved;  must be zero */
        }               dsc_b_aflags;   /* array flag bits */
        unsigned char   dsc_b_dimct;    /* number of dimensions */
        unsigned long   dsc_l_arsize;   /* if elements are actually contiguous, total size of array in bytes,
                                             or if dsc_b_dtype is DSC_K_DTYPE_P, digits (4 bits each) */
        /*
         * Two blocks of information must follow contiguously at this point;  the first block
         * contains information about the difference between the addresses of two adjacent
         * elements in each dimension (the stride).  The second block contains information
         * about the dimension bounds.
         *
         * The strides block has the following format:
         *      char            *dsc_a_a0;              Address of the element whose subscripts are all zero
         *      unsigned long   dsc_l_s [DIMCT];        Strides
         *
         * The bounds block has the following format:
         *      struct
         *      {
         *              long    dsc_l_l;                Lower bound
         *              long    dsc_l_u;                Upper bound
         *      } dsc_bounds [DIMCT];
         *
         * (DIMCT represents the value contained in dsc_b_dimct.)
         */
};


/*
 *      The Varying String Descriptor and Varying String Array Descriptor are used with strings
 *      of the following form:
 *
 *              struct
 *              {
 *                      unsigned short  CURLEN;         The current length of BODY in bytes
 *                      char    BODY [MAXSTRLEN];       A fixed-length area containing the string
 *              };
 *
 *      where MAXSTRLEN is the value contained in the dsc_w_maxstrlen field in the descriptor.
 */


/*
 *      Varying String Descriptor:
 */
struct  dsc_descriptor_vs
{
        unsigned short  dsc_w_maxstrlen; /* maximum length of the BODY field of the varying string in bytes */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VT */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_VS */
        char            *dsc_a_pointer; /* address of the CURLEN field of the varying string */
};


/*
 *      Varying String Array Descriptor:
 */
struct  dsc_descriptor_vsa
{
        unsigned short  dsc_w_maxstrlen; /* maximum length of the BODY field of an array element in bytes */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VT */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_VSA */
        char            *dsc_a_pointer; /* address of first actual byte of data storage */
        char            dsc_b_scale;    /* signed power-of-two or -ten multiplier, as specified by
                                             dsc_v_fl_binscale, to convert from internal to external form */
        unsigned char   dsc_b_digits;   /* if nonzero, number of decimal digits in internal representation */
        struct
        {
                unsigned                 : 3;   /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* if set, dsc_b_scale is a power-of-two, otherwise, -ten */
                unsigned dsc_v_fl_redim  : 1;   /* must be zero */
                unsigned                 : 3;   /* reserved;  must be zero */
        }               dsc_b_aflags;   /* array flag bits */
        unsigned char   dsc_b_dimct;    /* number of dimensions */
        unsigned long   dsc_l_arsize;   /* if elements are actually contiguous, total size of array in bytes */
        /*
         * Two blocks of information must follow contiguously at this point;  the first block
         * contains information about the difference between the addresses of two adjacent
         * elements in each dimension (the stride).  The second block contains information
         * about the dimension bounds.
         *
         * The strides block has the following format:
         *      char            *dsc_a_a0;              Address of the element whose subscripts are all zero
         *      unsigned long   dsc_l_s [DIMCT];        Strides
         *
         * The bounds block has the following format:
         *      struct
         *      {
         *              long    dsc_l_l;                Lower bound
         *              long    dsc_l_u;                Upper bound
         *      } dsc_bounds [DIMCT];
         *
         * (DIMCT represents the value contained in dsc_b_dimct.)
         */
};


/*
 *      Unaligned Bit String Descriptor:
 */
struct  dsc_descriptor_ubs
{
        unsigned short  dsc_w_length;   /* length of data item in bits */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VU */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_UBS */
        char            *dsc_a_base;    /* address to which dsc_l_pos is relative */
        long            dsc_l_pos;      /* bit position relative to dsc_a_base of first bit in string */
};


/*
 *      Unaligned Bit Array Descriptor:
 */
struct  dsc_descriptor_uba
{
        unsigned short  dsc_w_length;   /* length of data item in bits */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VU */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_UBA */
        char            *dsc_a_base;    /* address to which effective bit offset is relative */
        char            dsc_b_scale;    /* reserved;  must be zero */
        unsigned char   dsc_b_digits;   /* reserved;  must be zero */
        struct
        {
                unsigned                 : 3;   /* reserved;  must be zero */
                unsigned dsc_v_fl_binscale : 1; /* must be zero */
                unsigned dsc_v_fl_redim  : 1;   /* must be zero */
                unsigned                 : 3;   /* reserved;  must be zero */
        }               dsc_b_aflags;   /* array flag bits */
        unsigned char   dsc_b_dimct;    /* number of dimensions */
        unsigned long   dsc_l_arsize;   /* total size of array in bits */
        /*
         * Three blocks of information must follow contiguously at this point;  the first block
         * contains information about the difference between the bit addresses of two adjacent
         * elements in each dimension (the stride).  The second block contains information
         * about the dimension bounds.  The third block is the relative bit position with
         * respect to dsc_a_base of the first actual bit of the array.
         *
         * The strides block has the following format:
         *      long            dsc_l_v0;               Bit offset of the element whose subscripts are all zero,
         *                                              with respect to dsc_a_base
         *      unsigned long   dsc_l_s [DIMCT];        Strides
         *
         * The bounds block has the following format:
         *      struct
         *      {
         *              long    dsc_l_l;                Lower bound
         *              long    dsc_l_u;                Upper bound
         *      } dsc_bounds [DIMCT];
         *
         * The last block has the following format:
         *      long    dsc_l_pos;
         *
         * (DIMCT represents the value contained in dsc_b_dimct.)
         */
        };


/*
 *      String with Bounds Descriptor:
 */
struct  dsc_descriptor_sb
{
        unsigned short  dsc_w_length;   /* length of string in bytes */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_T */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_SB */
        char            *dsc_a_pointer; /* address of first byte of data storage */
        long            dsc_l_sb_l1;    /* lower bound */
        long            dsc_l_sb_u1;    /* upper bound */
};


/*
 *      Unaligned Bit String with Bounds Descriptor:
 */
struct  dsc_descriptor_ubsb
{
        unsigned short  dsc_w_length;   /* length of data item in bits */
        unsigned char   dsc_b_dtype;    /* data type code = DSC_K_DTYPE_VU */
        unsigned char   dsc_b_class;    /* descriptor class code = DSC_K_CLASS_UBSB */
        char            *dsc_a_base;    /* address to which dsc_l_pos is relative */
        long            dsc_l_pos;      /* bit position relative to dsc_a_base of first bit in string */
        long            dsc_l_ubsb_l1;  /* lower bound */
        long            dsc_l_ubsb_u1;  /* upper bound */
};


/*
 *      Codes for dsc_b_dtype:
 */

/*
 *      Atomic data types:
 */
#define DSC_K_DTYPE_Z   0               /* unspecified */
#define DSC_K_DTYPE_BU  2               /* byte (unsigned);  8-bit unsigned quantity */
#define DSC_K_DTYPE_WU  3               /* word (unsigned);  16-bit unsigned quantity */
#define DSC_K_DTYPE_LU  4               /* longword (unsigned);  32-bit unsigned quantity */
#define DSC_K_DTYPE_QU  5               /* quadword (unsigned);  64-bit unsigned quantity */
#define DSC_K_DTYPE_OU  25              /* octaword (unsigned);  128-bit unsigned quantity */
#define DSC_K_DTYPE_B   6               /* byte integer (signed);  8-bit signed 2's-complement integer */
#define DSC_K_DTYPE_W   7               /* word integer (signed);  16-bit signed 2's-complement integer */
#define DSC_K_DTYPE_L   8               /* longword integer (signed);  32-bit signed 2's-complement integer */
#define DSC_K_DTYPE_Q   9               /* quadword integer (signed);  64-bit signed 2's-complement integer */
#define DSC_K_DTYPE_O   26              /* octaword integer (signed);  128-bit signed 2's-complement integer */
#define DSC_K_DTYPE_F   10              /* F_floating;  32-bit single-precision floating point */
#define DSC_K_DTYPE_D   11              /* D_floating;  64-bit double-precision floating point */
#define DSC_K_DTYPE_G   27              /* G_floating;  64-bit double-precision floating point */
#define DSC_K_DTYPE_H   28              /* H_floating;  128-bit quadruple-precision floating point */
#define DSC_K_DTYPE_FC  12              /* F_floating complex */
#define DSC_K_DTYPE_DC  13              /* D_floating complex */
#define DSC_K_DTYPE_GC  29              /* G_floating complex */
#define DSC_K_DTYPE_HC  30              /* H_floating complex */
#define DSC_K_DTYPE_CIT 31              /* COBOL Intermediate Temporary */
/*
 *      String data types:
 */
#define DSC_K_DTYPE_T   14              /* character string;  a single 8-bit character or a sequence of characters */
#define DSC_K_DTYPE_VT  37              /* varying character string;  16-bit count, followed by a string */
#define DSC_K_DTYPE_NU  15              /* numeric string, unsigned */
#define DSC_K_DTYPE_NL  16              /* numeric string, left separate sign */
#define DSC_K_DTYPE_NLO 17              /* numeric string, left overpunched sign */
#define DSC_K_DTYPE_NR  18              /* numeric string, right separate sign */
#define DSC_K_DTYPE_NRO 19              /* numeric string, right overpunched sign */
#define DSC_K_DTYPE_NZ  20              /* numeric string, zoned sign */
#define DSC_K_DTYPE_P   21              /* packed decimal string */
#define DSC_K_DTYPE_V   1               /* aligned bit string */
#define DSC_K_DTYPE_VU  34              /* unaligned bit string */
/*
 *      Miscellaneous data types:
 */
#define DSC_K_DTYPE_ZI  22              /* sequence of instructions */
#define DSC_K_DTYPE_ZEM 23              /* procedure entry mask */
#define DSC_K_DTYPE_DSC 24              /* descriptor */
#define DSC_K_DTYPE_BPV 32              /* bound procedure value */
#define DSC_K_DTYPE_BLV 33              /* bound label value */
#define DSC_K_DTYPE_ADT 35              /* absolute date and time */
/*
 *      Reserved data type codes:
 *      codes 38-191 are reserved to DIGITAL;
 *      codes 160-191 are reserved to DIGITAL facilities for facility-specific purposes;
 *      codes 192-255 are reserved for DIGITAL's Computer Special Systems Group
 *        and for customers for their own use.
 */


/*
 *      Codes for dsc_b_class:
 */
#define DSC_K_CLASS_S   1               /* fixed-length descriptor */
#define DSC_K_CLASS_D   2               /* dynamic string descriptor */
/*      DSC_K_CLASS_V                   ** variable buffer descriptor;  reserved for use by DIGITAL */
#define DSC_K_CLASS_A   4               /* array descriptor */
#define DSC_K_CLASS_P   5               /* procedure descriptor */
/*      DSC_K_CLASS_PI                  ** procedure incarnation descriptor;  obsolete */
/*      DSC_K_CLASS_J                   ** label descriptor;  reserved for use by the VMS Debugger */
/*      DSC_K_CLASS_JI                  ** label incarnation descriptor;  obsolete */
#define DSC_K_CLASS_SD  9               /* decimal string descriptor */
#define DSC_K_CLASS_NCA 10              /* noncontiguous array descriptor */
#define DSC_K_CLASS_VS  11              /* varying string descriptor */
#define DSC_K_CLASS_VSA 12              /* varying string array descriptor */
#define DSC_K_CLASS_UBS 13              /* unaligned bit string descriptor */
#define DSC_K_CLASS_UBA 14              /* unaligned bit array descriptor */
#define DSC_K_CLASS_SB  15              /* string with bounds descriptor */
#define DSC_K_CLASS_UBSB 16             /* unaligned bit string with bounds descriptor */
/*
 *      Reserved descriptor class codes:
 *      codes 15-191 are reserved to DIGITAL;
 *      codes 160-191 are reserved to DIGITAL facilities for facility-specific purposes;
 *      codes 192-255 are reserved for DIGITAL's Computer Special Systems Group
 *        and for customers for their own use.
 */


/*
 *      A simple macro to construct a string descriptor:
 */

#define DESCRIPTOR(name,string)         struct dsc_descriptor_s name = { sizeof(string)-1, DSC_K_DTYPE_T, DSC_K_CLASS_S, string }
#define DSC_DESCRIPTOR(name,string)     struct dsc_descriptor_s name = { sizeof(string)-1, DSC_K_DTYPE_T, DSC_K_CLASS_S, string }

#define DESCRIP_H_DEFINED
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\endian.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    endian.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the
    interpreter to perform endian, floating pointer, and character conversions.

Author :

    David Kays  dkays   December 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "cvt.h"
#include "ndrp.h"
#include "interp2.h"
#include "attack.h"

void
NdrUDTSimpeTypeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass );

void cvt_ibm_f_to_ieee_single( ULONG *ulFP );
void cvt_ibm_d_to_ieee_double( ULONG *ulFP );


//
// Conversion routine table.
//
const
PCONVERT_ROUTINE    ConvertRoutinesTable[] =
                    {
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    NdrUDTSimpeTypeConvert,
                    
                    NdrPointerConvert,
                    NdrPointerConvert,
                    NdrPointerConvert,
                    NdrPointerConvert,

                    NdrSimpleStructConvert,
                    NdrSimpleStructConvert,
                    NdrConformantStructConvert,
                    NdrConformantStructConvert,
                    NdrConformantStructConvert,     // same as FC_CARRAY

                    NdrComplexStructConvert,

                    NdrConformantArrayConvert,
                    NdrConformantVaryingArrayConvert,
                    NdrFixedArrayConvert,
                    NdrFixedArrayConvert,
                    NdrVaryingArrayConvert,
                    NdrVaryingArrayConvert,

                    NdrComplexArrayConvert,

                    NdrConformantStringConvert,
                    NdrConformantStringConvert,
                    NdrConformantStringConvert,
                    NdrConformantStringConvert,

                    NdrNonConformantStringConvert,
                    NdrNonConformantStringConvert,
                    NdrNonConformantStringConvert,
                    NdrNonConformantStringConvert,

                    NdrEncapsulatedUnionConvert,
                    NdrNonEncapsulatedUnionConvert,

                    NdrByteCountPointerConvert,

                    NdrXmitOrRepAsConvert,   // transmit as
                    NdrXmitOrRepAsConvert,   // represent as

                    NdrInterfacePointerConvert,

                    NdrContextHandleConvert,

                    0,                       // NdrHardStructConvert,

                    NdrXmitOrRepAsConvert,   // transmit as ptr
                    NdrXmitOrRepAsConvert,   // represent as ptr

                    NdrUserMarshalConvert,

                    0,   // FC_PIPE 
                    0,   // FC_BLK_HOLE

                    NdrpRangeConvert
                    };

extern const
PCONVERT_ROUTINE * pfnConvertRoutines = ConvertRoutinesTable;

void
NdrUDTSimpeTypeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
{
    if ( fEmbeddedPointerPass )
    {
        ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(*pFormat));
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(*pFormat);
    }
    else
    {
        NdrSimpleTypeConvert( pStubMsg,
                              *pFormat );
    }
}

//
// Array for ebcdic to ascii conversions. Use ebcdic value as index into
// array whose corresponding value is the correct ascii value.
// The table below maps from IBM 1047 EBCDIC codeset to ANSI 1252 code page.
//
// Note that due to a disagreement among the code page experts both within Msft
// and between Msft and SAG, I could not determine what the proper mapping 
// between these 2 code pages should be.
// The following 2 characters where in dispute:
//   0x15 maps to 0x0a - this is most likely right, as per experts' majority vote
//   0x25 maps to 0x85 - no agreement here at all, except that for back mapping
//                       it cannot be 0x0a again. 
//                       So, I resolved to use the mapping that worked for SAG.
// Ryszardk, Dec 4, 97
//
extern const
unsigned char EbcdicToAscii[] =
    {
    0x00, 0x01, 0x02, 0x03, 0x9c, 0x09, 0x86, 0x7f, 
    0x97, 0x8d, 0x8e, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 

    0x10, 0x11, 0x12, 0x13, 0x9d, 0x0a, 0x08, 0x87,          // 0x15 -> 0x0a
    0x18, 0x19, 0x92, 0x8f, 0x1c, 0x1d, 0x1e, 0x1f, 

    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x17, 0x1b,          // 0x25 -> 0x85
    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x05, 0x06, 0x07, 

    0x90, 0x91, 0x16, 0x93, 0x94, 0x95, 0x96, 0x04, 
    0x98, 0x99, 0x9a, 0x9b, 0x14, 0x15, 0x9e, 0x1a, 
                                            
    0x20, 0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5, 
    0xe7, 0xf1, 0xa2, 0x2e, 0x3c, 0x28, 0x2b, 0x7c, 

    0x26, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef, 
    0xec, 0xdf, 0x21, 0x24, 0x2a, 0x29, 0x3b, 0x5e, 

    0x2d, 0x2f, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5, 
    0xc7, 0xd1, 0xa6, 0x2c, 0x25, 0x5f, 0x3e, 0x3f, 

    0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd, 0xce, 0xcf, 
    0xcc, 0x60, 0x3a, 0x23, 0x40, 0x27, 0x3d, 0x22, 

    0xd8, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
    0x68, 0x69, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1, 

    0xb0, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 
    0x71, 0x72, 0xaa, 0xba, 0xe6, 0xb8, 0xc6, 0xa4, 

    0xb5, 0x7e, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
    0x79, 0x7a, 0xa1, 0xbf, 0xd0, 0x5b, 0xde, 0xae, 

    0xac, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc, 
    0xbd, 0xbe, 0xdd, 0xa8, 0xaf, 0x5d, 0xb4, 0xd7, 

    0x7b, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
    0x48, 0x49, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5, 

    0x7d, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 
    0x51, 0x52, 0xb9, 0xfb, 0xfc, 0xf9, 0xfa, 0xff, 

    0x5c, 0xf7, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 
    0x59, 0x5a, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5, 

    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
    0x38, 0x39, 0xb3, 0xdb, 0xdc, 0xd9, 0xda, 0x9f  
    
    };


void RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    long                NumberParams )
/*--

Routine description :

    This is the new stub and interpreter entry point for endian conversion.
    This routine handles the conversion of all parameters in a procedure.

Arguments :

    pStubMsg        - Pointer to stub message.
    pFormat         - Format string description of procedure's parameters.
    NumberParams    - The number of parameters in the procedure.

Return :

    None.

--*/
{
    uchar *             pBuffer;
    PFORMAT_STRING      pFormatComplex;
    PFORMAT_STRING      pFormatTypes;
    PPARAM_DESCRIPTION  Params;
    int                 fClientSide;
    long                n;

    //
    // Check if we need to do any converting.
    //
    if ( (pStubMsg->RpcMsg->DataRepresentation & (unsigned long)0X0000FFFF) ==
          NDR_LOCAL_DATA_REPRESENTATION )
        return;

    // Save the original buffer pointer to restore later.
    pBuffer = pStubMsg->Buffer;

    // Get the type format string.
    pFormatTypes = pStubMsg->StubDesc->pFormatTypes;

    fClientSide = pStubMsg->IsClient;

    Params = (PPARAM_DESCRIPTION) pFormat;

    for ( n = 0; n < NumberParams; n++ )
        {
        if ( fClientSide )
            {
            if ( ! Params[n].ParamAttr.IsOut )
                continue;
            }
        else
            {

            if ( Params[n].ParamAttr.IsPartialIgnore )
                {
                NdrSimpleTypeConvert( pStubMsg, FC_POINTER );
                continue;
                }

            if ( ! Params[n].ParamAttr.IsIn )
                continue;
            }

        if ( Params[n].ParamAttr.IsPipe )
            continue;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            NdrSimpleTypeConvert( pStubMsg, Params[n].SimpleType.Type );
            }
        else
            {
            //
            // Complex type or pointer to complex type.
            //
            pFormatComplex = pFormatTypes + Params[n].TypeOffset;

            (*pfnConvertRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  pFormatComplex,
                  FALSE );
            }
        }

    pStubMsg->Buffer = pBuffer;
}


void RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*--

Routine description :

    This is the stub and interpreter entry point for endian conversion.
    This routine handles the conversion of all parameters in a procedure.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Format string description of procedure's parameters.

Return :

    None.

--*/
{
    uchar *             pBuffer;
    PFORMAT_STRING      pFormatComplex;
    PFORMAT_STRING      pFormatTypes;
    int                 fClientSide;

    //
    // Check if we need to do any converting.
    //
    if ( (pStubMsg->RpcMsg->DataRepresentation & (unsigned long)0X0000FFFF) ==
          NDR_LOCAL_DATA_REPRESENTATION )
        return;

    // Save the original buffer pointer to restore later.
    pBuffer = pStubMsg->Buffer;

    // Get the type format string.
    pFormatTypes = pStubMsg->StubDesc->pFormatTypes;

    fClientSide = pStubMsg->IsClient;

    for ( ;; )
        {
        switch ( *pFormat )
            {
            case FC_IN_PARAM :
            case FC_IN_PARAM_NO_FREE_INST :
                if ( fClientSide )
                    {
                    pFormat += 4;
                    continue;
                    }

                break;

            case FC_IN_PARAM_BASETYPE :
                if ( ! fClientSide )
                    NdrSimpleTypeConvert( pStubMsg, pFormat[1] );

                pFormat += 2;
                continue;
       
            case FC_PARTIAL_IGNORE_PARAM:
                if ( ! fClientSide )
                    {
                    NdrSimpleTypeConvert( pStubMsg, FC_LONG );
                    pFormat += 4;
                    continue;
                    }
            // Intentional fallthrough
            case FC_IN_OUT_PARAM :
                break;

            case FC_OUT_PARAM :
                if ( ! fClientSide )
                    {
                    pFormat += 4;
                    continue;
                    }

                break;

            case FC_RETURN_PARAM :
                if ( ! fClientSide )
                    {
                    pStubMsg->Buffer = pBuffer;
                    return;
                    }

                break;

            case FC_RETURN_PARAM_BASETYPE :
                if ( fClientSide )
                    NdrSimpleTypeConvert( pStubMsg, pFormat[1] );

                // We're done.  Fall through.

            default :
                pStubMsg->Buffer = pBuffer;
                return;
            }

        //
        // Complex type or pointer to complex type.
        //
        pFormatComplex = pFormatTypes + *((ushort *)(pFormat + 2));

        (*pfnConvertRoutines[ROUTINE_INDEX(*pFormatComplex)])
            ( pStubMsg,
              pFormatComplex,
              FALSE );

        if ( *pFormat == FC_RETURN_PARAM )
            {
            pStubMsg->Buffer = pBuffer;
            return;
            }

        pFormat += 4;
        }
}


void
NdrSimpleTypeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar               FormatChar )
/*--

Routine description :

    Converts a simple type.

Arguments :

    pStubMsg    - Pointer to stub message.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
    switch ( FormatChar )
        {
        case FC_CHAR :
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 1 );            

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_CHAR_REP_MASK) ==
                 NDR_EBCDIC_CHAR )
                *(pStubMsg->Buffer) = EbcdicToAscii[*(pStubMsg->Buffer)];

            pStubMsg->Buffer += 1;
            break;

        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 1 );

            pStubMsg->Buffer++;
            break;

        case FC_SHORT :
        case FC_USHORT :
        case FC_WCHAR :
        case FC_ENUM16 :
            ALIGN(pStubMsg->Buffer,1);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 2 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_INT_REP_MASK) !=
                  NDR_LOCAL_ENDIAN )
                {
                *((ushort *)pStubMsg->Buffer) = RtlUshortByteSwap((*(ushort *)pStubMsg->Buffer));
                }

            pStubMsg->Buffer += 2;
            break;

        case FC_LONG :
        case FC_ULONG :
#if defined(__RPC_WIN64__)
        case FC_INT3264:
        case FC_UINT3264:
#endif
        case FC_POINTER :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 4 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_INT_REP_MASK) !=
                  NDR_LOCAL_ENDIAN )
                {
                *((ulong *)pStubMsg->Buffer) = RtlUlongByteSwap(*(ulong *)pStubMsg->Buffer);
                }

            pStubMsg->Buffer += 4;
            break;

        case FC_HYPER :
            ALIGN(pStubMsg->Buffer,7);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 8 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_INT_REP_MASK) !=
                 NDR_LOCAL_ENDIAN )
                {
                *((MIDL_uhyper *)pStubMsg->Buffer) = RtlUlonglongByteSwap(*(MIDL_uhyper *)pStubMsg->Buffer);
                }

            pStubMsg->Buffer += 8;
            break;

        //
        // VAX floating point conversions is the only one supported.
        //

        case FC_FLOAT :
            ALIGN(pStubMsg->Buffer,3);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 4 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_FLOAT_INT_MASK)
                 != NDR_LOCAL_ENDIAN_IEEE_REP )
                {
                BOOL fEndianessDone = FALSE;

                if ( (pStubMsg->RpcMsg->DataRepresentation &
                      NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN )
                    {
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
                    fEndianessDone = TRUE;
                    }

                if ( (pStubMsg->RpcMsg->DataRepresentation &
                      NDR_FLOAT_REP_MASK) != NDR_IEEE_FLOAT )
                    {
                    if ( fEndianessDone )
                        pStubMsg->Buffer -= 4;

                    if ( (pStubMsg->RpcMsg->DataRepresentation &
                          NDR_FLOAT_REP_MASK) == NDR_VAX_FLOAT )
                        {
                        cvt_vax_f_to_ieee_single( pStubMsg->Buffer,
                                                  0,
                                                  pStubMsg->Buffer );
                        pStubMsg->Buffer += 4;
                        }
                    else if ( (pStubMsg->RpcMsg->DataRepresentation & 
                               NDR_FLOAT_REP_MASK) == NDR_IBM_FLOAT )
                        {
                        cvt_ibm_f_to_ieee_single( (ULONG *)pStubMsg->Buffer ) ;
                        pStubMsg->Buffer += 4 ;
                        }
                    else
                        RpcRaiseException(RPC_X_BAD_STUB_DATA);
                    }
                }
            else
                pStubMsg->Buffer += 4;

            break;

        case FC_DOUBLE :
            ALIGN(pStubMsg->Buffer,7);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 8 );

            if ( (pStubMsg->RpcMsg->DataRepresentation & NDR_FLOAT_INT_MASK)
                 != NDR_LOCAL_ENDIAN_IEEE_REP )
                {
                BOOL fEndianessDone = FALSE;

                if ( (pStubMsg->RpcMsg->DataRepresentation &
                      NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN )
                    {
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_HYPER );
                    fEndianessDone = TRUE;
                    }

                if ( (pStubMsg->RpcMsg->DataRepresentation &
                      NDR_FLOAT_REP_MASK) != NDR_IEEE_FLOAT )
                    {
                    if ( fEndianessDone )
                        pStubMsg->Buffer -= 8;

                    if ( (pStubMsg->RpcMsg->DataRepresentation &
                          NDR_FLOAT_REP_MASK) == NDR_VAX_FLOAT )
                        {
                        cvt_vax_g_to_ieee_double( pStubMsg->Buffer,
                                                  0,
                                                  pStubMsg->Buffer );
                        pStubMsg->Buffer += 8;
                        }
                    else if ( (pStubMsg->RpcMsg->DataRepresentation & 
                               NDR_FLOAT_REP_MASK) == NDR_IBM_FLOAT )
                        {
                        cvt_ibm_d_to_ieee_double( (ULONG *)pStubMsg->Buffer ) ;
                        pStubMsg->Buffer += 8 ;
                        }
                    else
                        RpcRaiseException(RPC_X_BAD_STUB_DATA);
                    }
                }
            else
                pStubMsg->Buffer += 8;

            break;

        case FC_IGNORE:
            break;

        default :
            NDR_ASSERT(0,"NdrSimpleTypeConvert : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}


void
NdrpRangeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

--*/
{
    uchar    FcType = pFormat[1] & 0x0f;

    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( FcType );
    else
        NdrSimpleTypeConvert( pStubMsg, FcType );
}


void
NdrPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level pointer and the data it points to.
    Pointers embedded in structures, arrays, or unions call
    NdrpPointerConvert directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Pointer's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar *     pBufferMark;

    if ( *pFormat != FC_RP )
        {
        ALIGN(pStubMsg->Buffer,3);

        pBufferMark = pStubMsg->Buffer;

        if ( fEmbeddedPointerPass )
            pStubMsg->Buffer += PTR_WIRE_SIZE;
        else
            NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }
    else
        pBufferMark = 0;

    NdrpPointerConvert( pStubMsg,
                        pBufferMark,
                        pFormat );
}


void
NdrpPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    PFORMAT_STRING      pFormat )
/*--

Routine description :

    Private routine for converting a pointer and the data it points to.
    This is the entry point for pointers embedded in structures, arrays,
    and unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Pointer's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar   uFlagsSave;

    switch ( *pFormat )
        {
        case FC_RP :
            break;

        case FC_UP :
        case FC_OP :
            if ( ! *((long *)pBufferMark) )
                return;

            break;

        case FC_FP :
            //
            // Check if we have already seen this full pointer ref id during
            // endian coversion.  If so then we are finished with this pointer.
            //
            //
            if ( NdrFullPointerQueryRefId( pStubMsg->FullPtrXlatTables,
                                           *((ulong *)pBufferMark),
                                           FULL_POINTER_CONVERTED,
                                           0 ) )
                return;

            break;

        default :
            NDR_ASSERT(0,"NdrpPointerConvert : Bad format type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Pointer to complex type.
    //
    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        pFormat += 2;

        //
        // Get the pointee format string.
        // Cast must be to a signed short since some offsets are negative.
        //
        pFormat += *((signed short *)pFormat);
        }
    else
        {
        switch ( pFormat[2] )
            {
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :
                // Get to the string's description.
                pFormat += 2;
                break;

            default :
                // Else it's a pointer to a simple type.
                NdrSimpleTypeConvert( pStubMsg,
                                      pFormat[2] );
                return;
            }
        }

    //
    // Now lookup the proper conversion routine.
    //
    uFlagsSave = pStubMsg->uFlags;
    RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    (*pfnConvertRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                    pFormat,
                                                    FALSE );
    pStubMsg->uFlags = uFlagsSave;
}


void
NdrSimpleStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormatLayout;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Remember where the struct starts in the buffer.
    pBufferMark = pStubMsg->Buffer;

    pFormat += 4;

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    //
    // Convert or skip the flat part of the structure.
    //
    NdrpStructConvert( pStubMsg,
                       pFormatLayout,
                       0,
                       fEmbeddedPointerPass );

    //
    // Convert the pointers.  This will do nothing if
    // pStubMsg->IgnoreEmbeddedPointers is TRUE.
    //
    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrConformantStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a conformant or conformant varying structure.

    Used for FC_CSTRUCT, FC_CPSTRUCT and FC_CVSTRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.
                              
                         Note that for a top level struct it can only be FALSE.

Return :

    None.

Notes.
    These pearls of wisdom should be recorded for posterity in the main NDR doc,
    but just in case, let's have them here as well.

    Pointer layout is generated for all structs with pointers, however it is very
    much different for bogus structs.
    A conformant struct has a pointer layout that's complete, i.e. includes pointers
    from conformant arrays in conformant structs. In other words, pointer layout
    propagates up the embedding chain of conf structs.
    For bogus structs, the layout has only the pointers from the current level
    of the bogus struct, the pointers from emebedded bogus structs are with the 
    embedded struct and the pointers from the array are with the array.
    
    Now, arrays in conf structs don't have their own pointer layout description.
    However, top level arrays do have a pointer layout description as appropriate,
    and also conformant arrays from bogus structures do have pointer layout.

    So the bottom line is that a bogus struct depends on its conformant structure 
    or on its conformant array to walk the pointers embedded therein. The only 
    pointers described within the bogus struct are its member level pointers.

    Another look at it is that a conformant struct always has a full description of
    all the pointers contained within itself, whether in the flat portion or in the
    array, and so a conformant struct embedded in a bogus struct can be treated 
    like a top level struct as far as walking its embedded pointers.
    (Then the outer bogus struct cannot walk its array for embedded pointers as it
    would if the embedded struct was another bogus struct.)
    
    So, the rule for the conformant size is simple: whoever picks up the size
    should also process the array for the flat part.
    For the embedded pointers the situation is somewhat unpleasant for the conf 
    struct inside a bogus struct but we simplify by walking both levels. 
    The topmost conf struct has to be walked to see the pointers and the bogus
    can be walked as the walk would be an empty operation.
--*/
{
    PPRIVATE_CONVERT_ROUTINE    pfnConvert;
    uchar *                     pStructStart;
    PFORMAT_STRING              pFormatArray;
    PFORMAT_STRING              pFormatLayout;
    long                        MaxCount = 0;
    uchar                       fTopLevelStruct, fTopmostConfStruct;

    // We can't use pStubMsg->PointerBufferMark == 0 due to dual way ComplexStruct
    // routine is called. One is when embedded, another is a recursion for
    // embedded pointer pass.

    // Top level means a standalone struct, topmost means topmost conf struct, 
    // that is topmost may be embedded in a bogus struct.

    fTopLevelStruct = ! IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    fTopmostConfStruct = ! IS_TOPMOST_CONF_STRUCT( pStubMsg->uFlags );

    if ( fTopLevelStruct )
        {
        ALIGN(pStubMsg->Buffer,3);

        // Remember the conformant size position.
        pStubMsg->BufferMark = pStubMsg->Buffer;
        //
        // Convert conformance count if needed.
        //
        if ( fEmbeddedPointerPass )
            pStubMsg->Buffer += 4;
        else
            NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );

        // Get the conformance count.
        // This is valid because a conf struct would have only a single dim array.

        MaxCount = *((long *)(pStubMsg->Buffer - 4));
        }
    else
        {
        // This will be used only for the topmost case, set by bogus struct.
        MaxCount = *((long *)(pStubMsg->BufferMark));
        }

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Remember where the struct starts in the buffer.
    pStructStart = pStubMsg->Buffer;

    pFormat += 4;

    // Get the array description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    pFormat += 2;

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    // When walking the struct we can descend into embedded conf structs
    // so mark that the top level already happened.
    //
    SET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
    SET_TOPMOST_CONF_STRUCT(pStubMsg->uFlags);

    //
    // Convert or skip the flat part of the structure.
    //
    NdrpStructConvert( pStubMsg,
                       pFormatLayout,
                       0,
                       fEmbeddedPointerPass );

    // Convert the flat part of the array only if top level, as the array 
    // description gets propagated up the embeddings.
    // See a note about propagating array and pointer descriptions above.

    if ( fTopmostConfStruct && !fEmbeddedPointerPass )
        {
        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnConvert = NdrpConformantArrayConvert;
                break;
            case FC_CVARRAY :
                pfnConvert = NdrpConformantVaryingArrayConvert;
                break;
            default :
                //
                // Conformant strings, but use the non-conformant string conversion
                // routine since we've already converted the conformant size.
                //
                NdrNonConformantStringConvert( pStubMsg,
                                               pFormatArray,
                                               fEmbeddedPointerPass );
                goto CheckPointers;
            }

        pStubMsg->MaxCount = MaxCount;

        (*pfnConvert)( pStubMsg,
                       pFormatArray,
                       fEmbeddedPointerPass );

        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
        }

CheckPointers:

    // Convert embedded pointers for the whole structure including the array

    RESET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
    RESET_TOPMOST_CONF_STRUCT(pStubMsg->uFlags);
    
    // Convert pointees if the structure is standalone or if it is
    //   topmost embedded and pointer pass
    
    if ( fTopLevelStruct // standalone && !fEmbeddedPointerPass  
        ||
         fEmbeddedPointerPass && fTopmostConfStruct )
        {
        // Top level, or topmost within a bogus struct: walk the pointers.
        // Convert the pointers.  This will do nothing if
        // pStubMsg->IgnoreEmbeddedPointers is TRUE.
        //
        if ( *pFormat == FC_PP )
            {
            pStubMsg->BufferMark = pStructStart;
    
            NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
            }

        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
        }

    // Restore flags.
    if ( ! fTopLevelStruct)
        SET_EMBED_CONF_STRUCT(pStubMsg->uFlags);

    if ( ! fTopmostConfStruct)
        SET_TOPMOST_CONF_STRUCT(pStubMsg->uFlags);
}


#if 0
void
NdrHardStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a hard structure.

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

Notes:

    pStubMsg->PointerBufferMark
        ! NULL      indicates embedding in a complex struct.
        NULL        indicates top level or embedding in something else

    So the algoritm here is
        if the hard struct is in a complex struct, then the complex
            struct is issuing two calls, first with FALSE, then with TRUE.
        if the hard struct is NOT in a complex struct then there is only
            one call and the union has to be called explicitely.
--*/
{
    uchar *   BufferSaved;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Remember where the struct starts in the buffer.
    BufferSaved = pStubMsg->Buffer;

    //
    // Convert or skip the flat part of the structure.
    //
    NdrpStructConvert( pStubMsg,
                       pFormat + 16,
                       0,  // no pointer layout
                       fEmbeddedPointerPass );

    if ( ! pStubMsg->PointerBufferMark )
        {
        //
        // Convert the pointers.  This will do nothing if
        // pStubMsg->IgnoreEmbeddedPointers is TRUE.
        //
        // See if we have a union, as the pointer may be only there.
        //
        pFormat += 14;
        if ( *((short *)pFormat) )
            {
            //
            // Set the pointer to the beginning of the union:
            // the copy size is the struct buffer size without the union.
            //

            pStubMsg->Buffer = BufferSaved + *((short *)&pFormat[-4]);

            pFormat += *((short *)pFormat);

            (*pfnConvertRoutines[ ROUTINE_INDEX( *pFormat )])
                ( pStubMsg,
                  pFormat,
                  TRUE );    // convert the pointer only, if any.
            }
        }
}
#endif


void
NdrComplexStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.
                              
                     Notice a recursive call to this routine at the end.
                     Hence, the flag can be TRUE or FALSE even for the top level
                     bogus structures.
                     Also, for the recursive call pStubMsg->PointerBufferMark is
                     not 0, even for top level bogus struct.

Return :

    None.
    
Note about the recursive use of this routine:

    First pass - flat conversion pass.
    Convert flat part of the struct, then convert the array. For the embedded
    structs or arrays, go in and convert all of them without walking their
    pointers. The embedded conformant arrays should not be walked, only the 
    top level one.
    
    Second pass - converting the pointees.
    It has to increment over the conformant size.
    It needs to go through the flat part of any embedded thing as for bogus
    the pointer members are described only at their level.
    It needs to go through the conf array at the top level only.


--*/
{
    uchar *         pBufferSave;
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormatSave;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatPointers;
    uchar           Alignment;
    uchar           fTopLevelStruct;

    // We can't base the fTopLevelStruct flag upon check if
    // pStubMsg->PointerBufferMark == 0 due to dual way this routine is called. 
    // One is when embedded in another struct (or array), another is a recursion
    // from the same level for embedded pointer pass.
    // Luckily, when embedded in an array, the struct can be bogus but not
    // conformant. 

    fTopLevelStruct = ! IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    
    pFormatSave = pFormat;

    // Remember the beginning of the structure in the buffer.
    pBufferSave = pStubMsg->Buffer;

    Alignment = pFormat[1];

    pFormat += 4;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        {
        long    Dimensions;
        long    i;

        pFormatArray = pFormat + *((signed short *)pFormat);

        // Skip conformant size(s) for embedded struct.

        if ( fTopLevelStruct )
            {
            ALIGN(pStubMsg->Buffer,3);
    
            // Mark the conformance start.
            pStubMsg->BufferMark = pStubMsg->Buffer;
    
            Dimensions = NdrpArrayDimensions( pStubMsg, pFormatArray, FALSE );
    
            if ( ! fEmbeddedPointerPass )
                {
                for ( i = 0; i < Dimensions; i++ )
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
                }
            else
                {
                pStubMsg->Buffer += Dimensions * 4;
                }
            }
        }
    else
        pFormatArray = 0;

    // Position of the conf size(s) - we will pass it to conf struct routine.
    pBufferMark = pStubMsg->BufferMark;

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Check if we are not embedded inside of another complex struct or array.
    //
    // Notice that this check depends on PointerBufferMark that gets changed.
    // Hence, fComplexEntry will come out FALSE for the top level struct during
    // the embedded pointer pass recursive call.

    if ( fTopLevelStruct )
        {
        //
        // Mark PointerBufferMark with a non-null value so complex array's
        // embeddings work properly.
        //
        if ( pStubMsg->PointerBufferMark == 0 )
            pStubMsg->PointerBufferMark = (uchar *) UlongToPtr( 0xffffffff );
        }

    //
    // Convert the flat part of the structure.
    // Or convert pointers of the flat part of the structure.
    //
    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    NdrpStructConvert( pStubMsg,
                       pFormat,
                       pFormatPointers,
                       fEmbeddedPointerPass );

    //
    // Convert any conformant array, if present.
    // This converts the array flat on the first pass and the array's pointees
    // during the recursive pass.
    //
    // Convert the array only for a top level bogus struct but not if there was
    // an embedded conformant struct as this had been done already.

    if ( pFormatArray  &&  fTopLevelStruct  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PPRIVATE_CONVERT_ROUTINE    pfnConvert;
        uchar                       fOldIgnore;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnConvert = NdrpConformantArrayConvert;
                break;

            case FC_CVARRAY :
                pfnConvert = NdrpConformantVaryingArrayConvert;
                break;

            case FC_BOGUS_ARRAY :
                pfnConvert = NdrpComplexArrayConvert;
                break;

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_SSTRING :
            // case FC_C_WSTRING :

            default :
                //
                // Call the non-conformant string routine since we've
                // already handled the conformance count.
                //
                NdrNonConformantStringConvert( pStubMsg,
                                               pFormatArray,
                                               fEmbeddedPointerPass );
                goto ComplexConvertPointers;
            }

        fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

        //
        // Ignore embedded pointers if fEmbeddedPointerPass is false.
        //
        pStubMsg->IgnoreEmbeddedPointers = ! fEmbeddedPointerPass;

        // Get the outermost max count for unidimensional arrays.
        pStubMsg->MaxCount = *((ulong *)pBufferMark);

        // Mark where conformance count(s) are.
        pStubMsg->BufferMark = pBufferMark;

        (*pfnConvert)( pStubMsg,
                       pFormatArray,
                       fEmbeddedPointerPass );

        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        }

ComplexConvertPointers:

    // Setup for the recursive call.
    // Now start a conversion pass for embedded pointers for the complex
    // struct if we're not embedded inside of another complex struct or array.
    //
    if ( fTopLevelStruct  &&  ! fEmbeddedPointerPass )
        {
        RESET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

        // The first pointee.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        // Starting from the conf size again.
        pStubMsg->Buffer = pBufferSave;

        NdrComplexStructConvert( pStubMsg,
                                 pFormatSave,
                                 TRUE );

        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    // Restore the flag
    if ( fTopLevelStruct )
        {
        RESET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );
        }
    else
        SET_EMBED_CONF_STRUCT(pStubMsg->uFlags);
}


void
NdrpStructConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    PFORMAT_STRING      pFormatPointers,
    uchar               fEmbeddedPointerPass )
/*++

Routine description :

    Converts any type of structure given a structure layout.
    Does one pass converting flat part or the pointees per fEmbeddedPointerPass.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Structure layout format string description.
    pFormatPointers         - Pointer layout if the structure is complex,
                              otherwise 0.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.
                              
    
        We set this to TRUE during our first pass over the structure in which
        we convert the flat part of the structure and ignore embedded pointers.
        This will make any embedded ok structs or ok arrays ignore their
        embedded pointers until the second pass to convert embedded pointers
        (at which point we'll have the correct buffer pointer to where the
        pointees are).
        
    pStubMsg->IgnoreEmbeddedPointers is preserved but does not change anything.
    pStubMsg->BufferMark is preserved and passed on for the embedded conf structs.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatComplex;
    uchar           fOldIgnore;
    uchar *         pBufferMarkSave = pStubMsg->BufferMark;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = ! fEmbeddedPointerPass;

    //
    // Convert the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // simple types
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
                if ( fEmbeddedPointerPass )
                    {
                    ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(*pFormat));
                    pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(*pFormat);
                    }
                else
                    {
                    NdrSimpleTypeConvert( pStubMsg,
                                          *pFormat );
                    }
                break;

            case FC_IGNORE :
                ALIGN(pStubMsg->Buffer,3);
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                break;
                
            case FC_POINTER :
                //
                // We can only get an FC_POINTER in a complex struct's layout.
                // Pointers show up as FC_LONG in ok struct's layouts.
                //
                if ( fEmbeddedPointerPass )
                    {
                    uchar *     pBuffer;
                    uchar       fEmbedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                    NDR_ASSERT(pFormatPointers != 0,"Internal error");

                    ALIGN(pStubMsg->Buffer,3);

                    pBuffer = pStubMsg->Buffer;

                    pStubMsg->Buffer = pStubMsg->PointerBufferMark;

                    pStubMsg->PointerBufferMark = 0;
                    RESET_EMBED_CONF_STRUCT(pStubMsg->uFlags);

                    NdrpPointerConvert( pStubMsg,
                                        pBuffer,
                                        pFormatPointers );

                    // Restore the flag
                    if ( fEmbedStruct )
                        SET_EMBED_CONF_STRUCT(pStubMsg->uFlags);

                    pStubMsg->PointerBufferMark = pStubMsg->Buffer;

                    pStubMsg->Buffer = pBuffer + PTR_WIRE_SIZE;

                    pFormatPointers += 4;

                    break;
                    }
                else
                    {
                    NdrSimpleTypeConvert( pStubMsg,
                                          (uchar) FC_LONG );
                    }
                break;

            //
            // Embedded structures
            //
            case FC_EMBEDDED_COMPLEX :
                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                pStubMsg->BufferMark = pBufferMarkSave;

                (*pfnConvertRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  pFormatComplex,
                  fEmbeddedPointerPass );  // the argument as it came in

                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                pFormat++;

                break;

            //
            // Unused for endian conversion.
            //
            case FC_ALIGNM2 :
            case FC_ALIGNM4 :
            case FC_ALIGNM8 :
                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pFormat += 3;
                break;

            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
                return;

            default :
                NDR_ASSERT(0,"NdrpStructConvert : Bad format type");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            }
        }

    pStubMsg->BufferMark = pBufferMarkSave;

}


void
NdrFixedArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a fixed array of any number of dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatLayout;
    uchar *         pBufferMark;
    long            Elements;
    uchar           fOldIgnore;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pBufferMark = pStubMsg->Buffer;

    // Get the number of array elements.
    Elements = NdrpArrayElements( pStubMsg,
                                  0,
                                  pFormat );

    pFormat += (*pFormat == FC_SMFARRAY) ? 4 : 6;

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = TRUE;

    NdrpArrayConvert( pStubMsg,
                      pFormatLayout,
                      Elements,
                      fEmbeddedPointerPass );

    pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrConformantArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts top level a one dimensional conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    ALIGN(pStubMsg->Buffer,3);

    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 4;
    else
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );

    pStubMsg->MaxCount = *((long *)(pStubMsg->Buffer - 4));

    NdrpConformantArrayConvert( pStubMsg,
                                pFormat,
                                fEmbeddedPointerPass );
}


void
NdrpConformantArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting a one dimensional conformant array.
    This is the entry point for an embedded conformant array.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatLayout;
    uchar *         pBufferMark;
    long            Elements;
    uchar           fOldIgnore;

    Elements = (ulong)pStubMsg->MaxCount;

    if ( ! Elements )
        return;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pBufferMark = pStubMsg->Buffer;

    pFormat += 8;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = TRUE;

    NdrpArrayConvert( pStubMsg,
                      pFormatLayout,
                      Elements,
                      fEmbeddedPointerPass );

    pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        pStubMsg->MaxCount = Elements;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrConformantVaryingArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level one dimensional conformant varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    ALIGN(pStubMsg->Buffer,3);

    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 4;
    else
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );

    // We don't care about the max count.

    NdrpConformantVaryingArrayConvert( pStubMsg,
                                       pFormat,
                                       fEmbeddedPointerPass );
}


void
NdrpConformantVaryingArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting a one dimensional conformant varying array.
    This is the entry point for converting an embedded conformant varying
    array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatLayout;
    uchar *         pBufferMark;
    long            Elements;
    uchar           fOldIgnore;

    ALIGN(pStubMsg->Buffer,3);

    // Convert offset and actual count.
    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 8;
    else
        {
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }

    Elements = *((long *)(pStubMsg->Buffer - 4));

    if ( ! Elements )
        return;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pBufferMark = pStubMsg->Buffer;

    pFormat += 12;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = TRUE;

    NdrpArrayConvert( pStubMsg,
                      pFormatLayout,
                      Elements,
                      fEmbeddedPointerPass );

    pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        pStubMsg->MaxCount = Elements;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrVaryingArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level or embedded varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatLayout;
    uchar *         pBufferMark;
    long            Elements;
    uchar           fOldIgnore;

    ALIGN(pStubMsg->Buffer,3);

    // Convert offset and actual count.
    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 8;
    else
        {
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }

    Elements = *((long *)(pStubMsg->Buffer - 4));

    if ( ! Elements )
        return;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pBufferMark = pStubMsg->Buffer;

    pFormat += (*pFormat == FC_SMVARRAY) ? 12 : 16;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        pFormatLayout = NdrpSkipPointerLayout( pFormat );
    else
        pFormatLayout = pFormat;

    fOldIgnore = (uchar) pStubMsg->IgnoreEmbeddedPointers;

    pStubMsg->IgnoreEmbeddedPointers = TRUE;

    NdrpArrayConvert( pStubMsg,
                      pFormatLayout,
                      Elements,
                      fEmbeddedPointerPass );

    pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferMark;

        pStubMsg->MaxCount = Elements;

        NdrpEmbeddedPointerConvert( pStubMsg, pFormat );
        }
}


void
NdrComplexArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    long    Dimensions;
    long    i;

    if ( ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff ) &&
         ( pStubMsg->pArrayInfo == 0 ) )
        {
        ALIGN(pStubMsg->Buffer,3);

        // Mark where conformance is.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        Dimensions = NdrpArrayDimensions(  pStubMsg, pFormat, FALSE );

       if ( ! fEmbeddedPointerPass )
            {
            for ( i = 0; i < Dimensions; i++ )
                NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
            }
        else
            pStubMsg->Buffer += Dimensions * 4;
        }

    NdrpComplexArrayConvert( pStubMsg,
                             pFormat,
                             fEmbeddedPointerPass );
}


void
NdrpComplexArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting a complex array.  This is the entry
    point for converting an embedded complex array.

    Used for FC_BOGUS_ARRAY.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO     pArrayInfo;
    PFORMAT_STRING  pFormatSave;
    uchar *         pBuffer;
    ULONG_PTR       MaxCountSave;
    long            Elements;
    long            Dimension;
    uchar           Alignment;

    //
    // Setup if we are the outer dimension.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        pStubMsg->pArrayInfo = &ArrayInfo;

        ArrayInfo.Dimension = 0;
        ArrayInfo.BufferConformanceMark = (unsigned long *)pStubMsg->BufferMark;
        ArrayInfo.BufferVarianceMark = 0;
        }

    pFormatSave = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    // Remember the start of the array in the buffer.
    pBuffer = pStubMsg->Buffer;

    // Get the array alignment.
    Alignment = pFormat[1];

    pFormat += 2;

    // Get number of elements (0 if conformance present).
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = pArrayInfo->BufferConformanceMark[Dimension];
        pStubMsg->MaxCount = Elements;
        }

    MaxCountSave = pStubMsg->MaxCount;

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        long    TotalDimensions;
        long    i;

        if ( Dimension == 0 )
            {
            ALIGN(pStubMsg->Buffer,3);

            pArrayInfo->BufferVarianceMark = (unsigned long *)pStubMsg->Buffer;

            TotalDimensions = NdrpArrayDimensions(  pStubMsg, pFormatSave, TRUE );

            if ( ! fEmbeddedPointerPass )
                {
                //
                // Convert offsets and lengths.
                //
                for ( i = 0; i < TotalDimensions; i++ )
                    {
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
                    NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
                    }
                }
            else
                pStubMsg->Buffer += TotalDimensions * 8;
            }

        // Overwrite Elements with the actual count.
        Elements = pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1];
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( Elements )
        {
        BOOL    fComplexEntry;
        uchar   fIsEmbedStruct = ! IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

        ALIGN(pStubMsg->Buffer,Alignment);
    
        //
        // Check if we are not embedded inside of another complex struct or array.
        //
        if ( fComplexEntry = (pStubMsg->PointerBufferMark == 0) )
            {
            //
            // Mark PointerBufferMark with a non-null value so complex array's
            // or struct's which we embed will get fComplexEntry = false.
            //
            pStubMsg->PointerBufferMark = (uchar *) UlongToPtr( 0xffffffff );
            SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
            }
    
        NdrpArrayConvert( pStubMsg,
                          pFormat,
                          Elements,
                          fEmbeddedPointerPass );
    
        pArrayInfo->Dimension = Dimension;
    
         //
         // Now convert pointers in the array members.
         //
         if ( ! fEmbeddedPointerPass && fComplexEntry )
            {
            pStubMsg->PointerBufferMark = pStubMsg->Buffer;
    
            pStubMsg->Buffer = pBuffer;
    
            // Restore BufferMark to handle multiD arrays.
            pStubMsg->BufferMark = (uchar *) ArrayInfo.BufferConformanceMark;
    
            // Restore the original max count if we had one.
            pStubMsg->MaxCount = MaxCountSave;
    
            NdrpComplexArrayConvert( pStubMsg,
                                     pFormatSave,
                                     TRUE );
    
            pStubMsg->Buffer = pStubMsg->PointerBufferMark;

            pStubMsg->PointerBufferMark = 0;
            }
        
        // Restore the entry values of these flags.

        if ( fComplexEntry )
            {
            pStubMsg->PointerBufferMark = 0;

            if ( ! fIsEmbedStruct )
                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
            }
        }

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;
}


void
NdrpArrayConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    long                Elements,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting any kind of array.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Array's element format string description.
    Elements                - Number of elements in the array.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PCONVERT_ROUTINE    pfnConvert;
    uchar *             pBufferSave;
    long                Dimension;
    long                i;
    uchar *             pPointerIdMark = 0;

    // Used for FC_RP only.
    pBufferSave = 0;

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            //
            // Get the complex type description.
            //
            pFormat += 2;
            pFormat += *((signed short UNALIGNED *)pFormat);

            pfnConvert = pfnConvertRoutines[ROUTINE_INDEX(*pFormat)];
            break;

        case FC_RP :
        case FC_IP :
            // we don't want to change the behavior of these two
            if (! fEmbeddedPointerPass)
                return;

            // fall through otherwise
        case FC_UP :
        case FC_FP :
        case FC_OP :
            pPointerIdMark = pStubMsg->Buffer;

            if ( ! fEmbeddedPointerPass )
            {
                for ( i = 0; i < Elements; i++ )
                    NdrSimpleTypeConvert(pStubMsg, FC_LONG);
                return;
            }

            if ( pStubMsg->PointerBufferMark )
                {
                pBufferSave = pStubMsg->Buffer;

                pStubMsg->Buffer = pStubMsg->PointerBufferMark;

                pStubMsg->PointerBufferMark = 0;
                }

            pfnConvert = (*pFormat == FC_IP) ? NdrInterfacePointerConvert:
                            (PCONVERT_ROUTINE) NdrpPointerConvert ;
            break;

        case FC_RANGE:
                if ( fEmbeddedPointerPass )
                    {
                    ulong RangeSize = Elements * SIMPLE_TYPE_BUFSIZE( pFormat[1] );
                    
                    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, RangeSize );
                    pStubMsg->Buffer += RangeSize;
                    return;
                    }

                for ( i = 0; i < Elements; i++ )
                    {
                    NdrpRangeConvert( pStubMsg,  pFormat,  fEmbeddedPointerPass);
                    }
                break;
        default :
            //
            // Simple type.
            //
            if ( fEmbeddedPointerPass )
                {
                unsigned long ArrSize = Elements * SIMPLE_TYPE_BUFSIZE(*pFormat);

                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, ArrSize );
                pStubMsg->Buffer += ArrSize;
                return;
                }

            // Optimize out an array of bytes

            if ( *pFormat == FC_BYTE )
                {
                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, Elements );
                pStubMsg->Buffer += Elements;

                return;
                }

            for ( i = 0; i < Elements; i++ )
                {
                NdrSimpleTypeConvert( pStubMsg,
                                      *pFormat );
                }

            return;
        }

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        {
        pStubMsg->pArrayInfo = 0;
        }
    else
        {
        //
        // If we're dealing with a multidimensional fixed array, then pArrayInfo will
        // be NULL.  For non-fixed multidimensional arrays it will be valid.
        //
        if ( pStubMsg->pArrayInfo )
            Dimension = pStubMsg->pArrayInfo->Dimension;
        }

    if ( pfnConvert == (PCONVERT_ROUTINE) NdrpPointerConvert )
        {
        ALIGN( pPointerIdMark, 3);
        for ( i = 0; i < Elements; i++, pPointerIdMark += PTR_WIRE_SIZE )
            {
            NdrpPointerConvert( pStubMsg,
                                pPointerIdMark,
                                pFormat );
            }
        }
    else
        {
        for ( i = 0; i < Elements; i++ )
            {
            if ( IS_ARRAY_OR_STRING(*pFormat) && pStubMsg->pArrayInfo )
                pStubMsg->pArrayInfo->Dimension = Dimension + 1;

            (*pfnConvert)( pStubMsg,
                           pFormat,
                           fEmbeddedPointerPass );
            }
        }

    if ( pBufferSave )
        {
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer = pBufferSave;
        }
}


void
NdrConformantStringConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - String's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    //
    // If this is not part of a multidimensional array then we check if we
    // have to convert the max count.
    //
    if ( pStubMsg->pArrayInfo == 0 )
        {
        ALIGN(pStubMsg->Buffer,3);

        if ( fEmbeddedPointerPass )
            pStubMsg->Buffer += 4;
        else
            NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }

    NdrNonConformantStringConvert( pStubMsg,
                                   pFormat,
                                   fEmbeddedPointerPass );
}


void
NdrNonConformantStringConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a non conformant string.  This routine is also used to convert
    conformant strings and is also the entry point for an embeded conformant
    string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, FC_BSTRING (NT Beta2
    compatability only), FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and
    FC_C_BSTRING (NT Beta2 compatability only).

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - String's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar * pBuffer;
    long    Elements;

    ALIGN(pStubMsg->Buffer,3);

    if ( fEmbeddedPointerPass )
        pStubMsg->Buffer += 8;
    else
        {
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
        }

    Elements = *((long *)(pStubMsg->Buffer - 4));

    pBuffer = pStubMsg->Buffer;

    //
    // Convert string.  Remember that NdrConformantStringConvert calls this
    // routine too.
    //
    switch ( *pFormat )
        {
        case FC_C_CSTRING :
        case FC_C_BSTRING :
        case FC_CSTRING :
        case FC_BSTRING :
            CHECK_ULONG_BOUND( Elements );
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + Elements );
        
            if ( ((pStubMsg->RpcMsg->DataRepresentation & NDR_CHAR_REP_MASK) ==
                  NDR_EBCDIC_CHAR) && ! fEmbeddedPointerPass )
                {
                for ( ; Elements-- > 0; )
                    *pBuffer++ = EbcdicToAscii[*pBuffer];
                }
            else
                pBuffer += Elements;

            break;

        case FC_C_WSTRING :
        case FC_WSTRING :
            CHECK_ULONG_BOUND( Elements * 2 );
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 2 * Elements );
        
            if ( ((pStubMsg->RpcMsg->DataRepresentation & NDR_INT_REP_MASK) !=
                  NDR_LOCAL_ENDIAN) && ! fEmbeddedPointerPass )
                {
                for ( ; Elements-- > 0; )
                    *((ushort *&)pBuffer)++ =
                            (*((ushort *)pBuffer) & MASK_A_) >> 8 |
                            (*((ushort *)pBuffer) & MASK__B) << 8 ;
                }
            else
                pBuffer += Elements * 2;

            break;

        case FC_C_SSTRING :
        case FC_SSTRING :
            // Never anything to convert.
            CHECK_ULONG_BOUND( Elements * pFormat[1]);
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + Elements * pFormat[1] );

            pBuffer += Elements * pFormat[1];
            break;

        default :
            NDR_ASSERT(0,"NdrNonConformantStringConvert : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    pStubMsg->Buffer = pBuffer;
}


void
NdrEncapsulatedUnionConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts an encapsulated union.

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Union's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar   SwitchType;

    NO_CORRELATION;

    SwitchType = LOW_NIBBLE(pFormat[1]);

    NdrpUnionConvert( pStubMsg,
                      pFormat + 4,
                      SwitchType,
                      fEmbeddedPointerPass );
}


void
NdrNonEncapsulatedUnionConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts an non-encapsulated union.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Union's format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar   SwitchType;

    SwitchType = pFormat[1];

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    pFormat += 2;

    NdrpUnionConvert( pStubMsg,
                      pFormat,
                      SwitchType,
                      fEmbeddedPointerPass );
}


void
NdrpUnionConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               SwitchType,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Private routine for converting a union shared by encapsulated and
    non-encapsulated unions.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Union's format string description.
    SwitchType              - Union's format char switch type.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    long    SwitchIs;
    long    Arms;
    uchar   Alignment;

    //
    // Convert the switch_is().
    //
    if ( fEmbeddedPointerPass )
        {
        ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(SwitchType));
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(SwitchType);
        }
    else
        {
        NdrSimpleTypeConvert( pStubMsg,
                              SwitchType );
        }

    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *)(pStubMsg->Buffer - 1));
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *)(pStubMsg->Buffer - 1));
            break;
        case FC_SHORT :
        case FC_ENUM16 :
            SwitchIs = (long) *((short *)(pStubMsg->Buffer - 2));
            break;
        case FC_USHORT :
        case FC_WCHAR :
            SwitchIs = (long) *((ushort *)(pStubMsg->Buffer - 2));
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG.
            SwitchIs = *((long *)(pStubMsg->Buffer - 4));
            break;
        default :
            NDR_ASSERT(0,"NdrpUnionConvert : bad switch value");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // We're at the union_arms<2> field now, which contains both the
    // Microsoft union aligment value and the number of union arms.
    //

    //
    // Get the union alignment (0 if this is a DCE union).
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Number of arms is the lower 12 bits.
    //
    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff);

    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm has no description.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        // Convert an arm of a simple type

        if ( fEmbeddedPointerPass )
            {
            ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( pFormat[0] ));
            pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( pFormat[0] );
            }
        else
            NdrSimpleTypeConvert( pStubMsg, pFormat[0] );

        return;
        }

    pFormat += *((signed short *)pFormat);

    //
    // We have to do special things for a union arm which is a pointer when
    // we have a union embedded in a complex struct or array.
    //
    if ( IS_BASIC_POINTER(*pFormat) && pStubMsg->PointerBufferMark )
        {
        uchar * pBufferMark;

        //
        // If we're not in the embedded pointer pass then just convert the
        // pointer value.
        //
        if ( ! fEmbeddedPointerPass )
            {
            NdrSimpleTypeConvert( pStubMsg, (uchar) FC_LONG );
            return;
            }

        pBufferMark = pStubMsg->Buffer;

        // Align pBufferMark.
        ALIGN(pBufferMark,3);

        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;

        //
        // We must call the private pointer conversion routine.
        //
        NdrpPointerConvert( pStubMsg,
                            pBufferMark,
                            pFormat );

        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer = pBufferMark + PTR_WIRE_SIZE;

        return;
        }

    //
    // Union arm of a complex type.
    //
    (*pfnConvertRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                    pFormat,
                                                    fEmbeddedPointerPass );
}


void
NdrByteCountPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a byte count pointer.

    Used for FC_BYTE_COUNT_POINTER.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Byte count pointer format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    if ( pFormat[1] != FC_PAD )
        {
        NdrSimpleTypeConvert( pStubMsg, pFormat[1] );
        return;
        }

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((short *)pFormat);

    (*pfnConvertRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                    pFormat,
                                                    fEmbeddedPointerPass );
}


void
NdrXmitOrRepAsConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a transmit as or represent as transmited object.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - s format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    PFORMAT_STRING           pTransFormat;

    // Transmitted type cannot have pointers in it, as of now,
    // so if this is a embedded pointer pass, just return.

    if ( fEmbeddedPointerPass )
        return;

    // Go to the transmitted type and convert it.

    pFormat += 8;
    pTransFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pTransFormat ) )
        {
        NdrSimpleTypeConvert( pStubMsg, *pTransFormat );
        }
    else
        {
        (*pfnConvertRoutines[ ROUTINE_INDEX( *pTransFormat) ])
                    ( pStubMsg,
                      pTransFormat,
                      fEmbeddedPointerPass );
        }
}


void
NdrUserMarshalConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts a user_marshal object using the transmissible type description.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - not used
    fEmbeddedPointerPass    - not used


Return :

    None.

--*/
{
    PFORMAT_STRING           pTransFormat;

    // Go to the transmissible type and convert it.

    pFormat += 8;
    pTransFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pTransFormat ) )
        {
        if ( fEmbeddedPointerPass )
            return;

        NdrSimpleTypeConvert( pStubMsg, *pTransFormat );
        }
    else
        {
        // It may have pointers in it.

        if ( IS_POINTER_TYPE(*pTransFormat) &&  pStubMsg->PointerBufferMark )
            {
            // Embedded case and the type is a pointer type.

            if ( fEmbeddedPointerPass )
                {
                uchar * BufferSave = pStubMsg->Buffer;

                // Get the pointee type and convert it.

                pStubMsg->Buffer = pStubMsg->PointerBufferMark;

                pTransFormat += 2;
                pTransFormat += *(short *)pTransFormat;

                if ( IS_SIMPLE_TYPE( *pTransFormat ) )
                    {
                    NdrSimpleTypeConvert( pStubMsg, *pTransFormat );
                    }
                else
                    {
                    uchar uFlagsSave;
                    uFlagsSave = pStubMsg->uFlags;
                    RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);
                    // Convert the pointee as if not embedded.

                    pStubMsg->PointerBufferMark = 0;
                    (*pfnConvertRoutines[ ROUTINE_INDEX( *pTransFormat) ])
                            ( pStubMsg,
                              pTransFormat,
                              FALSE );
                    pStubMsg->uFlags = uFlagsSave;

                    // Set the pointee marker behind the converted whole.

                    pStubMsg->PointerBufferMark = pStubMsg->Buffer;
                    }

                // Now step over the original pointer.

                pStubMsg->Buffer = BufferSave;

                ALIGN(pStubMsg->Buffer,3);
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                }
            else
                {
                // Convert the pointer itself only.
                // We can't call ptr convert routine because of the pointee.

                NdrSimpleTypeConvert( pStubMsg, FC_LONG );
                }
            }
        else
            {
            // Non embedded pointer type or
            // (embedded or not) a non-pointer or a non-simple type.
            // Just call the appropriate conversion routine.

            (*pfnConvertRoutines[ ROUTINE_INDEX( *pTransFormat) ])
                    ( pStubMsg,
                      pTransFormat,
                      fEmbeddedPointerPass );
            }
        }
}


unsigned char *  RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    unsigned char   FormatChar )
/*--

Routine description :

    Converts a simple type supplied from a user_marshal unmarshaled routine.

    Note that this is *not* supposed to be called when the NDR engine walks
    the wire type description to convert.

Arguments :

    pFlags      - flags as for user_marshal routines: data rep, context.
    pBuffer     - current buffer pointer supplied by the user
    FormatChar  - specifies the type

Return :

    None.

--*/
{
    uchar *             pBufferSave;
    USER_MARSHAL_CB *   pUserCB  = (USER_MARSHAL_CB *)pFlags;
    MIDL_STUB_MESSAGE * pStubMsg = pUserCB->pStubMsg;
    
    if ( pBuffer < pStubMsg->BufferStart  ||  
         pBuffer > pStubMsg->BufferEnd  ||
         ( (*pFlags >> 16)  !=
           (pStubMsg->RpcMsg->DataRepresentation & (ulong)0x0000FFFF) )
       )
        RpcRaiseException( RPC_S_INVALID_ARG );

    pBufferSave = pStubMsg->Buffer;

    pStubMsg->Buffer = pBuffer;
    NdrSimpleTypeConvert( pStubMsg, FormatChar );
    pBuffer = pStubMsg->Buffer;

    pStubMsg->Buffer = pBufferSave;

    return ( pBuffer );
}


void
NdrInterfacePointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Converts an interface pointer.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Xmit/Rep as format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    uchar * pBufferSave;
    unsigned long *pLength;

    // Align for getting the pointer's node id.
    ALIGN( pStubMsg->Buffer, 0x3 );

    //
    // If we're ignoring embedded pointers then we simply convert the pointer's
    // node id and return.  Otherwise, we skip the pointer's node id and
    // continue on to convert the actuall interface pointer.
    //
    if ( ! fEmbeddedPointerPass )
        {
        NdrSimpleTypeConvert( pStubMsg, FC_LONG );

        if ( pStubMsg->PointerBufferMark != 0 )
            return;

        pStubMsg->Buffer -= PTR_WIRE_SIZE;
        }

    // Skip the pointer's node id, which will already have been converted.
    //
    // Also, we don't have the pointee if the pointer itself is null;
    // An interface pointer behaves like a unique pointer.

    if ( *((long *&)pStubMsg->Buffer)++ == 0 )
        return;

    //
    // Check if we're handling pointers in a complex struct, and re-set the
    // Buffer pointer if so.
    //
    if ( pStubMsg->PointerBufferMark )
        {
        pBufferSave = pStubMsg->Buffer;

        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }
    else
        pBufferSave = 0;

    //
    // Convert the conformant size and the count field.
    //
    NdrSimpleTypeConvert( pStubMsg, FC_LONG );

    pLength = (unsigned long *) pStubMsg->Buffer;
    NdrSimpleTypeConvert( pStubMsg, FC_LONG );

    // Skip over the marshalled interface pointer.

    CHECK_EOB_RAISE_IB( pStubMsg->Buffer + *pLength );

    pStubMsg->Buffer += *pLength;

    //
    // Re-set the buffer pointer if needed.
    //
    if ( pBufferSave )
        {
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer = pBufferSave;
        }
}


void
NdrContextHandleConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass )
/*--

Routine description :

    Conversion routine for context handles, only increments the buffer.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Format string description.
    fEmbeddedPointerPass    - TRUE if a pass is being to convert only embedded
                              pointers in a struct/array.

Return :

    None.

--*/
{
    ALIGN(pStubMsg->Buffer,0x3);

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );
    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}


void
NdrpEmbeddedPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*--

Routine description :

    Private routine for converting an array's or a structure's embedded
    pointers.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Pointer layout format string description.

Return :

    None.

--*/
{
    uchar * pBufferMark;
    uchar * pBufferPointer;
    uchar * pBufferSave;
    ULONG_PTR MaxCountSave;

    MaxCountSave = pStubMsg->MaxCount;

    //
    // Return if we're ignoring embedded pointers.
    //
    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    //
    // Check if we're handling pointers in a complex struct, and re-set the
    // Buffer pointer if so.
    //
    if ( pStubMsg->PointerBufferMark )
        {
        pBufferSave = pStubMsg->Buffer;

        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }
    else
        pBufferSave = 0;

    pBufferMark = pStubMsg->BufferMark;

    //
    // Increment past the FC_PP and pad.
    //
    pFormat += 2;

    for (;;)
        {
        if ( *pFormat == FC_END )
            {
            if ( pBufferSave )
                {
                pStubMsg->PointerBufferMark = pStubMsg->Buffer;

                pStubMsg->Buffer = pBufferSave;
                }
            return;
            }

        // Check for a repeat pointer.
        if ( *pFormat != FC_NO_REPEAT )
            {
            pStubMsg->MaxCount = MaxCountSave;

            pFormat = NdrpEmbeddedRepeatPointerConvert( pStubMsg, pFormat );

            // Continue to the next pointer.
            continue;
            }

        // Increment to the buffer pointer offset.
        pFormat += 4;

        pBufferPointer = pBufferMark + *((signed short *&)pFormat)++;

        NdrpPointerConvert( pStubMsg,
                            pBufferPointer,
                            pFormat );

        // Increment past the pointer description.
        pFormat += 4;
        }
}


PFORMAT_STRING
NdrpEmbeddedRepeatPointerConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*--

Routine description :

    Private routine for converting an array's embedded pointers.

Arguments :

    pStubMsg                - Pointer to stub message.
    pFormat                 - Pointer layout format string description.

Return :

    Format string pointer past the array's pointer layout description.

--*/
{
    uchar *         pBufPtr;
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormatSave;
    ulong           RepeatCount,RepeatIncrement, Pointers, PointersSave;

    pBufferMark = pStubMsg->BufferMark;

    // Get the repeat count.
    switch ( *pFormat )
        {
        case FC_FIXED_REPEAT :
            pFormat += 2;

            RepeatCount = *((ushort *)pFormat);

            break;

        case FC_VARIABLE_REPEAT :
            RepeatCount = (ulong)pStubMsg->MaxCount;

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerConvert : bad format");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    pFormat += 2;

    RepeatIncrement = *((ushort *&)pFormat)++;

    // array_offset is ignored
    pFormat += 2;

    // Get number of pointers.
    Pointers = *((ushort *&)pFormat)++;

    pFormatSave = pFormat;
    PointersSave = Pointers;

    for ( ; RepeatCount--;
            pBufferMark += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        for ( ; Pointers--; )
            {
            pFormat += 2;

            pBufPtr = pBufferMark + *((signed short *&)pFormat)++;

            NdrpPointerConvert( pStubMsg,
                                pBufPtr,
                                pFormat );

            // Increment past the pointer description.
            pFormat += 4;
            }
        }

    return pFormatSave + PointersSave * 8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\endianp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    endianp.h

Abtract :

    Contains private sizing routine definitions.

Author :

    David Kays  dkays   December 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _ENDIANP_
#define _ENDIANP_

//
// These are no-exported APIs.
//
void 
NdrSimpleTypeConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char                       FormatChar
    );

void 
NdrPointerConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Structures */

void 
NdrSimpleStructConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrConformantStructConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrHardStructConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrComplexStructConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Arrays */

void 
NdrFixedArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrConformantArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrConformantVaryingArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrVaryingArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrComplexArrayConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Strings */

void 
NdrNonConformantStringConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrConformantStringConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Unions */

void 
NdrEncapsulatedUnionConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrNonEncapsulatedUnionConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Byte count pointer */

void 
NdrByteCountPointerConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* Transmit as and represent as convert */

void 
NdrXmitOrRepAsConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

/* User_marshall convert */

void 
NdrUserMarshalConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void 
NdrInterfacePointerConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

void
NdrContextHandleConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    unsigned char                       fConvertPointersOnly
    );

//
// Other helper routines.
//

void
NdrpPointerConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pBufferMark,
	PFORMAT_STRING				pFormat
	);

void
NdrpStructConvert( 
	PMIDL_STUB_MESSAGE 			pStubMsg, 
	PFORMAT_STRING				pFormat,
	PFORMAT_STRING 				pFormatPointers,
	uchar						fConvertPointersOnly
	);

void
NdrpConformantArrayConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat,
	uchar						fConvertPointersOnly
	);

void
NdrpConformantVaryingArrayConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat,
	uchar						fConvertPointersOnly
	);

void
NdrpComplexArrayConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat,
	uchar						fConvertPointersOnly
	);

void
NdrpArrayConvert( 
	PMIDL_STUB_MESSAGE	 		pStubMsg, 
	PFORMAT_STRING				pFormat,
	long						Elements,
	uchar						fConvertPointersOnly
	);

void
NdrpUnionConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat,
	uchar 						SwitchType,
	uchar						fConvertPointersOnly
	);

void
NdrpEmbeddedPointerConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat
	);

PFORMAT_STRING
NdrpEmbeddedRepeatPointerConvert( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	PFORMAT_STRING				pFormat
	);

typedef void	(* PCONVERT_ROUTINE)(
					PMIDL_STUB_MESSAGE, 
					PFORMAT_STRING,
					uchar  
				);

typedef void 	(* PPRIVATE_CONVERT_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					PFORMAT_STRING,
					uchar  
				);

// function table defined in endian.c
extern const PCONVERT_ROUTINE * pfnConvertRoutines;

//
// Conversion stuff.
//
extern const unsigned char EbcdicToAscii[];

#define NDR_FLOAT_INT_MASK                  (unsigned long)0X0000FFF0L

#define NDR_BIG_IEEE_REP                    (unsigned long)0X00000000L
#define NDR_LITTLE_IEEE_REP                 (unsigned long)0X00000010L

#define NDR_LOCAL_ENDIAN_IEEE_REP           NDR_LITTLE_IEEE_REP

//
// Masks defined for short byte swapping:
//

#define MASK_A_          (unsigned short)0XFF00
#define MASK__B          (unsigned short)0X00FF

//
// Masks defined for long byte swapping:
//

#define MASK_AB__        (unsigned long)0XFFFF0000L
#define MASK___CD        (unsigned long)0X0000FFFFL
#define MASK_A_C_        (unsigned long)0XFF00FF00L
#define MASK__B_D        (unsigned long)0X00FF00FFL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\freep.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    freep.h

Abtract :

    Contains private sizing routine definitions.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

typedef     void    (RPC_ENTRY * PFREE_ROUTINE)( 
						PMIDL_STUB_MESSAGE, 
					 	uchar *, 
						PFORMAT_STRING
					);

IMPORTSPEC
extern const PFREE_ROUTINE * pfnFreeRoutines;

void 
NdrpUnionFree(
	PMIDL_STUB_MESSAGE		pStubMsg,
    uchar *          		pMemory,
    PFORMAT_STRING   		pFormat,
	long					SwitchIs
    );

void
NdrpEmbeddedPointerFree(
	PMIDL_STUB_MESSAGE		pStubMsg,
    uchar *          		pMemory,
    PFORMAT_STRING   		pFormat
    );

PFORMAT_STRING
NdrpEmbeddedRepeatPointerFree(
	PMIDL_STUB_MESSAGE		pStubMsg,
    uchar *   		        pMemory,
    PFORMAT_STRING 		    pFormat
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\fullptr.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    fullptr.h

Abstract :

    This file contains private definitions for the NDR full pointer package.

Author :

    David Kays  dkays   January 1994.

Revision History :

  ---------------------------------------------------------------------*/

#ifndef _FULLPTR_
#define _FULLPTR_

#define FULL_POINTER_MARSHALLED     0x01
#define FULL_POINTER_UNMARSHALLED   0x02 
#define FULL_POINTER_BUF_SIZED      0x04
#define FULL_POINTER_MEM_SIZED      0x08
#define FULL_POINTER_CONVERTED      0x10
#define FULL_POINTER_FREED          0x20
#define FULL_POINTER_RMBED          0x40

#define CHECK_FULL_POINTER_STATE( State, StateType ) \
				( (State) & (StateType) )

#define SET_FULL_POINTER_STATE( State, StateType ) \
				( (State) |= (StateType) )

#define	DEFAULT_REF_ID_TO_POINTER_TABLE_ELEMENTS	512
#define	DEFAULT_POINTER_TO_REF_ID_TABLE_BUCKETS		512

#define	PTR_HASH( Pointer, HashMask )	\
				(ulong)( ((LONG_PTR)(Pointer) >> 3) & (HashMask) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\fmtstr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       FMTSTR.H
//
//  Contents:   Canned format string for 32bit and 64bit platforms.
//              This format string is generated from oandr.idl 
//              checkin ndr directory but not being built generally.
//              build mode: /Oicf /no_robust
//
//
//  History:    July 2nd, 1999 YongQu  Created
//
//----------------------------------------------------------------------------

#ifndef _FMTSTR_H_
#define _FMTSTR_H_

#if !defined(__RPC_WIN64__)

#define TYPE_FORMAT_STRING_SIZE   2364
#else
#define TYPE_FORMAT_STRING_SIZE   2508
#endif

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;


#if !defined(__RPC_WIN64__)

// 32 bit format string
#define BSTR_TYPE_FS_OFFSET 26              //bstr
#define LPWSTR_TYPE_FS_OFFSET 38            // lpwstr
#define LPSTR_TYPE_FS_OFFSET 42             // lpstr
#define EMBEDDED_LPWSTR_TYPE_FS_OFFSET 1028 // lpwstr
#define EMBEDDED_LPSTR_TYPE_FS_OFFSET 1036  // lpstr
#define VARIANT_TYPE_FS_OFFSET 986          // variant
#define DISPATCH_TYPE_FS_OFFSET 344         // pdispatch
#define UNKNOWN_TYPE_FS_OFFSET 326          // punk
#define DECIMAL_TYPE_FS_OFFSET 946          // decimal
#define SAFEARRAY_TYPE_FS_OFFSET 996        // pSafeArray


#define BYREF_BSTR_TYPE_FS_OFFSET 1014      // pBSTR
#define BYREF_LPWSTR_TYPE_FS_OFFSET 1024    // ppwsz
#define BYREF_LPSTR_TYPE_FS_OFFSET 1032     // ppsz
#define BYREF_VARIANT_TYPE_FS_OFFSET 1048   // pVariant
#define BYREF_DISPATCH_TYPE_FS_OFFSET 1062  // ppdistatch
#define BYREF_UNKNOWN_TYPE_FS_OFFSET 1058   // ppunk
#define BYREF_DECIMAL_TYPE_FS_OFFSET 958    // pDecimal
#define BYREF_SAFEARRAY_TYPE_FS_OFFSET 1082 // ppSafeArray


#define STREAM_TYPE_FS_OFFSET 1092          // pStream
#define BYREF_STREAM_TYPE_FS_OFFSET 1110    // ppStream
#define STORAGE_TYPE_FS_OFFSET 1114         // pStorage
#define BYREF_STORAGE_TYPE_FS_OFFSET 1132   // ppStorage
#define FILETIME_TYPE_FS_OFFSET 854         // FileTime
#define BYREF_FILETIME_TYPE_FS_OFFSET 1136  // pfileTime


#define BYREF_I1_TYPE_FS_OFFSET 898
#define BYREF_I2_TYPE_FS_OFFSET 902
#define BYREF_I4_TYPE_FS_OFFSET 906
#define BYREF_R4_TYPE_FS_OFFSET 910
#define BYREF_R8_TYPE_FS_OFFSET 914


#define I1_VECTOR_TYPE_FS_OFFSET 1150       // cab
#define I2_VECTOR_TYPE_FS_OFFSET 774        // cai
#define I4_VECTOR_TYPE_FS_OFFSET 804        // cal
#define R4_VECTOR_TYPE_FS_OFFSET 1180       // caflt
#define ERROR_VECTOR_TYPE_FS_OFFSET 804             // cascode
#define I8_VECTOR_TYPE_FS_OFFSET 1214               // cah
#define R8_VECTOR_TYPE_FS_OFFSET 1244       // cadbl
#define CY_VECTOR_TYPE_FS_OFFSET 1214       // cacy
#define DATE_VECTOR_TYPE_FS_OFFSET 1244             // cadate
#define FILETIME_VECTOR_TYPE_FS_OFFSET 1278         // cafiletime
#define BSTR_VECTOR_TYPE_FS_OFFSET 1434             // cabstr
#define BSTRBLOB_VECTOR_TYPE_FS_OFFSET 1486         // cabstrblob
#define LPSTR_VECTOR_TYPE_FS_OFFSET 1536            // calpstr
#define LPWSTR_VECTOR_TYPE_FS_OFFSET 1586           // calpwstr


#define BYREF_I1_VECTOR_TYPE_FS_OFFSET 2304 // pcab
#define BYREF_I2_VECTOR_TYPE_FS_OFFSET 2308 // pcai
#define BYREF_I4_VECTOR_TYPE_FS_OFFSET 2312 // pcal
#define BYREF_R4_VECTOR_TYPE_FS_OFFSET 2316 // pcaflt
#define BYREF_ERROR_VECTOR_TYPE_FS_OFFSET 2312      // pcascode
#define BYREF_I8_VECTOR_TYPE_FS_OFFSET 2320         // pcah
#define BYREF_R8_VECTOR_TYPE_FS_OFFSET 2324 // pcadbl
#define BYREF_CY_VECTOR_TYPE_FS_OFFSET 2320 // pcacy
#define BYREF_DATE_VECTOR_TYPE_FS_OFFSET 2324       // pcadate
#define BYREF_FILETIME_VECTOR_TYPE_FS_OFFSET 2328   // pcafiletime
#define BYREF_BSTR_VECTOR_TYPE_FS_OFFSET 2340       // pcabstr
#define BYREF_BSTRBLOB_VECTOR_TYPE_FS_OFFSET 2344   // pcabstrblob
#define BYREF_LPSTR_VECTOR_TYPE_FS_OFFSET 2348      // pcalpstr
#define BYREF_LPWSTR_VECTOR_TYPE_FS_OFFSET 2352     // pcalpwstr



/* File created by MIDL compiler version 5.03.0276 */
/* at Fri Jul 02 14:15:57 1999
 */
/* Compiler settings for oandr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/


static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xc ),	/* Offset= 12 (16) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 16 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (6) */
/* 22 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 24 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 26 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x4 ),	/* 4 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2) */
/* 36 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 38 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 40 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 42 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 44 */	
			0x12, 0x0,	/* FC_UP */
/* 46 */	NdrFcShort( 0x398 ),	/* Offset= 920 (966) */
/* 48 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 50 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 52 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 54 */	NdrFcShort( 0x2 ),	/* Offset= 2 (56) */
/* 56 */	NdrFcShort( 0x10 ),	/* 16 */
/* 58 */	NdrFcShort( 0x2b ),	/* 43 */
/* 60 */	NdrFcLong( 0x3 ),	/* 3 */
/* 64 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 66 */	NdrFcLong( 0x11 ),	/* 17 */
/* 70 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 72 */	NdrFcLong( 0x2 ),	/* 2 */
/* 76 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 78 */	NdrFcLong( 0x4 ),	/* 4 */
/* 82 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 84 */	NdrFcLong( 0x5 ),	/* 5 */
/* 88 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 90 */	NdrFcLong( 0xb ),	/* 11 */
/* 94 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 96 */	NdrFcLong( 0xa ),	/* 10 */
/* 100 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 102 */	NdrFcLong( 0x6 ),	/* 6 */
/* 106 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (320) */
/* 108 */	NdrFcLong( 0x7 ),	/* 7 */
/* 112 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 114 */	NdrFcLong( 0x8 ),	/* 8 */
/* 118 */	NdrFcShort( 0xffffff8c ),	/* Offset= -116 (2) */
/* 120 */	NdrFcLong( 0xd ),	/* 13 */
/* 124 */	NdrFcShort( 0xca ),	/* Offset= 202 (326) */
/* 126 */	NdrFcLong( 0x9 ),	/* 9 */
/* 130 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (344) */
/* 132 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 136 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (362) */
/* 138 */	NdrFcLong( 0x24 ),	/* 36 */
/* 142 */	NdrFcShort( 0x2f0 ),	/* Offset= 752 (894) */
/* 144 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 148 */	NdrFcShort( 0x2ea ),	/* Offset= 746 (894) */
/* 150 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 154 */	NdrFcShort( 0x2e8 ),	/* Offset= 744 (898) */
/* 156 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 160 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (902) */
/* 162 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 166 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (906) */
/* 168 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 172 */	NdrFcShort( 0x2e2 ),	/* Offset= 738 (910) */
/* 174 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 178 */	NdrFcShort( 0x2e0 ),	/* Offset= 736 (914) */
/* 180 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 184 */	NdrFcShort( 0x2ce ),	/* Offset= 718 (902) */
/* 186 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 190 */	NdrFcShort( 0x2cc ),	/* Offset= 716 (906) */
/* 192 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 196 */	NdrFcShort( 0x2d2 ),	/* Offset= 722 (918) */
/* 198 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 202 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (914) */
/* 204 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 208 */	NdrFcShort( 0x2ca ),	/* Offset= 714 (922) */
/* 210 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 214 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (926) */
/* 216 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 220 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (930) */
/* 222 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 226 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (934) */
/* 228 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 232 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (938) */
/* 234 */	NdrFcLong( 0x10 ),	/* 16 */
/* 238 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 240 */	NdrFcLong( 0x12 ),	/* 18 */
/* 244 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 246 */	NdrFcLong( 0x13 ),	/* 19 */
/* 250 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 252 */	NdrFcLong( 0x16 ),	/* 22 */
/* 256 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 258 */	NdrFcLong( 0x17 ),	/* 23 */
/* 262 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 264 */	NdrFcLong( 0xe ),	/* 14 */
/* 268 */	NdrFcShort( 0x2a6 ),	/* Offset= 678 (946) */
/* 270 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 274 */	NdrFcShort( 0x2ac ),	/* Offset= 684 (958) */
/* 276 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 280 */	NdrFcShort( 0x2aa ),	/* Offset= 682 (962) */
/* 282 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 286 */	NdrFcShort( 0x268 ),	/* Offset= 616 (902) */
/* 288 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 292 */	NdrFcShort( 0x266 ),	/* Offset= 614 (906) */
/* 294 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 298 */	NdrFcShort( 0x260 ),	/* Offset= 608 (906) */
/* 300 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 304 */	NdrFcShort( 0x25a ),	/* Offset= 602 (906) */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x0 ),	/* Offset= 0 (310) */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0x0 ),	/* Offset= 0 (316) */
/* 318 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (317) */
/* 320 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 326 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 338 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 340 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 342 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 344 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 346 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 352 */	NdrFcShort( 0x0 ),	/* 0 */
/* 354 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 356 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 358 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 360 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 362 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 364 */	NdrFcShort( 0x2 ),	/* Offset= 2 (366) */
/* 366 */	
			0x12, 0x0,	/* FC_UP */
/* 368 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (876) */
/* 370 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 372 */	NdrFcShort( 0x18 ),	/* 24 */
/* 374 */	NdrFcShort( 0xa ),	/* 10 */
/* 376 */	NdrFcLong( 0x8 ),	/* 8 */
/* 380 */	NdrFcShort( 0x58 ),	/* Offset= 88 (468) */
/* 382 */	NdrFcLong( 0xd ),	/* 13 */
/* 386 */	NdrFcShort( 0x78 ),	/* Offset= 120 (506) */
/* 388 */	NdrFcLong( 0x9 ),	/* 9 */
/* 392 */	NdrFcShort( 0x94 ),	/* Offset= 148 (540) */
/* 394 */	NdrFcLong( 0xc ),	/* 12 */
/* 398 */	NdrFcShort( 0xbc ),	/* Offset= 188 (586) */
/* 400 */	NdrFcLong( 0x24 ),	/* 36 */
/* 404 */	NdrFcShort( 0x114 ),	/* Offset= 276 (680) */
/* 406 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 410 */	NdrFcShort( 0x130 ),	/* Offset= 304 (714) */
/* 412 */	NdrFcLong( 0x10 ),	/* 16 */
/* 416 */	NdrFcShort( 0x148 ),	/* Offset= 328 (744) */
/* 418 */	NdrFcLong( 0x2 ),	/* 2 */
/* 422 */	NdrFcShort( 0x160 ),	/* Offset= 352 (774) */
/* 424 */	NdrFcLong( 0x3 ),	/* 3 */
/* 428 */	NdrFcShort( 0x178 ),	/* Offset= 376 (804) */
/* 430 */	NdrFcLong( 0x14 ),	/* 20 */
/* 434 */	NdrFcShort( 0x190 ),	/* Offset= 400 (834) */
/* 436 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (435) */
/* 438 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 440 */	NdrFcShort( 0x4 ),	/* 4 */
/* 442 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 444 */	NdrFcShort( 0x0 ),	/* 0 */
/* 446 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 448 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 450 */	NdrFcShort( 0x4 ),	/* 4 */
/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 454 */	NdrFcShort( 0x1 ),	/* 1 */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	0x12, 0x0,	/* FC_UP */
/* 462 */	NdrFcShort( 0xfffffe42 ),	/* Offset= -446 (16) */
/* 464 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 466 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 468 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 472 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 474 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 476 */	NdrFcShort( 0x4 ),	/* 4 */
/* 478 */	NdrFcShort( 0x4 ),	/* 4 */
/* 480 */	0x11, 0x0,	/* FC_RP */
/* 482 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (438) */
/* 484 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 486 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 488 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 496 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xffffff50 ),	/* Offset= -176 (326) */
/* 504 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 506 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x6 ),	/* Offset= 6 (518) */
/* 514 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 516 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 518 */	
			0x11, 0x0,	/* FC_RP */
/* 520 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (488) */
/* 522 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff40 ),	/* Offset= -192 (344) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x8 ),	/* 8 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x6 ),	/* Offset= 6 (552) */
/* 548 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 550 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (522) */
/* 556 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 558 */	NdrFcShort( 0x4 ),	/* 4 */
/* 560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 566 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 568 */	NdrFcShort( 0x4 ),	/* 4 */
/* 570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 572 */	NdrFcShort( 0x1 ),	/* 1 */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 578 */	0x12, 0x0,	/* FC_UP */
/* 580 */	NdrFcShort( 0x182 ),	/* Offset= 386 (966) */
/* 582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 584 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 586 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 592 */	NdrFcShort( 0x6 ),	/* Offset= 6 (598) */
/* 594 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 596 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 598 */	
			0x11, 0x0,	/* FC_RP */
/* 600 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (556) */
/* 602 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 604 */	NdrFcLong( 0x2f ),	/* 47 */
/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 612 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 614 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 616 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 618 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 620 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 622 */	NdrFcShort( 0x1 ),	/* 1 */
/* 624 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 626 */	NdrFcShort( 0x4 ),	/* 4 */
/* 628 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 630 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x10 ),	/* 16 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	NdrFcShort( 0xa ),	/* Offset= 10 (646) */
/* 638 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 640 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 642 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (602) */
/* 644 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 646 */	
			0x12, 0x0,	/* FC_UP */
/* 648 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (620) */
/* 650 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 652 */	NdrFcShort( 0x4 ),	/* 4 */
/* 654 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 656 */	NdrFcShort( 0x0 ),	/* 0 */
/* 658 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 660 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 662 */	NdrFcShort( 0x4 ),	/* 4 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0x1 ),	/* 1 */
/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 672 */	0x12, 0x0,	/* FC_UP */
/* 674 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (630) */
/* 676 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 678 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 680 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 682 */	NdrFcShort( 0x8 ),	/* 8 */
/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 686 */	NdrFcShort( 0x6 ),	/* Offset= 6 (692) */
/* 688 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 690 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 692 */	
			0x11, 0x0,	/* FC_RP */
/* 694 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (650) */
/* 696 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 698 */	NdrFcShort( 0x8 ),	/* 8 */
/* 700 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 702 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 704 */	NdrFcShort( 0x10 ),	/* 16 */
/* 706 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 708 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 710 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (696) */
			0x5b,		/* FC_END */
/* 714 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 716 */	NdrFcShort( 0x18 ),	/* 24 */
/* 718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 720 */	NdrFcShort( 0xa ),	/* Offset= 10 (730) */
/* 722 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 724 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 726 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (702) */
/* 728 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 730 */	
			0x11, 0x0,	/* FC_RP */
/* 732 */	NdrFcShort( 0xffffff0c ),	/* Offset= -244 (488) */
/* 734 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 736 */	NdrFcShort( 0x1 ),	/* 1 */
/* 738 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 744 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 746 */	NdrFcShort( 0x8 ),	/* 8 */
/* 748 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 750 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 752 */	NdrFcShort( 0x4 ),	/* 4 */
/* 754 */	NdrFcShort( 0x4 ),	/* 4 */
/* 756 */	0x12, 0x0,	/* FC_UP */
/* 758 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (734) */
/* 760 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 762 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 764 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 766 */	NdrFcShort( 0x2 ),	/* 2 */
/* 768 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 772 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 774 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 776 */	NdrFcShort( 0x8 ),	/* 8 */
/* 778 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 780 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 782 */	NdrFcShort( 0x4 ),	/* 4 */
/* 784 */	NdrFcShort( 0x4 ),	/* 4 */
/* 786 */	0x12, 0x0,	/* FC_UP */
/* 788 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (764) */
/* 790 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 792 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 794 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 796 */	NdrFcShort( 0x4 ),	/* 4 */
/* 798 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 804 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 806 */	NdrFcShort( 0x8 ),	/* 8 */
/* 808 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 810 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 812 */	NdrFcShort( 0x4 ),	/* 4 */
/* 814 */	NdrFcShort( 0x4 ),	/* 4 */
/* 816 */	0x12, 0x0,	/* FC_UP */
/* 818 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (794) */
/* 820 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 822 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 824 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 826 */	NdrFcShort( 0x8 ),	/* 8 */
/* 828 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 832 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 834 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 836 */	NdrFcShort( 0x8 ),	/* 8 */
/* 838 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 840 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 842 */	NdrFcShort( 0x4 ),	/* 4 */
/* 844 */	NdrFcShort( 0x4 ),	/* 4 */
/* 846 */	0x12, 0x0,	/* FC_UP */
/* 848 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (824) */
/* 850 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 852 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 854 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 858 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 860 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 862 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 864 */	NdrFcShort( 0x8 ),	/* 8 */
/* 866 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 868 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 870 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 872 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (854) */
/* 874 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 876 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 878 */	NdrFcShort( 0x28 ),	/* 40 */
/* 880 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (862) */
/* 882 */	NdrFcShort( 0x0 ),	/* Offset= 0 (882) */
/* 884 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 886 */	0x38,		/* FC_ALIGNM4 */
			0x8,		/* FC_LONG */
/* 888 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 890 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdf7 ),	/* Offset= -521 (370) */
			0x5b,		/* FC_END */
/* 894 */	
			0x12, 0x0,	/* FC_UP */
/* 896 */	NdrFcShort( 0xfffffef6 ),	/* Offset= -266 (630) */
/* 898 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 900 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 902 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 904 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 906 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 908 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 910 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 912 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 914 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 916 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 918 */	
			0x12, 0x0,	/* FC_UP */
/* 920 */	NdrFcShort( 0xfffffda8 ),	/* Offset= -600 (320) */
/* 922 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 924 */	NdrFcShort( 0xfffffc66 ),	/* Offset= -922 (2) */
/* 926 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 928 */	NdrFcShort( 0xfffffda6 ),	/* Offset= -602 (326) */
/* 930 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 932 */	NdrFcShort( 0xfffffdb4 ),	/* Offset= -588 (344) */
/* 934 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 936 */	NdrFcShort( 0xfffffdc2 ),	/* Offset= -574 (362) */
/* 938 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 940 */	NdrFcShort( 0x2 ),	/* Offset= 2 (942) */
/* 942 */	
			0x12, 0x0,	/* FC_UP */
/* 944 */	NdrFcShort( 0x16 ),	/* Offset= 22 (966) */
/* 946 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 948 */	NdrFcShort( 0x10 ),	/* 16 */
/* 950 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 952 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 954 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 956 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 958 */	
			0x12, 0x0,	/* FC_UP */
/* 960 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (946) */
/* 962 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 964 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 966 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 968 */	NdrFcShort( 0x20 ),	/* 32 */
/* 970 */	NdrFcShort( 0x0 ),	/* 0 */
/* 972 */	NdrFcShort( 0x0 ),	/* Offset= 0 (972) */
/* 974 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 976 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 978 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 980 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 982 */	NdrFcShort( 0xfffffc5a ),	/* Offset= -934 (48) */
/* 984 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 986 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 988 */	NdrFcShort( 0x1 ),	/* 1 */
/* 990 */	NdrFcShort( 0x10 ),	/* 16 */
/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
/* 994 */	NdrFcShort( 0xfffffc4a ),	/* Offset= -950 (44) */
/* 996 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 998 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1000 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0xfffffd7e ),	/* Offset= -642 (362) */
/* 1006 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1008 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1014) */
/* 1010 */	
			0x13, 0x0,	/* FC_OP */
/* 1012 */	NdrFcShort( 0xfffffc1c ),	/* Offset= -996 (16) */
/* 1014 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1016 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1018 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1020 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1022 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1010) */
/* 1024 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1026 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1028) */
/* 1028 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1030 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1032 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1034 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1036) */
/* 1036 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1038 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 1040 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1042 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1048) */
/* 1044 */	
			0x13, 0x0,	/* FC_OP */
/* 1046 */	NdrFcShort( 0xffffffb0 ),	/* Offset= -80 (966) */
/* 1048 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1050 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1052 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1044) */
/* 1058 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1060 */	NdrFcShort( 0xfffffd22 ),	/* Offset= -734 (326) */
/* 1062 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1064 */	NdrFcShort( 0xfffffd30 ),	/* Offset= -720 (344) */
/* 1066 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1068 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (946) */
/* 1070 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1072 */	NdrFcShort( 0xa ),	/* Offset= 10 (1082) */
/* 1074 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1076 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1078) */
/* 1078 */	
			0x13, 0x0,	/* FC_OP */
/* 1080 */	NdrFcShort( 0xffffff34 ),	/* Offset= -204 (876) */
/* 1082 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1084 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1086 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1090 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (1074) */
/* 1092 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1094 */	NdrFcLong( 0xc ),	/* 12 */
/* 1098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1102 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1104 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1106 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1108 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1110 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1112 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1092) */
/* 1114 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1116 */	NdrFcLong( 0xb ),	/* 11 */
/* 1120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1126 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1128 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1130 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1132 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1134 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1114) */
/* 1136 */	
			0x12, 0x0,	/* FC_UP */
/* 1138 */	NdrFcShort( 0xfffffee4 ),	/* Offset= -284 (854) */
/* 1140 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1142 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1144 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1148 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1150 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1152 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1154 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1156 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1158 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1160 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1162 */	0x12, 0x0,	/* FC_UP */
/* 1164 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1140) */
/* 1166 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1168 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1170 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1172 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1174 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1178 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 1180 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1182 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1184 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1186 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1188 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1190 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1192 */	0x12, 0x0,	/* FC_UP */
/* 1194 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1170) */
/* 1196 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1198 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1200 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1202 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1204 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1208 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1210 */	NdrFcShort( 0xfffffc86 ),	/* Offset= -890 (320) */
/* 1212 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1214 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1216 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1218 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1220 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1222 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1224 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1226 */	0x12, 0x0,	/* FC_UP */
/* 1228 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1200) */
/* 1230 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1232 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1234 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1238 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1242 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 1244 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1246 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1248 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1250 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1252 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1254 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1256 */	0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1234) */
/* 1260 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1262 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1264 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1266 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1268 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1272 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1274 */	NdrFcShort( 0xfffffe5c ),	/* Offset= -420 (854) */
/* 1276 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1278 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1280 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1282 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1284 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1286 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1288 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1290 */	0x12, 0x0,	/* FC_UP */
/* 1292 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1264) */
/* 1294 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1296 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1298 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1300 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1302 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1304 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1306 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1308 */	NdrFcShort( 0xfffffda2 ),	/* Offset= -606 (702) */
/* 1310 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1312 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1314 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1316 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1318 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1320 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1322 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1324 */	0x12, 0x0,	/* FC_UP */
/* 1326 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1298) */
/* 1328 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1330 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1332 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1334 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1336 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 1338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1340 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1342 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1344 */	NdrFcShort( 0xc ),	/* 12 */
/* 1346 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1348 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1350 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1354 */	0x12, 0x0,	/* FC_UP */
/* 1356 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1332) */
/* 1358 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1360 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1362 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1364 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1366 */	NdrFcShort( 0xc ),	/* 12 */
/* 1368 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1372 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1374 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1376 */	NdrFcShort( 0xc ),	/* 12 */
/* 1378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1380 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1382 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1384 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1386 */	0x12, 0x0,	/* FC_UP */
/* 1388 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (1332) */
/* 1390 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1392 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffcd ),	/* Offset= -51 (1342) */
			0x5b,		/* FC_END */
/* 1396 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1398 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1400 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1402 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1404 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1406 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1408 */	0x12, 0x0,	/* FC_UP */
/* 1410 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1364) */
/* 1412 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1414 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1416 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1420 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1424 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1428 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1430 */	NdrFcShort( 0xfffffa84 ),	/* Offset= -1404 (26) */
/* 1432 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1434 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1436 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1438 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1440 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1442 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1444 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1446 */	0x12, 0x0,	/* FC_UP */
/* 1448 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1416) */
/* 1450 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1452 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1454 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1456 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1458 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1462 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1464 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1466 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1472 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1474 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1476 */	0x12, 0x0,	/* FC_UP */
/* 1478 */	NdrFcShort( 0xfffffd18 ),	/* Offset= -744 (734) */
/* 1480 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1482 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd1d ),	/* Offset= -739 (744) */
			0x5b,		/* FC_END */
/* 1486 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1488 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1490 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1492 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1494 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1496 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1498 */	0x12, 0x0,	/* FC_UP */
/* 1500 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1454) */
/* 1502 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1504 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1506 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1508 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1510 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1514 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1516 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1518 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1522 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1528 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1530 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 1532 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1534 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1536 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1540 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1542 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1544 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1546 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1548 */	0x12, 0x0,	/* FC_UP */
/* 1550 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (1506) */
/* 1552 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1554 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1556 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1558 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1564 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1566 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1568 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1572 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1578 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1580 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1584 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1586 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1590 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1592 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1594 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1596 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1598 */	0x12, 0x0,	/* FC_UP */
/* 1600 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (1556) */
/* 1602 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1604 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1606 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 1608 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1610 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1612 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1614) */
/* 1614 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1616 */	NdrFcShort( 0x61 ),	/* 97 */
/* 1618 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1622 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1622) */
/* 1624 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1628 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1628) */
/* 1630 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1634 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1636 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1640 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1642 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1646 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1648 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1652 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1654 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1658 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1660 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1664 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1666 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1670 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1672 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1676 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1678 */	NdrFcLong( 0xe ),	/* 14 */
/* 1682 */	NdrFcShort( 0xfffffaae ),	/* Offset= -1362 (320) */
/* 1684 */	NdrFcLong( 0x14 ),	/* 20 */
/* 1688 */	NdrFcShort( 0xfffffaa8 ),	/* Offset= -1368 (320) */
/* 1690 */	NdrFcLong( 0x15 ),	/* 21 */
/* 1694 */	NdrFcShort( 0xfffffaa2 ),	/* Offset= -1374 (320) */
/* 1696 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1700 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1702 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1706 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1708 */	NdrFcLong( 0xb ),	/* 11 */
/* 1712 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1714 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 1718 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1720 */	NdrFcLong( 0xa ),	/* 10 */
/* 1724 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1726 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1730 */	NdrFcShort( 0xfffffa7e ),	/* Offset= -1410 (320) */
/* 1732 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1736 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1738 */	NdrFcLong( 0x40 ),	/* 64 */
/* 1742 */	NdrFcShort( 0xfffffc88 ),	/* Offset= -888 (854) */
/* 1744 */	NdrFcLong( 0x48 ),	/* 72 */
/* 1748 */	NdrFcShort( 0x1c6 ),	/* Offset= 454 (2202) */
/* 1750 */	NdrFcLong( 0x47 ),	/* 71 */
/* 1754 */	NdrFcShort( 0x1c4 ),	/* Offset= 452 (2206) */
/* 1756 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1760 */	NdrFcShort( 0xfffff93a ),	/* Offset= -1734 (26) */
/* 1762 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 1766 */	NdrFcShort( 0xfffffc02 ),	/* Offset= -1022 (744) */
/* 1768 */	NdrFcLong( 0x41 ),	/* 65 */
/* 1772 */	NdrFcShort( 0xfffffbfc ),	/* Offset= -1028 (744) */
/* 1774 */	NdrFcLong( 0x46 ),	/* 70 */
/* 1778 */	NdrFcShort( 0xfffffbf6 ),	/* Offset= -1034 (744) */
/* 1780 */	NdrFcLong( 0x1e ),	/* 30 */
/* 1784 */	NdrFcShort( 0x1aa ),	/* Offset= 426 (2210) */
/* 1786 */	NdrFcLong( 0x1f ),	/* 31 */
/* 1790 */	NdrFcShort( 0x1a8 ),	/* Offset= 424 (2214) */
/* 1792 */	NdrFcLong( 0xd ),	/* 13 */
/* 1796 */	NdrFcShort( 0xfffffa42 ),	/* Offset= -1470 (326) */
/* 1798 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1802 */	NdrFcShort( 0xfffffa4e ),	/* Offset= -1458 (344) */
/* 1804 */	NdrFcLong( 0x42 ),	/* 66 */
/* 1808 */	NdrFcShort( 0xfffffd34 ),	/* Offset= -716 (1092) */
/* 1810 */	NdrFcLong( 0x44 ),	/* 68 */
/* 1814 */	NdrFcShort( 0xfffffd2e ),	/* Offset= -722 (1092) */
/* 1816 */	NdrFcLong( 0x43 ),	/* 67 */
/* 1820 */	NdrFcShort( 0xfffffd3e ),	/* Offset= -706 (1114) */
/* 1822 */	NdrFcLong( 0x45 ),	/* 69 */
/* 1826 */	NdrFcShort( 0xfffffd38 ),	/* Offset= -712 (1114) */
/* 1828 */	NdrFcLong( 0x49 ),	/* 73 */
/* 1832 */	NdrFcShort( 0x182 ),	/* Offset= 386 (2218) */
/* 1834 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 1838 */	NdrFcShort( 0xfffffcb6 ),	/* Offset= -842 (996) */
/* 1840 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 1844 */	NdrFcShort( 0xfffffcb0 ),	/* Offset= -848 (996) */
/* 1846 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 1850 */	NdrFcShort( 0xfffffcaa ),	/* Offset= -854 (996) */
/* 1852 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 1856 */	NdrFcShort( 0xfffffca4 ),	/* Offset= -860 (996) */
/* 1858 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 1862 */	NdrFcShort( 0xfffffc9e ),	/* Offset= -866 (996) */
/* 1864 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 1868 */	NdrFcShort( 0xfffffc98 ),	/* Offset= -872 (996) */
/* 1870 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 1874 */	NdrFcShort( 0xfffffc92 ),	/* Offset= -878 (996) */
/* 1876 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 1880 */	NdrFcShort( 0xfffffc8c ),	/* Offset= -884 (996) */
/* 1882 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 1886 */	NdrFcShort( 0xfffffc86 ),	/* Offset= -890 (996) */
/* 1888 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 1892 */	NdrFcShort( 0xfffffc80 ),	/* Offset= -896 (996) */
/* 1894 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 1898 */	NdrFcShort( 0xfffffc7a ),	/* Offset= -902 (996) */
/* 1900 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 1904 */	NdrFcShort( 0xfffffc74 ),	/* Offset= -908 (996) */
/* 1906 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 1910 */	NdrFcShort( 0xfffffc6e ),	/* Offset= -914 (996) */
/* 1912 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 1916 */	NdrFcShort( 0xfffffc68 ),	/* Offset= -920 (996) */
/* 1918 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 1922 */	NdrFcShort( 0xfffffc62 ),	/* Offset= -926 (996) */
/* 1924 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 1928 */	NdrFcShort( 0xfffffc5c ),	/* Offset= -932 (996) */
/* 1930 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 1934 */	NdrFcShort( 0xfffffc56 ),	/* Offset= -938 (996) */
/* 1936 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 1940 */	NdrFcShort( 0xfffffc50 ),	/* Offset= -944 (996) */
/* 1942 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 1946 */	NdrFcShort( 0xfffffc4a ),	/* Offset= -950 (996) */
/* 1948 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 1952 */	NdrFcShort( 0xfffffcde ),	/* Offset= -802 (1150) */
/* 1954 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 1958 */	NdrFcShort( 0xfffffcd8 ),	/* Offset= -808 (1150) */
/* 1960 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 1964 */	NdrFcShort( 0xfffffb5a ),	/* Offset= -1190 (774) */
/* 1966 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 1970 */	NdrFcShort( 0xfffffb54 ),	/* Offset= -1196 (774) */
/* 1972 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 1976 */	NdrFcShort( 0xfffffb6c ),	/* Offset= -1172 (804) */
/* 1978 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 1982 */	NdrFcShort( 0xfffffb66 ),	/* Offset= -1178 (804) */
/* 1984 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 1988 */	NdrFcShort( 0xfffffcfa ),	/* Offset= -774 (1214) */
/* 1990 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 1994 */	NdrFcShort( 0xfffffcf4 ),	/* Offset= -780 (1214) */
/* 1996 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 2000 */	NdrFcShort( 0xfffffccc ),	/* Offset= -820 (1180) */
/* 2002 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 2006 */	NdrFcShort( 0xfffffd06 ),	/* Offset= -762 (1244) */
/* 2008 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 2012 */	NdrFcShort( 0xfffffb2a ),	/* Offset= -1238 (774) */
/* 2014 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 2018 */	NdrFcShort( 0xfffffb42 ),	/* Offset= -1214 (804) */
/* 2020 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 2024 */	NdrFcShort( 0xfffffcd6 ),	/* Offset= -810 (1214) */
/* 2026 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 2030 */	NdrFcShort( 0xfffffcee ),	/* Offset= -786 (1244) */
/* 2032 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 2036 */	NdrFcShort( 0xfffffd0a ),	/* Offset= -758 (1278) */
/* 2038 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 2042 */	NdrFcShort( 0xfffffd26 ),	/* Offset= -730 (1312) */
/* 2044 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 2048 */	NdrFcShort( 0xfffffd74 ),	/* Offset= -652 (1396) */
/* 2050 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 2054 */	NdrFcShort( 0xfffffd94 ),	/* Offset= -620 (1434) */
/* 2056 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 2060 */	NdrFcShort( 0xfffffdc2 ),	/* Offset= -574 (1486) */
/* 2062 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 2066 */	NdrFcShort( 0xfffffdee ),	/* Offset= -530 (1536) */
/* 2068 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 2072 */	NdrFcShort( 0xfffffe1a ),	/* Offset= -486 (1586) */
/* 2074 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 2078 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (2288) */
/* 2080 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 2084 */	NdrFcShort( 0xfffffb9e ),	/* Offset= -1122 (962) */
/* 2086 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 2090 */	NdrFcShort( 0xfffffb98 ),	/* Offset= -1128 (962) */
/* 2092 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 2096 */	NdrFcShort( 0xfffffb56 ),	/* Offset= -1194 (902) */
/* 2098 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 2102 */	NdrFcShort( 0xfffffb50 ),	/* Offset= -1200 (902) */
/* 2104 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 2108 */	NdrFcShort( 0xfffffb4e ),	/* Offset= -1202 (906) */
/* 2110 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 2114 */	NdrFcShort( 0xfffffb48 ),	/* Offset= -1208 (906) */
/* 2116 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 2120 */	NdrFcShort( 0xfffffb42 ),	/* Offset= -1214 (906) */
/* 2122 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 2126 */	NdrFcShort( 0xfffffb3c ),	/* Offset= -1220 (906) */
/* 2128 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 2132 */	NdrFcShort( 0xfffffb3a ),	/* Offset= -1222 (910) */
/* 2134 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 2138 */	NdrFcShort( 0xfffffb38 ),	/* Offset= -1224 (914) */
/* 2140 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 2144 */	NdrFcShort( 0xfffffb26 ),	/* Offset= -1242 (902) */
/* 2146 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 2150 */	NdrFcShort( 0xfffffb58 ),	/* Offset= -1192 (958) */
/* 2152 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 2156 */	NdrFcShort( 0xfffffb1e ),	/* Offset= -1250 (906) */
/* 2158 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 2162 */	NdrFcShort( 0xfffffb24 ),	/* Offset= -1244 (918) */
/* 2164 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 2168 */	NdrFcShort( 0xfffffb1a ),	/* Offset= -1254 (914) */
/* 2170 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 2174 */	NdrFcShort( 0x42 ),	/* Offset= 66 (2240) */
/* 2176 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 2180 */	NdrFcShort( 0xfffffb1a ),	/* Offset= -1254 (926) */
/* 2182 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 2186 */	NdrFcShort( 0xfffffb18 ),	/* Offset= -1256 (930) */
/* 2188 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 2192 */	NdrFcShort( 0x34 ),	/* Offset= 52 (2244) */
/* 2194 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 2198 */	NdrFcShort( 0x32 ),	/* Offset= 50 (2248) */
/* 2200 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (2199) */
/* 2202 */	
			0x12, 0x0,	/* FC_UP */
/* 2204 */	NdrFcShort( 0xfffffa22 ),	/* Offset= -1502 (702) */
/* 2206 */	
			0x12, 0x0,	/* FC_UP */
/* 2208 */	NdrFcShort( 0xfffffc9e ),	/* Offset= -866 (1342) */
/* 2210 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2212 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2214 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2216 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2218 */	
			0x12, 0x0,	/* FC_UP */
/* 2220 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2222) */
/* 2222 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2224 */	NdrFcShort( 0x14 ),	/* 20 */
/* 2226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2228 */	NdrFcShort( 0xc ),	/* Offset= 12 (2240) */
/* 2230 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2232 */	NdrFcShort( 0xfffffa06 ),	/* Offset= -1530 (702) */
/* 2234 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2236 */	NdrFcShort( 0xfffffb88 ),	/* Offset= -1144 (1092) */
/* 2238 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2240 */	
			0x12, 0x0,	/* FC_UP */
/* 2242 */	NdrFcShort( 0xfffff758 ),	/* Offset= -2216 (26) */
/* 2244 */	
			0x12, 0x0,	/* FC_UP */
/* 2246 */	NdrFcShort( 0xfffffb1e ),	/* Offset= -1250 (996) */
/* 2248 */	
			0x12, 0x0,	/* FC_UP */
/* 2250 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2252) */
/* 2252 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2254 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2258 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2258) */
/* 2260 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2262 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 2264 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2266 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd6b ),	/* Offset= -661 (1606) */
			0x5b,		/* FC_END */
/* 2270 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2274 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2278 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2282 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2284 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2252) */
/* 2286 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2288 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2290 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2294 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2300) */
/* 2296 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 2298 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2300 */	
			0x12, 0x0,	/* FC_UP */
/* 2302 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2270) */
/* 2304 */	
			0x12, 0x0,	/* FC_UP */
/* 2306 */	NdrFcShort( 0xfffffb7c ),	/* Offset= -1156 (1150) */
/* 2308 */	
			0x12, 0x0,	/* FC_UP */
/* 2310 */	NdrFcShort( 0xfffffa00 ),	/* Offset= -1536 (774) */
/* 2312 */	
			0x12, 0x0,	/* FC_UP */
/* 2314 */	NdrFcShort( 0xfffffa1a ),	/* Offset= -1510 (804) */
/* 2316 */	
			0x12, 0x0,	/* FC_UP */
/* 2318 */	NdrFcShort( 0xfffffb8e ),	/* Offset= -1138 (1180) */
/* 2320 */	
			0x12, 0x0,	/* FC_UP */
/* 2322 */	NdrFcShort( 0xfffffbac ),	/* Offset= -1108 (1214) */
/* 2324 */	
			0x12, 0x0,	/* FC_UP */
/* 2326 */	NdrFcShort( 0xfffffbc6 ),	/* Offset= -1082 (1244) */
/* 2328 */	
			0x12, 0x0,	/* FC_UP */
/* 2330 */	NdrFcShort( 0xfffffbe4 ),	/* Offset= -1052 (1278) */
/* 2332 */	
			0x12, 0x0,	/* FC_UP */
/* 2334 */	NdrFcShort( 0xfffffc02 ),	/* Offset= -1022 (1312) */
/* 2336 */	
			0x12, 0x0,	/* FC_UP */
/* 2338 */	NdrFcShort( 0xfffffc52 ),	/* Offset= -942 (1396) */
/* 2340 */	
			0x12, 0x0,	/* FC_UP */
/* 2342 */	NdrFcShort( 0xfffffc74 ),	/* Offset= -908 (1434) */
/* 2344 */	
			0x12, 0x0,	/* FC_UP */
/* 2346 */	NdrFcShort( 0xfffffca4 ),	/* Offset= -860 (1486) */
/* 2348 */	
			0x12, 0x0,	/* FC_UP */
/* 2350 */	NdrFcShort( 0xfffffcd2 ),	/* Offset= -814 (1536) */
/* 2352 */	
			0x12, 0x0,	/* FC_UP */
/* 2354 */	NdrFcShort( 0xfffffd00 ),	/* Offset= -768 (1586) */
/* 2356 */	
			0x12, 0x0,	/* FC_UP */
/* 2358 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (2288) */

			0x0, 0x0, 0x0, 0x0
        }
    };


#else // __RPC_WIN64__

#define BSTR_TYPE_FS_OFFSET 28              //bstr
#define LPWSTR_TYPE_FS_OFFSET 40            // lpwstr
#define LPSTR_TYPE_FS_OFFSET 44             // lpstr
#define EMBEDDED_LPWSTR_TYPE_FS_OFFSET 1010 // lpwstr
#define EMBEDDED_LPSTR_TYPE_FS_OFFSET 1018  // lpstr
#define VARIANT_TYPE_FS_OFFSET 968          // variant
#define DISPATCH_TYPE_FS_OFFSET 348         // pdispatch
#define UNKNOWN_TYPE_FS_OFFSET 330          // punk
#define DECIMAL_TYPE_FS_OFFSET 928          // decimal
#define SAFEARRAY_TYPE_FS_OFFSET 978        // pSafeArray


#define BYREF_BSTR_TYPE_FS_OFFSET 996       //pBSTR
#define BYREF_LPWSTR_TYPE_FS_OFFSET 1006    // ppwsz
#define BYREF_LPSTR_TYPE_FS_OFFSET 1014     // ppsz
#define BYREF_VARIANT_TYPE_FS_OFFSET 1030   // pVariant
#define BYREF_UNKNOWN_TYPE_FS_OFFSET 1040   // ppunk
#define BYREF_DISPATCH_TYPE_FS_OFFSET 1044  // ppdistatch
#define BYREF_DECIMAL_TYPE_FS_OFFSET 940    // pDecimal
#define BYREF_SAFEARRAY_TYPE_FS_OFFSET 1064 // ppSafeArray

#define STREAM_TYPE_FS_OFFSET 1074          // pStream
#define BYREF_STREAM_TYPE_FS_OFFSET 1092    // ppStream
#define STORAGE_TYPE_FS_OFFSET 1096         // pStorage
#define BYREF_STORAGE_TYPE_FS_OFFSET 1114   // ppStorage
#define FILETIME_TYPE_FS_OFFSET 834         // FileTime
#define BYREF_FILETIME_TYPE_FS_OFFSET 1118  // pfileTime


#define BYREF_I1_TYPE_FS_OFFSET 880
#define BYREF_I2_TYPE_FS_OFFSET 884
#define BYREF_I4_TYPE_FS_OFFSET 888
#define BYREF_R4_TYPE_FS_OFFSET 892
#define BYREF_R8_TYPE_FS_OFFSET 896

#define I1_VECTOR_TYPE_FS_OFFSET 1134       // cab
#define I2_VECTOR_TYPE_FS_OFFSET 1166       // cai
#define I4_VECTOR_TYPE_FS_OFFSET 1214       // cal
#define R4_VECTOR_TYPE_FS_OFFSET 1258       // caflt
#define ERROR_VECTOR_TYPE_FS_OFFSET 1274            // cascode
#define I8_VECTOR_TYPE_FS_OFFSET 1306               // cah
#define R8_VECTOR_TYPE_FS_OFFSET 1350       // cadbl
#define CY_VECTOR_TYPE_FS_OFFSET 1366       // cacy
#define DATE_VECTOR_TYPE_FS_OFFSET 1382             // cadate
#define FILETIME_VECTOR_TYPE_FS_OFFSET 1414         // cafiletime
#define BSTR_VECTOR_TYPE_FS_OFFSET 1552             // cabstr
#define BSTRBLOB_VECTOR_TYPE_FS_OFFSET 1606         // cabstrblob
#define LPSTR_VECTOR_TYPE_FS_OFFSET 1644            // calpstr
#define LPWSTR_VECTOR_TYPE_FS_OFFSET 1682           // calpwstr


#define BYREF_I1_VECTOR_TYPE_FS_OFFSET 2418 // pcab
#define BYREF_I2_VECTOR_TYPE_FS_OFFSET 2426 // pcai
#define BYREF_I4_VECTOR_TYPE_FS_OFFSET 2438 // pcal
#define BYREF_R4_VECTOR_TYPE_FS_OFFSET 2446 // pcaflt
#define BYREF_ERROR_VECTOR_TYPE_FS_OFFSET 2450      // pcascode
#define BYREF_I8_VECTOR_TYPE_FS_OFFSET 2454         // pcah
#define BYREF_R8_VECTOR_TYPE_FS_OFFSET 2462 // pcadbl
#define BYREF_CY_VECTOR_TYPE_FS_OFFSET 2466 // pcacy
#define BYREF_DATE_VECTOR_TYPE_FS_OFFSET 2470       // pcadate
#define BYREF_FILETIME_VECTOR_TYPE_FS_OFFSET 2474   // pcafiletime
#define BYREF_BSTR_VECTOR_TYPE_FS_OFFSET 2486       // pcabstr
#define BYREF_BSTRBLOB_VECTOR_TYPE_FS_OFFSET 2490   // pcabstrblob
#define BYREF_LPSTR_VECTOR_TYPE_FS_OFFSET 2494      // pcalpstr
#define BYREF_LPWSTR_VECTOR_TYPE_FS_OFFSET 2498     // pcalpwstr




 /* File created by MIDL compiler version 5.03.0276 */
/* at Mon Jul 05 13:57:41 1999
 */
/* Compiler settings for oandr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xe ),	/* Offset= 14 (18) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 18 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 20 */	NdrFcShort( 0x8 ),	/* 8 */
/* 22 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (6) */
/* 24 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 26 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 28 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x8 ),	/* 8 */
/* 34 */	NdrFcShort( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (2) */
/* 38 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 40 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 42 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 44 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 46 */	
			0x12, 0x0,	/* FC_UP */
/* 48 */	NdrFcShort( 0x384 ),	/* Offset= 900 (948) */
/* 50 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 52 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 54 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 56 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 58 */	NdrFcShort( 0x2 ),	/* Offset= 2 (60) */
/* 60 */	NdrFcShort( 0x10 ),	/* 16 */
/* 62 */	NdrFcShort( 0x2b ),	/* 43 */
/* 64 */	NdrFcLong( 0x3 ),	/* 3 */
/* 68 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 70 */	NdrFcLong( 0x11 ),	/* 17 */
/* 74 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 76 */	NdrFcLong( 0x2 ),	/* 2 */
/* 80 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 82 */	NdrFcLong( 0x4 ),	/* 4 */
/* 86 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 88 */	NdrFcLong( 0x5 ),	/* 5 */
/* 92 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 94 */	NdrFcLong( 0xb ),	/* 11 */
/* 98 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 100 */	NdrFcLong( 0xa ),	/* 10 */
/* 104 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 106 */	NdrFcLong( 0x6 ),	/* 6 */
/* 110 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (324) */
/* 112 */	NdrFcLong( 0x7 ),	/* 7 */
/* 116 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 118 */	NdrFcLong( 0x8 ),	/* 8 */
/* 122 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (2) */
/* 124 */	NdrFcLong( 0xd ),	/* 13 */
/* 128 */	NdrFcShort( 0xca ),	/* Offset= 202 (330) */
/* 130 */	NdrFcLong( 0x9 ),	/* 9 */
/* 134 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (348) */
/* 136 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 140 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (366) */
/* 142 */	NdrFcLong( 0x24 ),	/* 36 */
/* 146 */	NdrFcShort( 0x2da ),	/* Offset= 730 (876) */
/* 148 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 152 */	NdrFcShort( 0x2d4 ),	/* Offset= 724 (876) */
/* 154 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 158 */	NdrFcShort( 0x2d2 ),	/* Offset= 722 (880) */
/* 160 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 164 */	NdrFcShort( 0x2d0 ),	/* Offset= 720 (884) */
/* 166 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 170 */	NdrFcShort( 0x2ce ),	/* Offset= 718 (888) */
/* 172 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 176 */	NdrFcShort( 0x2cc ),	/* Offset= 716 (892) */
/* 178 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 182 */	NdrFcShort( 0x2ca ),	/* Offset= 714 (896) */
/* 184 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 188 */	NdrFcShort( 0x2b8 ),	/* Offset= 696 (884) */
/* 190 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 194 */	NdrFcShort( 0x2b6 ),	/* Offset= 694 (888) */
/* 196 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 200 */	NdrFcShort( 0x2bc ),	/* Offset= 700 (900) */
/* 202 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 206 */	NdrFcShort( 0x2b2 ),	/* Offset= 690 (896) */
/* 208 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 212 */	NdrFcShort( 0x2b4 ),	/* Offset= 692 (904) */
/* 214 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 218 */	NdrFcShort( 0x2b2 ),	/* Offset= 690 (908) */
/* 220 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 224 */	NdrFcShort( 0x2b0 ),	/* Offset= 688 (912) */
/* 226 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 230 */	NdrFcShort( 0x2ae ),	/* Offset= 686 (916) */
/* 232 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 236 */	NdrFcShort( 0x2ac ),	/* Offset= 684 (920) */
/* 238 */	NdrFcLong( 0x10 ),	/* 16 */
/* 242 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 244 */	NdrFcLong( 0x12 ),	/* 18 */
/* 248 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 250 */	NdrFcLong( 0x13 ),	/* 19 */
/* 254 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 256 */	NdrFcLong( 0x16 ),	/* 22 */
/* 260 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 262 */	NdrFcLong( 0x17 ),	/* 23 */
/* 266 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 268 */	NdrFcLong( 0xe ),	/* 14 */
/* 272 */	NdrFcShort( 0x290 ),	/* Offset= 656 (928) */
/* 274 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 278 */	NdrFcShort( 0x296 ),	/* Offset= 662 (940) */
/* 280 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 284 */	NdrFcShort( 0x294 ),	/* Offset= 660 (944) */
/* 286 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 290 */	NdrFcShort( 0x252 ),	/* Offset= 594 (884) */
/* 292 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 296 */	NdrFcShort( 0x250 ),	/* Offset= 592 (888) */
/* 298 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 302 */	NdrFcShort( 0x24a ),	/* Offset= 586 (888) */
/* 304 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 308 */	NdrFcShort( 0x244 ),	/* Offset= 580 (888) */
/* 310 */	NdrFcLong( 0x0 ),	/* 0 */
/* 314 */	NdrFcShort( 0x0 ),	/* Offset= 0 (314) */
/* 316 */	NdrFcLong( 0x1 ),	/* 1 */
/* 320 */	NdrFcShort( 0x0 ),	/* Offset= 0 (320) */
/* 322 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (321) */
/* 324 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 328 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 330 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 342 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 344 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 346 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 348 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 350 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 358 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 360 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 362 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 364 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 366 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 368 */	NdrFcShort( 0x2 ),	/* Offset= 2 (370) */
/* 370 */	
			0x12, 0x0,	/* FC_UP */
/* 372 */	NdrFcShort( 0x1e6 ),	/* Offset= 486 (858) */
/* 374 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 376 */	NdrFcShort( 0x20 ),	/* 32 */
/* 378 */	NdrFcShort( 0xa ),	/* 10 */
/* 380 */	NdrFcLong( 0x8 ),	/* 8 */
/* 384 */	NdrFcShort( 0x50 ),	/* Offset= 80 (464) */
/* 386 */	NdrFcLong( 0xd ),	/* 13 */
/* 390 */	NdrFcShort( 0x70 ),	/* Offset= 112 (502) */
/* 392 */	NdrFcLong( 0x9 ),	/* 9 */
/* 396 */	NdrFcShort( 0x90 ),	/* Offset= 144 (540) */
/* 398 */	NdrFcLong( 0xc ),	/* 12 */
/* 402 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (578) */
/* 404 */	NdrFcLong( 0x24 ),	/* 36 */
/* 408 */	NdrFcShort( 0x104 ),	/* Offset= 260 (668) */
/* 410 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 414 */	NdrFcShort( 0x120 ),	/* Offset= 288 (702) */
/* 416 */	NdrFcLong( 0x10 ),	/* 16 */
/* 420 */	NdrFcShort( 0x13a ),	/* Offset= 314 (734) */
/* 422 */	NdrFcLong( 0x2 ),	/* 2 */
/* 426 */	NdrFcShort( 0x150 ),	/* Offset= 336 (762) */
/* 428 */	NdrFcLong( 0x3 ),	/* 3 */
/* 432 */	NdrFcShort( 0x166 ),	/* Offset= 358 (790) */
/* 434 */	NdrFcLong( 0x14 ),	/* 20 */
/* 438 */	NdrFcShort( 0x17c ),	/* Offset= 380 (818) */
/* 440 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (439) */
/* 442 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 444 */	NdrFcShort( 0x0 ),	/* 0 */
/* 446 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 448 */	NdrFcShort( 0x0 ),	/* 0 */
/* 450 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 452 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 456 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 458 */	
			0x12, 0x0,	/* FC_UP */
/* 460 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (18) */
/* 462 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 464 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 466 */	NdrFcShort( 0x10 ),	/* 16 */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x6 ),	/* Offset= 6 (476) */
/* 472 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 474 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 476 */	
			0x11, 0x0,	/* FC_RP */
/* 478 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (442) */
/* 480 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 484 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
/* 488 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 490 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 494 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 496 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 498 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (330) */
/* 500 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 502 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 504 */	NdrFcShort( 0x10 ),	/* 16 */
/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
/* 508 */	NdrFcShort( 0x6 ),	/* Offset= 6 (514) */
/* 510 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 512 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 514 */	
			0x11, 0x0,	/* FC_RP */
/* 516 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (480) */
/* 518 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 528 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 532 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff44 ),	/* Offset= -188 (348) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x10 ),	/* 16 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x6 ),	/* Offset= 6 (552) */
/* 548 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 550 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (518) */
/* 556 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 566 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 570 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 572 */	
			0x12, 0x0,	/* FC_UP */
/* 574 */	NdrFcShort( 0x176 ),	/* Offset= 374 (948) */
/* 576 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 578 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 580 */	NdrFcShort( 0x10 ),	/* 16 */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x6 ),	/* Offset= 6 (590) */
/* 586 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 588 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 590 */	
			0x11, 0x0,	/* FC_RP */
/* 592 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (556) */
/* 594 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 596 */	NdrFcLong( 0x2f ),	/* 47 */
/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 604 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 606 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 608 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 610 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 612 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 614 */	NdrFcShort( 0x1 ),	/* 1 */
/* 616 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 618 */	NdrFcShort( 0x4 ),	/* 4 */
/* 620 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 622 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 624 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 626 */	NdrFcShort( 0x18 ),	/* 24 */
/* 628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 630 */	NdrFcShort( 0xc ),	/* Offset= 12 (642) */
/* 632 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 634 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 636 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (594) */
/* 638 */	0x39,		/* FC_ALIGNM8 */
			0x36,		/* FC_POINTER */
/* 640 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 642 */	
			0x12, 0x0,	/* FC_UP */
/* 644 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (612) */
/* 646 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 652 */	NdrFcShort( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 656 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 660 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 662 */	
			0x12, 0x0,	/* FC_UP */
/* 664 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (624) */
/* 666 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 668 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 670 */	NdrFcShort( 0x10 ),	/* 16 */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x6 ),	/* Offset= 6 (680) */
/* 676 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 678 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 680 */	
			0x11, 0x0,	/* FC_RP */
/* 682 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (646) */
/* 684 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 688 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 690 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 692 */	NdrFcShort( 0x10 ),	/* 16 */
/* 694 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 696 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 698 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (684) */
			0x5b,		/* FC_END */
/* 702 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 704 */	NdrFcShort( 0x20 ),	/* 32 */
/* 706 */	NdrFcShort( 0x0 ),	/* 0 */
/* 708 */	NdrFcShort( 0xa ),	/* Offset= 10 (718) */
/* 710 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 712 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 714 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffe7 ),	/* Offset= -25 (690) */
			0x5b,		/* FC_END */
/* 718 */	
			0x11, 0x0,	/* FC_RP */
/* 720 */	NdrFcShort( 0xffffff10 ),	/* Offset= -240 (480) */
/* 722 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 724 */	NdrFcShort( 0x1 ),	/* 1 */
/* 726 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 730 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 732 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 734 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 736 */	NdrFcShort( 0x10 ),	/* 16 */
/* 738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 740 */	NdrFcShort( 0x6 ),	/* Offset= 6 (746) */
/* 742 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 744 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 746 */	
			0x12, 0x0,	/* FC_UP */
/* 748 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (722) */
/* 750 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 752 */	NdrFcShort( 0x2 ),	/* 2 */
/* 754 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 758 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 760 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 762 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 764 */	NdrFcShort( 0x10 ),	/* 16 */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 768 */	NdrFcShort( 0x6 ),	/* Offset= 6 (774) */
/* 770 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 772 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 774 */	
			0x12, 0x0,	/* FC_UP */
/* 776 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (750) */
/* 778 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 780 */	NdrFcShort( 0x4 ),	/* 4 */
/* 782 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 786 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 788 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 790 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x10 ),	/* 16 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x6 ),	/* Offset= 6 (802) */
/* 798 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 800 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 802 */	
			0x12, 0x0,	/* FC_UP */
/* 804 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (778) */
/* 806 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 808 */	NdrFcShort( 0x8 ),	/* 8 */
/* 810 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 814 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 816 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 818 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 820 */	NdrFcShort( 0x10 ),	/* 16 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x6 ),	/* Offset= 6 (830) */
/* 826 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 828 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 830 */	
			0x12, 0x0,	/* FC_UP */
/* 832 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (806) */
/* 834 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 836 */	NdrFcShort( 0x8 ),	/* 8 */
/* 838 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 840 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 842 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 844 */	NdrFcShort( 0x8 ),	/* 8 */
/* 846 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 848 */	NdrFcShort( 0xffc8 ),	/* -56 */
/* 850 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 852 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 854 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (834) */
/* 856 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 858 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 860 */	NdrFcShort( 0x38 ),	/* 56 */
/* 862 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (842) */
/* 864 */	NdrFcShort( 0x0 ),	/* Offset= 0 (864) */
/* 866 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 868 */	0x38,		/* FC_ALIGNM4 */
			0x8,		/* FC_LONG */
/* 870 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 872 */	0x4,		/* 4 */
			NdrFcShort( 0xfffffe0d ),	/* Offset= -499 (374) */
			0x5b,		/* FC_END */
/* 876 */	
			0x12, 0x0,	/* FC_UP */
/* 878 */	NdrFcShort( 0xffffff02 ),	/* Offset= -254 (624) */
/* 880 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 882 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 884 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 886 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 888 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 890 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 892 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 894 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 896 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 898 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 900 */	
			0x12, 0x0,	/* FC_UP */
/* 902 */	NdrFcShort( 0xfffffdbe ),	/* Offset= -578 (324) */
/* 904 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 906 */	NdrFcShort( 0xfffffc78 ),	/* Offset= -904 (2) */
/* 908 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 910 */	NdrFcShort( 0xfffffdbc ),	/* Offset= -580 (330) */
/* 912 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 914 */	NdrFcShort( 0xfffffdca ),	/* Offset= -566 (348) */
/* 916 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 918 */	NdrFcShort( 0xfffffdd8 ),	/* Offset= -552 (366) */
/* 920 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 922 */	NdrFcShort( 0x2 ),	/* Offset= 2 (924) */
/* 924 */	
			0x12, 0x0,	/* FC_UP */
/* 926 */	NdrFcShort( 0x16 ),	/* Offset= 22 (948) */
/* 928 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 930 */	NdrFcShort( 0x10 ),	/* 16 */
/* 932 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 934 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 936 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 938 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 940 */	
			0x12, 0x0,	/* FC_UP */
/* 942 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (928) */
/* 944 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 946 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 948 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 950 */	NdrFcShort( 0x20 ),	/* 32 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x0 ),	/* Offset= 0 (954) */
/* 956 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 958 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 960 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 962 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 964 */	NdrFcShort( 0xfffffc6e ),	/* Offset= -914 (50) */
/* 966 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 968 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 970 */	NdrFcShort( 0x1 ),	/* 1 */
/* 972 */	NdrFcShort( 0x18 ),	/* 24 */
/* 974 */	NdrFcShort( 0x0 ),	/* 0 */
/* 976 */	NdrFcShort( 0xfffffc5e ),	/* Offset= -930 (46) */
/* 978 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 980 */	NdrFcShort( 0x2 ),	/* 2 */
/* 982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0xfffffd94 ),	/* Offset= -620 (366) */
/* 988 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 990 */	NdrFcShort( 0x6 ),	/* Offset= 6 (996) */
/* 992 */	
			0x13, 0x0,	/* FC_OP */
/* 994 */	NdrFcShort( 0xfffffc30 ),	/* Offset= -976 (18) */
/* 996 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (992) */
/* 1006 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1008 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1010) */
/* 1010 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1012 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1014 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1016 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1018) */
/* 1018 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1020 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 1022 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1024 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1030) */
/* 1026 */	
			0x13, 0x0,	/* FC_OP */
/* 1028 */	NdrFcShort( 0xffffffb0 ),	/* Offset= -80 (948) */
/* 1030 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1032 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1034 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1038 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1026) */
/* 1040 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1042 */	NdrFcShort( 0xfffffd38 ),	/* Offset= -712 (330) */
/* 1044 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1046 */	NdrFcShort( 0xfffffd46 ),	/* Offset= -698 (348) */
/* 1048 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1050 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (928) */
/* 1052 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 1054 */	NdrFcShort( 0xa ),	/* Offset= 10 (1064) */
/* 1056 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1060) */
/* 1060 */	
			0x13, 0x0,	/* FC_OP */
/* 1062 */	NdrFcShort( 0xffffff34 ),	/* Offset= -204 (858) */
/* 1064 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1066 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1068 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (1056) */
/* 1074 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1076 */	NdrFcLong( 0xc ),	/* 12 */
/* 1080 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1082 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1084 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1086 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1088 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1090 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1092 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1094 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1074) */
/* 1096 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1098 */	NdrFcLong( 0xb ),	/* 11 */
/* 1102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1106 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1108 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1110 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1112 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1114 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1116 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1096) */
/* 1118 */	
			0x12, 0x0,	/* FC_UP */
/* 1120 */	NdrFcShort( 0xfffffee2 ),	/* Offset= -286 (834) */
/* 1122 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1124 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1126 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1130 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1132 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 1134 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1136 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1140 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1146) */
/* 1142 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1144 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1146 */	
			0x12, 0x0,	/* FC_UP */
/* 1148 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1122) */
/* 1150 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1152 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1156 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1162) */
/* 1158 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1160 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1162 */	
			0x12, 0x0,	/* FC_UP */
/* 1164 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1122) */
/* 1166 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1168 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1170 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1172 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1178) */
/* 1174 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1176 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1178 */	
			0x12, 0x0,	/* FC_UP */
/* 1180 */	NdrFcShort( 0xfffffe52 ),	/* Offset= -430 (750) */
/* 1182 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1184 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1194) */
/* 1190 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1192 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1194 */	
			0x12, 0x0,	/* FC_UP */
/* 1196 */	NdrFcShort( 0xfffffe42 ),	/* Offset= -446 (750) */
/* 1198 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1200 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1204 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1210) */
/* 1206 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1208 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1210 */	
			0x12, 0x0,	/* FC_UP */
/* 1212 */	NdrFcShort( 0xfffffe32 ),	/* Offset= -462 (750) */
/* 1214 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1216 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1220 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1226) */
/* 1222 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1224 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1226 */	
			0x12, 0x0,	/* FC_UP */
/* 1228 */	NdrFcShort( 0xfffffe3e ),	/* Offset= -450 (778) */
/* 1230 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1232 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1236 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1242) */
/* 1238 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1240 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1242 */	
			0x12, 0x0,	/* FC_UP */
/* 1244 */	NdrFcShort( 0xfffffe2e ),	/* Offset= -466 (778) */
/* 1246 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1248 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1250 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1254 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1256 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 1258 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1260 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1264 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1270) */
/* 1266 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1268 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1270 */	
			0x12, 0x0,	/* FC_UP */
/* 1272 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1246) */
/* 1274 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1276 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1278 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1280 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1286) */
/* 1282 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1284 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1286 */	
			0x12, 0x0,	/* FC_UP */
/* 1288 */	NdrFcShort( 0xfffffe02 ),	/* Offset= -510 (778) */
/* 1290 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1294 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1300 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1302 */	NdrFcShort( 0xfffffc2e ),	/* Offset= -978 (324) */
/* 1304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1306 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1308 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1318) */
/* 1314 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1316 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1318 */	
			0x12, 0x0,	/* FC_UP */
/* 1320 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1290) */
/* 1322 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1324 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1328 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1334) */
/* 1330 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1332 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1334 */	
			0x12, 0x0,	/* FC_UP */
/* 1336 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1290) */
/* 1338 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1340 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1342 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1346 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1348 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 1350 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1352 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1362) */
/* 1358 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1360 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1362 */	
			0x12, 0x0,	/* FC_UP */
/* 1364 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1338) */
/* 1366 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1368 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1372 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1378) */
/* 1374 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1376 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1378 */	
			0x12, 0x0,	/* FC_UP */
/* 1380 */	NdrFcShort( 0xffffffa6 ),	/* Offset= -90 (1290) */
/* 1382 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1384 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1388 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1394) */
/* 1390 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1392 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1394 */	
			0x12, 0x0,	/* FC_UP */
/* 1396 */	NdrFcShort( 0xffffffc6 ),	/* Offset= -58 (1338) */
/* 1398 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1400 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1402 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1406 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1408 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1410 */	NdrFcShort( 0xfffffdc0 ),	/* Offset= -576 (834) */
/* 1412 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1414 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1416 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1420 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1426) */
/* 1422 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1424 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1426 */	
			0x12, 0x0,	/* FC_UP */
/* 1428 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1398) */
/* 1430 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1432 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1434 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1438 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1440 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1442 */	NdrFcShort( 0xfffffd10 ),	/* Offset= -752 (690) */
/* 1444 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1446 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1448 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1450 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1452 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1458) */
/* 1454 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1456 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1458 */	
			0x12, 0x0,	/* FC_UP */
/* 1460 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1430) */
/* 1462 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1464 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1466 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1472 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1474 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1476 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1480 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1488) */
/* 1482 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1484 */	0x39,		/* FC_ALIGNM8 */
			0x36,		/* FC_POINTER */
/* 1486 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1488 */	
			0x12, 0x0,	/* FC_UP */
/* 1490 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1462) */
/* 1492 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1496 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1498 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1500 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1502 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1506 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1508 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1510 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1474) */
/* 1512 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1514 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1516 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1518 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1520 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1526) */
/* 1522 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1524 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1526 */	
			0x12, 0x0,	/* FC_UP */
/* 1528 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1492) */
/* 1530 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1534 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1540 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1544 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1546 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1548 */	NdrFcShort( 0xfffffa10 ),	/* Offset= -1520 (28) */
/* 1550 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1552 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1554 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1556 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1558 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1564) */
/* 1560 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1562 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1564 */	
			0x12, 0x0,	/* FC_UP */
/* 1566 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1530) */
/* 1568 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1570 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1574 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1580) */
/* 1576 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1578 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1580 */	
			0x12, 0x0,	/* FC_UP */
/* 1582 */	NdrFcShort( 0xfffffca4 ),	/* Offset= -860 (722) */
/* 1584 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1588 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1592 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1594 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1598 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1600 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1602 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (1568) */
/* 1604 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1606 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1608 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1612 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1618) */
/* 1614 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1616 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1618 */	
			0x12, 0x0,	/* FC_UP */
/* 1620 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1584) */
/* 1622 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1626 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1630 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1632 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1636 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1638 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1640 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 1642 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1644 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1646 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1650 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1656) */
/* 1652 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1654 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1656 */	
			0x12, 0x0,	/* FC_UP */
/* 1658 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1622) */
/* 1660 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1662 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1664 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1668 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1670 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1674 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1676 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1678 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1680 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1682 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1684 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1688 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1694) */
/* 1690 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 1692 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1694 */	
			0x12, 0x0,	/* FC_UP */
/* 1696 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1660) */
/* 1698 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 1700 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1702 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1704 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1706 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1708) */
/* 1708 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1710 */	NdrFcShort( 0x61 ),	/* 97 */
/* 1712 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1716 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1716) */
/* 1718 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1722 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1722) */
/* 1724 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1728 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1730 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1734 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1736 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1740 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1742 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1746 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1748 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1752 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1754 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1758 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1760 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1764 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1766 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1770 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1772 */	NdrFcLong( 0xe ),	/* 14 */
/* 1776 */	NdrFcShort( 0xfffffa54 ),	/* Offset= -1452 (324) */
/* 1778 */	NdrFcLong( 0x14 ),	/* 20 */
/* 1782 */	NdrFcShort( 0xfffffa4e ),	/* Offset= -1458 (324) */
/* 1784 */	NdrFcLong( 0x15 ),	/* 21 */
/* 1788 */	NdrFcShort( 0xfffffa48 ),	/* Offset= -1464 (324) */
/* 1790 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1794 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1796 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1800 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1802 */	NdrFcLong( 0xb ),	/* 11 */
/* 1806 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1808 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 1812 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1814 */	NdrFcLong( 0xa ),	/* 10 */
/* 1818 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1820 */	NdrFcLong( 0x6 ),	/* 6 */
/* 1824 */	NdrFcShort( 0xfffffa24 ),	/* Offset= -1500 (324) */
/* 1826 */	NdrFcLong( 0x7 ),	/* 7 */
/* 1830 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1832 */	NdrFcLong( 0x40 ),	/* 64 */
/* 1836 */	NdrFcShort( 0xfffffc16 ),	/* Offset= -1002 (834) */
/* 1838 */	NdrFcLong( 0x48 ),	/* 72 */
/* 1842 */	NdrFcShort( 0x1c6 ),	/* Offset= 454 (2296) */
/* 1844 */	NdrFcLong( 0x47 ),	/* 71 */
/* 1848 */	NdrFcShort( 0x1c4 ),	/* Offset= 452 (2300) */
/* 1850 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1854 */	NdrFcShort( 0xfffff8de ),	/* Offset= -1826 (28) */
/* 1856 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 1860 */	NdrFcShort( 0xfffffedc ),	/* Offset= -292 (1568) */
/* 1862 */	NdrFcLong( 0x41 ),	/* 65 */
/* 1866 */	NdrFcShort( 0x1b6 ),	/* Offset= 438 (2304) */
/* 1868 */	NdrFcLong( 0x46 ),	/* 70 */
/* 1872 */	NdrFcShort( 0x1b0 ),	/* Offset= 432 (2304) */
/* 1874 */	NdrFcLong( 0x1e ),	/* 30 */
/* 1878 */	NdrFcShort( 0x1ba ),	/* Offset= 442 (2320) */
/* 1880 */	NdrFcLong( 0x1f ),	/* 31 */
/* 1884 */	NdrFcShort( 0x1b8 ),	/* Offset= 440 (2324) */
/* 1886 */	NdrFcLong( 0xd ),	/* 13 */
/* 1890 */	NdrFcShort( 0xfffff9e8 ),	/* Offset= -1560 (330) */
/* 1892 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1896 */	NdrFcShort( 0xfffff9f4 ),	/* Offset= -1548 (348) */
/* 1898 */	NdrFcLong( 0x42 ),	/* 66 */
/* 1902 */	NdrFcShort( 0xfffffcc4 ),	/* Offset= -828 (1074) */
/* 1904 */	NdrFcLong( 0x44 ),	/* 68 */
/* 1908 */	NdrFcShort( 0xfffffcbe ),	/* Offset= -834 (1074) */
/* 1910 */	NdrFcLong( 0x43 ),	/* 67 */
/* 1914 */	NdrFcShort( 0xfffffcce ),	/* Offset= -818 (1096) */
/* 1916 */	NdrFcLong( 0x45 ),	/* 69 */
/* 1920 */	NdrFcShort( 0xfffffcc8 ),	/* Offset= -824 (1096) */
/* 1922 */	NdrFcLong( 0x49 ),	/* 73 */
/* 1926 */	NdrFcShort( 0x192 ),	/* Offset= 402 (2328) */
/* 1928 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 1932 */	NdrFcShort( 0xfffffc46 ),	/* Offset= -954 (978) */
/* 1934 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 1938 */	NdrFcShort( 0xfffffc40 ),	/* Offset= -960 (978) */
/* 1940 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 1944 */	NdrFcShort( 0xfffffc3a ),	/* Offset= -966 (978) */
/* 1946 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 1950 */	NdrFcShort( 0xfffffc34 ),	/* Offset= -972 (978) */
/* 1952 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 1956 */	NdrFcShort( 0xfffffc2e ),	/* Offset= -978 (978) */
/* 1958 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 1962 */	NdrFcShort( 0xfffffc28 ),	/* Offset= -984 (978) */
/* 1964 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 1968 */	NdrFcShort( 0xfffffc22 ),	/* Offset= -990 (978) */
/* 1970 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 1974 */	NdrFcShort( 0xfffffc1c ),	/* Offset= -996 (978) */
/* 1976 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 1980 */	NdrFcShort( 0xfffffc16 ),	/* Offset= -1002 (978) */
/* 1982 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 1986 */	NdrFcShort( 0xfffffc10 ),	/* Offset= -1008 (978) */
/* 1988 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 1992 */	NdrFcShort( 0xfffffc0a ),	/* Offset= -1014 (978) */
/* 1994 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 1998 */	NdrFcShort( 0xfffffc04 ),	/* Offset= -1020 (978) */
/* 2000 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 2004 */	NdrFcShort( 0xfffffbfe ),	/* Offset= -1026 (978) */
/* 2006 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 2010 */	NdrFcShort( 0xfffffbf8 ),	/* Offset= -1032 (978) */
/* 2012 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 2016 */	NdrFcShort( 0xfffffbf2 ),	/* Offset= -1038 (978) */
/* 2018 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 2022 */	NdrFcShort( 0xfffffbec ),	/* Offset= -1044 (978) */
/* 2024 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 2028 */	NdrFcShort( 0xfffffbe6 ),	/* Offset= -1050 (978) */
/* 2030 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 2034 */	NdrFcShort( 0xfffffbe0 ),	/* Offset= -1056 (978) */
/* 2036 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 2040 */	NdrFcShort( 0xfffffbda ),	/* Offset= -1062 (978) */
/* 2042 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 2046 */	NdrFcShort( 0xfffffc70 ),	/* Offset= -912 (1134) */
/* 2048 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 2052 */	NdrFcShort( 0xfffffc7a ),	/* Offset= -902 (1150) */
/* 2054 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 2058 */	NdrFcShort( 0xfffffc84 ),	/* Offset= -892 (1166) */
/* 2060 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 2064 */	NdrFcShort( 0xfffffc8e ),	/* Offset= -882 (1182) */
/* 2066 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 2070 */	NdrFcShort( 0xfffffca8 ),	/* Offset= -856 (1214) */
/* 2072 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 2076 */	NdrFcShort( 0xfffffcb2 ),	/* Offset= -846 (1230) */
/* 2078 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 2082 */	NdrFcShort( 0xfffffcf8 ),	/* Offset= -776 (1306) */
/* 2084 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 2088 */	NdrFcShort( 0xfffffd02 ),	/* Offset= -766 (1322) */
/* 2090 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 2094 */	NdrFcShort( 0xfffffcbc ),	/* Offset= -836 (1258) */
/* 2096 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 2100 */	NdrFcShort( 0xfffffd12 ),	/* Offset= -750 (1350) */
/* 2102 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 2106 */	NdrFcShort( 0xfffffc74 ),	/* Offset= -908 (1198) */
/* 2108 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 2112 */	NdrFcShort( 0xfffffcba ),	/* Offset= -838 (1274) */
/* 2114 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 2118 */	NdrFcShort( 0xfffffd10 ),	/* Offset= -752 (1366) */
/* 2120 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 2124 */	NdrFcShort( 0xfffffd1a ),	/* Offset= -742 (1382) */
/* 2126 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 2130 */	NdrFcShort( 0xfffffd34 ),	/* Offset= -716 (1414) */
/* 2132 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 2136 */	NdrFcShort( 0xfffffd4e ),	/* Offset= -690 (1446) */
/* 2138 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 2142 */	NdrFcShort( 0xfffffd8c ),	/* Offset= -628 (1514) */
/* 2144 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 2148 */	NdrFcShort( 0xfffffdac ),	/* Offset= -596 (1552) */
/* 2150 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 2154 */	NdrFcShort( 0xfffffddc ),	/* Offset= -548 (1606) */
/* 2156 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 2160 */	NdrFcShort( 0xfffffdfc ),	/* Offset= -516 (1644) */
/* 2162 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 2166 */	NdrFcShort( 0xfffffe1c ),	/* Offset= -484 (1682) */
/* 2168 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 2172 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (2402) */
/* 2174 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 2178 */	NdrFcShort( 0xfffffb2e ),	/* Offset= -1234 (944) */
/* 2180 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 2184 */	NdrFcShort( 0xfffffb28 ),	/* Offset= -1240 (944) */
/* 2186 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 2190 */	NdrFcShort( 0xfffffae6 ),	/* Offset= -1306 (884) */
/* 2192 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 2196 */	NdrFcShort( 0xfffffae0 ),	/* Offset= -1312 (884) */
/* 2198 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 2202 */	NdrFcShort( 0xfffffade ),	/* Offset= -1314 (888) */
/* 2204 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 2208 */	NdrFcShort( 0xfffffad8 ),	/* Offset= -1320 (888) */
/* 2210 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 2214 */	NdrFcShort( 0xfffffad2 ),	/* Offset= -1326 (888) */
/* 2216 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 2220 */	NdrFcShort( 0xfffffacc ),	/* Offset= -1332 (888) */
/* 2222 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 2226 */	NdrFcShort( 0xfffffaca ),	/* Offset= -1334 (892) */
/* 2228 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 2232 */	NdrFcShort( 0xfffffac8 ),	/* Offset= -1336 (896) */
/* 2234 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 2238 */	NdrFcShort( 0xfffffab6 ),	/* Offset= -1354 (884) */
/* 2240 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 2244 */	NdrFcShort( 0xfffffae8 ),	/* Offset= -1304 (940) */
/* 2246 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 2250 */	NdrFcShort( 0xfffffaae ),	/* Offset= -1362 (888) */
/* 2252 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 2256 */	NdrFcShort( 0xfffffab4 ),	/* Offset= -1356 (900) */
/* 2258 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 2262 */	NdrFcShort( 0xfffffaaa ),	/* Offset= -1366 (896) */
/* 2264 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 2268 */	NdrFcShort( 0x52 ),	/* Offset= 82 (2350) */
/* 2270 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 2274 */	NdrFcShort( 0xfffffaaa ),	/* Offset= -1366 (908) */
/* 2276 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 2280 */	NdrFcShort( 0xfffffaa8 ),	/* Offset= -1368 (912) */
/* 2282 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 2286 */	NdrFcShort( 0x44 ),	/* Offset= 68 (2354) */
/* 2288 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 2292 */	NdrFcShort( 0x42 ),	/* Offset= 66 (2358) */
/* 2294 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (2293) */
/* 2296 */	
			0x12, 0x0,	/* FC_UP */
/* 2298 */	NdrFcShort( 0xfffff9b8 ),	/* Offset= -1608 (690) */
/* 2300 */	
			0x12, 0x0,	/* FC_UP */
/* 2302 */	NdrFcShort( 0xfffffcc4 ),	/* Offset= -828 (1474) */
/* 2304 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2306 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2310 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2316) */
/* 2312 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 2314 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2316 */	
			0x12, 0x0,	/* FC_UP */
/* 2318 */	NdrFcShort( 0xfffff9c4 ),	/* Offset= -1596 (722) */
/* 2320 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2322 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2324 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2326 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2328 */	
			0x12, 0x0,	/* FC_UP */
/* 2330 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2332) */
/* 2332 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2334 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2338 */	NdrFcShort( 0xc ),	/* Offset= 12 (2350) */
/* 2340 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2342 */	NdrFcShort( 0xfffff98c ),	/* Offset= -1652 (690) */
/* 2344 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2346 */	NdrFcShort( 0xfffffb08 ),	/* Offset= -1272 (1074) */
/* 2348 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2350 */	
			0x12, 0x0,	/* FC_UP */
/* 2352 */	NdrFcShort( 0xfffff6ec ),	/* Offset= -2324 (28) */
/* 2354 */	
			0x12, 0x0,	/* FC_UP */
/* 2356 */	NdrFcShort( 0xfffffa9e ),	/* Offset= -1378 (978) */
/* 2358 */	
			0x12, 0x0,	/* FC_UP */
/* 2360 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2362) */
/* 2362 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2364 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2366 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2368 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2368) */
/* 2370 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 2372 */	0x1,		/* FC_BYTE */
			0x38,		/* FC_ALIGNM4 */
/* 2374 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2376 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd59 ),	/* Offset= -679 (1698) */
			0x5b,		/* FC_END */
/* 2380 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 2382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2384 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2388 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2390 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2394 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2396 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2398 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2362) */
/* 2400 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2402 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2404 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2414) */
/* 2410 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 2412 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2414 */	
			0x12, 0x0,	/* FC_UP */
/* 2416 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2380) */
/* 2418 */	
			0x12, 0x0,	/* FC_UP */
/* 2420 */	NdrFcShort( 0xfffffafa ),	/* Offset= -1286 (1134) */
/* 2422 */	
			0x12, 0x0,	/* FC_UP */
/* 2424 */	NdrFcShort( 0xfffffb06 ),	/* Offset= -1274 (1150) */
/* 2426 */	
			0x12, 0x0,	/* FC_UP */
/* 2428 */	NdrFcShort( 0xfffffb12 ),	/* Offset= -1262 (1166) */
/* 2430 */	
			0x12, 0x0,	/* FC_UP */
/* 2432 */	NdrFcShort( 0xfffffb1e ),	/* Offset= -1250 (1182) */
/* 2434 */	
			0x12, 0x0,	/* FC_UP */
/* 2436 */	NdrFcShort( 0xfffffb2a ),	/* Offset= -1238 (1198) */
/* 2438 */	
			0x12, 0x0,	/* FC_UP */
/* 2440 */	NdrFcShort( 0xfffffb36 ),	/* Offset= -1226 (1214) */
/* 2442 */	
			0x12, 0x0,	/* FC_UP */
/* 2444 */	NdrFcShort( 0xfffffb42 ),	/* Offset= -1214 (1230) */
/* 2446 */	
			0x12, 0x0,	/* FC_UP */
/* 2448 */	NdrFcShort( 0xfffffb5a ),	/* Offset= -1190 (1258) */
/* 2450 */	
			0x12, 0x0,	/* FC_UP */
/* 2452 */	NdrFcShort( 0xfffffb66 ),	/* Offset= -1178 (1274) */
/* 2454 */	
			0x12, 0x0,	/* FC_UP */
/* 2456 */	NdrFcShort( 0xfffffb82 ),	/* Offset= -1150 (1306) */
/* 2458 */	
			0x12, 0x0,	/* FC_UP */
/* 2460 */	NdrFcShort( 0xfffffb8e ),	/* Offset= -1138 (1322) */
/* 2462 */	
			0x12, 0x0,	/* FC_UP */
/* 2464 */	NdrFcShort( 0xfffffba6 ),	/* Offset= -1114 (1350) */
/* 2466 */	
			0x12, 0x0,	/* FC_UP */
/* 2468 */	NdrFcShort( 0xfffffbb2 ),	/* Offset= -1102 (1366) */
/* 2470 */	
			0x12, 0x0,	/* FC_UP */
/* 2472 */	NdrFcShort( 0xfffffbbe ),	/* Offset= -1090 (1382) */
/* 2474 */	
			0x12, 0x0,	/* FC_UP */
/* 2476 */	NdrFcShort( 0xfffffbda ),	/* Offset= -1062 (1414) */
/* 2478 */	
			0x12, 0x0,	/* FC_UP */
/* 2480 */	NdrFcShort( 0xfffffbf6 ),	/* Offset= -1034 (1446) */
/* 2482 */	
			0x12, 0x0,	/* FC_UP */
/* 2484 */	NdrFcShort( 0xfffffc36 ),	/* Offset= -970 (1514) */
/* 2486 */	
			0x12, 0x0,	/* FC_UP */
/* 2488 */	NdrFcShort( 0xfffffc58 ),	/* Offset= -936 (1552) */
/* 2490 */	
			0x12, 0x0,	/* FC_UP */
/* 2492 */	NdrFcShort( 0xfffffc8a ),	/* Offset= -886 (1606) */
/* 2494 */	
			0x12, 0x0,	/* FC_UP */
/* 2496 */	NdrFcShort( 0xfffffcac ),	/* Offset= -852 (1644) */
/* 2498 */	
			0x12, 0x0,	/* FC_UP */
/* 2500 */	NdrFcShort( 0xfffffcce ),	/* Offset= -818 (1682) */
/* 2502 */	
			0x12, 0x0,	/* FC_UP */
/* 2504 */	NdrFcShort( 0xffffff9a ),	/* Offset= -102 (2402) */

			0x0, 0x0
        }
    };

#endif // __RPC_WIN64__

#endif // _FMTSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\factory.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    factory.c

Abstract:
    Implements the IPSFactoryBuffer interface.

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT, Windows 95 and PowerMac.
    We do not support DOS and Win16 or Mac.

Revision History:
    YongQu      1-Oct-1998  Unlimit vtbl

--*/

#define CINTERFACE
#define USE_STUBLESS_PROXY

#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>

//
// Internal CLSCTX used for loading Proxy/Stub DLLs
//
#define CLSCTX_PS_DLL                 0x80000000
extern void ** StublessClientVtbl;
EXTERN_C extern const void * g_StublessClientVtbl[];

#define MAX_STUBLESS_PROC 128
ULONG    g_dwVtblSize = MAX_STUBLESS_PROC;
ULONG    g_dwForwardVtblSize = MAX_STUBLESS_PROC;


static I_RPC_MUTEX TemplateMutex = 0 ,VtblMutex = 0 ;


HRESULT CreateStublessProcBuffer(ULONG numMethods, void *** lpTempVtbl);
HRESULT CreateForwardProcBuffer(ULONG numMethods, void *** lpTempVtbl);

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_QueryInterface (
    IPSFactoryBuffer *This,
    REFIID iid,
    void **ppv );

ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_AddRef(
    IPSFactoryBuffer *This);

ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_Release(
    IPSFactoryBuffer *This);

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_CreateProxy
(
    IPSFactoryBuffer *This,
    IUnknown *punkOuter,
    REFIID riid,
    IRpcProxyBuffer **ppProxy,
    void **ppv
);

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_CreateStub
(
    IPSFactoryBuffer *This,
    REFIID riid,
    IUnknown *punkServer,
    IRpcStubBuffer **ppStub
);

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_HkGetProxyFileInfo
(
    IN  IPSFactoryBuffer    *This,
    IN  REFIID              riid,
    OUT PINT                pOffset,
    OUT PVOID               *ppProxyFileInfo
);

extern "C"
{

void STDMETHODCALLTYPE
NdrProxyForwardingFunction3(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction4(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction5(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction6(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction7(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction8(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction9(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction10(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction11(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction12(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction13(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction14(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction15(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction16(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction17(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction18(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction19(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction20(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction21(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction22(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction23(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction24(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction25(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction26(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction27(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction28(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction29(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction30(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction31(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction32(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction33(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction34(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction35(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction36(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction37(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction38(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction39(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction40(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction41(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction42(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction43(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction44(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction45(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction46(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction47(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction48(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction49(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction50(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction51(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction52(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction53(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction54(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction55(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction56(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction57(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction58(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction59(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction60(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction61(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction62(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction63(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction64(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction65(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction66(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction67(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction68(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction69(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction70(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction71(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction72(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction73(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction74(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction75(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction76(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction77(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction78(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction79(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction80(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction81(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction82(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction83(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction84(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction85(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction86(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction87(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction88(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction89(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction90(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction91(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction92(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction93(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction94(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction95(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction96(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction97(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction98(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction99(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction100(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction101(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction102(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction103(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction104(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction105(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction106(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction107(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction108(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction109(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction110(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction111(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction112(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction113(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction114(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction115(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction116(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction117(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction118(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction119(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction120(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction121(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction122(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction123(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction124(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction125(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction126(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction127(void);

#if defined(_AMD64_) || defined(_IA64_)

void STDMETHODCALLTYPE
NdrProxyForwardingFunction128(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction129(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction130(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction131(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction132(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction133(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction134(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction135(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction136(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction137(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction138(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction139(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction140(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction141(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction142(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction143(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction144(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction145(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction146(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction147(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction148(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction149(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction150(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction151(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction152(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction153(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction154(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction155(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction156(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction157(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction158(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction159(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction160(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction161(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction162(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction163(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction164(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction165(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction166(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction167(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction168(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction169(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction170(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction171(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction172(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction173(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction174(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction175(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction176(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction177(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction178(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction179(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction180(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction181(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction182(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction183(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction184(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction185(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction186(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction187(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction188(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction189(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction190(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction191(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction192(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction193(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction194(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction195(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction196(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction197(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction198(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction199(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction200(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction201(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction202(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction203(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction204(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction205(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction206(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction207(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction208(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction209(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction210(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction211(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction212(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction213(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction214(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction215(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction216(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction217(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction218(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction219(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction220(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction221(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction222(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction223(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction224(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction225(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction226(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction227(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction228(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction229(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction230(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction231(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction232(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction233(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction234(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction235(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction236(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction237(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction238(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction239(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction240(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction241(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction242(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction243(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction244(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction245(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction246(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction247(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction248(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction249(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction250(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction251(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction252(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction253(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction254(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction255(void);

#endif // defined(_AMD64_) || defined(_IA64_)

}


//+-------------------------------------------------------------------------
//
//  Global data
//
//--------------------------------------------------------------------------

// Hook Factory

extern const IPSFactoryHookVtbl CStdPSFactoryBufferVtbl = {
    CStdPSFactoryBuffer_QueryInterface,
    CStdPSFactoryBuffer_AddRef,
    CStdPSFactoryBuffer_Release,
    CStdPSFactoryBuffer_CreateProxy,
    CStdPSFactoryBuffer_CreateStub,
    CStdPSFactoryBuffer_HkGetProxyFileInfo };

// Nondelegated synchronous StubBuffer vtable

extern const IRpcStubBufferVtbl CStdStubBufferVtbl= {
    CStdStubBuffer_QueryInterface,
    CStdStubBuffer_AddRef,
    0,                          // sync stub is not aggregated
    CStdStubBuffer_Connect,
    CStdStubBuffer_Disconnect,
    CStdStubBuffer_Invoke,
    CStdStubBuffer_IsIIDSupported,
    CStdStubBuffer_CountRefs,
    CStdStubBuffer_DebugServerQueryInterface,
    CStdStubBuffer_DebugServerRelease };

// Delegated synchronous StubBuffer vtable

extern const IRpcStubBufferVtbl CStdStubBuffer2Vtbl= {
    CStdStubBuffer_QueryInterface,
    CStdStubBuffer_AddRef,
    0,                          // sync stub is not aggregated
    CStdStubBuffer2_Connect,
    CStdStubBuffer2_Disconnect,
    CStdStubBuffer_Invoke,
    CStdStubBuffer_IsIIDSupported,
    CStdStubBuffer2_CountRefs,
    CStdStubBuffer_DebugServerQueryInterface,
    CStdStubBuffer_DebugServerRelease };

extern const IRpcProxyBufferVtbl CStdProxyBufferVtbl;
extern const IRpcProxyBufferVtbl CStdProxyBuffer2Vtbl;

extern const ICallFactoryVtbl CStdProxyBuffer_CallFactoryVtbl;
extern const ICallFactoryVtbl CStdProxyBuffer2_CallFactoryVtbl;

extern const ICallFactoryVtbl CStdStubBuffer_CallFactoryVtbl;
extern const ICallFactoryVtbl CStdStubBuffer2_CallFactoryVtbl;

extern const IReleaseMarshalBuffersVtbl CStdProxyBuffer_ReleaseMarshalBuffersVtbl;
extern const IReleaseMarshalBuffersVtbl CStdStubBuffer_ReleaseMarshalBuffersVtbl;
extern const IReleaseMarshalBuffersVtbl CStdAsyncProxyBuffer_ReleaseMarshalBuffersVtbl;
extern const IReleaseMarshalBuffersVtbl CStdAsyncStubBuffer_ReleaseMarshalBuffersVtbl;


extern const IRpcStubBufferVtbl CStdAsyncStubBufferVtbl= {
    CStdAsyncStubBuffer_QueryInterface,
    CStdAsyncStubBuffer_AddRef,
    CStdAsyncStubBuffer_Release,
    CStdAsyncStubBuffer_Connect,        //
    CStdAsyncStubBuffer_Disconnect,     //
    CStdAsyncStubBuffer_Invoke,
    CStdStubBuffer_IsIIDSupported,
    CStdStubBuffer_CountRefs,
    CStdStubBuffer_DebugServerQueryInterface,
    CStdStubBuffer_DebugServerRelease };


extern const IRpcStubBufferVtbl CStdAsyncStubBuffer2Vtbl= {
    CStdAsyncStubBuffer_QueryInterface,
    CStdAsyncStubBuffer_AddRef,
    CStdAsyncStubBuffer2_Release,
    CStdAsyncStubBuffer2_Connect,       //
    CStdAsyncStubBuffer2_Disconnect,    //
    CStdAsyncStubBuffer_Invoke,
    CStdStubBuffer_IsIIDSupported,
    CStdStubBuffer2_CountRefs,
    CStdStubBuffer_DebugServerQueryInterface,
    CStdStubBuffer_DebugServerRelease };



extern void * const g_ForwardingVtbl[] = {
    Forwarding_QueryInterface,
    Forwarding_AddRef,
    Forwarding_Release,
    NdrProxyForwardingFunction3,
    NdrProxyForwardingFunction4,
    NdrProxyForwardingFunction5,
    NdrProxyForwardingFunction6,
    NdrProxyForwardingFunction7,
    NdrProxyForwardingFunction8,
    NdrProxyForwardingFunction9,
    NdrProxyForwardingFunction10,
    NdrProxyForwardingFunction11,
    NdrProxyForwardingFunction12,
    NdrProxyForwardingFunction13,
    NdrProxyForwardingFunction14,
    NdrProxyForwardingFunction15,
    NdrProxyForwardingFunction16,
    NdrProxyForwardingFunction17,
    NdrProxyForwardingFunction18,
    NdrProxyForwardingFunction19,
    NdrProxyForwardingFunction20,
    NdrProxyForwardingFunction21,
    NdrProxyForwardingFunction22,
    NdrProxyForwardingFunction23,
    NdrProxyForwardingFunction24,
    NdrProxyForwardingFunction25,
    NdrProxyForwardingFunction26,
    NdrProxyForwardingFunction27,
    NdrProxyForwardingFunction28,
    NdrProxyForwardingFunction29,
    NdrProxyForwardingFunction30,
    NdrProxyForwardingFunction31,
    NdrProxyForwardingFunction32,
    NdrProxyForwardingFunction33,
    NdrProxyForwardingFunction34,
    NdrProxyForwardingFunction35,
    NdrProxyForwardingFunction36,
    NdrProxyForwardingFunction37,
    NdrProxyForwardingFunction38,
    NdrProxyForwardingFunction39,
    NdrProxyForwardingFunction40,
    NdrProxyForwardingFunction41,
    NdrProxyForwardingFunction42,
    NdrProxyForwardingFunction43,
    NdrProxyForwardingFunction44,
    NdrProxyForwardingFunction45,
    NdrProxyForwardingFunction46,
    NdrProxyForwardingFunction47,
    NdrProxyForwardingFunction48,
    NdrProxyForwardingFunction49,
    NdrProxyForwardingFunction50,
    NdrProxyForwardingFunction51,
    NdrProxyForwardingFunction52,
    NdrProxyForwardingFunction53,
    NdrProxyForwardingFunction54,
    NdrProxyForwardingFunction55,
    NdrProxyForwardingFunction56,
    NdrProxyForwardingFunction57,
    NdrProxyForwardingFunction58,
    NdrProxyForwardingFunction59,
    NdrProxyForwardingFunction60,
    NdrProxyForwardingFunction61,
    NdrProxyForwardingFunction62,
    NdrProxyForwardingFunction63,
    NdrProxyForwardingFunction64,
    NdrProxyForwardingFunction65,
    NdrProxyForwardingFunction66,
    NdrProxyForwardingFunction67,
    NdrProxyForwardingFunction68,
    NdrProxyForwardingFunction69,
    NdrProxyForwardingFunction70,
    NdrProxyForwardingFunction71,
    NdrProxyForwardingFunction72,
    NdrProxyForwardingFunction73,
    NdrProxyForwardingFunction74,
    NdrProxyForwardingFunction75,
    NdrProxyForwardingFunction76,
    NdrProxyForwardingFunction77,
    NdrProxyForwardingFunction78,
    NdrProxyForwardingFunction79,
    NdrProxyForwardingFunction80,
    NdrProxyForwardingFunction81,
    NdrProxyForwardingFunction82,
    NdrProxyForwardingFunction83,
    NdrProxyForwardingFunction84,
    NdrProxyForwardingFunction85,
    NdrProxyForwardingFunction86,
    NdrProxyForwardingFunction87,
    NdrProxyForwardingFunction88,
    NdrProxyForwardingFunction89,
    NdrProxyForwardingFunction90,
    NdrProxyForwardingFunction91,
    NdrProxyForwardingFunction92,
    NdrProxyForwardingFunction93,
    NdrProxyForwardingFunction94,
    NdrProxyForwardingFunction95,
    NdrProxyForwardingFunction96,
    NdrProxyForwardingFunction97,
    NdrProxyForwardingFunction98,
    NdrProxyForwardingFunction99,
    NdrProxyForwardingFunction100,
    NdrProxyForwardingFunction101,
    NdrProxyForwardingFunction102,
    NdrProxyForwardingFunction103,
    NdrProxyForwardingFunction104,
    NdrProxyForwardingFunction105,
    NdrProxyForwardingFunction106,
    NdrProxyForwardingFunction107,
    NdrProxyForwardingFunction108,
    NdrProxyForwardingFunction109,
    NdrProxyForwardingFunction110,
    NdrProxyForwardingFunction111,
    NdrProxyForwardingFunction112,
    NdrProxyForwardingFunction113,
    NdrProxyForwardingFunction114,
    NdrProxyForwardingFunction115,
    NdrProxyForwardingFunction116,
    NdrProxyForwardingFunction117,
    NdrProxyForwardingFunction118,
    NdrProxyForwardingFunction119,
    NdrProxyForwardingFunction120,
    NdrProxyForwardingFunction121,
    NdrProxyForwardingFunction122,
    NdrProxyForwardingFunction123,
    NdrProxyForwardingFunction124,
    NdrProxyForwardingFunction125,
    NdrProxyForwardingFunction126,
    NdrProxyForwardingFunction127
#if defined (_AMD64_) || defined(_IA64_)
    ,
    NdrProxyForwardingFunction128,
    NdrProxyForwardingFunction129,
    NdrProxyForwardingFunction130,
    NdrProxyForwardingFunction131,
    NdrProxyForwardingFunction132,
    NdrProxyForwardingFunction133,
    NdrProxyForwardingFunction134,
    NdrProxyForwardingFunction135,
    NdrProxyForwardingFunction136,
    NdrProxyForwardingFunction137,
    NdrProxyForwardingFunction138,
    NdrProxyForwardingFunction139,
    NdrProxyForwardingFunction140,
    NdrProxyForwardingFunction141,
    NdrProxyForwardingFunction142,
    NdrProxyForwardingFunction143,
    NdrProxyForwardingFunction144,
    NdrProxyForwardingFunction145,
    NdrProxyForwardingFunction146,
    NdrProxyForwardingFunction147,
    NdrProxyForwardingFunction148,
    NdrProxyForwardingFunction149,
    NdrProxyForwardingFunction150,
    NdrProxyForwardingFunction151,
    NdrProxyForwardingFunction152,
    NdrProxyForwardingFunction153,
    NdrProxyForwardingFunction154,
    NdrProxyForwardingFunction155,
    NdrProxyForwardingFunction156,
    NdrProxyForwardingFunction157,
    NdrProxyForwardingFunction158,
    NdrProxyForwardingFunction159,
    NdrProxyForwardingFunction160,
    NdrProxyForwardingFunction161,
    NdrProxyForwardingFunction162,
    NdrProxyForwardingFunction163,
    NdrProxyForwardingFunction164,
    NdrProxyForwardingFunction165,
    NdrProxyForwardingFunction166,
    NdrProxyForwardingFunction167,
    NdrProxyForwardingFunction168,
    NdrProxyForwardingFunction169,
    NdrProxyForwardingFunction170,
    NdrProxyForwardingFunction171,
    NdrProxyForwardingFunction172,
    NdrProxyForwardingFunction173,
    NdrProxyForwardingFunction174,
    NdrProxyForwardingFunction175,
    NdrProxyForwardingFunction176,
    NdrProxyForwardingFunction177,
    NdrProxyForwardingFunction178,
    NdrProxyForwardingFunction179,
    NdrProxyForwardingFunction180,
    NdrProxyForwardingFunction181,
    NdrProxyForwardingFunction182,
    NdrProxyForwardingFunction183,
    NdrProxyForwardingFunction184,
    NdrProxyForwardingFunction185,
    NdrProxyForwardingFunction186,
    NdrProxyForwardingFunction187,
    NdrProxyForwardingFunction188,
    NdrProxyForwardingFunction189,
    NdrProxyForwardingFunction190,
    NdrProxyForwardingFunction191,
    NdrProxyForwardingFunction192,
    NdrProxyForwardingFunction193,
    NdrProxyForwardingFunction194,
    NdrProxyForwardingFunction195,
    NdrProxyForwardingFunction196,
    NdrProxyForwardingFunction197,
    NdrProxyForwardingFunction198,
    NdrProxyForwardingFunction199,
    NdrProxyForwardingFunction200,
    NdrProxyForwardingFunction201,
    NdrProxyForwardingFunction202,
    NdrProxyForwardingFunction203,
    NdrProxyForwardingFunction204,
    NdrProxyForwardingFunction205,
    NdrProxyForwardingFunction206,
    NdrProxyForwardingFunction207,
    NdrProxyForwardingFunction208,
    NdrProxyForwardingFunction209,
    NdrProxyForwardingFunction210,
    NdrProxyForwardingFunction211,
    NdrProxyForwardingFunction212,
    NdrProxyForwardingFunction213,
    NdrProxyForwardingFunction214,
    NdrProxyForwardingFunction215,
    NdrProxyForwardingFunction216,
    NdrProxyForwardingFunction217,
    NdrProxyForwardingFunction218,
    NdrProxyForwardingFunction219,
    NdrProxyForwardingFunction220,
    NdrProxyForwardingFunction221,
    NdrProxyForwardingFunction222,
    NdrProxyForwardingFunction223,
    NdrProxyForwardingFunction224,
    NdrProxyForwardingFunction225,
    NdrProxyForwardingFunction226,
    NdrProxyForwardingFunction227,
    NdrProxyForwardingFunction228,
    NdrProxyForwardingFunction229,
    NdrProxyForwardingFunction230,
    NdrProxyForwardingFunction231,
    NdrProxyForwardingFunction232,
    NdrProxyForwardingFunction233,
    NdrProxyForwardingFunction234,
    NdrProxyForwardingFunction235,
    NdrProxyForwardingFunction236,
    NdrProxyForwardingFunction237,
    NdrProxyForwardingFunction238,
    NdrProxyForwardingFunction239,
    NdrProxyForwardingFunction240,
    NdrProxyForwardingFunction241,
    NdrProxyForwardingFunction242,
    NdrProxyForwardingFunction243,
    NdrProxyForwardingFunction244,
    NdrProxyForwardingFunction245,
    NdrProxyForwardingFunction246,
    NdrProxyForwardingFunction247,
    NdrProxyForwardingFunction248,
    NdrProxyForwardingFunction249,
    NdrProxyForwardingFunction250,
    NdrProxyForwardingFunction251,
    NdrProxyForwardingFunction252,
    NdrProxyForwardingFunction253,
    NdrProxyForwardingFunction254,
    NdrProxyForwardingFunction255

#endif // defined(_AMD64_) || defined(_IA64_)
    };

void ** ProxyForwardVtbl = (void **)g_ForwardingVtbl;



#pragma code_seg(".orpc")


//+---------------------------------------------------------------------------
//
//  Function:   GetTemplateVtbl
//
//  Synopsis:   retrieve a copy of stublessclientvtbl and addref it.
//
//  Arguments:  void *** pppVtbl stublessclientvtbl to return.
//
//  Note:       StublessClientVtbl - sizeof(LONG) is the ref count .
//
//  Returns:
//
//----------------------------------------------------------------------------
void GetTemplateVtbl(void *** pppVtbl)
{
    LPLONG pTemp;
    void **ppVtbl;
    I_RpcRequestMutex(&TemplateMutex);
    ppVtbl = StublessClientVtbl;
    pTemp = (LPLONG)ppVtbl;
    *pppVtbl = ppVtbl;

    if (ppVtbl == (void**)g_StublessClientVtbl)
    {
        I_RpcClearMutex(TemplateMutex);
        return ;
    }

    pTemp--;
    (*pTemp) ++ ;
    I_RpcClearMutex(TemplateMutex);

}

// release the vtbl, free the memory if necessary.
void ReleaseTemplateVtbl(void ** pVtbl)
{
    LPLONG pTemp;

    I_RpcRequestMutex(&TemplateMutex);
    pTemp = (LPLONG)pVtbl;
    if (pVtbl == (void**)g_StublessClientVtbl)
    {
        I_RpcClearMutex(TemplateMutex);
        return;
    }

    pTemp--;
    (*pTemp)--;
    if (0 == *pTemp )
    {
        I_RpcFree(pTemp);
    }
    I_RpcClearMutex(TemplateMutex);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetTemplateForwardVtbl
//
//  Synopsis:   retrieve a copy of stublessclientvtbl and addref it.
//
//  Arguments:  void *** pppVtbl stublessclientvtbl to return.
//
//  Note:       StublessClientVtbl - sizeof(LONG) is the ref count .
//
//  Returns:
//
//----------------------------------------------------------------------------
void GetTemplateForwardVtbl(void *** pppVtbl)
{
    LPLONG pTemp;
    void **ppVtbl;
    I_RpcRequestMutex(&TemplateMutex);
    ppVtbl = ProxyForwardVtbl;
    pTemp = (LPLONG)ppVtbl;
    *pppVtbl = ppVtbl;

    if (ppVtbl == g_ForwardingVtbl)
    {
        I_RpcClearMutex(TemplateMutex);
        return ;
    }

    pTemp--;
    (*pTemp) ++ ;
    I_RpcClearMutex(TemplateMutex);

}

// release the vtbl, free the memory if necessary.
void ReleaseTemplateForwardVtbl(void ** pVtbl)
{
    LPLONG pTemp;

    I_RpcRequestMutex(&TemplateMutex);
    pTemp = (LPLONG)pVtbl;
    if (pVtbl == g_ForwardingVtbl)
    {
        I_RpcClearMutex(TemplateMutex);
        return;
    }

    pTemp--;
    (*pTemp)--;
    if (0 == *pTemp )
    {
        I_RpcFree(pTemp);
    }
    I_RpcClearMutex(TemplateMutex);
}



//+---------------------------------------------------------------------------
//
//  Function:   NdrpInitializeStublessVtbl
//
//  Synopsis:   Initialize a stubless vtbl list for current process. increase the size of
//              vtbl link list  and regenerate the vtbl array if necessary.
//
//  Note:       The actural vtbl size created might be larger than requested: we will fill
//              in the whole block of link list .
//
//  Arguments:  numMethods  number of methods in the interface.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT NdrpInitializeStublessVtbl(ULONG numMethods)
{
    void ** TempVtbl, ** pOldVtbl = NULL;   // ole vtbl template to be freed.
    HRESULT hr;

#if defined(_AMD64_) || defined(_IA64_)
    if (numMethods <= 1024)
        return S_OK;
    else
        return E_FAIL;
#else

    if (numMethods <= MAX_STUBLESS_PROC)
        return S_OK;

    // request a mutex might fail because of OUT_OF_MEMORY, and exception would be thrown. 
    // we don't want to throw exception in ole call, so we initialize it first and catch the exceptions.
    if ( VtblMutex == NULL )
        {
        hr = NdrpInitializeMutex( &VtblMutex );
        if ( FAILED( hr ) )
            return hr;  
        }

    if ( TemplateMutex == NULL )
        {
        hr = NdrpInitializeMutex( &TemplateMutex );
        if ( FAILED( hr ) )
            return hr;
        }
    
    I_RpcRequestMutex(&VtblMutex);
    if (numMethods > g_dwVtblSize)
    {
        // create a
        hr = CreateStublessProcBuffer(numMethods,&TempVtbl);

        if (FAILED(hr))
        {
            I_RpcClearMutex(VtblMutex);
            return hr;
        }

        pOldVtbl = StublessClientVtbl;

        StublessClientVtbl = TempVtbl;

    }

    I_RpcClearMutex(VtblMutex);

    if (pOldVtbl)
        ReleaseTemplateVtbl(pOldVtbl);

    return S_OK;
#endif // defined(_AMD64_) || defined(_IA64_)
}



//+---------------------------------------------------------------------------
//
//  Function:   NdrpInitializeForwardVtbl
//
//  Synopsis:   Initialize a stubless vtbl list for current process. increase the size of
//              vtbl link list  and regenerate the vtbl array if necessary.
//
//  Note:       The actural vtbl size created might be larger than requested: we will fill
//              in the whole block of link list .
//
//  Arguments:  numMethods  number of methods in the interface.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT NdrpInitializeForwardVtbl(ULONG numMethods)
{
    void ** TempVtbl, ** pOldVtbl = NULL;   // ole vtbl template to be freed.
    HRESULT hr;
#if defined(_AMD64_) || defined(_IA64_)
    if (numMethods <= 256)
        return S_OK;
    else
        return E_FAIL;
#else


    if (numMethods <= MAX_STUBLESS_PROC)
        return S_OK;

    I_RpcRequestMutex(&VtblMutex);
    if (numMethods > g_dwForwardVtblSize)
    {
        // create a
        hr = CreateForwardProcBuffer(numMethods,&TempVtbl);

        if (FAILED(hr) )
        {
            I_RpcClearMutex(VtblMutex);
            return hr;
        }

        pOldVtbl = ProxyForwardVtbl;

        ProxyForwardVtbl = TempVtbl;

    }

    I_RpcClearMutex(VtblMutex);

    if (pOldVtbl)
        ReleaseTemplateForwardVtbl(pOldVtbl);

    return S_OK;
#endif // defined(_AMD64_) || defined(_IA64_)
}



BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList,
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex)
/*++

Routine Description:
    Search the ProxyFileInfo and find the specified interface.
    If the count is specified in the ProxyFileInfo, then the interfaces in
    the file are sorted by IID.  This means that we can perform a binary
    search for the IID.

Arguments:
    pProxyFileList  - Specifies a list of proxy files to be searched.
    riid            - Specifies the interface ID to be found.
    ppProxyFileInfo - Returns a pointer to the proxy file info.
    pIndex          - Returns the index of the interface in the proxy file info.

Return Value:
    TRUE    - The interface was found.
    FALSE   - The interface was not found.

--*/
{
    long 				j;
    BOOL 				fFound 			= FALSE;
	ProxyFileInfo	**	ppProxyFileCur;
	ProxyFileInfo	*	pProxyFileCur;

    //Search the list of proxy files.
    for( ppProxyFileCur = (ProxyFileInfo **) pProxyFileList;
        (*ppProxyFileCur != 0) && (fFound != TRUE);
        ppProxyFileCur++)
	    {
	    //Search for the interface proxy vtable.
        pProxyFileCur = *ppProxyFileCur;

        // see if it has a lookup routine already
        if ( ( pProxyFileCur->TableVersion >= 1 ) &&
			 ( pProxyFileCur->pIIDLookupRtn ) )	
			{
			fFound = (*pProxyFileCur->pIIDLookupRtn)( &riid, (int*)&j );
			}
		else	//Linear search.
	        {
	        for(j = 0;
	            (pProxyFileCur->pProxyVtblList[j] != 0);
	            j++)
		        {
	            if(memcmp(&riid,
	                pProxyFileCur->pStubVtblList[j]->header.piid,
	                sizeof(IID)) == 0)
		            {
	                fFound = TRUE;
		            break;
		            }
		        }
			}
	    }

	if ( fFound )
		{
        //We found the interface!
        if(ppProxyFileInfo != 0)
            *ppProxyFileInfo = pProxyFileCur;

        if(pIndex != 0)
            *pIndex = j;
		}

    return fFound;
 }



__inline
void NdrpInitializeProxyVtbl(
    CInterfaceProxyVtbl *pProxyVtbl,
    unsigned long count,
    BOOL IsDelegated,
    unsigned short ProxyVersion)
/*++

Routine Description:
    Initialize the proxy vtbl.

Arguments:
    pProxyVtbl  - Supplies vtbl to be initialized.
    count       - Supplies number of entries in the vtbl.
    IsDelegated - TRUE if the interface is delegated, FALSE otherwise.

Return Value:
    None.

--*/
{
    unsigned long k;
    void **  Vtbl;
    void **  pStublessVtbl, **pForwardingVtbl;
    void **  SourceVtbl;

    GetTemplateVtbl(&pStublessVtbl);
    GetTemplateForwardVtbl(&pForwardingVtbl);

    SourceVtbl = IsDelegated ?
                           pForwardingVtbl : pStublessVtbl;

    Vtbl = pProxyVtbl->Vtbl;

    //
    // Proxies after NT 3.51 Beta have a ProxyHeader 4 bytes
    // larger to support stubless proxies.  So in older proxies
    // subtract 4 bytes to get the the Vtable.
    //
    if ( ProxyVersion < 2 )
        Vtbl = (void **) ((char*)Vtbl - PTR_MEM_SIZE);


    // Initialize forwarding or stubless proxy functions if necessary.

    if ( IsDelegated )
        {
        Vtbl[0] = IUnknown_QueryInterface_Proxy;
        Vtbl[1] = IUnknown_AddRef_Proxy;
        Vtbl[2] = IUnknown_Release_Proxy;
        k = 3;
        }
    else
        k = 0;


    for( ; k < count; k++)
    {
        if(!Vtbl[k])
        {
            Vtbl[k] = SourceVtbl[k];
        }
        else if ( -1 == (ULONG_PTR)Vtbl[k] )
        {
            Vtbl[k] = pStublessVtbl[k];
        }
    }

    ReleaseTemplateVtbl(pStublessVtbl);
    ReleaseTemplateForwardVtbl(pForwardingVtbl);
}

__inline
void NdrpInitializeStubVtbl(
    CInterfaceStubVtbl *pStubVtbl,
    unsigned long version)
/*++

Routine Description:
    Initialize the stub vtbl.

Arguments:
    pStubVtbl  - Supplies vtbl to be initialized.
    version

Return Value:
    None.

--*/
{
    void * * pVtbl = (void **) &pStubVtbl->Vtbl;
    void * * pSourceVtbl;
    int      i;

    switch ( version )
        {
        case 2:
            pSourceVtbl = (void **)&CStdStubBuffer2Vtbl;
            break;

        case 3:
            pSourceVtbl = (void **)&CStdAsyncStubBufferVtbl;
            break;

        case 4:
            pSourceVtbl = (void **)&CStdAsyncStubBuffer2Vtbl;
            break;

        default:
            pSourceVtbl = (void **)&CStdStubBufferVtbl;

        }

    for ( i=0; i < sizeof(IRpcStubBufferVtbl)/PTR_MEM_SIZE; i++ )
        {
        if ( !pVtbl[i] )
            pVtbl[i] = pSourceVtbl[i];
        }

}


HRESULT NdrpInitializeProxyDll(
    IN  const ProxyFileInfo **  pProxyFileList,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer )
/*++

Routine Description:
    Initialize the proxy DLL.

Arguments:
    pProxyFileList   - Specifies a list of proxy files to be searched.
    pPSFactoryBuffer - Pointer to class factory for proxy DLL.

Return Value:
    None.

--*/
{
    long i, j;
    HRESULT hr;
    unsigned long version, lStublessMaxCount = 0, lForwardMaxCount = 0;

    // set up the PSFactory object if we are the first
    // note that the refcount is NOT altered right here to avoid races
    if (pPSFactoryBuffer->lpVtbl != 0)
        return S_OK;

    for (i = 0; pProxyFileList[i] != 0; i++)
        for (j = 0; pProxyFileList[i]->pProxyVtblList[j] != 0; j++)
        {
            if((pProxyFileList[i]->pDelegatedIIDs != 0) &&
               (pProxyFileList[i]->pDelegatedIIDs[j] != 0))
            {
                if (lForwardMaxCount < pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount)
                    lForwardMaxCount = pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount;
            }
            if (lStublessMaxCount < pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount)
                lStublessMaxCount = pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount;
        }

    hr = NdrpInitializeStublessVtbl(lStublessMaxCount);
    if (SUCCEEDED(hr))
        hr = NdrpInitializeForwardVtbl(lForwardMaxCount);

    if (FAILED(hr))
        return hr;

    //iterate over the list of proxy files in the proxy DLL.
    for(i = 0;
        pProxyFileList[i] != 0;
        i++)
    {
        //iterate over the list of interfaces in the proxy file.
        for(j = 0;
            pProxyFileList[i]->pProxyVtblList[j] != 0;
            j++)
        {
            if((pProxyFileList[i]->pDelegatedIIDs != 0) &&
               (pProxyFileList[i]->pDelegatedIIDs[j] != 0))
                version = 2;
            else
                version = 0;

            //Initialize the proxy vtbl.
            NdrpInitializeProxyVtbl(pProxyFileList[i]->pProxyVtblList[j],
                                    pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                    (version == 2),
                                    pProxyFileList[i]->TableVersion);

            //Initialize the stub vtbl.

            // See if this is an async uuid interface.
            if ( (pProxyFileList[i]->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                 (ULONG_PTR)pProxyFileList[i]->pAsyncIIDLookup[j] == -1 )
                {
                if (version == 2)
                    {
                    // delegated async
                    version = 4;
                    }
                else
                    {
                    // non-delegated async
                    version = 3;
                    }
                }

            NdrpInitializeStubVtbl(pProxyFileList[i]->pStubVtblList[j],
                                   version);

            //Initialize the stub dispatch table.

        }
    }

    pPSFactoryBuffer->pProxyFileList = pProxyFileList;

    //Set the lpVtbl.  This code is safe for multiple threads.
    InterlockedExchangePointer((PVOID *) &pPSFactoryBuffer->lpVtbl,
                               (PVOID) &CStdPSFactoryBufferVtbl);

    return hr;
 }

HRESULT RPC_ENTRY NdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer )
/*++

Routine Description:
    Searches the linked list for the required class.

Arguments:
    rclsid -- class id to find
    riid   -- interface to return
    ppv    -- output pointer
    ppfinfo-- proxyfile info data structure
    pclsid -- proxy file classid
    pPSFactoryBuffer -- pointer to class factory for dll

Return Value:
    CLASS_E_CLASSNOTAVAILABLE if class not found
    Otherwise, whatever is returned by the class's QI

--*/
{
    HRESULT hr;
    RPC_STATUS rc;
    BOOL    fFound;

    //Initialize the RPC heap.
    rc = NdrpPerformRpcInitialization();

    if (RPC_S_OK == rc)
        hr = NdrpInitializeProxyDll(pProxyFileList, pPSFactoryBuffer);
    else
        hr = HRESULT_FROM_WIN32(rc);

    if (SUCCEEDED(hr))
    {
        if((pclsid != 0) && (memcmp(&rclsid, pclsid, sizeof(IID)) == 0))
            fFound = TRUE;
        else
        {
            //Search the list of proxy files.
            fFound = NdrpFindInterface(pProxyFileList, rclsid, 0, 0);
        }

        if(fFound != TRUE)
            hr = CLASS_E_CLASSNOTAVAILABLE;
        else
        {
            // see if they asked for one of our interfaces
            hr = pPSFactoryBuffer->lpVtbl->QueryInterface(
                (IPSFactoryBuffer *)pPSFactoryBuffer, riid, ppv);
        }
    }

    if(FAILED(hr))
        *ppv  = 0;

    return hr;
}

HRESULT RPC_ENTRY
NdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer * pPSFactoryBuffer)
/*++

Routine Description:

Arguments:

Return Value:
    S_OK if DLL reference count is zero
    S_FALSE otherwise

--*/
{
    HRESULT hr;

    if(pPSFactoryBuffer->RefCount == 0)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}


EXTERN_C HRESULT NdrpCreateProxy(
    IN  REFIID              riid,
    IN  IUnknown *          punkOuter,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv)
/*++

Routine Description:
    Create a proxy for the specified interface.

Arguments:
    riid        - Specifies the interface ID.
    punkOuter   - Specifies the controlling unknown.
    ppProxy     - Returns a pointer to the IRpcProxyBuffer interface on the proxy.
    ppv         - Returns a pointer to the interface proxy.

Return Value:
    S_OK
    REGDB_E_IIDNOTREG
    REGDB_E_READREGDB
    REGDB_E_INVALIDVALUE
    E_NOINTERFACE

--*/
{
    HRESULT             hr;
    CLSID               clsid;
    IPSFactoryBuffer *  pFactory;

    hr = (*pfnCoGetPSClsid)(riid, &clsid);

    if(SUCCEEDED(hr))
    {
        hr = (*pfnCoGetClassObject)(clsid,
                                    CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL,
                                    0,
                                    IID_IPSFactoryBuffer,
                                    (void**)&pFactory);

        if(SUCCEEDED(hr))
        {
            hr = pFactory->lpVtbl->CreateProxy(pFactory, punkOuter, riid,  ppProxy, ppv);
            if(SUCCEEDED(hr))
            {
                //Note that CreateProxy increments the reference count on punkOuter.
                //In order to eliminate the circular reference,
                //we release the punkOuter here.
                if((*ppv != 0) && (punkOuter != 0))
                    punkOuter->lpVtbl->Release(punkOuter);
            }
            pFactory->lpVtbl->Release(pFactory);
        }
    }

    if(FAILED(hr))
    {
        *ppProxy = 0;
        *ppv = 0;
    }

    return hr;
}


EXTERN_C HRESULT NdrpCreateStub(
    IN  REFIID              riid,
    IN  IUnknown *          punkServer,
    OUT IRpcStubBuffer **   ppStub)
/*++

Routine Description:
    Create a stub for the specified interface.

Arguments:
    riid        - Species the interface ID.
    punkServer  - Specifies the controlling unknown.
    ppStub      - Returns a pointer to the stub.

Return Value:
    S_OK
    REGDB_E_IIDNOTREG
    REGDB_E_READREGDB
    REGDB_E_INVALIDVALUE
    E_NOINTERFACE

--*/
{
    HRESULT             hr;
    CLSID               clsid;
    IPSFactoryBuffer *  pFactory;

    hr = (*pfnCoGetPSClsid)(riid, &clsid);

    if(SUCCEEDED(hr))
    {
        hr = (*pfnCoGetClassObject)(clsid,
                                    CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL,
                                    0,
                                    IID_IPSFactoryBuffer,
                                    (void**)&pFactory);

        if(SUCCEEDED(hr))
        {
            hr = pFactory->lpVtbl->CreateStub(pFactory, riid, punkServer, ppStub);
            pFactory->lpVtbl->Release(pFactory);
        }
    }

    if(FAILED(hr))
        *ppStub = 0;

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_QueryInterface (
    IN  IPSFactoryBuffer *  This,
    IN  REFIID              iid,
    OUT void **             ppv )
/*++

Routine Description:
    Query for an interface on the PSFactoryBuffer.  The PSFactoryBuffer
    supports the IUnknown and IPSFactoryBuffer interfaces.

Arguments:
    iid - Specifies the interface ID.
    ppv - Returns a pointer to the specified interface.

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    HRESULT hr;

    if ((memcmp(&iid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&iid, &IID_IPSFactoryBuffer, sizeof(IID)) == 0) ||
        (memcmp(&iid, &IID_IPSFactoryHook, sizeof(IID)) == 0))
    {
        *ppv = This;
        This->lpVtbl->AddRef(This);
        hr = S_OK;
    }
    else
    {
        *ppv = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}


ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_AddRef(
    IN  IPSFactoryBuffer *This)
/*++

Routine Description:
    Increment reference count. Since we have a single instance of the
    CStdPSFactoryBuffer per DLL, we can use the PSFactory reference
    count as the DLL reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    InterlockedIncrement(&((CStdPSFactoryBuffer *) This)->RefCount);

    return (unsigned long) ((CStdPSFactoryBuffer *) This)->RefCount;
}

ULONG STDMETHODCALLTYPE
CStdPSFactoryBuffer_Release(
    IN  IPSFactoryBuffer *This)
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG       count;

    NDR_ASSERT(((CStdPSFactoryBuffer *)This)->RefCount > 0, "Invalid reference count");

    count = (ULONG) ((CStdPSFactoryBuffer *)This)->RefCount - 1;

    if(InterlockedDecrement(&((CStdPSFactoryBuffer *)This)->RefCount) == 0)
    {
        count = 0;
    }

    return count;
}



HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_CreateProxy
(
    IN  IPSFactoryBuffer *  This,
    IN  IUnknown *          punkOuter,
    IN  REFIID              riid,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv
)
/*++

Routine Description:
    Create a proxy for the specified interface.

Arguments:
    punkOuter   - Specifies the controlling unknown.
    riid        - Specifies the interface ID.
    ppProxy     - Returns a pointer to the IRpcProxyBuffer interface.
    ppv         - Returns a pointer to the specified interface.

Return Value:
    S_OK
    E_NOINTERFACE
    E_OUTOFMEMORY

--*/
{
    HRESULT             hr;
    BOOL                fFound;
    long                j;
    BOOL                fDelegate = FALSE;
    const ProxyFileInfo *pProxyFileInfo;

    fFound = NdrpFindInterface(((CStdPSFactoryBuffer *)This)->pProxyFileList, riid, &pProxyFileInfo, &j);

    if(fFound != TRUE)
        hr = E_NOINTERFACE;
    else if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
              (ULONG_PTR)pProxyFileInfo->pAsyncIIDLookup[j] == -1 )
        {
        // An attempt to create a sync proxy for an async interface.
        hr = E_NOINTERFACE;
        }
    else
    {
        if((pProxyFileInfo->pDelegatedIIDs != 0) &&
           (pProxyFileInfo->pDelegatedIIDs[j] != 0) &&
           (!IsEqualIID(*pProxyFileInfo->pDelegatedIIDs[j], IID_IUnknown)))
        {
            //Need to delegate to the proxy for the base interface..
            //Allocate memory for the new proxy buffer.
            CStdProxyBuffer2 *pProxyBuffer =
                (CStdProxyBuffer2*)(*pfnCoTaskMemAlloc)(sizeof(CStdProxyBuffer2));

            if(0 == pProxyBuffer)
                hr = E_OUTOFMEMORY;
            else
            {
                hr = S_OK;

                //Initialize the new proxy buffer.
                memset(pProxyBuffer, 0, sizeof(CStdProxyBuffer2));

                pProxyBuffer->lpVtbl = &CStdProxyBuffer2Vtbl;
                pProxyBuffer->RefCount = 1;
                pProxyBuffer->punkOuter = punkOuter ? punkOuter : (IUnknown *) pProxyBuffer;
                pProxyBuffer->pProxyVtbl = &pProxyFileInfo->
                                               pProxyVtblList[j]->Vtbl;
                if ( pProxyFileInfo->TableVersion < 2 )
                    pProxyBuffer->pRMBVtbl = NULL;
                else
                    pProxyBuffer->pRMBVtbl = &CStdProxyBuffer_ReleaseMarshalBuffersVtbl;

                if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                     pProxyFileInfo->pAsyncIIDLookup[j] != 0 )
                    {
                    // The interface has an async counterpart.
                    pProxyBuffer->pCallFactoryVtbl = & CStdProxyBuffer2_CallFactoryVtbl;
                    pProxyBuffer->pAsyncIID = pProxyFileInfo->pAsyncIIDLookup[j];
                    pProxyBuffer->pRMBVtbl = &CStdAsyncProxyBuffer_ReleaseMarshalBuffersVtbl;
                    }

                //
                // Proxies after NT 3.51 Beta have a ProxyHeader 4 bytes
                // larger to support stubless proxies.  So in older proxies
                // subtract 4 bytes to get the the Vtable.
                //
                if ( pProxyFileInfo->TableVersion < 2 )
                    pProxyBuffer->pProxyVtbl = (void *)
                                      ((char *)pProxyBuffer->pProxyVtbl - PTR_MEM_SIZE);



                //Increment the DLL reference count for DllCanUnloadNow.
                This->lpVtbl->AddRef(This);
                pProxyBuffer->pPSFactory = This;

                pProxyBuffer->iidBase = *pProxyFileInfo->pDelegatedIIDs[j];

                //Create a proxy for the base interface.
                hr = NdrpCreateProxy(*pProxyFileInfo->pDelegatedIIDs[j],
                                     (IUnknown *) pProxyBuffer,
                                     &pProxyBuffer->pBaseProxyBuffer,
                                     (void**)&pProxyBuffer->pBaseProxy);

                if(FAILED(hr))
                    {
                    (*pfnCoTaskMemFree)(pProxyBuffer);
                    }
                else
                    {
                    *ppProxy = (IRpcProxyBuffer *) pProxyBuffer;
                    *ppv = (void *) &pProxyBuffer->pProxyVtbl;
                    ((IUnknown *) *ppv)->lpVtbl->AddRef((IUnknown *) *ppv);
                    }
            }
        }
        else
        {
            //Allocate memory for the new proxy buffer.
            CStdProxyBuffer *pProxyBuffer =
                (CStdProxyBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdProxyBuffer));

            if(0 == pProxyBuffer)
                hr = E_OUTOFMEMORY;
            else
            {
                hr = S_OK;

                //Initialize the new proxy buffer.
                memset(pProxyBuffer, 0, sizeof(CStdProxyBuffer));

                pProxyBuffer->lpVtbl = &CStdProxyBufferVtbl;
                pProxyBuffer->RefCount = 1;
                pProxyBuffer->punkOuter = punkOuter ? punkOuter : (IUnknown *) pProxyBuffer;

                pProxyBuffer->pProxyVtbl = &pProxyFileInfo->
                                               pProxyVtblList[j]->Vtbl;

                if ( pProxyFileInfo->TableVersion < 2 )
                    pProxyBuffer->pRMBVtbl = NULL;
                else
                    pProxyBuffer->pRMBVtbl = &CStdProxyBuffer_ReleaseMarshalBuffersVtbl;


                if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                     pProxyFileInfo->pAsyncIIDLookup[j] != 0 )
                    {
                    pProxyBuffer->pCallFactoryVtbl = & CStdProxyBuffer_CallFactoryVtbl;
                    pProxyBuffer->pAsyncIID = pProxyFileInfo->pAsyncIIDLookup[j];
                    pProxyBuffer->pRMBVtbl = &CStdAsyncProxyBuffer_ReleaseMarshalBuffersVtbl;
                    }

                //
                // Proxies after NT 3.51 Beta have a ProxyHeader 4 bytes
                // larger to support stubless proxies.  So in older proxies
                // subtract 4 bytes to get the the Vtable.
                //
                if ( pProxyFileInfo->TableVersion < 2 )
                    pProxyBuffer->pProxyVtbl = (void *)
                               ((char*)pProxyBuffer->pProxyVtbl - PTR_MEM_SIZE);

                //Increment the DLL reference count for DllCanUnloadNow.
                This->lpVtbl->AddRef(This);
                pProxyBuffer->pPSFactory = This;

                *ppProxy = (IRpcProxyBuffer *) pProxyBuffer;
                *ppv = (void *) &pProxyBuffer->pProxyVtbl;
                ((IUnknown *) *ppv)->lpVtbl->AddRef((IUnknown *) *ppv);
            }
        }
    }

    if(FAILED(hr))
    {
        *ppProxy = 0;
        *ppv = 0;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_CreateStub
(
    IN  IPSFactoryBuffer *  This,
    IN  REFIID              riid,
    IN  IUnknown *          punkServer,
    OUT IRpcStubBuffer **   ppStub
)
/*++

Routine Description:
    Create a stub for the specified interface.

Arguments:

Return Value:

--*/
{
    HRESULT                 hr;
    const ProxyFileInfo *   pProxyFileInfo;
    long                    j;

    BOOL fFound = NdrpFindInterface(((CStdPSFactoryBuffer *)This)->pProxyFileList,
                                    riid,
                                    &pProxyFileInfo,
                                    &j);

    if(fFound != TRUE)
        hr = E_NOINTERFACE;
    else if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
              (ULONG_PTR)pProxyFileInfo->pAsyncIIDLookup[j] == -1 )
        {
        // An attempt to create a sync stub for an async interface.
        hr = E_NOINTERFACE;
        }
    else
    {
        if((pProxyFileInfo->pDelegatedIIDs != 0) &&
           (pProxyFileInfo->pDelegatedIIDs[j] != 0) &&
           (!IsEqualIID(*pProxyFileInfo->pDelegatedIIDs[j], IID_IUnknown)))
        {
            IUnknown *              punkForward;

            //We need to delegate to the stub for the base interface.
            CStdStubBuffer2 *pStubBuffer =
                (CStdStubBuffer2*)(*pfnCoTaskMemAlloc)(sizeof(CStdStubBuffer2));

            if(0 == pStubBuffer)
                hr = E_OUTOFMEMORY;
            else
            {
                void ** pForwardingVtbl;
                GetTemplateForwardVtbl(&pForwardingVtbl);
                //Initialize the new stub buffer.
                memset(pStubBuffer, 0, sizeof(CStdStubBuffer2));

                pStubBuffer->lpForwardingVtbl = pForwardingVtbl;
                pStubBuffer->lpVtbl = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
                pStubBuffer->RefCount= 1;
                pStubBuffer->pPSFactory = This;
                if ( pProxyFileInfo->TableVersion < 2 )
                    pStubBuffer->pRMBVtbl = NULL;
                else
                    pStubBuffer->pRMBVtbl = &CStdStubBuffer_ReleaseMarshalBuffersVtbl;

                if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                     pProxyFileInfo->pAsyncIIDLookup[j] != 0 )
                    {
                    pStubBuffer->pCallFactoryVtbl = &CStdStubBuffer2_CallFactoryVtbl;
                    pStubBuffer->pAsyncIID = pProxyFileInfo->pAsyncIIDLookup[j];
                    pStubBuffer->pRMBVtbl = &CStdAsyncStubBuffer_ReleaseMarshalBuffersVtbl;
                    }

                //Increment the DLL reference count for DllCanUnloadNow.
                This->lpVtbl->AddRef(This);
                *ppStub = (IRpcStubBuffer *) &pStubBuffer->lpVtbl;

                 //Connect the stub to the server object.
                if(punkServer != 0)
                {
                    hr = punkServer->lpVtbl->QueryInterface(
                        punkServer,
                        riid,
                        (void**)&pStubBuffer->pvServerObject);
                }
                else
                {
                    hr = S_OK;
                }

                if(SUCCEEDED(hr))
                {
                    if(punkServer != 0)
                        punkForward = (IUnknown *) &pStubBuffer->lpForwardingVtbl;
                    else
                        punkForward = 0;

                    //Create a stub for the base interface
                    hr = NdrpCreateStub(*pProxyFileInfo->pDelegatedIIDs[j],
                                        punkForward,
                                        &pStubBuffer->pBaseStubBuffer);
                }

                if(FAILED(hr))
                {
                    ReleaseTemplateForwardVtbl(pForwardingVtbl);
                    (*pfnCoTaskMemFree)(pStubBuffer);
                }
            }
        }
        else
        {
            //Create an ordinary stub buffer.
            CStdStubBuffer *pStubBuffer =
                (CStdStubBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdStubBuffer));

            if(0 == pStubBuffer)
                hr = E_OUTOFMEMORY;
            else
            {
                //Initialize the new stub buffer.
                memset(pStubBuffer, 0, sizeof(CStdStubBuffer));

                pStubBuffer->lpVtbl = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
                pStubBuffer->RefCount= 1;
                pStubBuffer->pPSFactory = This;

                if ( pProxyFileInfo->TableVersion < 2 )
                    pStubBuffer->pRMBVtbl = NULL;
                else
                    pStubBuffer->pRMBVtbl = &CStdStubBuffer_ReleaseMarshalBuffersVtbl;

                if ( (pProxyFileInfo->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)  &&
                     pProxyFileInfo->pAsyncIIDLookup[j] != 0 )
                    {
                    pStubBuffer->pCallFactoryVtbl = &CStdStubBuffer_CallFactoryVtbl;
                    pStubBuffer->pAsyncIID = pProxyFileInfo->pAsyncIIDLookup[j];
                    pStubBuffer->pRMBVtbl = &CStdAsyncStubBuffer_ReleaseMarshalBuffersVtbl;
                    }

                if(0 == punkServer)
                    hr = S_OK;
                else
                {
                    hr = punkServer->lpVtbl->QueryInterface(
                        punkServer,
                        riid,
                        (void**)&pStubBuffer->pvServerObject);
                }

                if(SUCCEEDED(hr))
                {
                    //Increment the DLL reference count for DllCanUnloadNow.
                    This->lpVtbl->AddRef(This);
                    *ppStub = (IRpcStubBuffer *) pStubBuffer;
                }
                else
                {
                    (*pfnCoTaskMemFree)(pStubBuffer);
                }
            }
        }
    }

    if(FAILED(hr))
        *ppStub = 0;

    return hr;
}

HRESULT STDMETHODCALLTYPE
CStdPSFactoryBuffer_HkGetProxyFileInfo
(
    IN  IPSFactoryBuffer    *This,
    IN  REFIID              riid,
    OUT PINT                pOffset,
    OUT PVOID               *ppProxyFileInfo
)

/*++

Routine Description:

    This function returns the proxy information for a particular
    interface.  HookOle requires information such as the number
    of methods in the vtable and a pointer to the
    StublessProxyInfo structure.


Arguments:

    This - This pointer for the proxy object.
    riid - IID of the interface we are asking about.
    pOffset - Offset into the ProxyFileInfo lists for this
        particular interface.
    ppProxyFileInfo - Pointer to location where a pointer to the
        ProxyFileInfo structure can be stored.

Return Value:


--*/
{
    HRESULT         hr=E_NOINTERFACE;
    ProxyFileInfo   *pProxyFileInfo=NULL;

    //
    // Find the index into the FileList for this iid.
    //
    if (NdrpFindInterface(
        ((CStdPSFactoryBuffer *)This)->pProxyFileList,
        riid,
        (const ProxyFileInfo**)&pProxyFileInfo,
        (long*)pOffset)) {

        *ppProxyFileInfo = (PVOID)pProxyFileInfo;
        hr = S_OK;
    }

    return(hr);
}

// initialize mutex, and return error instead of throwing. In OLE world, people 
// expect error code instead of exception.
HRESULT 
NdrpInitializeMutex( I_RPC_MUTEX * pMutex )
{
    RPC_STATUS rc = RPC_S_OK;
    NDR_ASSERT( *pMutex == NULL, "pMutex should be NULL to be initialized" );

    // 
    __try
        {
        I_RpcRequestMutex( pMutex );
        I_RpcClearMutex( *pMutex );
        }
    __except( EXCEPTION_EXECUTE_HANDLER )
        {
        // we want to catch all the exception here in OLE land
        rc = RpcExceptionCode();
        }

    return HRESULT_FROM_WIN32( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\fullptr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    fullptr.c

Abstract :

    This file contains the APIs for handling full pointers in the NDR engine
    and inlined stubs for MIDL 2.0.

Author :

    David Kays  dkays   January 1994.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"

static void 
NdrFullPointerXlatRealloc ( PFULL_PTR_XLAT_TABLES pXlatTables, ulong RefId );


PFULL_PTR_XLAT_TABLES RPC_ENTRY
NdrFullPointerXlatInit( 
    ulong       NumberOfPointers,
    XLAT_SIDE   XlatSide )
/***

Routine description :

    Allocates full pointer support data structures for an RPC call.

Arguments :

    NumberOfPointer - If possible, the stub passes in the total number
                      of possible full pointers that will be used during a call.

Return value :

    A pointer to the full pointer translations tables used during an rpc call.

 ***/
{
    PFULL_PTR_XLAT_TABLES   pXlatTables;
    uint                    RefIdToPointerEntries;
    uint                    PointerToRefIdBuckets;
    BOOL                    fOutOfMemory = FALSE;

    pXlatTables = (PFULL_PTR_XLAT_TABLES) 
                  I_RpcAllocate(sizeof(FULL_PTR_XLAT_TABLES));

    // Because old compilers didn't initialize the xlat ptr in stubmsg
    // at the client in Os mode, we cannot raise exception right away.

    if ( ! pXlatTables )
        fOutOfMemory = TRUE;
    else
        {
        //
        // Determine the size of both translation tables.
        //
        if ( NumberOfPointers )
            {
            ulong       Shift, Bitmask;
    
            RefIdToPointerEntries = (uint) NumberOfPointers;
    
            //
            // Find the smallest power of 2 which is greater than
            // RefIdToPointerEntries.
            //
            for ( Shift = 0, Bitmask = 0x80000000;
                  ! (Bitmask & (ulong) RefIdToPointerEntries);
                  Shift++, Bitmask >>= 1 )
                ;
    
            PointerToRefIdBuckets = (uint)((0xffffffff >> Shift) + 1);
            }
        else
            {
            RefIdToPointerEntries = DEFAULT_REF_ID_TO_POINTER_TABLE_ELEMENTS;
            PointerToRefIdBuckets = DEFAULT_POINTER_TO_REF_ID_TABLE_BUCKETS;
            }
    
        // Make sure we can clean up correctly later if case of an exception.
    
        pXlatTables->RefIdToPointer.XlatTable  = 0;
        pXlatTables->RefIdToPointer.StateTable = 0;
        pXlatTables->PointerToRefId.XlatTable  = 0;
        pXlatTables->RefIdToPointer.NumberOfEntries = 0;
        pXlatTables->PointerToRefId.NumberOfBuckets = 0;
    
        //
        // Initialize the ref id to pointer tables.
        //
        pXlatTables->RefIdToPointer.XlatTable =
            (void **) I_RpcAllocate( RefIdToPointerEntries * sizeof(void *) );
    
        if ( ! pXlatTables->RefIdToPointer.XlatTable )
            fOutOfMemory = TRUE;
        else
            {
            MIDL_memset( pXlatTables->RefIdToPointer.XlatTable,
                         0,
                         RefIdToPointerEntries * sizeof(void *) );
    
            pXlatTables->RefIdToPointer.StateTable =
                (uchar *) I_RpcAllocate( RefIdToPointerEntries * sizeof(uchar) );
        
            if ( ! pXlatTables->RefIdToPointer.StateTable )
                fOutOfMemory = TRUE;
            else
                {
                MIDL_memset( pXlatTables->RefIdToPointer.StateTable,
                             0,
                             RefIdToPointerEntries * sizeof(uchar) );
        
                pXlatTables->RefIdToPointer.NumberOfEntries = RefIdToPointerEntries;
            
                //
                // Intialize the pointer to ref id tables.
                //
                pXlatTables->PointerToRefId.XlatTable =
                    (PFULL_PTR_TO_REFID_ELEMENT *) 
                    I_RpcAllocate( PointerToRefIdBuckets * 
                                   sizeof(PFULL_PTR_TO_REFID_ELEMENT) );
            
                if ( ! pXlatTables->PointerToRefId.XlatTable )
                    fOutOfMemory = TRUE;
                else
                    {
                    MIDL_memset( pXlatTables->PointerToRefId.XlatTable,
                                 0,
                                 PointerToRefIdBuckets * sizeof(PFULL_PTR_TO_REFID_ELEMENT) );
                    }
                }
            }
        }

    if ( fOutOfMemory )
        {
        NdrFullPointerXlatFree( pXlatTables );

        if ( XlatSide == XLAT_SERVER )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );
        else
            {
            // The old compilers generate a code for the client side that
            // doesn't initialize the table pointer and the stub msg
            // initialization is after call to xlat initialize.
            // So, we are down to checking the pointer when used.

            return( 0 );
            }
        }

    pXlatTables->PointerToRefId.NumberOfBuckets = PointerToRefIdBuckets;
    pXlatTables->PointerToRefId.HashMask = PointerToRefIdBuckets - 1;

    pXlatTables->NextRefId = 1;

    pXlatTables->XlatSide = XlatSide;

    return pXlatTables;
}


void RPC_ENTRY
NdrFullPointerXlatFree( 
    PFULL_PTR_XLAT_TABLES pXlatTables )
/*** 

Routine description :

    Free the full pointer support data structures for an rpc call.

Arguments :

    pXlatTables        - Full pointer translation tables data structure to free.

 ***/
{
    PFULL_PTR_TO_REFID_ELEMENT *    HashTable;
    PFULL_PTR_TO_REFID_ELEMENT      pElement, pTemp;
    ulong                           Buckets;
    ulong                           i;

    if ( ! pXlatTables )
        return;

    //
    // Free the ref id to pointer tables.
    //
    if ( pXlatTables->RefIdToPointer.XlatTable )
        I_RpcFree( pXlatTables->RefIdToPointer.XlatTable );

    if ( pXlatTables->RefIdToPointer.StateTable )
        I_RpcFree( pXlatTables->RefIdToPointer.StateTable );

    //
    // Free the pointer to ref id table.
    //
    HashTable = pXlatTables->PointerToRefId.XlatTable;

    if ( HashTable )
        {
        Buckets = pXlatTables->PointerToRefId.NumberOfBuckets;
    
        for ( i = 0; i < Buckets; i++ )
            if ( HashTable[i] )
                for ( pElement = HashTable[i]; pElement; pElement = pTemp )
                    {
                    pTemp = pElement->Next;
    
                    I_RpcFree(pElement);
                    }
    
        I_RpcFree( HashTable );
        }

    //
    // Free the translation table structure.
    //
    I_RpcFree( pXlatTables );
}


int RPC_ENTRY
NdrFullPointerQueryPointer( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void *                  pPointer,
    uchar                   QueryType,
    ulong *                 pRefId )
/***

Routine description :

    This routine checks if a full pointer is in the full pointer translation 
    table and is marked with the given state.

    If there is no current translation for this pointer then a translation is 
    inserted in the given translation table and a ref id is assigned if pRefId
    is non-null.  

Arguments :

    pXlatTable  - The full pointer translation tables.
    pPointer    - The pointer to check.
    QueryType   - The type of query, either FULL_POINTER_MARSHALLED or 
                    FULL_POINTER_BUF_SIZED.
    pRefId      - The ref id for the pointer is returned if this parameter 
                    is non-null.

Return Value :

    TRUE if the given pointer was null or a translation for the full pointer 
    was found and had the QueryType set, FALSE otherwise.

    A return value of FALSE indicates that the pointee should be sized or 
    marshalled.

 ***/
{
    PFULL_PTR_TO_REFID_ELEMENT *    HashTable;
    PFULL_PTR_TO_REFID_ELEMENT      pElement;
    ulong                           HashTableIndex;

    if ( ! pPointer ) 
        {
        if ( pRefId )
            *pRefId = 0;

        return TRUE;
        }

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    HashTable = pXlatTables->PointerToRefId.XlatTable;

    //
    // Lookup pPointer in PointerToRefId table.
    //

    HashTableIndex = PTR_HASH( pPointer, pXlatTables->PointerToRefId.HashMask );

    for (  pElement = HashTable[HashTableIndex]; 
           pElement;  
           pElement = pElement->Next ) 
        {
        if ( pElement->Pointer == pPointer ) 
            {
            if ( CHECK_FULL_POINTER_STATE( pElement->State, QueryType ) ) 
                {
                if ( pRefId )
                    *pRefId = pElement->RefId;

                return TRUE;
                }
            else 
                {
                //
                // Assign a ref id now if it doesn't have one and pRefId is 
                // non null.
                //
                if ( pRefId && ! pElement->RefId ) 
                    pElement->RefId = pXlatTables->NextRefId++;

                SET_FULL_POINTER_STATE( pElement->State, QueryType ); 
                }
            break;
            }
        }

    //
    // If there is no translation for the pointer then insert a new one.
    //
    if ( ! pElement ) 
        {
        pElement = (PFULL_PTR_TO_REFID_ELEMENT) 
                   I_RpcAllocate( sizeof(FULL_PTR_TO_REFID_ELEMENT) );

        if ( ! pElement )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        pElement->State = 0;

        SET_FULL_POINTER_STATE( pElement->State, QueryType );

        pElement->Pointer = pPointer;

        if ( pRefId )
            pElement->RefId = pXlatTables->NextRefId++;
        else
            pElement->RefId = 0;

        pElement->Next = HashTable[HashTableIndex];
        HashTable[HashTableIndex] = pElement;
        }

    //
    // Set the ref id return value.
    //
    if ( pRefId )
        {
        //
        // We get here the first time we marshall a new full pointer.
        //
        *pRefId = pElement->RefId;

        //
        // We insert the reverse translation if we're on the client side.
        //
        if ( pXlatTables->XlatSide == XLAT_CLIENT )
            {
            if ( *pRefId >= pXlatTables->RefIdToPointer.NumberOfEntries ) 
                NdrFullPointerXlatRealloc( pXlatTables, *pRefId );

            pXlatTables->RefIdToPointer.XlatTable[*pRefId] = pPointer;
            }
        }

    return FALSE;
}


int RPC_ENTRY
NdrFullPointerQueryRefId( 
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    ulong                   RefId,
    uchar                   QueryType,
    void **                 ppPointer )
/***

Routine description :

    This routine checks if a ref id is in the full pointer translation table
    and is marked with the given state.

    If a translation is found and ppPointer is non-null then *ppPointer is set
    to the value of the ref id's pointer value.

    If this routine returns FALSE for a FULL_POINTER_UNMARSHALLED query then 
    the full pointer should be allocated and a call to 
    NdrFullPointerInsertRefId must be made. 

    If this routine returns FALSE for a FULL_POINTER_MEM_SIZED query then 
    the size of the full pointer's pointee should be added to the current 
    memory sizing calculation.

Arguments :

    pXlatTable   - The full pointer translation tables.
    pRefId       - The ref id to search for.
    QueryType    - The type of query, either FULL_POINTER_UNMARSHALLED or
                    FULL_POINTER_MEM_SIZED.
    ppPointer    - Holds the returned pointer value for the ref id if it is 
                    found.

Return Value :

    TRUE if the ref id is 0 or a translation for the ref id is found and had 
    the QueryType set, FALSE otherwise.

    A return value of FALSE indicates that the pointee should be sized or 
    unmarshalled.

 ***/
{
    uchar *     StateTable;
    void *      Pointer;

    if ( ! RefId ) 
        {
        return TRUE;
        }

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    if ( RefId >= pXlatTables->NextRefId )
        pXlatTables->NextRefId = RefId + 1;

    if ( RefId >= pXlatTables->RefIdToPointer.NumberOfEntries ) 
        NdrFullPointerXlatRealloc( pXlatTables, RefId );

    StateTable = pXlatTables->RefIdToPointer.StateTable;

    Pointer = pXlatTables->RefIdToPointer.XlatTable[RefId];

    //
    // We make this check first.  It's possible that we will already have
    // a translation for the ref id, but it simply won't be marked yet with
    // the proper state.  In this case we still want to return the correct
    // pointer value from the translation tables, but we'll still end up 
    // returning false when we make the state check.
    //
    if ( ppPointer )
        {
        // 
        // We have to make sure and always copy the pointer's value from
        // the table.  This way we handle the case when a pointer's VALUE 
        // changes to a pointer which has a currently valid RefId (an 
        // example of this could happen when a server swaps the values of 
        // two [in,out] double pointers).
        //
        // Pointer will be null if this is the first time we've seen or used
        // this ref id.
        //
        *ppPointer = Pointer;
        }

    if ( CHECK_FULL_POINTER_STATE( StateTable[RefId], QueryType ) )
        {
        return TRUE;
        }
    else
        {
        SET_FULL_POINTER_STATE( StateTable[RefId], QueryType );
    
        return FALSE;
        }
}


void RPC_ENTRY
NdrFullPointerInsertRefId( 
    PFULL_PTR_XLAT_TABLES     pXlatTables,
    ulong                     RefId,
    void *                    pPointer )
/***

Routine description :

    This routine inserts a ref id to pointer translation in the full pointer
    translation table.

Arguments :

    pXlatTable    - The full pointer translation tables.
    pRefId        - The ref id. 
    pPointer      - The pointer. 

Return Value :

    None.

 ***/
{
    // unused: uchar *        StateTable;

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    // 
    // Ref id should be non-zero.
    //
    NDR_ASSERT( RefId, "NdrFullPointerInsertRefId : Ref id is zero" ); 

    //
    // Ref id should fit in the current table.
    //
    NDR_ASSERT( RefId < pXlatTables->RefIdToPointer.NumberOfEntries,
                "NdrFullPointerInsertRefId : Ref Id too large" );

    //
    // There should currently be no pointer translation for this ref id.
    //
    NDR_ASSERT( ! pXlatTables->RefIdToPointer.XlatTable[RefId],
                "NdrFullPointerInsertRefId : Translation already exists" );

    //
    // Insert the translation.
    //
    pXlatTables->RefIdToPointer.XlatTable[RefId] = pPointer;

    //
    // If we're on the server side then insert the inverse translation.
    //
    if ( pXlatTables->XlatSide == XLAT_SERVER )
        {
        PFULL_PTR_TO_REFID_ELEMENT  pElement;
        long                        HashTableIndex;

        pElement = (PFULL_PTR_TO_REFID_ELEMENT) 
                   I_RpcAllocate( sizeof(FULL_PTR_TO_REFID_ELEMENT) );

        if ( ! pElement )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        pElement->State = 0;
        pElement->Pointer = pPointer;
        pElement->RefId = RefId;

        HashTableIndex = PTR_HASH( pPointer, 
                                   pXlatTables->PointerToRefId.HashMask );

        pElement->Next = pXlatTables->PointerToRefId.XlatTable[HashTableIndex];
        pXlatTables->PointerToRefId.XlatTable[HashTableIndex] = pElement;
        }
}


int RPC_ENTRY
NdrFullPointerFree( 
    PFULL_PTR_XLAT_TABLES     pXlatTables,
    void *                    pPointer )
/*** 

Routine description :

    Removes a full pointer from the translation tables, and frees it's 
    associated translation data.

Return value :

    TRUE if the pointer has not yet been freed or is null, FALSE otherwise.

 ***/
{
    PFULL_PTR_TO_REFID_ELEMENT *    HashTable;
    PFULL_PTR_TO_REFID_ELEMENT      pElement; 
    ulong                           HashTableIndex;

    if ( ! pPointer ) 
         return FALSE;

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    HashTable = pXlatTables->PointerToRefId.XlatTable;

    //
    // Lookup pPointer in PointerToRefId table.
    //

    HashTableIndex = PTR_HASH( pPointer, pXlatTables->PointerToRefId.HashMask );

    for ( pElement = HashTable[HashTableIndex]; 
          pElement;   
          pElement = pElement->Next ) 
        {
        if ( pElement->Pointer == pPointer ) 
            {
            if ( CHECK_FULL_POINTER_STATE(pElement->State,FULL_POINTER_FREED) )
                {
                return FALSE;
                }
            else
                {
                SET_FULL_POINTER_STATE(pElement->State,FULL_POINTER_FREED);
                return TRUE;
                }
            }
        }

    //
    // There is an instance when a full pointer is encountered for the first
    // time during freeing.  This occurs if an [in] full pointer is changed
    // by the server manager routine.  If this occurs we must insert the new
    // full pointer so we can keep track of it so that we don't free it more
    // than once.
    //

    pElement = (PFULL_PTR_TO_REFID_ELEMENT)
               I_RpcAllocate( sizeof(FULL_PTR_TO_REFID_ELEMENT) );

    if ( ! pElement )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    pElement->State = 0;
    pElement->Pointer = pPointer;

    HashTableIndex = PTR_HASH( pPointer,
                               pXlatTables->PointerToRefId.HashMask );

    pElement->Next = pXlatTables->PointerToRefId.XlatTable[HashTableIndex];
    pXlatTables->PointerToRefId.XlatTable[HashTableIndex] = pElement;

    SET_FULL_POINTER_STATE( pElement->State, FULL_POINTER_FREED );

    return TRUE;
}


static void
NdrFullPointerXlatRealloc( 
    PFULL_PTR_XLAT_TABLES pXlatTables,
    ulong   RefId)
{
    void *  pMemory;
    uint    Entries;

    if ( ! pXlatTables )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    Entries = (uint) pXlatTables->RefIdToPointer.NumberOfEntries;

    // If the number is much larger than the previous one, most likely the
    // number is invalid. Before we have a concrete solution to replace the
    // current fixed array of RefIdToPointer lookup, this can catch most 
    // of the failures. 
    if ( RefId >= 2 * Entries )
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
    //
    // Realloc RefIdToPointerTable.  Allocate twice as many entries.
    //
    pMemory = I_RpcAllocate( Entries * sizeof(void *) * 2 );

    if ( ! pMemory )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    //
    // Now copy the current entries into the new memory.
    //
    RpcpMemoryCopy( pMemory,
                    pXlatTables->RefIdToPointer.XlatTable,
                    Entries * sizeof( void * ) );

    //
    // Set the new entries to 0.
    //
    MIDL_memset( (char *) pMemory + Entries * sizeof( void *),
                 0,
                 Entries * sizeof( void *) );

    //
    // Free the old table.
    //
    I_RpcFree( pXlatTables->RefIdToPointer.XlatTable );

    //
    // Get the new table.
    //
    pXlatTables->RefIdToPointer.XlatTable = (void**)pMemory;

    //
    // Realloc RefIdToPointerState
    //
    pMemory = I_RpcAllocate( Entries * sizeof(uchar) * 2 );

    if ( ! pMemory )
        RpcRaiseException( RPC_S_OUT_OF_MEMORY );

    //
    // Now copy the current entries into the new memory.
    //
    RpcpMemoryCopy( pMemory,
                    pXlatTables->RefIdToPointer.StateTable,
                    Entries * sizeof(uchar) );

    //
    // Set the new entries to 0.
    //
    MIDL_memset( (char *) pMemory + Entries * sizeof(uchar),
                 0,
                 Entries * sizeof(uchar) );

    //
    // Free the old table.
    //
    I_RpcFree( pXlatTables->RefIdToPointer.StateTable );

    //
    // Get the new table.
    //
    pXlatTables->RefIdToPointer.StateTable = (uchar*)pMemory;

    //
    // Update number of entries.
    //
    pXlatTables->RefIdToPointer.NumberOfEntries *= 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\free.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    free.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the 
    interpreter for freeing unmarshalled data on the server. 

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

RPCRTAPI
void
RPC_ENTRY
NdrpNoopFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char *     pMemory,
    PFORMAT_STRING      pFormat
    );


//
// Free routine table.
//
extern const
PFREE_ROUTINE   FreeRoutinesTable[] = 
                {
                NdrpNoopFree,                        // 0x00
                NdrpNoopFree,                        // 0x01
                NdrpNoopFree,                        // 0x02
                NdrpNoopFree,                        // 0x03
                NdrpNoopFree,                        // 0x04
                NdrpNoopFree,                        // 0x05
                NdrpNoopFree,                        // 0x06
                NdrpNoopFree,                        // 0x07
                NdrpNoopFree,                        // 0x08
                NdrpNoopFree,                        // 0x09
                NdrpNoopFree,                        // 0x0A
                NdrpNoopFree,                        // 0x0B
                NdrpNoopFree,                        // 0x0C
                NdrpNoopFree,                        // 0x0D
                NdrpNoopFree,                        // 0x0E
                NdrpNoopFree,                        // 0x0F
                NdrpNoopFree,                        // 0x10
                                                     
                NdrPointerFree,                      // 0x11
                NdrPointerFree,                      // 0x12
                NdrPointerFree,                      // 0x13
                NdrPointerFree,                      // 0x14

                NdrpNoopFree,                        // 0x15 Simple struct
                NdrSimpleStructFree,                 // 0x16
                NdrpNoopFree,                        // 0x17 Conformant struct
                NdrConformantStructFree,             // 0x18
                NdrConformantVaryingStructFree,      // 0x19

                NdrComplexStructFree,                // 0x1A

                NdrConformantArrayFree,              // 0x1B
                NdrConformantVaryingArrayFree,       // 0x1C

                NdrFixedArrayFree,                   // 0x1D
                NdrFixedArrayFree,                   // 0x1E
                NdrVaryingArrayFree,                 // 0x1F Small varying array
                NdrVaryingArrayFree,                 // 0x20 Large varying array

                NdrComplexArrayFree,                 // 0x21

                NdrpNoopFree,                        // 0x22 Conformant string
                NdrpNoopFree,                        // 0x23 Conformant string
                NdrpNoopFree,                        // 0x24 Conformant string
                NdrpNoopFree,                        // 0x25 Conformant string

                NdrpNoopFree,                        // 0x26 NonConformant string
                NdrpNoopFree,                        // 0x27 NonConformant string
                NdrpNoopFree,                        // 0x28 NonConformant string
                NdrpNoopFree,                        // 0x29 NonConformant string

                NdrEncapsulatedUnionFree,            // 0x2A 
                NdrNonEncapsulatedUnionFree,         // 0x2B 

                NdrByteCountPointerFree,             // 0x2C 

                NdrXmitOrRepAsFree,                  // 0x2D transmit as 
                NdrXmitOrRepAsFree,                  // 0x2E represent as

                NdrPointerFree,                      // 0x2F

                NdrpNoopFree,                        // 0x30 Context handle

                // New Post NT 3.5 token serviced from here on.

                NdrpNoopFree,                        // 0x31 NdrHardStructFree,

                NdrXmitOrRepAsFree,                  // 0x32 transmit as ptr
                NdrXmitOrRepAsFree,                  // 0x33 represent as ptr

                NdrUserMarshalFree,                  // 0x34

                NdrpNoopFree,                        // 0x35 FC_PIPE 
                NdrpNoopFree,                        // 0x36 FC_BLK_HOLE

                NdrpRangeFree,                       // 0x37

                NdrpNoopFree,                        // 0x38
                NdrpNoopFree,                        // 0x39
                NdrpNoopFree,                        // 0x3A
                NdrpNoopFree,                        // 0x3B
                NdrpNoopFree,                        // 0x3C
                NdrpNoopFree,                        // 0x3D
                NdrpNoopFree,                        // 0x3E
                NdrpNoopFree,                        // 0x3F

                };

extern const
PFREE_ROUTINE * pfnFreeRoutines = FreeRoutinesTable;

RPCRTAPI
void RPC_ENTRY
NdrTypeFree(PMIDL_STUB_MESSAGE                   pStubMsg,
			unsigned char __RPC_FAR *            pMemory,
			PFORMAT_STRING                       pFormat )
{
	if (pfnFreeRoutines[ROUTINE_INDEX(*pFormat)])
	{
		(*pfnFreeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
													 pMemory,
													 pFormat );
	}
}


void RPC_ENTRY
NdrpNoopFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a top level or embedded simple type.

    Used for VT_USERDEFINED but in fact simple types,
    like TKIND_ENUM and TKIND_ALIAS

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    return;
}

inline void
NdrFreeTypeMemory( 
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory )
{

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {
        (*pStubMsg->pfnFree)(pMemory);
        }
    else
        {
        NDR_PFNFREE_POINTER_QUEUE_ELEMENT*pElement = 
            new(pStubMsg->pPointerQueueState) 
                NDR_PFNFREE_POINTER_QUEUE_ELEMENT(pStubMsg->pfnFree,
                                                  pMemory );
        pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );

        }
}




__forceinline void 
NdrPointerFreeInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a top level or embedded pointer to anything.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatPointee;
    uchar *         pMemoryPointee;

    pMemoryPointee = pMemory;

    if ( ! pMemory )
        return;

    switch( *pFormat )
        {
        case FC_FP:
            //
            // Check if we've already freed this full pointer.
            //
            if ( ! NdrFullPointerFree( pStubMsg->FullPtrXlatTables,
                                       pMemory ) )
                return;
            break;

        case FC_IP:
            if(pMemory != 0)
                {
                ((IUnknown *)pMemory)->Release();
                pMemory = 0;
                }
            return;
        default:
            break;
        }

    if ( pFormat[1] == 0 )
        goto FreeEmbeddedPointers;

    //
    // Check if this pointer and any possible embedded pointers should not
    // be freed.
    //
    if ( DONT_FREE(pFormat[1]) )
        return;

    // 
    // Just go free a pointer to a simple type.
    //
    if ( SIMPLE_POINTER(pFormat[1]) ) 
        goto FreeTopPointer;

    // 
    // Check if this is an allocate all nodes pointer.  
    // IDL symantics say that we only free the top most allocate all nodes
    // pointer on the server even in the [out] only case.  So jump to the 
    // check for the pointer free at the end of the routine.  
    //  
    if ( ALLOCATE_ALL_NODES(pFormat[1]) )
        goto FreeTopPointer;

    if ( POINTER_DEREF(pFormat[1]) )
        pMemoryPointee = *((uchar **)pMemory);

FreeEmbeddedPointers:

    pFormatPointee = pFormat + 2;
    pFormatPointee += *((signed short *)pFormatPointee);

    //
    // Call the correct free routine if one exists for this type.
    //
    if ( pfnFreeRoutines[ROUTINE_INDEX(*pFormatPointee)] )
        {
        uchar   uFlagsSave = pStubMsg->uFlags;

        RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

        (*pfnFreeRoutines[ROUTINE_INDEX(*pFormatPointee)])
        ( pStubMsg,
          pMemoryPointee,
          pFormatPointee );

        pStubMsg->uFlags = uFlagsSave;
        }

FreeTopPointer:

    //
    // Now free the pointer.  Pointer guaranteed to be non-null here.
    //
    // We only free the pointer if it lies outside of the message buffer
    // that the server stub received from the RPC runtime. Otherwise we
    // used the RPC buffer to hold the pointer's data and should not free it.
    //
    if ( (pMemory < pStubMsg->BufferStart) || (pMemory > pStubMsg->BufferEnd) )
        {
        //
        // Also check to make sure that the pointer was not allocated on the
        // server stub's stack (this may happen for ref pointers).
        //
        // full pointer can't be allocated on stack (it's possible that 
        // an embedded FP points to the stack slot and got free first, and 
        // it will try to free the stack memory ). But currently MIDL still
        // generate allocated_on_stack flag for FC_FP. The workaround is 
        // that in unmarshall, we always allocate new, and in free, we should
        // free despite the flag. 
        if ( ! ALLOCED_ON_STACK(pFormat[1]) || ( *pFormat == FC_FP ))
            {

            NdrFreeTypeMemory( 
                pStubMsg,
                pMemory );
            }
        }
}


NDR_FREE_POINTER_QUEUE_ELEMENT::NDR_FREE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :
        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags) 
{

}

void 
NDR_FREE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );

    NdrPointerFreeInternal( pStubMsg,
                            pMemory,
                            pFormat );
}

#if defined(DBG)
void 
NDR_FREE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_FREE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );

}
#endif

void 
NdrpEnquePointerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );    
    
    RpcTryFinally
    {
        NDR_FREE_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_FREE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                               pMemory,
                                               pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
    }
    RpcFinally
    {
        PointerContext.EndContext();    
    }
    RpcEndFinally
}


void RPC_ENTRY
NdrPointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{

    if ( !NdrIsLowStack(pStubMsg) )
        {
        NdrPointerFreeInternal( 
            pStubMsg,
            pMemory,
            pFormat );
        return;
        }
    
    NdrpEnquePointerFree( 
        pStubMsg,
        pMemory,
        pFormat );

}



void RPC_ENTRY
NdrpRangeFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++
--*/
{
    return;
}


void RPC_ENTRY
NdrSimpleStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a simple structure's embedded pointers which were allocated during 
    a remote call.  

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    if ( *pFormat == FC_PSTRUCT ) 
        {
        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormat + 4 );
        }
}


void RPC_ENTRY
NdrConformantStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a conformant structure's embedded pointers which were allocated 
    during a remote call.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.
    
--*/
{
    PFORMAT_STRING  pFormatArray;

    if ( *pFormat == FC_CSTRUCT )
        return;

    // Get a pointer to the conformant array's description.
    pFormatArray = pFormat + 4;
    pFormatArray += *((signed short *)pFormatArray);

    //
    // Get the conformance count.  Pass a memory pointer to the beginning 
    // of the array.
    //
    NdrpComputeConformance( pStubMsg,
                            pMemory + *((ushort *)(pFormat + 2)),
                            pFormatArray );

    // Must pass a format string pointing to the pointer layout.
    NdrpEmbeddedPointerFree( pStubMsg,
                             pMemory,
                             pFormat + 6 );

    // Above, we walk the array pointers as well.

    if ( IS_EMBED_CONF_STRUCT( pStubMsg->uFlags ) )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
}


void RPC_ENTRY
NdrConformantVaryingStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a conformant varying structure's embedded pointers which were 
    allocated during a remote call.  

    Used for FC_CVSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatArray;

    if ( *(pFormat + 6) != FC_PP ) 
        return;

    //
    // Set the memory pointer to the start of the conformant array/string.
    //

    // Get the conformant array/string description.
    pFormatArray = pFormat + 4;
    pFormatArray += *((signed short *)pFormatArray);

    NdrpComputeConformance( pStubMsg,
                            pMemory + *((ushort *)(pFormat + 2)),
                            pFormatArray );

    NdrpComputeVariance( pStubMsg,
                         pMemory + *((ushort *)(pFormat + 2)),
                         pFormatArray );

    pStubMsg->MaxCount = pStubMsg->ActualCount;                         

    // Must pass a format string pointing to the pointer layout.
    NdrpEmbeddedPointerFree( pStubMsg,
                             pMemory,
                             pFormat + 6 );

    // Above, we walk the array pointers as well.

    if ( IS_EMBED_CONF_STRUCT( pStubMsg->uFlags ) )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );
}


#if 0
void RPC_ENTRY
NdrHardStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a hard structure's embedded pointers which were allocated during 
    a remote call.  

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    if ( *((short *)&pFormat[14]) )
        {
        pFormat += 12;

        pMemory += *((ushort *)pFormat)++;

        pFormat += *((short *)pFormat);

        (*pfnFreeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
        }
}
#endif


void RPC_ENTRY
NdrComplexStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a complex structure's embedded pointers which were allocated during 
    a remote call.  

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    uchar *         pMemorySave;
    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatComplex;
    long            Align8Mod;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    //
    // This is used for support of structs with doubles passed on an
    // i386 stack.
    //
    // A cast to long is what we need.
    Align8Mod = 0x7 & PtrToLong( pMemory );

    pMemorySave = pStubMsg->Memory;
    pStubMsg->Memory = pMemory;

    pFormat += 4;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        pFormatArray = pFormat + *((signed short *)pFormat);
    else
        pFormatArray = 0;

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    //
    // Free the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // simple types
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
            case FC_IGNORE :
                pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_POINTER :
                NdrPointerFree( pStubMsg,
                                *((uchar **)pMemory),
                                pFormatPointers );

                pMemory += PTR_MEM_SIZE;

                pFormatPointers += 4;
                break;

            //
            // Embedded complex types.
            //
            case FC_EMBEDDED_COMPLEX :
                // Add padding.
                pMemory += pFormat[1];   

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( pfnFreeRoutines[ROUTINE_INDEX(*pFormatComplex)] )
                    {
                    (*pfnFreeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                    ( pStubMsg,
                      (*pFormatComplex == FC_IP) ? *(uchar **)pMemory : pMemory,
                      pFormatComplex );
                    }

                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormatComplex );

                //
                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                //
                pFormat++;

                break;

            case FC_ALIGNM2 :
                ALIGN( pMemory, 0x1 );
                break;

            case FC_ALIGNM4 :
                ALIGN( pMemory, 0x3 );
                break;

            case FC_ALIGNM8 :
                //
                // We have to play some tricks for the i386 to handle the case
                // when an 8 byte aligned structure is passed by value.  The
                // alignment of the struct on the stack is not guaranteed to be
                // on an 8 byte boundary.
                //
                pMemory -= Align8Mod;
                ALIGN( pMemory, 0x7 );
                pMemory += Align8Mod;

                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                pMemory += (*pFormat - FC_STRUCTPAD1) + 1; 
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pMemory += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;

            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                goto ComplexFreeEnd;

            default :
                NDR_ASSERT(0,"NdrComplexStructFree : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            } // switch
        } // for

ComplexFreeEnd :

    // Walk the array at the top level only.

    if ( pFormatArray && !fIsEmbeddedStruct  &&  
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PFREE_ROUTINE   pfnFree;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnFree = NdrConformantArrayFree;
                break;

            case FC_CVARRAY :
                pfnFree = NdrConformantVaryingArrayFree;
                break;

            case FC_BOGUS_ARRAY :
                pfnFree = NdrComplexArrayFree;
                break;

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_WSTRING :
            // case FC_C_SSTRING :

            default :
                pfnFree = 0;
                break;
            }

        if ( pfnFree )
            {
            (*pfnFree)( pStubMsg,
                        pMemory,
                        pFormatArray );
            }
        }

    if ( fIsEmbeddedStruct )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    pStubMsg->Memory = pMemorySave;
}


void RPC_ENTRY
NdrFixedArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a fixed array's embedded pointers which were allocated during 
    a remote call.  

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;
    
    if ( *pFormat == FC_SMFARRAY ) 
        pFormat += 4;
    else // *pFormat == FC_LGFARRAY 
        pFormat += 6;

    if ( *pFormat == FC_PP ) 
        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormat ); 
}


void RPC_ENTRY
NdrConformantArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a one dimensional conformant array's embedded pointers which were 
    allocated during a remote call.  Called for both top level and embedded
    conformant arrays.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatPP;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;
    
    pFormatPP = pFormat + 8;
    CORRELATION_DESC_INCREMENT( pFormatPP );

    if ( *pFormatPP == FC_PP ) 
        {
        NdrpComputeConformance( pStubMsg,
                                pMemory,
                                pFormat );

        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormatPP );
        }
}


void RPC_ENTRY
NdrConformantVaryingArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a one dimensional conformant varying array's embedded pointers which 
    were allocated during a remote call.  Called for both top level and 
    embedded conformant varying arrays.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatPP;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;

    pFormatPP = pFormat + 12;
    CORRELATION_DESC_INCREMENT( pFormatPP );
    CORRELATION_DESC_INCREMENT( pFormatPP );
    
    if ( *(pFormatPP) == FC_PP ) 
        {
        NdrpComputeConformance( pStubMsg,
                                pMemory,
                                pFormat );

        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormat );

        //
        // Set MaxCount equal to the number of shipped elements.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormatPP );
        }
}


void RPC_ENTRY
NdrVaryingArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a varying array's embedded pointers which were allocated 
    during a remote call.  Called for both top level and embedded varying
    arrays.


    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatPointers;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;
    
    if ( *pFormat == FC_SMVARRAY ) 
        pFormatPointers = pFormat + 12;
    else // *pFormat == FC_LGVARRAY
        pFormatPointers = pFormat + 16;
    CORRELATION_DESC_INCREMENT( pFormatPointers );

    if ( *pFormatPointers == FC_PP ) 
        {
        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormat );

        //
        // Set MaxCount equal to the number of shipped elements. 
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerFree( pStubMsg,
                                 pMemory,
                                 pFormatPointers );
        }
}


void RPC_ENTRY
NdrComplexArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a complex array's embedded pointers which were allocated 
    during a remote call.  Called for both top level and embedded complex
    arrays.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO     pArrayInfo;
    PFREE_ROUTINE   pfnFree;
    PFORMAT_STRING  pFormatStart;
    uchar *         pMemorySave;
    ulong           Elements;
    ulong           Offset, Count;
    ulong           MemoryElementSize;
    long            Dimension;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;

    //
    // Lots of setup if we are the outer dimension.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        pStubMsg->pArrayInfo = &ArrayInfo;

        ArrayInfo.Dimension = 0;
        ArrayInfo.BufferConformanceMark = (unsigned long *)pStubMsg->BufferMark;
        ArrayInfo.BufferVarianceMark = 0;
        ArrayInfo.MaxCountArray = (unsigned long *) pStubMsg->MaxCount;
        ArrayInfo.OffsetArray = (ulong *) UlongToPtr( pStubMsg->Offset );
        ArrayInfo.ActualCountArray = (ulong *) UlongToPtr( pStubMsg->ActualCount );
        }

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;
    
    pFormatStart = pFormat;

    pFormat += 2;

    // Get number of elements (0 if conformance present). 
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *&)pFormat) != 0xffffffff )
        {
        Elements = (ulong) NdrpComputeConformance( pStubMsg,
                                                   pMemory,
                                                   pFormatStart );
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormatStart );

        Offset = pStubMsg->Offset;
        Count = pStubMsg->ActualCount;
        }
    else
        {
        Offset = 0;
        Count = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ( ! (pfnFree = pfnFreeRoutines[ROUTINE_INDEX(*pFormat)]) )
                goto ComplexArrayFreeEnd;

            pArrayInfo->Dimension = Dimension + 1;

            MemoryElementSize = (ulong)
                                ( NdrpMemoryIncrement( pStubMsg,
                                                       pMemory,
                                                       pFormat ) - pMemory );
            break;

        case FC_RP :
        case FC_UP :
        case FC_FP :
        case FC_OP :
            pfnFree = NdrPointerFree;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_IP :
            pfnFree = NdrInterfacePointerFree;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        default :
            // Must be a basetype.
            goto ComplexArrayFreeEnd;
        }

    pMemorySave = pMemory;

    //
    // If there is variance then increment the memory pointer to the first
    // element actually being marshalled.
    //
    if ( Offset )
        pMemory += Offset * MemoryElementSize;

    if ( pfnFree == NdrPointerFree )
        {
        pStubMsg->pArrayInfo = 0;

        for(; Count--; )
            {

            NdrPointerFree( pStubMsg,
                            *((uchar **)pMemory),
                            pFormat );
            
            // Increment the memory pointer by the element size.
            pMemory += PTR_MEM_SIZE;
            
            }

        goto ComplexArrayFreeEnd;
        }

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        pStubMsg->pArrayInfo = 0;

    for ( ; Count--; )
        {
        // Keep track of multidimensional array dimension.
        if ( IS_ARRAY_OR_STRING(*pFormat) )
            pArrayInfo->Dimension = Dimension + 1;

        (*pfnFree)( pStubMsg,
                    pMemory,
                    pFormat );

        // Increment the memory pointer by the element size.
        pMemory += MemoryElementSize;
        }

ComplexArrayFreeEnd:

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;

}


void RPC_ENTRY
NdrEncapsulatedUnionFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees an encapsulated union's embedded pointers which were allocated 
    during a remote call.  

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;

    NO_CORRELATION;

    switch ( LOW_NIBBLE(pFormat[1]) )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *)pMemory);
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *)pMemory);
            break;

        case FC_ENUM16 :
        case FC_SHORT :
            SwitchIs = (long) *((short *)pMemory);
            break;

        case FC_USHORT :
        case FC_WCHAR :
            SwitchIs = (long) *((ushort *)pMemory);
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG.
            SwitchIs = *((long *)pMemory);
            break;
        default :
            NDR_ASSERT(0,"NdrEncapsulatedUnionFree : bad switch type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Increment memory pointer to the union.
    pMemory += HIGH_NIBBLE(pFormat[1]);

    NdrpUnionFree( pStubMsg,
                   pMemory,
                   pFormat + 2,
                   SwitchIs );
}


void RPC_ENTRY
NdrNonEncapsulatedUnionFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a non-encapsulated union's embedded pointers which were allocated 
    during a remote call.  

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;

    SwitchIs = (ulong) NdrpComputeSwitchIs( pStubMsg,
                                            pMemory,
                                            pFormat );

    //
    // Set the format string to the memory size and arm description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    NdrpUnionFree( pStubMsg,
                   pMemory,
                   pFormat,
                   SwitchIs );
}


void 
NdrpUnionFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                SwitchIs )
/*++

Routine Description :

    Private routine shared by encapsulated and non-encapsulated unions for 
    freeing a union's embedded pointers which were allocated during a remote 
    call.  

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.
    SwitchIs    - The union's switch is.

Return :

    None.

--*/
{
    long            Arms;
    PFREE_ROUTINE   pfnFree;

    // Skip the memory size field.
    pFormat += 2;

    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff );

    // 
    // Search for the arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        return;
        }

    //
    // Return if the arm is empty.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        return;

    pFormat += *((signed short *)pFormat);

    //
    // If the union arm we take is a pointer, we have to dereference the
    // current memory pointer since we're passed a pointer to the union
    // (regardless of whether the actual parameter was a by-value union
    // or a pointer to a union).
    //
    if ( IS_POINTER_TYPE(*pFormat) )
        pMemory = *((uchar **)pMemory);

    if ( pfnFree = pfnFreeRoutines[ROUTINE_INDEX(*pFormat)] ) 
        {
        (*pfnFree)( pStubMsg,
                    pMemory,
                    pFormat );
        }
}


void RPC_ENTRY
NdrByteCountPointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees a byte count pointer.

    Used for FC_BYTE_COUNT_POINTER.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    if ( ! pMemory )
        return;

    //
    // Free it if we didn't use the rpc buffer for it.
    //
    if ( (pMemory < pStubMsg->BufferStart) || (pMemory > pStubMsg->BufferEnd) )
        (*pStubMsg->pfnFree)(pMemory);
}


void RPC_ENTRY
NdrXmitOrRepAsFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees the transmit-as object (actually the presented type instance)
    and steps over the object.

    There is an exceptional situation where the spec forbids stub to free
    the instance. This happens when there is an [in] only parameter with
    a [transmit_as()] on a component of the parameter, and the presented
    typedef is composed of one or more pointers.
    We have a flag in the stub msg that is set when this happens.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple;
    unsigned short                 QIndex;

    // Skip the token itself and Oi flag. Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);
    pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;

    // Free the presented type instance unless forbidden explicitely.

    if ( ! pStubMsg->fDontCallFreeInst )
        {
        pStubMsg->pPresentedType = pMemory;
        pQuintuple[ QIndex ].pfnFreeInst( pStubMsg );
        }
}


void RPC_ENTRY
NdrUserMarshalFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees the usr_marshal object and steps over the object.
    See mrshl.c for the description of the layouts.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const USER_MARSHAL_ROUTINE_QUADRUPLE *  pQuadruple;
    unsigned short                          QIndex;
    USER_MARSHAL_CB                         UserMarshalCB;

    QIndex = *(unsigned short *)(pFormat + 2);
    pQuadruple = pStubMsg->StubDesc->aUserMarshalQuadruple;

    // Call the user to free his stuff.

    NdrpInitUserMarshalCB( pStubMsg,
                           pFormat,
                           USER_MARSHAL_CB_FREE,
                           & UserMarshalCB);

    // The user shouldn't ever free the top level object as we free it.
    // He should free only pointees of his top level object.

    pQuadruple[ QIndex ].pfnFree( (ulong*) &UserMarshalCB, pMemory );

    // NdrpMemoryIncrement steps over the memory object.
}


void RPC_ENTRY
NdrInterfacePointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees any memory associated with an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Interface pointer.
    pFormat     - Interface pointer's format string description.

Return :

    None.

--*/
{
    if(pMemory != 0)
        {
        ((IUnknown *)pMemory)->Release();
        pMemory = 0;
        }
}


void 
NdrpEmbeddedPointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees an array's or a structure's embedded pointers which were allocated 
    during a remote call.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    uchar **    ppMemPtr;
    uchar *     pMemorySave;
    ULONG_PTR   MaxCountSave;
    long        OffsetSave;

    MaxCountSave = pStubMsg->MaxCount;
    OffsetSave = pStubMsg->Offset;

    pMemorySave = pStubMsg->Memory;

    pStubMsg->Memory = pMemory;

    // Increment past the FC_PP and pad.
    pFormat += 2; 

    for (;;) 
        {
        if ( *pFormat == FC_END ) 
            {
            pStubMsg->Memory = pMemorySave;
            break;
            }

        // Check for FC_FIXED_REPEAT or FC_VARIABLE_REPEAT.
        if ( *pFormat != FC_NO_REPEAT ) 
            {
            pStubMsg->MaxCount = MaxCountSave;
            pStubMsg->Offset = OffsetSave;

            pFormat = NdrpEmbeddedRepeatPointerFree( pStubMsg,
                                                     pMemory,
                                                     pFormat );

            // Continue loop to next pointer.
            continue;
            }

        // Get the pointer to the pointer to free.
        ppMemPtr = (uchar **)( pMemory + *((signed short *)(pFormat + 2)) );

        // Increment to pointer description.
        pFormat += 6;

        NdrPointerFree( 
            pStubMsg,
            *ppMemPtr,
            pFormat );
        
        // Increment to the next pointer description.
        pFormat += 4;
        }
}


PFORMAT_STRING
NdrpEmbeddedRepeatPointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Frees an array's embedded pointers which were allocated during a remote 
    call.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    Format string pointer after the array's pointer description.

--*/
{
    uchar **        ppMemPtr;
    uchar *         pMemorySave;
    PFORMAT_STRING  pFormatSave;
    ulong           RepeatCount, RepeatIncrement, Pointers, PointersSave;

    pMemorySave = pStubMsg->Memory;

    switch ( *pFormat ) 
        {
        case FC_FIXED_REPEAT :
            // Increment past the FC_FIXED_REPEAT and FC_PAD.
            pFormat += 2;
    
            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = *((ushort *&)pFormat)++;

            break;

        case FC_VARIABLE_REPEAT :
            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = (ulong)pStubMsg->MaxCount;

            //
            // Check if this variable repeat instance also has a variable
            // offset (this would be the case for a conformant varying array
            // of pointers).  If so then increment the memory pointer to point
            // to the actual first array element which is being marshalled.
            //
            if ( pFormat[1] == FC_VARIABLE_OFFSET )
                pMemory += *((ushort *)(pFormat + 2)) * pStubMsg->Offset;

            // else pFormat[1] == FC_FIXED_OFFSET - do nothing

            // Move the format string to the increment field.
            pFormat += 2;
        
            break;

        default :
            NDR_ASSERT(0,"NdrEmbeddedRepeatPointerFree : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Get the increment amount between successive pointers.
    // This is actually increment to the next element, same position.
    RepeatIncrement = *((ushort *&)pFormat)++;

    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // to the array whose pointers we're marshalling.
    //
    pStubMsg->Memory += *((ushort *&)pFormat)++;

    // Get the number of pointers in this repeat instance.
    PointersSave = Pointers = *((ushort *&)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop over the number of array elements.
    //
    for ( ; RepeatCount--;
            pMemory += RepeatIncrement,
            pStubMsg->Memory += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        // 
        // Loop over the number of pointers per array element (this can be
        // zero for an array of structures).
        //
        for ( ; Pointers--; )
            {
            ppMemPtr = (uchar **)(pMemory + *((signed short *)pFormat));
            
            // Increment to pointer's description.
            pFormat += 4;

            NdrPointerFree( 
                pStubMsg,
                *ppMemPtr,
                pFormat );

            // Increment to the next pointer's offset_in_memory.
            pFormat += 4;
            }
        }

    pStubMsg->Memory = pMemory;

    // Return format string pointer past the array's pointer layout.
    return pFormatSave + PointersSave * 8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\global.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    global.c

Abtract :

    Contains some global variable declarations for the NDR library.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

#include "ndrp.h"

//
// Simple type buffer alignment masks.
//
extern const unsigned char SimpleTypeAlignment[] =
				{
    			0, 		// FC_ZERO

    			0, 		// FC_BYTE
    			0, 		// FC_CHAR
    			0, 		// FC_SMALL
    			0, 		// FC_USMALL

    			1, 		// FC_WCHAR
    			1, 		// FC_SHORT
    			1, 		// FC_USHORT

    			3, 		// FC_LONG
    			3, 		// FC_ULONG
    			3, 		// FC_FLOAT

    			7, 		// FC_HYPER
    			7, 		// FC_DOUBLE

				1, 		// FC_ENUM16
				3, 		// FC_ENUM32
				3, 		// FC_IGNORE
				3, 		// FC_ERROR_STATUS_T

                  0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x11 .. 1f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x20 .. 2f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x30 .. 3f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x40 .. 4f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x50 .. 5f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x60 .. 6f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x70 .. 7f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x80 .. 8f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x90 .. 9f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0xa0 .. af
                0,0,0,0, 0,0,0,0,                     // 0xb0 .. b7

                3,      // FC_INT3264
                3,      // FC_UINT3264
                
                0,      // 0xbb (FC_CSARRAY)
                3,      // 0xbc (FC_CS_TAG)
				};

#if !defined(NDR_GLOBAL_TABLES_ONLY)

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeBufferAlignment( unsigned char FormatChar )
{
     return SimpleTypeAlignment[FormatChar];
} 

#endif

//
// Simple type buffer sizes.
//
extern const unsigned char SimpleTypeBufferSize[] =
				{
    			0, 		// FC_ZERO

    			1, 		// FC_BYTE
    			1, 		// FC_CHAR
    			1, 		// FC_SMALL
    			1, 		// FC_USMALL

    			2, 		// FC_WCHAR
    			2, 		// FC_SHORT
    			2, 		// FC_USHORT

    			4, 		// FC_LONG
    			4, 		// FC_ULONG
    			4, 		// FC_FLOAT

    			8, 		// FC_HYPER
    			8, 		// FC_DOUBLE

				2, 		// FC_ENUM16
				4, 		// FC_ENUM32
				4, 		// FC_IGNORE
				4, 		// FC_ERROR_STATUS_T

                  0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x11 .. 1f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x20 .. 2f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x30 .. 3f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x40 .. 4f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x50 .. 5f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x60 .. 6f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x70 .. 7f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x80 .. 8f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x90 .. 9f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0xa0 .. af
                0,0,0,0, 0,0,0,0,                     // 0xb0 .. b7

                4,      // FC_INT3264
                4,      // FC_UINT3264

                0,      // 0xbb (FC_CSARRAY)
                4       // 0xbc (FC_CS_TAG)
				};

#if !defined(NDR_GLOBAL_TABLES_ONLY)

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeBufferSize( unsigned char FormatChar )
{
    return SimpleTypeBufferSize[FormatChar];
}

#endif

//
// Simple type memory sizes.
//
extern const unsigned char SimpleTypeMemorySize[] =
				{
    			0, 		// FC_ZERO

    			1, 		// FC_BYTE
    			1, 		// FC_CHAR
    			1, 		// FC_SMALL
    			1, 		// FC_USMALL

    			2, 		// FC_WCHAR
    			2, 		// FC_SHORT
    			2, 		// FC_USHORT

    			4, 		// FC_LONG
    			4, 		// FC_ULONG
    			4, 		// FC_FLOAT

    			8, 		// FC_HYPER
    			8, 		// FC_DOUBLE

				sizeof(int), 		// FC_ENUM16
				sizeof(int), 		// FC_ENUM32
				PTR_MEM_SIZE, 	    // FC_IGNORE
				4, 					// FC_ERROR_STATUS_T

                  0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x11 .. 1f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x20 .. 2f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x30 .. 3f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x40 .. 4f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x50 .. 5f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x60 .. 6f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x70 .. 7f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x80 .. 8f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0x90 .. 9f
                0,0,0,0, 0,0,0,0,  0,0,0,0, 0,0,0,0,  // 0xa0 .. af
                0,0,0,0, 0,0,0,0,                     // 0xb0 .. b7

                PTR_MEM_SIZE,      // FC_INT3264 : 4 for 32b, 8 for 64b
                PTR_MEM_SIZE,      // FC_UINT3264: 4 for 32b, 8 for 64b

                0,      // 0xbb (FC_CSARRAY)
                4       // 0xbc (FC_CS_TAG)
				};

#if !defined(NDR_GLOBAL_TABLES_ONLY)

RPCRTAPI
unsigned char 
RPC_ENTRY
NdrGetSimpleTypeMemorySize( unsigned char FormatChar )
{
   return SimpleTypeMemorySize[ FormatChar ];
}

#endif

//
// Contains information about individual ndr types defined in ndrtypes.h.
// Currently is used only by the interpreter.  A set entry indicates that
// the type is a by-value type.  This may be expanded in the future to 
// contain additional attributes.
//
extern const unsigned long NdrTypeFlags[] =
    {
    0,        

    //
    // Simple types
    //
    _SIMPLE_TYPE_,        
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,
    _SIMPLE_TYPE_,

    //
    // Pointer types
    //
    _BASIC_POINTER_ | _POINTER_,        
    _BASIC_POINTER_ | _POINTER_,
    _BASIC_POINTER_ | _POINTER_,
    _BASIC_POINTER_ | _POINTER_,

    //
    // Structures
    //
    _STRUCT_ | _BY_VALUE_,        
    _STRUCT_ | _BY_VALUE_,
    _STRUCT_ | _BY_VALUE_,
    _STRUCT_ | _BY_VALUE_,
    _STRUCT_ | _BY_VALUE_,
    _STRUCT_ | _BY_VALUE_,

    //
    // Arrays
    //
    _ARRAY_,        
    _ARRAY_,
    _ARRAY_,
    _ARRAY_,
    _ARRAY_,
    _ARRAY_,
    _ARRAY_,

    //
    // Conformant Strings
    //
    _STRING_,        
    _STRING_,
    _STRING_,
    _STRING_,

    //
    // Non-conformant String.
    //
    _STRING_,        
    _STRING_,
    _STRING_,
    _STRING_,

    // Encapsulated Union
    _UNION_ | _BY_VALUE_,        

    // Non-encapsulated Union
    _UNION_ | _BY_VALUE_,        

    // Byte count pointer (does NOT get _POINTER_ attribute)
    0,        

    // Transmit as
    _XMIT_AS_ | _BY_VALUE_,        

    // Represent as
    _XMIT_AS_ | _BY_VALUE_,        

    // Interface pointer 
    _POINTER_,        

    // Handles (only explicit handles get the _HANDLE_ attribute)
    _HANDLE_,        
    _HANDLE_,
    _HANDLE_,
    0,
    0,
    0,

    // ** Unused section ***
    0,

    0,
    0,
    0,
    0,
    0,
    0,

    0,
    0,
    0,
    0,
    0,
    0,
    0,

    0,
    0,

    0,
    0,
    0,
    0,
    0,

    0,

    0,

    0,
    0,
    0,
    0,
    0,
    0,
    0,

    0,
    0,
    0,
    0,
    0,
    0,

    0,

    0,        // FC_END
    0,        // FC_PAD
    // ** Unused section end ***

    // ** Gap before new format string types ** 
    0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0,
    // ** Gap before new format string types end **

    // 
    // Post NT 3.5 format characters.
    //

    // Hard struct
    _STRUCT_ | _BY_VALUE_,

    // Transmit_as and Represent_as via poiner

    _XMIT_AS_ | _BY_VALUE_,        
    _XMIT_AS_ | _BY_VALUE_,        

    // User_marshal

    _XMIT_AS_ | _BY_VALUE_,

    0,  // FC_PIPE
    0,  // FC_BLKHOLE

    0,  // RANGE

    _SIMPLE_TYPE_,   // FC_INT3264
    _SIMPLE_TYPE_,   // FC_UINT3264

    0,  // FC_CSARRAY
    0   // FC_CS_TAG
    };

#if !defined(NDR_GLOBAL_TABLES_ONLY)

RPCRTAPI
unsigned long 
RPC_ENTRY
NdrGetTypeFlags( unsigned char FormatChar )
{
    return NdrTypeFlags[ FormatChar ];
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\hndl.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Copyright (c) 1993  - 1999 Microsoft Corporation

Module Name :

    hndl.c

Abstract :

    To hold support routines for interpreting handles
    in support of Format Strings.

Author :
    
    Bruce McQuistan (brucemc)

Revision History :

    ryszardk    3/12/94     handle optimization and fixes

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "hndl.h"
#include "interp.h"

extern const IID GUID_NULL;

handle_t
GenericHandleMgr(
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    )
/*++

Description :

    Provides a filter for generic binding handle management issues.
    Deals with implicit or explicit generic binding handles calling
    user functions as appropriate.

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - pointer to handle.
    pFormat   - pointer to Format string such that *pFormat is a
                handle descriptor.
    Flag      - flag indicating either binding or unbinding.

Returns :     

    Valid binding handle.

*/
{
    uchar                                GHandleSize;
    handle_t                             ReturnHandle = 0;
    BOOL                                 fBinding;
    GENERIC_BINDING_ROUTINE              pBindFunc = 0;
    GENERIC_UNBIND_ROUTINE               pUnBindFunc = 0;
    const GENERIC_BINDING_ROUTINE_PAIR * Table;
    BOOL                                 fIsPtr = FALSE;

    Table = pStubDesc->aGenericBindingRoutinePairs;

    fBinding = (Flags & BINDING_MASK);

    if ( Flags & IMPLICIT_MASK )
        {
        //
        // Implicit generic: All the info is taken from the implicit generic
        // handle info structure accessed via stub descriptor.
        //
        PGENERIC_BINDING_INFO pGenHandleInfo;

        pGenHandleInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

        GHandleSize = (uchar) pGenHandleInfo->Size;

        if ( fBinding )
            pBindFunc = pGenHandleInfo->pfnBind;
        else
            pUnBindFunc = pGenHandleInfo->pfnUnbind;
        }
    else
        {
        //
        // Explicit generic: Get index into array of function ptrs and
        // the gen handle size the format string.
        //
        uchar TableIndex = pFormat[4];

        GHandleSize = LOW_NIBBLE(pFormat[1]);

        if ( fBinding )
            pBindFunc = Table[TableIndex].pfnBind;
        else
            pUnBindFunc = Table[TableIndex].pfnUnbind;

        if ( IS_HANDLE_PTR(pFormat[1]) )
            fIsPtr = TRUE;           
        }

    //
    // Call users routine on correctly dereferenced pointer.
    //
    switch (GHandleSize)
        {
        case 1:
            {
            uchar HandlePtr = (uchar)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (uchar *)ArgPtr;
                
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGCHAR)pBindFunc)(
                        (uchar)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGCHAR)pUnBindFunc)(
                    (uchar)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

        case 2:
            {
            ushort HandlePtr = (ushort)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ushort *)ArgPtr;

            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGSHORT)pBindFunc)(
                        (ushort)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGSHORT)pUnBindFunc)(
                    (ushort)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

        case 4:
            {
            ulong HandlePtr = (ulong)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ulong *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGLONG)pBindFunc)(
                        (ulong)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGLONG)pUnBindFunc)(
                    (ulong)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }
#if defined(__RPC_WIN64__)
        case 8:
            {
            ULONG_PTR HandlePtr = (ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ULONG_PTR *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGINT64)pBindFunc)(
                        (ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGINT64)pUnBindFunc)(
                    (ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }
#endif

        default:
            NDR_ASSERT(0,"GenericHandleMgr : Handle size too big");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    if ( fBinding )
        {
        *pGenericHandle = ReturnHandle;
        if ( ReturnHandle == NULL )
            RpcRaiseException( RPC_S_INVALID_BINDING );
        }
    else
        *pGenericHandle = NULL;

    return ReturnHandle;
}


void
GenericHandleUnbind(
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    )
/*++

Description :

    Unbinds a generic handle: checks if it is implicit or explicit,
    gets the handle and calls GenericHandleMgr.

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - pointer to beginning of the stack.
    pFormat   - pointer to Format string such that *pFormat is a
                  handle descriptor.
    Flag      - flag indicating implicit vs. explicit.

 --*/
{
    if ( Flags & IMPLICIT_MASK )
        {
        PGENERIC_BINDING_INFO BindInfo;

        BindInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

        NDR_ASSERT( BindInfo != 0, "GenericHandleUnbind : null bind info" );

        ArgPtr = (uchar *) BindInfo->pObj;
        }
    else
        {
        ArgPtr += *(ushort *)(pFormat + 2);

        ArgPtr = *(uchar **)ArgPtr;

        }

    (void) GenericHandleMgr( pStubDesc,
                             ArgPtr,
                             pFormat,
                             Flags,
                             pGenericHandle );
}


handle_t
ImplicitBindHandleMgr(
    PMIDL_STUB_DESC pStubDesc,
    uchar           HandleType,
    handle_t *      pSavedGenericHandle
    )
/*++

Description :

    Provides a filter for implicit handle management issues. Deals
    with binding handles (generic, primitive or auto), extracting
    a valid handle from pStubDesc.

Arguments :

    pStubDesc  - pointer to current StubDescriptor.
    HandleType - handle format code.

Return :     
    
    Valid handle.

--*/
{
    handle_t                ReturnHandle;
    PGENERIC_BINDING_INFO   pBindInfo;

    switch ( HandleType )
        {
        case FC_BIND_PRIMITIVE :
            ReturnHandle = *(pStubDesc->IMPLICIT_HANDLE_INFO.pPrimitiveHandle);
            break;

        case FC_BIND_GENERIC :
            pBindInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

            NDR_ASSERT( pBindInfo != 0, 
                        "ImplicitBindHandleMgr : no generic bind info" );

            ReturnHandle = GenericHandleMgr( pStubDesc,
                                             (uchar *)pBindInfo->pObj,
                                             &HandleType,
                                             BINDING_MASK | IMPLICIT_MASK,
                                             pSavedGenericHandle );
            break;

        case FC_AUTO_HANDLE :
            ReturnHandle = *(pStubDesc->IMPLICIT_HANDLE_INFO.pAutoHandle);
            break;

        case FC_CALLBACK_HANDLE :
            ReturnHandle = GET_CURRENT_CALL_HANDLE();
            break;

        default :
            NDR_ASSERT(0, "ImplicitBindHandleMgr : bad handle type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return ReturnHandle;
}


handle_t
ExplicitBindHandleMgr(
    PMIDL_STUB_DESC pStubDesc,
    uchar *         ArgPtr,
    PFORMAT_STRING  pFormat,
    handle_t *      pSavedGenericHandle
    )
/*

Description :

    Provides a filter for explicit binding handle management issues.
    Deals with binding handles (primitive, generic or context), calling
    either no routine, NDR routines or user functions as appropriate.

    To be called in the following cases:
    1) if handle is explicit.
        a) before calling I_RpcGetBuffer (to bind).
        b) after unmarshalling (to unbind).

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - Pointer to start of stack
    pFormat   - pointer to Format string such that *pFormat is a
                  handle descriptor.

Return :     

    Valid binding handle.

*/
{
    handle_t    ReturnHandle;

    //
    // We need to manage Explicit and Implicit handles.
    // Implicit handles are managed with info accessed via the StubMessage.
    // Explicit handles have their information stored in the format string.
    // We manage explicit handles for binding here.
    //

    //
    // Get location in stack of handle referent.
    //
    ArgPtr += *((ushort *)(pFormat + 2));

    ArgPtr = *(uchar **)ArgPtr;

    //
    // At this point ArgPtr is an address of the handle.
    //
    switch ( *pFormat )
        {
        case FC_BIND_PRIMITIVE :
            if ( IS_HANDLE_PTR(pFormat[1]) )
                ArgPtr = *(uchar **)ArgPtr;
            ReturnHandle = (handle_t)(ULONG_PTR)ArgPtr;
            break;

        case FC_BIND_GENERIC :
            ReturnHandle = GenericHandleMgr( pStubDesc,
                                             ArgPtr,
                                             pFormat,
                                             BINDING_MASK,
                                             pSavedGenericHandle );
            break;
    
        case FC_BIND_CONTEXT :
            if ( IS_HANDLE_PTR(pFormat[1]) )
                ArgPtr = *(uchar **)ArgPtr;

            if ( (!(ArgPtr)) && (!IS_HANDLE_OUT(pFormat[1])) )
                 RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

            ReturnHandle = 0;    // covers NULL case below.

            if ( ArgPtr && ! 
                 (ReturnHandle = NDRCContextBinding((NDR_CCONTEXT)ArgPtr)) )
                 RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

            break;

        default :
            NDR_ASSERT( 0, "ExplictBindHandleMgr : bad handle type" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return ReturnHandle;
}


unsigned char * RPC_ENTRY
NdrMarshallHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pArg,
    PFORMAT_STRING      pFormat
    )
/*++

Routine description :

    Marshalls a context handle.

Arguments :
    
    pStubMsg    - Pointer to stub message.
    pArg        - Context handle to marshall (NDR_CCONTEXT or NDR_SCONTEXT).
    pFormat     - Context handle's format string description.

Return :

    Buffer pointer after marshalling the context handle.

--*/
{
    long    Index;

    NDR_ASSERT( *pFormat == FC_BIND_CONTEXT, 
                "NdrMarshallHandle : Expected a context handle" );


    if ( pStubMsg->IsClient )
        {
        NDR_CCONTEXT Context;

        ALIGN( pStubMsg->Buffer, 0x3 );

        //
        // Get the context handle.
        //
        Context = IS_HANDLE_PTR(pFormat[1]) ? 
                        *((NDR_CCONTEXT *)pArg) : (NDR_CCONTEXT)pArg;

        //
        // An [in] only context handle must be non-zero.
        //
        if ( ! Context && ! IS_HANDLE_OUT(pFormat[1]) )
            RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

        NDRCContextMarshall( Context, (void *) pStubMsg->Buffer );

        pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

        }
    else    
        {
 
        //
        // The NT 3.5 Interpreter used the stub message to keep track of
        // parameter number, newer Interpreters have the param number in the 
        // context handle's description.
        //
        if ( pStubMsg->StubDesc->Version == NDR_VERSION_1_1 )
            {
            Index = pStubMsg->ParamNumber;
            }
        else
            {
            Index = (long) pFormat[3];

            if ( IS_HANDLE_RETURN(pFormat[1]) )
                {
                NDR_SCONTEXT    SContext;

                //
                // Initialize the context handle.
                //
                SContext = NdrContextHandleInitialize ( pStubMsg,
                                                        pFormat );

                //
                // Put the user context that was returned into the context
                // handle.
                //
                *((uchar **)NDRSContextValue(SContext)) = pArg;

                pStubMsg->SavedContextHandles[Index] = SContext;
                }
            }
        // If the new value is NULL, after marshalling, runtime will deallocate the buffer
        // We need to zero out the saved context to avoid referencing garbage.
        NDR_SCONTEXT pContext = pStubMsg->SavedContextHandles[Index];
        pStubMsg->SavedContextHandles[Index] = (NDR_SCONTEXT) CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER;
        
        NdrServerContextNewMarshall( pStubMsg,
                                     pContext,
                                     pStubMsg->StubDesc->apfnNdrRundownRoutines[pFormat[2]],
                                     pFormat );

        pStubMsg->SavedContextHandles[Index] = (NDR_SCONTEXT)CONTEXT_HANDLE_AFTER_MARSHAL_MARKER;
        }


    return 0;
}

unsigned char * RPC_ENTRY
NdrUnmarshallHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppArg,
    PFORMAT_STRING      pFormat,
    uchar		        fIgnored
    )
/*++

Routine description :

    Unmarshall a context handle.

Arguments :
    
    pStubMsg    - Pointer to stub message.
    ppArg       - Pointer to the context handle on the client/server stack.
                  On the client this is a NDR_CCONTEXT *.  On the server
                  side this is a NDR_SCONTEXT (regardless of direction).
    pFormat     - Context handle's format string description.
    fIgnored    - Ignored, but needed to match necessary routine prototype.

Return :

    Buffer pointer after unmarshalling the context handle.

--*/
{
    NDR_ASSERT( *pFormat == FC_BIND_CONTEXT, 
                "NdrUnmarshallHHandle : Expected a context handle" );

    if ( pStubMsg->IsClient )
        {

        ALIGN( pStubMsg->Buffer, 0x3 );

        //
        // Check if we have a pointer to a context handle
        // (the pointer can't be null).
        //
        if ( IS_HANDLE_PTR(pFormat[1]) )
            {
            ppArg = (uchar **) *ppArg;
            }

        //
        // Zero an [out] only context handle before unmarshalling.
        //
        if ( ! IS_HANDLE_IN(pFormat[1]) )
            *ppArg = 0;

        //
        // We must use the original binding handle in this call.   
        //
        NDRCContextUnmarshall( (NDR_CCONTEXT *)ppArg,
                               pStubMsg->SavedHandle,
                               (void *)pStubMsg->Buffer,
                               pStubMsg->RpcMsg->DataRepresentation );

        pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

        }
    else
        {

        NDR_SCONTEXT    SContext;

        SContext = NdrServerContextNewUnmarshall( pStubMsg,
                                                  pFormat );

        NdrSaveContextHandle( pStubMsg, 
                              SContext, 
                              ppArg, 
                              pFormat );
        }

    return 0;
}


void 
NdrSaveContextHandle (
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        CtxtHandle,
    uchar **            ppArg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description : 

    Saves a context handle's current value and then extracts the user's
    context value.

Arguments :

    pStubMsg    - The stub message.
    CtxtHandle  - The context handle.
    ppArg       - Pointer to where user's context value should go.

Return : 

    None.

*/
{
    long    Index;

    //
    // The NT 3.5 Interpreter used the stub message to keep track of
    // parameter number, newer Interpreters have the param number in the 
    // context handle's description.
    //
    if ( pStubMsg->StubDesc->Version == NDR_VERSION_1_1 )
        Index = pStubMsg->ParamNumber;
    else
        Index = (long) pFormat[3];

    pStubMsg->SavedContextHandles[Index] = CtxtHandle;

    // On 32b alphas, a handle pointer needs to be properly sign extended
    // to a 64b virtual stack value, as this will become the register value.
    // So, we cast to the REGISTER_TYPE to get the sign extension

    if ( ! IS_HANDLE_PTR(pFormat[1]) )
        *((REGISTER_TYPE*)ppArg) = (REGISTER_TYPE) *(NDRSContextValue(CtxtHandle));
    else
        *((REGISTER_TYPE*)ppArg) = (REGISTER_TYPE) NDRSContextValue(CtxtHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\hndl.h ===
/************************************************************************

Copyright (c) 1993 Microsoft Corporation

Module Name :

    hndl.h

Abstract :

    To hold prototypes of support routines for interpreting handles in 
    support of Format Strings.

Author :

    Bruce McQuistan (brucemc)

Revision History :

  ***********************************************************************/

#ifndef __HNDL_H__
#define __HNDL_H__

//
// The following is to be used in as masks for flags passed in these
// routines.
//
#define     MARSHALL_MASK           0x2
#define     IMPLICIT_MASK           0x4
#define     BINDING_MASK            0x8

//
// Next, a macro for getting the current call handle. On dos,win16, it'll
// never be called.
//
#define GET_CURRENT_CALL_HANDLE()   I_RpcGetCurrentCallHandle()

//
// Some typedefs to keep the front end of the C compiler happy and possibly to
// improve code generation.
//
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGCHAR)(uchar);
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGSHORT)(ushort);
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGLONG)(ulong);

typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGCHAR)(uchar, handle_t);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGSHORT)(ushort, handle_t);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGLONG)(ulong, handle_t);

#if defined(__RPC_WIN64__)
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGINT64)(uint64);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGINT64)(uint64, handle_t);
#endif

handle_t
GenericHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

void
GenericHandleUnbind(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

handle_t
ExplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    handle_t *              pSavedGenericHandle
    );

handle_t
ImplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar                   HandleType,
    handle_t *              pSavedGenericHandle
    );

unsigned char * RPC_ENTRY
NdrMarshallHandle(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar *                 pArg,
    PFORMAT_STRING          FmtString
    );

unsigned char * RPC_ENTRY
NdrUnmarshallHandle(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar **                ppArg,
    PFORMAT_STRING          FmtString,
	uchar				    fIgnored
    );

void
NdrSaveContextHandle (
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            CtxtHandle,
    uchar **                ppArg,
    PFORMAT_STRING          pFormat
    );

void
NdrContextHandleQueueFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    void *                  FixedArray
    );

#endif __HNDL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\interp2.h ===
/************************************************************************

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    newintrp.h

Abstract :

    Definitions for the new client and server stub interpreter.

Author :

    DKays       December 1994

Revision History :

  ***********************************************************************/

#ifndef _NEWINTRP_
#define _NEWINTRP_

#include "interp.h"

extern "C"
{
void
NdrClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar *             pArg
    );

void
NdrClientMapCommFault(
    PMIDL_STUB_MESSAGE  pStubMsg,
    long                ProcNum,
    RPC_STATUS          ExceptionCode,
    ULONG_PTR *          pReturnValue
    );

void
NdrpFreeParams(
    MIDL_STUB_MESSAGE       * pStubMsg,
    long                    NumberParams,
    PPARAM_DESCRIPTION      Params,
    uchar *                 pArgBuffer
    );

void
Ndr64ClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    uchar *             pArg
    );


void
Ndr64pFreeParams(
    MIDL_STUB_MESSAGE       *           pStubMsg,
    long                                NumberParams,
    NDR64_PARAM_FORMAT      *           Params,
    uchar *                             pArgBuffer
    );


REGISTER_TYPE
Invoke(
    MANAGER_FUNCTION pFunction,
    REGISTER_TYPE *  pArgumentList,
#if defined(_IA64_)
    ulong            FloatArgMask,
#endif
    ulong            cArguments);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\memsize.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    memsize.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the
    intepreter for computing the memory size needed to hold a parameter being
    unmarshalled.

Author :

    David Kays  dkays   November 1993.

Revision History :

Note:
    Simple types are not checked for buffer over-run since we are 
    only reading from the buffer and not writing from it.  So if
    a buffer overun actually occures, no real damage is done.

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "interp2.h"
#include "attack.h"
#include "pointerq.h"

unsigned long
NdrUDTSimpleTypeMemsize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat );

extern const
PMEM_SIZE_ROUTINE   MemSizeRoutinesTable[] =
                    {
                    
                    // dummies for 64b C compiler workaround
                    //
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,      // FC_ZERO - FC_USHORT
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,
                    NdrUDTSimpleTypeMemsize,      // FC_LONG - FC_IGNORE
                    NdrUDTSimpleTypeMemsize,      // FC_ERROR_STATUS_T

                    NdrPointerMemorySize,
                    NdrPointerMemorySize,
                    NdrPointerMemorySize,
                    NdrPointerMemorySize,

                    NdrSimpleStructMemorySize,
                    NdrSimpleStructMemorySize,
                    NdrConformantStructMemorySize,
                    NdrConformantStructMemorySize,
                    NdrConformantVaryingStructMemorySize,

                    NdrComplexStructMemorySize,

                    NdrConformantArrayMemorySize,
                    NdrConformantVaryingArrayMemorySize,
                    NdrFixedArrayMemorySize,
                    NdrFixedArrayMemorySize,
                    NdrVaryingArrayMemorySize,
                    NdrVaryingArrayMemorySize,

                    NdrComplexArrayMemorySize,

                    NdrConformantStringMemorySize,
                    NdrConformantStringMemorySize,
                    NdrConformantStringMemorySize,
                    NdrConformantStringMemorySize,

                    NdrNonConformantStringMemorySize,
                    NdrNonConformantStringMemorySize,
                    NdrNonConformantStringMemorySize,
                    NdrNonConformantStringMemorySize,

                    NdrEncapsulatedUnionMemorySize,
                    NdrNonEncapsulatedUnionMemorySize,

                    0,                           // byte count

                    NdrXmitOrRepAsMemorySize,    // transmit as
                    NdrXmitOrRepAsMemorySize,    // represent as

                    NdrPointerMemorySize,

                    0,

                    // New Post NT 3.5 token serviced from here on.

                    0,                         // NdrHardStructMemorySize,

                    NdrXmitOrRepAsMemorySize,  // transmit as ptr
                    NdrXmitOrRepAsMemorySize,  // represent as ptr

                    NdrUserMarshalMemorySize,

                    0,   // FC_PIPE 
                    0,   // FC_BLK_HOLE

                    NdrpRangeMemorySize,

                    0,   // FC_INT3264
                    0,   // FC_UINT3264

                    0, // NdrCsArrayMemorySize,
                    0, // NdrCsTagMemorySize
                    };

extern const
PMEM_SIZE_ROUTINE * pfnMemSizeRoutines = MemSizeRoutinesTable;

void
NdrpInterfacePointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat );

unsigned long
NdrUDTSimpleTypeMemsize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
{
    ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT(*pFormat) );
    pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(*pFormat);
    pStubMsg->MemorySize += SIMPLE_TYPE_MEMSIZE(*pFormat);
    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrpRangeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++
--*/
{
    FORMAT_CHARACTER    FcType = (FORMAT_CHARACTER)(pFormat[1] & 0x0f);

    ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(FcType));
   
    pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE(FcType);

    switch ( pFormat[2] )
        {
        case FC_ENUM16 :
            //
            // We can't use the simple type tables for enum16.
            //
            LENGTH_ALIGN( pStubMsg->MemorySize, sizeof(int) - 1 );
            pStubMsg->MemorySize += sizeof(int);
            break;

        default :
            LENGTH_ALIGN( pStubMsg->MemorySize,
                          SIMPLE_TYPE_ALIGNMENT(FcType) );
            pStubMsg->MemorySize += SIMPLE_TYPE_MEMSIZE(FcType);
            break;
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a top level pointer to anything.
    Pointers embedded in structures, arrays, or unions call
    NdrpPointerMemorySize directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar * pBufferMark;

    //
    // If this is not a ref pointer then mark where the pointer's id is in
    // the buffer and increment the stub message buffer pointer.
    //
    if ( *pFormat != FC_RP )
        {
        ALIGN(pStubMsg->Buffer,0x3);

        pBufferMark = pStubMsg->Buffer;
        
        pStubMsg->Buffer += PTR_WIRE_SIZE;
        }
    else
        pBufferMark = 0;

    // Else we can leave pBufferMark unitialized.

    return NdrpPointerMemorySize( pStubMsg,
                                  pBufferMark,
                                  pFormat );
}


__forceinline unsigned long
NdrpPointerMemorySizeInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the memory size required for a pointer to
    anything.  This is the entry point for pointers embedded in structures
    arrays, or unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to stub message.
    pBufferMark - Location in the buffer where a unique or full pointer's id is.
                  Unused for ref pointers.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar   uFlagsSave;
    ulong   MemSize;

    switch ( *pFormat )
        {
        case FC_RP :
            break;

        case FC_UP :
        case FC_OP :
            if ( ! *((long *)pBufferMark) )
                return pStubMsg->MemorySize;
            break;

        case FC_IP:
            if ( IS_BROKEN_INTERFACE_POINTER(pStubMsg->uFlags) )
                {
                // In this case, the whole pointer and pointee are
                // where the pointee should have been.
                // (Treat like toplevel at this point )
                NdrInterfacePointerMemorySize( pStubMsg,
                                               pFormat );
                }
            else
                {
                if ( ! *((long *)pBufferMark) )
                    return pStubMsg->MemorySize;
                NdrpInterfacePointerMemorySize( pStubMsg,
                                                pFormat );                
                }
            return pStubMsg->MemorySize;

        case FC_FP :
            //
            // Check if we've already mem sized this full pointer.
            //
            if ( NdrFullPointerQueryRefId( pStubMsg->FullPtrXlatTables,
                                           *((ulong *)pBufferMark),
                                           FULL_POINTER_MEM_SIZED,
                                           0 ) )
                return pStubMsg->MemorySize;

            break;

        default :
            NDR_ASSERT(0,"NdrpPointerMemorySize : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    //
    // We align all memory pointers on at least a void * boundary.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );

    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        // Pointer to complex type.

        if ( POINTER_DEREF(pFormat[1]) )
            pStubMsg->MemorySize += PTR_MEM_SIZE;

        pFormat += 2;

        pFormat += *((signed short *)pFormat);
        }
    else
        {
        switch ( pFormat[2] )
            {
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :
                // Increment to string's description.
                pFormat += 2;
                break;

            default :
                // Simple type.

                ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(pFormat[2]));
                pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( pFormat[2] );

                switch ( pFormat[2] )
                    {
                    case FC_ENUM16 :
                        //
                        // We can't use the simple type tables for enum16.
                        //
                        LENGTH_ALIGN( pStubMsg->MemorySize, sizeof(int) - 1 );
                        pStubMsg->MemorySize += sizeof(int);
                        break;

                    default :
                        LENGTH_ALIGN( pStubMsg->MemorySize,
                                      SIMPLE_TYPE_ALIGNMENT(pFormat[2]) );
                        pStubMsg->MemorySize += SIMPLE_TYPE_MEMSIZE(pFormat[2]);
                        break;
                    }

                return pStubMsg->MemorySize;
            }
        }

    uFlagsSave = pStubMsg->uFlags;
    RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    MemSize = (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)])
                    ( pStubMsg,
                      pFormat );

    pStubMsg->uFlags = uFlagsSave;

    return MemSize;
}

NDR_MEMSIZE_POINTER_QUEUE_ELEMENT::NDR_MEMSIZE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg,
    uchar             *pBufferMarkNew,
    PFORMAT_STRING     pFormatNew ) :

        pFormat(pFormatNew),
        pBufferMark(pBufferMarkNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags) 
{

}

void 
NDR_MEMSIZE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0!\n");
    NDR_ASSERT( !pStubMsg->PointerLength, "PointerLength is not 0!\n");

    NdrpPointerMemorySizeInternal( pStubMsg,
                                   pBufferMark,
                                   pFormat );

}

#if defined(DBG)
void 
NDR_MEMSIZE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pBufferMark:             %p\n", pBufferMark );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );
}
#endif

void
NdrpEnquePointerMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pBufferMark,
    PFORMAT_STRING     pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {

        NDR_MEMSIZE_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_MEMSIZE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                  pBufferMark,
                                                  pFormat );
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally
}

unsigned long
NdrpPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    PFORMAT_STRING      pFormat )
{
    
    if ( !NdrIsLowStack(pStubMsg) )
        {
        return
        NdrpPointerMemorySizeInternal( pStubMsg,
                                       pBufferMark,
                                       pFormat );      
        }
    
    NdrpEnquePointerMemorySize(
        pStubMsg,
        pBufferMark,
        pFormat );

    return 0;
}


unsigned long RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Structure's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   Size;

    Size = *((ushort *)(pFormat + 2));

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + Size );
    pStubMsg->Buffer += Size;

    pStubMsg->MemorySize += Size;

    if ( *pFormat == FC_PSTRUCT )
        {
        // Mark where the structure starts in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat + 4 );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a conformant structure.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    PFORMAT_STRING  pFormatArray;
    ulong           Size;
    uchar           Alignment = pFormat[1];
    // set by the outermost embedding complex struct
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    Size = *((ushort *)(pFormat + 2));

    // Get the conformance count.
    if ( fIsEmbeddedStruct )
        {
        // A bogus struct would set the mark.
        pStubMsg->MaxCount = *((long *)pStubMsg->BufferMark);
        }
    else
        {
        // Align for the conformance count.
        ALIGN(pStubMsg->Buffer,0x3);
        pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;
        }

    // Increment the format string to the offset to array description.
    pFormat += 4;

    // Get the array's description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    // Check bounds.
    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormatArray[4] & 0x0f );

    // check for possible mulitplication overflow attack here.
    Size += MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount, *((ushort *)(pFormatArray + 2) ) );
    
    // Increment the format string past the offset to array description.
    pFormat += 2;

    // Realign for struct 
    ALIGN(pStubMsg->Buffer, Alignment);

    LENGTH_ALIGN( pStubMsg->MemorySize, Alignment );
    
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, Size );
    pStubMsg->Buffer += Size;
    pStubMsg->MemorySize += Size;

    if ( *pFormat == FC_PP )
        {
        // Mark the beginning of the struct in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a conformant varying structure.

    Used for FC_CVSTRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    PFORMAT_STRING  pFormatArray;
    uchar *         pBufferMark;
    ulong           Size;
    // set by the outermost embedding complex struct
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    Size = *((ushort *)(pFormat + 2));

    // Get the conformance count.
    if ( fIsEmbeddedStruct )
        {
        pStubMsg->MaxCount = *((long *&)pStubMsg->BufferMark);
        }
    else
        {
        ALIGN(pStubMsg->Buffer,0x3);
        pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;
        }

    ALIGN(pStubMsg->Buffer,pFormat[1]);
    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    // Remember the start of the struct in the buffer.
    pBufferMark = pStubMsg->Buffer;

    CHECK_EOB_RAISE_IB( pStubMsg->Buffer + Size );
    pStubMsg->Buffer += Size;
 
    pStubMsg->MemorySize += Size;

    pFormat += 4;

    // Get array's format string description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    // We always marshal the array, the outer struct will watch for the done flag.

    if ( *pFormatArray == FC_CVARRAY )
        {
        NdrpConformantVaryingArrayMemorySize( pStubMsg,
                                              pFormatArray );
        }
    else
        {
        NdrpConformantStringMemorySize( pStubMsg,
                                        pFormatArray );
        }

    pFormat += 2;

    if ( *pFormat == FC_PP )
        {
        // Mark the start of the structure in the buffer.
        pStubMsg->Buffer = pBufferMark;
    
        pStubMsg->MaxCount = pStubMsg->ActualCount;
        
        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return pStubMsg->MemorySize;
}


#if 0
unsigned long RPC_ENTRY
NdrHardStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a hard structure.

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ushort      CopySize;

    LENGTH_ALIGN(pStubMsg->MemorySize,pFormat[1]);

    pStubMsg->MemorySize += *((ushort *)&pFormat[2]);

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    CopySize = *((ushort *)&pFormat[10]);

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CopySize );
    pStubMsg->Buffer += CopySize;

    if ( *((short *)&pFormat[14]) )
        {
        pFormat += 14;
        pFormat += *((short *)pFormat);

        (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                        pFormat );
        }

    return pStubMsg->MemorySize;
}
#endif // 0


unsigned long RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

Notes:
    This routine can calculate the memory size with or without pointees.
    When calculating size with pointees at the top level, the routine calls
    itself recursively to find out where pointees would be and then remember
    the context using pStubMsg->MemorySize and pStubMsg->PointerBufferMark.

--*/
{
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatComplex;
    long            Alignment;
    BOOL            fSetPointerBufferMark;

    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    BOOL            fEmbedConfStructContext;

    //
    // This is fun.  If we're not ignoring embedded pointers and this structure
    // is not embedded inside of another struct or array then we make a
    // recursive call to get a pointer to where the flat part of the structure
    // ends in the buffer.  Then we can properly get to any embedded pointer's
    // pointees.
    //
    if ( fSetPointerBufferMark =
         (! pStubMsg->IgnoreEmbeddedPointers && ! pStubMsg->PointerBufferMark) )
        {
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // This gets clobbered.
        uchar * BufferSave = pStubMsg->Buffer;
        ulong MemorySizeSave = pStubMsg->MemorySize;

        //
        // Get a buffer pointer to where the struct's pointees are.
        //
        (void) NdrComplexStructMemorySize( pStubMsg,
                                           pFormat );


        // Mark where the pointees begin.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->PointerLength     = pStubMsg->MemorySize;

        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        
        pStubMsg->MemorySize = MemorySizeSave;
        pStubMsg->Buffer = BufferSave;
        }

    Alignment = pFormat[1];

    pFormat += 4;

    fEmbedConfStructContext = fIsEmbeddedStruct;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        {
        ulong ConformanceSize;

        pFormatArray = pFormat + *((signed short *)pFormat);

        if ( FixWireRepForDComVerGTE54( pStubMsg ) )
            fEmbedConfStructContext = TRUE;

        if ( !fIsEmbeddedStruct )
            {
            ALIGN(pStubMsg->Buffer,3);

            // conformance count marker
            pStubMsg->BufferMark = pStubMsg->Buffer;

            // Handle multidimensional arrays.
            ConformanceSize = NdrpArrayDimensions( pStubMsg, pFormatArray, FALSE ) * 4;
  
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + ConformanceSize );
            pStubMsg->Buffer += ConformanceSize;
            }
        }
    else
        {
        pFormatArray = 0;
        }

    // BufferMark may be set by an outer bogus struct.
    pBufferMark = pStubMsg->BufferMark;
    RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Size the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // Simple types.
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
            case FC_IGNORE :
                ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(*pFormat));

                pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( *pFormat );

                pStubMsg->MemorySize += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_POINTER :
                {
                ALIGN(pStubMsg->Buffer,0x3);
                uchar *pPointerId = pStubMsg->Buffer;
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                
                if ( ! pStubMsg->IgnoreEmbeddedPointers )
                    {
                    POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );
                    NdrpPointerMemorySize( pStubMsg,
                                           pPointerId,
                                           pFormatPointers );

                    }

                //
                // We actually do a post alignment of the memory size.
                // Do this to prevent some under-allocations when pointers
                // to strings, or char or short are involved.
                //
                LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );

                pStubMsg->MemorySize += PTR_MEM_SIZE;
                pFormatPointers += 4;
                }

                break;

            //
            // Embedded complex types.
            //
            case FC_EMBEDDED_COMPLEX :
                // Add padding.
                pStubMsg->MemorySize += pFormat[1];

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( FC_IP == *pFormatComplex ) 
                    {
                    ALIGN(pStubMsg->Buffer,0x3);
                    uchar *pPointerId = pStubMsg->Buffer;
                    pStubMsg->Buffer += PTR_WIRE_SIZE;
                
                    if ( ! pStubMsg->IgnoreEmbeddedPointers )
                        {
                        POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );
                        NdrpPointerMemorySize( pStubMsg,
                                               pPointerId,
                                               pFormatComplex );

                        }

                    pStubMsg->MemorySize += PTR_MEM_SIZE;
                    pFormat++;
                    break;

                    }

                // Needed for embedded conf structs
                //
                pStubMsg->BufferMark = pBufferMark;
                if ( fEmbedConfStructContext )
                    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                (void) (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                       ( pStubMsg,
                         pFormatComplex );

                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
                //
                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                //
                pFormat++;

                break;

            case FC_ALIGNM2 :
                LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
                break;

            case FC_ALIGNM4 :
                LENGTH_ALIGN( pStubMsg->MemorySize, 0x3 );
                break;

            case FC_ALIGNM8 :
                LENGTH_ALIGN( pStubMsg->MemorySize, 0x7 );
                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                pStubMsg->MemorySize += (*pFormat - FC_STRUCTPAD1) + 1;
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pStubMsg->MemorySize += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;

            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                goto ComplexMemorySizeEnd;

            default :
                NDR_ASSERT(0,"NdrComplexStructMemorySize : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            }
        }

ComplexMemorySizeEnd :

    if ( pFormatArray && !fIsEmbeddedStruct  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PPRIVATE_MEM_SIZE_ROUTINE   pfnMemSize;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnMemSize = NdrpConformantArrayMemorySize;
                break;

            case FC_CVARRAY :
                pfnMemSize = NdrpConformantVaryingArrayMemorySize;
                break;

            case FC_BOGUS_ARRAY :
                pfnMemSize = NdrpComplexArrayMemorySize;
                break;

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_WSTRING :
            // case FC_C_SSTRING :

            default :
                pfnMemSize = NdrpConformantStringMemorySize;
                break;
            }

        // Set the max count for non-complex conformant arrays.
        pStubMsg->MaxCount = *((ulong *)pBufferMark);

        // Mark where conformance count(s) are.
        pStubMsg->BufferMark = pBufferMark;

        (void) (*pfnMemSize)( pStubMsg,
                              pFormatArray );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer            = pStubMsg->PointerBufferMark;
        pStubMsg->MemorySize        = pStubMsg->PointerLength; 
        pStubMsg->PointerBufferMark = 0;
        pStubMsg->PointerLength     = 0;
        }

    if ( fIsEmbeddedStruct )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a fixed array of any number of dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   Size;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    if ( *pFormat == FC_SMFARRAY )
        {
        pFormat += 2;
        Size = *((ushort *&)pFormat)++;
        }
    else
        {
        pFormat += 2;
        Size = *((ulong UNALIGNED *&)pFormat)++;
        }

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + Size );
    pStubMsg->Buffer += Size;

    pStubMsg->MemorySize += Size;

    if ( *pFormat == FC_PP )
        {
        // Mark the location in the buffer where the array starts.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a top level one dimensional conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    //
    // Get the conformance count.
    //
    ALIGN(pStubMsg->Buffer,0x3);

    pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;

    return NdrpConformantArrayMemorySize( pStubMsg,
                                          pFormat );
}


unsigned long
NdrpConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the memory size of a one dimensional
    conformant array.  This is the entry point for an embedded conformant
    array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   Size;

    if ( ! pStubMsg->MaxCount )
        return pStubMsg->MemorySize;

    // Check bounds.
    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormat[4] & 0x0f );

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    // Increment to element size.
    pFormat += 2;

    // Compute array size.
    // check for possible mulitplication overflow attack here.
    Size = MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount, *((ushort *)pFormat) );

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, Size );
    pStubMsg->Buffer += Size;             

    pStubMsg->MemorySize += Size;

    if ( *pFormat == FC_PP )
        {
        // Mark the location in the buffer where the array starts.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a one dimensional top level conformant
    varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    //
    // Get the conformance count.
    //
    ALIGN(pStubMsg->Buffer,0x3);

    pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;

    return NdrpConformantVaryingArrayMemorySize( pStubMsg,
                                                 pFormat );
}


unsigned long
NdrpConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the memory size of a one dimensional
    conformant varying array.  This is the entry point for memory sizing an
    embedded conformant varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong           BufferSize;
    PFORMAT_STRING  pFormatVar;
    
    //
    // Get the offset and actual count in case needed for pointer sizing.
    //
    ALIGN(pStubMsg->Buffer,0x3);

    pStubMsg->Offset = *((long *&)pStubMsg->Buffer)++;
    pStubMsg->ActualCount = *((long *&)pStubMsg->Buffer)++;

    // Check bounds.
    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormat[4] & 0x0f );

    pFormatVar = pFormat + 8;
    CORRELATION_DESC_INCREMENT( pFormatVar );
    CHECK_BOUND( pStubMsg->ActualCount, *pFormatVar & 0x0f );

    if ( (pStubMsg->MaxCount < (pStubMsg->Offset + pStubMsg->ActualCount)) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    //
    // Do the memory size increment now in case the actual count is 0.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    // check for possible mulitplication overflow attack here.
    pStubMsg->MemorySize += MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount,  *((ushort *)(pFormat + 2)) );

    if ( ! pStubMsg->ActualCount )
        return pStubMsg->MemorySize;

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    // Increment to element size.
    pFormat += 2;

    BufferSize = pStubMsg->ActualCount * *((ushort *)pFormat);

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer += BufferSize;

    pFormat += 10;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        {
        // Mark the location in the buffer where the array starts.
        pStubMsg->BufferMark = pStubMsg->Buffer - BufferSize;

        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a top level or embedded varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   MemorySize;
    ulong   BufferSize;
    uchar   Alignment;
    long    Elements;

    //
    // Get the offset and actual count.
    //
    ALIGN(pStubMsg->Buffer,0x3);

    pStubMsg->Offset = *((long *&)pStubMsg->Buffer)++;
    pStubMsg->ActualCount = *((long *&)pStubMsg->Buffer)++;

    // Check bounds using the old part of correlation descr.
    CHECK_BOUND( pStubMsg->ActualCount,
                 pFormat[(*pFormat == FC_SMVARRAY) ? 8 : 12] & 0x0f );

    Elements =
        (*pFormat == FC_SMVARRAY) ?
        *((ushort *)(pFormat + 4)) : *((ulong UNALIGNED *)(pFormat + 6));

    if ( (((long)pStubMsg->Offset) < 0) ||
         (Elements < (long)(pStubMsg->ActualCount + pStubMsg->Offset)) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    Alignment = pFormat[1];

    if ( *pFormat == FC_SMVARRAY )
        {
        pFormat += 2;
        MemorySize = (ulong) *((ushort *)pFormat);
        
        pFormat += 4;
        }
    else
        {
        pFormat += 2;
        MemorySize = *((ulong UNALIGNED *)pFormat);
    
        pFormat += 8;
        }

    //
    // Do the memory size increment now in case the actual count is 0 and
    // we have return.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, Alignment );

    pStubMsg->MemorySize += MemorySize;

    if ( ! pStubMsg->ActualCount )
        return pStubMsg->MemorySize;

    ALIGN(pStubMsg->Buffer, Alignment);

    // check for possible mulitplication overflow attack here.
    BufferSize = MultiplyWithOverflowCheck( pStubMsg->ActualCount , *((ushort *)pFormat) );
   
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer += BufferSize;

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        {
        // Mark the start of the array in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - BufferSize;

        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    BOOL            fSetPointerBufferMark;
    PFORMAT_STRING  pFormatPP;

    //
    // We set this if we're doing a real 'all nodes' sizing, this array
    // is not embedded in another structure or array, and this is not an
    // array of ref pointers.
    //
    pFormatPP = pFormat + 12;
    CORRELATION_DESC_INCREMENT( pFormatPP );
    CORRELATION_DESC_INCREMENT( pFormatPP );

    fSetPointerBufferMark = ! pStubMsg->IgnoreEmbeddedPointers &&
                            ! pStubMsg->PointerBufferMark &&
                            *pFormatPP != FC_RP;

    //
    // More fun.  Make a recursive call so that we have a pointer to the end
    // of the array's flat stuff in the buffer.  Then we can properly get to
    // any embedded pointer members.  We have no way of knowing if there are
    // any embedded pointers so we're stuck doing this all the time.
    //
    if ( fSetPointerBufferMark )
        {
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // Save this since it gets clobbered.
        ulong MemorySizeSave = pStubMsg->MemorySize;
        uchar* pBufferSave = pStubMsg->Buffer;

        //
        // Get a buffer pointer to where the array's pointees are.
        //
        (void) NdrComplexArrayMemorySize( pStubMsg,
                                          pFormat );


        // This is where the array pointees start.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->PointerLength     = pStubMsg->MemorySize;
        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        
        pStubMsg->MemorySize = MemorySizeSave;
        pStubMsg->Buffer = pBufferSave;
        }

    if ( ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff ) &&
         ( pStubMsg->pArrayInfo == 0 ) )
        {
        //
        // The outer most array dimension sets the conformance marker.
        //
        
        ALIGN(pStubMsg->Buffer,0x3);

        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment past conformance count(s).
        pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormat, FALSE ) * 4;

        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

        }

    (void) NdrpComplexArrayMemorySize( pStubMsg,
                                       pFormat );

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer            = pStubMsg->PointerBufferMark;
        pStubMsg->MemorySize        = pStubMsg->PointerLength;
        pStubMsg->PointerLength     = 0;
        pStubMsg->PointerBufferMark = 0;
        }

    return pStubMsg->MemorySize;
}


unsigned long
NdrpComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the memory size of a complex array.  This
    is the entry point for memory sizing an embedded complex array.

    Used for FC_BOGUS_ARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ARRAY_INFO          ArrayInfo;
    PARRAY_INFO         pArrayInfo;
    PMEM_SIZE_ROUTINE   pfnMemSize;
    uchar *             pBufferSave;
    PFORMAT_STRING      pFormatSave;
    ulong               Elements;
    ulong               Count, CountSave;
    long                Dimension;
    uchar               Alignment;
    uchar *             pPointerIdMark;

    bool                IsBrokenInterfacePointerFormat = false;
    //
    // Setup if we are the outer dimension.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        pStubMsg->pArrayInfo = &ArrayInfo;

        ArrayInfo.Dimension = 0;
        ArrayInfo.BufferConformanceMark = (unsigned long *)pStubMsg->BufferMark;
        ArrayInfo.BufferVarianceMark = 0;
        }

    // Used for array of ref pointers only.
    pBufferSave = 0;

    pFormatSave = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    // Get the array alignment.
    Alignment = pFormat[1];

    pFormat += 2;

    // Get number of elements (0 if conformance present).
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = pArrayInfo->BufferConformanceMark[Dimension];

        // Check bounds
        CHECK_BOUND( Elements, *pFormat & 0x0f );
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        long    Offset;

        if ( Dimension == 0 )
            {
            ulong   VarianceSize;

            ALIGN(pStubMsg->Buffer,0x3);

            // Mark where the variance counts are.
            pArrayInfo->BufferVarianceMark = (unsigned long *)pStubMsg->Buffer;

            // Handle multidimensional arrays.
            VarianceSize = NdrpArrayDimensions( pStubMsg, pFormatSave, TRUE ) * 8;

            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + VarianceSize );
            pStubMsg->Buffer += VarianceSize;
            }

        Count = pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1];

        // Check bounds
        CHECK_BOUND( Count, *pFormat & 0x0f );

        Offset = pArrayInfo->BufferVarianceMark[(Dimension * 2)];

        if ( (Offset < 0) || (Elements < (Offset + Count)) )
            RpcRaiseException( RPC_X_INVALID_BOUND );
        }
    else
        {
        Count = Elements;
        }

    CountSave = Count;

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Only align the buffer if at least one element was shipped.
    //
    if ( Count )
        ALIGN(pStubMsg->Buffer,Alignment);

    pPointerIdMark = 0;

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            pfnMemSize = pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)];
            
            if ( FC_IP == *pFormat ) goto HandleInterfacePointer;
            break;

        case FC_IP :
HandleInterfacePointer:
            IsBrokenInterfacePointerFormat = !FixWireRepForDComVerGTE54( pStubMsg );
            pPointerIdMark = pStubMsg->Buffer;

            // Do not leave any space for the pointer if this is
            // the broken format.  But do position the pointee as if the
            // pointer was transmitted.
            if ( pStubMsg->IgnoreEmbeddedPointers ||
                 !IsBrokenInterfacePointerFormat )
                {
                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, Count * PTR_WIRE_SIZE );
                pStubMsg->Buffer += MultiplyWithOverflowCheck( Count , PTR_WIRE_SIZE );
                }
            goto HandleRefPointer;

        case FC_UP :
        case FC_FP :
        case FC_OP :
            pPointerIdMark = pStubMsg->Buffer;

            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, Count * PTR_WIRE_SIZE );
            pStubMsg->Buffer += MultiplyWithOverflowCheck( Count , PTR_WIRE_SIZE );
            // Fall through
        case FC_RP :
HandleRefPointer:
            //
            // Add in the size of the array explicitly.
            //
            LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );
            pStubMsg->MemorySize += MultiplyWithOverflowCheck( Elements, PTR_MEM_SIZE );
            
            if ( pStubMsg->IgnoreEmbeddedPointers )
                goto ComplexArrayMemSizeEnd;

            pfnMemSize = (PMEM_SIZE_ROUTINE) NdrpPointerMemorySize; 
            break;

        case FC_RANGE:
                {
            LENGTH_ALIGN( pStubMsg->MemorySize, SIMPLE_TYPE_ALIGNMENT( pFormat[1] ) );
            ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( pFormat[1] ) );

            pStubMsg->Buffer +=  MultiplyWithOverflowCheck( Count, SIMPLE_TYPE_BUFSIZE( pFormat[1] ) );
            pStubMsg->MemorySize += MultiplyWithOverflowCheck( Elements, SIMPLE_TYPE_MEMSIZE( pFormat[1] ) );
            // not really needed as it's checked after memsize is done
            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );
            goto ComplexArrayMemSizeEnd;
            break;
            }
        default :
            {
            ulong ByteCount;

            NDR_ASSERT( IS_SIMPLE_TYPE(*pFormat),
                        "NdrpComplexArrayMemorySize : bad format char" );

            ByteCount = MultiplyWithOverflowCheck( Count , SIMPLE_TYPE_BUFSIZE(*pFormat) );

            CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, ByteCount );
            pStubMsg->Buffer += ByteCount;

            if ( *pFormat == FC_ENUM16 )
                LENGTH_ALIGN( pStubMsg->MemorySize, sizeof(int) - 1 );
            else
                LENGTH_ALIGN( pStubMsg->MemorySize,
                              SIMPLE_TYPE_ALIGNMENT(*pFormat) );

            pStubMsg->MemorySize += MultiplyWithOverflowCheck( Elements, SIMPLE_TYPE_MEMSIZE( * pFormat ) );

            goto ComplexArrayMemSizeEnd;
            }
        }

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        pStubMsg->pArrayInfo = 0;

    if ( pfnMemSize == (PMEM_SIZE_ROUTINE) NdrpPointerMemorySize )
        {

        // If the broken format is used, the pointer and pointee
        // are where the pointee should have been.
        if (IsBrokenInterfacePointerFormat)
            SET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

        POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );
        
        for ( ;  Count--;  pPointerIdMark += PTR_WIRE_SIZE )
            {
            NdrpPointerMemorySize( 
                pStubMsg,
                pPointerIdMark,
                pFormat );
            }

        if (IsBrokenInterfacePointerFormat)
            RESET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

        }
    else
        {
        for ( ; Count--; )
            {
            // Keep track of multidimensional array dimension.
            if ( IS_ARRAY_OR_STRING(*pFormat) )
                pArrayInfo->Dimension = Dimension + 1;

            (*pfnMemSize)( pStubMsg,
                           pFormat );

            }
        }

    if ( pBufferSave )
        {
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer = pBufferSave;
        }

    //
    // If we had variance then we have to make sure and add in the node size
    // of any members that were not shipped.
    //
    if ( (CountSave < Elements) && (*pFormat != FC_RP) )
        {
        long    ElementSize;

        pArrayInfo->Dimension = Dimension + 1;
        pArrayInfo->MaxCountArray = pArrayInfo->BufferConformanceMark;

        pStubMsg->pArrayInfo = pArrayInfo;

        ElementSize = (long)( NdrpMemoryIncrement( pStubMsg,
                                                   0,
                                                   pFormat ) - (uchar*)0 );

        pArrayInfo->MaxCountArray = 0;

        //
        // We don't have the memory alignment anywhere, so align the memory
        // size to 8.  At worse we'll allocate a few extra bytes.
        //
        LENGTH_ALIGN(pStubMsg->MemorySize,0x7);
        pStubMsg->MemorySize += MultiplyWithOverflowCheck( (Elements - CountSave) , ElementSize );
        }

ComplexArrayMemSizeEnd:

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a non conformant string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, and FC_BSTRING (NT Beta2
    compatability only).

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   BufferSize;
    ulong   MemorySize;

    ALIGN(pStubMsg->Buffer,0x3);

    // Skip the offset.
    pStubMsg->Buffer += 4;

    BufferSize = *((long *&)pStubMsg->Buffer)++;

    MemorySize = *((ushort *)(pFormat + 2));

    if ( MemorySize < BufferSize )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    switch ( *pFormat )
        {
        case FC_WSTRING :
            // Buffer is already aligned on a 4 byte boundary.

            // Align memory just in case.
            LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
            MemorySize = MultiplyWithOverflowCheck( MemorySize, sizeof(wchar_t) );
            BufferSize = MultiplyWithOverflowCheck( BufferSize, sizeof(wchar_t) );
            break;
        case FC_SSTRING :
            MemorySize = MultiplyWithOverflowCheck( MemorySize, pFormat[1] );
            BufferSize = MultiplyWithOverflowCheck ( BufferSize, pFormat[1] );
            break;
        default :
            break;
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer += BufferSize;
    pStubMsg->MemorySize += MemorySize;

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    //
    // Get string size.
    //

    if ( pStubMsg->pArrayInfo != 0 )
        {
        //
        // If this is part of a multidimensional array then we get the location
        // where the conformance is from a special place.
        //
        pStubMsg->MaxCount =
            pStubMsg->pArrayInfo->
                      BufferConformanceMark[pStubMsg->pArrayInfo->Dimension];
        }
    else
        {
        ALIGN(pStubMsg->Buffer,0x3);

        pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;
        }

    return NdrpConformantStringMemorySize( pStubMsg,
                                           pFormat );
}


unsigned long
NdrpConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for determing the memory size of a conformant string.
    This is the entry point for an embedded conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   MemorySize;
    ulong   BufferSize;

    ALIGN(pStubMsg->Buffer,3);

    // Skip the offset.
    pStubMsg->Buffer += 4;

    BufferSize = *((long *&)pStubMsg->Buffer)++;

    MemorySize = (ulong)pStubMsg->MaxCount;

    // Check bounds.

    if ( (*pFormat != FC_C_SSTRING) && (pFormat[1] == FC_STRING_SIZED) )
        CHECK_BOUND( MemorySize, pFormat[2] & 0xf);

    //
    // Make sure the offset is 0 and the memory size is at least as
    // large as the buffer size.
    //
    if ( *((long *)(pStubMsg->Buffer - 8)) != 0 || 
         (MemorySize < BufferSize) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    switch ( *pFormat )
        {
        case FC_C_WSTRING :
            // Buffer is already aligned on a 4 byte boundary.

            // Align memory just in case.
            LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
            MemorySize = MultiplyWithOverflowCheck( MemorySize, sizeof(wchar_t) );
            BufferSize = MultiplyWithOverflowCheck( BufferSize, sizeof(wchar_t) );
            break;

        case FC_C_SSTRING :
            MemorySize = MultiplyWithOverflowCheck( MemorySize, pFormat[1] );
            BufferSize = MultiplyWithOverflowCheck( BufferSize, pFormat[1] );
            break;
        default :
            break;
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer += BufferSize;

    pStubMsg->MemorySize += MemorySize;

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of an encapsulated union.

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar   SwitchType;

    SwitchType = LOW_NIBBLE(pFormat[1]);

    //
    // No alignment needed.  Add number of bytes to the union.
    //
    pStubMsg->MemorySize += HIGH_NIBBLE(pFormat[1]);

    NO_CORRELATION;

    return NdrpUnionMemorySize( pStubMsg,
                                pFormat + 2,
                                SwitchType );
}


unsigned long RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a non-encapsulated union.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar    SwitchType;

    SwitchType = pFormat[1];

    //
    // Set the format string to the memory size and arm description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    return NdrpUnionMemorySize( pStubMsg,
                                pFormat,
                                SwitchType );
}


unsigned long
NdrpUnionMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               SwitchType )
/*++

Routine Description :

    Private routine for computing the memory size needed for a union.  This
    routine is used for sizing both encapsulated and non-encapsulated unions.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.
    SwitchType  - Union's switch type.

Return :

    The computed memory size.

--*/
{
    long        UnionSize;
    long        SwitchIs;
    long        Arms;
    uchar       Alignment;

    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *&)pStubMsg->Buffer)++;
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *&)pStubMsg->Buffer)++;
            break;
        case FC_SHORT :
        case FC_ENUM16 :
            ALIGN(pStubMsg->Buffer,0x1);
            SwitchIs = (long) *((short *&)pStubMsg->Buffer)++;
            break;
        case FC_USHORT :
        case FC_WCHAR :
            ALIGN(pStubMsg->Buffer,0x1);
            SwitchIs = (long) *((ushort *&)pStubMsg->Buffer)++;
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG
            ALIGN(pStubMsg->Buffer,0x3);
            SwitchIs = *((long *&)pStubMsg->Buffer)++;
            break;
        default :
            NDR_ASSERT(0,"NdrpUnionMemorySize : bad switch type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    //
    // Get the max flat union memory size.
    //
    UnionSize = *((ushort *&)pFormat)++;

    //
    // We're at the union_arms<2> field now, which contains both the
    // Microsoft union aligment value and the number of union arms.
    //

    //
    // Get the union alignment (0 if this is a DCE union).
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    ALIGN(pStubMsg->Buffer,Alignment);

    pStubMsg->MemorySize += UnionSize;

    //
    // Get number of union arms.
    //
    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff );

    //
    // Search for the correct arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        //
        // Raise an exception here.
        //
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm is emtpy.
    //
    if ( ! *((ushort *)pFormat) )
        return pStubMsg->MemorySize;

    //
    // Ok we've got the correct arm now.  The only goal now is to increment
    // the buffer pointer by the correct amount, and possibly add the size
    // of embedded pointers in the chosen union arm to the memory size.
    //

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        unsigned char FcType = pFormat[0];

        ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( FcType ));
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( FcType );

        return pStubMsg->MemorySize;
        }

    pFormat += *((signed short *)pFormat);

    if ( IS_POINTER_TYPE(*pFormat) )
        {

        if ( pStubMsg->IgnoreEmbeddedPointers )
            {
            ALIGN(pStubMsg->Buffer,0x3);
            pStubMsg->Buffer += PTR_WIRE_SIZE;
            return pStubMsg->MemorySize;
            }

        if ( pStubMsg->PointerBufferMark )
            {

            ALIGN(pStubMsg->Buffer,0x3);
            uchar *pPointerId = pStubMsg->Buffer;
            pStubMsg->Buffer += PTR_WIRE_SIZE;
            
            if ( !pStubMsg->IgnoreEmbeddedPointers )
                {
                POINTER_MEMSIZE_SWAP_CONTEXT SwapContext(pStubMsg);
                (void) NdrpPointerMemorySize( pStubMsg,
                                              pPointerId,
                                              pFormat );
                }
            
            return pStubMsg->MemorySize;
            }
        }

    //
    // Add in the size of arm.  We end up adding the size of the flat part
    // of the arm a second time here.
    // We do have to call this however, so that the buffer pointer is properly
    // updated.
    //
    return (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)])
           ( pStubMsg,
             pFormat );
}


unsigned long RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for the presented type of a
    transmit as or represent as.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size of the presented type object.

--*/
{
    unsigned long           MemorySize;
    unsigned short          QIndex;

    // Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);

    // Memsize the presented object.

    MemorySize = *(unsigned short *)(pFormat + 4);

    // Update our current count in the stub message.
    pStubMsg->MemorySize += MemorySize;

    // Move the pointer in the buffer behind the transmitted object
    // for the next field to be memsized correctly.

    pFormat += 8;
    pFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pFormat ))
        {
        // Simple type.
        ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( *pFormat) );
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( *pFormat );
        }
    else
        {
            uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
            pStubMsg->PointerBufferMark = 0;
            NDR_POINTER_QUEUE *pOldQueue = NULL;

            if ( pStubMsg->pPointerQueueState)
                {
                pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
                pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
                }

            RpcTryFinally
                {
                (*pfnMemSizeRoutines[ ROUTINE_INDEX( *pFormat) ])( pStubMsg, pFormat );
                }
            RpcFinally
                {
                pStubMsg->PointerBufferMark = PointerBufferMarkSave;
                if ( pStubMsg->pPointerQueueState)
                    {
                    pStubMsg->pPointerQueueState->SetActiveQueue(pOldQueue);
                    }
                }
            RpcEndFinally
        }

    return( MemorySize );
}



void
NdrpUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
{

    unsigned long MemorySizeSave;

    // Flat type.
    // Optimization: if we know the wire size, don't walk to size it.

    if ( *(unsigned short *)(pFormat + 6) != 0 )
        {
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + *(unsigned short *)(pFormat + 6));
        pStubMsg->Buffer += *(unsigned short *)(pFormat + 6);
        return;
        }

    // Unknown wire size: we need to step through the buffer.
    // However, the memory size may have nothing to do with
    // the wire type description..
    // so, we need to remember what the current memory size is.

    MemorySizeSave = pStubMsg->MemorySize;

    pFormat += 8;
    pFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pFormat ))
        {
        // Simple type.
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( *pFormat );
        }
    else
        {
        (*pfnMemSizeRoutines[ ROUTINE_INDEX( *pFormat) ])( pStubMsg, pFormat );
        }

    pStubMsg->MemorySize = MemorySizeSave;

}

void 
NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    NdrpUserMarshalMemorySize( pStubMsg,
                               pFormat );
}
#if defined(DBG)
void 
NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


unsigned long RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a usr_marshal type.
    See mrshl.c for the description of the layouts.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The memory size of the usr_marshall object.

--*/
{
    unsigned long           MemorySize;

    // The memory sizing routine can be called only when sizing a complex
    // struct for memory allocation.
    // Hence, IgnoreEmbeddedPointer in this case has to be on.

    // Memsize the presented object.

    MemorySize = *(unsigned short *)(pFormat + 4);

    // Update our current count in the stub message.
    pStubMsg->MemorySize += MemorySize;

    // Move the pointer in the buffer behind the transmitted object
    // for the next field to be memsized correctly.

    ALIGN( pStubMsg->Buffer, LOW_NIBBLE( pFormat[1] ) );

    if ( pFormat[1] & USER_MARSHAL_POINTER )
        {

        ulong PointerMarker = 0;

        if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  ||
             ((pFormat[1] & USER_MARSHAL_REF) && pStubMsg->PointerBufferMark) )
            {
            PointerMarker = *((unsigned long * &)pStubMsg->Buffer)++;
            }

        if ( pStubMsg->IgnoreEmbeddedPointers )
            return pStubMsg->MemorySize;

        if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  &&
            !PointerMarker)
           return pStubMsg->MemorySize;

        if ( !pStubMsg->pPointerQueueState ||
             !pStubMsg->pPointerQueueState->GetActiveQueue() )
            {
            // If we are embedded, switch to the pointee buffer.
            POINTER_MEMSIZE_SWAP_CONTEXT NewContext(pStubMsg);

            NdrpUserMarshalMemorySize( 
                pStubMsg,
                pFormat );
            }
        else
            {
            NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT*pElement = 
               new(pStubMsg->pPointerQueueState) 
                   NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT(pFormat );
            pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
            }
        
        return pStubMsg->MemorySize;
        }

    NdrpUserMarshalMemorySize( 
        pStubMsg,
        pFormat );

    return pStubMsg->MemorySize;
}


void
NdrpInterfacePointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size needed for an interface pointer.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The current memory size.

--*/
{

    ALIGN( pStubMsg->Buffer, 3 );
    // Pick up the conformant size and the count field.
    ulong MaxCount = *((unsigned long *&) pStubMsg->Buffer)++;
    ulong Size     = *((unsigned long *&) pStubMsg->Buffer)++;

    //Check the array bounds
    if ( Size != MaxCount )
        RpcRaiseException( RPC_X_BAD_STUB_DATA );

    IStream* pStream = 0;

    RpcTryFinally
    {
        if (MaxCount > 0)
            {
            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, MaxCount );
            if ( IS_WALKIP( pStubMsg->uFlags) )
                {

#if defined(DEBUG_WALKIP)
                CHAR AppName[MAX_PATH];
                memset(AppName, 0, sizeof(AppName ) );
                GetModuleFileNameA( NULL, AppName, sizeof(AppName ) );
                DbgPrint("WALKIP32 %s %p\n", AppName, pStubMsg->Buffer );
#else
                pStream = (*NdrpCreateStreamOnMemory)(pStubMsg->Buffer, MaxCount);
                if(pStream == 0)
                    RpcRaiseException(RPC_S_OUT_OF_MEMORY);

                HRESULT hr = (*pfnCoReleaseMarshalData)(pStream);
                
                if(FAILED(hr))
                    RpcRaiseException(hr);
#endif
                }
            }

    }
    RpcFinally
        {
        if ( pStream ) pStream->Release();
        pStubMsg->Buffer += MaxCount;
        }
    RpcEndFinally
}

unsigned long RPC_ENTRY
NdrInterfacePointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
{
    ALIGN(pStubMsg->Buffer,0x3);
    ulong PtrValue = *((long *&)pStubMsg->Buffer)++;

    LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );
    pStubMsg->MemorySize += PTR_MEM_SIZE;

    if ( !PtrValue || pStubMsg->IgnoreEmbeddedPointers )
        return pStubMsg->MemorySize;
     
    NdrpInterfacePointerMemorySize( pStubMsg,
                                    pFormat );

    return pStubMsg->MemorySize;
}


void
NdrpEmbeddedPointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for all embedded pointers in an
    array or a structure.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );
    uchar *     pBufPtr;
    uchar *     pBufferMark;
    uchar *     pBufferSave;
    ULONG_PTR   MaxCountSave;

    MaxCountSave = pStubMsg->MaxCount;

    pBufferMark = pStubMsg->BufferMark;

    // Increment past the FC_PP and pad.
    pFormat += 2;

    for (;;)
        {

        if ( *pFormat == FC_END )
            {
            return;
            }

        //
        // Check for FC_FIXED_REPEAT or FC_VARIABLE_REPEAT.
        //
        if ( *pFormat != FC_NO_REPEAT )
            {
            pStubMsg->MaxCount = MaxCountSave;

            pStubMsg->BufferMark = pBufferMark;

            NdrpEmbeddedRepeatPointerMemorySize( pStubMsg,
                                                 &pFormat );

            // Continue to the next pointer.
            continue;
            }

        // Compute the pointer to the pointer id in the buffer to size.
        pBufPtr = (pBufferMark + *((signed short *)(pFormat + 4)));

        // Increment to the pointer description.
        pFormat += 6;

        NdrpPointerMemorySize( 
            pStubMsg,
            pBufPtr,
            pFormat );

        // Increment to next pointer description.
        pFormat += 4;
        } // for
}


void
NdrpEmbeddedRepeatPointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING *    ppFormat )
/*++

Routine Description :

    Computes the memory size required for all embedded pointers in an
    array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar *         pBufPtr;
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormat;
    PFORMAT_STRING  pFormatSave;
    ulong           RepeatCount, RepeatIncrement, Pointers, PointersSave;

    pBufferMark = pStubMsg->BufferMark;

    pFormat = *ppFormat;

    switch ( *pFormat )
        {
        case FC_FIXED_REPEAT :
            // Increment past the FC_FIXED_REPEAT and FC_PAD.
            pFormat += 2;

            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = *((ushort *&)pFormat)++;

            break;

        case FC_VARIABLE_REPEAT :
            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = (ulong)pStubMsg->MaxCount;

            pFormat += 2;

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerMemorySize : bad format");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Get the increment amount between successive pointers.
    RepeatIncrement = *((ushort *&)pFormat)++;

    // Offset to array is ignored.
    pFormat += 2;

    // Get number of pointers.
    PointersSave = Pointers = *((ushort *&)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop for the number of shipped array elements.
    //
    for ( ; RepeatCount--;
            pBufferMark += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        //
        // Loop for the number of pointer in each array element (which could
        // be greater than 0 for an array of structures).
        //
        for ( ; Pointers--; )
            {
            pFormat += 2;

            // Get the buffer pointer where the pointer id is.
            pBufPtr = pBufferMark + *((signed short *&)pFormat)++;

            NdrpPointerMemorySize( 
                   pStubMsg,
                   pBufPtr,
                   pFormat );

            // Increment to the next the pointer description.
            pFormat += 4;
            }
        }

    // Get the format string pointer past this repeat pointer description.
    *ppFormat = pFormatSave + PointersSave * 8;
}


#ifdef _CS_CHAR
unsigned long RPC_ENTRY
NdrCsTagMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a cs tag.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer to FC_CS_TAG in the format string.

Return :

    The computed memory size.

--*/
{
    // We need to set the tag in the stub message so that it can be used
    // later for sizing/unmarshalling arrays

    NdrpGetSetCSTagUnmarshall(
            pStubMsg,
            (NDR_CS_TAG_FORMAT *) pFormat);

    pStubMsg->Buffer += sizeof( ulong );
    pStubMsg->MemorySize += sizeof( ulong );

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrCsArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a cs_char array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer to FC_CS_TAG in the format string.

Return :

    The computed memory size.

--*/
{
    NDR_CS_ARRAY_FORMAT            *pCSFormat;
    NDR_CS_SIZE_CONVERT_ROUTINES   *CSRoutines;
    CS_TYPE_LOCAL_SIZE_ROUTINE      LocalSizeRoutine;
    IDL_CS_CONVERT                  ConversionType;
    ulong                           ArraySize;
    ulong                           WireLength;
    error_status_t                  status;

    pCSFormat = (NDR_CS_ARRAY_FORMAT *) pFormat;

    NDR_ASSERT( NULL != pStubMsg->pCSInfo, "cs_char stub info not set up");

    // Get all the info out of the FC_CS_ARRAY structure and bump pFormat
    // to point to the underlying data descriptor

    CSRoutines = pStubMsg->StubDesc->CsRoutineTables->pSizeConvertRoutines;
    LocalSizeRoutine = CSRoutines[ pCSFormat->CSRoutineIndex].pfnLocalSize;

    pFormat += pCSFormat->DescriptionOffset;

    // Get the size of the data on the wire

    WireLength = PtrToUlong( NdrpMemoryIncrement( pStubMsg, 0, pFormat ) );

    LocalSizeRoutine(
            pStubMsg->RpcMsg->Handle,
            pStubMsg->pCSInfo->WireCodeset,
            WireLength,
            &ConversionType,
            &ArraySize,
            &status);

    if ( RPC_S_OK != status )
        RpcRaiseException( status );

    pStubMsg->MemorySize += ArraySize * pCSFormat->UserTypeSize;
    
    return pStubMsg->MemorySize;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\interp.h ===
/************************************************************************

Copyright (c) 1993 Microsoft Corporation

Module Name :

    interp.h

Abstract :

    Definitions for the client and server stub interpreter.  Compiled from
    previous files srvcall.h, srvoutp.h, and getargs.h.

Author :

    DKays       October 1994

Revision History :

  ***********************************************************************/

#ifndef _INTERP_
#define _INTERP_

//
// Stack and argument defines.
//

#if defined(_IA64_) || defined(_AMD64_)
#define REGISTER_TYPE               _int64
#else
#define REGISTER_TYPE               int
#endif

#define RETURN_SIZE                 8

//
// Define interpreter limitations.
//

#define ARGUMENT_COUNT_THRESHOLD    16

#define MAX_STACK_SIZE              ARGUMENT_COUNT_THRESHOLD * sizeof(double)

//
// The maximum number of context handles parameters in a procedure that we
// can handle.
//

#define MAX_CONTEXT_HNDL_NUMBER     8

//
// Argument caching data structures.
//

#define QUEUE_LENGTH                ARGUMENT_COUNT_THRESHOLD

typedef struct _ARG_QUEUE_INFO
    {
    PFORMAT_STRING  pFormat;

    uchar *         pArg;
    uchar **        ppArg;

    short           ParamNum;

    short           IsReturn            : 1;
    short           IsBasetype          : 1;
    short           IsIn                : 1;
    short           IsOut               : 1;
    short           IsOutOnly           : 1;

    short           IsDeferredFree      : 1;

    short           IsDontCallFreeInst  : 1;
    } ARG_QUEUE_ELEM, *PARG_QUEUE_ELEM;

typedef struct _ARG_QUEUE
    {
    long                Length;
    ARG_QUEUE_ELEM *    Queue;
    } ARG_QUEUE, *PARG_QUEUE;

//
// Argument retrieval macros.
//

#define INIT_ARG(argptr,arg0)   va_start(argptr, arg0)

//
// Both MIPS and x86 are 4 byte aligned stacks, with MIPS supporting 8byte
// alignment on the stack as well. Their va_list is essentially an
// unsigned char *.
//

#if     defined(_IA64_)
#define GET_FIRST_IN_ARG(argptr)
#define GET_FIRST_OUT_ARG(argptr)
#elif   defined(_AMD64_)
#define GET_FIRST_IN_ARG(argptr)
#define GET_FIRST_OUT_ARG(argptr)
#else
#define GET_FIRST_IN_ARG(argptr)            argptr = *(va_list *)argptr
#define GET_FIRST_OUT_ARG(argptr)           argptr = *(va_list *)argptr
#endif

#define GET_NEXT_C_ARG(argptr,type)         va_arg(argptr,type)

#define SKIP_STRUCT_ON_STACK(ArgPtr, Size)	ArgPtr += Size

#define GET_STACK_START(ArgPtr)			    ArgPtr
#define GET_STACK_POINTER(ArgPtr, mode)		ArgPtr

//
// Use the following macro _after_ argptr has been saved or processed
//
#define SKIP_PROCESSED_ARG(argptr, type) \
                    GET_NEXT_C_ARG(argptr, type); \
                    GET_STACK_POINTER(argptr,type)

#define GET_NEXT_S_ARG(argptr,type)     argptr += sizeof(type)

//
// Some typedefs so that the C compiler front end won't complain about calling
// the server manager function with a specific number of arguments. This may
// help the C compiler code generator too.
//

typedef _int64 (__RPC_API * MANAGER_FUNCTION)(void);
typedef _int64 (__RPC_API * MANAGER_FUNCTION1)(
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION2)(
            REGISTER_TYPE, REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION3)(
            REGISTER_TYPE, REGISTER_TYPE, REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION4)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION5)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION6)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION7)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION8)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION9)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION10)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION11)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION12)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION13)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION14)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION15)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION16)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION17)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION18)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION19)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION20)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION21)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION22)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION23)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION24)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION25)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION26)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION27)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION28)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION29)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION30)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION31)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);
typedef _int64 (__RPC_API * MANAGER_FUNCTION32)(
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,
            REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE,REGISTER_TYPE);


#if !defined(__RPC_WIN64__)

void
NdrServerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    void *              pThis
    );

void
NdrCallServerManager (
    MANAGER_FUNCTION    pFtn,
    double *            pArgs,
    ulong               NumRegisterArgs,
    BOOL                fHasReturn
    );

#endif // !defined(__RPC_WIN64__)

void
Ndr64OutInit(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PNDR64_FORMAT           pFormat,
    uchar **                ppArg
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\memsizep.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    memsizep.h

Abtract :

    Contains private memory sizing routine definitions.

Author :

    David Kays  dkays   November 1993

Revision History :

--------------------------------------------------------------------*/

typedef     ulong	(RPC_ENTRY * PMEM_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
                        PFORMAT_STRING		pFormat
                    );

typedef     ulong	(* PPRIVATE_MEM_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
                        PFORMAT_STRING		pFormat
                    );

extern const PMEM_SIZE_ROUTINE * pfnMemSizeRoutines;

ulong 
NdrpPointerMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
	uchar *				pBufferMark,
    PFORMAT_STRING		pFormat
	);

ulong 
NdrpConformantArrayMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
	);

ulong 
NdrpConformantVaryingArrayMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
	);

ulong 
NdrpComplexArrayMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
	);

ulong 
NdrpConformantStringMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
	);

ulong
NdrpUnionMemorySize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat,
	uchar				SwitchIs
    );

void
NdrpEmbeddedPointerMemorySize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
    );

void
NdrpEmbeddedRepeatPointerMemorySize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING *	ppFormatt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\iid.cxx ===
// Copyright (c) 1993-1999 Microsoft Corporation

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;


extern "C"
{

extern const IID IID_IPSFactoryHook = {0x2f5c0480, 0x6bc0, 0x11cf, {0x89, 0xb9, 0x0, 0xaa, 0x0, 0x57, 0xb1, 0x49}};

extern const IID IID_IDispatch = {0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IStream = {0x0000000c,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IUnknown      = {0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
extern const IID IID_IClassFactory = {0x00000001,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IRpcChannelBuffer  = {0xD5F56B60,0x593B,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
extern const IID IID_IRpcChannelBuffer2 = {0x594f31d0,0x7f19,0x11d0,{0xb1,0x94,0x00,0xa0,0xc9,0x0d,0xc8,0xbf}};
extern const IID IID_IRpcChannelBuffer3 = {0x25B15600,0x0115,0x11d0,{0xBF,0x0D,0x00,0xAA,0x00,0xB8,0xDF,0xD2}};
extern const IID IID_IAsyncRpcChannelBuffer = {0xa5029fb6,0x3c34,0x11d1,{0x9c,0x99,0x00,0xc0,0x4f,0xb9,0x98,0xaa}};
                                     
extern const IID IID_IRpcProxyBuffer = {0xD5F56A34,0x593B,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};
extern const IID IID_IRpcStubBuffer  = {0xD5F56AFC,0x593B,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};

extern const IID IID_IPSFactoryBuffer = {0xD5F569D0,0x593B,0x101A,{0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A}};

extern const IID GUID_NULL = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

extern const IID IID_ISynchronize  = {0x00000030,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
extern const IID IID_ICallFactory  = {0x1c733a30,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}};

extern const IID IID_ITypeFactory = {0x0000002E,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
extern const IID IID_ITypeMarshal = {0x0000002D,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IMarshal = {0x00000003,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IRpcHelper  = {0x00000149,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
extern const IID CLSID_RpcHelper = {0x0000032a,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern const IID IID_IReleaseMarshalBuffers = {0xeb0cb9e8,0x7996,0x11d2,{0x87,0x2e,0x00,0x00,0xf8,0x08,0x08,0x59}};

extern const IID IID_IRpcSyntaxNegotiate = {0x58a08519,0x24c8,0x4935,{0xb4,0x82,0x3f,0xd8,0x23,0x33,0x3a,0x4f}};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\mrshlp.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    mrshlp.c

Abstract :

    This file contains the routines for marshalling an array's or a structure's
    embedded pointers and for computing conformance and variance counts and 
    union switch values.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "attack.h"
#include "interp2.h"
#include "mulsyntx.h"
#include "asyncu.h"
#include "pointerq.h"


PFORMAT_STRING
NdrpEmbeddedPointerMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls an array's or a structure's embedded pointers.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure or array whose embedded pointers 
                  are being marshalled. 
    pFormat     - The format string pointer layout.  Should point to the 
                  pointer layout's beginning FC_PP character upon entry. 

Return :

    Format string pointer after the pointer layout.

 --*/
{
    uchar **        ppMemPtr;
    uchar *         pBufPtr;
    uchar *         pBufferMark;
    uchar *         pMemorySave;
    ULONG_PTR       MaxCountSave;
    long            OffsetSave;

    MaxCountSave = pStubMsg->MaxCount;
    OffsetSave = pStubMsg->Offset;
    
    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

    pMemorySave = pStubMsg->Memory;

    // This is where the embedding structure or array begins in the buffer.
    pBufferMark = pStubMsg->BufferMark;

    //
    // The Memory field in the stub message keeps track of the pointer to 
    // the current embedding structure or array.  This is needed to handle 
    // size/length pointers, so that we can get a pointer to the current 
    // embedding struct when computing conformance and variance.
    //
    pStubMsg->Memory = pMemory;

    // Skip FC_PP and FC_PAD.
    pFormat += 2;

    for (;;) 
        {

        if ( *pFormat == FC_END ) 
            {
            pStubMsg->Memory = pMemorySave;

            return pFormat;
            }

        //
        // Check for FC_FIXED_REPEAT and FC_VARIABLE_REPEAT.
        //
        if ( *pFormat != FC_NO_REPEAT ) 
            {
            pStubMsg->MaxCount = MaxCountSave;
            pStubMsg->Offset = OffsetSave;

            pStubMsg->BufferMark = pBufferMark;

            pFormat = NdrpEmbeddedRepeatPointerMarshall( pStubMsg,
                                                         pMemory,
                                                         pFormat );
            // Continue to the next pointer.
            continue;
            } 

        // Compute the pointer to the pointer to marshall.
        ppMemPtr = (uchar **)(pMemory + *((signed short *)(pFormat + 2)));

        //
        // Compute the location in the buffer where the pointer's value will be 
        // marshalled.  Needed for full pointers.
        //
        pBufPtr = pBufferMark + *((signed short *)(pFormat + 4));

        // Increment to the pointer description.
        pFormat += 6;

        //
        // Now marshall the pointer.  
        //
        NdrpPointerMarshall( pStubMsg,
                             pBufPtr,
                             *ppMemPtr,
                             pFormat );

        // Increment to the next pointer description.
        pFormat += 4;

        } // for
}


PFORMAT_STRING
NdrpEmbeddedRepeatPointerMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls an array's embedded pointers.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array whose embedded pointers are being marshalled.
    pFormat     - Pointer layout format string description.

Return :

    Format string pointer after the pointer layout.

--*/
{
    uchar **        ppMemPtr;
    uchar *         pBufPtr;
    PFORMAT_STRING  pFormatSave;
    uchar *         pMemorySave;
    uchar *         pBufferMark;
    ulong           RepeatCount, RepeatIncrement, Pointers, PointersSave;

    pMemorySave = pStubMsg->Memory;

    //
    // This is where the current embedding structure or array begins in 
    // the buffer.
    //
    pBufferMark = pStubMsg->BufferMark;

    // Get the number of shipped elements in the array.
    switch ( *pFormat ) 
        {
        case FC_FIXED_REPEAT :
            pFormat += 2;

            RepeatCount = *((ushort *)pFormat);

            break;

        case FC_VARIABLE_REPEAT :
            RepeatCount = (ulong)pStubMsg->MaxCount;

            //
            // Check if this variable repeat instance also has a variable
            // offset (this would be the case for a conformant varying array
            // of pointers).  If so then increment the memory pointer by the
            // increment size time the variance offset.
            //
            if ( pFormat[1] == FC_VARIABLE_OFFSET ) 
                pMemory += *((ushort *)(pFormat + 2)) * pStubMsg->Offset;

            // else pFormat[1] == FC_FIXED_OFFSET - do nothing

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Increment format string to increment field.
    pFormat += 2;

    // Get the increment amount between successive pointers.
    // This is actually an increment over the array element.
    RepeatIncrement = *((ushort * &)pFormat)++;

    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // or array to the array whose pointers we're marshalling.
    //
    pStubMsg->Memory += *((ushort * &)pFormat)++;

    // Get the number of pointers in this repeat instance.
    PointersSave = Pointers = *((ushort * &)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop over the number of shipped elements of the array.
    //
    for ( ; RepeatCount--;  
            pBufferMark += RepeatIncrement,
            pMemory += RepeatIncrement,
            pStubMsg->Memory += RepeatIncrement ) 
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        //
        // Loop over the number of pointer per array element (could be 
        // greater than one for an array of structures).
        //
        for ( ; Pointers--; ) 
            {
            ppMemPtr = (uchar **)(pMemory + *((signed short * &)pFormat)++); 

            pBufPtr = pBufferMark + *((signed short * &)pFormat)++;

            NdrpPointerMarshall( pStubMsg,
                                 pBufPtr,
                                 *ppMemPtr,
                                 pFormat );

            // Increment to the next pointer's offset_in_memory.
            pFormat += 4;
            }
        }

    pStubMsg->Memory = pMemorySave;

    // Return the format string pointer past the pointer descriptions.
    return pFormatSave + PointersSave * 8;
}


ULONG_PTR 
NdrpComputeConformance ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    This routine computes the conformant size for an array or the switch_is
    value for a union.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array, string, or union whose size or switch_is
                  is being computed.  This is ignored for top level parameters.
    pFormat     - Format string description of the array, string, or union.

Return :

    The array or string size or the union switch_is.

Note:
    Async splitting:
    The only thing that the compiler should generate with the FC_SPLIT_* operations
    should be top level conformance.
    Expr evaluation routines and top level multi-dim sizing is not supported with 
    the async uuid split.

Note64:
    On 64b platform this routine is can return 8 bytes of a iid_is pointer.
    However, the MaxCount field does not need to keep it and it stays as a ulong.
    

--*/
{
    void *          pCount;
    LONG_PTR       Count;

    unsigned char   FormatCopy[4];
    BOOL            fAsyncSplit = FALSE;

    static uchar    Increments[] = 
                            { 
                            4,              // Conformant array.
                            4,              // Conformant varying array.
                            0, 0,           // Fixed arrays - unused.
                            0, 0,           // Varying arrays - unused.
                            4,              // Complex array.

                            2,              // Conformant char string. 
                            2,              // Conformant byte string.
                            4,              // Conformant stringable struct. 
                            2,              // Conformant wide char string.

                            0, 0, 0, 0,     // Non-conformant strings - unused.

                            0,              // Encapsulated union - unused. 
                            2,              // Non-encapsulated union.
                            2,              // Byte count pointer.
                            0, 0,           // Xmit/Rep as - unused.
                            2               // Interface pointer.
                            };

    //
    // Advance the format string to the size_is, switch_is, iid_is, or
    // byte count description.
    //
    pFormat += Increments[*pFormat - FC_CARRAY];

    pCount = 0;

    //
    // First check if this is a callback.
    //
    if ( pFormat[1] == FC_CALLBACK ) 
        {
        uchar *     pOldStackTop;
        ushort      Index;

        // Index into expression callback routines table.
        Index = *((ushort *)(pFormat + 2));

        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval != 0,
                   "NdrpComputeConformance : no expr eval routines");
        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval[Index] != 0,
                   "NdrpComputeConformance : bad expr eval routine index");

        pOldStackTop = pStubMsg->StackTop;

        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        if ( (*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE ) 
            {
            if ( (*pFormat & 0xf0) == FC_POINTER_CONFORMANCE )
                pMemory = pStubMsg->Memory;
            pStubMsg->StackTop = pMemory;
            }

        //
        // This call puts the result in pStubMsg->MaxCount.
        //
        (*pStubMsg->StubDesc->apfnExprEval[Index])( pStubMsg );

        pStubMsg->StackTop = pOldStackTop;

        return pStubMsg->MaxCount;
        }

    if ( (*pFormat & 0xf0) == FC_NORMAL_CONFORMANCE )
        {
        // Get the address where the conformance variable is in the struct.
        pCount = pMemory + *((signed short *)(pFormat + 2));
        goto ComputeConformantGetCount;
        }

    // See if this is an async split

    if ( pFormat[1] & 0x20 )
        {
        fAsyncSplit = TRUE;
        RpcpMemoryCopy( & FormatCopy[0], pFormat, 4 );
        pFormat = (PFORMAT_STRING) & FormatCopy[0];

        // Remove the async marker
        FormatCopy[1] = pFormat[1] & (unsigned char)~0x20;
        }

    //
    // Get a pointer to the conformance describing variable.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_CONFORMANCE ) 
        {
        //
        // Top level conformance.  For /Os stubs, the stubs put the max
        // count in the stub message.  For /Oi stubs, we get the max count
        // via an offset from the stack top.
        //
        if ( pStubMsg->StackTop ) 
            {
            if ( fAsyncSplit )
                {
                PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg;

                pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE) pStubMsg->pAsyncMsg;

                pCount = pAsyncMsg->BeginStack + *((ushort *)(pFormat + 2));
                }
            else
                pCount = pStubMsg->StackTop + *((ushort *)(pFormat + 2));
            goto ComputeConformantGetCount;
            }
        else
            {
            //
            // If this is top level conformance with /Os then we don't have 
            // to do anything, the proper conformance count is placed in the 
            // stub message inline in the stubs.
            //
            return pStubMsg->MaxCount;
            }
        }

    //
    // If we're computing the size of an embedded sized pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    if ( (*pFormat & 0xf0) == FC_POINTER_CONFORMANCE )
        {
        pMemory = pStubMsg->Memory;
        pCount = pMemory + *((signed short *)(pFormat + 2));
        goto ComputeConformantGetCount;
        }

    //
    // Check for constant size/switch.
    //
    if ( (*pFormat & 0xf0) == FC_CONSTANT_CONFORMANCE )
        {
        //
        // The size/switch is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        Count =  (LONG_PTR) ((ulong)pFormat[1] << 16);
        Count |= (LONG_PTR) *((ushort *)(pFormat + 2));

        goto ComputeConformanceEnd;
        }

    //
    // Check for conformance of a multidimensional array element in 
    // a -Os stub.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE )
        {
        long Dimension;

        if ( fAsyncSplit )
            RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

        //
        // If pArrayInfo is non-null than we have a multi-D array.  If it
        // is null then we have multi-leveled sized pointers.
        //
        if ( pStubMsg->pArrayInfo ) 
            {
            Dimension = pStubMsg->pArrayInfo->Dimension;
            pStubMsg->MaxCount = pStubMsg->pArrayInfo->MaxCountArray[Dimension];
            }
        else
            {
            Dimension = *((ushort *)(pFormat + 2));
            pStubMsg->MaxCount = pStubMsg->SizePtrCountArray[Dimension];
            }

        return pStubMsg->MaxCount;
        }

    NDR_ASSERT(0, "NdrpComputeConformance:, Invalid Conformance type");
    RpcRaiseException( RPC_S_INTERNAL_ERROR );
    return 0; //bogus return

ComputeConformantGetCount:

    //
    // Must check now if there is a dereference op.
    //
    if ( pFormat[1] == FC_DEREFERENCE )
        {
        pCount = *(void **)pCount;
        }

    //
    // Now get the conformance count.
    //
    switch ( *pFormat & 0x0f ) 
        {
        case FC_HYPER :
            // iid_is on 64b platforms only.
            Count = *((LONG_PTR *)pCount);
            break;

        case FC_ULONG :
            Count = (LONG_PTR)*((ulong *)pCount);
            break;

        case FC_LONG :
            Count = *((long *)pCount);
            break;

        case FC_ENUM16:
        case FC_USHORT :
            Count = (long) *((ushort *)pCount);
            break;

        case FC_SHORT :
            Count = (long) *((short *)pCount);
            break;

        case FC_USMALL :
            Count = (long) *((uchar *)pCount);
            break;

        case FC_SMALL :
            Count = (long) *((char *)pCount);
            break;

        default :
            NDR_ASSERT(0,"NdrpComputeConformance : bad count type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        } 

    //
    // Check the operator.
    //
    switch ( pFormat[1] ) 
        {
        case FC_DIV_2 :
            Count /= 2;
            break;
        case FC_MULT_2 :
            Count *= 2;
            break;
        case FC_SUB_1 :
            Count -= 1;
            break;
        case FC_ADD_1 :
            Count += 1;
            break;
        default :
            // OK
            break;
        }

ComputeConformanceEnd:

    // Max count is not used for iid_is.

    pStubMsg->MaxCount = (ulong) Count;

    return (ULONG_PTR) Count;
}


void 
NdrpComputeVariance ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the variance (offset and actual count) for an array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array whose variance is being computed.  This
                  is unused for a top level parameter.
    pFormat     - Format string description of the array.

Return :

    None.

--*/
{
    void *          pLength;
    LONG_PTR        Length;

    unsigned char   FormatCopy[4];
    BOOL            fAsyncSplit = FALSE;

    uchar   FcType = *pFormat;

    //
    // Advance the format string to the variance description.
    //

    static uchar    Increments[] = { 8,     // Conformant varying array.
                                     0, 0,  // Fixed arrays - unsed.
                                     8, 12, // Varying array.
                                     8      // Complex array. 
                                   };

    pFormat += Increments[ FcType - FC_CVARRAY];

    if (FcType == FC_CVARRAY  ||  FcType == FC_BOGUS_ARRAY)
        {
        CORRELATION_DESC_INCREMENT( pFormat );
        }

    pLength = 0;

    //
    // First check if this is a callback.
    //
    if ( pFormat[1] == FC_CALLBACK ) 
        {
        ULONG_PTR   OldMaxCount;
        uchar *     pOldStackTop;
        ushort      Index;

        Index = *((ushort *)(pFormat + 2));

        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval != 0,
                   "NdrpComputeConformance : no expr eval routines");
        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval[Index] != 0,
                   "NdrpComputeConformance : bad expr eval routine index");

        pOldStackTop = pStubMsg->StackTop;

        // This gets trampled by the callback routine.
        OldMaxCount = pStubMsg->MaxCount;

        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        if ( (*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE ) 
            {
            if ( (*pFormat & 0xf0) == FC_POINTER_VARIANCE )
                pMemory = pStubMsg->Memory;
            pStubMsg->StackTop = pMemory;
            }

        //
        // This puts the computed offset in pStubMsg->Offset and the length 
        // in pStubMsg->MaxCount.
        //
        (*pStubMsg->StubDesc->apfnExprEval[Index])( pStubMsg );

        // Put the length in the proper field.
        pStubMsg->ActualCount = (ulong)pStubMsg->MaxCount;

        pStubMsg->MaxCount = OldMaxCount;

        pStubMsg->StackTop = pOldStackTop;

        return;
        }

    if (  (*pFormat & 0xf0) == FC_NORMAL_VARIANCE  )
        {
        // Get the address where the variance variable is in the struct.
        pLength = pMemory + *((signed short *)(pFormat + 2));
        goto ComputeVarianceGetCount;
        }

    // See if this is an async split

    if ( pFormat[1] & 0x20 )
        {
        fAsyncSplit = TRUE;
        RpcpMemoryCopy( & FormatCopy[0], pFormat, 4 );
        pFormat = (PFORMAT_STRING) & FormatCopy[0];

        // Remove the async marker
        FormatCopy[1] = pFormat[1] & 0xdf;
        }

    //
    // Get a pointer to the variance variable.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_VARIANCE ) 
        {
        //
        // Top level variance.  For /Os stubs, the stubs put the actual
        // count and offset in the stub message.  For /Oi stubs, we get the 
        // actual count via an offset from the stack top.  The first_is must
        // be zero if we get here.
        //
        if ( pStubMsg->StackTop ) 
            {
            if ( fAsyncSplit )
                {
                PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg;

                pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE) pStubMsg->pAsyncMsg;

                pLength = pAsyncMsg->BeginStack + *((signed short *)(pFormat + 2));
                }
            else
                pLength = pStubMsg->StackTop + *((signed short *)(pFormat + 2));
            goto ComputeVarianceGetCount;
            }
        else
            {
            //
            // If this is top level variance with /Os then we don't have 
            // to do anything, the proper variance values are placed in the 
            // stub message inline in the stubs.
            //
            return;
            }
        }

    //
    // If we're computing the length of an embedded size/length pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    if ( (*pFormat & 0xf0) == FC_POINTER_VARIANCE )
        {
        pMemory = pStubMsg->Memory;
        pLength = pMemory + *((signed short *)(pFormat + 2));
        goto ComputeVarianceGetCount;
        }

    //
    // Check for constant length.
    //
    if ( (*pFormat & 0xf0) == FC_CONSTANT_VARIANCE )
        {
        //
        // The length is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        Length =  (LONG_PTR) ((ulong)pFormat[1] << 16);
        Length |= (LONG_PTR) *((ushort *)(pFormat + 2));

        goto ComputeVarianceEnd;
        }

    //
    // Check for variance of a multidimensional array element in 
    // a -Os stub.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE )
        {
        long Dimension;

        if ( fAsyncSplit )
            RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

        //
        // If pArrayInfo is non-null than we have a multi-D array.  If it
        // is null then we have multi-leveled sized pointers.
        //
        if ( pStubMsg->pArrayInfo )
            {
            Dimension = pStubMsg->pArrayInfo->Dimension;

            pStubMsg->Offset = 
                    pStubMsg->pArrayInfo->OffsetArray[Dimension];
            pStubMsg->ActualCount = 
                    pStubMsg->pArrayInfo->ActualCountArray[Dimension];
            }
        else
            {
            Dimension = *((ushort *)(pFormat + 2));

            pStubMsg->Offset = pStubMsg->SizePtrOffsetArray[Dimension];
            pStubMsg->ActualCount = pStubMsg->SizePtrLengthArray[Dimension];
            }

        return;
        }

ComputeVarianceGetCount:

    //
    // Must check now if there is a dereference op.
    //
    if ( pFormat[1] == FC_DEREFERENCE )
        {
        pLength = *(void **)pLength;
        }

    //
    // Now get the conformance count.
    //
    switch ( *pFormat & 0x0f ) 
        {
        case FC_ULONG :
            Length = (LONG_PTR)*((ulong *)pLength);
            break;

        case FC_LONG :
            Length = *((long *)pLength);
            break;

        case FC_USHORT :
            Length = (long) *((ushort *)pLength);
            break;

        case FC_SHORT :
            Length = (long) *((short *)pLength);
            break;

        case FC_USMALL :
            Length = (long) *((uchar *)pLength);
            break;

        case FC_SMALL :
            Length = (long) *((char *)pLength);
            break;

        default :
            NDR_ASSERT(0,"NdrpComputeVariance : bad format");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        } 

    //
    // Check the operator.
    //
    switch ( pFormat[1] ) 
        {
        case FC_DIV_2 :
            Length /= 2;
            break;
        case FC_MULT_2 :
            Length *= 2;
            break;
        case FC_SUB_1 :
            Length -= 1;
            break;
        case FC_ADD_1 :
            Length += 1;
            break;
        default :
            // OK
            break;
        }

ComputeVarianceEnd:

    // Get here if the length was computed directly.
    pStubMsg->Offset = 0;
    pStubMsg->ActualCount = (ulong) Length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\mrshl.cxx ===
/************************************************************************

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    mrshl.c

Abstract :

    This file contains the marshalling routines called by MIDL generated
    stubs and the interpreter.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ***********************************************************************/

#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

unsigned char  *RPC_ENTRY
NdrUDTSimpleTypeMarshall1(
    PMIDL_STUB_MESSAGE    pStubMsg,
    unsigned char *       pMemory,
    PFORMAT_STRING        pFormat
    );

//
// Function table of marshalling routines.
//
extern const PMARSHALL_ROUTINE MarshallRoutinesTable[] =
                    {
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    
                    NdrPointerMarshall,
                    NdrPointerMarshall,
                    NdrPointerMarshall,
                    NdrPointerMarshall,

                    NdrSimpleStructMarshall,
                    NdrSimpleStructMarshall,
                    NdrConformantStructMarshall,
                    NdrConformantStructMarshall,
                    NdrConformantVaryingStructMarshall,

                    NdrComplexStructMarshall,

                    NdrConformantArrayMarshall,
                    NdrConformantVaryingArrayMarshall,
                    NdrFixedArrayMarshall,
                    NdrFixedArrayMarshall,
                    NdrVaryingArrayMarshall,
                    NdrVaryingArrayMarshall,

                    NdrComplexArrayMarshall,

                    NdrConformantStringMarshall,
                    NdrConformantStringMarshall,
                    NdrConformantStringMarshall,
                    NdrConformantStringMarshall,

                    NdrNonConformantStringMarshall,
                    NdrNonConformantStringMarshall,
                    NdrNonConformantStringMarshall,
                    NdrNonConformantStringMarshall,

                    NdrEncapsulatedUnionMarshall,
                    NdrNonEncapsulatedUnionMarshall,

                    NdrByteCountPointerMarshall,

                    NdrXmitOrRepAsMarshall,    // transmit as
                    NdrXmitOrRepAsMarshall,    // represent as

                    NdrPointerMarshall,

                    NdrMarshallHandle,

                    // New Post NT 3.5 token serviced from here on.

                    0,                       // NdrHardStructMarshall,

                    NdrXmitOrRepAsMarshall,  // transmit as ptr
                    NdrXmitOrRepAsMarshall,  // represent as ptr

                    NdrUserMarshalMarshall,

                    0,   // FC_PIPE 
                    0,   // FC_BLK_HOLE

                    NdrpRangeMarshall,
                    
                    0,   // FC_INT3264
                    0,   // FC_UINT3264

                    0, // NdrCsArrayMarshall,
                    0, // NdrCsTagMarshall
                    };

extern const PMARSHALL_ROUTINE * pfnMarshallRoutines = MarshallRoutinesTable;

unsigned char *
NdrpInterfacePointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat );

RPCRTAPI
unsigned char *RPC_ENTRY
NdrTypeMarshall( 
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PFORMAT_STRING     pFormat )
{
    return
    (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
}


__inline unsigned char  *RPC_ENTRY
NdrUDTSimpleTypeMarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      FormatString )
{
    NdrSimpleTypeMarshall(pStubMsg,pMemory,*FormatString);
    return 0;
}
    


void RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    uchar               FormatChar )
/*++

Routine Description :

    Marshalls a simple type.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data to be marshalled.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
    switch ( FormatChar )
        {
        case FC_CHAR :
        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            *(pStubMsg->Buffer)++ = *pMemory;
            break;

        case FC_ENUM16 :
            if ( *((int *)pMemory) & ~((int)0x7fff) )
                {
                RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
                }
            // fall through...

        case FC_WCHAR :
        case FC_SHORT :
        case FC_USHORT :
            ALIGN(pStubMsg->Buffer,1);

            *((ushort *&)pStubMsg->Buffer)++ = *((ushort *)pMemory);
            break;

        case FC_LONG :
        case FC_ULONG :
#if defined(__RPC_WIN64__)
        case FC_INT3264:
        case FC_UINT3264:
#endif
        case FC_FLOAT :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);

            *((ulong *&)pStubMsg->Buffer)++ = *((ulong *)pMemory);
            break;

        case FC_HYPER :
        case FC_DOUBLE :
            ALIGN(pStubMsg->Buffer,7);

            //
            // Let's stay away from casts to double.
            //
            *((ulong *&)pStubMsg->Buffer)++ = *((ulong *)pMemory);
            *((ulong *&)pStubMsg->Buffer)++ = *((ulong *)(pMemory + 4));
            break;

        case FC_IGNORE:
            break;

        default :
            NDR_ASSERT(0,"NdrSimpleTypeMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}


unsigned char * RPC_ENTRY
NdrpRangeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++
--*/
{
    uchar  FcType = pFormat[1] & 0x0f;

    NdrSimpleTypeMarshall( pStubMsg, pMemory, FcType );

    return 0;
}


unsigned char * RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level pointer to anything.  Pointers embedded in
    structures, arrays, or unions call NdrpPointerMarshall directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data to be marshalled.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    uchar * pBufferMark;

    //
    // If this is not a ref pointer then set buffer mark and increment the
    // stub message buffer pointer.
    //
    if ( *pFormat != FC_RP )
        {
        ALIGN( pStubMsg->Buffer, 3 );

        // This is where we marshall the node id.
        pBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer += PTR_WIRE_SIZE;
        }
    else
        pBufferMark = 0;

    //
    // For ref pointers pBufferMark will not be used and can be left
    // unitialized.
    //

    NdrpPointerMarshall( pStubMsg,
                         pBufferMark,
                         pMemory,
                         pFormat );

    return 0;
}


__forceinline void
NdrpPointerMarshallInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for marshalling a pointer and its pointee.  This is the
    entry point for pointers embedded in structures, arrays, and unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pBufferMark - The location in the buffer where the pointer itself is
                  marshalled.  Important for full pointers, unfortunately it's
                  overkill for unique pointers.
    pMemory     - Pointer to the data to be marshalled.
    pFormat     - Pointer format string description.

    pStubMsg->Buffer - the place for the pointee.

Return :

    None.

--*/
{
    //
    // Check the pointer type.
    //
    switch ( *pFormat )
        {
        case FC_RP :
            if ( ! pMemory )
                RpcRaiseException( RPC_X_NULL_REF_POINTER );

            break;

        case FC_UP :
        case FC_OP :
            // Put the pointer in the buffer.
            *((ulong*&)pBufferMark)++ = PTR_WIRE_REP(pMemory);

            if ( ! pMemory )
                return;

            break;

        case FC_IP :

            if ( IS_BROKEN_INTERFACE_POINTER(pStubMsg->uFlags) )
                {
                // The pointee is effectivly both the pointer
                // and the pointee.

                NdrInterfacePointerMarshall( pStubMsg,
                                             pMemory,
                                             pFormat );
                return;
                }

            // Interface pointers behave like unique pointers
            *((ulong*&)pBufferMark)++ = PTR_WIRE_REP(pMemory);
            if ( ! pMemory )
                return;

            NdrpInterfacePointerMarshall( pStubMsg,
                                          pMemory,
                                          pFormat );
            return;

        case FC_FP :
            //
            // Marshall the pointer's ref id and see if we've already
            // marshalled the pointer's data.
            //
            if ( NdrFullPointerQueryPointer( pStubMsg->FullPtrXlatTables,
                                             pMemory,
                                             FULL_POINTER_MARSHALLED,
                                             (ulong *) pBufferMark ) )
                return;

            break;

        default :
            NDR_ASSERT(0,"NdrpPointerMarshall : bad pointer type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Check for a pointer to a complex type.
    //
    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        uchar   uFlagsSave;

        if ( POINTER_DEREF(pFormat[1]) )
            pMemory = *((uchar **)pMemory);

        // Increment to offset_to_complex_description<2> field.
        pFormat += 2;

        //
        // Set format string to complex type description.
        // Cast must be to a signed short since some offsets are negative.
        //
        pFormat += *((signed short *)pFormat);

        //
        // Look up the proper marshalling routine in the marshalling function
        // table.
        //
        uFlagsSave = pStubMsg->uFlags;
        RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

        (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                         pMemory,
                                                         pFormat );
        pStubMsg->uFlags = uFlagsSave;
        return;
        }

    //
    // Else it's a pointer to a simple type or a string pointer.
    //

    switch ( pFormat[2] )
        {
        case FC_C_CSTRING :
        case FC_C_BSTRING :
        case FC_C_WSTRING :
        case FC_C_SSTRING :
            NdrConformantStringMarshall( pStubMsg,
                                         pMemory,
                                         pFormat + 2 );
            break;

        default :
            NdrSimpleTypeMarshall( pStubMsg,
                                   pMemory,
                                   pFormat[2] );
            break;
        }
}


NDR_MRSHL_POINTER_QUEUE_ELEMENT::NDR_MRSHL_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pBufferMarkNew,
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :

        pBufferMark(pBufferMarkNew),
        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags) 
{

}

void 
NDR_MRSHL_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0\n");

    NdrpPointerMarshallInternal( pStubMsg,
                                 pBufferMark,
                                 pMemory,
                                 pFormat );
}

#if defined(DBG)
void 
NDR_MRSHL_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pBufferMark:             %p\n", pBufferMark );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );
}
#endif

void 
NdrpEnquePointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );    
    
    RpcTryFinally
    {
        NDR_MRSHL_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_MRSHL_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                pBufferMark,
                                                pMemory,
                                                pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
    }
    RpcFinally
    {
        PointerContext.EndContext();    
    }
    RpcEndFinally
}

void
NdrpPointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    
    if ( !NdrIsLowStack(pStubMsg) )
        {
        NdrpPointerMarshallInternal(  pStubMsg,
                                      pBufferMark,
                                      pMemory,
                                      pFormat );
        return;
        }

    NdrpEnquePointerMarshall( pStubMsg,
                              pBufferMark,
                              pMemory,
                              pFormat );

}



unsigned char * RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    uint   StructSize;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    StructSize = (uint) *((ushort *)(pFormat + 2));

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    StructSize );

    // Mark the start of the structure in the buffer.
    pStubMsg->BufferMark = pStubMsg->Buffer;

    pStubMsg->Buffer += StructSize;

    // Marshall embedded pointers.
    if ( *pFormat == FC_PSTRUCT )
        {
        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat + 4 );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a conformant structure.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.        - may set the CONF_ARRAY_DONE flag.

Note

    Due to problems with MIDL generated code, the ConformantStruct routine always
    marshals the conformant array. Only a bogus struct can embed a conf struct, 
    and there is a flag that bogus struct watches in order not to marshal the array
    second time.

--*/
{
    PFORMAT_STRING  pFormatArray;
    uint            StructSize;
    uchar           Alignment;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    // Save structure's alignment.
    Alignment = pFormat[1];

    // Increment format string to struct size field.
    pFormat += 2;

    // Get flat struct size and increment format string.
    StructSize = (uint) *((ushort *&)pFormat)++;

    // Set conformant array format string description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    //
    // Compute conformance information.  Pass a memory pointer to the
    // end of the non-conformant part of the structure.
    //
    NdrpComputeConformance( pStubMsg,
                            pMemory + StructSize,
                            pFormatArray );

    // Only a bogus struct can embed a conf struct.

    if ( fIsEmbeddedStruct )
        *(ulong *)pStubMsg->BufferMark = (ulong)pStubMsg->MaxCount;
    else
        {
        // Align the buffer for conformance count marshalling.
        ALIGN(pStubMsg->Buffer,3);

        // Marshall conformance count.
        *((ulong *&)pStubMsg->Buffer)++ = (ulong)pStubMsg->MaxCount;
        }


    // Re-align buffer 
    ALIGN(pStubMsg->Buffer,Alignment);

    // Increment array format string to array element size field.
    pFormatArray += 2;

    // Add the size of the conformant array to the structure size.
    StructSize += (ulong)pStubMsg->MaxCount * *((ushort *)pFormatArray);

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    StructSize );

    // Update the buffer pointer.
    pStubMsg->Buffer += StructSize;

    // Increment format string past offset to array description field.
    pFormat += 2;

    // Marshall embedded pointers. This covers the struct and the conf array.
    if ( *pFormat == FC_PP )
        {
        // Mark the start of the structure in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - StructSize;

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }

    // Only a complex struct may set up this flag for embedding.
    // Set the reverse flag to signal that array has been marshaled.

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a structure which contains a conformant varying array.

    Used for FC_CVSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatArray;
    uint            StructSize;
    uchar           Alignment;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    uchar*          pBuffer;

    if ( !fIsEmbeddedStruct )
        {
        // Align the buffer for marshalling conformance info.
        ALIGN(pStubMsg->Buffer,3);

        // Mark the location in the buffer where the conformance will be marshalled.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment buffer pointer past where conformance will be marshalled.
        pStubMsg->Buffer += 4;
        }
    // else BufferMark is set by the ComplexStruct code.

    // Save the structure's alignment.
    Alignment = pFormat[1];

    // Increment format string to struct size field.
    pFormat += 2;

    // Get non-conformance struct size and increment format string.
    StructSize = (uint) *((ushort *&)pFormat)++;

    // Get conformant array's description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    // Align buffer for struct
    ALIGN(pStubMsg->Buffer, Alignment);
    pBuffer = pStubMsg->Buffer;

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    StructSize );
    // Set stub message buffer pointer past non-conformant part of struct.
    pStubMsg->Buffer += StructSize;

    //
    // Call the correct private array or string marshalling routine.
    // We must pass a memory pointer to the beginning of the array/string.
    //
    if ( *pFormatArray == FC_CVARRAY )
        {
        NdrpConformantVaryingArrayMarshall( pStubMsg,
                                            pMemory + StructSize,
                                            pFormatArray );
        }
    else
        {
        NdrpConformantStringMarshall( pStubMsg,
                                      pMemory + StructSize,
                                      pFormatArray );
        }

    // Increment format string past the offset_to_array_description<2> field.
    pFormat += 2;

    //
    // Marshall embedded pointers.
    //
    if ( *pFormat == FC_PP )
        {
        // Mark the start of the structure in the buffer.
        pStubMsg->BufferMark = pBuffer;

        pStubMsg->MaxCount = pStubMsg->ActualCount;       

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }

    // Only a complex struct may set up this flag for embedding.
    // Set the reverse flag to signal that array has been marshaled.

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}


#if 0
unsigned char * RPC_ENTRY
NdrHardStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a hard structure.

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being marshalled.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pFormat += 8;

    //
    // Do any needed enum16 exception check.
    //
    if ( *((short *)pFormat) != (short) -1 )
        {
        if ( *((int *)(pMemory + *((ushort *)pFormat))) & ~((int)0x7fff) )
            {
            RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
            }
        }

    pFormat += 2;

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    *((ushort *)pFormat) );

    pStubMsg->Buffer += *((ushort *)pFormat)++;

    //
    // See if we have a union.
    //
    if ( *((short *)&pFormat[2]) )
        {
        pMemory += *((ushort *)pFormat)++;

        pFormat += *((short *)pFormat);

        (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                         pMemory,
                                                         pFormat );
        }

    return 0;
}
#endif // 0


unsigned char * RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being marshalled.
    pFormat     - Structure's format string description.
    
Return :

    None.
    
Notes :

    pStubMsg->BufferMark is set to a place where conformance would be marhaled.
    pStubMsg->pPointerBufferMark is a pointee buffer mark a usual.

--*/
{
    uchar *         pBufferSave;
    uchar *         pBufferMark;
    uchar *         pMemorySave;
    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatSave;
    PFORMAT_STRING  pFormatComplex;
    long            Alignment;
    long            Align8Mod;
    uchar           fSetPointerBufferMark;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    BOOL            fEmbedConfStructContext;
    
    // Get struct's wire alignment.
    Alignment = pFormat[1];

    //
    // This is used for support of structs with doubles passed on an
    // i386 stack.
    //
    // A cast to long is what we need.
    Align8Mod = 0x7 & PtrToLong( pMemory );

    pFormatSave = pFormat;
    pBufferSave = pStubMsg->Buffer;
    pMemorySave = pStubMsg->Memory;

    pStubMsg->Memory = pMemory;

    // Increment to conformant array offset field.
    pFormat += 4;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        {
        pFormatArray = pFormat + *((signed short *)pFormat);

        if ( !fIsEmbeddedStruct )
            {
            // Align for conformance marshalling.
            ALIGN(pStubMsg->Buffer,3);

            // Remember where the conformance count(s) will be marshalled.
            pStubMsg->BufferMark = pStubMsg->Buffer;

            // Increment the buffer pointer 4 bytes for every array dimension.
            pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormatArray, FALSE ) * 4;
            }
        }
    else
        pFormatArray = 0;

    // Mark the place to marshal conformant size(s), this may come from upper levels.
    pBufferMark = pStubMsg->BufferMark;

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    // Align buffer on struct's alignment.
    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // If the the stub message PointerBufferMark field is 0, then determine
    // the position in the buffer where pointees will be marshalled.
    //
    // We have to do this to handle embedded pointers.
    //
    if ( fSetPointerBufferMark = ! pStubMsg->PointerBufferMark )
        {
        BOOL    fOldIgnore;
        ulong   BufferLenOffset;

        fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        //
        // Set BufferLength equal to the current buffer pointer, and then
        // when we return from NdrComplexStructBufferSize it will pointer to
        // the location in the buffer where the pointees should be marshalled.
        //     pStubMsg->BufferLength = pBufferSave;
        // Instead of pointer, we now calculate pointer increment explicitly.

        // Set the pointer alignment as a base.
        // We use pBufferSave as the sizing routine accounts for the conf sizes.
        //
        BufferLenOffset = 0xf & PtrToUlong( pBufferSave );
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->BufferLength = BufferLenOffset;

        NdrComplexStructBufferSize( pStubMsg,
                                    pMemory,
                                    pFormatSave );

        // Pointer increment including alignments.
        BufferLenOffset = pStubMsg->BufferLength - BufferLenOffset;

        // Set the location in the buffer where pointees will be marshalled.
        pStubMsg->PointerBufferMark = pBufferSave + BufferLenOffset;
        pStubMsg->BufferLength = BufferLengthSave;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        }

    fEmbedConfStructContext = fIsEmbeddedStruct ||
                              pFormatArray && FixWireRepForDComVerGTE54( pStubMsg );

    RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    //
    // Marshall the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // Simple types.
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
                NdrSimpleTypeMarshall( pStubMsg,
                                       pMemory,
                                       *pFormat );

                pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_IGNORE :
                ALIGN(pStubMsg->Buffer,3);
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                pMemory += PTR_MEM_SIZE;
                break;

            case FC_POINTER :
                {
                
                ALIGN( pStubMsg->Buffer, 0x3 );
                uchar *pPointerId = pStubMsg->Buffer;
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                NDR_ASSERT(pFormatPointers, "NdrComplexStructMarshall: pointer field but no pointer layout");

                {
                    POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
                    NdrpPointerMarshall( pStubMsg,
                                         pPointerId,
                                         *((uchar **)pMemory),
                                         pFormatPointers );

                }

                //
                // Increment memory pointers past the pointer.
                //

                pMemory += PTR_MEM_SIZE;

                pFormatPointers += 4;

                break;
                }

            //
            // Embedded complex types.
            //
            case FC_EMBEDDED_COMPLEX :
                // Increment memory pointer by padding.
                pMemory += pFormat[1];

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( FC_IP == *pFormatComplex ) 
                    {

                    // Treat the same as an embedded pointer
                    ALIGN( pStubMsg->Buffer, 0x3 );
                    uchar *pPointerId = pStubMsg->Buffer;
                    pStubMsg->Buffer += PTR_WIRE_SIZE;

                    {
                        POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
                        NdrpPointerMarshall( pStubMsg,
                                             pPointerId,
                                             *((uchar **)pMemory),
                                             pFormatComplex );

                    }
                    pMemory += PTR_MEM_SIZE;
                    pFormat++;
                    break;

                    }

                // Context needed for the embedded conf struct.
                //
                pStubMsg->BufferMark = pBufferMark;
                if ( fEmbedConfStructContext )
                    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                // Marshall complex type.
                (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  pMemory,
                  pFormatComplex );

                //
                // Increment the memory pointer.
                //
                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormatComplex );

                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                //
                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                //
                pFormat++;

                break;

            case FC_ALIGNM2 :
                ALIGN( pMemory, 0x1 );
                break;

            case FC_ALIGNM4 :
                ALIGN( pMemory, 0x3 );
                break;

            case FC_ALIGNM8 :
                //
                // We have to play some tricks for the i386 to handle the case
                // when an 8 byte aligned structure is passed by value.  The
                // alignment of the struct on the stack is not guaranteed to be
                // on an 8 byte boundary.
                //
                pMemory -= Align8Mod;
                ALIGN( pMemory, 0x7 );
                pMemory += Align8Mod;

                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                //
                // Increment memory pointer by amount of padding.
                //
                pMemory += (*pFormat - FC_STRUCTPAD1) + 1;
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pMemory += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;
                
            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                goto ComplexMarshallEnd;

            default :
                NDR_ASSERT(0,"NdrComplexStructMarshall : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            } // switch
        } // for

ComplexMarshallEnd:

    //
    // Marshall conformant array if we have one.
    // .. but not when embedded and not when it had been marshaled by conf struct.
    //
    if ( pFormatArray &&  !fIsEmbeddedStruct  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        // Normal case: top level marshaling.

        PPRIVATE_MARSHALL_ROUTINE   pfnPMarshall;


        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnPMarshall = NdrpConformantArrayMarshall;
                break;

            case FC_CVARRAY :
                pfnPMarshall = NdrpConformantVaryingArrayMarshall;
                break;

            case FC_BOGUS_ARRAY :
                pfnPMarshall = NdrpComplexArrayMarshall;
                break;

            case FC_C_WSTRING :
                ALIGN(pMemory,1);
                // fall through

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_SSTRING :

            default :
                pfnPMarshall = NdrpConformantStringMarshall;
                break;
            }

        //
        // Mark where the conformance count(s) will be marshalled.
        //
        pStubMsg->BufferMark = pBufferMark;

        // Marshall the array.
        (*pfnPMarshall)( pStubMsg,
                         pMemory,
                         pFormatArray );
        }

    //
    // Now fix up the stub message Buffer field if we set the PointerBufferMark
    // field.
    //
    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    pStubMsg->Memory = pMemorySave;

    if ( fIsEmbeddedStruct )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );
    return 0;
}


unsigned char * RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a non conformant string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, and FC_BSTRING (NT Beta2
    compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{
    uint        Count;
    uint        CopySize;

    // Align the buffer for offset and count marshalling.
    ALIGN(pStubMsg->Buffer,3);

    switch ( *pFormat )
        {
        case FC_CSTRING :
        case FC_BSTRING :
            CopySize = Count = MIDL_ascii_strlen((char *)pMemory) + 1;
            break;

        case FC_WSTRING :
            Count = wcslen((wchar_t *)pMemory) + 1;
            CopySize = Count * sizeof(wchar_t);
            break;

        case FC_SSTRING :
            Count = NdrpStringStructLen( pMemory, pFormat[1] ) + 1;
            CopySize = Count * pFormat[1];
            break;

        default :
            NDR_ASSERT(0,"NdrNonConformantStringMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Marshall variance.
    *((ulong *&)pStubMsg->Buffer)++ = 0;
    *((ulong *&)pStubMsg->Buffer)++ = Count;

    // Copy the string.
    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update buffer pointer.
    pStubMsg->Buffer += CopySize;

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{
    if ( pStubMsg->pArrayInfo != 0 )
        {
        //
        // If this is part of a multidimensional array then we get the location
        // where the conformance is marshalled from a special place.
        //
        pStubMsg->BufferMark = ( uchar * )
            &(pStubMsg->pArrayInfo->
                        BufferConformanceMark[pStubMsg->pArrayInfo->Dimension]);
        }
    else
        {
        // Align the buffer for max count marshalling.
        ALIGN(pStubMsg->Buffer,3);

        // Mark where the max count will be marshalled.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment the buffer past where the max count will be marshalled.
        pStubMsg->Buffer += 4;
        }

    // Call the private marshalling routine.
    NdrpConformantStringMarshall( pStubMsg,
                                  pMemory,
                                  pFormat );

    return 0;
}


void
NdrpConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Private routine for marshalling a conformant string.  This is the
    entry point for marshalling an embedded conformant strings.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{
    ulong       MaxCount;
    uint        ActualCount, CopySize;
    BOOL        IsSized;

    IsSized = (pFormat[1] == FC_STRING_SIZED);

    // Compute the element count of the string and the total copy size.
    switch ( *pFormat )
        {
        case FC_C_CSTRING :
        case FC_C_BSTRING :
            CopySize = ActualCount = MIDL_ascii_strlen((char *)pMemory) + 1;
            break;

        case FC_C_WSTRING :
            ActualCount = wcslen((wchar_t *)pMemory) + 1;
            CopySize = ActualCount * sizeof(wchar_t);
            break;

        case FC_C_SSTRING :
            ActualCount = NdrpStringStructLen( pMemory, pFormat[1] ) + 1;
            CopySize = ActualCount * pFormat[1];

            // Redo this check correctly.
            IsSized = (pFormat[2] == FC_STRING_SIZED);
            break;

        default :
            NDR_ASSERT(0,"NdrpConformantStringMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // If the string is sized then compute the max count, otherwise the
    // max count is equal to the actual count.
    //
    if ( IsSized )
        {
        MaxCount =  (ulong) NdrpComputeConformance( pStubMsg,
                                                    pMemory,
                                                    pFormat );
        }
    else
        {
        MaxCount = ActualCount;
        }

    // Marshall the max count.
    *((ulong *)pStubMsg->BufferMark) = MaxCount;

    // Align the buffer for variance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Marshall variance.
    *((ulong *&)pStubMsg->Buffer)++ = 0;
    *((ulong *&)pStubMsg->Buffer)++ = ActualCount;

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update the Buffer pointer.
    pStubMsg->Buffer += CopySize;
}


unsigned char * RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a fixed array of any number of dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array to be marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    uint   Size;

    // Align the buffer.
    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Get total array size.
    if ( *pFormat == FC_SMFARRAY )
        {
        pFormat += 2;
        Size = (ulong) *((ushort *&)pFormat)++;
        }
    else // *pFormat == FC_LGFARRAY
        {
        pFormat += 2;
        Size = *((ulong UNALIGNED *&)pFormat)++;
        }

    // Copy the array.
    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    Size );

    // Increment stub message buffer pointer.
    pStubMsg->Buffer += Size;

    // Marshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        // Mark the start of the array in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level one dimensional conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    // Align the buffer for conformance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Mark where the conformance will be marshalled.
    pStubMsg->BufferMark = pStubMsg->Buffer;

    // Increment past where the conformance will go.
    pStubMsg->Buffer += 4;

    // Call the private marshalling routine to do the work.
    NdrpConformantArrayMarshall( pStubMsg,
                                 pMemory,
                                 pFormat );

    return 0;
}


void
NdrpConformantArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for marshalling a one dimensional conformant array.
    This is the entry point for marshalling an embedded conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ulong       Count;
    uint        CopySize;

    // Compute conformance information.
    Count = (ulong) NdrpComputeConformance( pStubMsg,
                                            pMemory,
                                            pFormat );

    // Marshall the conformance.
    *((ulong *)pStubMsg->BufferMark) = Count;

    //
    // Return if size is 0.
    //
    if ( ! Count )
        return;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Compute the total array size in bytes.
    CopySize = Count * *((ushort *)(pFormat + 2));

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update buffer pointer.
    pStubMsg->Buffer += CopySize;

    // Increment to possible pointer layout.
    pFormat += 8;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Marshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        //
        // Mark the start of the array in the buffer.
        //
        pStubMsg->BufferMark = pStubMsg->Buffer - CopySize;

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }
}


unsigned char * RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level one dimensional conformant varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    // Align the buffer for conformance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Mark where the conformance will be marshalled.
    pStubMsg->BufferMark = pStubMsg->Buffer;

    // Increment past where the conformance will go.
    pStubMsg->Buffer += 4;

    // Call the private marshalling routine to do the work.
    NdrpConformantVaryingArrayMarshall( pStubMsg,
                                        pMemory,
                                        pFormat );

    return 0;
}


void
NdrpConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for marshalling a one dimensional conformant varying array.
    This is the entry point for marshalling an embedded conformant varying
    array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array to be marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    uint        CopyOffset, CopySize;
    ushort      ElemSize;

    // Compute and marshall the conformant size.
    *((ulong *)pStubMsg->BufferMark) = (ulong) NdrpComputeConformance( pStubMsg,
                                                                       pMemory,
                                                                       pFormat );

    // Compute variance offset and count.
    NdrpComputeVariance( pStubMsg,
                         pMemory,
                         pFormat );

    // Align the buffer for variance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Marshall variance.
    *((ulong *&)pStubMsg->Buffer)++ = pStubMsg->Offset;
    *((ulong *&)pStubMsg->Buffer)++ = pStubMsg->ActualCount;

    //
    // Return if length is 0.
    //
    if ( ! pStubMsg->ActualCount )
        return;

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    ElemSize = *((ushort *)(pFormat + 2));

    // Compute byte offset and size for the array copy.
    CopyOffset = pStubMsg->Offset * ElemSize;
    CopySize = pStubMsg->ActualCount * ElemSize;

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory + CopyOffset,
                    CopySize );

    pStubMsg->Buffer += CopySize;

    // Increment to a possible pointer layout.
    pFormat += 12;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    // Marshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        //
        // Set the MaxCount field equal to the ActualCount field.  The pointer
        // marshalling routine uses the MaxCount field to determine the number
        // of times an FC_VARIABLE_REPEAT pointer is marshalled.  In the face
        // of variance the correct number of time is the ActualCount, not the
        // the MaxCount.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        //
        // Mark the start of the array in the buffer.
        //
        pStubMsg->BufferMark = pStubMsg->Buffer - CopySize;

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }
}


unsigned char * RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level or embedded one dimensional varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    uint        CopyOffset, CopySize;
    ushort      ElemSize;

    // Compute the variance offset and count.
    NdrpComputeVariance( pStubMsg,
                         pMemory,
                         pFormat );

    // Align the buffer for variance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Marshall variance.
    *((ulong *&)pStubMsg->Buffer)++ = pStubMsg->Offset;
    *((ulong *&)pStubMsg->Buffer)++ = pStubMsg->ActualCount;

    //
    // Return if length is 0.
    //
    if ( ! pStubMsg->ActualCount )
        return 0;

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    // Increment the format string to the element_size field.
    if ( *pFormat == FC_SMVARRAY )
        pFormat += 6;
    else // *pFormat == FC_LGVARRAY
        pFormat += 10;

    // Get element size.
    ElemSize = *((ushort *)pFormat);

    //
    // Compute the byte offset from the beginning of the array for the copy
    // and the number of bytes to copy.
    //
    CopyOffset = pStubMsg->Offset * ElemSize;
    CopySize = pStubMsg->ActualCount * ElemSize;

    // Copy the array.
    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory + CopyOffset,
                    CopySize );

    // Update buffer pointer.
    pStubMsg->Buffer += CopySize;

    // Increment format string to possible pointer layout.
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Marshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        // Mark the start of the array in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - CopySize;

        //
        // Set the MaxCount field equal to the ActualCount field.  The pointer
        // marshalling routine uses the MaxCount field to determine the number
        // of times an FC_VARIABLE_REPEAT pointer is marshalled.  In the face
        // of variance the correct number of time is the ActualCount, not the
        // the MaxCount.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        //
        // Marshall the embedded pointers.
        // Make sure to pass a memory pointer to the first array element
        // which is actually being marshalled.
        //
        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory + CopyOffset,
                                     pFormat );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    BOOL            fSetPointerBufferMark;
    PFORMAT_STRING  pFormatPP;

    //
    // Setting this flag means that the array is not embedded inside of
    // another complex struct or array.
    //
    pFormatPP = pFormat + 12;
    CORRELATION_DESC_INCREMENT( pFormatPP );
    CORRELATION_DESC_INCREMENT( pFormatPP );

    fSetPointerBufferMark = (! pStubMsg->PointerBufferMark) &&
                            (*pFormatPP != FC_RP);

    if ( fSetPointerBufferMark )
        {
        BOOL    fOldIgnore;
        ULONG_PTR MaxCountSave;
        ulong   Offset, ActualCount;
        ulong   BufferLenOffset;

        //
        // Save the current conformance and variance fields.  The sizing
        // routine can overwrite them.
        //
        MaxCountSave = pStubMsg->MaxCount;
        Offset = pStubMsg->Offset;
        ActualCount = pStubMsg->ActualCount;

        fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        //
        // Set BufferLength equal to the current buffer pointer, and then
        // when we return from NdrComplexArrayBufferSize it will point to
        // the location in the buffer where the pointers should be marshalled
        // into.
        // Instead of pointer, we now calculate pointer increment explicitly.
        //
        // Set the pointer alignment as a base.

        BufferLenOffset = 0xf & PtrToUlong( pStubMsg->Buffer );
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->BufferLength = BufferLenOffset;

        NdrComplexArrayBufferSize( pStubMsg,
                                   pMemory,
                                   pFormat );

        // Pointer increment including alignments.
        BufferLenOffset = pStubMsg->BufferLength - BufferLenOffset;

        //
        // This is the buffer pointer to the position where embedded pointers
        // will be marshalled.
        //
        pStubMsg->PointerBufferMark = pStubMsg->Buffer + BufferLenOffset;
        pStubMsg->BufferLength = BufferLengthSave;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

        // Restore conformance and variance fields.
        pStubMsg->MaxCount = MaxCountSave;
        pStubMsg->Offset = Offset;
        pStubMsg->ActualCount = ActualCount;
        }

    if ( ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff ) &&
         ( pStubMsg->pArrayInfo == 0 ) )
        {
        //
        // Outer most dimension sets the conformance marker.
        //

        // Align the buffer for conformance marshalling.
        ALIGN(pStubMsg->Buffer,3);

        // Mark where the conformance count(s) will be marshalled.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment past where the conformance will go.
        pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormat, FALSE ) * 4;
        }

    // Call the private marshalling routine to do all the work.
    NdrpComplexArrayMarshall( pStubMsg,
                              pMemory,
                              pFormat );

    if ( fSetPointerBufferMark )
        {
        //
        // This will set the buffer pointer to end of all of the array's
        // unmarshalled data in the buffer.
        //
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    return 0;
}


void
NdrpComplexArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for marshalling a complex array.  This is the entry
    point for marshalling an embedded complex array.

    Used for FC_BOGUS_ARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

    pStubMsg->Buffer            - array pointer
    pStubMsg->BufferMark        - a place to marshal the conformant size
    pStubMsg->BufferPointerMark - a place to marshal the pointees
    
Return :

    None.

--*/
{
    ARRAY_INFO          ArrayInfo;
    PARRAY_INFO         pArrayInfo;
    PMARSHALL_ROUTINE   pfnMarshall;
    PFORMAT_STRING      pFormatStart;
    uint                Elements;
    uint                Offset, Count;
    uint                MemoryElementSize;
    long                Dimension;
    uchar               Alignment;
    bool                UseBrokenInterfacePointerRep = false;

    //
    // Lots of setup if we are the outer dimension.  All this is for
    // multidimensional array support.  If we didn't have to worry about
    // Beta2 stub compatability we could this much better.
    //
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        pStubMsg->pArrayInfo = &ArrayInfo;

        ArrayInfo.Dimension = 0;
        ArrayInfo.BufferConformanceMark = (unsigned long *) pStubMsg->BufferMark;
        ArrayInfo.BufferVarianceMark = 0;
        ArrayInfo.MaxCountArray =    (ulong *) pStubMsg->MaxCount;
        ArrayInfo.OffsetArray =      (ulong *) UlongToPtr( pStubMsg->Offset );
        ArrayInfo.ActualCountArray = (ulong *) UlongToPtr( pStubMsg->ActualCount );
        }

    pFormatStart = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    // Get the array's alignment.
    Alignment = pFormat[1];

    pFormat += 2;

    // Get number of elements (0 if the array has conformance).
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = (ulong) NdrpComputeConformance( pStubMsg,
                                                   pMemory,
                                                   pFormatStart );

        // Marshall this dimension's conformance count.
        pArrayInfo->BufferConformanceMark[Dimension] = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        if ( Dimension == 0 )
            {
            //
            // Set the variance marker.
            //

            ALIGN(pStubMsg->Buffer,0x3);

            // Mark where the variance count(s) will be marshalled.
            pArrayInfo->BufferVarianceMark = (unsigned long *) pStubMsg->Buffer;

            // Increment past where the variance will go.
            pStubMsg->Buffer +=
                    NdrpArrayDimensions( pStubMsg, pFormatStart, TRUE ) * 8;
            }

        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormatStart );

        Offset = pStubMsg->Offset;
        Count = pStubMsg->ActualCount;

        //
        // Marshall the outer dimension's variance.
        //
        pArrayInfo->BufferVarianceMark[Dimension * 2] = Offset;
        pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1] = Count;
        }
    else
        {
        Offset = 0;
        Count = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Return if count is 0.
    //
    if ( ! Count )
        goto ComplexArrayMarshallEnd;

    // Align on array's alignment.
    ALIGN(pStubMsg->Buffer,Alignment);

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ( FC_IP == *pFormat )
                goto HandleInterfacePointer;

            // Get the proper marshalling routine.
            pfnMarshall = pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)];

            pArrayInfo->Dimension = Dimension + 1;

            // Compute the size of an array element.
            MemoryElementSize = (uint) (NdrpMemoryIncrement( pStubMsg,
                                                             pMemory,
                                                             pFormat ) - pMemory);
            break;

        case FC_RP :
        case FC_UP :
        case FC_FP :
        case FC_OP :
            pfnMarshall = (PMARSHALL_ROUTINE) NdrpPointerMarshall;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_IP :
HandleInterfacePointer:
            UseBrokenInterfacePointerRep = !FixWireRepForDComVerGTE54( pStubMsg );

            // Probably does not exercise this code path, for IP the compiler
            // generates embedded complex as an array element.
            //
            pfnMarshall = (PMARSHALL_ROUTINE) NdrpPointerMarshall;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_ENUM16 :
            pfnMarshall = 0;

            // Need this in case we have a variant offset.
            MemoryElementSize = sizeof(int);
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
        case FC_UINT3264:
            pfnMarshall = 0;
            MemoryElementSize = sizeof(__int64);
            break;
#endif
        case FC_RANGE:
            // let's just memcpy in marshalling phase: don't need to check value here.
            Count *= SIMPLE_TYPE_BUFSIZE( pFormat[1] );
            pMemory += Offset * SIMPLE_TYPE_MEMSIZE( pFormat[1] );

            RpcpMemoryCopy( pStubMsg->Buffer,
                            pMemory,
                            Count );

            pStubMsg->Buffer += Count;
            break;
            
        default :
            NDR_ASSERT( IS_SIMPLE_TYPE(*pFormat),
                        "NdrpComplexArrayMarshall : bad format char" );

            Count *= SIMPLE_TYPE_BUFSIZE(*pFormat);

            pMemory += Offset * SIMPLE_TYPE_MEMSIZE(*pFormat);

            RpcpMemoryCopy( pStubMsg->Buffer,
                            pMemory,
                            Count );

            pStubMsg->Buffer += Count;

            goto ComplexArrayMarshallEnd;
        }

    //
    // If there is variance then increment the memory pointer to the first
    // element actually being marshalled.
    //
    if ( Offset )
        pMemory += Offset * MemoryElementSize;

    //
    // Array of enum16 or int3264.
    //
    if ( ! pfnMarshall )
        {
      #if defined(__RPC_WIN64__)
        if ( *pFormat != FC_ENUM16 )
            {
            for ( ; Count--; )
                *((long * &)pStubMsg->Buffer)++ = (long)*((INT64 * &)pMemory)++;
            }
        else
      #endif
            {
            for ( ; Count--; )
                {
                if ( *((int *)pMemory) & ~((int)0x7fff) )
                    RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);

                *((ushort *&)pStubMsg->Buffer)++ = (ushort) *((int *&)pMemory)++;
                }
            }

        goto ComplexArrayMarshallEnd;
        }

    //
    // For 32b, an array of ref or interface pointers.
    // For 64b, an array of any pointers.
    //
    if ( pfnMarshall == (PMARSHALL_ROUTINE) NdrpPointerMarshall )
        {
        pStubMsg->pArrayInfo = 0;

        uchar * pPointerId = (*pFormat == FC_RP) ? 0 : pStubMsg->Buffer;

        if ( UseBrokenInterfacePointerRep )
            {
            // If were using the broken array format, do no increment the
            // buffer pointer for the flat part, and throw everything
            // where the pointee should go.
            SET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

            POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
            for ( ; Count--; )
                {

                // This effectively calls NdrInterfacePointerMarshall.  Doinging
                // this so another queue structure/callback isn't needed just for
                // this rare code.
                NdrpPointerMarshall( 
                    pStubMsg,
                    pPointerId,
                    *((uchar **&)pMemory)++,
                    pFormat );
                pPointerId += PTR_WIRE_SIZE;
                }
            RESET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );
            }

        else
        {
            {
                POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
                for ( ; Count--; )
                    {

                    NdrpPointerMarshall( 
                        pStubMsg,
                        pPointerId,
                        *((uchar **&)pMemory)++,
                        pFormat );
                    //
                    // Needed only for non ref pointers, but pPointerIds is not used for refs.
                    //
                    pPointerId += PTR_WIRE_SIZE;
                    }
            }
            
            // Increment buffer pointer past the flat part of the array.
            if ( *pFormat != FC_RP )
                pStubMsg->Buffer = pPointerId;

        }


        goto ComplexArrayMarshallEnd;
        }

    //
    // It's an array of complex types.
    //

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        pStubMsg->pArrayInfo = 0;

    // Marshall the array elements.
    for ( ; Count--; )
        {
        // Keep track of multidimensional array dimension.
        if ( IS_ARRAY_OR_STRING(*pFormat) )
            pArrayInfo->Dimension = Dimension + 1;

        (*pfnMarshall)( pStubMsg,
                        pMemory,
                        pFormat );

        // Increment the memory pointer by the element size.
        pMemory += MemoryElementSize;
        }

ComplexArrayMarshallEnd:

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;
}


unsigned char * RPC_ENTRY
NdrEncapsulatedUnionMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls an encapsulated union.

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being marshalled.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;
    uchar   SwitchType;

    NO_CORRELATION;

    SwitchType = LOW_NIBBLE(pFormat[1]);

    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *)pMemory);
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *)pMemory);
            break;

        case FC_ENUM16 :
        case FC_SHORT :
            SwitchIs = (long) *((short *)pMemory);
            break;

        case FC_USHORT :
        case FC_WCHAR :
            SwitchIs = (long) *((ushort *)pMemory);
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG
            SwitchIs = *((long *)pMemory);
            break;
        default :
            NDR_ASSERT(0,"NdrEncapsulatedUnionMarshall : bad swith type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Increment the memory pointer to the union.
    pMemory += HIGH_NIBBLE(pFormat[1]);

    NdrpUnionMarshall( pStubMsg,
                       pMemory,
                       pFormat + 2,
                       SwitchIs,
                       SwitchType );

    return 0;
}


unsigned char * RPC_ENTRY
NdrNonEncapsulatedUnionMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a non encapsulated union.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being marshalled.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;
    uchar   SwitchType;

    SwitchType = pFormat[1];

    SwitchIs = (ulong) NdrpComputeSwitchIs( pStubMsg,
                                            pMemory,
                                            pFormat );

    //
    // Set the format string to the memory size and arm description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    NdrpUnionMarshall( pStubMsg,
                       pMemory,
                       pFormat,
                       SwitchIs,
                       SwitchType );

    return 0;
}


void
NdrpUnionMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                SwitchIs,
    uchar               SwitchType )
/*++

Routine Description :

    Private routine for marshalling a union.  This routine is shared for
    both encapsulated and non-encapsulated unions and handles the actual
    marshalling of the proper union arm.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being marshalled.
    pFormat     - The memory size and arm description portion of the format
                  string for the union.
    SwitchIs    - Union's switch is.
    SwitchType  - Union's switch is type.

Return :

    None.

--*/
{
    long    Arms;
    uchar   Alignment;

    // Marshall the switch is value.
    NdrSimpleTypeMarshall( pStubMsg,
                           (uchar *)&SwitchIs,
                           SwitchType );

    // Skip the memory size field.
    pFormat += 2;

    //
    // We're at the union_arms<2> field now, which contains both the
    // Microsoft union aligment value and the number of union arms.
    //

    //
    // Get the union alignment (0 if this is a DCE union).
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Number of arms is the lower 12 bits.
    //
    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff);

    //
    // Search for the correct arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm is empty.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        NdrSimpleTypeMarshall( pStubMsg,
                               pMemory,
                               pFormat[0] );

        return;
        }

    pFormat += *((signed short *)pFormat);

    //
    // If the union arm we take is a pointer, we have to dereference the
    // current memory pointer since we're passed a pointer to the union
    // (regardless of whether the actual parameter was a by-value union
    // or a pointer to a union).
    //
    // We also have to do a bunch of other special stuff to handle unions
    // embedded inside of strutures.
    //
    if ( IS_POINTER_TYPE(*pFormat) )
        {
        pMemory = *((uchar **)pMemory);
        
        //
        // If we're embedded in a struct or array we have do some extra stuff.
        //
        if ( pStubMsg->PointerBufferMark )
            {

            ALIGN(pStubMsg->Buffer,3);
            uchar *pPointerId = pStubMsg->Buffer;
            pStubMsg->Buffer += PTR_WIRE_SIZE;

            POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

            NdrpPointerMarshall( pStubMsg,
                                 pPointerId,
                                 pMemory,
                                 pFormat );
            return;
            }
        }

    //
    // Union arm of a non-simple type.
    //
    (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])
    ( pStubMsg,
      pMemory,
      pFormat );
}


unsigned char * RPC_ENTRY
NdrByteCountPointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a pointer with the byte count attribute applied to it.

    Used for FC_BYTE_COUNT_POINTER.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the byte count pointer being marshalled.
    pFormat     - Byte count pointer's format string description.

Return :

    None.

--*/
{
    //
    // We don't do anything special here.  Just pass things on to the
    // right marshalling routine.
    //
    if ( pFormat[1] != FC_PAD )
        {
        NdrSimpleTypeMarshall( pStubMsg,
                               pMemory,
                               pFormat[1] );
        }
    else
        {
        pFormat += 6;
        CORRELATION_DESC_INCREMENT( pFormat );
        pFormat += *((signed short *)pFormat);

        (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                         pMemory,
                                                         pFormat );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrXmitOrRepAsMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a transmit as or represent as argument:
        - translate the presented object into a transmitted object
        - marshall the transmitted object
        - free the transmitted object

    Format string layout:

         0  FC_TRANSMIT_AS or FC_REPRESENT_AS
            Oi array flag/alignment<1>
        +2  quintuple index<2>
        +4  pres type mem size<2>
        +6  tran type buf size<2>
        +8  offset<2>

Arguments :

    pStubMsg    - a pointer to the stub message
    pMemory     - presented type translated into transmitted type
                  and than to be marshalled
    pFormat     - format string description

--*/
{
    unsigned char *                pTransmittedType;
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;
    unsigned short                 QIndex;
    BOOL                           fXmitByPtr = *pFormat == FC_TRANSMIT_AS_PTR ||
                                                *pFormat == FC_REPRESENT_AS_PTR;

    // Skip the token itself and Oi flag. Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);

    // First translate the presented type into the transmitted type.
    // This includes an allocation of a transmitted type object.

    pStubMsg->pPresentedType = pMemory;
    pStubMsg->pTransmitType = NULL;
    pQuintuple[ QIndex ].pfnTranslateToXmit( pStubMsg );

    // Marshall the transmitted type.

    pFormat += 8;
    pFormat = pFormat + *(short *) pFormat;

    pTransmittedType = pStubMsg->pTransmitType;
    if ( IS_SIMPLE_TYPE( *pFormat ))
        {
        NdrSimpleTypeMarshall( pStubMsg,
                               pTransmittedType,
                               *pFormat );
        }
    else
        {
        uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        NDR_POINTER_QUEUE *pOldQueue = NULL;

        // Reset the current queue to NULL so that all the pointers
        // in the transmitted type will be queued and marshalled togother.
        if ( pStubMsg->pPointerQueueState )
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])
                ( pStubMsg,
                  fXmitByPtr  ?  *(uchar **)pTransmittedType
                              :  pTransmittedType,
                  pFormat );
            }
        RpcFinally
            {
            pStubMsg->PointerBufferMark = PointerBufferMarkSave;
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally
        }
    pStubMsg->pTransmitType = pTransmittedType;

    // Free the temporary transmitted object (it was allocated by the user).

    pQuintuple[ QIndex ].pfnFreeXmit( pStubMsg );

    return 0;
}


void
NdrpUserMarshalMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    unsigned long *     pWireMarkerPtr )
/*++

Routine Description :

    Marshals a usr_marshall object.

    The format string layout is as follows:

        FC_USER_MARSHAL
        flags & alignment<1>
        quadruple index<2>
        memory size<2>
        wire size<2>
        type offset<2>

    The wire layout description is at the type offset.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the usr_marshall object to marshall.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    const USER_MARSHAL_ROUTINE_QUADRUPLE *  pQuadruple;
    unsigned short                          QIndex;
    unsigned char *                         pUserBuffer;
    USER_MARSHAL_CB                         UserMarshalCB;
    unsigned char *                         pUserBufferSaved;

    pUserBufferSaved = pUserBuffer = pStubMsg->Buffer;

    // We always call user's routine to marshall.
    NdrpInitUserMarshalCB( pStubMsg,
                           pFormat,
                           USER_MARSHAL_CB_MARSHALL,  
                           & UserMarshalCB );

    QIndex     = *(unsigned short *)(pFormat + 2);
    pQuadruple = pStubMsg->StubDesc->aUserMarshalQuadruple;   

    if ((pUserBufferSaved < (uchar *) pStubMsg->RpcMsg->Buffer) ||
        ((unsigned long) (pUserBufferSaved - (uchar *) pStubMsg->RpcMsg->Buffer) 
                                           > pStubMsg->RpcMsg->BufferLength)) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        } 

    pUserBuffer = pQuadruple[ QIndex ].pfnMarshall( (ulong*) &UserMarshalCB,
                                                    pUserBuffer,
                                                    pMemory );

    if ((pUserBufferSaved > pUserBuffer) || 
        ((unsigned long) (pUserBuffer - (uchar *) pStubMsg->RpcMsg->Buffer)
                                      > pStubMsg->RpcMsg->BufferLength )) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    if ( pUserBuffer == pUserBufferSaved )
        {
        // This is valid only if the wire type was a unique type.

        if ( (pFormat[1] & USER_MARSHAL_UNIQUE) )
            {
            *pWireMarkerPtr = 0;
            return;
            }
        else
            RpcRaiseException( RPC_X_NULL_REF_POINTER );
        }

	pStubMsg->Buffer = pUserBuffer;
    return;
}

void 
NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    NdrpUserMarshalMarshall( pStubMsg,
                             pMemory,
                             pFormat,
                             pWireMarkerPtr );
}

#if defined(DBG)
void 
NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pWireMarkerPtr:          %p\n", pWireMarkerPtr );
}
#endif

unsigned char * RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    
    unsigned long *                         pWireMarkerPtr = 0;
    // Align for the object or a pointer to it.

    ALIGN( pStubMsg->Buffer, LOW_NIBBLE(pFormat[1]) );

    if ( pFormat[1] & USER_MARSHAL_POINTER )
        {

        if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  ||
             ((pFormat[1] & USER_MARSHAL_REF) && pStubMsg->PointerBufferMark) )
            {
            pWireMarkerPtr = (unsigned long *) pStubMsg->Buffer;
            *((unsigned long *&)pStubMsg->Buffer)++ = USER_MARSHAL_MARKER;
            }

        if ( !pStubMsg->pPointerQueueState ||
             !pStubMsg->pPointerQueueState->GetActiveQueue() )
            {
            // If we are embedded, switch to the pointee buffer.
            POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

            NdrpUserMarshalMarshall( pStubMsg,
                                     pMemory,
                                     pFormat,
                                     pWireMarkerPtr );
            }
        else
            {
            NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT*pElement = 
               new(pStubMsg->pPointerQueueState) 
                   NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT(pMemory,
                                                             pFormat,
                                                             pWireMarkerPtr);
            pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
            }

        return 0;
        }

    NdrpUserMarshalMarshall( pStubMsg,
                             pMemory,
                             pFormat,
                             pWireMarkerPtr );
    return 0;
}



unsigned char *
NdrpInterfacePointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the interface pointer being marshalled.
    pFormat     - Interface pointer's format string description.

Return :

    None.

Notes : There is now one representation of a marshalled interface pointer.
        The format string contains FC_IP followed by either
        FC_CONSTANT_IID or FC_PAD.

            typedef struct
            {
                unsigned long size;
                [size_is(size)] byte data[];
            }MarshalledInterface;

--*/
{
    HRESULT         hr;
    IID             iid;
    IID *           piid;
    unsigned long * pSize;
    unsigned long * pMaxCount;
    unsigned long   cbData = 0;
    unsigned long   cbMax;
    unsigned long   position;
    IStream *       pStream;
    LARGE_INTEGER   libMove;
    ULARGE_INTEGER  libPosition;

    ALIGN(pStubMsg->Buffer,0x3);
    //
    // Get an IID pointer.
    //
    if ( pFormat[1] != FC_CONSTANT_IID )
        {
        //
        // This is like computing a variance with a long.
        //

        piid = (IID *) NdrpComputeIIDPointer( pStubMsg,
                                              pMemory,
                                              pFormat );
        if(piid == 0)
            RpcRaiseException( RPC_S_INVALID_ARG );
        }
    else
        {
        // 
        // The IID may not be aligned properly in the format string,
        // so we copy it to a local variable.
        //

        piid = &iid;
        RpcpMemoryCopy( &iid, &pFormat[2], sizeof(iid) );
        }

    // Leave space in the buffer for the conformant size and the size field.

    pMaxCount = (unsigned long *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(unsigned long);

    pSize = (unsigned long *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(unsigned long);

    if(pMemory)
        {

        //Calculate the maximum size of the stream.

        position = (ulong)( pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer);
        cbMax = pStubMsg->RpcMsg->BufferLength - position;

#if defined(DEBUG_WALKIP)
    {
    CHAR AppName[MAX_PATH];
    memset(AppName, 0, sizeof(AppName ) );
    GetModuleFileNameA( NULL, AppName, sizeof(AppName ) );
    DbgPrint("MRSHL32 %s %p\n", AppName, pStubMsg->Buffer );
    }
#endif

        //Create a stream on memory.

        pStream = NdrpCreateStreamOnMemory(pStubMsg->Buffer, cbMax);
        if(pStream == 0)
            RpcRaiseException(RPC_S_OUT_OF_MEMORY);

        hr = (*pfnCoMarshalInterface)(pStream, *piid, (IUnknown *)pMemory, pStubMsg->dwDestContext, pStubMsg->pvDestContext, 0);
        if(FAILED(hr))
            {
            pStream->Release();
            pStream = 0;
            RpcRaiseException(hr);
            }

        //Calculate the size of the data written

        libMove.LowPart = 0;
        libMove.HighPart = 0;
        pStream->Seek(libMove, STREAM_SEEK_CUR, &libPosition);
        pStream->Release();
        pStream = 0;
        cbData = libPosition.LowPart;
        }

    //Update the array bounds.

    *pMaxCount = cbData;
    *pSize = cbData;

    //Advance the stub message buffer pointer.
    pStubMsg->Buffer += cbData;

    return 0;
}

unsigned char * RPC_ENTRY
NdrInterfacePointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{

    // Always put the pointer itself on wire, it behaves like a unique.
    //

    // This function is only called for toplevel interface pointers with Os mode,
    // or when being backward compatible with the incorrect wire format.
    // Oicf uses NdrPointerMarshall.

    ALIGN(pStubMsg->Buffer,0x3);
    *((ulong *&)pStubMsg->Buffer)++ = PTR_WIRE_REP(pMemory);

    // If the pointer is null, it's done.

    if ( pMemory == 0 )
        return 0;


    return
    NdrpInterfacePointerMarshall( 
        pStubMsg,
        pMemory,
        pFormat );
}


//
// Context handle marshalling routines.
//

void RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_CCONTEXT        ContextHandle,
    int                 fCheck )
/*++

Routine Description :

    Marshalls a context handle on the client side.

Arguments :

    pStubMsg        - Pointer to stub message.
    ContextHandle   - Context handle to marshall.
    fCheck          - TRUE if an exception check should be made on the handle,
                      FALSE otherwise.

Return :

    None.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called NdrMarshallHandle
    // and can be found in hndl.c

    if ( fCheck && ! ContextHandle )
        RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

    ALIGN(pStubMsg->Buffer,3);

    // This call will check for bogus handles now and will raise
    // an exception when necessary.

    NDRCContextMarshall( ContextHandle, pStubMsg->Buffer );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

void RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        ContextHandle,
    NDR_RUNDOWN         RundownRoutine )
/*++

Routine Description :

    Marshalls a context handle on the server side.

Arguments :

    pStubMsg        - Pointer to stub message.
    ContextHandle   - Context handle to marshall.
    RundownRoutine  - The context rundown routine.

Return :

    None.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called NdrMarshallHandle
    // and can be found in hndl.c

    ALIGN(pStubMsg->Buffer,3);

    NDRSContextMarshall2(pStubMsg->RpcMsg->Handle,
                         ContextHandle,
                         pStubMsg->Buffer,
                         RundownRoutine,
                         RPC_CONTEXT_HANDLE_DEFAULT_GUARD,
                         RPC_CONTEXT_HANDLE_DEFAULT_FLAGS );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

void RPC_ENTRY
NdrServerContextNewMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        ContextHandle,
    NDR_RUNDOWN         RundownRoutine,
    PFORMAT_STRING      pFormat )
/*
    This is a non-optimized NDR engine entry for context handle marshaling.
    In particular it is able to handle all the new NT5 context handle flavors.
    The optimized routine follows below.
    
      ContextHandle - note, this is not the user's handle but a
                      NDR_SCONTEXT pointer from the stub local stack. 
                      User's handle is a field in that object.
                
    Note that intepreter calls NdrMarshallHandle. However, we can't use it 
    as it assumes a helper array of saved context handles that we don't need.
   
*/
{   
    void *  pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD   Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pFormat[1] & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pFormat[1] & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pFormat[1] & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    ALIGN( pStubMsg->Buffer, 0x3 );

    NDRSContextMarshall2( 
        pStubMsg->RpcMsg->Handle,
        ContextHandle,
        pStubMsg->Buffer,
        RundownRoutine,
        pGuard,
        Flags );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}


void
NdrpGetArraySizeLength (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                ElementSize,
    long *              pSize,
    long *              pLength,
    long *              pWireSize )
/*++

Routine Description :

    Return the size and length of an array.

    We need to have this routine rather than just calling BufferSize since
    we need the actual length of the array, not the length plus whatever 
    goop the NDR format puts in from of it.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the local array.
    pFormat     - Pointer to the array to get the size of.

Return :

    The size and length.

Notes:

--*/
{
    switch ( *pFormat )
        {
        case FC_SMFARRAY:
            *pWireSize = * (short *) ( pFormat + 2 );
            *pSize     = *pWireSize;
            *pLength   = *pSize;    
            return;

        case FC_LGFARRAY:
            *pWireSize = * (int *) ( pFormat + 2 );
            *pSize     = *pWireSize;
            *pLength   = *pSize;
            return;

        case FC_CARRAY:
            *pSize     = (long) NdrpComputeConformance( pStubMsg, pMemory, pFormat );
            *pWireSize = *pLength * ElementSize;
            *pLength   = *pSize;
            return;

        case FC_LGVARRAY:
            *pWireSize = * (long *) ( pFormat + 2 );
            *pSize     = * (short *) ( pFormat + 6 );
            NdrpComputeVariance( pStubMsg, pMemory, pFormat );
            *pLength   = pStubMsg->ActualCount;
            return;

        case FC_SMVARRAY:
            *pWireSize = * (short *) ( pFormat + 2 );
            *pSize     = * (short *) ( pFormat + 4 );
            NdrpComputeVariance( pStubMsg, pMemory, pFormat );
            *pLength   = pStubMsg->ActualCount;
            return;

        case FC_CVARRAY:
            *pSize     = (long) NdrpComputeConformance( pStubMsg, pMemory, pFormat );
            *pWireSize = *pSize * ElementSize;
            NdrpComputeVariance( pStubMsg, pMemory, pFormat );
            *pLength   = pStubMsg->ActualCount;
            return;

        case FC_CSTRING:
            *pSize     = strlen( (char*)pMemory ) + 1;
            *pWireSize = *pSize;
            *pLength   = *pSize;
            return;

        case FC_WSTRING:
            *pSize     = wcslen( (wchar_t *) pMemory ) + 1;
            *pWireSize = *pSize * 2;
            *pLength   = *pSize;
            return;
        }

    NDR_ASSERT( 0, "NdrpGetArraySizeLength: Unhandled type" );
    RpcRaiseException( RPC_S_INTERNAL_ERROR );
    *pSize     = 0;
    *pWireSize = 0;
    *pLength   = 0;
}


#ifdef _CS_CHAR_
unsigned char * RPC_ENTRY
NdrCsTagMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a cs tag (i.e. a parameter marked with [cs_stag], [cs_drtag],
    or [cs_rtag].

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the value on the stack.
    pFormat     - Pointer to the FC_CS_TAG entry in the format string.

Return :

    None.

--*/
{
    ulong   Codeset = NdrpGetSetCSTagMarshall( 
                                pStubMsg,
                                pMemory,
                                (NDR_CS_TAG_FORMAT *) pFormat);

    * (ulong *) pStubMsg->Buffer = Codeset;
    pStubMsg->Buffer += sizeof( ulong );
    
    return 0;
}

extern const byte NdrpArrayMarshallFlags[] = 
{
    MARSHALL_CONFORMANCE,                       // Conformant array
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant varying
    0,                                          // Small fixed
    0,                                          // Large fixed
    MARSHALL_VARIANCE,                          // Small varying
    MARSHALL_VARIANCE,                          // Large varying
    MARSHALL_BOGUS,                             // Bogus array
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant C string
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant byte string
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant struct string
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant Unicode string
    MARSHALL_VARIANCE,                          // C string
    MARSHALL_VARIANCE,                          // byte string
    MARSHALL_VARIANCE,                          // struct string
    MARSHALL_VARIANCE                           // Unicode string
};
     
    

void 
NdrpUpdateArrayProlog(
    PFORMAT_STRING      pFormat,
    uchar *             BufferMark,
    ulong               WireSize,
    ulong               Offset,
    ulong               WireLength )
{
    int flags;

    NDR_ASSERT( *pFormat >= FC_CARRAY,  "Invalid array descriptor" );
    NDR_ASSERT( *pFormat <= FC_WSTRING, "Invalid array descriptor" );

    // We don't support bogus arrays for now
    NDR_ASSERT( *pFormat != FC_BOGUS_ARRAY, "Bogus arrays are not supported" );

    flags = NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ];

    if ( flags & MARSHALL_CONFORMANCE )
        {
        * (ulong *) BufferMark = WireSize;
        BufferMark += 4;
        }

    if ( flags & MARSHALL_VARIANCE )
        {
        * (ulong *) BufferMark = Offset;
        BufferMark += 4;
        * (ulong *) BufferMark = WireLength;
        }
}


unsigned char * RPC_ENTRY
NdrCsArrayMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a [cs_char] array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the local array.
    pFormat     - Pointer to the FC_CSARRAY entry in the format string.

Return :

    None.

Notes :
    
    Arrays of [cs_char] are defined as arrays of bytes on the wire so
    marshalling is pretty simple once you know which bytes to marshall and
    how many of them.  Since the existing array marshalling routines are not
    very general (they don't take size/length parameters) and since the
    overhead of a call to memcpy isn't very high we do the marshalling
    ourselves.

--*/
{
    ulong           SendingCodeset;
    ulong           ReceivingCodeset;
    ulong           ArraySize;
    ulong           ArrayLength;
    ulong           WireSize;
    ulong           WireLength;
    uchar          *BufferMark;
    error_status_t  status;

    NDR_CS_ARRAY_FORMAT            *pCSFormat;
    NDR_CS_SIZE_CONVERT_ROUTINES   *CSRoutines;
    CS_TYPE_NET_SIZE_ROUTINE        NetSizeRoutine;
    CS_TYPE_TO_NETCS_ROUTINE        ToNetCSRoutine;
    IDL_CS_CONVERT                  ConversionType;
    
    pCSFormat = (NDR_CS_ARRAY_FORMAT *) pFormat;

    // Get all the info out of the FC_CS_ARRAY structure and bump pFormat
    // to point to the underlying data descriptor

    NDR_ASSERT( NULL != pStubMsg->pCSInfo, "cs_char info is not set up");

    if ( pStubMsg->IsClient )
        SendingCodeset = pStubMsg->pCSInfo->WireCodeset;
    else
        SendingCodeset = pStubMsg->pCSInfo->DesiredReceivingCodeset;

    CSRoutines = pStubMsg->StubDesc->CsRoutineTables->pSizeConvertRoutines;

    NetSizeRoutine = CSRoutines[pCSFormat->CSRoutineIndex].pfnNetSize;
    ToNetCSRoutine = CSRoutines[pCSFormat->CSRoutineIndex].pfnToNetCs;

    pFormat += pCSFormat->DescriptionOffset;

    // Get the size and length of the unconverted array.

    NdrpGetArraySizeLength( pStubMsg,
                            pMemory,
                            pFormat,
                            pCSFormat->UserTypeSize,
                            (long*)&ArraySize,
                            (long*)&ArrayLength,
                            (long*)&WireSize );

    // Figure out whether we need to convert the data

    WireSize = ArraySize;

    NetSizeRoutine(
                pStubMsg->RpcMsg->Handle,
                SendingCodeset,
                ArraySize,
                &ConversionType,
                NdrpIsConformantArray( pFormat ) ? &WireSize : NULL,
                &status);

    if ( RPC_S_OK != status )
        RpcRaiseException( status );

    // Skip the buffer ahead to where the actual bits will go.  We'll patch
    // up the array prolog later.

    ALIGN( pStubMsg->Buffer, 3 );

    BufferMark = pStubMsg->Buffer;
    pStubMsg->Buffer += NdrpArrayPrologLength( pFormat );

    // If we need to convert do so, otherwise just memcpy
    
//    WireLength = WireSize;
    WireLength = ArrayLength * pCSFormat->UserTypeSize;

    if ( IDL_CS_NO_CONVERT == ConversionType )
        {
        CopyMemory( pStubMsg->Buffer, pMemory, WireLength );
        pStubMsg->Buffer += WireLength;
        }
    else
        {
        ToNetCSRoutine(
                pStubMsg->RpcMsg->Handle,
                SendingCodeset,
                pMemory,
                ArrayLength,
                pStubMsg->Buffer,
//                ! NdrpIsVaryingArray( pFormat ) ? NULL : &WireLength,
                NdrpIsFixedArray( pFormat ) ? NULL : &WireLength,
                &status);

        if ( RPC_S_OK != status )
            RpcRaiseException( status );

        NDR_ASSERT( 
                WireLength <= WireSize, 
                "Buffer overflow during [cs_char] conversion");

        pStubMsg->Buffer += WireLength;
/*
        // For conformant or fixed arrays we must have WireSize bytes on the
        // wire so pad it out if necessary

        if ( ! NdrpIsVaryingArray( pFormat ) && WireLength < WireSize )
            {
            // REVIEW: Is zero'ing necessary?
            ZeroMemory( pStubMsg->Buffer, WireSize - WireLength );
            pStubMsg->Buffer += WireSize - WireLength;
            }
*/
        if ( ! NdrpIsVaryingArray( pFormat ) )
            WireSize = WireLength;
        }

    NdrpUpdateArrayProlog( 
            pFormat, 
            BufferMark, 
            WireSize, 
            pStubMsg->Offset,
            WireLength );

    return 0;
}
#endif // _CS_CHAR


void
RPC_ENTRY
NdrPartialIgnoreClientMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    void *                              pMemory
    )
{
    ALIGN( pStubMsg->Buffer, 0x3 );
    *(ulong *)pStubMsg->Buffer = pMemory ? 1 : 0;
    pStubMsg->Buffer += PTR_WIRE_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\misc.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    misc.c

Abstract :

    Contains miscelaneous helper routines.

Author :

    David Kays  dkays   December 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "attack.h"

uchar *
NdrpMemoryIncrement( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat 
    )
/*++

Routine Description :

    Returns a memory pointer incremeted past a complex data type.  This routine
    is also overloaded to compute the size of a complex data type by passing
    a 0 memory pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the complex type, or 0 if a size is being computed.
    pFormat     - Format string description.

Return :

    A memory pointer incremented past the complex type.  If a 0 memory pointer
    was passed in then the returned value is the size of the complex type.

--*/
{
    long    Elements;
    long    ElementSize;

    switch ( *pFormat )
        {
        //
        // Structs
        //
        case FC_STRUCT :
        case FC_PSTRUCT :
        case FC_HARD_STRUCT :
            pMemory += *((ushort *)(pFormat + 2));
            break;

        case FC_CSTRUCT :
        case FC_CVSTRUCT :
        case FC_CPSTRUCT :
            pMemory += *((ushort *)(pFormat + 2));
        
            // Get conformant array or string description.
            pFormat += 4;
            pFormat += *((signed short *)pFormat);

            // This flag is set by the endianess pass only.
            if ( ! IS_TOPMOST_CONF_STRUCT( pStubMsg->uFlags ) )
                {
                // When embedding in a bogus struct, array is accounted
                // at the conf struct level, due to pointer layout.
                // Get the memory pointer past the conformant array.
                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormat );
                }
            break;

        case FC_BOGUS_STRUCT :
            pMemory += *((ushort *)(pFormat + 2));
            
            pFormat += 4;

            // Check for a conformant array or string in the struct.
            if ( *((signed short *)pFormat) )
                {
                pFormat += *((signed short *)pFormat);

                if ( !IS_EMBED_CONF_STRUCT( pStubMsg->uFlags )  &&
                     ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
                    {
                    // Get the memory pointer past the conformant array.
                    pMemory = NdrpMemoryIncrement( pStubMsg,
                                                   pMemory,
                                                   pFormat );
                    }
                }
            break;

        //
        // Unions
        //
        case FC_ENCAPSULATED_UNION :
            pMemory += HIGH_NIBBLE(pFormat[1]);
            pMemory += *((ushort *)(pFormat + 2));
            break;

        case FC_NON_ENCAPSULATED_UNION :
            // Go to the size/arm description.
            pFormat += 6;
            CORRELATION_DESC_INCREMENT( pFormat );
            pFormat += *((signed short *)pFormat);
        
            pMemory += *((ushort *)pFormat);
            break;

        //
        // Arrays
        //
        case FC_SMFARRAY :
        case FC_SMVARRAY :
            pMemory += *((ushort *)(pFormat + 2));
            break;

        case FC_LGFARRAY :
        case FC_LGVARRAY :
            pMemory += *((ulong UNALIGNED *)(pFormat + 2));
            break;

        case FC_CARRAY:
        case FC_CVARRAY:
                {
                ULONG_PTR ConfSize =  NdrpComputeConformance( pStubMsg, 
                                               pMemory, 
                                               pFormat);
                // check for possible mulitplication overflow attack here.
                pMemory += MultiplyWithOverflowCheck(  ConfSize, *((ushort *)(pFormat + 2)) );
                }
            break;

        case FC_BOGUS_ARRAY :
            {
            PARRAY_INFO pArrayInfo = pStubMsg->pArrayInfo;

            if ( *((long UNALIGNED *)(pFormat + 4)) == 0xffffffff )
                Elements = *((ushort *)(pFormat + 2));
            else
                {
                if ( pArrayInfo && 
                     pArrayInfo->MaxCountArray &&
                     (pArrayInfo->MaxCountArray ==  
                      pArrayInfo->BufferConformanceMark) )
                    {
                    Elements = pArrayInfo->MaxCountArray[pArrayInfo->Dimension];
                    }
                else
                    {
                    Elements = (ulong) NdrpComputeConformance( pStubMsg,
                                                               pMemory,
                                                               pFormat );
                    }
                }

            // Go to the array element's description.
            pFormat += 12;
            CORRELATION_DESC_INCREMENT( pFormat );
            CORRELATION_DESC_INCREMENT( pFormat );

            // 
            // Get the size of one element.
            //
            switch ( *pFormat )
                {
                case FC_ENUM16 :
                    ElementSize = sizeof(int);
                    break;

                case FC_RP :
                case FC_UP :
                case FC_FP :
                case FC_OP :
                    ElementSize = PTR_MEM_SIZE;
                    break;

                case FC_EMBEDDED_COMPLEX :
                    //
                    // It's some complicated thingy.
                    //
                    pFormat += 2;
                    pFormat += *((signed short *)pFormat);

                    if ( (*pFormat == FC_TRANSMIT_AS) || 
                         (*pFormat == FC_REPRESENT_AS) ||
                         (*pFormat == FC_USER_MARSHAL) )
                        {
                        //
                        // Get the presented type size.
                        //
                        ElementSize = *((ushort *)(pFormat + 4));
                        }
                    else
                        {
                        if ( pArrayInfo ) 
                            pArrayInfo->Dimension++;

                        ElementSize = (long)
                                     ( NdrpMemoryIncrement( pStubMsg,
                                                            pMemory,
                                                            pFormat ) - pMemory );

                        if ( pArrayInfo ) 
                            pArrayInfo->Dimension--;
                        }
                    break;

                case FC_RANGE:
                        ElementSize = SIMPLE_TYPE_MEMSIZE( (pFormat[1] & 0x0f) );
                        break;

                default :
                    if ( IS_SIMPLE_TYPE(*pFormat) )
                        {
                        ElementSize = SIMPLE_TYPE_MEMSIZE(*pFormat);
                        break;
                        }

                    NDR_ASSERT(0,"NdrpMemoryIncrement : bad format char");
                    RpcRaiseException( RPC_S_INTERNAL_ERROR );
                    return 0;
                }

            // check for possible mulitplication overflow attack here.
            pMemory += MultiplyWithOverflowCheck(  Elements, ElementSize );
            }

            break;

        //
        // String arrays (a.k.a. non-conformant strings).
        //
        case FC_CSTRING :
        case FC_BSTRING :
        case FC_WSTRING :
                {
                ULONG ElementSize = (*pFormat == FC_WSTRING) ? sizeof(wchar_t) : sizeof(char) ;
                ULONG Elements = *((ushort *)(pFormat + 2)) ;
                // check for possible mulitplication overflow attack here.
                pMemory += MultiplyWithOverflowCheck(  Elements, ElementSize );  
                }
            break;

        case FC_SSTRING :
            // check for possible mulitplication overflow attack here.
            pMemory += MultiplyWithOverflowCheck( pFormat[1], *((ushort *)(pFormat + 2) ) );
            break;

        //
        // Sized conformant strings.
        //
        case FC_C_CSTRING:
        case FC_C_BSTRING:
        case FC_C_WSTRING:
            {
            PARRAY_INFO pArrayInfo = pStubMsg->pArrayInfo;
            ULONG ElementSize =  (*pFormat == FC_C_WSTRING) ? 
                                sizeof(wchar_t) : 
                                sizeof(char);

            NDR_ASSERT(pFormat[1] == FC_STRING_SIZED, 
                       "NdrpMemoryIncrement : called for non-sized string");

            if ( pArrayInfo && 
                 pArrayInfo->MaxCountArray &&
                 (pArrayInfo->MaxCountArray == 
                  pArrayInfo->BufferConformanceMark) )
                {
                Elements = pArrayInfo->MaxCountArray[pArrayInfo->Dimension];
                }
            else
                {
                Elements = (ulong) NdrpComputeConformance( pStubMsg, 
                                                           pMemory, 
                                                           pFormat );
                }

            // check for possible mulitplication overflow attack here.
            pMemory += MultiplyWithOverflowCheck( Elements, ElementSize );
            }
            break;

        case FC_C_SSTRING:
            {
            PARRAY_INFO pArrayInfo = pStubMsg->pArrayInfo;

            if ( pArrayInfo && 
                 pArrayInfo->MaxCountArray &&
                 (pArrayInfo->MaxCountArray == 
                  pArrayInfo->BufferConformanceMark) )
                {
                Elements = pArrayInfo->MaxCountArray[pArrayInfo->Dimension];
                }
            else
                {
                Elements = (ulong) NdrpComputeConformance( pStubMsg, 
                                                           pMemory, 
                                                           pFormat );
                }

            // check for possible mulitplication overflow attack here.
            pMemory += MultiplyWithOverflowCheck( Elements, pFormat[1] );
            }
            break;

        //
        // Transmit as, represent as, user marshal
        //
        case FC_TRANSMIT_AS :
        case FC_REPRESENT_AS :
        case FC_USER_MARSHAL :
            // Get the presented type size.
            pMemory += *((ushort *)(pFormat + 4));
            break;

        case FC_BYTE_COUNT_POINTER:
            //
            // Should only hit this case when called from NdrSrvOutInit().
            // In this case it's the total byte count allocation size we're
            // looking for.
            //
            // We are taking the larger of conformant size and the real data
            // type size, otherwise, we might give user a partially invalid
            // buffer, and that'll come back to bite us during sizing/marshalling
            {
            uchar * pMemory1 = pMemory;
            uchar * pMemory2 = pMemory;
            PFORMAT_STRING pFormat2 = pFormat;

            if ( pFormat[1] != FC_PAD )
                {
                pMemory2 += SIMPLE_TYPE_MEMSIZE( pFormat[1] );
                }
            else
                {

                // go pass the conformance & get to the real type
                pFormat2 += 6;
                CORRELATION_DESC_INCREMENT( pFormat2 );
                pFormat2 += *((signed short *)pFormat2);
            
                pMemory2 = NdrpMemoryIncrement( pStubMsg, 
                                                pMemory2, 
                                                pFormat2 );

                }

            pMemory1 += NdrpComputeConformance( pStubMsg, 
                                                pMemory1, 
                                                pFormat );

            pMemory = ( pMemory1 > pMemory2 )? pMemory1 : pMemory2;
            break;
            }

        case FC_IP :
            pMemory += PTR_MEM_SIZE;
            break;

        case FC_RANGE:
            pMemory += SIMPLE_TYPE_MEMSIZE( (pFormat[1] & 0x0f) );
            break;

#ifdef _CS_CHAR_
        case FC_CSARRAY:
            {
            uchar * OldBuffer = pStubMsg->Buffer;
            ulong   OldSize   = pStubMsg->MemorySize;

            pStubMsg->MemorySize = 0;

            pMemory += NdrCsArrayMemorySize( pStubMsg, pFormat );

            pStubMsg->MemorySize = OldSize;
            pStubMsg->Buffer     = OldBuffer;

            break;
            }

        case FC_CS_TAG:
            pMemory += sizeof( ulong );
            break;
#endif _CS_CHAR_

        default :
            NDR_ASSERT(0,"NdrpMemoryIncrement : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return pMemory;
}

long
NdrpArrayDimensions( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    BOOL                fIgnoreStringArrays 
    )
/*++

Routine description :

    This routine determines the number of dimensions in a complex array, which
    is the only array type which is allowed to have multiple dimensions other
    than an array of multiple fixed dimensions.

Arguments :

    pFormat             - Complex array's format string description.
    fIgnoreStringArrays - TRUE if a string array should not be counted as
                          a dimension, FALSE if it should.

Return :

    The number of dimensions in the array.

--*/
{
    long    Dimensions;

    //
    // Only a complex array can have multiple dimensions.
    //
    if ( *pFormat != FC_BOGUS_ARRAY )
        return 1;

    Dimensions = 1;

    pFormat += 12;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    for ( ; *pFormat == FC_EMBEDDED_COMPLEX; )
        {
        pFormat += 2;
        pFormat += *((signed short *)pFormat);

        //
        // Search for a fixed, complex, or string array.
        //
        switch ( *pFormat ) 
            {
            case FC_SMFARRAY :
                pFormat += 4;
                break;

            case FC_LGFARRAY :
                pFormat += 6;
                break;

            case FC_BOGUS_ARRAY :
                pFormat += 12;
                CORRELATION_DESC_INCREMENT( pFormat );
                CORRELATION_DESC_INCREMENT( pFormat );
                break;

            case FC_CSTRING :
            case FC_BSTRING :
            case FC_WSTRING :
            case FC_SSTRING :
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :
                //
                // Can't have any more dimensions after a string array.
                //
                return fIgnoreStringArrays ? Dimensions : Dimensions + 1;

            default :
                return Dimensions;
            }

        Dimensions++;
        }

    //
    // Get here if you have only one dimension.
    //
    return Dimensions;
}

long
NdrpArrayElements( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory, 
    PFORMAT_STRING      pFormat 
    )
/*++

Routine description :

    This routine determines the number of elements (allocation size) in an 
    array.  Used to handle multidimensional arrays.

Arguments :

    pStubMsg    - The stub message.
    pMemory     - The array.
    pFormat     - Array's format string description.

Return :

    The number of elements in the array.

--*/
{
    long    TotalSize;
    long    ElementSize;

    switch ( *pFormat )
        {
        case FC_SMFARRAY :
            TotalSize = (long) *((ushort *)(pFormat + 2));
            pFormat += 4;
            break;

        case FC_LGFARRAY :
            TotalSize = *((long UNALIGNED *)(pFormat + 2));
            pFormat += 6;
            break;
        
        case FC_SMVARRAY :
            return (long) *((ushort *)(pFormat + 4));
            
        case FC_LGVARRAY :
            return *((long UNALIGNED *)(pFormat + 6));
            
        case FC_BOGUS_ARRAY :
            if ( *((long *)(pFormat + 4)) == 0xffffffff )
                return (long) *((ushort *)(pFormat + 2));

            // else fall through

        case FC_CARRAY :
        case FC_CVARRAY :
            return (ulong) NdrpComputeConformance( pStubMsg, 
                                                   pMemory,
                                                   pFormat ); 

        default :
            NDR_ASSERT(0,"NdrpArrayElements : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    //
    // We get here for a non-complex fixed array.
    //
    // Since a fixed array's format string description does not
    // contain the number of elements in the array, we have to compute
    // it by computing the array's element size and dividing this into
    // the total array size.
    //
    // A fixed array's child can only be a nice struct, another
    // fixed array, a pointer, or a simple type.
    //

    //
    // Skip pointer layout if one is present.
    //
    if ( *pFormat == FC_PP )
        pFormat = NdrpSkipPointerLayout( pFormat );

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            //
            // We must be at FC_STRUCT, FC_PSTRUCT, FC_SMFARRAY, or FC_LGFARRAY.
            // All these have the total size as a short at 2 bytes past the 
            // beginning of the description except for large fixed array.
            //
            if ( *pFormat != FC_LGFARRAY )
                ElementSize = (long) *((ushort *)(pFormat + 2));
            else
                ElementSize = *((long UNALIGNED *)(pFormat + 2));
                
            break;
    
        //
        // Simple type (enum16 not possible).
        //
        default :
            ElementSize = SIMPLE_TYPE_MEMSIZE( *pFormat );
            break;
        }

    return TotalSize / ElementSize;
}

void
NdrpArrayVariance( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long *              pOffset,
    long *              pLength
    )
/*++

Routine description :

    This routine determines the offset and length values for an array.  
    Used to handle multidimensional arrays.

Arguments :

    pStubMsg    - The stub message.
    pMemory     - The array.
    pFormat     - Array's format string description.
    pOffset     - Returned offset value.
    pLength     - Returned length value.

Return :

    None.

--*/
{
    switch ( *pFormat )
        {
        case FC_SMFARRAY :
        case FC_LGFARRAY :
        case FC_CARRAY :
            *pOffset = 0;
            *pLength = NdrpArrayElements( pStubMsg,
                                          pMemory, 
                                          pFormat );
            break;

        case FC_BOGUS_ARRAY :
            {
            PFORMAT_STRING  pFormatBAV = pFormat + 8;

            CORRELATION_DESC_INCREMENT( pFormatBAV );

            if ( *((long UNALIGNED *)(pFormatBAV + 8)) == 0xffffffff )
                {
                *pOffset = 0;
                *pLength = NdrpArrayElements( pStubMsg, 
                                              pMemory, 
                                              pFormat );
                return;
                }
            }

            // else fall through

        case FC_CVARRAY :
        case FC_SMVARRAY :
        case FC_LGVARRAY :
            NdrpComputeVariance( pStubMsg, 
                                 pMemory,
                                 pFormat ); 

            *pOffset = (long) pStubMsg->Offset;
            *pLength = (long) pStubMsg->ActualCount;
            break;

        default :
            NDR_ASSERT(0,"NdrpArrayVariance : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}

PFORMAT_STRING
NdrpSkipPointerLayout( 
    PFORMAT_STRING pFormat 
    )
/*--

RoutineDescription :

    Skips a pointer layout format string description.

Arguments :

    pFormat - Format string pointer layout description.  Must currently
              point to the FC_PP beginning the pointer layout.

Return :

    Format string pointer past the pointer layout.

--*/
{
    long    Pointers;

    NDR_ASSERT( *pFormat == FC_PP, 
                "NdrpSkipPointerLayout : format string not at FC_PP" );

    // Skip FC_PP and FC_PAD.
    pFormat += 2;

    for (;;)
        {
        switch ( *pFormat )
            {
            case FC_END :
                return pFormat + 1;

            case FC_NO_REPEAT :
                pFormat += 10;
                break;

            case FC_FIXED_REPEAT :
                pFormat += 2;
                // fall through...

            case FC_VARIABLE_REPEAT :
                pFormat += 6;

                Pointers = *((ushort * &)pFormat)++;

                pFormat += Pointers * 8;
                break;

            default :
                NDR_ASSERT( 0, "NdrpSkipPointerLayout : bad format char" );
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            }
        }
}

long
NdrpStringStructLen( 
    uchar *     pMemory,
    long        ElementSize
    )
/*--

RoutineDescription :

    Determines a stringable struct's length.

Arguments :

    pMemory     - Pointer to stringable struct.
    ElementSize - Number of bytes of each string element.

Return :

    Length of string.

--*/
{
    long    Length;
    uchar   Buffer[256];

    // Note : String struct element size is limited to 256 bytes.

    MIDL_memset( Buffer, 0, 256 );

    for ( Length = 0; ; Length++ )
        {
        if ( memcmp( pMemory, Buffer, ElementSize ) == 0 )
            break;

        pMemory += ElementSize;
        }

    return Length;
}

void
NdrpCheckBound(
    ulong               Bound,
    int                 Type
    )
{
    ulong   Mask;

    switch ( Type )
        {
        case FC_ULONG :

#if defined(__RPC_WIN64__)
        case FC_UINT3264 :
        case FC_INT3264 :
#endif
            //
            // We use a mask here which will raise an exception for counts
            // of 2GB or more since this is the max NT allocation size.
            //
            Mask = 0x80000000UL;
            break;
        case FC_LONG :
            Mask = 0x80000000UL;
            break;
        case FC_USHORT :
            Mask = 0xffff0000UL;
            break;
        case FC_SHORT :
            Mask = 0xffff8000UL;
            break;
        case FC_USMALL :
            Mask = 0xffffff00UL;
            break;
        case FC_SMALL :
            Mask = 0xffffff80UL;
            break;
        case 0 :
            //
            // For variance which requires calling an auxilary expression
            // evaluation routine a type is not emitted in the format string.
            // We have to just give up.
            //
            // The same thing happens with constant conformance type
            // we emit zero on the var type nibble.
            //
            return;
        default :
            NDR_ASSERT( 0, "NdrpCheckBound : bad type" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    if ( Bound & Mask )
        RpcRaiseException( RPC_X_INVALID_BOUND );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\mulsyntx.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    mulsyntx.cxx

Abstract :

    This file contains multiple transfer syntaxes negotiation related code

Author :

    Yong Qu    yongqu    September 1999.

Revision History :


  ---------------------------------------------------------------------*/


#include "ndrp.h"
#define CINTERFACE
#include "ndrole.h"
#include "rpcproxy.h"
#include "mulsyntx.h"
#include "hndl.h"
#include "auxilary.h"
#include "pipendr.h"
#include "ndr64tkn.h"

const extern PMARSHALL_ROUTINE        MarshallRoutinesTable[];
const extern PUNMARSHALL_ROUTINE      UnmarshallRoutinesTable[];
const extern PSIZE_ROUTINE            SizeRoutinesTable[];
const extern PMEM_SIZE_ROUTINE        MemSizeRoutinesTable[];
const extern PFREE_ROUTINE            FreeRoutinesTable[];
//const extern PWALKIP_ROUTINE          WalkIPRoutinesTable[];

// TODO: move this to ndrpall.h after Preview.
#define MIDL_VERSION_6_0_322   ((6UL << 24) | (0UL << 16) | 322UL)

void RPC_ENTRY
NdrpClientInit(MIDL_STUB_MESSAGE * pStubMsg,
               void *              pReturnValue )
{
    PFORMAT_STRING              pFormatParam;
    ulong                       ProcNum;
    BOOL                        fRaiseExcFlag;
    ulong                       n;
    uchar *                     pArg;
    INTERPRETER_FLAGS           InterpreterFlags;
    PPARAM_DESCRIPTION          Params;
    NDR_PROC_CONTEXT *          pContext = (NDR_PROC_CONTEXT *) pStubMsg->pContext;
    INTERPRETER_OPT_FLAGS       OptFlags = pContext->NdrInfo.pProcDesc->Oi2Flags;
    PFORMAT_STRING              pTypeFormat;

    // When this routine is called from ndrclientcall2, we don't have MIDL_SYNTAX_INFO,
    // so we need to read it from MIDL_STUB_DESC;
    // Note: we need to conenct StubDesc to pStubMsg before calling into here.
    if ( NULL == pContext->pSyntaxInfo )
        pContext->DceTypeFormatString = pStubMsg->StubDesc->pFormatTypes;
    else
        pContext->DceTypeFormatString = pContext->pSyntaxInfo->TypeString;

    InterpreterFlags = pContext->NdrInfo.InterpreterFlags;
    Params = ( PPARAM_DESCRIPTION )pContext->Params;
    pTypeFormat = pContext->DceTypeFormatString;

    if ( InterpreterFlags.FullPtrUsed )
        pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );
    else
        pStubMsg->FullPtrXlatTables = 0;

    if ( InterpreterFlags.RpcSsAllocUsed )
        NdrRpcSmSetClientToOsf( pStubMsg );

    // Set Rpc flags after the call to client initialize.
    pStubMsg->RpcMsg->RpcFlags = pContext->RpcFlags;

    if ( OptFlags.HasPipes )
        NdrpPipesInitialize32( pStubMsg,
                               &pContext->AllocateContext,
                               (PFORMAT_STRING) pContext->Params,
                               ( char * )pContext->StartofStack,
                               pContext->NumberParams  );

    // Must do this before the sizing pass!
    pStubMsg->StackTop = pContext->StartofStack;

    if ( OptFlags.HasExtensions )
        {
        pStubMsg->fHasExtensions  = 1;
        pStubMsg->fHasNewCorrDesc = pContext->NdrInfo.pProcDesc->NdrExts.Flags2.HasNewCorrDesc;
        if ( pContext->NdrInfo.pProcDesc->NdrExts.Flags2.ClientCorrCheck )
            {
            ulong *pCache =
                (ulong*)NdrpAlloca(&pContext->AllocateContext,
                                   NDR_DEFAULT_CORR_CACHE_SIZE );

            NdrCorrelationInitialize( pStubMsg,
                                      pCache,
                                      NDR_DEFAULT_CORR_CACHE_SIZE,
                                      0 /* flags */ );
            }
        }



    //
    // Get the compile time computed buffer size.
    //
    pStubMsg->BufferLength = pContext->NdrInfo.pProcDesc->ClientBufferSize;

    //
    // Check ref pointers and do object proc [out] zeroing.
    //

    fRaiseExcFlag = FALSE;

    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        if ( Params[n].ParamAttr.IsReturn )
            pArg = (uchar *) &pReturnValue;
        else
            pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsSimpleRef && !Params[n].ParamAttr.IsReturn )
            {
            // We cannot raise the exception here,
            // as some out args may not be zeroed out yet.

            if ( ! *((uchar **)pArg) )
                {
                fRaiseExcFlag = TRUE;
                continue;
                }
            }

        // if top level point is FC_RP and the arg is NULL, we'll catch this
        // before the call goes to server.
        // We wouldn't catch all the null ref pointer here, but we should be able
        // to catch the most obvious ones.
        // This code is called from sync & raw async code; in async dcom,
        // we only go through outinit in finish routine so we can't do anything anyhow.
        if ( Params[n].ParamAttr.IsOut && ! Params[n].ParamAttr.IsBasetype  )
            {
            pFormatParam = pTypeFormat + Params[n].TypeOffset;
            if ( * pFormatParam == FC_RP &&  !*((uchar **)pArg) )
                {
                fRaiseExcFlag = TRUE;
                continue;
                }
            }

        //
        // In object procs and complex return types we have to zero
        // out all [out] parameters.  We do the basetype check to
        // cover the [out] simple ref to basetype case.
        //
        if ( ( InterpreterFlags.ObjectProc &&
               ! pContext->IsAsync &&
               ( Params[n].ParamAttr.IsPartialIgnore ||
                 ( ! Params[n].ParamAttr.IsIn &&
                   ! Params[n].ParamAttr.IsReturn &&
                   ! Params[n].ParamAttr.IsPipe ) ) ) ||
             ( pContext->HasComplexReturn &&
                    Params[n].ParamAttr.IsReturn ) )
            {
                if ( Params[n].ParamAttr.IsBasetype )
                    {
                    // [out] only arg can only be ref, we checked that above.
                    MIDL_memset( *(uchar **)pArg,
                                 0,
                                 (size_t)SIMPLE_TYPE_MEMSIZE( Params[n].SimpleType.Type ));
                    }
                else
                    {
                    pFormatParam = pTypeFormat +
                           Params[n].TypeOffset;

                    NdrClientZeroOut(
                    pStubMsg,
                    pFormatParam,
                    *(uchar **)pArg );
                    }
            }
        }

    if ( fRaiseExcFlag )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if ( OptFlags.ClientMustSize )
        {
        // Compiler prevents variable size non-pipe args for NT v.4.0.

        if ( OptFlags.HasPipes )
            RpcRaiseException( RPC_X_WRONG_PIPE_VERSION );

        }
    else
        pContext->pfnSizing = (PFNSIZING)NdrpNoopSizing;
}

void RPC_ENTRY
NdrpNoopSizing( MIDL_STUB_MESSAGE *    pStubMsg,
            BOOL                   IsClient )
{
    return;
}


void RPC_ENTRY
NdrpSizing( MIDL_STUB_MESSAGE *    pStubMsg,
            BOOL                   IsClient )
{
    PFORMAT_STRING          pFormatParam;
    ulong                    n;
    uchar *                     pArg;
    NDR_PROC_CONTEXT *      pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION      Params = ( PPARAM_DESCRIPTION )pContext->Params;
    PFORMAT_STRING          pTypeFormat = pContext->DceTypeFormatString;

    //
    // Skip buffer size pass if possible.
    //

        for ( n = 0; n < pContext->NumberParams; n++ )
            {

            if ( !SAMEDIRECTION(IsClient, Params[n]) ||
                 ! Params[n].ParamAttr.MustSize )
                continue;

            if ( IsClient &&
                 Params[n].ParamAttr.IsPartialIgnore )
                {
                LENGTH_ALIGN( pStubMsg->BufferLength, 0x3 );
                pStubMsg->BufferLength += PTR_WIRE_SIZE;
                continue;
                }

            //
            // Note : Basetypes will always be factored into the
            // constant buffer size emitted by in the format strings.
            //

            pFormatParam = pTypeFormat +
                           Params[n].TypeOffset;

            pArg = pContext->StartofStack + Params[n].StackOffset;

            if ( ! Params[n].ParamAttr.IsByValue )
                pArg = *((uchar **)pArg);

            (*SizeRoutinesTable[ROUTINE_INDEX(*pFormatParam)])
			( pStubMsg,
			  pArg,
			  pFormatParam );
            }

}

void RPC_ENTRY
NdrpClientMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject )
{
    ulong n;
    uchar * pArg;
    PFORMAT_STRING              pFormatParam;
    NDR_PROC_CONTEXT *          pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION ) pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;

    //
    // ----------------------------------------------------------
    // Marshall Pass.
    // ----------------------------------------------------------
    //


    for ( n = 0; n < pContext->NumberParams; n++ )
        {

        if (!Params[n].ParamAttr.IsIn ||
             Params[n].ParamAttr.IsPipe )
            continue;

        if ( Params[n].ParamAttr.IsPartialIgnore )
            {

            pArg = pContext->StartofStack + Params[n].StackOffset;

            ALIGN( pStubMsg->Buffer, 0x3 );
            *(ulong*)pStubMsg->Buffer = *(void**)pArg ? 1 : 0;
            pStubMsg->Buffer += PTR_WIRE_SIZE;
            continue;

            }

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for pointer to basetype.
            //
            if ( Params[n].ParamAttr.IsSimpleRef )
                pArg = *((uchar **)pArg);
            else
            {

#ifdef _IA64_
             if ( !IsObject &&
                  Params[n].SimpleType.Type == FC_FLOAT )
                {
                // Due to the fact that NdrClientCall2 is called with the
                // parameters in ... arguments, floats get promoted to doubles.
                // This is not true for DCOM since an assembly langauge wrapper
                // is used that saves the floats as floats.
                //
                // BUG, BUG.  IA64 passes byval structures that consist
                // entirely of float fields with each field in a separate register.
                // We do not handle this case properly.
                *((float *) pArg) = (float) *((double *)pArg);

                }
#endif
            }

            if ( Params[n].SimpleType.Type == FC_ENUM16 )
                {
                if ( *((int *)pArg) & ~((int)0x7fff) )
                    RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);

                }

            ALIGN( pStubMsg->Buffer,
                   SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ) );

            RpcpMemoryCopy(
                pStubMsg->Buffer,
                pArg,
                (uint)SIMPLE_TYPE_BUFSIZE(Params[n].SimpleType.Type) );

            pStubMsg->Buffer +=
                SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );

            continue;
            }

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        if ( ! Params[n].ParamAttr.IsByValue )
            pArg = *((uchar **)pArg);

        (* MarshallRoutinesTable[ROUTINE_INDEX(*pFormatParam)] )
        ( pStubMsg,
	      pArg,
		  pFormatParam );
        }

        if ( pStubMsg->RpcMsg->BufferLength <
                 (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
            {
            NDR_ASSERT( 0, "NdrpClientMarshal marshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }


}

void RPC_ENTRY
NdrpServerMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject )
{
    ulong n;
    uchar * pArg;
    PFORMAT_STRING              pFormatParam;
    NDR_PROC_CONTEXT *          pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION ) pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;

    //
    // ----------------------------------------------------------
    // Marshall Pass.
    // ----------------------------------------------------------
    //


    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        if (!Params[n].ParamAttr.IsOut  ||
             Params[n].ParamAttr.IsPipe )
            continue;

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for pointer to basetype.
            //
            if ( Params[n].ParamAttr.IsSimpleRef )
                pArg = *((uchar **)pArg);

            if ( Params[n].SimpleType.Type == FC_ENUM16 )
                {
                if ( *((int *)pArg) & ~((int)0x7fff) )
                    RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);

                }

            ALIGN( pStubMsg->Buffer,
                   SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ) );

            RpcpMemoryCopy(
                pStubMsg->Buffer,
                pArg,
                (uint)SIMPLE_TYPE_BUFSIZE(Params[n].SimpleType.Type) );

            pStubMsg->Buffer +=
                SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );

            continue;
            }

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        if ( ! Params[n].ParamAttr.IsByValue )
            pArg = *((uchar **)pArg);

        (* MarshallRoutinesTable[ROUTINE_INDEX(*pFormatParam)] )
        ( pStubMsg,
	      pArg,
		  pFormatParam );
        }

        if ( pStubMsg->RpcMsg->BufferLength <
                 (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
            {
            NDR_ASSERT( 0, "NdrpServerMarshal marshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }

}

/*
From:	To:		Marshall:	User Exception:	Cleanup:Rundown:	context handle:
----------	----------------------------------	--------------------------------
Any		NULL		Y		N/A				No		No		INVALID_HANDLE from the server
!NULL	Same value	Any		Any				No		No		Same as before
!NULL	Different 	Any		Any				No		No		New context on the server
!NULL	Any			N/A		Y				No		No		No new context handle is created
NULL	ANY 		N/A		Y				Yes		No		INVALID_HANDLE from the server
NULL	!NULL		Y		N				Yes		Yes		INVALID_HANDLE from the server
NULL	!NULL		N		N				Yes		Yes		INVALID_HANDLE from the server
!NULL	NULL		N		N				Yes		No		No new context handle is created
NULL	NULL		N		N				Yes		No		No new context handle is created

In the OUT only context handle case:
To:		Marshall:	User Exception:	Cleanup:Rundown:	context handle:
--------------------------------------------------------------------------------------
Any		N/A		    Y				N		N		No new context handle is created
NULL	N		    N				N		N		No new context handle is created
NULL	Y		    N				N		N		No new context handle is created
!NULL	N		    N				N		Y		No new context handle is created
!NULL	Y		    N				Y		Y		No new context handle is created


*/
void
NdrpEmergencyContextCleanup(
    MIDL_STUB_MESSAGE  *            pStubMsg,
    PNDR_CONTEXT_HANDLE_ARG_DESC    pCtxtDesc,
    void *                          pArg,
    BOOL                            fManagerRoutineException
    )
{
    int          RtnIndex   = pCtxtDesc->RundownRtnIndex;
    NDR_RUNDOWN  pfnRundown = pStubMsg->StubDesc->apfnNdrRundownRoutines[ RtnIndex ];
    NDR_SCONTEXT SContext   = pStubMsg->SavedContextHandles[ pCtxtDesc->ParamOrdinal ];
    void *       NewHandle  = pArg;

    // if runtime failes during marshalling context handle, we shouldn't call into
    // cleanup routine since it's already cleanup by runtime.
    if ( SContext == (NDR_SCONTEXT )CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER )
        return;


    if ( fManagerRoutineException )
        {
//        NDR_ASSERT( SContext != NULL ||  pCtxtDesc->Flags.IsReturn ,
//            "only return context handle can have null scontext in exception" );

        // if we failed somewhere during unmarshalling, or this is a return context handle,
        // we don't need to cleanup
        if ( SContext == NULL )
            return;

        // in NdrServerOutInit, we initialize the scontext for regular [out] parameters,
        // and runtime has already allocated some memory. But for return context handle,
        // we initialize the scontext during marshalling and saved context is NULL till
        // just before marshalling.
        }
    else
        {
        // haven't unmarshalled yet.
        if ( SContext == NULL )
            {
            if ( NULL == NewHandle )
                return;
            else
                {
                // note : what if the context handle is both return and viaptr?
                NDR_ASSERT( pCtxtDesc->Flags.IsReturn, "has to be return context handle" );
                }
            }
        else
            if ( SContext == (NDR_SCONTEXT )CONTEXT_HANDLE_AFTER_MARSHAL_MARKER )
            {
            // this particular context handle has been marshalled; the exception happens
            // during marshalling other parameters after this one.

            // After marshalling is done, the runtime will release the user context if new context
            // handle is NULL, so we can't reference to the user context at this point.
            NewHandle = NULL;
            }
        else
            {
            if ( pCtxtDesc->Flags.IsViaPtr )
                NewHandle = *((void * UNALIGNED *)pArg);
            }
        // if this is a regular [in,out] or [out] context handle, and it hasn't been marshalled
        // yet, we need to call into runtime to cleanup.
        }


    // Kamen volunteer to process the logic of calling runtime or not. In NDR we just
    // don't call into the routine when it isn't supposed to.
    NDRSContextEmergencyCleanup( pStubMsg->RpcMsg->Handle,
                                 SContext,
                                 pfnRundown,
                                 NewHandle,
                                 fManagerRoutineException );
}

void
NdrpCleanupServerContextHandles(
    MIDL_STUB_MESSAGE *    pStubMsg,
    uchar *                pStartOfStack,
    BOOL                   fManagerRoutineException )
{
    ulong n;
    uchar * pArg;
    PFORMAT_STRING              pFormatParam;
    NDR_PROC_CONTEXT *          pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION ) pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;

    //
    // ------------------------------------------------------------------------
    // Context handle loop: clean up out context handles to prevent leaks.
    //
    // Note, this routine handles only the handles that may have been dropped
    // due to the NDR engine raising exception between a clean return from
    // the manager routine and end of marshaling back of the parameters.
    // This addresses a situation where handles get dropped by NDR without being
    // registered with the runtime and so the server leaks because the rundown
    // routine is never called on the dropped handles.
    // ------------------------------------------------------------------------
    //

    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        if (!Params[n].ParamAttr.IsOut  ||
             Params[n].ParamAttr.IsPipe )
            continue;

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for pointer to basetype.
            //
            continue;
            }

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        if ( ! Params[n].ParamAttr.IsByValue )
            pArg = *((uchar **)pArg);

        // Context handle have their own "via pointer" flag to mark dereference.

        if ( *pFormatParam == FC_BIND_CONTEXT )
            {
            NdrpEmergencyContextCleanup( pStubMsg,
                                         (PNDR_CONTEXT_HANDLE_ARG_DESC) pFormatParam,
                                         pArg,
                                         fManagerRoutineException
                                         );
            }
        } // parameter loop

}

void RPC_ENTRY
NdrpClientUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg,
                void  *                 pReturnValue )
{
    ulong                       n;
    uchar *                     pArg;
    uchar **                    ppArg;
    PFORMAT_STRING              pFormatParam, pFormat;
    NDR_PROC_CONTEXT    *       pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION)pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;

    // we only need to do conversion in NDR32 now: we cut off endian
    // conversion in NDR64.
    // Do endian/floating point conversions if necessary.
    //
    if ( (pStubMsg->RpcMsg->DataRepresentation & 0X0000FFFFUL) !=
          NDR_LOCAL_DATA_REPRESENTATION )
        {
        NdrConvert2( pStubMsg,
                     (PFORMAT_STRING) Params,
                     pContext->NumberParams );
        }

   //
    // ----------------------------------------------------------
    // Unmarshall Pass.
    // ----------------------------------------------------------
    //

    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        if ( Params[n].ParamAttr.IsPipe )
            continue;

        if ( !Params[n].ParamAttr.IsOut )
            {
            if (    !Params[n].ParamAttr.IsIn
                 && !Params[n].ParamAttr.IsReturn )
                {
                // If a param is not [in], [out], or a return value,
                // then it is a "hidden" client-side only status
                // paramater.  It will get set below if an exception
                // happens.  If everything is ok we need to zero it
                // out here.

                NDR_ASSERT( Params[n].ParamAttr.IsSimpleRef
                                && Params[n].ParamAttr.IsBasetype
                                && FC_ERROR_STATUS_T ==
                                        Params[n].SimpleType.Type,
                            "Apparently not a hidden status param" );

                pArg = pContext->StartofStack + Params[n].StackOffset;

                ** (error_status_t **) pArg = RPC_S_OK;
                }

            continue;
            }

        if ( Params[n].ParamAttr.IsReturn )
            pArg = (uchar *) pReturnValue;
        else
            pArg = pContext->StartofStack + Params[n].StackOffset;

        //
        // This is for returned basetypes and for pointers to
        // basetypes.
        //
        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for a pointer to a basetype.
            //
            if ( Params[n].ParamAttr.IsSimpleRef )
                pArg = *((uchar **)pArg);

            ALIGN( pStubMsg->Buffer,
                   SIMPLE_TYPE_ALIGNMENT(Params[n].SimpleType.Type) );

            #if defined(__RPC_WIN64__)
                // Special case for int3264.

                if ( Params[n].SimpleType.Type == FC_INT3264  ||
                     Params[n].SimpleType.Type == FC_UINT3264 )
                    {
                    if ( Params[n].SimpleType.Type == FC_INT3264 )
                        *((INT64 *)pArg) = *((long * &)pStubMsg->Buffer)++;
                    else
                        *((UINT64 *)pArg) = *((ulong * &)pStubMsg->Buffer)++;
                    continue;
                    }
            #endif

            if ( Params[n].SimpleType.Type == FC_ENUM16 )
                {
                *((int *)(pArg)) = *((int *)pArg) & ((int)0x7fff) ;

                }

            RpcpMemoryCopy(
                pArg,
                pStubMsg->Buffer,
                (uint)SIMPLE_TYPE_BUFSIZE(Params[n].SimpleType.Type) );

            pStubMsg->Buffer +=
                SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );

            continue;
            }


        ppArg = Params[n].ParamAttr.IsByValue ? &pArg : (uchar **)pArg;

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        //
        // Transmit/Represent as can be passed as [out] only, thus
        // the IsByValue check.
        //
        (* UnmarshallRoutinesTable[ROUTINE_INDEX(*pFormatParam)] )
        ( pStubMsg,
          ppArg,
          pFormatParam,
          FALSE );
        }

    if ( pStubMsg->pCorrInfo )
        NdrCorrelationPass( pStubMsg );

    return ;
}

void RPC_ENTRY
NdrpServerUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg )
{
    ulong                        n;
    uchar *                     pArg;
    uchar **                    ppArg;
    PFORMAT_STRING              pFormatParam, pFormat;
    NDR_PROC_CONTEXT    *       pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION)pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;


    // we only need to do conversion in NDR32 now: we cut off endian
    // conversion in NDR64.
    // Do endian/floating point conversions if necessary.
    //
    if ( ( pStubMsg->RpcMsg->DataRepresentation & 0X0000FFFFUL) !=
          NDR_LOCAL_DATA_REPRESENTATION )
    {
        NdrConvert2( pStubMsg,
                     (PFORMAT_STRING) Params,
                     (long) pContext->NumberParams );
    }

    // --------------------------------
    // Unmarshall all of our parameters.
    // --------------------------------

    for ( n = 0; n < pContext->NumberParams; n++ )
        {

        if ( ! Params[n].ParamAttr.IsIn  ||
             Params[n].ParamAttr.IsPipe )
            continue;

        if ( Params[n].ParamAttr.IsPartialIgnore )
            {
            pArg = pContext->StartofStack + Params[n].StackOffset;

            ALIGN( pStubMsg->Buffer, 0x3 );
            *(void**)pArg = *(ulong*)pStubMsg->Buffer ? (void*)1 : (void*)0;
            pStubMsg->Buffer += PTR_WIRE_SIZE;

            continue;
            }

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for a pointer to a basetype.  Set the arg pointer
            // at the correct buffer location and you're done.
            // Except darn int3264
            if ( Params[n].ParamAttr.IsSimpleRef )
                {
                ALIGN( pStubMsg->Buffer,
                       SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ) );

                #if defined(__RPC_WIN64__)
                // Special case for a ref pointer to int3264.

                if ( Params[n].SimpleType.Type == FC_INT3264  ||
                     Params[n].SimpleType.Type == FC_UINT3264 )
                    {
                    *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext, 8 );

                    if ( Params[n].SimpleType.Type == FC_INT3264 )
                        *(*(INT64**)pArg) = *((long * &)pStubMsg->Buffer)++;
                    else
                        *(*(UINT64**)pArg)= *((ulong * &)pStubMsg->Buffer)++;
                    continue;
                    }
                #endif

                *((uchar **)pArg) = pStubMsg->Buffer;

                pStubMsg->Buffer +=
                    SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );
                }
            else
                {
                NdrUnmarshallBasetypeInline(
                    pStubMsg,
                    pArg,
                    Params[n].SimpleType.Type );

                }

            continue;
            } // IsBasetype

        //
        // This is an initialization of [in] and [in,out] ref pointers
        // to pointers.  These can not be initialized to point into the
        // rpc buffer and we want to avoid doing a malloc of 4 bytes!
        // 32b: a ref pointer to any pointer, we allocate the pointee pointer.
        //
        if ( Params[n].ParamAttr.ServerAllocSize != 0 )
            {
            *((void **)pArg) = NdrpAlloca(& pContext->AllocateContext, PTR_MEM_SIZE );

            // Triple indirection - cool!
            **((void ***)pArg) = 0;
            }

        pStubMsg->ReuseBuffer = Params[n].ParamAttr.IsForceAllocate;
        ppArg = Params[n].ParamAttr.IsByValue ? &pArg : (uchar **)pArg;

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        (*UnmarshallRoutinesTable[ROUTINE_INDEX(*pFormatParam)])
        ( pStubMsg,
          ppArg,
          pFormatParam,
          Params[n].ParamAttr.IsForceAllocate &&
              !Params[n].ParamAttr.IsByValue );

        pStubMsg->ReuseBuffer = FALSE;

        }

    if ( pStubMsg->pCorrInfo )
        NdrCorrelationPass( pStubMsg );

    return ;
}

void RPC_ENTRY
NdrpDcomClientExceptionHandling(  MIDL_STUB_MESSAGE  *      pStubMsg,
                    ulong                                   ProcNum,
                    RPC_STATUS                              ExceptionCode,
                    CLIENT_CALL_RETURN  *                   pReturnValue )
{
    ulong                   NumberParams;
    PPARAM_DESCRIPTION      Params;
    PFORMAT_STRING          pTypeFormat;
    ulong                   n;
    uchar *                 pArg;
    PFORMAT_STRING          pFormatParam;
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

    pReturnValue->Simple = NdrProxyErrorHandler(ExceptionCode);
    if( pStubMsg->dwStubPhase != PROXY_UNMARSHAL)
        return;

    NumberParams = pContext->NumberParams;
    Params = ( PPARAM_DESCRIPTION )pContext->Params;
    // alert: this can't be directly called from ndrclientcall2: we don't have pSyntaxInfo.
    pTypeFormat = pContext->DceTypeFormatString;

    //
    // In OLE, since they don't know about error_status_t and wanted to
    // reinvent the wheel, check to see if we need to map the exception.
    // In either case, set the return value and then try to free the
    // [out] params, if required.
    //
        pStubMsg->BufferStart = 0;
        pStubMsg->BufferEnd   = 0;

        for ( n = 0; n < pContext->NumberParams; n++ )
            {
            //
            // Skip everything but [out] only parameters.  We make
            // the basetype check to cover [out] simple ref pointers
            // to basetypes.
            //

            if ( !Params[n].ParamAttr.IsPartialIgnore )
                {
                if ( Params[n].ParamAttr.IsIn ||
                     Params[n].ParamAttr.IsReturn ||
                     Params[n].ParamAttr.IsBasetype ||
                     Params[n].ParamAttr.IsPipe )
                    continue;
                }

            pArg = pContext->StartofStack + Params[n].StackOffset;

            pFormatParam = pTypeFormat +
                           Params[n].TypeOffset;

            NdrClearOutParameters( pStubMsg,
                                   pFormatParam,
                                   *((uchar **)pArg) );
            }

    return ;
}

void RPC_ENTRY
NdrpClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                    ulong                   ProcNum,
                    RPC_STATUS              ExceptionCode,
                    CLIENT_CALL_RETURN  *   pReturnValue )
{
    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT * ) pStubMsg->pContext;

    NDR_ASSERT( pContext->NdrInfo.InterpreterFlags.HasCommOrFault, 
            " must have comm or fault to catch" );
    NdrClientMapCommFault( pStubMsg,
                           ProcNum,
                           ExceptionCode,
                           (ULONG_PTR*)&pReturnValue->Simple );

    return ;
}

void RPC_ENTRY
NdrpAsyncClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                    ulong                   ProcNum,
                    RPC_STATUS              ExceptionCode,
                    CLIENT_CALL_RETURN  *   pReturnValue  )
{
    NDR_PROC_CONTEXT    *       pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

    if ( pContext->NdrInfo.InterpreterFlags.HasCommOrFault )
        {
        NdrClientMapCommFault( pStubMsg,
                               ProcNum,
                               ExceptionCode,
                               (ULONG_PTR*)&pReturnValue->Simple );
        if ( ExceptionCode == RPC_S_ASYNC_CALL_PENDING )
            {
            // If the call is just pending, force the pending error code
            // to show up in the return value of RpcAsyncCallComplete.

            pReturnValue->Simple = RPC_S_ASYNC_CALL_PENDING;
            }
        }
    else
        {
        RpcRaiseException(ExceptionCode);
        }

    return ;
}


void  RPC_ENTRY
NdrpClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis )
{
    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT * ) pStubMsg->pContext;
    NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

    NdrCorrelationFree( pStubMsg );

    //
    // Free the RPC buffer.
    //
    if ( pThis )
        {
        NdrProxyFreeBuffer( pThis, pStubMsg );
        }
    else
        {
        NdrFreeBuffer( pStubMsg );

    //
    // Unbind if generic handle used.  We do this last so that if the
    // the user's unbind routine faults, then all of our internal stuff
    // will already have been freed.
    //
        if ( pContext->SavedGenericHandle )
        GenericHandleUnbind( pStubMsg->StubDesc,
                             pContext->StartofStack,
                             pContext->pHandleFormatSave,
                             (pContext->HandleType) ? IMPLICIT_MASK : 0,
                             &pContext->SavedGenericHandle );
        }

    NdrpAllocaDestroy( & pContext->AllocateContext );
}


void
NdrpServerInit( PMIDL_STUB_MESSAGE   pStubMsg,
                RPC_MESSAGE *        pRpcMsg,
                PMIDL_STUB_DESC      pStubDesc,
                void *               pThis,
                IRpcChannelBuffer *  pChannel,
                PNDR_ASYNC_MESSAGE   pAsyncMsg )
{
    NDR_PROC_CONTEXT *  pContext = (NDR_PROC_CONTEXT *) pStubMsg->pContext;

    uchar *                 pArg;
    uchar *  pArgBuffer = pContext->StartofStack;

    if ( pContext->pSyntaxInfo == NULL )
        pContext->DceTypeFormatString = pStubDesc->pFormatTypes;
    else
        pContext->DceTypeFormatString = pContext->pSyntaxInfo->TypeString;

    if ( ! pContext->HandleType )
    {
        //
        // For a handle_t parameter we must pass the handle field of
        // the RPC message to the server manager.
        //
        if ( *pContext->pHandleFormatSave == FC_BIND_PRIMITIVE )
        {
            pArg = pArgBuffer + *((ushort *)&pContext->pHandleFormatSave[2]);

            if ( IS_HANDLE_PTR(pContext->pHandleFormatSave[1]) )
                pArg = *((uchar **)pArg);

            *((handle_t *)pArg) = pRpcMsg->Handle;
        }
    }

    //
    // If OLE, put pThis in first dword of stack.
    //
    if ( pThis )
    {
        *((void **)pArgBuffer) =
            (void *)((CStdStubBuffer *)pThis)->pvServerObject;
    }

    //
    // Initialize the Stub message.
    //
    if ( ! pChannel )
        {
        if ( ! pContext->NdrInfo.pProcDesc->Oi2Flags.HasPipes )
           {
            NdrServerInitializeNew( pRpcMsg,
                                    pStubMsg,
                                    pStubDesc );
           }
        else
            NdrServerInitializePartial( pRpcMsg,
                                        pStubMsg,
                                        pStubDesc,
                                        pContext->NdrInfo.pProcDesc->ClientBufferSize );
        }
    else
        {
        // pipe is not supported in obj interface.
        NDR_ASSERT( ! pContext->HasPipe, "Pipe is not supported in dcom" );
        NdrStubInitialize( pRpcMsg,
                           pStubMsg,
                           pStubDesc,
                           pChannel );
        }

    if ( pAsyncMsg )
        {
        pStubMsg->pAsyncMsg = pAsyncMsg;
        pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;
        }

    if ( pContext->NdrInfo.InterpreterFlags.FullPtrUsed )
        pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );
    else
        pStubMsg->FullPtrXlatTables = NULL;


        //
        // Set StackTop AFTER the initialize call, since it zeros the field
        // out.
        //
        pStubMsg->StackTop = pArgBuffer;

        if ( pContext->NdrInfo.pProcDesc->Oi2Flags.HasPipes )
            {
            NdrpPipesInitialize32( pStubMsg,
                                   &pContext->AllocateContext,
                                   (PFORMAT_STRING) pContext->Params,
                                   (char*)pArgBuffer,
                                   pContext->NumberParams );

            }

        //
        // We must make this check AFTER the call to ServerInitialize,
        // since that routine puts the stub descriptor alloc/dealloc routines
        // into the stub message.
        //
        if ( pContext->NdrInfo.InterpreterFlags.RpcSsAllocUsed )
            NdrRpcSsEnableAllocate( pStubMsg );

        if ( pContext->NdrInfo.pProcDesc->Oi2Flags.HasExtensions )
            {
            pStubMsg->fHasExtensions  = 1;
            pStubMsg->fHasNewCorrDesc = pContext->NdrInfo.pProcDesc->NdrExts.Flags2.HasNewCorrDesc;
            if ( pContext->NdrInfo.pProcDesc->NdrExts.Flags2.ServerCorrCheck )
                {

                void * pCorr = NdrpAlloca( &pContext->AllocateContext, NDR_DEFAULT_CORR_CACHE_SIZE );
                NdrCorrelationInitialize( pStubMsg,
                                          pCorr,
                                          NDR_DEFAULT_CORR_CACHE_SIZE,
                                          0  /* flags */ );
                }
            }

}


void NdrpServerOutInit( PMIDL_STUB_MESSAGE pStubMsg )
{
    ulong n;
    NDR_PROC_CONTEXT   *    pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION      Params = ( PPARAM_DESCRIPTION ) pContext->Params;
    PFORMAT_STRING          pFormatTypes = pContext->DceTypeFormatString;
    uchar *                 pArgBuffer = pContext->StartofStack;
    uchar *                 pArg;
    PFORMAT_STRING          pFormatParam;

        for ( n = 0; n < pContext->NumberParams; n++ )
            {

            if ( !Params[n].ParamAttr.IsPartialIgnore )
                {
                if ( Params[n].ParamAttr.IsIn     ||
                     ( Params[n].ParamAttr.IsReturn && !pContext->HasComplexReturn  ) ||
                     Params[n].ParamAttr.IsPipe  )
                    continue;

                pArg = pArgBuffer + Params[n].StackOffset;
                }
            else
                {
                pArg = pArgBuffer + Params[n].StackOffset;

                if ( !*(void**)pArg )
                    continue;

                }

            //
            // Check if we can initialize this parameter using some of our
            // stack.
            //
            if ( Params[n].ParamAttr.ServerAllocSize != 0 )
                {
                *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext,
                                              Params[n].ParamAttr.ServerAllocSize * 8);

                MIDL_memset( *((void **)pArg),
                             0,
                             Params[n].ParamAttr.ServerAllocSize * 8 );
                continue;
                }
            else if ( Params[n].ParamAttr.IsBasetype )
                {
                *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext, 8 ); 
                MIDL_memset( *((void **)pArg), 0, 8 );
                continue;
                };

            pFormatParam = pFormatTypes + Params[n].TypeOffset;

            NdrOutInit( pStubMsg,
                        pFormatParam,
                        (uchar **)pArg );
            }


}

#if defined( BUILD_NDR64 )
BOOL IsServerSupportNDR64( MIDL_SERVER_INFO *pServerInfo )
{
    if ( ( pServerInfo->pStubDesc->Version > NDR_VERSION ) ||
         ( pServerInfo->pStubDesc->Version < NDR_VERSION_6_0 ) ||
         ( pServerInfo->pStubDesc->MIDLVersion < MIDL_VERSION_6_0_322 ) ||
         ! ( pServerInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES ) )
        return FALSE;
    return TRUE;


}
#endif

RPC_STATUS RPC_ENTRY
NdrClientGetSupportedSyntaxes(
    IN RPC_CLIENT_INTERFACE * pInf,
    OUT ulong * pCount,
    MIDL_SYNTAX_INFO ** pArr )
{
    MIDL_SYNTAX_INFO *pSyntaxInfo;

    NDR_ASSERT( pInf->Flags & RPCFLG_HAS_MULTI_SYNTAXES, "invalid clientif" );
    if ( pInf->Flags & RPCFLG_HAS_CALLBACK )
        {
        // interpreter info is  MIDL_SERVER_INFO
        MIDL_SERVER_INFO * pServerInfo = ( MIDL_SERVER_INFO *) pInf->InterpreterInfo;
        *pCount = ( ulong ) pServerInfo->nCount ;
        *pArr = pServerInfo->pSyntaxInfo;
        }
    else
        {
        MIDL_STUBLESS_PROXY_INFO * pProxyInfo = ( MIDL_STUBLESS_PROXY_INFO *) pInf->InterpreterInfo;
        *pCount = ( ulong ) pProxyInfo->nCount ;
        *pArr = pProxyInfo->pSyntaxInfo;
        }

    return RPC_S_OK;

}

RPC_STATUS RPC_ENTRY
NdrServerGetSupportedSyntaxes(
    IN RPC_SERVER_INTERFACE * pInf,
    OUT ulong * pCount,
    MIDL_SYNTAX_INFO ** pArr,
    OUT ulong * pPrefer)
{
    NDR_ASSERT( pInf->Flags & RPCFLG_HAS_MULTI_SYNTAXES,"invalid serverif" );
    MIDL_SERVER_INFO *pServerInfo = ( MIDL_SERVER_INFO *) pInf->InterpreterInfo;
    *pCount = ( ulong ) pServerInfo->nCount;
    *pArr = pServerInfo->pSyntaxInfo;
    NdrpGetPreferredSyntax( ( ulong )pServerInfo->nCount, pServerInfo->pSyntaxInfo, pPrefer );
    return RPC_S_OK;
}

RPC_STATUS RPC_ENTRY
NdrCreateServerInterfaceFromStub(
            IN IRpcStubBuffer* pStub,
            IN OUT RPC_SERVER_INTERFACE *pServerIf )
{
#if !defined( BUILD_NDR64 )
    return S_OK;
#else
    CInterfaceStubVtbl *    pStubVTable;
    PMIDL_SERVER_INFO       pServerInfo;
    IRpcStubBuffer *        pv = NULL;
    RpcTryExcept
        {
        // filter out non-ndr stub first.
        if ( S_OK != pStub->lpVtbl->QueryInterface(pStub, IID_IPrivStubBuffer, (void **)& pv ) )
            return S_OK;

        pv->lpVtbl->Release(pv);

        pStubVTable = (CInterfaceStubVtbl *)
                  (*((uchar **)pStub) - sizeof(CInterfaceStubHeader));

        pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

        // In /Os mode, we don't have pServerInfo.
        if ( pServerInfo &&
             IsServerSupportNDR64( pServerInfo ) )
            {
            memcpy ( &pServerIf->TransferSyntax, pServerInfo->pTransferSyntax, sizeof( RPC_SYNTAX_IDENTIFIER ) );
            pServerIf->Flags |= RPCFLG_HAS_MULTI_SYNTAXES;
            pServerIf->InterpreterInfo = pServerInfo;
            }
        }
    RpcExcept( 1 )
        {
        }
    RpcEndExcept
#endif

    return S_OK;
}



/*++

Routine Description :

    Read the proc header for different transfer syntax.
    We need to return proc number in dce because for stubs compiled with
    DCE only, proc header is the only place to get the procnum.

    This rountine being called from both client and server. The difference
    is that client side we are reading from the default one; server side we
    are reading from the selected one.
Arguments :


Return :

    none.   Raise exception if something goes wrong. We can't recovered
    from here because we don't have enough information about how the
    stub looks like if we don't have valid proc header.

--*/

ulong RPC_ENTRY
MulNdrpInitializeContextFromProc (
                          SYNTAX_TYPE            SyntaxType,
                          PFORMAT_STRING         pFormat,
                          NDR_PROC_CONTEXT  *    pContext,
                          uchar *                StartofStack,
                          BOOLEAN                IsReset )
{
    ulong                               RpcFlags;
    ulong                               ProcNum = 0;

    if ( !IsReset )
        NdrpInitializeProcContext( pContext );

    pContext->pProcFormat  = pFormat;
    pContext->StartofStack = StartofStack;


    if ( SyntaxType ==  XFER_SYNTAX_DCE )
        {
        PPARAM_DESCRIPTION          Params;
        INTERPRETER_FLAGS           InterpreterFlags;
        PFORMAT_STRING              pNewProcDescr;
        INTERPRETER_OPT_FLAGS       OptFlags;

        pContext->CurrentSyntaxType = XFER_SYNTAX_DCE;

        pContext->HandleType = *pFormat++ ;
        pContext->UseLocator = (FC_AUTO_HANDLE == pContext->HandleType);

        pContext->NdrInfo.InterpreterFlags = *((PINTERPRETER_FLAGS)pFormat++);

        InterpreterFlags = pContext->NdrInfo.InterpreterFlags;

        if ( InterpreterFlags.HasRpcFlags )
            RpcFlags = *(( UNALIGNED ulong* &)pFormat)++;
        else
            RpcFlags = 0;

        ProcNum   = *(ushort *)pFormat; pFormat += 2;
        pContext->StackSize = *(ushort *)pFormat; pFormat += 2;

        pContext->pHandleFormatSave = pFormat;

        pNewProcDescr = pFormat;

        if ( ! pContext->HandleType )
            {
            // explicit handle

            pNewProcDescr += ((*pFormat == FC_BIND_PRIMITIVE) ?  4 :  6);
            }

        pContext->NdrInfo.pProcDesc = (NDR_PROC_DESC *)pNewProcDescr;

        OptFlags = ( (NDR_PROC_DESC *)pNewProcDescr )->Oi2Flags;

        pContext->NumberParams = pContext->NdrInfo.pProcDesc->NumberParams;

        //
        // Parameter descriptions are nicely spit out by MIDL.
        // If there is no extension, Params is in the position of extensions.
        //
        Params = (PPARAM_DESCRIPTION) &( pContext->NdrInfo.pProcDesc->NdrExts );


        // Proc header extentions, from NDR ver. 5.2.
        // Params must be set correctly here because of exceptions.

        if ( OptFlags.HasExtensions )
            {
            pContext->HasComplexReturn = pContext->NdrInfo.pProcDesc->NdrExts.Flags2.HasComplexReturn;

            Params = (PPARAM_DESCRIPTION)((uchar*)Params + pContext->NdrInfo.pProcDesc->NdrExts.Size);
#if defined(_AMD64_) || defined(_IA64_)
            PNDR_PROC_HEADER_EXTS64 pExts = (PNDR_PROC_HEADER_EXTS64 )&pContext->NdrInfo.pProcDesc->NdrExts;

            pContext->FloatDoubleMask = pExts->FloatArgMask;
#endif // defined(_AMD64_) || defined(_IA64_)

            }

        pContext->Params = Params;

        pContext->IsAsync = OptFlags.HasAsyncUuid ;
        pContext->IsObject = InterpreterFlags.ObjectProc;
        pContext->HasPipe = OptFlags.HasPipes;

        pContext->ExceptionFlag = ! ( InterpreterFlags.IgnoreObjectException ) &&
                                  ( pContext->IsObject || InterpreterFlags.HasCommOrFault );           
        }   // XFER_SYNTAX_DCE

#if defined(BUILD_NDR64)

    else if ( SyntaxType == XFER_SYNTAX_NDR64  )
            {
            NDR64_PROC_FLAGS *  pProcFlags;

            pContext->CurrentSyntaxType = XFER_SYNTAX_NDR64;

            pContext->Ndr64Header = (NDR64_PROC_FORMAT *)pFormat;
            pContext->HandleType =
            NDR64MAPHANDLETYPE( NDR64GETHANDLETYPE( &pContext->Ndr64Header->Flags ) );
            pContext->UseLocator = (FC64_AUTO_HANDLE == pContext->HandleType);

            RpcFlags = pContext->Ndr64Header->RpcFlags;
#if defined(_AMD64_) || defined(_IA64_)

            pContext->FloatDoubleMask = pContext->Ndr64Header->FloatDoubleMask;
#endif // defined(_AMD64_) || defined(_IA64_)
            pContext->NumberParams = pContext->Ndr64Header->NumberOfParams;
            pContext->Params = (NDR64_PROC_FORMAT *)( (char *) pFormat + sizeof( NDR64_PROC_FORMAT ) + pContext->Ndr64Header->ExtensionSize );
            pContext->StackSize = pContext->Ndr64Header->StackSize;

            pProcFlags = (NDR64_PROC_FLAGS *) &pContext->Ndr64Header->Flags;

            pContext->HasComplexReturn = pProcFlags->HasComplexReturn;
            pContext->IsAsync = pProcFlags->IsAsync;
            pContext->IsObject = pProcFlags->IsObject;
            pContext->HasPipe = pProcFlags->UsesPipes;

            pContext->ExceptionFlag = pContext->IsObject || pProcFlags->HandlesExceptions;
            }   // XFER_SYNTAX_NDR64

#endif

    else
        NDR_ASSERT( 0, "Invalid transfer syntax.");

    // setup the pipe flag before negotiation.
    if ( pContext->HasPipe )
        {
        RpcFlags &= ~RPC_BUFFER_COMPLETE;
        RpcFlags |= RPC_BUFFER_PARTIAL;
        }

    pContext->RpcFlags = RpcFlags;
    // We need to cleanup the resend flag during initialization in preparation
    // for retry later.
    pContext->NeedsResend = FALSE;

    return ProcNum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\mrshlp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

	mrshlp.h

Abtract :
	
	Contains private definitions for mrshl.c.

Author : 
	
	David Kays	dkays 	September 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _MRSHLP_
#define _MRSHLP_

void 
NdrpPointerMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pBufferMark,
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpConformantArrayMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpConformantVaryingArrayMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpComplexArrayMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpConformantStringMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpUnionMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat,
	long						SwitchIs,
	uchar						SwitchType
	);

PFORMAT_STRING
NdrpEmbeddedPointerMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

PFORMAT_STRING 
NdrpEmbeddedRepeatPointerMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

ULONG_PTR
NdrpComputeConformance(
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpComputeVariance(
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

typedef uchar * (RPC_ENTRY * PMARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar *, 
					PFORMAT_STRING
				);

typedef void 	(* PPRIVATE_MARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar *, 
					PFORMAT_STRING
				);

//
// Function table defined in mrshl.c
//
IMPORTSPEC
extern const PMARSHALL_ROUTINE * pfnMarshallRoutines; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\ndrole.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    ndrole.h

Abstract:
    OLE routines for interface pointer marshalling.

Author:
    ShannonC    18-Apr-1994

Environment:
    Windows NT and Windows 95.

Revision History:

---------------------------------------------------------------------*/

#ifndef _NDROLE_
#define _NDROLE_


#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

// ProxyFile->TableVersion may be
//    1 for really old junk
//    2 since the time we defined new proxy and stub Buffer2 for delegation
//    6 for async uuid as we treat the previous values as flags.

#define NDR_PROXY_FILE_ASYNC_UUID   0x4

EXTERN_C IStream *__stdcall
NdrpCreateStreamOnMemory( unsigned char *pData, unsigned long cbSize );

// Note, both proxies and stubs have been remapped to the same size,
// as a preparation for some code simplifications.
// This means that some fields may not be used in some circumstances.

// Non-delegated proxy

typedef struct tagCStdProxyBuffer
{
    const struct IRpcProxyBufferVtbl *  lpVtbl;
    const void *                        pProxyVtbl; //Points to Vtbl in CInterfaceProxyVtbl
    long                                RefCount;
    struct IUnknown *                   punkOuter;
    struct IRpcChannelBuffer *          pChannel;
    struct IPSFactoryBuffer    *        pPSFactory; // endof old ProxyBuffer
    struct IRpcProxyBuffer *            Pad_pBaseProxyBuffer;
    struct IPSFactoryBuffer *           Pad_pPSFactory;
    IID                                 Pad_iidBase;
    const struct ICallFactoryVtbl  *    pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    const struct IReleaseMarshalBuffersVtbl  *    pRMBVtbl;
} CStdProxyBuffer;

// Delegated proxy

typedef struct tagCStdProxyBuffer2
{
    const struct IRpcProxyBufferVtbl *  lpVtbl;
    const void *                        pProxyVtbl; //Points to Vtbl in CInterfaceProxyVtbl
    long                                RefCount;
    struct IUnknown *                   punkOuter;
    struct IRpcChannelBuffer *          pChannel;
    struct IUnknown *                   pBaseProxy; // colides with pPSFactory
    struct IRpcProxyBuffer *            pBaseProxyBuffer;
    struct IPSFactoryBuffer *           pPSFactory;
    IID                                 iidBase;    // endof old ProxyBuffer2
    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    const struct IReleaseMarshalBuffersVtbl  *    pRMBVtbl;
} CStdProxyBuffer2;

// Async proxy buffer, one for delegated and non-delegated case.

typedef struct _NdrDcomAsyncFlags
{
    unsigned long                       AsyncMsgSet     : 1;
    unsigned long                       BeginStarted    : 1;
    unsigned long                       BeginDone       : 1;
    unsigned long                       FinishStarted   : 1;
    unsigned long                       FinishDone      : 1;
    unsigned long                       BeginError      : 1;
    unsigned long                       FinishError     : 1;
    unsigned long                       InvokeForwarded : 1;
    unsigned long                       Unused          :24;
} NdrDcomAsyncFlags;

typedef struct _CStdProxyBufferMap
{
    struct IUnknown *                   pBaseProxy;
} CStdProxyBufferMap;

typedef struct _NdrDcomAsyncCallState
{
    unsigned long                       Signature;
    unsigned long                       Lock;
    void *                              pAsyncMsg;
    NdrDcomAsyncFlags                   Flags;
    HRESULT                             Hr;
} NdrDcomAsyncCallState;

typedef struct tagCStdAsyncProxyBuffer
{
    const struct IRpcProxyBufferVtbl *  lpVtbl;
    const void *                        pProxyVtbl; //Points to Vtbl in CInterfaceProxyVtbl
    long                                RefCount;
    struct IUnknown *                   punkOuter;
    struct IRpcChannelBuffer *          pChannel;
    CStdProxyBufferMap                  map;        // the only colision 1<>2
    struct IRpcProxyBuffer *            pBaseProxyBuffer;
    struct IPSFactoryBuffer *           pPSFactory;
    IID                                 iidBase;
    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pSyncIID;  // points to sync iid in async
    // endof new ProxyBuffer,2 

    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
    NdrDcomAsyncCallState               CallState;

} CStdAsyncProxyBuffer;


// This definition is in rpcproxy.h because CStdStubBuffer::pvServerObject is called explicitly
// from /Os stub.
// It is reproduced here for convenience.
// It should be removed from there or may be left but a renamed clone  used internally.

#if 0
typedef struct tagCStdStubBuffer
{
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
} CStdStubBuffer;
#endif

// The plan to rewrite and colapse these structure does involve removing of the
// pvServerObject field completely.
// The channel would supply a pvServerObject pointer on the only call where
// this is really needed, that is on the Invoke call.
// In this model there would be no need whatsover for Connect and Disconnect operations
// on the stub object, both sync stubs and async stub call objects.


typedef struct tagCStdStubBuffer2
{
    const void *                        lpForwardingVtbl;
    struct IRpcStubBuffer *             pBaseStubBuffer;
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
} CStdStubBuffer2;

typedef struct tagCStdAsyncStubBuffer
{
    void *                              lpForwardingVtbl;
    struct IRpcStubBuffer *             pBaseStubBuffer;
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;

    const struct ISynchronizeVtbl *     pSynchronizeVtbl;

    NdrDcomAsyncCallState               CallState;

} CStdAsyncStubBuffer;



HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_QueryInterface(IRpcProxyBuffer *pThis,REFIID riid, void **ppv);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_AddRef(IRpcProxyBuffer *pThis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel);

void STDMETHODCALLTYPE
CStdProxyBuffer_Disconnect(IRpcProxyBuffer *pThis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_Release(IRpcProxyBuffer *pThis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel);

void STDMETHODCALLTYPE
CStdProxyBuffer2_Disconnect(IRpcProxyBuffer *pThis);


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_RMB_QueryInterface(IReleaseMarshalBuffers *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_RMB_AddRef(IReleaseMarshalBuffers *pthis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_RMB_Release(IReleaseMarshalBuffers *pthis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_RMB_ReleaseMarshalBuffer(IN IReleaseMarshalBuffers *This,RPCOLEMESSAGE * pMsg,DWORD dwFlags,IUnknown *pChnl);

HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_RMB_ReleaseMarshalBuffer(IN IReleaseMarshalBuffers *This,RPCOLEMESSAGE * pMsg,DWORD dwFlags,IUnknown *pChnl);


HRESULT STDMETHODCALLTYPE
IUnknown_QueryInterface_Proxy(
    IN  IUnknown *  This,
    IN  REFIID      riid,
    OUT void **     ppv);

ULONG STDMETHODCALLTYPE
IUnknown_AddRef_Proxy(
    IN  IUnknown *This);

ULONG STDMETHODCALLTYPE
IUnknown_Release_Proxy(
    IN  IUnknown *This);


HRESULT STDMETHODCALLTYPE
Forwarding_QueryInterface(
    IN  IUnknown *  This,
    IN  REFIID      riid,
    OUT void **     ppv);

ULONG STDMETHODCALLTYPE
Forwarding_AddRef(
    IN  IUnknown *This);

ULONG STDMETHODCALLTYPE
Forwarding_Release(
    IN  IUnknown *This);


void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD             * pdwStubPhase);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(IRpcStubBuffer *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(IRpcStubBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(IRpcStubBuffer *pthis, IUnknown *pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(IRpcStubBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(IRpcStubBuffer *pthis,RPCOLEMESSAGE *_prpcmsg,IRpcChannelBuffer *_pRpcChannelBuffer);

IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(IRpcStubBuffer *pthis,REFIID riid);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(IRpcStubBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(IRpcStubBuffer *pthis, void **ppv);

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(IRpcStubBuffer *pthis, void *pv);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_Connect(IRpcStubBuffer *pthis, IUnknown *pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer2_Disconnect(IRpcStubBuffer *pthis);

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_CountRefs(IRpcStubBuffer *pthis);

//  Async

extern const IRpcProxyBufferVtbl CStdAsyncProxyBufferVtbl;
extern const IRpcProxyBufferVtbl CStdAsyncProxyBuffer2Vtbl;

extern const IRpcStubBufferVtbl CStdAsyncStubBufferVtbl;
extern const IRpcStubBufferVtbl CStdAsyncStubBuffer2Vtbl;

extern const ISynchronizeVtbl CStdStubBuffer_ISynchronizeVtbl;
extern const ISynchronizeVtbl CStdStubBuffer2_ISynchronizeVtbl;

extern void * const ForwardingVtbl[];


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_CF_QueryInterface(ICallFactory *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_CF_AddRef(ICallFactory *pthis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_CF_Release(ICallFactory *pthis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_CF_CreateCall(ICallFactory *pthis, REFIID riid, IUnknown* punkOuter, REFIID riid2, IUnknown **ppvObject);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_CF_QueryInterface(ICallFactory *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_CF_AddRef(ICallFactory *pthis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_CF_Release(ICallFactory *pthis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_CF_CreateCall(ICallFactory *pthis, REFIID riid, IUnknown* punkOuter, REFIID riid2, IUnknown **ppvObject);


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_CF_QueryInterface(ICallFactory *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CF_AddRef(ICallFactory *pthis);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CF_Release(ICallFactory *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_CF_CreateCall(ICallFactory *pthis, REFIID riid, IUnknown* punkOuter, REFIID riid2, IUnknown **ppvObject);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_CF_QueryInterface(ICallFactory *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_CF_AddRef(ICallFactory *pthis);

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_CF_Release(ICallFactory *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_CF_CreateCall(ICallFactory *pthis, REFIID riid, IUnknown* punkOuter, REFIID riid2, IUnknown **ppvObject);


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_RMB_QueryInterface(IReleaseMarshalBuffers *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_RMB_AddRef(IReleaseMarshalBuffers *pthis);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_RMB_Release(IReleaseMarshalBuffers *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_RMB_ReleaseMarshalBuffer(IN IReleaseMarshalBuffers *This,RPCOLEMESSAGE * pMsg,DWORD dwFlags,IUnknown *pChnl);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_QueryInterface(IReleaseMarshalBuffers *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_AddRef(IReleaseMarshalBuffers *pthis);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_Release(IReleaseMarshalBuffers *pthis);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_ReleaseMarshalBuffer(IN IReleaseMarshalBuffers *This,RPCOLEMESSAGE * pMsg,DWORD dwFlags,IUnknown *pChnl);


HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_QueryInterface(IRpcProxyBuffer *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdAsyncProxyBuffer_Release(IRpcProxyBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel);

ULONG STDMETHODCALLTYPE
CStdAsyncProxyBuffer2_Release(IRpcProxyBuffer *pThis);

HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer2_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel);


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_QueryInterface(IRpcStubBuffer *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_AddRef(IRpcStubBuffer *pthis);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Release(IRpcStubBuffer *pthis);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Release(IRpcStubBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Connect(IRpcStubBuffer *pthis, IUnknown *pUnkServer);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Connect(IRpcStubBuffer *pthis, IUnknown *pUnkServer);

void STDMETHODCALLTYPE
CStdAsyncStubBuffer_Disconnect(IRpcStubBuffer *pthis );

void STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Disconnect(IRpcStubBuffer *pthis );

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Invoke(IRpcStubBuffer *pthis,RPCOLEMESSAGE *_prpcmsg,IRpcChannelBuffer *_pRpcChannelBuffer);


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_QueryInterface( ISynchronize *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_AddRef(ISynchronize *pthis);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Release(ISynchronize *pthis);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Wait( ISynchronize *pthis, DWORD dwFlags, DWORD mili );

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Signal( ISynchronize *pthis );

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Reset( ISynchronize *pthis );


HRESULT
NdrpAsyncProxySignal(
    CStdAsyncProxyBuffer * pAsyncPB );

HRESULT
NdrpAsyncProxyMsgConstructor(
    CStdAsyncProxyBuffer * pAsyncPB );

HRESULT
NdrpAsyncProxyMsgDestructor(
    CStdAsyncProxyBuffer * pAsyncPB );


HRESULT
NdrpAsyncStubMsgConstructor(
    CStdAsyncStubBuffer * pAsyncSB );

HRESULT
NdrpAsyncStubMsgDestructor(
    CStdAsyncStubBuffer * pAsyncSB );

HRESULT
NdrLoadOleRoutines();

typedef
HRESULT (STDAPICALLTYPE RPC_GET_CLASS_OBJECT_ROUTINE)(
    REFCLSID      rclsid,
    DWORD dwClsContext,
    void *pvReserved,
    REFIID riid,
    void **ppv);

typedef
HRESULT (STDAPICALLTYPE RPC_GET_MARSHAL_SIZE_MAX_ROUTINE)(
    ULONG *     pulSize,
    REFIID      riid,
    LPUNKNOWN   pUnk,
    DWORD       dwDestContext,
    LPVOID      pvDestContext,
    DWORD       mshlflags);

typedef
HRESULT (STDAPICALLTYPE RPC_MARSHAL_INTERFACE_ROUTINE)(
    LPSTREAM    pStm,
    REFIID      riid,
    LPUNKNOWN   pUnk,
    DWORD       dwDestContext,
    LPVOID      pvDestContext,
    DWORD       mshlflags);

typedef
HRESULT (STDAPICALLTYPE RPC_UNMARSHAL_INTERFACE_ROUTINE)(
    LPSTREAM    pStm,
    REFIID      riid,
    LPVOID FAR* ppv);

typedef
HRESULT (STDAPICALLTYPE RPC_STRING_FROM_IID)(
    REFIID rclsid,
    LPOLESTR FAR* lplpsz);

typedef
HRESULT (STDAPICALLTYPE RPC_GET_PS_CLSID)(
    REFIID iid,
    LPCLSID lpclsid);

typedef
HRESULT (STDAPICALLTYPE RPC_CO_CREATE_INSTANCE)(
    REFCLSID    rclsid,
    LPUNKNOWN   pUnkOuter,
    DWORD       dwClsContext,
    REFIID      riid,
    LPVOID *    ppv);

typedef
HRESULT (STDAPICALLTYPE RPC_CO_RELEASEMARSHALDATA)(
    IStream * pStm);

typedef
HRESULT (STDAPICALLTYPE RPC_DCOMCHANNELSETHRESULT)(
        PRPC_MESSAGE pmsg,
        ULONG * ulReserved,
        HRESULT appsHR );


extern  RPC_GET_CLASS_OBJECT_ROUTINE     *  pfnCoGetClassObject;
extern  RPC_GET_MARSHAL_SIZE_MAX_ROUTINE *  pfnCoGetMarshalSizeMax;
extern  RPC_MARSHAL_INTERFACE_ROUTINE    *  pfnCoMarshalInterface;
extern  RPC_UNMARSHAL_INTERFACE_ROUTINE  *  pfnCoUnmarshalInterface;
extern  RPC_STRING_FROM_IID              *  pfnStringFromIID;
extern  RPC_GET_PS_CLSID                 *  pfnCoGetPSClsid;
extern  RPC_CO_CREATE_INSTANCE           *  pfnCoCreateInstance;
extern  RPC_CO_RELEASEMARSHALDATA        *  pfnCoReleaseMarshalData;
extern  RPC_CLIENT_ALLOC                 *  pfnCoTaskMemAlloc;
extern  RPC_CLIENT_FREE                  *  pfnCoTaskMemFree;
extern  RPC_DCOMCHANNELSETHRESULT        *  pfnDcomChannelSetHResult;


HRESULT (STDAPICALLTYPE NdrStringFromIID)(
    REFIID rclsid,
    char * lplpsz);

//------------------------------------------------------------------------
// New async support
// -----------------------------------------------------------------------

void
NdrpAsyncProxyMgrConstructor(
    CStdAsyncProxyBuffer * pAsyncPB );

void
NdrpAsyncStubMgrConstructor(
    CStdAsyncStubBuffer * pAsyncSB );

HRESULT
NdrpAsyncStubSignal(
    CStdAsyncStubBuffer * pAsyncSB );


const IID * RPC_ENTRY
NdrGetProxyIID(
    IN  const void *pThis);


HRESULT NdrpClientReleaseMarshalBuffer(
        IReleaseMarshalBuffers * pRMB,
        RPC_MESSAGE *pRpcMsg,
        DWORD dwIOFlags,
        BOOLEAN fAsync);

HRESULT NdrpServerReleaseMarshalBuffer(
        IReleaseMarshalBuffers *pRMB,
        RPC_MESSAGE *pRpcMsg,
        DWORD dwIOFlags,
        BOOLEAN fAsync);

HRESULT Ndr64pReleaseMarshalBuffer( 
        PRPC_MESSAGE        pRpcMsg,
        PMIDL_SYNTAX_INFO   pSyntaxInfo,
        unsigned long       ProcNum,
        PMIDL_STUB_DESC     pStubDesc,
        DWORD               dwIOFlags,
        BOOLEAN             IsClient );

HRESULT 
NdrpInitializeMutex( I_RPC_MUTEX * pMutex );

EXTERN_C const IID IID_IPrivStubBuffer;
//--------------------
// HookOle Interface
//--------------------
EXTERN_C extern const IID IID_IPSFactoryHook;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IPSFactoryHook : public IPSFactoryBuffer
{
public:

    STDMETHOD (HkGetProxyFileInfo)
    (
        REFIID          riid,
        PINT            pOffset,
        PVOID           *ppProxyFileInfo
    )=0;
};
typedef IPSFactoryHook *PI_PSFACTORYHOOK;

#else   /* C Style Interface */

    typedef struct IPSFactoryHookVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( __stdcall *QueryInterface )(
            IPSFactoryBuffer *  This,
            /* [in] */ REFIID   riid,
            /* [out] */ void ** ppvObject);

        ULONG ( __stdcall *AddRef )(
            IPSFactoryBuffer *  This);

        ULONG ( __stdcall *Release )(
            IPSFactoryBuffer *  This);

        HRESULT ( __stdcall *CreateProxy )(
            IPSFactoryBuffer            *   This,
            /* [in] */ IUnknown         *   pUnkOuter,
            /* [in] */ REFIID               riid,
            /* [out] */ IRpcProxyBuffer **  ppProxy,
            /* [out] */ void            **  ppv);

        HRESULT ( __stdcall *CreateStub )(
            IPSFactoryBuffer            *   This,
            /* [in] */ REFIID               riid,
            /* [unique][in] */ IUnknown *   pUnkServer,
            /* [out] */ IRpcStubBuffer  **  ppStub);


        HRESULT ( __stdcall *HkGetProxyFileInfo )(
            IPSFactoryBuffer *  This,
            /* [in] */ REFIID   riid,
            /* [out]*/ PINT     pOffset,
            /* [out]*/ PVOID  * ppProxyFileInfo);

        END_INTERFACE
    } IPSFactoryHookVtbl;


    interface IPSFactoryHook
    {
        CONST_VTBL struct IPSFactoryHookVtbl *lpVtbl;
    };

typedef interface IPSFactoryHook *PI_PSFACTORYHOOK;

#ifdef COBJMACROS

#define IPSFactoryHook_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPSFactoryHook_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IPSFactoryHook_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IPSFactoryHook_CreateProxy(This,pUnkOuter,riid,ppProxy,ppv)   \
    (This)->lpVtbl -> CreateProxy(This,pUnkOuter,riid,ppProxy,ppv)

#define IPSFactoryHook_CreateStub(This,riid,pUnkServer,ppStub)    \
    (This)->lpVtbl -> CreateStub(This,riid,pUnkServer,ppStub)

#define IPSFactoryHook_HkGetProxyFileInfo(This,riid,pOffset,ppProxyFileInfo)    \
    (This)->lpVtbl -> HkGetProxyFileInfo(This,riid,pOffset,ppProxyFileInfo)

#endif /* COBJMACROS */


#endif  /* C style interface */
//-------------------------
// End - HookOle Interface
//-------------------------

#ifdef __cplusplus
}
#endif

#endif /* _NDROLE_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\mulsyntx.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    srvcall.c

Abstract :

    This file contains multiple transfer syntaxes negotiation related code

Author :

    Yong Qu    yongqu    September 1999. 

Revision History :


  ---------------------------------------------------------------------*/

#ifndef _MULSYNTX_H
#define _MULSYNTX_H
#include <stddef.h>

typedef struct _NDR_PROC_CONTEXT NDR_PROC_CONTEXT;
typedef struct _NDR_ALLOCA_CONTEXT NDR_ALLOCA_CONTEXT;

#ifdef __cplusplus
extern "C"
{
#endif
typedef void ( RPC_ENTRY * PFNMARSHALLING )( MIDL_STUB_MESSAGE *   pStubMsg,
                                  BOOL                   IsObject 
                                  );

typedef void ( RPC_ENTRY * PFNUNMARSHALLING ) 
              ( MIDL_STUB_MESSAGE *     pStubMsg,
                void *                  pReturnValue
                );

typedef void ( RPC_ENTRY * PFNINIT ) (MIDL_STUB_MESSAGE * pStubMsg,
                           void *              pReturnValue );

typedef void ( RPC_ENTRY * PFNSIZING ) (MIDL_STUB_MESSAGE *     pStubMsg,
             BOOL                   IsClient);

typedef unsigned char * ( RPC_ENTRY * PFNCLIENTGETBUFFER ) (MIDL_STUB_MESSAGE * pStubMsg );
                           
typedef void (* PFNGENERICUNBIND ) (
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    );

typedef unsigned char ( RPC_ENTRY * PFNGETBUFFER ) (
    PMIDL_STUB_MESSAGE      *       pStubMsg,
    unsigned    long                BufferLength );

typedef void ( RPC_ENTRY * PFNSENDRECEIVE ) (
    PMIDL_STUB_MESSAGE      *       pStubMsg );    
    
    
typedef void ( RPC_ENTRY *PFNCLIENT_EXCEPTION_HANDLING )
                 (  MIDL_STUB_MESSAGE  *    pStubMsg,
                    ulong                   ProcNum,
                    RPC_STATUS              ExceptionCode,
                    CLIENT_CALL_RETURN *    pReturnValue);

typedef VOID ( RPC_ENTRY *PFNCLIENTFINALLY )
                (   MIDL_STUB_MESSAGE   *   pStubMsg,
                    void *                  pThis );

// important! the vtbl sequence should match the fields in NDR_PROC_CONTEXT alwyas.
// we can't do anonymous structure in c++.
typedef struct _SYNTAX_DISPATCH_TABLE
{
    PFNINIT                         pfnInit;
    PFNSIZING                       pfnSizing;
    PFNMARSHALLING                  pfnMarshal;
    PFNUNMARSHALLING                pfnUnmarshal;
    PFNCLIENT_EXCEPTION_HANDLING    pfnExceptionHandling;
    PFNCLIENTFINALLY                pfnFinally;
//    PFNGETBUFFER                    pfnGetBuffer;
//    PFNSENDRECEIVE                  pfnSendReceive;
} SYNTAX_DISPATCH_TABLE;


typedef struct _NDR_PROC_DESC 
{
    unsigned short              ClientBufferSize;    // The Oi2 header
    unsigned short              ServerBufferSize;    //
    INTERPRETER_OPT_FLAGS       Oi2Flags;            //
    unsigned char               NumberParams;        //
    NDR_PROC_HEADER_EXTS        NdrExts;
} NDR_PROC_DESC;

typedef struct _NDR_PROC_INFO
{
    INTERPRETER_FLAGS           InterpreterFlags;
    NDR_PROC_DESC    *          pProcDesc;
} NDR_PROC_INFO;

#define NDR_ALLOCA_PREALLOCED_BLOCK_SIZE 512
#define NDR_ALLOCA_MIN_BLOCK_SIZE        4096

typedef struct _NDR_ALLOCA_CONTEXT {
  PBYTE pBlockPointer;
  LIST_ENTRY MemoryList;
  ULONG_PTR BytesRemaining;
#if defined(NDR_PROFILE_ALLOCA)
  SIZE_T AllocaBytes;
  SIZE_T AllocaAllocations;
  SIZE_T MemoryBytes;
  SIZE_T MemoryAllocations;
#endif
  BYTE PreAllocatedBlock[NDR_ALLOCA_PREALLOCED_BLOCK_SIZE];
} NDR_ALLOCA_CONTEXT, *PNDR_ALLOCA_CONTEXT;

// Simulated Alloca

VOID
NdrpAllocaInit(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    );

VOID
NdrpAllocaDestroy(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    );

PVOID
NdrpAlloca(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    UINT Size
    );

class NDR_POINTER_QUEUE_ELEMENT;
typedef struct _NDR_PROC_CONTEXT
{
    SYNTAX_TYPE CurrentSyntaxType;
    union {
        NDR_PROC_INFO               NdrInfo;
        NDR64_PROC_FORMAT *         Ndr64Header;
        } ;
    PFORMAT_STRING                  pProcFormat;        // proc format string.    
    ulong                           NumberParams;    
    void *                          Params;
    uchar *                         StartofStack;
    uchar                           HandleType;
    handle_t                        SavedGenericHandle;    
    PFORMAT_STRING                  pHandleFormatSave;
    PFORMAT_STRING                  DceTypeFormatString;
    ulong                           IsAsync     : 1;
    ulong                           IsObject    : 1;
    ulong                           HasPipe     : 1;
    ulong                           HasComplexReturn :1;
    ulong                           NeedsResend  : 1;
    ulong                           UseLocator   : 1;
    ulong                           Reserved7    :1 ;
    ulong                           Reserved8   : 1;
    ulong                           Reservedleft: 8;
    ulong                           FloatDoubleMask;
    ulong                           ResendCount;
    ulong                           RpcFlags;
    ulong                           ExceptionFlag;
    ulong                           StackSize;
    MIDL_SYNTAX_INFO           *    pSyntaxInfo;
    PFNINIT                         pfnInit;
    PFNSIZING                       pfnSizing;
    PFNMARSHALLING                  pfnMarshal;
    PFNUNMARSHALLING                pfnUnMarshal;
    PFNCLIENT_EXCEPTION_HANDLING    pfnExceptionHandling;
    PFNCLIENTFINALLY                pfnClientFinally;
    NDR_PIPE_DESC              *    pPipeDesc;
    NDR_POINTER_QUEUE_ELEMENT  *    pQueueFreeList;
    NDR_ALLOCA_CONTEXT              AllocateContext;
} NDR_PROC_CONTEXT;

extern uchar Ndr64HandleTypeMap[]; 

const extern RPC_SYNTAX_IDENTIFIER NDR_TRANSFER_SYNTAX;
const extern RPC_SYNTAX_IDENTIFIER NDR64_TRANSFER_SYNTAX;
const extern RPC_SYNTAX_IDENTIFIER FAKE_NDR64_TRANSFER_SYNTAX;

void
NdrServerSetupNDR64TransferSyntax(
    ulong                   ProcNum,
    MIDL_SYNTAX_INFO  *     pServerInfo,
    NDR_PROC_CONTEXT  *     pContext );

RPC_STATUS RPC_ENTRY
Ndr64ClientNegotiateTransferSyntax(
    void *                       pThis,
    MIDL_STUB_MESSAGE           *pStubMsg,
    MIDL_STUBLESS_PROXY_INFO    *pProxyInfo,
    NDR_PROC_CONTEXT            *pContext );

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall3(
    void *                      pThis,
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void                       *pReturnValue,
    NDR_PROC_CONTEXT        *   pContext,
    unsigned char *             StartofStack
    );

void RPC_ENTRY 
NdrpClientUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg,
                void  *                 pReturnValue );

void RPC_ENTRY 
NdrpServerUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg );


void RPC_ENTRY 
NdrpClientMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject );

void RPC_ENTRY 
NdrpServerMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject );


void RPC_ENTRY
NdrpClientInit( MIDL_STUB_MESSAGE * pStubMsg,
                           void *              pReturnValue );
                
void RPC_ENTRY 
Ndr64pClientUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg,
                void                *   pReturnValue  );

void RPC_ENTRY 
Ndr64pServerUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg  );


void RPC_ENTRY 
Ndr64pClientMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                    IsObject );

void RPC_ENTRY 
Ndr64pServerMarshal( MIDL_STUB_MESSAGE *    pStubMsg  );

void 
Ndr64pServerOutInit( PMIDL_STUB_MESSAGE pStubMsg );

void RPC_ENTRY
Ndr64pClientInit( MIDL_STUB_MESSAGE * pStubMsg,
                           void *              ReturnValue );


void RPC_ENTRY
NdrpClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );

void RPC_ENTRY
NdrpAsyncClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );

void RPC_ENTRY
NdrpDcomClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );

void RPC_ENTRY
NdrpNoopSizing( MIDL_STUB_MESSAGE *    pStubMsg,
            BOOL                   IsClient );

void RPC_ENTRY
NdrpSizing( MIDL_STUB_MESSAGE *     pStubMsg,
             BOOL                   IsClient );

void RPC_ENTRY
Ndr64pSizing( MIDL_STUB_MESSAGE *     pStubMsg,
             BOOL                   IsClient  );
                      
                      
void RPC_ENTRY
Ndr64pClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );
                
void RPC_ENTRY
Ndr64pDcomClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );
                

void RPC_ENTRY NdrpClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                                  void *  pThis );

void RPC_ENTRY Ndr64pClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                                    void *  pThis );
                       

typedef handle_t (* PFNEXPLICITBINDHANDLEMGR)(PMIDL_STUB_DESC   pStubDesc,
                                              uchar *           ArgPtr,
                                              PFORMAT_STRING    pFormat,
                                              handle_t *        pSavedGenericHandle); 

typedef handle_t (* PFNIMPLICITBINDHANDLEMGR)(PMIDL_STUB_DESC   pStubDesc,
                                              uchar             HandleType,
                                              handle_t *        pSavedGenericHandle); 

void RPC_ENTRY
Ndr64ClientInitializeContext(
    SYNTAX_TYPE                         SyntaxType,
    const MIDL_STUBLESS_PROXY_INFO *    pProxyInfo,
    ulong                               nProcNum,
    NDR_PROC_CONTEXT *                  pContext,
    uchar *                             StartofStack );

RPC_STATUS RPC_ENTRY
Ndr64pClientSetupTransferSyntax( void * pThis,
                           RPC_MESSAGE  *                   pRpcMsg,
                           MIDL_STUB_MESSAGE  *             pStubMsg,
                           MIDL_STUBLESS_PROXY_INFO *       ProxyInfo,
                           NDR_PROC_CONTEXT *               pContext,
                           ulong                            nProcNum );

HRESULT
MulNdrpBeginDcomAsyncClientCall(
                            MIDL_STUBLESS_PROXY_INFO    *     pProxyInfo,
                            ulong                             nProcNum,
                            NDR_PROC_CONTEXT *                pContext, 
                            void *                            StartofStack );
HRESULT
MulNdrpFinishDcomAsyncClientCall(
                            MIDL_STUBLESS_PROXY_INFO    *     pProxyInfo,
                            ulong                             nProcNum,
                            NDR_PROC_CONTEXT *                pContext,
                            void *                            StartofStack );

void Ndr64SetupClientSyntaxVtbl( PRPC_SYNTAX_IDENTIFIER pSyntax,
                                 NDR_PROC_CONTEXT     * pContext );


ulong RPC_ENTRY
MulNdrpInitializeContextFromProc ( 
                          SYNTAX_TYPE    SyntaxType,
                          PFORMAT_STRING         pFormat,
                          NDR_PROC_CONTEXT  *    pContext,
                          uchar *                StartofStack,
                          BOOLEAN                IsReset = FALSE );

RPC_STATUS RPC_ENTRY
Ndr64SetupServerContext ( NDR_PROC_CONTEXT  * pContext,
                          PFORMAT_STRING      pFormat );

/* rpcndr64.h */
BOOL NdrValidateServerInfo( MIDL_SERVER_INFO *pServerInfo );

void 
NdrpServerInit( PMIDL_STUB_MESSAGE   pStubMsg,
                RPC_MESSAGE *        pRpcMsg,
                PMIDL_STUB_DESC      pStubDesc,
                void *               pThis,
                IRpcChannelBuffer *  pChannel,
                PNDR_ASYNC_MESSAGE   pAsynMsg);

void NdrpServerOutInit( PMIDL_STUB_MESSAGE pStubMsg );


void RPC_ENTRY
Ndr64ProxyInitialize(
    IN  void * pThis,
    IN  PRPC_MESSAGE                    pRpcMsg,
    IN  PMIDL_STUB_MESSAGE              pStubMsg,
    IN  PMIDL_STUBLESS_PROXY_INFO       pProxyInfo,
    IN  unsigned int                    ProcNum );


__forceinline 
PFORMAT_STRING
NdrpGetProcString( PMIDL_SYNTAX_INFO pSyntaxInfo,
                   SYNTAX_TYPE SyntaxType,
                   ulong       nProcNum )
{
   if ( SyntaxType == XFER_SYNTAX_DCE )
      {
        unsigned long nFormatOffset;
        nFormatOffset = (pSyntaxInfo->FmtStringOffset)[nProcNum];
        return (PFORMAT_STRING) &pSyntaxInfo->ProcString[nFormatOffset];
      }
   else 
      {
      return ((PFORMAT_STRING*)(pSyntaxInfo->FmtStringOffset))[nProcNum];      
      }
}

__forceinline 
SYNTAX_TYPE NdrpGetSyntaxType( PRPC_SYNTAX_IDENTIFIER pSyntaxId )
{
    SYNTAX_TYPE SyntaxType = (SYNTAX_TYPE)( * (ulong *)pSyntaxId );
#if !defined( __RPC_WIN64__ ) 
    if ( SyntaxType == XFER_SYNTAX_TEST_NDR64 )
        SyntaxType = XFER_SYNTAX_NDR64;
#endif
//    NDR_ASSERT( SyntaxType == XFER_SYNTAX_NDR64 || SyntaxType == XFER_SYNTAX_DCE,
//                "invliad transfer syntax" );
    return SyntaxType ;

}

__forceinline void
NdrpInitializeProcContext( NDR_PROC_CONTEXT * pContext )
{
    memset( pContext, 0, offsetof( NDR_PROC_CONTEXT, AllocateContext ) );
    NdrpAllocaInit( & pContext->AllocateContext );
}
                                      
#define NDR64GETHANDLETYPE(x) ( ((NDR64_PROC_FLAGS *)x)->HandleType )
#define NDR64MAPHANDLETYPE(x) ( Ndr64HandleTypeMap[ x ] )

#define SAMEDIRECTION(flag , Param ) ( flag ? Param.ParamAttr.IsIn : Param.ParamAttr.IsOut )
#define NDR64SAMEDIRECTION( flag, pParamFlags ) ( flag ? pParamFlags->IsIn : pParamFlags->IsOut )

__forceinline
void NdrpGetPreferredSyntax( ulong nCount,
                             MIDL_SYNTAX_INFO * pSyntaxInfo,
                             ulong * pPrefer )
{
    pSyntaxInfo;
    // ndr64 is always the last one.
#if !defined(__RPC_WIN64__)
    *pPrefer = nCount - 1;
//    *pPrefer = 0; // should be 0 in 32bit. 
#else
    *pPrefer = nCount -1;
#endif 
}

#ifdef __cplusplus
}
#endif

#endif // _MULSYNTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\ndrp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993-2000 Microsoft Corporation

Module Name :

    ndrp.h

Abtract :

    Contains private definitions for Ndr files in this directory.  This
    file is included by all source files in this directory.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _NDRP_
#define _NDRP_

#include <sysinc.h>
#include "rpc.h"
#include "rpcndr.h"

// Get new token definitions for 64b.
#define RPC_NDR_64
#include "ndrtypes.h"
#include "ndr64types.h"

#include "ndrpall.h"


#ifdef   NDR_IMPORT_NDRP
#define  IMPORTSPEC EXTERN_C DECLSPEC_IMPORT
#else
#define  IMPORTSPEC EXTERN_C
#endif

#include "ndr64types.h"
#include "mrshlp.h"
#include "unmrshlp.h"
#include "bufsizep.h"
#include "memsizep.h"
#include "freep.h"
#include "endianp.h"
#include "fullptr.h"
#include "pipendr.h"
#include "mulsyntx.h"

long
NdrpArrayDimensions(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    BOOL                fIgnoreStringArrays
    );

long
NdrpArrayElements(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat
    );

void
NdrpArrayVariance(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long *              pOffset,
    long *              pLength
    );

PFORMAT_STRING
NdrpSkipPointerLayout(
    PFORMAT_STRING      pFormat
    );

long
NdrpStringStructLen(
    uchar *             pMemory,
    long                ElementSize
    );

void
NdrpCheckBound(
    ulong               Bound,
    int                 Type
    );

RPCRTAPI
void
RPC_ENTRY
NdrpRangeBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char *     pMemory,
    PFORMAT_STRING      pFormat
    );

void
NdrpRangeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass
    );

void RPC_ENTRY
NdrpRangeFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat
    );

unsigned long RPC_ENTRY
NdrpRangeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat );

unsigned char * RPC_ENTRY
NdrpRangeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat );

unsigned long
FixWireRepForDComVerGTE54(
    PMIDL_STUB_MESSAGE   pStubMsg );

RPC_STATUS
NdrpPerformRpcInitialization (
    void
    );

PVOID
NdrpPrivateAllocate(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    UINT Size 
    );

void
NdrpPrivateFree(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    void *pMemory 
    );

void
NdrpInitUserMarshalCB(
    MIDL_STUB_MESSAGE *pStubMsg,
    PFORMAT_STRING     pFormat,
    USER_MARSHAL_CB_TYPE CBType,
    USER_MARSHAL_CB   *pUserMarshalCB
    );

void  
NdrpCleanupServerContextHandles( 
    MIDL_STUB_MESSAGE *    pStubMsg,
    uchar *                pStartOfStack,
    BOOL                   fManagerRoutineException
    );



// Checking bounds etc.
// The bound value check below is independent of anything.

#define CHECK_BOUND( Bound, Type )  NdrpCheckBound( Bound, (int)(Type) )

// check for overflow when calculating the total size. 
ULONG MultiplyWithOverflowCheck( ULONG_PTR Count, ULONG_PTR ElemSize );



// These end of buffer checks can be performed on a receiving side only.
// The necessary setup is there for memorysize, unmarshal and convert walks.
// This also includes pickling walk.
// Don't use this on the sending side.

// Checks if the pointer is past the end of the buffer.  Do not check for wraparound.

#define CHECK_EOB_RAISE_BSD( p )                                      \
    {                                                                 \
       if( (uchar *)(p) > pStubMsg->BufferEnd )                       \
           {                                                          \
           RpcRaiseException( RPC_X_BAD_STUB_DATA );                  \
           }                                                          \
    }

#define CHECK_EOB_RAISE_IB( p )                                       \
    {                                                                 \
        if( (uchar *)(p) > pStubMsg->BufferEnd )                      \
            {                                                         \
            RpcRaiseException( RPC_X_INVALID_BOUND );                 \
            }                                                         \
    }

// Checks if p + incsize is past the end of the bufffer.
// Correctly handle wraparound.

#define CHECK_EOB_WITH_WRAP_RAISE_BSD( p, incsize )                   \
    {                                                                 \
        unsigned char *NewBuffer = ((uchar *)(p)) + (SIZE_T)(incsize);\
        if( (NewBuffer > pStubMsg->BufferEnd) || (NewBuffer < (p)) )  \
             {                                                        \
             RpcRaiseException( RPC_X_BAD_STUB_DATA );                \
             }                                                        \
    }

#define CHECK_EOB_WITH_WRAP_RAISE_IB( p, incsize )                    \
    {                                                                 \
        unsigned char *NewBuffer = ((uchar *)(p)) + (SIZE_T)(incsize);\
        if(  (NewBuffer > pStubMsg->BufferEnd) || (NewBuffer < (p)) ) \
             {                                                        \
             RpcRaiseException( RPC_X_INVALID_BOUND );                \
             }                                                        \
    }

                                                     

#define CHECK_ULONG_BOUND( v )   if ( 0x80000000 & (unsigned long)(v) ) \
                                        RpcRaiseException( RPC_X_INVALID_BOUND );

#define REUSE_BUFFER(pStubMsg) (! pStubMsg->IsClient)

// This would be appropriate on the sending side for marshaling.

#define CHECK_SEND_EOB_RAISE_BSD( p )  \
        if ( pStubMsg->RpcMsg->Buffer + pStubMsg->RpcMsg->BufferLength < p ) \
            RpcRaiseException( RPC_X_BAD_STUB_DATA )

#define NdrpComputeSwitchIs( pStubMsg, pMemory, pFormat )   \
            NdrpComputeConformance( pStubMsg,   \
                                    pMemory,    \
                                    pFormat )

#define NdrpComputeIIDPointer( pStubMsg, pMemory, pFormat )   \
            NdrpComputeConformance( pStubMsg,   \
                                    pMemory,    \
                                    pFormat )

//
// Defined in global.c
//
IMPORTSPEC extern const unsigned char SimpleTypeAlignment[];
IMPORTSPEC extern const unsigned char SimpleTypeBufferSize[];
IMPORTSPEC extern const unsigned char SimpleTypeMemorySize[];
IMPORTSPEC extern const unsigned long NdrTypeFlags[];

#if defined(__RPC_WIN64__)
#define PTR_WIRE_REP(p)  (ulong)(p ? ( PtrToUlong( p ) | 0x80000000) : 0)
#else
#define PTR_WIRE_REP(p)  (ulong)p
#endif

//
// Proc info flags macros.
//
#define IS_OLE_INTERFACE(Flags)         ((Flags) & Oi_OBJECT_PROC)

#define HAS_RPCFLAGS(Flags)             ((Flags) & Oi_HAS_RPCFLAGS)

#define DONT_HANDLE_EXCEPTION(Flags)    \
                    ((Flags) & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING)


//
// Routine index macro.
//
#define ROUTINE_INDEX(FC)       ((FC) & 0x3F)

#include <ndrmisc.h>

//
// Union hack helper. (used to be MAGIC_UNION_BYTE 0x80)
//
#define IS_MAGIC_UNION_BYTE(pFmt) \
    ((*(unsigned short *)pFmt & (unsigned short)0xff00) == MAGIC_UNION_SHORT)

// User marshal marker on wire.

#define USER_MARSHAL_MARKER     0x72657355


#define BOGUS_EMBED_CONF_STRUCT_FLAG     ( ( unsigned char ) 0x01 )

// compute buffer size for the pointees of a complex struct or complex array
// specifically excluding the flat parts.
#define POINTEE_BUFFER_LENGTH_ONLY_FLAG  ( ( unsigned char ) 0x02 )
#define TOPMOST_CONF_STRUCT_FLAG         ( ( unsigned char ) 0x04 )
#define REVERSE_ARRAY_MARSHALING_FLAG    ( ( unsigned char ) 0x08 )
#define WALKIP_FLAG                      ( ( unsigned char ) 0x10 )
#define BROKEN_INTERFACE_POINTER_FLAG    ( ( unsigned char ) 0x20 )
#define SKIP_REF_CHECK_FLAG              ( ( unsigned char ) 0x40 )


#define IS_EMBED_CONF_STRUCT( f )     ( ( f ) & BOGUS_EMBED_CONF_STRUCT_FLAG )
#define SET_EMBED_CONF_STRUCT( f )     ( f ) |= BOGUS_EMBED_CONF_STRUCT_FLAG
#define RESET_EMBED_CONF_STRUCT( f )   ( f ) &= ~BOGUS_EMBED_CONF_STRUCT_FLAG

#define COMPUTE_POINTEE_BUFFER_LENGTH_ONLY( Flags )          ( ( Flags ) & POINTEE_BUFFER_LENGTH_ONLY_FLAG )
#define SET_COMPUTE_POINTEE_BUFFER_LENGTH_ONLY( Flags )      ( ( Flags ) |= POINTEE_BUFFER_LENGTH_ONLY_FLAG )
#define RESET_COMPUTE_POINTEE_BUFFER_LENGTH_ONLY( Flags )    ( ( Flags ) &= ~POINTEE_BUFFER_LENGTH_ONLY_FLAG )

#define IS_TOPMOST_CONF_STRUCT( f )       ( ( f ) & TOPMOST_CONF_STRUCT_FLAG )
#define SET_TOPMOST_CONF_STRUCT( f )      ( ( f ) |= TOPMOST_CONF_STRUCT_FLAG )
#define RESET_TOPMOST_CONF_STRUCT( f )    ( ( f ) &= ~TOPMOST_CONF_STRUCT_FLAG )

#define IS_CONF_ARRAY_DONE( f )      ( ( f ) & REVERSE_ARRAY_MARSHALING_FLAG )
#define SET_CONF_ARRAY_DONE( f )     ( ( f ) |= REVERSE_ARRAY_MARSHALING_FLAG )
#define RESET_CONF_ARRAY_DONE( f )   ( ( f ) &= ~REVERSE_ARRAY_MARSHALING_FLAG )

#define IS_WALKIP( f )    ( ( f ) & WALKIP_FLAG )
#define SET_WALKIP( f )   ( ( f ) |= WALKIP_FLAG )
#define RESET_WALKIP( f ) ( ( f ) &= ~WALKIP_FLAG )

#define IS_SKIP_REF_CHECK( f ) ( ( f ) & SKIP_REF_CHECK_FLAG )
#define SET_SKIP_REF_CHECK( f ) ( ( f ) |= SKIP_REF_CHECK_FLAG )
#define RESET_SKIP_REF_CHECK( f ) ( ( f ) &= ~SKIP_REF_CHECK_FLAG )


#define IS_BROKEN_INTERFACE_POINTER( f )    ( ( f ) & BROKEN_INTERFACE_POINTER_FLAG )
#define SET_BROKEN_INTERFACE_POINTER( f )   ( ( f ) |= BROKEN_INTERFACE_POINTER_FLAG )
#define RESET_BROKEN_INTERFACE_POINTER( f ) ( ( f ) &= ~BROKEN_INTERFACE_POINTER_FLAG )

#define RESET_CONF_FLAGS_TO_STANDALONE( f )  (f) &= ~( BOGUS_EMBED_CONF_STRUCT_FLAG | \
                                                       TOPMOST_CONF_STRUCT_FLAG |     \
                                                       REVERSE_ARRAY_MARSHALING_FLAG )

//
// Environment dependent macros
//

#define SIMPLE_TYPE_BUF_INCREMENT(Len, FC)      Len += 16

#define EXCEPTION_FLAG  \
            ( (!(RpcFlags & RPCFLG_ASYNCHRONOUS)) &&        \
              (!InterpreterFlags.IgnoreObjectException) &&  \
              (StubMsg.dwStubPhase != PROXY_SENDRECEIVE) )



#endif // _NDRP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\pipendr.h ===
/************************************************************************

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    pipendr.h

Abstract :

    NDR Pipe related definitions.

Author :

    RyszardK       December 1995

Revision History :

  ***********************************************************************/

#ifndef _PIPENDR_H_
#define _PIPENDR_H_

#include "interp2.h"

typedef struct _NDR_PIPE_DESC * PNDR_PIPE_DESC;


#define PIPE_PARTIAL_BUFFER_SIZE   5000
#define PIPE_ELEM_BUFFER_SIZE      5000
//                  
// Signature and version
//

#define NDR_PIPE_SIGNATURE          (ushort) 0x5667
#define NDR_PIPE_VERSION            (short)  0x3031

//
// Pipe flags
//

#define NDR_IN_PIPE                 0x0001
#define NDR_OUT_PIPE                0x0002
#define NDR_LAST_IN_PIPE            0x0004
#define NDR_LAST_OUT_PIPE           0x0008
#define NDR_OUT_ALLOCED             0x0010
#define NDR_REF_PIPE                0x0020

//
// Pipe Status - global state for individual pipes in the pipe message.
//

typedef enum {
    NDR_PIPE_NOT_OPENED,
    NDR_PIPE_ACTIVE_IN,
    NDR_PIPE_ACTIVE_OUT,
    NDR_PIPE_DRAINED
    } NDR_PIPE_STATUS;


#define PLONG_LV_CAST        *(long * *)&
#define PULONG_LV_CAST       *(ulong * *)&

#define WIRE_PAD(size, al)   ((((ulong)size)&al) ? ((ulong)(al+1)-(((ulong)size)&al)) : 0)

#define REMAINING_BYTES() ((long)pStubMsg->RpcMsg->BufferLength - \
                           (long)(pStubMsg->Buffer - (uchar*)pStubMsg->RpcMsg->Buffer))

// These are the states of the state machine processing the chunks
// in the marshaling buffer.

typedef enum {
    START,
    COPY_PIPE_ELEM,
    RETURN_PARTIAL_ELEM,
    READ_PARTIAL_ELEM,
    VERIFY_TAIL_CHUNK
    } RECEIVE_STATES;


typedef struct _FC_PIPE_DEF
    {
    unsigned char   Fc;

    unsigned char   Align      : 4;     //
    unsigned char   Unused     : 1;     //  Flag and alignment byte
    unsigned char   HasRange   : 1;     // 
    unsigned char   ObjectPipe : 1;     //
    unsigned char   BigPipe    : 1;     //

    short           TypeOffset;
    union
        {
        struct
            {
            unsigned short  MemSize;
            unsigned short  WireSize;
            unsigned long   LowChunkLimit;
            unsigned long   HighChunkLimit;
            } s;
        struct
            {
            unsigned long   MemSize;
            unsigned long   WireSize;
            unsigned long   LowChunkLimit;
            unsigned long   HighChunkLimit;
            } Big;
        };
    } FC_PIPE_DEF;

//
// The NDR_PIPE_*_RTN are templates for the DCE raw runtime routines.
// This should be moved to rpcndr.h when we decide to expose -Os stubs.
//

typedef void
(__RPC_API * NDR_PIPE_PULL_RTN)(
        char          *  state,
        void          *  buf,
        unsigned long    esize,
        unsigned long *  ecount );

typedef  void
(__RPC_API * NDR_PIPE_PUSH_RTN)(
        char          *  state,
        void          *  buf,
        unsigned long    ecount );

typedef void
(__RPC_API * NDR_PIPE_ALLOC_RTN)(
        char             *  state,
        unsigned long       bsize,
        void             ** buf,
        unsigned long    *  bcount );

//
// The NDR_HR_PIPE_*_RTN are templates abstracting DCOM pipe routines 
// and also async raw pipe routine - note that there is an error code returned.
//

typedef RPC_STATUS
(__RPC_API * NDR_HR_PIPE_PULL_RTN)(
        char          *  state,
        void          *  buf,
        unsigned long    esize,
        unsigned long *  ecount );

typedef  RPC_STATUS
(__RPC_API * NDR_HR_PIPE_PUSH_RTN)(
        char          *  state,
        void          *  buf,
        unsigned long    ecount );

typedef RPC_STATUS
(__RPC_API * NDR_HR_PIPE_ALLOC_RTN)(
        char             *  state,
        unsigned long       bsize,
        void             ** buf,
        unsigned long    *  bcount );


typedef struct  _GENERIC_PIPE_TYPE
    {
    NDR_HR_PIPE_PULL_RTN       pfnPull;
    NDR_HR_PIPE_PUSH_RTN       pfnPush;
    NDR_HR_PIPE_ALLOC_RTN      pfnAlloc;
    char  *                    pState;
    } GENERIC_PIPE_TYPE;


#define NDR_DEFAULT_PIPE_HIGH_CHUNK_LIMIT   0x0ffffff /* less than 2GB */

typedef struct {
    int                 CurrentState;
    int                 TotalElemsCount;
    int                 OrigElemsInChunk;
    int                 ElemsInChunk;
    int                 ElemAlign;          
    int                 ElemWireSize;         
    int                 ElemMemSize;
    int                 PartialBufferSize;
    unsigned char *     PartialElem;
    int                 PartialElemSize;
    int                 PartialOffset;
    int                 EndOfPipe : 1;
    int                 EndOfPipePending : 1;
    int                 LowChunkLimit;
    int                 HighChunkLimit;
    BOOL                fBlockCopy;
    int                 ElemPad;
    PFORMAT_STRING      TypeFormat;
    } NDR_PIPE_STATE;

typedef enum _NDR_DCOM_PIPE_STATE 
    {
     NDR_DCOM_NO_PIPES,
     NDR_DCOM_IN_PIPE_PROCESSING,
     NDR_DCOM_IN_PIPES_DRAINED,
     NDR_DCOM_OUT_PIPE_PROCESSING,
     NDR_DCOM_OUT_PIPES_DRAINED,
     NDR_DCOM_PIPES_DONE,
     NDR_DCOM_PIPE_ERROR
    } NDR_DCOM_PIPE_STATE;

typedef struct  _NDR_PIPE_MESSAGE
    {
    unsigned short          Signature;
    unsigned short          PipeId;
    unsigned short          PipeStatus;
    unsigned short          PipeFlags;
    PFORMAT_STRING          pTypeFormat;
    PMIDL_STUB_MESSAGE      pStubMsg;
    GENERIC_PIPE_TYPE    *  pPipeObject;
    } NDR_PIPE_MESSAGE, * PNDR_PIPE_MESSAGE;

//
// Flags helping with the buffer management at the server.
// [in] pipes need to be processed within a separate in buffer.
// This buffer needs to be freed after last [in] pipe.
// [out] pipe processing has to start with a partial RpcGetBuffer.
// Nothing needs to be done with that buffer before return to runtime.
//

typedef struct  _PIPEDESC_FLAGS
    {
    unsigned short          AuxOutBufferAllocated : 1;
    unsigned short          NoBufferCallPending   : 1;
    unsigned short          Reserved              : 1;
    unsigned short          NoMoreBuffersToRead   : 1;
    } PIPEDESC_FLAGS;

#ifdef __cplusplus

class NDR_PIPE_HELPER
{

public:
    // Init functions
    virtual PNDR_PIPE_DESC GetPipeDesc() = 0;

    // Parameter enum functions
    virtual bool InitParamEnum() = 0;
    virtual bool GotoNextParam() = 0;
    virtual unsigned short GetParamPipeFlags() = 0;
    virtual PFORMAT_STRING GetParamTypeFormat() = 0;
    virtual char *GetParamArgument() = 0;

    // Pipe State
    virtual void InitPipeStateWithType( PNDR_PIPE_MESSAGE pPipeMsg) = 0;
    
    // Marshall Unmarshall Functions.
    virtual void MarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                               uchar *pMemory,
                               unsigned long Elements ) = 0;
    virtual void UnmarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements ) = 0;
    virtual void BufferSizeType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements ) = 0;
    virtual void ConvertType( PNDR_PIPE_MESSAGE pPipeMsg,
                              unsigned long Elements ) = 0;

    virtual void BufferSizeChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg ) = 0;

    virtual bool UnmarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong *pOut ) = 0;

    virtual void MarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                       ulong Counter ) = 0;

    virtual void BufferSizeChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg ) = 0;

    virtual void MarshallChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                           ulong Counter ) = 0;

    virtual bool VerifyChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong HeaderCounter ) = 0;
    virtual bool HasChunkTailCounter() = 0;

};

typedef NDR_PIPE_HELPER *PNDR_PIPE_HELPER;

#else // #ifdef __cplusplus

typedef void *PNDR_PIPE_HELPER;

#endif

typedef struct _NDR_ALLOCA_CONTEXT *PNDR_ALLOCA_CONTEXT;

typedef struct  _NDR_PIPE_DESC
    {
    NDR_PIPE_MESSAGE  *     pPipeMsg;
    short                   CurrentPipe;
    short                   PrevPipe;
    short                   InPipes;
    short                   OutPipes;
    short                   TotalPipes;
    short                   PipeVersion;
    PIPEDESC_FLAGS          Flags;
    unsigned long           PipeException;
    unsigned char    *      DispatchBuffer;
    unsigned long           DispatchBufferLength;
    unsigned char    *      LastPartialBuffer;
    unsigned long           LastPartialSize;
    unsigned char           Leftover[8];
    unsigned long           LeftoverSize;
    unsigned char    *      BufferSave;
    unsigned long           LengthSave;
    NDR_PIPE_STATE          RuntimeState;
    void             *      ChainingBuffer;
    unsigned long           ChainingBufferSize;
    PNDR_PIPE_HELPER        pPipeHelper;
    PNDR_ALLOCA_CONTEXT     pAllocContext;
    } NDR_PIPE_DESC, * PNDR_PIPE_DESC;


//
// Most of these prototypes should be exposed when we have -Os stubs.
//

void  RPC_ENTRY
NdrPipeAlloc(
    char             *  pState,
    unsigned long       bsize,
    void            **  buf,
    unsigned long    *  bcount );

RPC_STATUS  RPC_ENTRY
NdrAsyncPipeAlloc(
    char             *  pState,
    unsigned long       bsize,
    void            **  buf,
    unsigned long    *  bcount );


RPCRTAPI
RPC_STATUS  RPC_ENTRY
NdrAsyncPipePull(
    char          *     pState,
    void          *     buf,
    unsigned long       esize,
    unsigned long *     ecount );

RPCRTAPI
RPC_STATUS  RPC_ENTRY
NdrAsyncPipePush(
    char          *     pState,
    void          *     buf,
    unsigned long       ecount );

void
NdrpPipeElementBufferSize( 
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    ulong               ElemCount 
    );

void
NdrpPipeElementConvertAndUnmarshal( 
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar * *           ppMemory,
    long                ElemMemCount,
    long  *             pActCount
    );

BOOL
NdrReadPipeElements(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char *     pTargetBuffer,
    long *              pElementsRead
    );

void
NdrpReadPipeElementsFromBuffer (
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            TargetBuffer,
    long                TargetBufferCount, 
    long *              NumCopied
    );

RPC_STATUS
NdrpPushPipeForClient( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC   *   pPipeDesc,
    BOOL                fPushWholePipe,
    long            *   pActElems );

RPC_STATUS
NdrpPullPipeForClient( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC   *   pPipeDesc,
    BOOL                fPushWholePipe,
    long            *   pActElems,
    BOOL            *   fEndOfPipe );

void
NdrMarkNextActivePipe(
    NDR_PIPE_DESC   *   pPipeDesc );

RPC_STATUS RPC_ENTRY
NdrSend(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    BOOL                fPartial );

void RPC_ENTRY
NdrPartialSend(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg );

void RPC_ENTRY
NdrCompleteSend(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg );

void RPC_ENTRY
NdrReceive(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       Size,
    BOOL                fPartial );

void RPC_ENTRY
NdrPartialReceive(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       Size );

void RPC_ENTRY
NdrPipeSendReceive(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC *     pPipeDesc
    );

void
RPC_ENTRY
NdrIsAppDoneWithPipes(
    PNDR_PIPE_DESC      pPipeDesc
    );

void RPC_ENTRY
NdrPipesInitialize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_PIPE_HELPER    pPipeHelper,
    PNDR_ALLOCA_CONTEXT pAllocContext
    );

void
NdrpPipesInitialize32(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_ALLOCA_CONTEXT pAllocContext,
    PFORMAT_STRING      Params,
    char *              pStackTop,
    unsigned long       NumberParams
    );

void
NdrpPipesInitialize64(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_ALLOCA_CONTEXT pAllocContext,
    PFORMAT_STRING      Params,
    char *              pStackTop,
    unsigned long       NumberParams
    );  

RPCRTAPI
void
RPC_ENTRY
NdrPipePull(
    char          *     pState,
    void          *     buf,
    unsigned long       esize,
    unsigned long *     ecount );

RPCRTAPI
void
RPC_ENTRY
NdrPipePush(
    char          *     pState,
    void          *     buf,
    unsigned long       ecount );

RPCRTAPI
unsigned char *
RPC_ENTRY
NdrGetPipeBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferLength,
    RPC_BINDING_HANDLE  Handle );

RPCRTAPI
void
RPC_ENTRY
NdrGetPartialBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg );

void
NdrpRaisePipeException(
    NDR_PIPE_DESC  *    pPipeDesc,
    RPC_STATUS          Exception );

#endif // PIPENDR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\ndrpall.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 2000 Microsoft Corporation

Module Name :

    ndrpall.h

Abtract :

    Contains private definitions which are common to both
    ndr20 and ndr64

Author :

    mzoran   May 31, 2000

Revision History :

--------------------------------------------------------------------*/

#if !defined(__NDRPALL_H__)
#define __NDRPALL_H__

//
// The MIDL version is contained in the stub descriptor starting with
// MIDL version 2.00.96 (pre NT 3.51 Beta 2, 2/95) and can be used for a finer
// granularity of compatability checking.  The MIDL version was zero before
// MIDL version 2.00.96.  The MIDL version number is converted into
// an integer long using the following expression :
//     ((Major << 24) | (Minor << 16) | Revision)
//
#define MIDL_NT_3_51           ((2UL << 24) | (0UL << 16) | 102UL)
#define MIDL_VERSION_3_0_39    ((3UL << 24) | (0UL << 16) |  39UL)
#define MIDL_VERSION_3_2_88    ((3UL << 24) | (2UL << 16) |  88UL)
#define MIDL_VERSION_5_0_136   ((5UL << 24) | (0UL << 16) | 136UL)
#define MIDL_VERSION_5_2_202   ((5UL << 24) | (2UL << 16) | 202UL)

// Shortcut typedefs.
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;
typedef unsigned __int64    uint64;

#if defined(NDRFREE_DEBUGPRINT)
// force a debug print and a breakpoint on a free build
#define NDR_ASSERT( exp, S ) \
    if (!(exp)) { DbgPrint( "%s(%s)\n", __FILE__, __LINE__ );DbgPrint( S## - Ryszard's private rpcrt4.dll\n", NULL );DebugBreak(); }
#else
// Just use the RPC runtime assert
#define NDR_ASSERT( exp, S )   \
    { ASSERT( ( S, (exp) ) ); }
#endif


#define NDR_MEMORY_LIST_SIGNATURE 'MEML'

typedef struct _NDR_MEMORY_LIST_TAIL_NODE {
   ULONG Signature;
   void *pMemoryHead;
   struct _NDR_MEMORY_LIST_TAIL_NODE *pNextNode;
} NDR_MEMORY_LIST_TAIL_NODE, *PNDR_MEMORY_LIST_TAIL_NODE;

struct NDR_ALLOC_ALL_NODES_CONTEXT {
   unsigned char       *   AllocAllNodesMemory;
   unsigned char       *   AllocAllNodesMemoryBegin;
   unsigned char       *   AllocAllNodesMemoryEnd;
};

void
NdrpFreeMemoryList(
    PMIDL_STUB_MESSAGE  pStubMsg
    );

void
NdrpGetIIDFromBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg,
    IID **              ppIID
    );

void
NDRSContextEmergencyCleanup (
    IN RPC_BINDING_HANDLE   BindingHandle,
    IN OUT NDR_SCONTEXT     hContext,
    IN NDR_RUNDOWN          userRunDownIn,
    IN PVOID                NewUserContext,
    IN BOOL                 fManagerRoutineException
    );

void
NdrpEmergencyContextCleanup(
    MIDL_STUB_MESSAGE  *            pStubMsg,
    PNDR_CONTEXT_HANDLE_ARG_DESC    pCtxtDesc,
    void *                          pArg,
    BOOL                            fManagerRoutineException );


//
// Alignment macros.
//

#define ALIGN( pStuff, cAlign ) \
                pStuff = (uchar *)((LONG_PTR)((pStuff) + (cAlign)) \
                                   & ~ ((LONG_PTR)(cAlign)))

#define LENGTH_ALIGN( Length, cAlign ) \
                Length = (((Length) + (cAlign)) & ~ (cAlign))

#if defined(_IA64_)
#include "ia64reg.h"

#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
#pragma intrinsic (__getReg)

#ifdef __cplusplus
} // extern "C"
#endif

#endif

#if defined(_X86_)
__forceinline
void*
NdrGetCurrentStackPointer(void)
{
   _asm{ mov eax, esp }
}

__forceinline
void
NdrSetupLowStackMark( PMIDL_STUB_MESSAGE pStubMsg )
{
    pStubMsg->LowStackMark = (uchar*)NdrGetCurrentStackPointer() - 0x1000; //4KB
}

__forceinline
BOOL
NdrIsLowStack(MIDL_STUB_MESSAGE *pStubMsg ) {
    return (SIZE_T)NdrGetCurrentStackPointer() < (SIZE_T)pStubMsg->LowStackMark;
    //return false;
    }

#elif defined(_AMD64_)

__forceinline
void*
NdrGetCurrentStackPointer(void)
{
    PVOID TopOfStack;

    return (&TopOfStack + 1);
}

__forceinline
void
NdrSetupLowStackMark( PMIDL_STUB_MESSAGE pStubMsg )
{
    pStubMsg->LowStackMark = (uchar*)NdrGetCurrentStackPointer() - 0x1000; //4KB
}

__forceinline
BOOL
NdrIsLowStack(MIDL_STUB_MESSAGE *pStubMsg ) {
    return (SIZE_T)NdrGetCurrentStackPointer() < (SIZE_T)pStubMsg->LowStackMark;
    //return false;
    }

#elif defined(_IA64_)

__forceinline
void*
NdrGetCurrentStackPointer(void)
{
    return (void*)__getReg(CV_IA64_IntSp);
}

__forceinline
void*
NdrGetCurrentBackingStorePointer(void)
{
    return (void*)__getReg(CV_IA64_RsBSP);
}

__forceinline
void
NdrSetupLowStackMark( PMIDL_STUB_MESSAGE pStubMsg )
{
   // a backing store pointer which is used to store the stack based registers.
   // The normal stack grows downward and the backing store pointer grows upward.
   pStubMsg->LowStackMark = (uchar*)NdrGetCurrentStackPointer() - 0x4000; //16KB
   pStubMsg->BackingStoreLowMark =
       (uchar*)NdrGetCurrentBackingStorePointer() + 0x4000; //16KB  // IA64 really has 2 stack pointers.  The normal stack pointer and
}

__forceinline
BOOL
NdrIsLowStack(MIDL_STUB_MESSAGE *pStubMsg ) {
    return ((SIZE_T)NdrGetCurrentBackingStorePointer() > (SIZE_T)pStubMsg->BackingStoreLowMark) ||
           ((SIZE_T)NdrGetCurrentStackPointer() < (SIZE_T)pStubMsg->LowStackMark);
    //return false;
    }

#else
#error Unsupported Architecture
#endif

__forceinline
void
NdrRpcSetNDRSlot( void * pStubMsg )
{
    RPC_STATUS rc = I_RpcSetNDRSlot( pStubMsg ) ;
    if ( rc!= RPC_S_OK )
        RpcRaiseException(rc );
}

BOOL
IsWriteAV (
    IN struct _EXCEPTION_POINTERS *ExceptionPointers
    );

int RPC_ENTRY
NdrServerUnmarshallExceptionFlag(
    IN struct _EXCEPTION_POINTERS *ExceptionPointers
);


#endif // __NDRPALL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\pipes.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                                   
Copyright (c) 1995-2000 Microsoft Corporation

Module Name :

    pipe.c

Abstract :

    This file contains the idl pipe implementetion code.

Author :

    Ryszard K. Kott     (ryszardk)    Dec 1995

Revision History :

---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY

#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "ndrole.h"
#include "objidl.h"
#include "rpcproxy.h"
#include "interp.h"
#include "interp2.h"
#include "mulsyntx.h"
#include "pipendr.h"
#include "asyncndr.h"

#if DBG

typedef enum 
{
    PIPE_LOG_NONE,
    PIPE_LOG_CRITICAL,
    PIPE_LOG_API,
    PIPE_LOG_NOISE
} NDR_PIPE_LOG_LEVEL;

NDR_PIPE_LOG_LEVEL NdrPipeLogLevel = PIPE_LOG_NONE;

#define NDR_PIPE_LOG( level, args )                    \
    if ( NdrPipeLogLevel > level )                     \
        {                                              \
        DbgPrint( "NdrPipeLog: %d : ", level );        \
        DbgPrint  args  ;                              \
        DbgPrint( "\n" );                              \
        }                                              \
        
#else

#define NDR_PIPE_LOG( level, args )

#endif


RPC_STATUS RPC_ENTRY
NdrSend(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    BOOL                fPartial )
/*++

Routine Description :

    Performs a I_RpcSend in all the context it could be used:
        - pipes,
        - async, no pipes

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

    The new message buffer pointer returned from the runtime after the
    partial Send to the server.

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg;

    pRpcMsg = pStubMsg->RpcMsg;

    if ( pRpcMsg->BufferLength <
                   (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer))
        {
        NDR_ASSERT( 0, "NdrSend : buffer overflow" );
        NdrpRaisePipeException( pPipeDesc, RPC_S_INTERNAL_ERROR );
        }

    pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

    pStubMsg->fBufferValid = FALSE;

    if ( fPartial )
        pRpcMsg->RpcFlags |= RPC_BUFFER_PARTIAL;
    else
        pRpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;

    if ( pStubMsg->pRpcChannelBuffer )
        {
        ((IRpcChannelBuffer3 *)pStubMsg->pRpcChannelBuffer)->lpVtbl->Send(
                                (IRpcChannelBuffer3 *)pStubMsg->pRpcChannelBuffer,
                                (RPCOLEMESSAGE *)pRpcMsg,
                                (unsigned long*) &Status );
        NDR_ASSERT( Status != RPC_S_SEND_INCOMPLETE, "Unexpected channel error" );
        }
    else
        Status = I_RpcSend( pRpcMsg );

    if ( ! ( Status == RPC_S_OK  ||
             (Status == RPC_S_SEND_INCOMPLETE  &&  fPartial) ) )
        {
        if ( fPartial  &&  ! pStubMsg->IsClient )
            {
            // The buffer on which it failed has been freed by the runtime.
            // The stub has to return to runtime with the original buffer.
            // See ResetToDispatchBuffer for more info.

            pRpcMsg->Buffer = pPipeDesc->DispatchBuffer;
            pStubMsg->BufferStart = pPipeDesc->DispatchBuffer;
            pStubMsg->BufferEnd   = pPipeDesc->DispatchBuffer +
                                    pPipeDesc->DispatchBufferLength;
            }

        if ( pStubMsg->pAsyncMsg )
            pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;

        NdrpRaisePipeException( pPipeDesc,  Status );
        }
    pStubMsg->Buffer = (uchar*) pRpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return( Status );
}


void RPC_ENTRY
NdrPartialSend(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg )
/*++

Routine Description :

    Performs a partial I_RpcSend. It's used in the following contexts:
        - synchronous pipes
        - async pipes

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

    The new message buffer pointer returned from the runtime after the
    partial Send to the server.

Note:
    The partial I_RpcSend sends out full packets, the data from the last
    packet is left over and stays in the same buffer.
    That buffer can later be "reallocated" or reallocated for the new size.
    This is done in the NdrGetPartialBuffer.

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;

    // This routine needs to send only multiple of 8s now.

    pPipeDesc->LeftoverSize = PtrToUlong(pStubMsg->Buffer) & 0x7;

    if ( pPipeDesc->LeftoverSize )
        {
        pStubMsg->Buffer -= pPipeDesc->LeftoverSize;
        RpcpMemoryCopy( pPipeDesc->Leftover,
                        pStubMsg->Buffer,
                        pPipeDesc->LeftoverSize );
        }

    Status = NdrSend( pPipeDesc,
                      pStubMsg,
                      TRUE );    // send partial

    // Handle unsent buffer case.

    if ( Status == RPC_S_SEND_INCOMPLETE )
        {
        pPipeDesc->LastPartialBuffer = (uchar*) pRpcMsg->Buffer;
        pPipeDesc->LastPartialSize   = pRpcMsg->BufferLength;

        NDR_ASSERT( ((LONG_PTR)pRpcMsg->Buffer & 0x7) == 0,
                    "unsent buffer should still be a multiple of 8" );
        }
    else
        {
        // means no buffer left behind.

        pPipeDesc->LastPartialBuffer = NULL;
        pPipeDesc->LastPartialSize   = 0;
        }

    //  Handle the modulo 8 leftover.

    if ( pPipeDesc->LeftoverSize )
        {
        pPipeDesc->LastPartialBuffer = (uchar*) pRpcMsg->Buffer;
        pPipeDesc->LastPartialSize  += pPipeDesc->LeftoverSize;
        }
}


void RPC_ENTRY
NdrCompleteSend(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg )
/*++

Routine Description :

    Performs a complete send via I_RpcSend.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

Note :

    I_RpcSend with partial bit zeroed out is a rough equivalant
    of RpcSendReceive; this also covers the way the buffer is handled.
    The runtime takes care of the sent buffer, returns a buffer with
    data that needs to be freed later by the stub.
    If the buffer coming back is partial, the partial Receives take
    care of it and only the last one needs to be freed w/RpcFreeBuffer.

--*/
{
    NdrSend( pPipeDesc,
             pStubMsg,
             FALSE );    // send not partial

    pPipeDesc->LastPartialBuffer = NULL;
    pPipeDesc->LastPartialSize   = 0;

}


void RPC_ENTRY
NdrReceive(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       Size,
    BOOL                fPartial )
/*++

Routine Description :

    Performs a partial I_RpcReceive.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;
    unsigned long   CurOffset  = 0;

    pStubMsg->fBufferValid = FALSE;

    if ( ! pStubMsg->pRpcChannelBuffer )
        {
        // Channel sets the flag on the last, complete send
        // so we cannot assert for channel for now.
        NDR_ASSERT( !(pRpcMsg->RpcFlags & RPC_BUFFER_COMPLETE), "no more buffers" );
        }

    if ( fPartial )
        {
        pRpcMsg->RpcFlags |= RPC_BUFFER_PARTIAL;
        pRpcMsg->RpcFlags &= ~RPC_BUFFER_EXTRA;

        // For partials, the current offset will be zero.
        }
    else
        {
        pRpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;

        // The extra flag may be set or cleared by the caller.
        // On the client
        //    it should be cleared if there is no out pipes
        //    it should be set only on the last receive after out pipes
        // On the server
        //    it should be set on the initial receives that get non pipe data
        //    it should cleared on all the other receives.

        // For a complete with extra (i.e. appending new data),
        // the current offset needs to be preserved.
        // For a complete without extra, the offset is zero
        // as the receive follows immediately after a send call.

        CurOffset = (ulong)(pStubMsg->Buffer - (uchar*)pRpcMsg->Buffer);
        }

    if ( pStubMsg->pRpcChannelBuffer )
        {
        ((IRpcChannelBuffer3 *)pStubMsg->pRpcChannelBuffer)->lpVtbl->Receive(
                                (IRpcChannelBuffer3 *)pStubMsg->pRpcChannelBuffer,
                                (RPCOLEMESSAGE *)pRpcMsg,
                                Size,
                                (unsigned long *)&Status );
        }
    else
        Status = I_RpcReceive( pRpcMsg, Size );

    if ( Status )
        {
        // Pending is also OK: if so, we should not touch the state,
        // just return from the call to the app.

        if ( Status != RPC_S_ASYNC_CALL_PENDING )
            {
            // Real bug happened, the state will be teared down etc.

            if ( ! pStubMsg->IsClient )
                {
                // The buffer on which it failed has been freed by the runtime.
                // See ResetToDispatchBuffer for explanations why we do this.
                // Also note, on server we never call with async-nonpipe context.

                pRpcMsg->Buffer       = pPipeDesc->DispatchBuffer;
                pStubMsg->BufferStart = pPipeDesc->DispatchBuffer;
                pStubMsg->BufferEnd   = pPipeDesc->DispatchBuffer +
                                        pPipeDesc->DispatchBufferLength;
                }

            if ( pStubMsg->pAsyncMsg )
                {
                // raw rpc: if async, prevent calling abort later.

                if ( pStubMsg->pAsyncMsg )
                    pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;
                }
            }

        NdrpRaisePipeException( pPipeDesc, Status);
        }

    NDR_ASSERT( 0 == pRpcMsg->BufferLength ||
                NULL != pRpcMsg->Buffer,
                "Rpc runtime returned an invalid buffer." ); 

    if ( fPartial )
        {
        NDR_ASSERT( pRpcMsg->BufferLength, "a partial buffer can't be empty" );
        if ( pRpcMsg->BufferLength == 0)
            RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    pStubMsg->Buffer = (uchar*) pRpcMsg->Buffer + CurOffset;

    pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferEnd   = (uchar*)pRpcMsg->Buffer + pRpcMsg->BufferLength;
    pStubMsg->fBufferValid = TRUE;

}


void RPC_ENTRY
NdrPartialReceive(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       Size )
/*++

Routine Description :

    Performs a partial I_RpcReceive.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

--*/
{
    //
    // On the server we need to keep the dispatch buffer as the non-pipe
    // arguments may actually reside in the buffer.
    //    pPipeDesc->DispatchBuffer always points to the original buffer.
    //
    // Note that the runtime would free any buffer passed in the receive call
    // unless the extra flag is set.
    // Buffer being zero means a request for a new buffer.

    if ( pPipeDesc->Flags.NoMoreBuffersToRead )
        NdrpRaisePipeException( pPipeDesc,  RPC_X_BAD_STUB_DATA );

    if ( ! pStubMsg->IsClient  &&
         (pPipeDesc->DispatchBuffer == pStubMsg->RpcMsg->Buffer ) )
        {
        // Setup a request for a new buffer.

        pStubMsg->RpcMsg->Buffer = NULL;
        }

    NdrReceive( pPipeDesc,
                pStubMsg,
                Size,
                TRUE );  // partial

    if ( !( pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE )  &&
         ( pStubMsg->RpcMsg->BufferLength & 0x7 ) )
        {
        NDR_ASSERT( 0, "Partial buffer length not multiple of 8");
        NdrpRaisePipeException( pPipeDesc,  RPC_S_INTERNAL_ERROR );
        }

    if ( pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE )
        pPipeDesc->Flags.NoMoreBuffersToRead = 1;

}


unsigned char * RPC_ENTRY
NdrGetPipeBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferLength,
    RPC_BINDING_HANDLE  Handle )
/*++

Routine Description :

    This is the first call at the client or server side. Needs to be
    different from NdrGetBuffer as later calls to get buffer are different.
     - raw: the buffer will be reallocated by means of I_RpcReallocPipeBuffer

--*/
{
    unsigned char * pBuffer;
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;

    pRpcMsg->RpcFlags &= ~RPC_BUFFER_COMPLETE;
    pRpcMsg->RpcFlags |= RPC_BUFFER_PARTIAL;
//#if !defined(__RPC_WIN64__)
    pRpcMsg->ProcNum  |= RPC_FLAGS_VALID_BIT;
//#endif    

    pBuffer = NdrGetBuffer( pStubMsg, BufferLength, Handle );

    return  pBuffer;
}


void RPC_ENTRY
NdrGetPartialBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg )
/*++

Routine Description :

    Gets the next buffer for a partial send depending on the pipe state.
    Because of the way partial I_RpcSend works, this routine takes care
    of the leftover from the last send by means of setting the buffer
    pointer to the first free position.
    See NdrPartialSend for more comments.

Return :

--*/
{
    RPC_STATUS      Status    = RPC_S_OK;
    NDR_PIPE_DESC * pPipeDesc = (NDR_PIPE_DESC *) pStubMsg->pContext->pPipeDesc;

    pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_COMPLETE;
    pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_PARTIAL;

    Status = I_RpcReallocPipeBuffer( pStubMsg->RpcMsg,
                                     pStubMsg->BufferLength );

    if ( Status != RPC_S_OK )
        {
        // Raw rpc: if async, don't call runtime to abort later.

        if ( pStubMsg->pAsyncMsg )
            pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;

        NdrpRaisePipeException( pPipeDesc,  Status );
        }

    ASSERT( pStubMsg->RpcMsg->BufferLength >= pStubMsg->BufferLength );

    pStubMsg->Buffer = (uchar*) pStubMsg->RpcMsg->Buffer +
                                pPipeDesc->LastPartialSize;

    if ( pPipeDesc->LeftoverSize )
        {
        // Because of sizing, LastPartialSize already had LeftoverSize in it.

        RpcpMemoryCopy( pStubMsg->Buffer - pPipeDesc->LeftoverSize,
                        pPipeDesc->Leftover,
                        pPipeDesc->LeftoverSize );
        }
}


void RPC_ENTRY
NdrPipesInitialize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_PIPE_HELPER    pPipeHelper,
    PNDR_ALLOCA_CONTEXT pAllocContext
    )
/*+
    Initializes all the pipe structures.
    Only standard RPC (non-DCOM) pipes are supported now.

+*/
{
    NDR_PIPE_STATE *    pRuntimeState;
        
    NDR_ASSERT( ! pStubMsg->pRpcChannelBuffer, "DCOM pipes not supported" );

    NDR_PIPE_DESC *pPipeDesc = pPipeHelper->GetPipeDesc();
    
    MIDL_memset( pPipeDesc, 0, sizeof(NDR_PIPE_DESC) );

    pPipeDesc->pPipeHelper   = pPipeHelper;
    pPipeDesc->pAllocContext = pAllocContext;

    pStubMsg->pContext->pPipeDesc = pPipeDesc;

    // See how many pipes we have and what the maximum wire size is.

    if ( pPipeHelper->InitParamEnum() )
        {

        do
            {
            unsigned short PipeFlags = pPipeHelper->GetParamPipeFlags();

            if ( PipeFlags )
                {

                if ( PipeFlags & NDR_IN_PIPE )
                    pPipeDesc->InPipes++;
                
                if ( PipeFlags & NDR_OUT_PIPE )
                    pPipeDesc->OutPipes++;

                pPipeDesc->TotalPipes++;
                }

            }
            while ( pPipeHelper->GotoNextParam() );

        }


    pPipeDesc->pPipeMsg = 
        (NDR_PIPE_MESSAGE *)NdrpAlloca( pPipeDesc->pAllocContext, 
                                        pPipeDesc->TotalPipes * sizeof( NDR_PIPE_MESSAGE ) );

    MIDL_memset( pPipeDesc->pPipeMsg,
                 0,
                 pPipeDesc->TotalPipes * sizeof( NDR_PIPE_MESSAGE ));

    pPipeDesc->CurrentPipe = -1;
    pPipeDesc->PrevPipe    = -1;
    pPipeDesc->PipeVersion = NDR_PIPE_VERSION;


    // Now set the individual pipe messages.

    NDR_PIPE_MESSAGE *pLastInPipe   = NULL;
    NDR_PIPE_MESSAGE *pLastOutPipe  = NULL;

    int PipeNo = 0;
    if ( pPipeHelper->InitParamEnum() )
        {

        do
            {
            unsigned short PipeFlags = pPipeHelper->GetParamPipeFlags();

            if ( !PipeFlags)
                continue;

            NDR_PIPE_MESSAGE * pPipe = & pPipeDesc->pPipeMsg[ PipeNo ];

            if ( PipeFlags & NDR_IN_PIPE )
                pLastInPipe  = pPipe;
            if ( PipeFlags & NDR_OUT_PIPE )
                pLastOutPipe = pPipe;
                
            pPipe->Signature   = NDR_PIPE_SIGNATURE;
            pPipe->PipeId      = (ushort)PipeNo;
            pPipe->PipeStatus  = NDR_PIPE_NOT_OPENED;
            pPipe->PipeFlags   = PipeFlags;
            pPipe->pTypeFormat = pPipeHelper->GetParamTypeFormat(); 
            pPipe->pStubMsg    = pStubMsg;

            pPipe->pPipeObject = (GENERIC_PIPE_TYPE *) pPipeHelper->GetParamArgument();

            if ( pPipe->PipeFlags & NDR_REF_PIPE )
                {
                // dereference the argument to get the pipe control block.

                if ( ! pStubMsg->IsClient )
                    {
                    // For the server, under interpreter, we don't have
                    // the actual pipe object that is referenced.
                    // The stack argument should be null.

                    NDR_ASSERT( ! *(void **)pPipe->pPipeObject,
                                "null expected for out pipe by ref" );

                    // The pipe object is not a real parameter in the 
                    // same sense as the other RPC parameters. The user 
                    // can not free the object.

                    void * temp = NdrpAlloca( pPipeDesc->pAllocContext,
                                              sizeof(GENERIC_PIPE_TYPE ) );

                    MIDL_memset( temp, 0, sizeof( GENERIC_PIPE_TYPE ) );

                    *(void **)pPipe->pPipeObject = temp;

                    pPipe->PipeFlags |= NDR_OUT_ALLOCED;
                    }

                  pPipe->pPipeObject = *(GENERIC_PIPE_TYPE **)pPipe->pPipeObject;
               }

            // For raw async rpc set up the pipe arg on both sides.
            // For non-async raw set up the pipe on server only.

            if (  pStubMsg->IsClient )
                {
                if ( pStubMsg->pAsyncMsg )
                    {
                    GENERIC_PIPE_TYPE * pPipeType = pPipe->pPipeObject;

                    pPipeType->pfnPull = NdrAsyncPipePull;
                    pPipeType->pfnPush = NdrAsyncPipePush;
                    pPipeType->pfnAlloc= NdrAsyncPipeAlloc;
                    pPipeType->pState  = (char *)pPipe;
                    }
                }
            else
                {
                GENERIC_PIPE_TYPE * pPipeType = pPipe->pPipeObject;

                if ( pStubMsg->pAsyncMsg )
                    {
                    pPipeType->pfnPull = NdrAsyncPipePull;
                    pPipeType->pfnPush = NdrAsyncPipePush;
                    pPipeType->pfnAlloc= NdrAsyncPipeAlloc;
                    pPipeType->pState  = (char *)pPipe;
                    }
                else
                    {
                    pPipeType->pfnPull = (NDR_HR_PIPE_PULL_RTN) NdrPipePull;
                    pPipeType->pfnPush = (NDR_HR_PIPE_PUSH_RTN) NdrPipePush;
                    pPipeType->pfnAlloc= (NDR_HR_PIPE_ALLOC_RTN)NdrPipeAlloc;
                    pPipeType->pState  = (char *)pPipe;
                    }
                }

            PipeNo++;

            } while ( pPipeHelper->GotoNextParam() ); 
        }

    // Mark the last in and out pipes.

    if ( pLastInPipe )
         pLastInPipe->PipeFlags |= NDR_LAST_IN_PIPE;
    if ( pLastOutPipe )
         pLastOutPipe->PipeFlags |= NDR_LAST_OUT_PIPE;

    // Set up structures for receiving pipes.

    pPipeDesc->DispatchBuffer       = (uchar *) pStubMsg->RpcMsg->Buffer;
    pPipeDesc->DispatchBufferLength =           pStubMsg->RpcMsg->BufferLength;

    if ( pPipeDesc->OutPipes  &&  pStubMsg->IsClient  ||
         pPipeDesc->InPipes   &&  ! pStubMsg->IsClient )
        {
        pRuntimeState = & pPipeDesc->RuntimeState;
        pRuntimeState->CurrentState      = START;
        pRuntimeState->TotalElemsCount   = 0;
        pRuntimeState->PartialElem       = 0;       // temp buf for elem
        pRuntimeState->PartialBufferSize = 0;       // temp buf for elem
        }

    if ( ! pStubMsg->IsClient  &&
         (pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE ))
        pPipeDesc->Flags.NoMoreBuffersToRead = 1;

}


class NDR_PIPE_HELPER32 : public NDR_PIPE_HELPER
{

private:

    PMIDL_STUB_MESSAGE pStubMsg;
    char *pStackTop;

    unsigned long NumberParameters;
    PPARAM_DESCRIPTION pFirstParameter;

    PPARAM_DESCRIPTION pCurrentParameter;
    unsigned long CurrentParamNumber;

    NDR_PIPE_DESC PipeDesc;

public:

    void *operator new( size_t stAllocateBlock, PNDR_ALLOCA_CONTEXT pAllocContext )
    {
        return NdrpAlloca( pAllocContext, (UINT)stAllocateBlock );
    }
    // Do nothing since the memory will be deleted automatically
    void operator delete(void *pMemory) {}

    NDR_PIPE_HELPER32( PMIDL_STUB_MESSAGE  pStubMsg,
                       PFORMAT_STRING      Params,
                       char *              pStackTop,
                       unsigned long       NumberParams )
    {
        NDR_PIPE_HELPER32::pStubMsg  = pStubMsg;
        NDR_PIPE_HELPER32::pStackTop = pStackTop; 
        pFirstParameter  = (PPARAM_DESCRIPTION)Params;
        NumberParameters = NumberParams;

    }

    virtual PNDR_PIPE_DESC GetPipeDesc() 
        {
        return &PipeDesc;
        }

    virtual bool InitParamEnum() 
        {
        pCurrentParameter = pFirstParameter;
        CurrentParamNumber = 0;
        return NumberParameters > 0;
        }

    virtual bool GotoNextParam() 
        {
        if ( CurrentParamNumber + 1 >= NumberParameters )
            {
            return false;
            }
        
        CurrentParamNumber++;
        pCurrentParameter = pFirstParameter + CurrentParamNumber;
        return true;
        }

    virtual unsigned short GetParamPipeFlags()
        {
            if ( !pCurrentParameter->ParamAttr.IsPipe )
                return 0;

            unsigned short Flags = 0;

            if ( pCurrentParameter->ParamAttr.IsIn )
                Flags |= NDR_IN_PIPE;
            if ( pCurrentParameter->ParamAttr.IsOut )
                Flags |= NDR_OUT_PIPE;

            if ( pCurrentParameter->ParamAttr.IsSimpleRef )
                Flags |= NDR_REF_PIPE;

            return Flags;
        }

    virtual PFORMAT_STRING GetParamTypeFormat() 
        {
            return pStubMsg->StubDesc->pFormatTypes +
                   pCurrentParameter->TypeOffset;
        }

    virtual char *GetParamArgument() 
        {
            return pStackTop + pCurrentParameter->StackOffset;
        }

    virtual void InitPipeStateWithType( PNDR_PIPE_MESSAGE pPipeMsg )
        {

        FC_PIPE_DEF *   pPipeFc  = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
        NDR_PIPE_STATE *pState   = & PipeDesc.RuntimeState;

        pState->LowChunkLimit = 0;
        pState->HighChunkLimit = NDR_DEFAULT_PIPE_HIGH_CHUNK_LIMIT;
        pState->ElemAlign = pPipeFc->Align;
        if ( pPipeFc->BigPipe )
            {
            pState->ElemMemSize  = * (long UNALIGNED *) & pPipeFc->Big.MemSize;
            pState->ElemWireSize = * (long UNALIGNED *) & pPipeFc->Big.WireSize;
            if ( pPipeFc->HasRange )
                {
                pState->LowChunkLimit  = * (long UNALIGNED *) &pPipeFc->Big.LowChunkLimit;
                pState->HighChunkLimit = * (long UNALIGNED *) &pPipeFc->Big.HighChunkLimit;
                }
            }
        else
            {
            pState->ElemMemSize  = pPipeFc->s.MemSize;
            pState->ElemWireSize = pPipeFc->s.WireSize;
            if ( pPipeFc->HasRange )
                {
                pState->LowChunkLimit  = * (long UNALIGNED *) &pPipeFc->s.LowChunkLimit;
                pState->HighChunkLimit = * (long UNALIGNED *) &pPipeFc->s.HighChunkLimit;
                }
            }

        pState->ElemPad     = WIRE_PAD( pState->ElemWireSize, pState->ElemAlign );
        pState->fBlockCopy  = (pState->ElemMemSize == 
                               pState->ElemWireSize + pState->ElemPad); 
        }
    
    virtual void MarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                               uchar *pMemory,
                               unsigned long Elements )
        {

            unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
            
            FC_PIPE_DEF *   pPipeFc      = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
            PFORMAT_STRING  pElemFormat  =
                       (uchar *) & pPipeFc->TypeOffset + pPipeFc->TypeOffset;

            while( Elements-- )
                {
                (*pfnMarshallRoutines[ROUTINE_INDEX(*pElemFormat)])
                   ( pPipeMsg->pStubMsg,
                     pMemory,
                     pElemFormat);
                pMemory += ElemMemSize;
                }
        }
    
    virtual void UnmarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements )
        {

            unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
            
            FC_PIPE_DEF *   pPipeFc      = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
            PFORMAT_STRING  pElemFormat  =
                       (uchar *) & pPipeFc->TypeOffset + pPipeFc->TypeOffset;

            while( Elements-- )
                {
                (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pElemFormat)])
                   ( pPipeMsg->pStubMsg,
                     &pMemory,
                     pElemFormat,
                     FALSE );
                pMemory += ElemMemSize;
                }

        }
    
    virtual void BufferSizeType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements )
        { 
        
        unsigned long ElemMemSize = PipeDesc.RuntimeState.ElemMemSize;
        
        FC_PIPE_DEF *   pPipeFc      = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
        PFORMAT_STRING  pElemFormat  =
                   (uchar *) & pPipeFc->TypeOffset + pPipeFc->TypeOffset;

        while( Elements-- )
            {
            (*pfnSizeRoutines[ROUTINE_INDEX(*pElemFormat)])
               ( pPipeMsg->pStubMsg,
                 pMemory,
                 pElemFormat);
            pMemory += ElemMemSize;
            }

        }
    
    virtual void ConvertType( PNDR_PIPE_MESSAGE pPipeMsg,
                              unsigned long Elements ) 
        {

        unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
        
        FC_PIPE_DEF *   pPipeFc      = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
        PFORMAT_STRING  pElemFormat  =
                   (uchar *) & pPipeFc->TypeOffset + pPipeFc->TypeOffset;

        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;

        if ( pStubMsg->RpcMsg->DataRepresentation
                               == NDR_LOCAL_DATA_REPRESENTATION )
            return;

        uchar * BufferSaved = pStubMsg->Buffer;

        // We can end up here for any object.

        while ( Elements-- )
            {
            if ( IS_SIMPLE_TYPE( *pElemFormat) )
                {
                NdrSimpleTypeConvert( pStubMsg, *pElemFormat );
                }
            else
                {
                (*pfnConvertRoutines[ ROUTINE_INDEX( *pElemFormat ) ])
                            ( pStubMsg,
                              pElemFormat,
                              FALSE );  // embedded pointers
                }
            }

        pStubMsg->Buffer = BufferSaved;

        }

    virtual void BufferSizeChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg ) 
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        LENGTH_ALIGN( pStubMsg->BufferLength, 3 );
        pStubMsg->BufferLength += sizeof(ulong);
    }

    virtual bool UnmarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong *pOut )
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        ALIGN( pStubMsg->Buffer, 3);
       
        if ( 0 == REMAINING_BYTES() )
           {
           return false;
           }

        // transition: end of src

        if (REMAINING_BYTES() < sizeof(DWORD))
            {
            // with packet sizes being a multiple of 8,
            // this cannot happen.

            NDR_ASSERT( 0, "Chunk counter split is not possible.");

            NdrpRaisePipeException( &PipeDesc,  RPC_S_INTERNAL_ERROR );
            return false;
            }

        if ( pStubMsg->RpcMsg->DataRepresentation
                               != NDR_LOCAL_DATA_REPRESENTATION )
            {
            uchar * BufferSaved = pStubMsg->Buffer;

            NdrSimpleTypeConvert( pStubMsg, FC_LONG );
            pStubMsg->Buffer = BufferSaved;
            }

        ulong Value = *(ulong*)pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(ulong);

        CHECK_BOUND( Value, FC_ULONG );
        *pOut = Value;
        return true;
    }

    virtual void MarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                       ulong Counter )
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        CHECK_BOUND( Counter, FC_ULONG );
        
        ALIGN( pStubMsg->Buffer, 3);
        *(ulong*)pStubMsg->Buffer = Counter;
        pStubMsg->Buffer += sizeof(ulong);
    }

    virtual void BufferSizeChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg ) { pPipeMsg; };

    virtual void MarshallChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                           ulong Counter ) { pPipeMsg; Counter; }

    virtual bool VerifyChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong HeaderCounter ) 
    { 
        pPipeMsg; HeaderCounter; 
        return true;
    }

    virtual bool HasChunkTailCounter() { return FALSE; }


};

typedef NDR_PIPE_HELPER *PNDR_PIPE_HELPER;


void
NdrpPipesInitialize32(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_ALLOCA_CONTEXT pAllocContext,
    PFORMAT_STRING      Params,
    char *              pStackTop,
    unsigned long       NumberParams
    )
{

/* C wrapper to initialize the 32 pipe helper and call NdrPipesInitialize*/
    NDR_PIPE_HELPER32 *pPipeHelper =
        new( pAllocContext ) NDR_PIPE_HELPER32( pStubMsg,
                                                Params,
                                                pStackTop,
                                                NumberParams );
    
    NdrPipesInitialize( pStubMsg,
                        pPipeHelper,
                        pAllocContext );
}


void  RPC_ENTRY
ResetToDispatchBuffer(
    NDR_PIPE_DESC *     pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg
    )
/*
    This is a server side routine that makes sure that
    the original dispatch buffer is restored to the rpc message.

    These are the rules:
    - the engine can return to the runtime with the original or a new
      buffer; if it's a new buffer it has to be valid (not freed yet).
      When exception happens, the runtime will be freeing any buffer
      that is different from the original buffer.
    - when I_RpcReceive or I_RpcSend fail, they free the current
      buffer, and so the stub cannot free it. If this is the second
      buffer, the original dispatch buffer pointer should be restored
      in the rpcmsg.
    - the second buffer does not have to be freed in case of a
      normal return or an exception clean up in a situation different
      from above. The runtime will free it.

    Note that we never free the original dispatch buffer.
*/
{
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;

    // If the dispatch buffer was replaced by a partial buffer,
    // free the partial buffer and restore the dispatch buffer.

    if ( pPipeDesc->DispatchBuffer != pRpcMsg->Buffer )
        {
        I_RpcFreePipeBuffer( pRpcMsg );

        pRpcMsg->Buffer = pPipeDesc->DispatchBuffer;
        pStubMsg->BufferStart = pPipeDesc->DispatchBuffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pPipeDesc->DispatchBufferLength;
        }
}


void  RPC_ENTRY
NdrPipeSendReceive(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_PIPE_DESC  *      pPipeDesc
    )
/*+
    Complete send-receive routine for client pipes.
    It takes over with a buffer filled with non-pipe args,
    sends [in] pipes, receives [out] pipes and then receives
    the buffer with non-pipe args.
+*/
{
    int                 CurrentPipe;
    NDR_PIPE_MESSAGE *  pPipeMsg;
    RPC_STATUS          Status;

    // Service the in pipes

    if ( pPipeDesc->InPipes )
        {
        // Once we know we have an [in] pipe, we can send the non-pipe
        // arguments via a partial I_RpcSend.
        // It is OK to call that with the BufferLength equal zero.

        NdrPartialSend( pPipeDesc, pStubMsg );


        for ( CurrentPipe = 0; CurrentPipe < pPipeDesc->TotalPipes; CurrentPipe++ )
            {
            long    LastChunkSent;

            pPipeMsg = & pPipeDesc->pPipeMsg[ CurrentPipe ];

            if ( ! (pPipeMsg->PipeFlags & NDR_IN_PIPE) )
                continue;

            pPipeDesc->CurrentPipe = (short) CurrentPipe;
            pPipeMsg->PipeStatus   = (ushort) NDR_PIPE_ACTIVE_IN;

            Status = NdrpPushPipeForClient( pStubMsg,
                                           pPipeDesc,
                                           TRUE,   // whole pipe
                                           &LastChunkSent );

            // The call above would raise an exception for any case other than
            // dcom async pipe case. This covers sync usage of this code path.
            // So, if we are here, the call succeeded, the status should be ok
            // and last chunk zero, as we requested to push the whole pipe.

            NDR_ASSERT( Status == RPC_S_OK  &&  LastChunkSent == 0,
                        "should process all or raise exception" );

            pPipeMsg->PipeStatus = NDR_PIPE_DRAINED;

            } // for [in] pipes
        }

    NdrCompleteSend( pPipeDesc, pStubMsg );

    // The above call uses I_RpcSend and requires that I_RpcReceive is called
    // later. This has to be done regardless whether any data is expected
    // in the buffer or not.
    // The receive call is complete or partial depending on the context.

    if ( pPipeDesc->OutPipes == 0 )
        {
        // After send we would still have the [in] buffer around so we
        // need to clear the extra flag to avoid appending.

        pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_EXTRA;

        NdrReceive( pPipeDesc,
                    pStubMsg,
                    0,         // size, ignored for complete calls
                    FALSE );   // complete buffer
        return;
        }

    // Service the out pipes
    // Partial calls always clear up the extra flag before calling runtime.

    NdrPartialReceive( pPipeDesc,
                       pStubMsg,
                       PIPE_PARTIAL_BUFFER_SIZE );

    // The buffer has some pipe elemements

    pPipeDesc->BufferSave = pStubMsg->Buffer;
    pPipeDesc->LengthSave = pStubMsg->RpcMsg->BufferLength;

    for ( CurrentPipe = 0; CurrentPipe < pPipeDesc->TotalPipes; CurrentPipe++ )
        {
        long    LastChunk;
        BOOL    EndOfPipe;

        pPipeMsg = & pPipeDesc->pPipeMsg[ CurrentPipe ];

        if ( ! (pPipeMsg->PipeFlags & NDR_OUT_PIPE) )
            continue;

        pPipeDesc->CurrentPipe = (short) CurrentPipe;
        pPipeMsg->PipeStatus   = NDR_PIPE_ACTIVE_OUT;

        Status = NdrpPullPipeForClient( pStubMsg,
                                        pPipeDesc,
                                        TRUE,   // whole pipe
                                        & LastChunk,
                                        & EndOfPipe );

        NDR_ASSERT( Status == RPC_S_OK  &&  EndOfPipe,
                    "should process all or raise exception" );

        pPipeMsg->PipeStatus = NDR_PIPE_DRAINED;

        } // for [out] pipes

    // After all the partial receives, have the last one that is complete.

    if ( ! (pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE) )
        {
        // On the last call at client we need the extra flag as some
        // non-pipe data may have already been received.

        pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_EXTRA;

        NdrReceive( pPipeDesc,
                    pStubMsg,
                    0,         // size, ignored for complete calls
                    FALSE );   // complete buffer
        }
}


RPC_STATUS
NdrpPushPipeForClient(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC   *   pPipeDesc,
    BOOL                fWholePipe,
    long            *   pLastChunkSent )
{
    PFORMAT_STRING  pElemFormat;
    ulong           ElemAlign, ElemMemSize, ElemWireSize, ElemPad;
    ulong           PipeAllocSize, CopySize;
    BOOL            fBlockCopy;
    RPC_STATUS      Status = RPC_S_OK;

    NDR_PIPE_LOG(PIPE_LOG_NOISE, ("NdrpPushPipeForClient: pStubMsg->Buffer %p", pStubMsg->Buffer) );

    RpcTryExcept
        {
        NDR_PIPE_MESSAGE * pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];

        // Service an in pipe.

        GENERIC_PIPE_TYPE * pPipeType = pPipeMsg->pPipeObject;
        
        pPipeDesc->pPipeHelper->InitPipeStateWithType( pPipeMsg );

        ElemAlign    = pPipeDesc->RuntimeState.ElemAlign;
        ElemMemSize  = pPipeDesc->RuntimeState.ElemMemSize;
        ElemWireSize = pPipeDesc->RuntimeState.ElemWireSize;
        ElemPad      = pPipeDesc->RuntimeState.ElemPad;
        fBlockCopy   = pPipeDesc->RuntimeState.fBlockCopy;

        if ( PIPE_PARTIAL_BUFFER_SIZE < ElemMemSize )
            PipeAllocSize = ElemMemSize;
        else
            PipeAllocSize = PIPE_PARTIAL_BUFFER_SIZE;

        uchar *             pMemory;
        unsigned long       bcChunkSize;
        unsigned long       ActElems, ReqElems;

        NDR_HR_PIPE_PULL_RTN    pfnPull  = pPipeType->pfnPull;
        NDR_HR_PIPE_ALLOC_RTN   pfnAlloc = pPipeType->pfnAlloc;
        void                  * pThis    = pPipeType->pState;

        do
            {
            HRESULT Hr;

            // Get memory for the pipe elements

            Hr = (*pfnAlloc)( (char *)pThis,
                              PipeAllocSize,
                              (void **) & pMemory,
                              & bcChunkSize );

            if ( pMemory == 0 )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_APP_MEMORY );

            // Get the pipe elements to the buffer.

            ActElems = bcChunkSize / ElemMemSize;
            ReqElems = ActElems;

            if ( ActElems == 0 )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_INVALID_BUFFER );

            Hr = (*pfnPull)( (char *)pThis,
                             pMemory,
                             ActElems,
                             & ActElems );

            NDR_PIPE_LOG( PIPE_LOG_NOISE, ("NdrpPushPipeForClient: pfnPull returned %d ActElems", ActElems) );

            if ( ReqElems < ActElems )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_INVALID_BUFFER );

            //
            // Size the chunk and get the marshaling buffer
            //

            pStubMsg->BufferLength = pPipeDesc->LastPartialSize;

            pPipeDesc->pPipeHelper->BufferSizeChunkCounter( pPipeMsg );
            
            CopySize = ( ActElems - 1) * (ElemWireSize + ElemPad)
                          + ElemWireSize;

            if ( ActElems )
                {
                LENGTH_ALIGN( pStubMsg->BufferLength, ElemAlign );

                if ( fBlockCopy )
                    pStubMsg->BufferLength += CopySize;
                else
                    {
                    NdrpPipeElementBufferSize( pPipeDesc,
                                               pStubMsg,
                                               pMemory,
                                               ActElems );
                    }
                }

            pPipeDesc->pPipeHelper->BufferSizeChunkTailCounter( pPipeMsg );

            // Get the new buffer, put the frame leftover in it.

            NdrGetPartialBuffer( pStubMsg );

            //
            // Marshal the chunk
            //

            pPipeDesc->pPipeHelper->MarshallChunkCounter( pPipeMsg,
                                                          ActElems );

            NDR_PIPE_LOG( PIPE_LOG_NOISE, ( "Writting pipe chunk: %d", ActElems ) );

            if ( ActElems )
                {
                ALIGN( pStubMsg->Buffer, ElemAlign );

                if ( fBlockCopy )
                    {
                    RpcpMemoryCopy( pStubMsg->Buffer,
                                    pMemory,
                                    CopySize );
                    pStubMsg->Buffer += CopySize;
                    }
                else
                    {
                    // Again: only complex is possible

                    pPipeDesc->pPipeHelper->MarshallType( pPipeMsg,
                                                          pMemory,
                                                          ActElems );
                    pMemory += ActElems * ElemMemSize;
                    
                    }
                }

            pPipeDesc->pPipeHelper->MarshallChunkTailCounter( pPipeMsg, 
                                                              ActElems );

            // Send it if it is not the last partial send.

            if ( !(pPipeMsg->PipeFlags & NDR_LAST_IN_PIPE)  ||
                 ((pPipeMsg->PipeFlags & NDR_LAST_IN_PIPE)  &&  ActElems)
               )
                NdrPartialSend( pPipeDesc, pStubMsg );

            }
        while( fWholePipe  &&  ActElems > 0 );

        *pLastChunkSent = ActElems;

        NDR_PIPE_LOG( PIPE_LOG_NOISE, ("NdrpPushPipeForClient: exit *pLastChunkSent", *pLastChunkSent ) );

        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();

        NdrpRaisePipeException( pPipeDesc,  Status );
        }
    RpcEndExcept

    return Status;
}


RPC_STATUS
NdrpPullPipeForClient(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC   *   pPipeDesc,
    BOOL                fWholePipe,
    long            *   pActElems,
    BOOL            *   pEndOfPipe )
{
    PFORMAT_STRING  pElemFormat;
    ulong           ElemAlign, ElemMemSize, ElemWireSize, ElemPad;
    BOOL            fBlockCopy;
    long            ActElems;
    RPC_STATUS      Status = RPC_S_OK;

    RpcTryExcept
        {
        NDR_PIPE_MESSAGE * pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];

        // Service an out pipe

        pPipeDesc->pPipeHelper->InitPipeStateWithType( pPipeMsg );
        pPipeDesc->RuntimeState.EndOfPipe = 0;

        ElemAlign    = pPipeDesc->RuntimeState.ElemAlign;
        ElemMemSize  = pPipeDesc->RuntimeState.ElemMemSize;
        ElemWireSize = pPipeDesc->RuntimeState.ElemWireSize;
        ElemPad      = pPipeDesc->RuntimeState.ElemPad;
        fBlockCopy   = pPipeDesc->RuntimeState.fBlockCopy;

        GENERIC_PIPE_TYPE  *    pPipeType = pPipeMsg->pPipeObject;

        NDR_HR_PIPE_PUSH_RTN    pfnPush  = pPipeType->pfnPush;
        NDR_HR_PIPE_ALLOC_RTN   pfnAlloc = pPipeType->pfnAlloc;
        void                  * pThis    = pPipeType->pState;

        BOOL                    EndOfPipe;

        // RequestedSize estimates a reasonable size for pfnAlloc call.

        HRESULT     Hr;
        ulong       RequestedSize;
        uchar     * pMemory;

        if (ElemWireSize< PIPE_PARTIAL_BUFFER_SIZE)
            RequestedSize = (PIPE_PARTIAL_BUFFER_SIZE / ElemWireSize)
                                 * ElemMemSize;
        else
            RequestedSize = 2 * ElemMemSize;

        do
            {
            unsigned long   bcChunkSize;

            // Get a chunk of memory for pipe elements to push

            Hr = (*pfnAlloc)( (char *)pThis,
                              RequestedSize,
                              (void **) & pMemory,
                              & bcChunkSize );

            if ( pMemory == 0 )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_APP_MEMORY );

            ActElems = bcChunkSize / ElemMemSize;

            if ( ActElems == 0 )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_INVALID_BUFFER );

            EndOfPipe = NdrReadPipeElements( pPipeDesc,
                                             pStubMsg,
                                             pMemory,
                                             & ActElems );

            Hr = (*pfnPush)( (char *)pThis,
                             pMemory,
                             ActElems );
            }
        while ( fWholePipe  &&  ActElems  &&  ! EndOfPipe );

        if ( ActElems )
            {
            Hr = (*pfnPush)( (char *)pThis,
                             pMemory + ActElems * ElemMemSize,
                             0 );
            }

        *pActElems = ActElems;
        *pEndOfPipe = EndOfPipe;
        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();

        NdrpRaisePipeException( pPipeDesc,  Status );
        }
    RpcEndExcept

    return Status;
}


void
NdrMarkNextActivePipe(
    NDR_PIPE_DESC  *  pPipeDesc )
/*

Description:

    This routine is used on the server side sync calls, or on both side of async
    calls to manage the proper sequence of pipes to service.

Note:

    When the last possible pipe is done, this routine restores the
    original dispatch buffer to the rpc message.

*/
{
    unsigned long   Mask;
    int             NextPipe    = 0;
    int             CurrentPipe = pPipeDesc->CurrentPipe;

    if ( CurrentPipe == -1 )
        {
        // This means an initial call at any side.
        // Find the first in pipe, or if none, find first out pipe.

        Mask = pPipeDesc->InPipes ?  NDR_IN_PIPE
                                  :  NDR_OUT_PIPE;
        }
    else
        {
        // Switching from one active pipe to another.

        NDR_PIPE_MESSAGE *  pPipeMsg;
        unsigned short      LastPipeStatus;

        pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];

        LastPipeStatus       = pPipeMsg->PipeStatus;
        pPipeMsg->PipeStatus = NDR_PIPE_DRAINED;

        // Mark no active pipe.

        pPipeDesc->PrevPipe    = pPipeDesc->CurrentPipe;
        pPipeDesc->CurrentPipe = -1;

        // See if the drained pipe was the last possible pipe.

        if ( (LastPipeStatus == NDR_PIPE_ACTIVE_OUT)  &&
             (pPipeMsg->PipeFlags  &  NDR_LAST_OUT_PIPE) )
            {
            return;
            }

        // See if the drained pipe was the last in pipe.
        // Set how to look for the next active pipe.

        if ( (LastPipeStatus == NDR_PIPE_ACTIVE_IN)  &&
             (pPipeMsg->PipeFlags  &  NDR_LAST_IN_PIPE) )
            {
            ResetToDispatchBuffer( pPipeDesc, pPipeMsg->pStubMsg );

            if (pPipeDesc->OutPipes == 0)
                return;

            // Change direction after the last in pipe.
            // The search will be from the beginning.

            Mask = NDR_OUT_PIPE;
            }
        else
            {
            // Same direction, start the search with the next pipe.

            NextPipe = CurrentPipe + 1;
            Mask = (LastPipeStatus == NDR_PIPE_ACTIVE_IN) ?  NDR_IN_PIPE
                                                          :  NDR_OUT_PIPE;
            }
        }

    // First fit. We are here only when there is another pipe to service.

    while( NextPipe < pPipeDesc->TotalPipes )
        {
        if ( pPipeDesc->pPipeMsg[NextPipe].PipeFlags  &  Mask )
           {
           pPipeDesc->CurrentPipe = (short) NextPipe;
           if ( Mask == NDR_IN_PIPE )
               {
               pPipeDesc->pPipeMsg[NextPipe].PipeStatus = NDR_PIPE_ACTIVE_IN;
               }
           else
               {
               pPipeDesc->pPipeMsg[NextPipe].PipeStatus = NDR_PIPE_ACTIVE_OUT;
               }

           pPipeDesc->pPipeHelper->InitPipeStateWithType( &pPipeDesc->pPipeMsg[NextPipe] );
           pPipeDesc->RuntimeState.EndOfPipe = 0;
           break;
           }
        NextPipe++;
        }

    // If it is the first out pipe on server, get the buffer.

    PMIDL_STUB_MESSAGE  pStubMsg = pPipeDesc->pPipeMsg[NextPipe].pStubMsg;

    if ( ! pStubMsg->IsClient  &&
         Mask == NDR_OUT_PIPE  &&
         ! pPipeDesc->Flags.AuxOutBufferAllocated )
        {
        NdrGetPipeBuffer( pStubMsg,
                          PIPE_PARTIAL_BUFFER_SIZE,
                          pStubMsg->SavedHandle );

        pPipeDesc->Flags.AuxOutBufferAllocated = 1;
        }

}


void
NdrpVerifyPipe( char  *  pState )
/*
    This routine verifies the context for server application calling
    pull or push emtries of the engine.
*/
{
    NDR_PIPE_MESSAGE *  pPipeMsg = (NDR_PIPE_MESSAGE *) pState;

    if ( ! pPipeMsg           ||
         ! pPipeMsg->pStubMsg ||
         pPipeMsg->Signature != NDR_PIPE_SIGNATURE )
        RpcRaiseException( RPC_X_INVALID_PIPE_OBJECT );

    NDR_PIPE_DESC * pPipeDesc = (NDR_PIPE_DESC *) pPipeMsg->pStubMsg->pContext->pPipeDesc;

    if ( ! pPipeDesc )
        RpcRaiseException( RPC_X_INVALID_PIPE_OBJECT );

    // An exception occured on the pipe call, but the app
    // for some unknown reason is trying to call Rpc again.
    // Just rethrow the exception that the app received the first time.
    if ( 0 != pPipeDesc->PipeException )
        RpcRaiseException( pPipeDesc->PipeException );

   // See if a different pipe is currently active.

   if ( pPipeDesc->CurrentPipe != -1  &&
        & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ] != pPipeMsg )
      NdrpRaisePipeException( pPipeDesc,  RPC_X_WRONG_PIPE_ORDER );

}

void RPC_ENTRY
NdrIsAppDoneWithPipes(
    NDR_PIPE_DESC  *    pPipeDesc
    )
/*
    This routine is called from the engine after the manager code returned
    to the engine to see if all the pipes have been processed.
    It is also called from NdrCompleteAsyncClientCall.
    It is not called from the synchronous client as it is the stub
    that manages the pipe processing for synchronous case.
*/
{
    // It is possible for the server in sync rpc and both side in async rpc
    // to receive an error, ignore it and continue. 
    // To prevent this, rethrow the exception if an exception was hit before.
    
    if ( pPipeDesc->PipeException )
        RpcRaiseException( pPipeDesc->PipeException );
    
    if ( pPipeDesc->CurrentPipe != -1 )
        NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_DISCIPLINE_ERROR );

    for (int i = 0; i < pPipeDesc->TotalPipes; i++ )
        if ( pPipeDesc->pPipeMsg[i].PipeStatus != NDR_PIPE_DRAINED )
            NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_DISCIPLINE_ERROR );
}


void RPC_ENTRY
NdrPipePull(
    char          * pState,
    void          * buf,
    unsigned long   esize,
    unsigned long * ecount )
/*+
    Server side [in] pipe arguments.
-*/
{

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrPipePull: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    buf %p, esize %u", buf, esize ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    ecount %p", ecount ) );

    NdrpVerifyPipe( pState );

    NDR_PIPE_MESSAGE *  pPipeMsg  = (NDR_PIPE_MESSAGE *) pState;
    PMIDL_STUB_MESSAGE  pStubMsg  = pPipeMsg->pStubMsg;
    NDR_PIPE_DESC *     pPipeDesc = (NDR_PIPE_DESC *) pStubMsg->pContext->pPipeDesc;

    if ( pPipeDesc->CurrentPipe == -1  &&
         & pPipeDesc->pPipeMsg[ pPipeDesc->PrevPipe ] == pPipeMsg )
        {
        // An attempt to read from the pipe that was the last one used.

        NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_EMPTY );
        }

    // Pulling in pipe on async raw client, out pipe on any server

    if ( pPipeMsg->PipeStatus == NDR_PIPE_ACTIVE_IN  &&  pStubMsg->IsClient  ||
         pPipeMsg->PipeStatus == NDR_PIPE_ACTIVE_OUT && !pStubMsg->IsClient )
        NdrpRaisePipeException( pPipeDesc,  RPC_X_WRONG_PIPE_ORDER );

    if ( esize == 0 )
        NdrpRaisePipeException( pPipeDesc,  RPC_S_INVALID_ARG );

    long  ElemCount = (long) esize;

    *ecount = 0;
    if ( pPipeDesc->RuntimeState.EndOfPipe )
        {
        NdrMarkNextActivePipe( pPipeDesc );
        return;
        }

    uchar * pMemory   = (uchar*) buf;
    BOOL    EndOfPipe;

    EndOfPipe = NdrReadPipeElements( pPipeDesc,
                                     pStubMsg,
                                     pMemory,
                                     & ElemCount );

    NDR_ASSERT( ElemCount <= (long)esize, "read more than asked for" );

    *ecount = ElemCount;

    if ( EndOfPipe  &&  ElemCount == 0 )
        NdrMarkNextActivePipe( pPipeDesc );
}


void  RPC_ENTRY
NdrPipePush(
    char          * pState,
    void          * buf,
    unsigned long   ecount )
/*+
    Server side [out] pipe arguments.
-*/
{
    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrPipePush: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    Buf %p, ecount %u", buf, ecount ) );

    NdrpVerifyPipe( pState );

    NDR_PIPE_MESSAGE *  pPipeMsg  = (NDR_PIPE_MESSAGE *) pState;
    PMIDL_STUB_MESSAGE  pStubMsg  = pPipeMsg->pStubMsg;
    NDR_PIPE_DESC *     pPipeDesc = (NDR_PIPE_DESC *) pStubMsg->pContext->pPipeDesc;

    if ( pPipeDesc->CurrentPipe == -1  &&
         & pPipeDesc->pPipeMsg[ pPipeDesc->PrevPipe ] == pPipeMsg )
        {
        // An attempt to write the pipe that was the last one used.

        NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_CLOSED );
        }

    // Pushing out pipe on async raw client, in pipe on any server

    if ( pPipeMsg->PipeStatus == NDR_PIPE_ACTIVE_OUT &&  pStubMsg->IsClient  ||
         pPipeMsg->PipeStatus == NDR_PIPE_ACTIVE_IN  && !pStubMsg->IsClient )
        NdrpRaisePipeException( pPipeDesc,  RPC_X_WRONG_PIPE_ORDER );

    ulong   ElemAlign    = pPipeDesc->RuntimeState.ElemAlign;
    ulong   ElemMemSize  = pPipeDesc->RuntimeState.ElemMemSize;
    ulong   ElemWireSize = pPipeDesc->RuntimeState.ElemWireSize;
    ulong   ElemPad      = pPipeDesc->RuntimeState.ElemPad;
    BOOL    fBlockCopy   = pPipeDesc->RuntimeState.fBlockCopy;

    // Size the chunk and get the marshaling buffer
    //

    pStubMsg->BufferLength = pPipeDesc->LastPartialSize;

    pPipeDesc->pPipeHelper->BufferSizeChunkCounter( pPipeMsg );

    ulong  CopySize = ( ecount - 1) * (ElemWireSize + ElemPad)
                                                    + ElemWireSize;
    uchar * pMemory   = (uchar*) buf;

    if ( ecount )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, ElemAlign );

        if ( fBlockCopy )
            pStubMsg->BufferLength += CopySize;
        else
            {
            NdrpPipeElementBufferSize( pPipeDesc,
                                       pStubMsg,
                                       pMemory,
                                       ecount );
            }
        }


    pPipeDesc->pPipeHelper->BufferSizeChunkTailCounter( pPipeMsg );

    // Get the new buffer, put the frame leftover in it.

    NdrGetPartialBuffer( pStubMsg );

    // Marshal the chunk

    pPipeDesc->pPipeHelper->MarshallChunkCounter( pPipeMsg, ecount );

    if ( ecount )
        {
        ALIGN( pStubMsg->Buffer, ElemAlign );

        if ( fBlockCopy )
           {
           RpcpMemoryCopy( pStubMsg->Buffer,
                           pMemory,
                           CopySize );
           pStubMsg->Buffer += CopySize;
           }
        else
           {
           // Again: only complex is possible

           pPipeDesc->pPipeHelper->MarshallType( pPipeMsg,
                                                 pMemory,
                                                 ecount );
           pMemory += ElemMemSize * ecount;
           
           }
       }

    pPipeDesc->pPipeHelper->MarshallChunkTailCounter( pPipeMsg, ecount );

    // If it is not the last terminator, use a partial send.
    // On client (async only) the last send should be complete,
    // On server (sync or async) the complete send will happen after marshaling
    // non-pipe out data.
    // Channel requires the last call on server.

    if ( pStubMsg->IsClient )
        {
        if ( ecount == 0  &&  (pPipeMsg->PipeFlags & NDR_LAST_IN_PIPE))
            NdrCompleteSend( pPipeDesc, pStubMsg );
        else
            NdrPartialSend( pPipeDesc, pStubMsg );
        }
    else
        NdrPartialSend( pPipeDesc, pStubMsg );

    if ( ecount == 0 )
        NdrMarkNextActivePipe( pPipeDesc );
}


void  RPC_ENTRY
NdrPipeAlloc(
    char          * pState,
    unsigned long   bsize,
    void          **buf,
    unsigned long * bcount )
/*
    This method has been introduced to support pipe chaining - when
    a server becomes a client and passes a pipe argument along.
    Only one buffer is ever there: next call releases the previous one.
*/
{

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrPipeAlloc: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    bsize %d, buf %p", bsize, buf ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    bcount %p", bcount ) );

    NdrpVerifyPipe( pState );

    NDR_PIPE_MESSAGE *  pPipeMsg  = (NDR_PIPE_MESSAGE *) pState;
    PMIDL_STUB_MESSAGE  pStubMsg  = pPipeMsg->pStubMsg;
    NDR_PIPE_DESC *     pPipeDesc = (NDR_PIPE_DESC *) pStubMsg->pContext->pPipeDesc;

    if ( pPipeDesc->ChainingBuffer )
        {
        if ( pPipeDesc->ChainingBufferSize >= bsize )
            {
            *bcount = pPipeDesc->ChainingBufferSize;
            *buf    = pPipeDesc->ChainingBuffer;
            return;
            }
        else
            {
            NdrpPrivateFree( pPipeDesc->pAllocContext, pPipeDesc->ChainingBuffer );
            pPipeDesc->ChainingBuffer = NULL;
            pPipeDesc->ChainingBufferSize = 0;
            }
        }

    RpcTryExcept
        {
        pPipeDesc->ChainingBuffer = NdrpPrivateAllocate( pPipeDesc->pAllocContext, bsize );
        }
    RpcExcept(1)
        {
        NdrpRaisePipeException( pPipeDesc,  RPC_S_OUT_OF_MEMORY );
        }
    RpcEndExcept

    *bcount = bsize;
    *buf = pPipeDesc->ChainingBuffer;
}


void
NdrpAsyncHandlePipeError(
    char      * pState,
    RPC_STATUS  Status )
/*++
Routine Description :

    Forces the connect to close by either freeing the buffer
    or aborting the call on an async pipe error.

Arguments :

    pState  - Supplies the pipe state.
    Statue  - Supplies the error code.

Return :

    None.

--*/

{
    
   NDR_PIPE_MESSAGE    *pPipeMsg;
   MIDL_STUB_MESSAGE   *pStubMsg;
   PNDR_ASYNC_MESSAGE  pAsyncMsg;

   // Pending isn't really an error.
   if ( RPC_S_ASYNC_CALL_PENDING == Status )
      return;

   if ( !pState )
      {
      return;
      }

   pPipeMsg = (NDR_PIPE_MESSAGE *)pState;

   if ( ! pPipeMsg->pStubMsg ||
        pPipeMsg->Signature != NDR_PIPE_SIGNATURE )
      return;

   pStubMsg = pPipeMsg->pStubMsg;
   
   if ( !pStubMsg->pAsyncMsg )
      {
      return;
      }

   pAsyncMsg = pStubMsg->pAsyncMsg;

   RpcTryExcept
      {
      if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
         {
            if ( pStubMsg->IsClient )
               {
               NdrFreeBuffer( pStubMsg );      
               }
            else 
               {
               I_RpcAsyncAbortCall( pAsyncMsg->AsyncHandle, Status);
               }
         }
      }
   RpcExcept(1)
      {
      // Ignore and exceptions that occured
      }
   RpcEndExcept
   pAsyncMsg->Flags.RuntimeCleanedUp = 1;

}



RPC_STATUS RPC_ENTRY
NdrAsyncPipePull(
    char          * pState,
    void          * buf,
    unsigned long   esize,
    unsigned long * ecount )
{
    RPC_STATUS Status = RPC_S_OK;

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrAsyncPipePull: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    buf %p, esize %u", buf, esize ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    ecount %u", ecount ) );

    RpcTryExcept
        {
        NdrPipePull( pState, buf, esize, ecount );
        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();
        NdrpAsyncHandlePipeError( pState, Status );
        }
    RpcEndExcept

    return Status;
}

RPC_STATUS  RPC_ENTRY
NdrAsyncPipePush(
    char          * pState,
    void          * buf,
    unsigned long   ecount )
{
    RPC_STATUS Status = RPC_S_OK;

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrAsyncPipePush: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    buf %p, count %u", buf, ecount ) );

    RpcTryExcept
        {
        NdrPipePush( pState, buf, ecount );
        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();
        NdrpAsyncHandlePipeError( pState, Status );
        }
    RpcEndExcept

    return Status;
}

RPC_STATUS  RPC_ENTRY
NdrAsyncPipeAlloc(
    char          * pState,
    unsigned long   bsize,
    void          **buf,
    unsigned long * bcount )
/*
*/
{
    RPC_STATUS Status = RPC_S_OK;

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrAsyncPipeAlloc: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    bsize %u, buf %p", bsize, buf ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    bcount %p", bcount ) );

    RpcTryExcept
        {
        NdrPipeAlloc( pState, bsize, buf, bcount );
        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();
        NdrpAsyncHandlePipeError( pState, Status );
        }
    RpcEndExcept

    return Status;
}



void
NdrpPipeElementBufferSize(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    ulong               ElemCount
    )
/*++

Routine Description :

    Computes the needed buffer size for the pipe elements.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{

    if ( ElemCount == 0 )
        return;

    // We can end up here only for complex objects.
    // For objects without unions, we may be forced to size because
    // of different packing levels.

    if ( pPipeDesc->RuntimeState.ElemWireSize )
        {
        // There is a fixed WireSize, so use it.

        ulong WireSize = pPipeDesc->RuntimeState.ElemWireSize;
        ulong WireAlign = pPipeDesc->RuntimeState.ElemAlign;

        pStubMsg->BufferLength +=
              (ElemCount -1) * (WireSize + WIRE_PAD( WireSize, WireAlign )) +
                                  WireSize;
        }
    else
        {
        NDR_PIPE_MESSAGE * pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];

        pPipeDesc->pPipeHelper->BufferSizeType(  pPipeMsg,
                                                 pMemory,
                                                 ElemCount );
        }
}


void
NdrpPipeElementConvertAndUnmarshal(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar * *           ppMemory,
    long                ActElems,
    long  *             pActCount
    )
/*++

Routine Description :

    Computes the needed buffer size for the pipe elements.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    NDR_PIPE_STATE *    state    = & pPipeDesc->RuntimeState;
    NDR_PIPE_MESSAGE *  pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];
    uchar *             pMemory  = *ppMemory;

    ulong   ElemWireSize = state->ElemWireSize;
    ulong   ElemPad      = state->ElemPad;
    BOOL    fBlockCopy   = state->fBlockCopy;

    NDR_PIPE_LOG( PIPE_LOG_NOISE, ( " NdrpPipeElementConvertAndUnmarshal: ActElems %d", ActElems ) );
    NDR_PIPE_LOG( PIPE_LOG_NOISE, ("    pStubMsg->Buffer %p, pMemory %p", pStubMsg->Buffer, pMemory ) );

    if ( ActElems )
        {
        pPipeDesc->pPipeHelper->ConvertType( pPipeMsg,
                                             ActElems );


        // Unmarshal the chunk

        ALIGN( pStubMsg->Buffer, state->ElemAlign );

        if ( fBlockCopy )
            {
            ulong  CopySize  = ( ActElems - 1) * (ElemWireSize + ElemPad)
                                               + ElemWireSize;
            RpcpMemoryCopy( pMemory,
                            pStubMsg->Buffer,
                            CopySize );
            pStubMsg->Buffer += CopySize;
            }
        else
            {
            // Only complex and enum is possible here.

            pPipeDesc->pPipeHelper->UnmarshallType( pPipeMsg,
                                                    pMemory,
                                                    ActElems );
            pMemory += state->ElemMemSize;
            
            }

        *ppMemory += state->ElemMemSize * ActElems;
        }

    *pActCount += ActElems;
}



BOOL
NdrReadPipeElements(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char *     pTargetBuffer,
    long *              pElementsRead
    )
/*
    This procedure encapsulates reading pipe elements from the RPC runtime.

*/
{
    NDR_PIPE_STATE * pRuntimeState = & pPipeDesc->RuntimeState;
    ulong            ElemWireSize  = pRuntimeState->ElemWireSize;

    // Get the temporary buffers

    if ( ( pRuntimeState->PartialBufferSize / ElemWireSize ) == 0 )
        {
        // buffer too small.
        // We preallocate a buffer that is of an arbitrary big size.
        // If the element is even bigger, we allocate a buffer big
        // enough for one element.

        if ( pRuntimeState->PartialElem )
            NdrpPrivateFree( pPipeDesc->pAllocContext, pRuntimeState->PartialElem );

        if ( PIPE_PARTIAL_BUFFER_SIZE < ElemWireSize )
            pRuntimeState->PartialBufferSize = ElemWireSize;
        else
            pRuntimeState->PartialBufferSize = PIPE_PARTIAL_BUFFER_SIZE;

        // We allocate more for alignment padding.

        RpcTryExcept
            {
            pRuntimeState->PartialElem =  (uchar *)
                NdrpPrivateAllocate( pPipeDesc->pAllocContext, 
                                     pRuntimeState->PartialBufferSize + 8);
            }
        RpcExcept(1)
            {
            if ( ! pRuntimeState->PartialElem )
                NdrpRaisePipeException( pPipeDesc,  RPC_S_OUT_OF_MEMORY );             
            }
        RpcEndExcept

        }

    long ElemsToRead = *pElementsRead;
    long LeftToRead  = *pElementsRead;
    long ElemsRead   = 0;

    *pElementsRead = 0;

    // New semantics - unmarshal only what we have at hand, don't call
    // for the next buffer unless it would mean giving back 0 elems.

    while ( ( LeftToRead > 0  &&  ! pPipeDesc->RuntimeState.EndOfPipe ) ||
            pPipeDesc->RuntimeState.EndOfPipePending )
        {
        // See if there is a buffer to process first

        if ( ! pPipeDesc->Flags.NoBufferCallPending )
            {
            // Read elements from the marshaling buffer (the StubMsg->Buffer)
            // to the user's target buffer (converted and unmarshaled).
            // ElemsRead would be cumulative across the calls when looping.

            NdrpReadPipeElementsFromBuffer( pPipeDesc,
                                            pStubMsg,
                                            & pTargetBuffer,
                                            LeftToRead,
                                            & ElemsRead );
            }

        LeftToRead = ElemsToRead - ElemsRead;

        if ( ( LeftToRead > 0   &&  ! pPipeDesc->RuntimeState.EndOfPipe ) ||
             pPipeDesc->RuntimeState.EndOfPipePending  )
            {
            // We ran out of data in the current buffer.
            // Check if we unmarshaled some elems already - if so, don't read.

            if ( ElemsRead == 0 )
                {
                pPipeDesc->Flags.NoBufferCallPending = 1;

                NdrPartialReceive( pPipeDesc,
                                   pStubMsg,
                                   pRuntimeState->PartialBufferSize );

                pPipeDesc->Flags.NoBufferCallPending = 0;
                continue;
                }
            }

        break;
        }

    *pElementsRead = ElemsRead;
    return  pPipeDesc->RuntimeState.EndOfPipe;
}


void NdrpReadPipeElementsFromBuffer (
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            pTargetBuffer,
    long                ElemsToRead,
    long *              NumCopied
    )
{
    NDR_PIPE_STATE *    state   = & pPipeDesc->RuntimeState;
    NDR_PIPE_MESSAGE * pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];
    BOOL fHasChunkTailCounter   = pPipeDesc->pPipeHelper->HasChunkTailCounter();

    long                len;
    uchar *             BufferSave;

    NDR_ASSERT( state->CurrentState == START ||
                state->PartialElemSize  < state->ElemWireSize,
                "when starting to read pipe elements" );

    NDR_PIPE_LOG( PIPE_LOG_NOISE, ( "NdrpReadPipeElementsFromBuffer: ElemsToRead %x", ElemsToRead ) );
    NDR_PIPE_LOG( PIPE_LOG_NOISE, ( "    pStubMsg->Buffer %p", pStubMsg->Buffer ) );

    if ( ( ElemsToRead == 0 ) &&
         ( !state->EndOfPipePending ) )
        {
        return ;
        }

    while (1)
        {
        switch( state->CurrentState )
            {
            case  START:

                NDR_PIPE_LOG( PIPE_LOG_NOISE, ( " START: pStubMgs->Buffer %p", pStubMsg->Buffer ) );

                ASSERT(pStubMsg->Buffer >= pStubMsg->RpcMsg->Buffer);
                ASSERT(pStubMsg->Buffer - pStubMsg->RpcMsg->BufferLength <= pStubMsg->RpcMsg->Buffer);

                // The state to read the chunk counter.

                state->PartialElemSize = 0 ;

                // Read the element count.
                {
                    ulong ElemsInChunk;
                    if ( !pPipeDesc->pPipeHelper->UnmarshallChunkCounter( pPipeMsg, 
                                                                          &ElemsInChunk ) )
                    return;
                 
                    state->ElemsInChunk = state->OrigElemsInChunk = ElemsInChunk;
                }
                
                NDR_PIPE_LOG( PIPE_LOG_NOISE, ("Read pipe chuck: %d", state->ElemsInChunk ) );

                if (state->ElemsInChunk == 0)
                    {
                    
                    if ( fHasChunkTailCounter )
                        {
                        state->EndOfPipePending = 1;
                        state->CurrentState = VERIFY_TAIL_CHUNK;

                        NDR_PIPE_LOG( PIPE_LOG_NOISE, ("Waiting for duplicate 0...") );
                        }
                    else
                        {
                        state->EndOfPipe = 1;                        
                        return;
                        }
                    
                    }
                else
                    {
                    if ( state->LowChunkLimit > state->ElemsInChunk  ||
                         state->HighChunkLimit < state->ElemsInChunk )
                        NdrpRaisePipeException( pPipeDesc,  RPC_X_INVALID_BOUND );

                    state->CurrentState = COPY_PIPE_ELEM;
                    }
                break;

            case  COPY_PIPE_ELEM:

                NDR_PIPE_LOG( PIPE_LOG_NOISE, (" COPY_PIPE_ELEM: state->ElemsInChunk %d", state->ElemsInChunk ) );
                NDR_PIPE_LOG( PIPE_LOG_NOISE, ("     pStubMsg->Buffer %p, ElemsToRead %d", pStubMsg->Buffer, ElemsToRead ) );
                
                // The state with some elements in the current chunk left.
                // The elements may not be in the current buffer, though.

                NDR_ASSERT( state->ElemsInChunk != 0xbaadf00d, "bogus chunk count" );
                NDR_ASSERT( state->ElemsInChunk, "empty chunk!" );

                ALIGN( pStubMsg->Buffer, state->ElemAlign );

                if ( state->ElemWireSize <= REMAINING_BYTES() )
                    {
                    // There is enough on wire to unmarshal at least one.

                    if ( ElemsToRead )
                        {
                        long ElemsReady, ActCount, EffectiveSize, WirePad;

                        WirePad = WIRE_PAD( state->ElemWireSize, state->ElemAlign );

                        EffectiveSize = state->ElemWireSize + WirePad;

                        ElemsReady = (REMAINING_BYTES() + WirePad) /
                                                            EffectiveSize;
                        if ( ElemsReady > state->ElemsInChunk )
                            ElemsReady = state->ElemsInChunk;
                        if ( ElemsReady > ElemsToRead )
                            ElemsReady = ElemsToRead;

                        ActCount   = 0;
                        NdrpPipeElementConvertAndUnmarshal( pPipeDesc,
                                                            pStubMsg,
                                                            pTargetBuffer,
                                                            ElemsReady,
                                                            & ActCount );

                        ElemsToRead         -= ActCount;
                        state->ElemsInChunk -= ActCount;
                        *NumCopied          += ActCount;

                        if (state->ElemsInChunk == 0)
                            {

                            state->CurrentState =  fHasChunkTailCounter ? 
                                                       VERIFY_TAIL_CHUNK :
                                                       START;

                            if ( ElemsToRead == 0 )
                                return;
                            }
                        }
                    else
                        {
                        // End of target buffer: return the count.
                        // Keep the same state for the next round.

                        return;
                        }
                    }
                else
                    {
                    // Not enough wire bytes to unmarshal element.

                    if ( REMAINING_BYTES() )
                        {
                        NDR_ASSERT( 0 < REMAINING_BYTES(),
                                    "buffer pointer not within the buffer" );

                        state->CurrentState = RETURN_PARTIAL_ELEM;
                        }
                    else
                        {
                        state->PartialElemSize = 0;
                        return;
                        }
                    }
                break;

            case RETURN_PARTIAL_ELEM:

                NDR_PIPE_LOG( PIPE_LOG_NOISE, (" RETURN_PARTIAL_ELEM: state->ElemsInChunk %d", state->ElemsInChunk ) );

                // This happens when there is no whole element left
                // during copying. The chunk has some elements.

                NDR_ASSERT( state->ElemsInChunk, "empty chunk" );

                len = REMAINING_BYTES();

                NDR_ASSERT( 0 < len  &&  len < state->ElemWireSize,
                            "element remnant expected" );

                // Save the remnants of the elem in PartialElem;
                // Pay attention to the alignment of the remnant, though.

                state->PartialOffset   = 0;
                state->PartialElemSize = 0;

                if ( len )
                    {
                    // we need to simulate the original alignment by
                    // means of an offset in the PartialElem buffer.

                    state->PartialOffset = 0x7 & PtrToUlong( pStubMsg->Buffer );

                    RpcpMemoryCopy( state->PartialElem + state->PartialOffset,
                                    pStubMsg->Buffer,
                                    len );
                    pStubMsg->Buffer      += len;
                    state->PartialElemSize = len;
                    }
                state->CurrentState = READ_PARTIAL_ELEM ;
                return;


            case READ_PARTIAL_ELEM:     //also a start state

                NDR_PIPE_LOG( PIPE_LOG_NOISE, (" READ_PARTIAL_ELEM: state->ElemsInChunk %d", state->ElemsInChunk ) );

                NDR_ASSERT( state->PartialElemSize > 0 &&
                            state->PartialElemSize < state->ElemWireSize,
                            "element remnant expected" );

                NDR_ASSERT( ElemsToRead, "no elements to read" );

                len = state->ElemWireSize - state->PartialElemSize;

                if ( len > REMAINING_BYTES() )
                    {
                    // Add another piece to the partial element,
                    // then wait for another round in the same state.

                    RpcpMemoryCopy( state->PartialElem + state->PartialOffset
                                       + state->PartialElemSize,
                                    pStubMsg->Buffer,
                                    REMAINING_BYTES() );
                    pStubMsg->Buffer       += REMAINING_BYTES();
                    state->PartialElemSize += REMAINING_BYTES();

                    return;
                    }

                // Assemble a complete partial element, unmarshal it,
                // then switch to the regular element copying.

                RpcpMemoryCopy( state->PartialElem  + state->PartialOffset
                                   + state->PartialElemSize,
                                pStubMsg->Buffer,
                                len );
                pStubMsg->Buffer       += len;
                state->PartialElemSize  += len;  

                // Assemble a fake STUB_MESSAGE and RPC_MESSAGE so that
                // the buffer looks likes the a regular RPC buffer.
                {
                    // Save modified fields.
                    void          *   RpcBufferSave    = pStubMsg->RpcMsg->Buffer;                   
                    unsigned int      RpcBufferLength  = pStubMsg->RpcMsg->BufferLength;
                    unsigned char *   BufferSave       = pStubMsg->Buffer;
                    unsigned char *   BufferStartSave  = pStubMsg->BufferStart;
                    unsigned char *   BufferEndSave    = pStubMsg->BufferEnd;
                    
                     
                    RpcTryFinally
                        {

                        pStubMsg->RpcMsg->Buffer       = state->PartialElem + state->PartialOffset;
                        pStubMsg->RpcMsg->BufferLength = state->PartialElemSize; 

                        pStubMsg->Buffer      = (unsigned char *)pStubMsg->RpcMsg->Buffer;
                        pStubMsg->BufferStart = pStubMsg->Buffer;
                        pStubMsg->BufferEnd   = pStubMsg->Buffer + pStubMsg->RpcMsg->BufferLength;

                        len = 0;
                        NdrpPipeElementConvertAndUnmarshal( pPipeDesc,
                                                            pStubMsg,
                                                            pTargetBuffer,
                                                            1,
                                                            & len );


                        NDR_ASSERT( len == 1, "partial element count" );
                        ElemsToRead         -= 1;
                        state->ElemsInChunk -= 1;
                        *NumCopied          += 1 ;
                        
        				
                        // reset partial element state.
                        state->PartialOffset    = 0;
                        state->PartialElemSize  = 0;
                        
                        }

                    RpcFinally 
                        {

                        // Switch back to regular elem unmarshaling.
        
                        pStubMsg->RpcMsg->Buffer       = RpcBufferSave;
                        pStubMsg->RpcMsg->BufferLength = RpcBufferLength; 

                        pStubMsg->Buffer      = BufferSave;
                        pStubMsg->BufferStart = BufferStartSave;
                        pStubMsg->BufferEnd   = BufferEndSave;
                        }
                    RpcEndFinally
                }  

                if ( state->ElemsInChunk == 0 )
                    {
                    state->CurrentState =  fHasChunkTailCounter ? 
                           VERIFY_TAIL_CHUNK :
                           START;

                    if ( ElemsToRead == 0 )
                        return;
                    }
                else
                    state->CurrentState = COPY_PIPE_ELEM;

                break;

            case  VERIFY_TAIL_CHUNK:
                
                NDR_PIPE_LOG( PIPE_LOG_NOISE, (" VERIFY_TAIL_CHUNK: state->OrigElemsInChunk %d", state->OrigElemsInChunk ) );
                NDR_PIPE_LOG( PIPE_LOG_NOISE, ("    pStubMsg->Buffer %p", pStubMsg->Buffer ) );

                ASSERT(pStubMsg->Buffer >= pStubMsg->RpcMsg->Buffer);
                ASSERT(pStubMsg->Buffer - pStubMsg->RpcMsg->BufferLength <= pStubMsg->RpcMsg->Buffer);

                // The state to verify the tail chunk counter.

                state->PartialElemSize = 0 ;
                
                if (! pPipeDesc->pPipeHelper->VerifyChunkTailCounter( pPipeMsg,
                                                                      state->OrigElemsInChunk ) )
                    {
                    NDR_PIPE_LOG( PIPE_LOG_NOISE, ( "Not enough buffer for tail chunk counter..Leaving state machine."))
                    return;
                    }

                // Get read for the next chunk.
                state->CurrentState = START;

                if ( state->EndOfPipePending )
                    {
                    state->EndOfPipePending = 0;
                    state->EndOfPipe = 1;
                    return;
                    }
                break;


            default:
                NDR_ASSERT(0, "unknown state") ;
                break;
            }
        }
}

void
NdrpRaisePipeException(
    NDR_PIPE_DESC  *    pPipeDesc,
    RPC_STATUS          Exception )
{
    // Remember the first exception that happened,
    // ignore all the subsequent exceptions by reraising the first one.

    if ( Exception != RPC_S_ASYNC_CALL_PENDING && pPipeDesc )
        {
        
        if ( pPipeDesc->PipeException == 0 )
           
           pPipeDesc->PipeException = Exception;

        RpcRaiseException( pPipeDesc->PipeException );
        
        }
    else
        RpcRaiseException( Exception );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\pointerq.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    pointerq.cxx

Abstract :

    This file contains the routines for the pointer queues
    
Author :

    Mike Zoran  mzoran   Jun 2000.

Revision History :

  ---------------------------------------------------------------------*/
#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

void 
NDR32_POINTER_QUEUE_STATE::Free(
    NDR_POINTER_QUEUE_ELEMENT *pElement 
    ) 
{
    #if defined(DBG)
    memset( pElement, 0xBD, NdrMaxPointerQueueElement);
    #endif
    
    pElement->pNext = pFreeList;
    pFreeList = pElement;
}

NDR_POINTER_QUEUE_ELEMENT *
NDR32_POINTER_QUEUE_STATE::Allocate()
{
    NDR_POINTER_QUEUE_ELEMENT *pNewElement;
    if ( pFreeList )
        {
        pNewElement = pFreeList;
        pFreeList = pNewElement->pNext;
        }
    else
        {
        pNewElement = InternalAllocate();
        }
#if defined(DBG)
     memset( pNewElement, 0xDB, NdrMaxPointerQueueElement );
#endif
    return pNewElement;
}


void 
NDR32_POINTER_QUEUE_STATE::FreeAll() 
{
    while ( pAllocationList )
        {
        AllocationElement *pThisAlloc = pAllocationList;
        pAllocationList = pAllocationList->pNext;
        I_RpcFree( pThisAlloc );
        }    
}

NDR_POINTER_QUEUE_ELEMENT * 
NDR32_POINTER_QUEUE_STATE::InternalAllocate()
{
    if ( !pAllocationList || 
         (ItemsToAllocate == pAllocationList->ItemsAllocated ) )
        {

        struct AllocationElement *pElement =
            (struct AllocationElement *)I_RpcAllocate( sizeof(AllocationElement) );
        if ( !pElement )
            {
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );
            }

        pElement->pNext          = pAllocationList;
        pElement->ItemsAllocated = 0;
        pAllocationList          = pElement;
        }

    return (NDR_POINTER_QUEUE_ELEMENT*)
        (NDR_POINTER_QUEUE_ELEMENT*)pAllocationList->Data[pAllocationList->ItemsAllocated++];
 
}

#if defined(BUILD_NDR64)

NDR_POINTER_QUEUE_ELEMENT *
NDR64_POINTER_QUEUE_STATE::Allocate()
{
    NDR_POINTER_QUEUE_ELEMENT *pNewElement;
    if ( pProcContext->pQueueFreeList )
        {
        pNewElement = pProcContext->pQueueFreeList;
        pProcContext->pQueueFreeList = pNewElement->pNext;
        }
    else
        {
        pNewElement = (NDR_POINTER_QUEUE_ELEMENT *)
            NdrpAlloca( &pProcContext->AllocateContext, 
                        NdrMaxPointerQueueElement );
        }
#if defined(DBG)
     memset( pNewElement, 0xDB, NdrMaxPointerQueueElement );
#endif

     return pNewElement;
}

void 
NDR64_POINTER_QUEUE_STATE::Free(
    NDR_POINTER_QUEUE_ELEMENT *pElement 
    ) 
{
    #if defined(DBG)
    memset( pElement, 0xBD, NdrMaxPointerQueueElement);
    #endif
    
    pElement->pNext = pProcContext->pQueueFreeList;
    pProcContext->pQueueFreeList = pElement;
}

#endif

inline NDR_POINTER_QUEUE::STORAGE::STORAGE( ) :
    pHead(NULL),
    pPrevHead(NULL),
    pPrevInsertPointer(NULL),
    pInsertPointer(&pHead)
{
}

inline void NDR_POINTER_QUEUE::STORAGE::MergeContext()
{
    // Add old list to end of this list.
    if ( pPrevHead )
        {
        // Append list
        *pInsertPointer = pPrevHead;
        // Set insert pointer to end of old list
        pInsertPointer = pPrevInsertPointer;
        }
    
    pPrevHead = NULL;
    pPrevInsertPointer = NULL;
}

inline void NDR_POINTER_QUEUE::STORAGE::NewContext()
{

    pPrevHead          = pHead;
    pPrevInsertPointer = pInsertPointer;

    pHead           = NULL;
    pInsertPointer  = &pHead;

}

inline void NDR_POINTER_QUEUE::STORAGE::InsertTail( NDR_POINTER_QUEUE_ELEMENT *pNewNode )
{
    *pInsertPointer = pNewNode;
    pNewNode->pNext = NULL;
    pInsertPointer  = &pNewNode->pNext;
}

inline NDR_POINTER_QUEUE_ELEMENT *NDR_POINTER_QUEUE::STORAGE::RemoveHead()
{

    NDR_POINTER_QUEUE_ELEMENT *pOldHead = pHead;

    if (!pHead)
        {
        return pHead;
        }

    if ( !pHead->pNext )
        {
        // Last item, reinitialize list. 
        pHead = NULL;
        pInsertPointer = &pHead->pNext;
        }
    else 
        {
        pHead = pHead->pNext;
        }

    return pOldHead;
}



#if defined(DBG)
ulong NdrPointerQueueLogLevel;
#endif

void NDR_POINTER_QUEUE::Enque( NDR_POINTER_QUEUE_ELEMENT * pElement )
{

    Storage.InsertTail( pElement );

#if defined(DBG)
    if ( NdrPointerQueueLogLevel )
        {
        DbgPrint( "Queing Element %p\n", pElement );
        pElement->Print();
        }
#endif

}

void NDR_POINTER_QUEUE::Dispatch()
{
    while ( 1 )
        {

        NDR_POINTER_QUEUE_ELEMENT *pHead = Storage.RemoveHead();

        if ( !pHead )
            return;

#if defined(DBG)
        if ( NdrPointerQueueLogLevel )
            {
            DbgPrint( "Dispatching Element: %p\n", pHead );
            pHead->Print();
            }
#endif
        
        Storage.NewContext();
        pHead->Dispatch( pStubMsg );
        pQueueState->Free( pHead );        
        Storage.MergeContext();

        }
}

NDR_POINTER_QUEUE::NDR_POINTER_QUEUE( PMIDL_STUB_MESSAGE pNewStubMsg,
                                      NDR_POINTER_QUEUE_STATE *pNewState ) :
    pStubMsg( pNewStubMsg ),
    Storage(),
    pQueueState(pNewState)
    {
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\pickle.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    pickle.cxx

Abstract:

    This module contains pickling related ndr library routines.

Notes:

Author:

    Ryszard K. Kott (ryszardk)  Oct 10, 1993

Revision History:

    ryszardk    Mar 17, 1994    Reworked for midl20


------------------------------------------------------------------------*/

#include <ndrp.h>
#include <rpcdcep.h>
#include "ndrtypes.h"
#include <midles.h>
#include <stdarg.h>
#include <malloc.h>
#include "interp2.h"
#include "mulsyntx.h"

#include "picklep.hxx"
#include "util.hxx" // PerformRpcInitialization

extern const MIDL_FORMAT_STRING __MIDLFormatString;

// DCE puts endianness on the low nibble in the pickling header.

#define NDR_LOCAL_ENDIAN_LOW    (NDR_LOCAL_ENDIAN >> 4)

RPC_STATUS
NdrpPerformRpcInitialization (
    void
    )
{
    return PerformRpcInitialization();
}




// =======================================================================
//    Handle validation
// =======================================================================

void
NdrpValidateMesHandle(
    PMIDL_ES_MESSAGE_EX  pMesMsgEx )
{
    RpcTryExcept
        {
        if ( pMesMsgEx == 0  ||  pMesMsgEx->Signature != MIDL_ES_SIGNATURE  ||
             pMesMsgEx->MesMsg.MesVersion != MIDL_ES_VERSION )
            RpcRaiseException( RPC_S_INVALID_ARG );
        }
    RpcExcept( 1 )
        {
        RpcRaiseException( RPC_S_INVALID_ARG );
        }
    RpcEndExcept
}

RPC_STATUS
NdrpValidateMesHandleReturnStatus(
    PMIDL_ES_MESSAGE_EX  pMesMsgEx )
{
    RPC_STATUS  Status = RPC_S_OK;

    RpcTryExcept
        {
        if ( pMesMsgEx == 0  ||  pMesMsgEx->Signature != MIDL_ES_SIGNATURE  ||
             ( pMesMsgEx->MesMsg.MesVersion != MIDL_ES_VERSION &&
               pMesMsgEx->MesMsg.MesVersion != MIDL_NDR64_ES_VERSION ) )
            Status = RPC_S_INVALID_ARG;
        }
    RpcExcept( 1 )
        {
        Status = RPC_S_INVALID_ARG;
        }
    RpcEndExcept

    return Status;
}



// =======================================================================
//    Handle allocation and freeing.
// =======================================================================

RPC_STATUS
NdrpHandleAllocate(
    handle_t *    pHandle )
/*++
    The reason for having this function here is that
    handle_t is a near pointer on win16 (but not on Dos),
    and we still compile the whole rpcndr20 large for that platform.
    So we need near malloc to be within the default segment.
--*/
{
    RPC_STATUS RpcStatus;

    if ( pHandle == NULL )
        return( RPC_S_INVALID_ARG );

    // Rpc mtrt heap allocation initialization (any platform).
    // This is a macro that returns from NdrpHandleAllocate with
    // out of memory error when it fails.
    // It's under an if only to facilitate testing.


    RpcStatus = NdrpPerformRpcInitialization();
    if ( RpcStatus != RPC_S_OK )
        return(RpcStatus);

    // Now allocate.
    // Mes handle includes stubmsg but we need to add rpcmsg to it.

    *pHandle = new char[ sizeof(MIDL_ES_MESSAGE_EX) ];

    if ( *pHandle == NULL )
        return( RPC_S_OUT_OF_MEMORY );
    return( RPC_S_OK );
}

RPC_STATUS  RPC_ENTRY
MesHandleFree( handle_t  Handle )
/*++
    This routine frees a pickling handle.
--*/
{
    if ( Handle)
        {
        delete Handle;
        }
    return( RPC_S_OK );
}

void RPC_ENTRY
I_NdrMesMessageInit(
    PMIDL_ES_MESSAGE_EX pMesMsgEx )
{
    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsgEx->MesMsg.StubMsg;
    PRPC_MESSAGE        pRpcMsg  = & pMesMsgEx->RpcMsg;

    MIDL_memset( pStubMsg, 0, sizeof(MIDL_STUB_MESSAGE) );
    MIDL_memset( pRpcMsg, 0, sizeof(RPC_MESSAGE) );

    pRpcMsg->DataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;

    pStubMsg->RpcMsg   = pRpcMsg;
    pStubMsg->IsClient = 1;

    NdrSetupLowStackMark( pStubMsg );
}


// =======================================================================

RPC_STATUS RPC_ENTRY
MesEncodeIncrementalHandleCreate(
    void     *    UserState,
    MIDL_ES_ALLOC           Alloc,
    MIDL_ES_WRITE           Write,
    handle_t *    pHandle )
/*++
    This routine creates an encoding incremental pickling handle.
--*/
{
    RPC_STATUS Status;

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_INCREMENTAL_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesIncrementalHandleReset( *pHandle,
                                                  UserState,
                                                  Alloc,
                                                  Write,
                                                  0,
                                                  MES_ENCODE )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}

RPC_STATUS RPC_ENTRY
MesDecodeIncrementalHandleCreate(
    void     *      UserState,
    MIDL_ES_READ    Read,
    handle_t *      pHandle )
/*++
    This routine creates a descoding incrementsl pickling handle.
--*/
{
    RPC_STATUS Status;

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_INCREMENTAL_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesIncrementalHandleReset( *pHandle,
                                                  UserState,
                                                  0,
                                                  0,
                                                  Read,
                                                  MES_DECODE )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}


RPC_STATUS  RPC_ENTRY
MesIncrementalHandleReset(
    handle_t           Handle,
    void *             UserState,
    MIDL_ES_ALLOC      Alloc,
    MIDL_ES_WRITE      Write,
    MIDL_ES_READ       Read,
    MIDL_ES_CODE       Operation )
/*++
    This routine initializes a pickling handle with supplied arguments.
--*/
{
    RPC_STATUS  Status;

    Status = NdrpValidateMesHandleReturnStatus( (PMIDL_ES_MESSAGE_EX)Handle );
    if ( Status != RPC_S_OK )
        return Status;

    PMIDL_ES_MESSAGE  pMesMsg = (PMIDL_ES_MESSAGE) Handle;

    // we support ndr64 pickling now.
    if ( Handle == NULL  ||
         pMesMsg->HandleStyle != MES_INCREMENTAL_HANDLE  ||
         ( Operation != MES_ENCODE  &&  
           Operation != MES_DECODE  &&
           Operation != MES_ENCODE_NDR64 &&
           Operation != MES_DECODE_NDR64 ) )
        return( RPC_S_INVALID_ARG );

    I_NdrMesMessageInit( (PMIDL_ES_MESSAGE_EX) Handle );

    pMesMsg->Operation  = Operation;
    pMesMsg->HandleFlags = 0;
    pMesMsg->ByteCount = 0;
    if ( Operation == MES_ENCODE_NDR64 ||
         Operation == MES_DECODE_NDR64 )
        {
        pMesMsg->MesVersion  = MIDL_NDR64_ES_VERSION;
        }
    else
        {
        pMesMsg->MesVersion  = MIDL_ES_VERSION;
        }

    if ( UserState )
        pMesMsg->UserState = UserState;
    if ( Alloc )
        pMesMsg->Alloc = Alloc;
    if ( Write )
        pMesMsg->Write = Write;
    if ( Read )
        pMesMsg->Read  = Read;

    if ( ( (Operation == MES_ENCODE || Operation == MES_ENCODE_NDR64 ) &&
             (pMesMsg->Alloc == NULL  ||  pMesMsg->Write == NULL) ) ||
         ( (Operation == MES_DECODE  || Operation == MES_DECODE_NDR64 ) && 
            (pMesMsg->Read == NULL))  )
        return( RPC_S_INVALID_ARG );

    return( RPC_S_OK );
}


RPC_STATUS  RPC_ENTRY
MesEncodeFixedBufferHandleCreate(
    char *            Buffer,
    unsigned long     BufferSize,
    unsigned long *   pEncodedSize,
    handle_t  *       pHandle )
{
    RPC_STATUS Status;

    if( (LONG_PTR)Buffer & 0x7 )
        return( RPC_X_INVALID_BUFFER );

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_FIXED_BUFFER_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesBufferHandleReset( *pHandle,
                                             MES_FIXED_BUFFER_HANDLE,
                                             MES_ENCODE,
                                             & Buffer,
                                             BufferSize,
                                             pEncodedSize )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}

RPC_STATUS  RPC_ENTRY
MesEncodeDynBufferHandleCreate(
    char             ** pBuffer,
    unsigned long    *  pEncodedSize,
    handle_t         *  pHandle )
{
    RPC_STATUS Status;

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_DYNAMIC_BUFFER_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesBufferHandleReset( *pHandle,
                                             MES_DYNAMIC_BUFFER_HANDLE,
                                             MES_ENCODE,
                                             pBuffer,
                                             0,
                                             pEncodedSize )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}

RPC_STATUS  RPC_ENTRY
MesDecodeBufferHandleCreate(
    char *          Buffer,
    unsigned long   BufferSize,
    handle_t  *     pHandle )
{
    if ( Buffer == NULL  ||
         BufferSize < MES_CTYPE_HEADER_SIZE + 8 )
        return( RPC_S_INVALID_ARG );

    if( (LONG_PTR)Buffer & 0x7 )
        return( RPC_X_INVALID_BUFFER );

    RPC_STATUS Status;

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_FIXED_BUFFER_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesBufferHandleReset( *pHandle,
                                             MES_FIXED_BUFFER_HANDLE,
                                             MES_DECODE,
                                             & Buffer,
                                             BufferSize,
                                             0            )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}


// reset a pickling handle. 
RPC_STATUS  RPC_ENTRY
MesBufferHandleReset(
    handle_t            Handle,
    unsigned long       HandleStyle,
    MIDL_ES_CODE        Operation,
    char * *            pBuffer,
    unsigned long       BufferSize,
    unsigned long *     pEncodedSize )
{
    RPC_STATUS  Status;

    Status = NdrpValidateMesHandleReturnStatus( (PMIDL_ES_MESSAGE_EX)Handle );
    if ( Status != RPC_S_OK )
        return Status;

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;

    if ( Handle == NULL ||  pBuffer == NULL  ||
        ( HandleStyle != MES_FIXED_BUFFER_HANDLE  &&
            HandleStyle != MES_DYNAMIC_BUFFER_HANDLE )  ||
        (HandleStyle == MES_FIXED_BUFFER_HANDLE  &&
            (*pBuffer == NULL  ||  BufferSize < MES_MINIMAL_BUFFER_SIZE)) ||
        (Operation == MES_ENCODE  &&  pEncodedSize == NULL)  ||
        (Operation == MES_DECODE  &&
            (*pBuffer == NULL  ||  BufferSize < MES_MINIMAL_BUFFER_SIZE))
       )
        return( RPC_S_INVALID_ARG );

    if ( (Operation == MES_ENCODE_NDR64  &&  pEncodedSize == NULL)  ||
        (Operation == MES_DECODE_NDR64  &&
            (*pBuffer == NULL  ||  BufferSize < MES_MINIMAL_NDR64_BUFFER_SIZE ) ) )
        return( RPC_S_INVALID_ARG );

    I_NdrMesMessageInit( (PMIDL_ES_MESSAGE_EX) Handle );

    pMesMsg->Operation  = Operation;
    pMesMsg->HandleFlags = 0;
    pMesMsg->HandleStyle = HandleStyle;
    pMesMsg->ByteCount = 0;
    if ( Operation == MES_ENCODE_NDR64 ||
         Operation == MES_DECODE_NDR64 )
        {
        pMesMsg->MesVersion  = MIDL_NDR64_ES_VERSION;
        }
    else
        {
        pMesMsg->MesVersion  = MIDL_ES_VERSION;
        }


    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsg->StubMsg;
    PRPC_MESSAGE        pRpcMsg  =   pMesMsg->StubMsg.RpcMsg;

    if ( HandleStyle == MES_FIXED_BUFFER_HANDLE)
        {
        pMesMsg->Buffer         = (uchar *)*pBuffer;

        pRpcMsg->BufferLength = BufferSize;
        pRpcMsg->Buffer       = *pBuffer;

        pStubMsg->Buffer      = (uchar *)*pBuffer;
        pStubMsg->BufferStart = (uchar *)*pBuffer;
        pStubMsg->BufferEnd   = (uchar *)*pBuffer + BufferSize;
        }
    if ( HandleStyle == MES_DYNAMIC_BUFFER_HANDLE)
        {
        pMesMsg->pDynBuffer = (uchar **)pBuffer;
        if (Operation == MES_DECODE || Operation == MES_DECODE_NDR64 )
            {
            pMesMsg->Buffer       = (uchar *)*pBuffer;

            pRpcMsg->BufferLength = BufferSize;
            pRpcMsg->Buffer       = *pBuffer;

            pStubMsg->Buffer      = (uchar *)*pBuffer;
            pStubMsg->BufferStart = (uchar *)*pBuffer;
            pStubMsg->BufferEnd   = (uchar *)*pBuffer + BufferSize;
            }
        else
            {
            *pBuffer = NULL;

            pRpcMsg->BufferLength = 0;
            pRpcMsg->Buffer       = 0;

            pStubMsg->Buffer      = 0;
            pStubMsg->BufferStart = 0;
            pStubMsg->BufferEnd   = 0;
            }
        }
    pMesMsg->BufferSize = BufferSize;
    pMesMsg->pEncodedSize = pEncodedSize;

    return( RPC_S_OK );
}


RPC_STATUS  RPC_ENTRY
MesInqProcEncodingId(
    handle_t                Handle,
    PRPC_SYNTAX_IDENTIFIER  pInterfaceId,
    unsigned long *         pProcNumber )
/*++

    The routine returns an informantion about the last proc encoding.
    Called before an encode, it should return RPC_X_INVALID_ES_ACTION.
    Called after an encode, it should return the last encoding info.
    Called before a decode, it should return the same encoding info.
    Called after a decode, it should return the just decoded encode info.

--*/
{
    RPC_STATUS  Status;

    Status = NdrpValidateMesHandleReturnStatus( (PMIDL_ES_MESSAGE_EX)Handle );
    if ( Status != RPC_S_OK )
        return Status;

    PMIDL_ES_MESSAGE  pMesMsg = (PMIDL_ES_MESSAGE) Handle;

    Status  = RPC_X_INVALID_ES_ACTION;

    if ( Handle == NULL  ||  pInterfaceId == NULL  ||  pProcNumber == NULL )
        return( RPC_S_INVALID_ARG );

    RpcTryExcept
        {
        // Note: because we allow to pickle several procs into the same buffer
        // (using the same handle without resetting), the PEEKED bit may be
        // cleared and the info may still be available.
        // On the other hand, the info bit is always set if we unmarshaled
        // a header. So check the info bit first.

        if ( pMesMsg->Operation == MES_DECODE  &&
             ! GET_MES_INFO_AVAILABLE( pMesMsg ) &&
             ! GET_MES_HEADER_PEEKED( pMesMsg ) )
            {
            NdrpProcHeaderUnmarshallAll( pMesMsg );
            SET_MES_HEADER_PEEKED( pMesMsg );
            }
            
        if ( GET_MES_INFO_AVAILABLE( pMesMsg ) )
            {
            RpcpMemoryCopy( pInterfaceId,
                            & pMesMsg->InterfaceId,
                            sizeof( RPC_SYNTAX_IDENTIFIER ) );
            *pProcNumber = pMesMsg->ProcNumber;
            Status =  RPC_S_OK;
            }
        // else Status = RPC_X_INVALID_ES_ACTION;
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept

    return( Status );
}


// =======================================================================
//
//   Private Alloc, Read, Write helper routines
//
// =======================================================================

void
NdrpAllocPicklingBuffer(
    PMIDL_ES_MESSAGE    pMesMsg,
    unsigned int        RequiredLen
    )
{
    unsigned int ActualLen;

    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    // Get the marshalling buffer.

    // alert: assuming the return buffer is aligned at 16 in 64bit platform. 
    // ndr64 buffer needs to be aligned at 16.
    switch ( pMesMsg->HandleStyle )
        {
        case MES_INCREMENTAL_HANDLE:
            // Allocating the pickling buffer.

            ActualLen = RequiredLen;
            (pMesMsg->Alloc)( pMesMsg->UserState,
                              (char * *) & pStubMsg->Buffer,
                              & ActualLen );
            if ( ActualLen < RequiredLen )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );

            pStubMsg->RpcMsg->BufferLength = ActualLen;
            pStubMsg->RpcMsg->Buffer       = pStubMsg->Buffer;

            pStubMsg->BufferStart = pStubMsg->Buffer;
            pStubMsg->BufferEnd   = pStubMsg->Buffer + ActualLen;
            break;

        case MES_FIXED_BUFFER_HANDLE:
            break;

        case MES_DYNAMIC_BUFFER_HANDLE:
            {
            // We have to return one buffer for multiple encodings,
            // and a cumulative size along with it.
            // So, we check if we have to copy data to a new buffer.

            uchar * pOldBufferToCopy = NULL;

            if ( pMesMsg->ByteCount )
                {
                RequiredLen += pMesMsg->ByteCount;
                pOldBufferToCopy = *pMesMsg->pDynBuffer;
                }

            pStubMsg->Buffer = (uchar *) pStubMsg->pfnAllocate( RequiredLen );
            if ( pStubMsg->Buffer == NULL )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );

            if ( pOldBufferToCopy )
                {
                RpcpMemoryCopy( pStubMsg->Buffer,
                                pOldBufferToCopy,
                                pMesMsg->ByteCount );

                pStubMsg->pfnFree( pOldBufferToCopy );
                }

            pStubMsg->RpcMsg->BufferLength = RequiredLen;
            pStubMsg->RpcMsg->Buffer       = pStubMsg->Buffer;

            pStubMsg->BufferStart = pStubMsg->Buffer;
            pStubMsg->BufferEnd   = pStubMsg->Buffer + RequiredLen;

            * pMesMsg->pDynBuffer = pStubMsg->Buffer;
            pMesMsg->BufferSize = RequiredLen;

            // We write after the previously written buffer.

            pStubMsg->Buffer += pMesMsg->ByteCount;
            break;
            }
        }

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );
}

void
NdrpReadPicklingBuffer(
    PMIDL_ES_MESSAGE    pMesMsg,
    unsigned int        RequiredLen
    )
{
    unsigned int ActualLen;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    // Read the marshalling buffer.

    if ( pMesMsg->HandleStyle  == MES_INCREMENTAL_HANDLE )
        {
            // Allocating the pickling buffer.

            ActualLen = RequiredLen;
            (pMesMsg->Read)( pMesMsg->UserState,
                             (char **) & pStubMsg->Buffer,
                             & ActualLen );
            if ( ActualLen < RequiredLen )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );

            pStubMsg->RpcMsg->BufferLength = ActualLen;
            pStubMsg->RpcMsg->Buffer       = pStubMsg->Buffer;

            pStubMsg->BufferStart = pStubMsg->Buffer;
            pStubMsg->BufferEnd   = pStubMsg->Buffer + ActualLen;
        }

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );
}

void
NdrpWritePicklingBuffer(
    PMIDL_ES_MESSAGE    pMesMsg,
    uchar *             pBuffer,
    size_t              WriteLength
    )
{
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    NDR_ASSERT( ! ((LONG_PTR)pStubMsg->Buffer & 0x7), "Misaligned buffer" );
    NDR_ASSERT( ! (WriteLength & 0x7 ), "Length should be multiple of 8" );

    // Write the marshalling buffer.

    if ( pMesMsg->HandleStyle == MES_INCREMENTAL_HANDLE )
        {
        (pMesMsg->Write)( pMesMsg->UserState,
                          (char * ) pBuffer,
                          WriteLength );
        }
    else
        {
        // We return the cumulative length both for the fixed buffer
        // and for the dynamic buffer style.

        pMesMsg->ByteCount += WriteLength;
        * pMesMsg->pEncodedSize = pMesMsg->ByteCount;
        }
}



// =======================================================================
//
//   One call generic routine pickling.
//
// =======================================================================


void
NdrpProcHeaderMarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    // Marshall DCE pickle header.

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    * pStubMsg->Buffer++ = MIDL_ES_VERSION;
    * pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN_LOW;
    *( PSHORT_LV_CAST pStubMsg->Buffer)++ = (short)0xcccc;    // filler

    // Marshall transfer syntax from the stub.

    RpcpMemoryCopy( pStubMsg->Buffer,
                    & ((PRPC_CLIENT_INTERFACE)(pStubMsg->
                          StubDesc->RpcInterfaceInformation))->TransferSyntax,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

    // We need to remember InterfaceId for inquiries.

    RpcpMemoryCopy( & pMesMsg->InterfaceId,
                    & ((PRPC_CLIENT_INTERFACE)(pStubMsg->
                         StubDesc->RpcInterfaceInformation))->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

   // Marshall InterfaceId and ProcNumber from the handle.

    RpcpMemoryCopy( pStubMsg->Buffer + sizeof(RPC_SYNTAX_IDENTIFIER),
                    & pMesMsg->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long) );

    SET_MES_INFO_AVAILABLE( pMesMsg );

    pStubMsg->Buffer += 2 * sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long);

    * pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN_LOW;
    * pStubMsg->Buffer++ = NDR_ASCII_CHAR;
    * pStubMsg->Buffer++ = (char) (NDR_IEEE_FLOAT >> 8);
    * pStubMsg->Buffer++ = 0;   // filler

    // This is non-DCE element as they have just 4 more bytes of filler here.
    // This field is used only when unmarshalling in our incremental style.

    *( PLONG_LV_CAST pStubMsg->Buffer)++ = pStubMsg->BufferLength -
                                                   MES_PROC_HEADER_SIZE;
}

void
NdrpProcHeaderUnmarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    unsigned char *         BufferToRestore;
    PMIDL_STUB_MESSAGE      pStubMsg = &pMesMsg->StubMsg;

    if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
        return;

    NdrpReadPicklingBuffer( pMesMsg, MES_PROC_HEADER_SIZE );

    // Unmarshalling the header

    if ( *pStubMsg->Buffer != MIDL_ES_VERSION )
        RpcRaiseException( RPC_X_WRONG_ES_VERSION );

    BufferToRestore = pStubMsg->Buffer + 4;

    if ( pStubMsg->Buffer[1] != NDR_LOCAL_ENDIAN_LOW )
        {
        // The DCE header has the endianness on the low nibble, while
        // our DataRep has it on the high nibble.
        // We need only endianess to convert the proc header.

        byte Endianness = (pStubMsg->Buffer[1] << 4 );

        pStubMsg->RpcMsg->DataRepresentation = Endianness;

        pStubMsg->Buffer += 4;
        NdrSimpleStructConvert( pStubMsg,
                                &__MIDLFormatString.Format[32],
                                FALSE );
        }

    pStubMsg->Buffer = BufferToRestore;

    // Verify the transfer syntax

    if ( NULL != pStubMsg->StubDesc )
        {
        if (0 != RpcpMemoryCompare( 
                        pStubMsg->Buffer,
                        & ((PRPC_CLIENT_INTERFACE)(pStubMsg->
                            StubDesc->RpcInterfaceInformation))->
TransferSyntax,
                        sizeof(RPC_SYNTAX_IDENTIFIER) ) )
            {
            RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );
            } 
        }

    RpcpMemoryCopy( &((PMIDL_ES_MESSAGE_EX)pMesMsg)->TransferSyntax, 
                      pStubMsg->Buffer,
                      sizeof( RPC_SYNTAX_IDENTIFIER ) );

    pStubMsg->Buffer += sizeof(RPC_SYNTAX_IDENTIFIER);

    // We need to remember the last InterfaceId and ProcNumber for inquiries.

    RpcpMemoryCopy( & pMesMsg->InterfaceId,
                    pStubMsg->Buffer,
                    sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long) );

    pStubMsg->Buffer += sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long);

    SET_MES_INFO_AVAILABLE( pMesMsg );

    unsigned long AlienDataRepresentation =
                        ( (pStubMsg->Buffer[0] << 4)  |           // endianness
                          pStubMsg->Buffer[1]  |                       // chars
                        ((unsigned long)(pStubMsg->Buffer[2]) << 8) ); // float
    pMesMsg->AlienDataRep = AlienDataRepresentation;
    pMesMsg->IncrDataSize = (size_t) *(unsigned long *)
                                                (pStubMsg->Buffer + 4);
    pStubMsg->Buffer += 8;
}

void
NdrpDataBufferInit(
    PMIDL_ES_MESSAGE    pMesMsg,
    PFORMAT_STRING      pProcFormat
    )
{
    size_t              RequiredLen;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        pStubMsg->RpcMsg->DataRepresentation = pMesMsg->AlienDataRep;
        NdrConvert( pStubMsg, pProcFormat );
        }

    // When incremental, this is the non-DCE buffer size.
    // For non incremental RequiredLen will be ignored.

    RequiredLen = pMesMsg->IncrDataSize;

    NdrpReadPicklingBuffer( pMesMsg, RequiredLen );

    pStubMsg->pfnAllocate = pStubMsg->StubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubMsg->StubDesc->pfnFree;
}


void  RPC_VAR_ENTRY
NdrMesProcEncodeDecode(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    ...
    )
/*++

Routine description:

    Sizes and marshalls [in] arguments, unmarshalls [out] arguments.
    Includes a routine header.

Arguments:

    Handle      - a pickling handle
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type.

Note:

    Please note that all the ... arguments here are pointers.
    We will handle them appropriately to access the original arguments.

    The pickling header for the routine is included in the sizing.

--*/
{
    BOOL                fMoreParams;
    PFORMAT_STRING      pProcFormat;
    void            *   pArg;
    va_list             ArgList;
    unsigned char   *   BufferSaved;
    size_t              WriteLength;

    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg  = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsg->StubMsg;

    NDR_ASSERT( *pFormat == FC_BIND_PRIMITIVE  ||  *pFormat == 0,
                "Pickling handle expected" );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    BOOL fEncodeUsed = (pFormat[1] & ENCODE_IS_USED)  &&
                       pMesMsg->Operation == MES_ENCODE;
    BOOL fDecodeUsed = (pFormat[1] & DECODE_IS_USED)  &&
                       pMesMsg->Operation == MES_DECODE;

    NDR_ASSERT( !( fEncodeUsed && fDecodeUsed ),
                "Both encode & decode at the same time" );

    if ( !fEncodeUsed && !fDecodeUsed )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    pStubMsg->FullPtrXlatTables = ( (pFormat[1]  &  Oi_FULL_PTR_USED)
                                    ?  NdrFullPointerXlatInit( 0, XLAT_CLIENT )
                                    :  0 );

    pFormat += HAS_RPCFLAGS(pFormat[1]) ? 6
                                        : 2;

    // We use the proc number only to support MesInqEncodingId. So, set it for
    // encoding only. When decoding it will get picked up from the header.
    //
    if ( fEncodeUsed )
        pMesMsg->ProcNumber = * (unsigned short *) pFormat;

    pFormat +=4;

    if ( *pFormat == FC_BIND_PRIMITIVE )
        pFormat += 4;

    if ( fEncodeUsed )
        {
        //
        // The sizing walk.
        //

        pStubMsg->BufferLength = MES_PROC_HEADER_SIZE;

        // We will be walking this routine's stack.
        // However, for the engine to be able to calculate conformant arrays
        // and such, top of the original routine's stack has to be available
        // via the stub message.

        INIT_ARG( ArgList, pFormat );
        GET_FIRST_ARG( pArg, ArgList );

        pStubMsg->StackTop = *(uchar * *)pArg;
        pProcFormat = pFormat;
        fMoreParams = TRUE;

        for ( ; fMoreParams ; pProcFormat += 2 )
            {
            switch ( *pProcFormat )
                {
                case FC_OUT_PARAM:
                    break;

                case FC_RETURN_PARAM:
                    fMoreParams = FALSE;
                    break;
                default:
                    fMoreParams = FALSE;
                    break;

                case FC_IN_PARAM_BASETYPE :

                    LENGTH_ALIGN( pStubMsg->BufferLength,
                                SIMPLE_TYPE_ALIGNMENT( pProcFormat[1] ));
                    pStubMsg->BufferLength +=
                                SIMPLE_TYPE_BUFSIZE( pProcFormat[1] );
                    break;

                case FC_IN_PARAM:
                case FC_IN_PARAM_NO_FREE_INST:

                    // Other [in] types than simple or ignore
                    // fall through to [in,out].

                case FC_IN_OUT_PARAM:
                    {
                    uchar *         pOrigArg = *(uchar * *)pArg;
                    PFORMAT_STRING  pTypeFormat;
                    unsigned char   FcType;


                    pProcFormat += 2;
                    pTypeFormat = pStubDesc->pFormatTypes +
                                                *(signed short *) pProcFormat;
                    FcType = *pTypeFormat;

                    if ( ! IS_BY_VALUE( FcType ) )
                        pOrigArg = *(uchar * *)pOrigArg;

                    (*pfnSizeRoutines[ ROUTINE_INDEX( FcType ) ])( pStubMsg,
                                                                   pOrigArg,
                                                                   pTypeFormat );
                    }
                    break;
                }

            GET_NEXT_ARG( pArg, ArgList );
            }   // for

        LENGTH_ALIGN( pStubMsg->BufferLength, 7 );

        size_t  LengthSaved;

        NdrpAllocPicklingBuffer( pMesMsg, pStubMsg->BufferLength );
        BufferSaved = pStubMsg->Buffer;
        LengthSaved = pStubMsg->BufferLength;

        //
        // Marshalling.
        //

        NdrpProcHeaderMarshall( pMesMsg );

        INIT_ARG( ArgList, pFormat );
        GET_FIRST_ARG( pArg, ArgList );

        pProcFormat = pFormat;
        fMoreParams = TRUE;

        for ( ; fMoreParams ; pProcFormat += 2 )
            {
            switch ( *pProcFormat )
                {
                case FC_OUT_PARAM:
                    break;

                case FC_RETURN_PARAM:
                default:
                    fMoreParams = FALSE;
                    break;

                case FC_IN_PARAM_BASETYPE :

                    NdrSimpleTypeMarshall( pStubMsg,
                                           *(uchar * *)pArg,
                                           pProcFormat[1] );
                    break;

                case FC_IN_PARAM:
                case FC_IN_PARAM_NO_FREE_INST:
                case FC_IN_OUT_PARAM:
                    {
                    uchar *         pOrigArg = *(uchar * *)pArg;
                    PFORMAT_STRING  pTypeFormat;
                    unsigned char   FcType;

                    pProcFormat += 2;
                    pTypeFormat = pStubDesc->pFormatTypes +
                                                *(signed short *) pProcFormat;
                    FcType = *pTypeFormat;

                    if ( ! IS_BY_VALUE( FcType ) )
                        pOrigArg = *(uchar * *)pOrigArg;

                    (*pfnMarshallRoutines[ ROUTINE_INDEX( FcType )])( pStubMsg,
                                                                      pOrigArg,
                                                                      pTypeFormat );
                    }
                    break;
                }

            GET_NEXT_ARG( pArg, ArgList );
            }

        // Next encoding (if any) starts at aligned to 8.

        ALIGN( pStubMsg->Buffer, 7 );

        // Now manage the actual size of encoded data.

        WriteLength = (size_t)(pStubMsg->Buffer - BufferSaved);
        * (unsigned long *)
                ( BufferSaved + MES_PROC_HEADER_SIZE - 4) =
                                    WriteLength - MES_PROC_HEADER_SIZE;

        if ( LengthSaved < WriteLength )
            {
            NDR_ASSERT( 0, "NdrMesProcEncodeDecode: encode buffer overflow" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            }

        NdrpWritePicklingBuffer( pMesMsg, BufferSaved, WriteLength );
        }

    if ( fDecodeUsed )
        {
        //
        // Unmarshalling.
        //

        if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
            {
            // This makes it possible to encode/decode several procs one after
            // another with the same pickling handle (using the same buffer).

            CLEAR_MES_HEADER_PEEKED( pMesMsg );
            }
        else
            NdrpProcHeaderUnmarshall( pMesMsg );

        NdrpDataBufferInit( pMesMsg, pFormat );

        INIT_ARG( ArgList, pFormat );
        GET_FIRST_ARG( pArg, ArgList );

        pStubMsg->StackTop = *(uchar * *)pArg;
        pProcFormat = pFormat;
        fMoreParams = TRUE;

        for ( ; fMoreParams ; pProcFormat += 2 )
            {
            switch ( *pProcFormat )
                {
                case FC_IN_PARAM_BASETYPE :
                case FC_IN_PARAM:
                case FC_IN_PARAM_NO_FREE_INST:
                    break;

                default:
                    fMoreParams = FALSE;
                    break;

                case FC_RETURN_PARAM_BASETYPE :

                    NdrSimpleTypeUnmarshall( pStubMsg,
                                             *(uchar * *)pArg,
                                             pProcFormat[1] );
                    fMoreParams = FALSE;
                    break;

                case FC_RETURN_PARAM:
                    fMoreParams = FALSE;

                    // fall through to out params.

                case FC_IN_OUT_PARAM:
                case FC_OUT_PARAM:
                    {
                    uchar *         pOrigArg = *(uchar * *)pArg;
                    PFORMAT_STRING  pTypeFormat;
                    unsigned char   FcType;

                    pProcFormat += 2;
                    pTypeFormat = pStubDesc->pFormatTypes +
                                                *(signed short *) pProcFormat;
                    FcType = *pTypeFormat;

                    if ( IS_STRUCT( FcType )  ||  IS_UNION( FcType)  ||
                         IS_XMIT_AS( FcType ) )
                        {
                        // All these are possible only as a return value.
                        pOrigArg = (uchar *) &pOrigArg;
                        }
                    else
                        pOrigArg = (uchar *)pOrigArg;

                    (*pfnUnmarshallRoutines[ ROUTINE_INDEX( FcType )])(
                        pStubMsg,
                        (uchar * *)pOrigArg,
                        pTypeFormat,
                        FALSE );
                    }
                    break;
                }

            GET_NEXT_ARG( pArg, ArgList );
            }   // for

            // Next decoding (if any) starts at aligned to 8.

            ALIGN( pStubMsg->Buffer, 7 );

        }   // if decode

    NdrFullPointerXlatFree( pStubMsg->FullPtrXlatTables );
}


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrMesProcEncodeDecode2(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    )
{
    va_list                     ArgList;
    uchar *                     StartofStack;
    PFORMAT_STRING              pFormatParam;
    CLIENT_CALL_RETURN          ReturnValue;
    ulong                       ProcNum;
    uchar *                     pArg;
    void *                      pThis;
    PFORMAT_STRING              pProcFormat = pFormat;
    unsigned char *             BufferSaved;
    size_t                      WriteLength;
    NDR_PROC_CONTEXT            ProcContext;
    PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;

    ReturnValue.Pointer = 0;

    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    //
    INIT_ARG( ArgList, pFormat);

    //
    // Get the address of the stack where the parameters are.
    //
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *) GET_STACK_START(ArgList);

    // StartofStack points to the virtual stack at this point.

    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg  = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsg->StubMsg;

    NDR_ASSERT( *pFormat == FC_BIND_PRIMITIVE  ||  *pFormat == 0,
                "Pickling handle expected" );

    pStubMsg->StubDesc = pStubDescriptor;
    pStubMsg->pfnAllocate = pStubDescriptor->pfnAllocate;
    pStubMsg->pfnFree     = pStubDescriptor->pfnFree;

    ProcNum = MulNdrpInitializeContextFromProc( XFER_SYNTAX_DCE, pFormat, &ProcContext, StartofStack );

    BOOL fEncodeUsed = ( * ( ( uchar *)&ProcContext.NdrInfo.InterpreterFlags ) & ENCODE_IS_USED )  &&
                       pMesMsg->Operation == MES_ENCODE;
    BOOL fDecodeUsed = ( * ( ( uchar *)&ProcContext.NdrInfo.InterpreterFlags ) & DECODE_IS_USED )  &&
                       pMesMsg->Operation == MES_DECODE;

    NDR_ASSERT( !( fEncodeUsed && fDecodeUsed ),
                "Both encode & decode at the same time" );

    if ( !fEncodeUsed && !fDecodeUsed )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( fEncodeUsed )
    pMesMsg->ProcNumber = ProcNum;


   // Must do this before the sizing pass!
   pStubMsg->StackTop = StartofStack;
   pStubMsg->pContext = &ProcContext;

   RpcTryFinally
        {

        // We don't really need to zeroout here, but code is much more cleaner this way, 
        // and ObjectProc is the first check anyhow.
        NdrpClientInit( pStubMsg, &ReturnValue );
        if (fEncodeUsed)
            {

            //
            // ----------------------------------------------------------------
            // Sizing Pass.
            // ----------------------------------------------------------------
            //

            pStubMsg->BufferLength += MES_PROC_HEADER_SIZE;

            //
            // Skip buffer size pass if possible.
            //
            if ( ProcContext.NdrInfo.pProcDesc->Oi2Flags.ClientMustSize )
                {
                NdrpSizing( pStubMsg, 
                            TRUE );     // IsClient
                }

            LENGTH_ALIGN( pStubMsg->BufferLength, 7 );

            size_t  LengthSaved;

            NdrpAllocPicklingBuffer( pMesMsg, pStubMsg->BufferLength );
            BufferSaved = pStubMsg->Buffer;
            LengthSaved = pStubMsg->BufferLength;

            NdrpProcHeaderMarshall( pMesMsg );

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            NdrpClientMarshal( pStubMsg,
                               FALSE ); // IsObject
                           

            // Next encoding (if any) starts at aligned to 8.

            ALIGN( pStubMsg->Buffer, 7 );

            // Now manage the actual size of encoded data.

            WriteLength = (size_t)(pStubMsg->Buffer - BufferSaved);
            * (unsigned long *) ( BufferSaved + MES_PROC_HEADER_SIZE - 4) =
                                    WriteLength - MES_PROC_HEADER_SIZE;

            if ( LengthSaved < WriteLength )
                {
                NDR_ASSERT( 0, "NdrMesProcEncodeDecode: encode buffer overflow" );
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                }

            NdrpWritePicklingBuffer( pMesMsg, BufferSaved, WriteLength );
            }


        if (fDecodeUsed)
            {
            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //

            if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
                {
                // This makes it possible to encode/decode several procs one after
                // another with the same pickling handle (using the same buffer).
    
                CLEAR_MES_HEADER_PEEKED( pMesMsg );
                }
            else    
                NdrpProcHeaderUnmarshall( pMesMsg );
       
            NdrpDataBufferInit( pMesMsg, pFormat );

            NdrpClientUnMarshal( pStubMsg,
                             &ReturnValue );

            // Next decoding (if any) starts at aligned to 8.

            ALIGN( pStubMsg->Buffer, 7 );

            } // if decode

        }
    RpcFinally
        {

        NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

        NdrCorrelationFree( pStubMsg );
        }
   RpcEndFinally

    return ReturnValue;
}


// =======================================================================
//
//   Generic type pickling routines (for non-simple types).
//
// =======================================================================

void
NdrpCommonTypeHeaderSize(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    // This check is to prevent a decoding handle from being used
    // for both encoding and sizing of types.

    if ( pMesMsg->Operation != MES_ENCODE )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( ! GET_COMMON_TYPE_HEADER_SIZED( pMesMsg ) )
        {
        pMesMsg->StubMsg.BufferLength += MES_CTYPE_HEADER_SIZE;

        SET_COMMON_TYPE_HEADER_SIZED( pMesMsg );
        }
}


size_t  RPC_ENTRY
NdrMesTypeAlignSize2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo, 
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormat,
    const void *                    pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )
        
    pStubMsg->fHasExtensions  = 1;

    if ( pPicklingInfo->Flags.HasNewCorrDesc )
        {
        void * pCorrInfo = alloca( NDR_DEFAULT_CORR_CACHE_SIZE );

        NdrCorrelationInitialize( pStubMsg,
                        (unsigned long *) pCorrInfo,
                        NDR_DEFAULT_CORR_CACHE_SIZE,
                        0 /* flags */ );
        }

    return NdrMesTypeAlignSize(Handle, pStubDesc, pFormat, pObject);
}

size_t  RPC_ENTRY
NdrMesTypeAlignSize(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    const void *            pObject
    )
/*++

Routine description:

    Calculates the buffer size of the object relative to the current state
    of the pickling handle.

Arguments:

    Handle      - a pickling handle,
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type
    pObject     - a pointer to the object being sized.

Returns:

    The size.

Note:

    The pickling header is included in the sizing.

--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE)Handle)->StubMsg;
    size_t             OldLength = pStubMsg->BufferLength;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (long)pStubMsg->BufferLength & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    // See if we need to size the common type header.

    NdrpCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );

    // Now the individual type object.

    pStubMsg->BufferLength += MES_HEADER_SIZE;

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void * *)pObject;
        }

    (*pfnSizeRoutines[ ROUTINE_INDEX(*pFormat) ])
                                        ( pStubMsg,
                                        (uchar *)pObject,
                                        pFormat );

   LENGTH_ALIGN( pStubMsg->BufferLength, 7 );

   return( pStubMsg->BufferLength - OldLength );
}



size_t
NdrpCommonTypeHeaderMarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
/*++
    Returns the space used by the common header.
--*/
{
    if ( ! GET_COMMON_TYPE_HEADER_IN( pMesMsg ) )
        {
        PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

        MIDL_memset( pStubMsg->Buffer, 0xcc, MES_CTYPE_HEADER_SIZE );

        *pStubMsg->Buffer++ = MIDL_ES_VERSION;
        *pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN;
        * PSHORT_CAST pStubMsg->Buffer = MES_CTYPE_HEADER_SIZE;

        pStubMsg->Buffer += MES_CTYPE_HEADER_SIZE - 2;

        SET_COMMON_TYPE_HEADER_IN( pMesMsg );
        return( MES_CTYPE_HEADER_SIZE );
        }

    return( 0 );
}


void  RPC_ENTRY
NdrMesTypeEncode2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormat,
    const void *                    pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    pStubMsg->fHasExtensions  = 1;

    if ( pPicklingInfo->Flags.HasNewCorrDesc )
        {
        void * pCorrInfo = alloca( NDR_DEFAULT_CORR_CACHE_SIZE );

        NdrCorrelationInitialize( pStubMsg,
                        (unsigned long *) pCorrInfo,
                        NDR_DEFAULT_CORR_CACHE_SIZE,
                        0 /* flags */ );
        }
    RpcTryFinally
        {
        NdrMesTypeEncode(Handle, pStubDesc, pFormat, pObject);
        if ( pStubMsg->pCorrInfo )
            NdrCorrelationPass( pStubMsg );        
        }
    RpcFinally
        {
        // while currently we are not using corrinfo in marshalling pass, we need this 
        // in case we are using corrinfo later (like info for free)
        NdrCorrelationFree( pStubMsg );        
        }
    RpcEndFinally
        
}

void  RPC_ENTRY
NdrMesTypeEncode(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    const void *            pObject
    )
/*++

Routine description:

    Encodes the object to the buffer depending on the state of the handle.
    This means: sizing, allocating buffer, marshalling, writing buffer.

Arguments:

    Handle      - a pickling handle
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type,
    pObject     - a pointer to the object being sized.

Returns:

    The size.

Note:

    The pickling header is included in the sizing.

--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    uchar *             pBufferSaved;
    size_t              RequiredLen, CommonHeaderSize, LengthSaved;

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    // Size and allocate the buffer.
    // The req len includes: (the common header), the header and the data

    // Take the pointer alignment to come up with the right size.

    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    RequiredLen = NdrMesTypeAlignSize( Handle,
                                       pStubDesc,
                                       pFormat,
                                       pObject );

    NdrpAllocPicklingBuffer( pMesMsg, RequiredLen );

    pBufferSaved = pStubMsg->Buffer;
    LengthSaved  = RequiredLen;

    // See if we need to marshall the common type header

    CommonHeaderSize = NdrpCommonTypeHeaderMarshall( pMesMsg );

    // Marshall the header and the object.

    // zero out the type header (will contain type buffer length after
    // encoding is done )
    memset( pStubMsg->Buffer, 0, MES_HEADER_SIZE );
    pStubMsg->Buffer += MES_HEADER_SIZE;

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void * *)pObject;
        }

    (*pfnMarshallRoutines[ ROUTINE_INDEX(*pFormat) ])
                                      ( pStubMsg,
                                        (uchar *)pObject,
                                        pFormat );

    // We adjust the buffer to the next align by 8 and
    // so, we tell the user that we've written out till next mod 8.

    ALIGN( pStubMsg->Buffer, 7 );
    size_t WriteLength = (size_t)(pStubMsg->Buffer - pBufferSaved);

    // We always save the rounded up object length in the type header.

    *(unsigned long *)(pBufferSaved + CommonHeaderSize) =
                     WriteLength - CommonHeaderSize - MES_HEADER_SIZE;

    if ( LengthSaved < WriteLength )
        {
        NDR_ASSERT( 0, "NdrMesTypeEncode: encode buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    NdrpWritePicklingBuffer( pMesMsg, pBufferSaved, WriteLength );
}



void
NdrpCommonTypeHeaderUnmarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    if ( pMesMsg->Operation != MES_DECODE )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( ! GET_COMMON_TYPE_HEADER_IN( pMesMsg ) )
        {
        PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

        NdrpReadPicklingBuffer( pMesMsg, MES_CTYPE_HEADER_SIZE );

        // Check the version number, endianness.

        if ( *pStubMsg->Buffer != MIDL_ES_VERSION )
            RpcRaiseException( RPC_X_WRONG_ES_VERSION );

        if ( pStubMsg->Buffer[1] == NDR_LOCAL_ENDIAN )
            {
            // Read the note about endianess at NdrMesTypeDecode.
            //
            pMesMsg->AlienDataRep = NDR_LOCAL_DATA_REPRESENTATION;
            }
        else
            {
            unsigned char temp = pStubMsg->Buffer[2];
            pStubMsg->Buffer[2] = pStubMsg->Buffer[3];
            pStubMsg->Buffer[3] = temp;

            pMesMsg->AlienDataRep = ( NDR_ASCII_CHAR       |     // chars
                                      pStubMsg->Buffer[1]  |     // endianness
                                      NDR_IEEE_FLOAT );          // float
            }

        pStubMsg->Buffer += MES_CTYPE_HEADER_SIZE;

        SET_COMMON_TYPE_HEADER_IN( pMesMsg );
        }

}

void  RPC_ENTRY
NdrMesTypeDecode2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void                          * pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    pStubMsg->fHasExtensions  = 1;
    RpcTryFinally
        {

    if ( pPicklingInfo->Flags.HasNewCorrDesc )
        {
        void * pCorrInfo = alloca( NDR_DEFAULT_CORR_CACHE_SIZE );

        NdrCorrelationInitialize( pStubMsg,
                        (unsigned long *) pCorrInfo,
                        NDR_DEFAULT_CORR_CACHE_SIZE,
                        0 /* flags */ );
        }

        NdrMesTypeDecode(Handle, pStubDesc, pFormat, pObject);
        if ( pStubMsg->pCorrInfo )
            NdrCorrelationPass( pStubMsg );
        }
    RpcFinally
        {
        NdrCorrelationFree( pStubMsg );
        }
    RpcEndFinally
}

void  RPC_ENTRY
NdrMesTypeDecode(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    void                 *  pObject
    )
/*++

Routine description:

    Decodes the object to the buffer depending on the state of the handle.
    This means: reads the header, reads the buffer, unmarshalls.

Arguments:

    Handle      - a pickling handle
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type,
    pObject     - a pointer to the object being sized.

Returns:

    The size.

Note:

    Endianness and other conversions when decoding *types*.
    Starting with Mac implementation, types have a conversion that
    takes care of different endianness. ASCII and VAX_FLOAT are still
    assummed for types.
    Common header conveys the endianness information. The handle gets the
    endian info from the common header and so when decoding types, the
    handle is used to check if the conversion is needed.

    We cannot convert the whole buffer at the time of processing the common
    header as the buffer may not be there yet (for incremental handle).

--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    size_t              RequiredLen;

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;
    uchar *             BufferSaved;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    // See if we need to unmarshall the common type header.

    NdrpCommonTypeHeaderUnmarshall( pMesMsg );

    // Now the individual data object.

    NdrpReadPicklingBuffer( pMesMsg, MES_HEADER_SIZE );

    // Reading the object. Get the length of the buffer first.

    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        pStubMsg->RpcMsg->DataRepresentation = pMesMsg->AlienDataRep;

        BufferSaved = pStubMsg->Buffer;
        NdrSimpleTypeConvert( pStubMsg, FC_LONG );
        pStubMsg->Buffer = BufferSaved;
        }

    RequiredLen = (size_t) *(unsigned long *)pStubMsg->Buffer;
    pStubMsg->Buffer += MES_HEADER_SIZE;

    NdrpReadPicklingBuffer( pMesMsg, RequiredLen );

    // Now the conversion of the object, if needed.

    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        BufferSaved = pStubMsg->Buffer;
        (*pfnConvertRoutines[ ROUTINE_INDEX( *pFormat) ])
            ( pStubMsg,
              pFormat,
              FALSE );
        pStubMsg->Buffer = BufferSaved;
        }

    // Unmarshalling.

    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    void * pArg = pObject;

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        //
        pArg = *(void **)pArg;
        }

    (*pfnUnmarshallRoutines[ ROUTINE_INDEX( *pFormat )])
                            ( pStubMsg,
                              (uchar * *)&pArg,
                              pFormat,
                              FALSE );

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // Don't drop the pointee, if it was allocated.

        *(void **)pObject = pArg;
        }

    // Next decoding needs to start at aligned to 8.

    ALIGN( pStubMsg->Buffer, 7 );
}




void  RPC_ENTRY
NdrMesTypeFree(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    void                 *  pObject
    )
/*++

Routine description:

    Free the object.

Arguments:

    Handle      - a pickling handle,
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type
    pObject     - a pointer to the object being freed.

Returns:

Note:

    The pickling header is included in the sizing.

--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE)Handle)->StubMsg;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    // Now the individual type object.

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void * *)pObject;
        }

    (*pfnFreeRoutines[ ROUTINE_INDEX(*pFormat) ])
                                        ( pStubMsg,
                                        (uchar *)pObject,
                                        pFormat );
}

void  RPC_ENTRY
NdrMesTypeFree2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void                          * pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    pStubMsg->fHasExtensions  = 1;

    if ( pPicklingInfo->Flags.HasNewCorrDesc )
        {
        void * pCorrInfo = alloca( NDR_DEFAULT_CORR_CACHE_SIZE );

        NdrCorrelationInitialize( pStubMsg,
                        (unsigned long *) pCorrInfo,
                        NDR_DEFAULT_CORR_CACHE_SIZE,
                        0 /* flags */ );
        }

    NdrMesTypeFree(Handle, pStubDesc, pFormat, pObject);
}


// =======================================================================
//
//   Ready to use AlignSize routines for simple types
//
// =======================================================================

size_t  RPC_ENTRY
NdrMesSimpleTypeAlignSize(
    handle_t Handle )
/*++
    Size is always 8 bytes for data and there is no header here per data.
    However, the common header gets included for the first object.
--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE) Handle)->StubMsg;

    if( (long)( pStubMsg->BufferLength & 0x7 ) )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    unsigned long OldLength = pStubMsg->BufferLength;

    NdrpCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );
    pStubMsg->BufferLength += 8;

    return( (size_t)(pStubMsg->BufferLength - OldLength) );
}


// =======================================================================
//
//   Ready to use Encode routines for simple types
//
// =======================================================================

void  RPC_ENTRY
NdrMesSimpleTypeEncode(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    const void           *  pData,
    short                   Size )
/*++
    Marshall a simple type entity. There is no header here per data.
    However, the common header gets included for the first object.
--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    size_t RequiredLen;

    // Size and allocate the buffer.
    // The req len includes: (the common header) and the data

    // Take the pointer alignment to come up with the right size.

    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    RequiredLen = NdrMesSimpleTypeAlignSize( Handle );
    NdrpAllocPicklingBuffer( pMesMsg, RequiredLen );

    // See if we need to marshall the common type header

    uchar *   pBufferSaved = pStubMsg->Buffer;

    NdrpCommonTypeHeaderMarshall( pMesMsg );

    switch ( Size )
        {
        case 1:
            * PCHAR_CAST pStubMsg->Buffer  = * PCHAR_CAST pData;
            break;

        case 2:
            * PSHORT_CAST pStubMsg->Buffer = * PSHORT_CAST pData;
            break;

        case 4:
            * PLONG_CAST pStubMsg->Buffer  = * PLONG_CAST pData;
            break;

        case 8:
            * PHYPER_CAST pStubMsg->Buffer = * PHYPER_CAST pData;
            break;

        default:
            NDR_ASSERT( 0, " Size generation problem" );
        }
    pStubMsg->Buffer += 8;

    NdrpWritePicklingBuffer( pMesMsg, pBufferSaved, RequiredLen );
}



// =======================================================================
//
//   Ready to use Decode routines for simple types
//
// =======================================================================

void  RPC_ENTRY
NdrMesSimpleTypeDecode(
    handle_t Handle,
    void  *  pData,
    short    FormatChar )
/*++
    Does not include the header for the data.
    However, the common header gets included for the first object.

    Note. Endianness and other conversions for decode.
    This has been deemed as not worthy doing in the Daytona time frame.
    However, to be able to add it in future without backward compatibility
    problems, we have the last argument to be the format character as
    opposed to the size.
    This makes it possible to call NdrSimpleTypeConvert, if needed.
--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE)Handle)->StubMsg;
    uchar *             BufferSaved;

    // See if we need to unmarshall the common type header.

    NdrpCommonTypeHeaderUnmarshall( (PMIDL_ES_MESSAGE) Handle );

    // Now the data.

    NdrpReadPicklingBuffer( (PMIDL_ES_MESSAGE) Handle, 8);

    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        pStubMsg->RpcMsg->DataRepresentation = pMesMsg->AlienDataRep;

        BufferSaved = pStubMsg->Buffer;
        NdrSimpleTypeConvert( pStubMsg, (unsigned char)FormatChar );
        pStubMsg->Buffer = BufferSaved;
        }

    switch ( FormatChar )
        {
        case FC_BYTE:
        case FC_CHAR:
        case FC_SMALL:
        case FC_USMALL:
            * PCHAR_CAST  pData = * PCHAR_CAST pStubMsg->Buffer;
            break;

        case FC_WCHAR:
        case FC_SHORT:
        case FC_USHORT:
        case FC_ENUM16:
            * PSHORT_CAST pData = * PSHORT_CAST pStubMsg->Buffer;
            break;

        case FC_LONG:
        case FC_ULONG:
        case FC_FLOAT:
        case FC_ENUM32:
        case FC_ERROR_STATUS_T:
            * PLONG_CAST  pData = * PLONG_CAST pStubMsg->Buffer;
            break;

        case FC_HYPER:
        case FC_DOUBLE:
            * PHYPER_CAST pData = * PHYPER_CAST pStubMsg->Buffer;
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
            *((INT64 *)pData)  = *((long *) pStubMsg->Buffer);
            break;

        case FC_UINT3264:
            *((UINT64 *)pData) = *((ulong *)pStubMsg->Buffer);
            break;
#endif

        default:
            NDR_ASSERT( 0, " Size generation problem for simple types" );
        }

    pStubMsg->Buffer += 8;
}

void
NdrpProcHeaderMarshallAll(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    // Marshall DCE pickle header.

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    if ( pMesMsg->Operation == MES_ENCODE )
        * pStubMsg->Buffer++ = MIDL_ES_VERSION;
    else
        * pStubMsg->Buffer++ = MIDL_NDR64_ES_VERSION;
        
    * pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN_LOW;
    *( PSHORT_LV_CAST pStubMsg->Buffer)++ = (short)0xcccc;    // filler

    // Marshall transfer syntax from the stub.

    RpcpMemoryCopy( pStubMsg->Buffer,
                    &( ( PMIDL_ES_MESSAGE_EX)pMesMsg )->TransferSyntax,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

    // We need to remember InterfaceId for inquiries.

    RpcpMemoryCopy( & pMesMsg->InterfaceId,
                    & ((PRPC_CLIENT_INTERFACE)(pStubMsg->
                         StubDesc->RpcInterfaceInformation))->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

   // Marshall InterfaceId and ProcNumber from the handle.

    RpcpMemoryCopy( pStubMsg->Buffer + sizeof(RPC_SYNTAX_IDENTIFIER),
                    & pMesMsg->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long) );

    SET_MES_INFO_AVAILABLE( pMesMsg );

    pStubMsg->Buffer += 2 * sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long);

    * pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN_LOW;
    * pStubMsg->Buffer++ = NDR_ASCII_CHAR;
    * pStubMsg->Buffer++ = (char) (NDR_IEEE_FLOAT >> 8);
    * pStubMsg->Buffer++ = 0;   // filler

    // This is non-DCE element as they have just 4 more bytes of filler here.
    // This field is used only when unmarshalling in our incremental style.

    *( PLONG_LV_CAST pStubMsg->Buffer)++ = pStubMsg->BufferLength -
                                                   MES_PROC_HEADER_SIZE;
}

void
NdrpProcHeaderUnmarshallAll(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    unsigned char *         BufferToRestore;
    PMIDL_STUB_MESSAGE      pStubMsg = &pMesMsg->StubMsg;

    if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
        return;

    NdrpReadPicklingBuffer( pMesMsg, MES_PROC_HEADER_SIZE );

    // Unmarshalling the header

    if ( *pStubMsg->Buffer != MIDL_ES_VERSION && 
         *pStubMsg->Buffer != MIDL_NDR64_ES_VERSION)
        RpcRaiseException( RPC_X_WRONG_ES_VERSION );

    BufferToRestore = pStubMsg->Buffer + 4;

    if ( pStubMsg->Buffer[1] != NDR_LOCAL_ENDIAN_LOW )
        {
        // The DCE header has the endianness on the low nibble, while
        // our DataRep has it on the high nibble.
        // We need only endianess to convert the proc header.

        byte Endianness = (pStubMsg->Buffer[1] << 4 );

        pStubMsg->RpcMsg->DataRepresentation = Endianness;

        pStubMsg->Buffer += 4;
        NdrSimpleStructConvert( pStubMsg,
                                &__MIDLFormatString.Format[32],
                                FALSE );
        }

    pStubMsg->Buffer = BufferToRestore;

    // Verify the transfer syntax

    RpcpMemoryCopy( &((PMIDL_ES_MESSAGE_EX)pMesMsg)->TransferSyntax, 
                      pStubMsg->Buffer,
                      sizeof( RPC_SYNTAX_IDENTIFIER ) );

    pStubMsg->Buffer += sizeof(RPC_SYNTAX_IDENTIFIER);

    // We need to remember the last InterfaceId and ProcNumber for inquiries.

    RpcpMemoryCopy( & pMesMsg->InterfaceId,
                    pStubMsg->Buffer,
                    sizeof(RPC_SYNTAX_IDENTIFIER)  );
  
    pStubMsg->Buffer += sizeof(RPC_SYNTAX_IDENTIFIER);

    pMesMsg->ProcNumber = *(ulong *)pStubMsg->Buffer;

    pStubMsg->Buffer += 4;

    SET_MES_INFO_AVAILABLE( pMesMsg );

    unsigned long AlienDataRepresentation =
                        ( (pStubMsg->Buffer[0] << 4)  |           // endianness
                          pStubMsg->Buffer[1]  |                       // chars
                        ((unsigned long)(pStubMsg->Buffer[2]) << 8) ); // float
    pMesMsg->AlienDataRep = AlienDataRepresentation;
    pMesMsg->IncrDataSize = (size_t) *(unsigned long __RPC_FAR *)
                                                (pStubMsg->Buffer + 4);
    pStubMsg->Buffer += 8;
}

extern const MIDL_FORMAT_STRING __MIDLFormatString =
    {
        0,
        {
            
            0x1d,       /* FC_SMFARRAY */
            0x0,        /* 0 */
/*  2 */    0x6, 0x0,   /* 6 */
/*  4 */    0x1,        /* FC_BYTE */
            0x5b,       /* FC_END */
/*  6 */    
            0x15,       /* FC_STRUCT */
            0x3,        /* 3 */
/*  8 */    0x10, 0x0,  /* 16 */
/* 10 */    0x8,        /* FC_LONG */
            0x6,        /* FC_SHORT */
/* 12 */    0x6,        /* FC_SHORT */
            0x3,        /* FC_SMALL */
/* 14 */    0x3,        /* FC_SMALL */
            0x4c,       /* FC_EMBEDDED_COMPLEX */
/* 16 */    0x0,        /* 0 */
            0xef, 0xff, /* Offset= -17 (0) */
            0x5b,       /* FC_END */
/* 20 */    
            0x15,       /* FC_STRUCT */
            0x3,        /* 3 */
/* 22 */    0x14, 0x0,  /* 20 */
/* 24 */    0x4c,       /* FC_EMBEDDED_COMPLEX */
            0x0,        /* 0 */
/* 26 */    0xec, 0xff, /* Offset= -20 (6) */
/* 28 */    0x6,        /* FC_SHORT */
            0x6,        /* FC_SHORT */
/* 30 */    0x5c,       /* FC_PAD */
            0x5b,       /* FC_END */
/* 32 */    
            0x15,       /* FC_STRUCT */
            0x3,        /* 3 */
/* 34 */    0x34, 0x0,  /* 52 */
/* 36 */    0x4c,       /* FC_EMBEDDED_COMPLEX */
            0x0,        /* 0 */
/* 38 */    0xee, 0xff, /* Offset= -18 (20) */
/* 40 */    0x4c,       /* FC_EMBEDDED_COMPLEX */
            0x0,        /* 0 */
/* 42 */    0xea, 0xff, /* Offset= -22 (20) */
/* 44 */    0x8,        /* FC_LONG */
            0x1,        /* FC_BYTE */
/* 46 */    0x1,        /* FC_BYTE */
            0x1,        /* FC_BYTE */
/* 48 */    0x1,        /* FC_BYTE */
            0x38,       /* FC_ALIGNM4 */
/* 50 */    0x8,        /* FC_LONG */
            0x5b,       /* FC_END */

            0x0
        }
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\pointerq.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    pointerq.h

Abstract :

    This file contains the routines for pointer queues.
    
Author :

    Mike Zoran  mzoran   Jun 2000.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"

#if !defined(__POINTERQ_H__)
#define  __POINTERQ_H__

template<class T>
class SAVE_CONTEXT
{
    const T OldValue;
    T & LocationToRestore;
public:
    __forceinline SAVE_CONTEXT(T & Location) :
        OldValue( Location ),
        LocationToRestore( Location )
    {}
    __forceinline SAVE_CONTEXT(T & Location, T NewValue) :
        OldValue( Location ),
        LocationToRestore( Location )
    { 
        Location = NewValue;
    }
    __forceinline ~SAVE_CONTEXT()
    {
        LocationToRestore = OldValue;
    }
};

class POINTER_BUFFER_SWAP_CONTEXT
{
    MIDL_STUB_MESSAGE *pStubMsg;
    uchar *pBufferSave;
    const bool DoSwap;
public:
    __forceinline POINTER_BUFFER_SWAP_CONTEXT( MIDL_STUB_MESSAGE *pStubMsgNew ) :
        pStubMsg( pStubMsgNew ),
        DoSwap( pStubMsg->PointerBufferMark != NULL )
    {
       if ( DoSwap )
           {
           pBufferSave = pStubMsg->Buffer;
           pStubMsg->Buffer = pStubMsg->PointerBufferMark;
           pStubMsg->PointerBufferMark = 0;
           }
    }
    __forceinline ~POINTER_BUFFER_SWAP_CONTEXT()
    {
        if ( DoSwap ) 
            {
            pStubMsg->PointerBufferMark = pStubMsg->Buffer;
            pStubMsg->Buffer = pBufferSave;
            }
    }
};

class POINTER_BUFFERLENGTH_SWAP_CONTEXT
{
    MIDL_STUB_MESSAGE *pStubMsg;
    ulong LengthSave;
    const bool DoSwap;
public:
    __forceinline POINTER_BUFFERLENGTH_SWAP_CONTEXT( MIDL_STUB_MESSAGE *pStubMsgNew ) :
        pStubMsg( pStubMsgNew ),
        DoSwap( pStubMsg->PointerBufferMark != NULL )
    {
       if ( DoSwap )
           {
           LengthSave = pStubMsg->BufferLength;
           pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
           pStubMsg->PointerBufferMark = 0;
           }
    }
    __forceinline ~POINTER_BUFFERLENGTH_SWAP_CONTEXT()
    {
        if ( DoSwap ) 
            {
            pStubMsg->PointerBufferMark = (uchar *) UlongToPtr(pStubMsg->BufferLength);
            pStubMsg->BufferLength = LengthSave;
            }
    }
};

class POINTER_MEMSIZE_SWAP_CONTEXT
{
    MIDL_STUB_MESSAGE *pStubMsg;
    ulong MemorySave;
    uchar *pBufferSave;
    const bool DoSwap;
public:
    __forceinline POINTER_MEMSIZE_SWAP_CONTEXT( MIDL_STUB_MESSAGE *pStubMsgNew ) :
        pStubMsg( pStubMsgNew ),
        DoSwap( pStubMsg->PointerBufferMark != 0 )
    {
       if ( DoSwap )
           {
           MemorySave  = pStubMsg->MemorySize;
           pBufferSave = pStubMsg->Buffer;
           pStubMsg->MemorySize = pStubMsg->PointerLength;
           pStubMsg->Buffer     = pStubMsg->PointerBufferMark;
           pStubMsg->PointerBufferMark = 0;
           pStubMsg->PointerLength = 0;
           }
    }
    __forceinline ~POINTER_MEMSIZE_SWAP_CONTEXT()
    {
        if ( DoSwap ) 
            {
            pStubMsg->PointerBufferMark = pStubMsg->Buffer;
            pStubMsg->PointerLength     = pStubMsg->MemorySize;
            pStubMsg->Buffer            = pBufferSave;
            pStubMsg->MemorySize        = MemorySave;
            }
    }
};

class NDR_POINTER_QUEUE;

struct NDR_POINTER_QUEUE_STATE;

class NDR_POINTER_QUEUE_ELEMENT
{
public:
   NDR_POINTER_QUEUE_ELEMENT *pNext;
   
   virtual void Dispatch( MIDL_STUB_MESSAGE *pStubMsg ) = 0;
   
#if defined(DBG)
   virtual void Print() = 0;
#endif

   // All of these elements are allocated from a special memory pool.
   // Define these after NDR_POINTER_QUEUE_STATE is defined.
   
   void * operator new( size_t /*stAllocateBlock */, NDR_POINTER_QUEUE_STATE *pAllocator );
   void operator delete( void *pThis, NDR_POINTER_QUEUE_STATE *pAllocator );
};

class NDR_MRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pBufferMark;
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const Memory;
    const uchar uFlags;

public:

    NDR_MRSHL_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                     uchar * const pBufferMarkNew,
                                     uchar * const pMemoryNew,
                                     const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    unsigned long * const pWireMarkerPtr;
public:
    NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                               PFORMAT_STRING pFormatNew,
                                               unsigned long *pWireMarkerPtrNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew ),
        pWireMarkerPtr( pWireMarkerPtrNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};


class NDR_BUFSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const Memory;
    const uchar uFlags;

public:

    NDR_BUFSIZE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                       uchar * const pMemoryNew,
                                       const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
public:
    NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                 PFORMAT_STRING pFormatNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR_FREE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const Memory;
    const uchar uFlags;

public:

    NDR_FREE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                    uchar * const pMemoryNew,
                                    const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_PFNFREE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
public:
    typedef void (__RPC_API * FREEFUNC)(void *);
private:
    FREEFUNC pfnFree;
    uchar *pMemory;
public:
    NDR_PFNFREE_POINTER_QUEUE_ELEMENT(
        FREEFUNC pfnFreeNew,
        uchar *pMemoryNew) :
        pfnFree(pfnFreeNew),
        pMemory(pMemoryNew)

    {
    }

    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg) {(*pfnFree)(pMemory);}
    virtual void Print() 
        {
        DbgPrint("NDR_PFNFREE_POINTER_QUEUE_ELEMENT\n");
        DbgPrint("pfnFree:                 %p\n", pfnFree );
        DbgPrint("pMemory:                 %p\n", pMemory );
        }
};

class NDR_UNMRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar ** const ppMemory;
    uchar * const pMemory;
    long * const pBufferPointer;
    const PFORMAT_STRING pFormat;
    uchar * const Memory;
    const uchar uFlags;
    const int fInDontFree;
    uchar * const pCorrMemory;
    NDR_ALLOC_ALL_NODES_CONTEXT *const pAllocAllNodesContext;
public:

    NDR_UNMRSHL_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                       uchar **            ppMemoryNew,      
                                       uchar *             pMemoryNew,
                                       long  *             pBufferPointerNew,
                                       PFORMAT_STRING      pFormatNew );
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
public:
    NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                 PFORMAT_STRING pFormatNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR_MEMSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING pFormat;
    uchar * const pBufferMark;
    uchar * const Memory;
    const uchar uFlags;

public:

    NDR_MEMSIZE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                       uchar *            pBufferMarkNew,
                                       PFORMAT_STRING      pFormatNew );
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING pFormat;
public:
    NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT( PFORMAT_STRING pFormatNew ) :
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

//
// NDR64 Queue Elements

class NDR64_MRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    NDR64_PTR_WIRE_TYPE * const pBufferMark;
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const pCorrMemory;
    const uchar uFlags;
public:

    NDR64_MRSHL_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                     NDR64_PTR_WIRE_TYPE * const pBufferMarkNew,
                                     uchar * const pMemoryNew,
                                     const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    NDR64_PTR_WIRE_TYPE * const pWireMarkerPtr;
public:
    NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                 PFORMAT_STRING pFormatNew,
                                                 NDR64_PTR_WIRE_TYPE *pWireMarkerPtrNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew ),
        pWireMarkerPtr( pWireMarkerPtrNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    NDR64_PTR_WIRE_TYPE *pBufferMark;
    uchar *         pMemory;
    PFORMAT_STRING  pFormat;
    uchar *         pCorrMemory;
    uchar           uFlags;

public:

    NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                         uchar * const pMemoryNew,
                                         const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};


class NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
public:
    NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                   PFORMAT_STRING pFormatNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew ) 
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING  pFormat;   
    const uchar           uFlags;
    NDR64_PTR_WIRE_TYPE * const pBufferMark;
public:

    NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                         PFORMAT_STRING      pFormatNew,
                                         NDR64_PTR_WIRE_TYPE *pBufferMarkNew ) :
        pFormat( pFormatNew ),
        uFlags( pStubMsg->uFlags ),
        pBufferMark( pBufferMarkNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING pFormat;
public:
    NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT(  PFORMAT_STRING pFormatNew ) :
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    NDR64_PTR_WIRE_TYPE WirePtr;
    uchar **        ppMemory;
    uchar *         pMemory;
    PFORMAT_STRING  pFormat;
    uchar *         pCorrMemory;
    NDR_ALLOC_ALL_NODES_CONTEXT *pAllocAllNodesContext; 
    BOOL            fInDontFree;    
    uchar           uFlags;
public:

    NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                         uchar **            ppMemoryNew,      
                                         uchar *             pMemoryNew,
                                         NDR64_PTR_WIRE_TYPE WirePtrNew,
                                         PFORMAT_STRING      pFormatNew );
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};


class NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
public:
    NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                 PFORMAT_STRING pFormatNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR64_FREE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const pCorrMemory;
    const uchar uFlags;

public:

    NDR64_FREE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                      uchar * const pMemoryNew,
                                      const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

const SIZE_T Ndr32MaxPointerQueueElement = 
    max(sizeof(NDR_MRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_BUFSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_FREE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_PFNFREE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_UNMRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_MEMSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT),
        0)))))))));

const SIZE_T Ndr64MaxPointerQueueElement =
    max(sizeof(NDR64_MRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_FREE_POINTER_QUEUE_ELEMENT),
        0)))))))));

const SIZE_T NdrMaxPointerQueueElement = 
    max(Ndr32MaxPointerQueueElement,
    max(Ndr64MaxPointerQueueElement,
        0));

struct NDR_POINTER_QUEUE_STATE 
{
private:
   NDR_POINTER_QUEUE *pActiveQueue;

public:

   NDR_POINTER_QUEUE_STATE(void) :
       pActiveQueue(NULL)
      {
      }

   virtual NDR_POINTER_QUEUE_ELEMENT *Allocate() = 0;
   virtual void Free(NDR_POINTER_QUEUE_ELEMENT *pElement) = 0;
                

   NDR_POINTER_QUEUE* GetActiveQueue() { return pActiveQueue; }
   void SetActiveQueue(NDR_POINTER_QUEUE *pNewQueue) { pActiveQueue = pNewQueue; }  

}; 

inline void * 
NDR_POINTER_QUEUE_ELEMENT::operator new( 
   size_t /*stAllocateBlock */, 
   NDR_POINTER_QUEUE_STATE *pAllocator )
{
   return pAllocator->Allocate(); 
}

inline void 
NDR_POINTER_QUEUE_ELEMENT::operator delete(
   void *pThis, 
   NDR_POINTER_QUEUE_STATE *pAllocator )
{
   pAllocator->Free( (NDR_POINTER_QUEUE_ELEMENT*)pThis );
}


class NDR32_POINTER_QUEUE_STATE : public NDR_POINTER_QUEUE_STATE
{    
public:
   // Make this private for a C compiler bug.
   static const ItemsToAllocate = 100;

private:

   NDR_POINTER_QUEUE_ELEMENT *pFreeList;

   struct AllocationElement
       {
       SIZE_T ItemsAllocated;
       struct AllocationElement *pNext;
       // Should be pointer aligned
       char Data[ItemsToAllocate][NdrMaxPointerQueueElement];
       } *pAllocationList;

   void FreeAll(); 
   NDR_POINTER_QUEUE_ELEMENT *InternalAllocate();

public:
   NDR32_POINTER_QUEUE_STATE( MIDL_STUB_MESSAGE *pStubMsg ) :
       pFreeList(NULL),
       pAllocationList(NULL)
   {
   }
   ~NDR32_POINTER_QUEUE_STATE() { if ( pAllocationList ) FreeAll(); }

   NDR_POINTER_QUEUE_ELEMENT *Allocate();
   void Free(NDR_POINTER_QUEUE_ELEMENT *pElement);

   void* operator new(size_t, void *pMemory) { return pMemory; }
   void operator delete(void *,void *) {return; }
   void operator delete(void *) {}
};

#if defined(BUILD_NDR64)

class NDR64_POINTER_QUEUE_STATE : public NDR_POINTER_QUEUE_STATE
{
private:
   NDR_PROC_CONTEXT * const pProcContext;

public:
    NDR64_POINTER_QUEUE_STATE( 
        MIDL_STUB_MESSAGE *pStubMsg ) :
        pProcContext( (NDR_PROC_CONTEXT*)pStubMsg->pContext )
    {
    }

    NDR_POINTER_QUEUE_ELEMENT *Allocate();
    void Free(NDR_POINTER_QUEUE_ELEMENT *pElement);
    
    void* operator new(size_t, void *pMemory) { return pMemory;}
    void operator delete(void *,void *) {}
    void operator delete(void *) {}
};

#endif

class NDR_POINTER_QUEUE
{
    PMIDL_STUB_MESSAGE pStubMsg;
    NDR_POINTER_QUEUE_STATE *pQueueState;

    class STORAGE 
    {
        NDR_POINTER_QUEUE_ELEMENT *pHead, *pPrevHead;
        NDR_POINTER_QUEUE_ELEMENT **pInsertPointer, **pPrevInsertPointer;
        
    public:
        STORAGE( );
        void MergeContext();
        void NewContext(); 
        void InsertTail( NDR_POINTER_QUEUE_ELEMENT *pNewNode );
        NDR_POINTER_QUEUE_ELEMENT *RemoveHead();
    } Storage;

public:
    NDR_POINTER_QUEUE( PMIDL_STUB_MESSAGE pStubMsg, NDR_POINTER_QUEUE_STATE *pQueueState );

    void Enque( NDR_POINTER_QUEUE_ELEMENT *pElement );
    void Dispatch();

    void* operator new(size_t, void *pMemory) { return pMemory; }
    void operator delete(void *,void *) {return; }
    void operator delete(void *) {}
    
};

template<class T>
class NDR_POINTER_CONTEXT
{
private:

    bool bNewState;
    bool bNewQueue;
    
    MIDL_STUB_MESSAGE * const pStubMsg;
    // Should be pointer aligned
    char PointerQueueStateStorage[sizeof(T)];

    NDR_POINTER_QUEUE *pActiveQueue;
    // Should be pointer aligned
    char PointerQueueStorage[sizeof(NDR_POINTER_QUEUE)];
    
public:
    __forceinline NDR_POINTER_QUEUE_STATE *GetActiveState() { return pStubMsg->pPointerQueueState; }
private:    
    __forceinline bool IsStateActive() { return NULL != GetActiveState();}

public:


    NDR_POINTER_CONTEXT( MIDL_STUB_MESSAGE *pStubMsgNew ) :
        pStubMsg( pStubMsgNew ),
        bNewState( false ),
        bNewQueue( false ),
        pActiveQueue( NULL )
    {
        NDR_ASSERT( NdrIsLowStack( pStubMsg ), "Created Pointer context too early.\n");
        if ( !IsStateActive() )
            {
            // The queue state wasn't created. 
            pStubMsg->pPointerQueueState =
                new(PointerQueueStateStorage) T(pStubMsg);
            pActiveQueue =
                new(PointerQueueStorage) NDR_POINTER_QUEUE( pStubMsg, GetActiveState() );
            GetActiveState()->SetActiveQueue( pActiveQueue );
            bNewState = bNewQueue = true;
                
            return;
            }

        // State already exists
        pActiveQueue = GetActiveState()->GetActiveQueue();
        if ( pActiveQueue )
            return;

        // Already have a state, but no active queue.
        // Activate the queue.

        pActiveQueue = new(PointerQueueStorage) NDR_POINTER_QUEUE( pStubMsg, GetActiveState() );
        GetActiveState()->SetActiveQueue( pActiveQueue );
        bNewQueue = true;

    }
    __forceinline void DispatchIfRequired( )
    {
        if ( bNewQueue )
            {
            pActiveQueue->Dispatch();
            }
    }
    __forceinline bool ShouldEnque() { return pActiveQueue != NULL; }
    __forceinline void Enque( NDR_POINTER_QUEUE_ELEMENT *pElement ) 
        { 
        pActiveQueue->Enque( pElement ); 
        
        }

    // REVIEW: Replace with a destructor once native
    // exception handling is enabled for ndr.
    __forceinline void EndContext()
    {
        if ( bNewQueue )
            {
            GetActiveState()->SetActiveQueue(NULL);
            }
        
        if ( bNewState)   
            {
            delete (T*)GetActiveState();
            pStubMsg->pPointerQueueState = NULL;
            }
    }
};

typedef NDR_POINTER_CONTEXT<NDR32_POINTER_QUEUE_STATE> NDR32_POINTER_CONTEXT;

#if defined(BUILD_NDR64)
typedef NDR_POINTER_CONTEXT<NDR64_POINTER_QUEUE_STATE> NDR64_POINTER_CONTEXT;
#endif

#endif // __POINTER32_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\proxy.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    proxy.c

Abstract:
    Implements the IRpcProxyBuffer interface.

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT and Windows 95 and PowerMac.
    We do not support DOS, Win16 and Mac.

Revision History:

--*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>
#include <stddef.h>

CStdProxyBuffer * RPC_ENTRY
NdrGetProxyBuffer(
    void *pThis);

const IID * RPC_ENTRY
NdrGetProxyIID(
    const void *pThis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_Release(
    IN  IRpcProxyBuffer *This);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_Release(
    IN  IRpcProxyBuffer *This);

BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList, 
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex );


// The channel wrapper
//

typedef struct tagChannelWrapper
{
    const IRpcChannelBufferVtbl *lpVtbl;
    long                         RefCount;
    const IID *                  pIID;
    struct IRpcChannelBuffer *   pChannel;
} ChannelWrapper;


HRESULT STDMETHODCALLTYPE
CreateChannelWrapper
(
    const IID *          pIID,
    IRpcChannelBuffer *  pChannel,
    IRpcChannelBuffer ** pChannelWrapper
);

HRESULT STDMETHODCALLTYPE
CreateAsyncChannelWrapper
(
    const IID *          pIID,
    IRpcChannelBuffer *  pChannel,
    IRpcChannelBuffer ** pChannelWrapper
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_QueryInterface
(
    IRpcChannelBuffer3 * This,
    REFIID               riid,
    void **              ppvObject
);

ULONG STDMETHODCALLTYPE
ChannelWrapper_AddRef
(
    IRpcChannelBuffer3 * This
);

ULONG STDMETHODCALLTYPE
ChannelWrapper_Release
(
    IRpcChannelBuffer3 * This
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetBuffer
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    REFIID              riid
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_SendReceive
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG *             pStatus
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_FreeBuffer
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetDestCtx
(
    IRpcChannelBuffer3 * This,
    DWORD *             pdwDestContext,
    void **             ppvDestContext
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_IsConnected
(
    IRpcChannelBuffer3 * This
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetProtocolVersion
(
    IRpcChannelBuffer3 * This,
    DWORD             * pdwVersion
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_Send(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG *             pStatus
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_Receive(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG               ulSize,
    ULONG *             pStatus
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_Cancel(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetCallContext(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    REFIID              riid,
    void    **          pInterface
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetDestCtxEx(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    DWORD *             pdwDestContext,
    void **             ppvDestContext
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetState(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    DWORD         *     pState
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_RegisterAsync(
    IRpcChannelBuffer3 *    This,
    RPCOLEMESSAGE *         pMessage,
    IAsyncManager *         pAsyncMgr
    );



HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_QueryInterface
(
    IAsyncRpcChannelBuffer  *   This,
    REFIID                      riid,
    void **                     ppvObject
);

ULONG STDMETHODCALLTYPE
AsyncChannelWrapper_AddRef
(
    IAsyncRpcChannelBuffer  *   This
);

ULONG STDMETHODCALLTYPE
AsyncChannelWrapper_Release
(
    IAsyncRpcChannelBuffer  *   This
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetBuffer
(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    REFIID                      riid
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_SendReceive
(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    ULONG *                     pStatus
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_FreeBuffer
(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetDestCtx
(
    IAsyncRpcChannelBuffer  *   This,
    DWORD *                     pdwDestContext,
    void **                     ppvDestContext
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_IsConnected
(
    IAsyncRpcChannelBuffer  *   This
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetProtocolVersion
(
    IAsyncRpcChannelBuffer  *   This,
    DWORD                   *   pdwVersion
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_Send(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    ISynchronize *              pSynchronize,
    ULONG *                     pStatus
    );

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_Receive(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    ULONG *                     pStatus
    );

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetDestCtxEx
(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    DWORD *                     pdwDestContext,
    void **                     ppvDestContext
);


//+-------------------------------------------------------------------------
//
//  Global data
//
//--------------------------------------------------------------------------

// ProxyBuffer vtables for non-delegaed and delegated case.

extern const IRpcProxyBufferVtbl CStdProxyBufferVtbl = {
    CStdProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdProxyBuffer_Release,
    CStdProxyBuffer_Connect,
    CStdProxyBuffer_Disconnect };

extern const IRpcProxyBufferVtbl CStdProxyBuffer2Vtbl = {
    CStdProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdProxyBuffer2_Release,
    CStdProxyBuffer2_Connect,
    CStdProxyBuffer2_Disconnect };

// ICallFactory interface on the ProxyBuffer objects.
// ICallFactory is an interface on a sync proxy only.
// It has been introduced for NT5 beta2.

extern const ICallFactoryVtbl CStdProxyBuffer_CallFactoryVtbl = {
    CStdProxyBuffer_CF_QueryInterface,
    CStdProxyBuffer_CF_AddRef,
    CStdProxyBuffer_CF_Release,
    CStdProxyBuffer_CF_CreateCall };

extern const ICallFactoryVtbl CStdProxyBuffer2_CallFactoryVtbl = {
    CStdProxyBuffer_CF_QueryInterface,
    CStdProxyBuffer_CF_AddRef,
    CStdProxyBuffer_CF_Release,
    CStdProxyBuffer2_CF_CreateCall };

extern const IReleaseMarshalBuffersVtbl CStdProxyBuffer_ReleaseMarshalBuffersVtbl = {
    CStdProxyBuffer_RMB_QueryInterface,
    CStdProxyBuffer_RMB_AddRef,
    CStdProxyBuffer_RMB_Release,
    CStdProxyBuffer_RMB_ReleaseMarshalBuffer };

extern const IReleaseMarshalBuffersVtbl CStdAsyncProxyBuffer_ReleaseMarshalBuffersVtbl = {
    CStdProxyBuffer_RMB_QueryInterface,
    CStdProxyBuffer_RMB_AddRef,
    CStdProxyBuffer_RMB_Release,
    CStdAsyncProxyBuffer_RMB_ReleaseMarshalBuffer };

// Async proxy buffer vtables

extern const IRpcProxyBufferVtbl CStdAsyncProxyBufferVtbl = {
    CStdAsyncProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdAsyncProxyBuffer_Release,
    CStdAsyncProxyBuffer_Connect,
    CStdProxyBuffer_Disconnect };

extern const IRpcProxyBufferVtbl CStdAsyncProxyBuffer2Vtbl = {
    CStdAsyncProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdAsyncProxyBuffer2_Release,
    CStdAsyncProxyBuffer2_Connect,
    CStdProxyBuffer2_Disconnect };

// Channel wrapper is used for delegetion only.


extern const IRpcChannelBuffer3Vtbl ChannelWrapperVtbl = {
    ChannelWrapper_QueryInterface,
    ChannelWrapper_AddRef,
    ChannelWrapper_Release,
    ChannelWrapper_GetBuffer,
    ChannelWrapper_SendReceive,
    ChannelWrapper_FreeBuffer,
    ChannelWrapper_GetDestCtx,
    ChannelWrapper_IsConnected,
    ChannelWrapper_GetProtocolVersion,
    ChannelWrapper_Send,
    ChannelWrapper_Receive,
    ChannelWrapper_Cancel,
    ChannelWrapper_GetCallContext,
    ChannelWrapper_GetDestCtxEx,
    ChannelWrapper_GetState,
    ChannelWrapper_RegisterAsync
    };

extern const IAsyncRpcChannelBufferVtbl AsyncChannelWrapperVtbl = {
    AsyncChannelWrapper_QueryInterface,
    AsyncChannelWrapper_AddRef,
    AsyncChannelWrapper_Release,
    AsyncChannelWrapper_GetBuffer,
    AsyncChannelWrapper_SendReceive,
    AsyncChannelWrapper_FreeBuffer,
    AsyncChannelWrapper_GetDestCtx,
    AsyncChannelWrapper_IsConnected,
    AsyncChannelWrapper_GetProtocolVersion,
    AsyncChannelWrapper_Send,
    AsyncChannelWrapper_Receive,
    AsyncChannelWrapper_GetDestCtxEx
    };

//+-------------------------------------------------------------------------
//
//  End of Global data
//
//--------------------------------------------------------------------------


#pragma code_seg(".orpc")

// __inline
CStdProxyBuffer * RPC_ENTRY
NdrGetProxyBuffer(
    IN  void *pThis)
/*++

Routine Description:
    The "this" pointer points to the pProxyVtbl field in the
    CStdProxyBuffer structure.  The NdrGetProxyBuffer function
    returns a pointer to the top of the CStdProxyBuffer
    structure.

Arguments:
    pThis - Supplies a pointer to the interface proxy.

Return Value:
    This function returns a pointer to the proxy buffer.

--*/
{
    unsigned char *pTemp;

    pTemp = (unsigned char *) pThis;
    pTemp -= offsetof(CStdProxyBuffer, pProxyVtbl);

    return (CStdProxyBuffer *)pTemp;
}

//__inline
const IID * RPC_ENTRY
NdrGetProxyIID(
    IN  const void *pThis)
/*++

Routine Description:
    The NDRGetProxyIID function returns a pointer to IID.

Arguments:
    pThis - Supplies a pointer to the interface proxy.

Return Value:
    This function returns a pointer to the IID.

--*/
{
    unsigned char **    ppTemp;
    unsigned char *     pTemp;
    CInterfaceProxyVtbl *pProxyVtbl;

    //Get a pointer to the proxy vtbl.
    ppTemp = (unsigned char **) pThis;
    pTemp = *ppTemp;
    pTemp -= sizeof(CInterfaceProxyHeader);
    pProxyVtbl = (CInterfaceProxyVtbl *) pTemp;

    return pProxyVtbl->header.piid;
}


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_QueryInterface(
    IN  IRpcProxyBuffer *   This,
    IN  REFIID              riid,
    OUT void **             ppv)
/*++

Routine Description:
    Query for an interface on the proxy.  This function provides access
    to both internal and external interfaces.

Arguments:
    riid - Supplies the IID of the requested interface.
        ppv  - Returns a pointer to the requested interface.

Return Value:
    S_OK
        E_NOINTERFACE

--*/
{
    CStdProxyBuffer   * pCThis  = (CStdProxyBuffer *) This;
    HRESULT             hr = E_NOINTERFACE;
    const IID *         pIID;

    *ppv = 0;

    if( (memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcProxyBuffer, sizeof(IID)) == 0) )
    {
        //This is an internal interface. Increment the internal reference count.
        InterlockedIncrement( &pCThis->RefCount);
        *ppv = This;
        hr = S_OK;
        return hr;   
    }
    else if ( pCThis->pCallFactoryVtbl != 0  && 
              memcmp(&riid, &IID_ICallFactory, sizeof(IID)) == 0 )
        {
        // This is an exposed interface so go through punkOuter ot addref.
        pCThis->punkOuter->lpVtbl->AddRef(pCThis->punkOuter);

        *ppv = (void *) & pCThis->pCallFactoryVtbl;
        hr = S_OK;
        return hr;
        }
    else if ( pCThis->pRMBVtbl && 
              (memcmp(&riid, &IID_IReleaseMarshalBuffers,sizeof(IID)) == 0))
    {
        InterlockedIncrement( &pCThis->RefCount);

        *ppv = (void *) & pCThis->pRMBVtbl;
        hr = S_OK;
        return hr;
    }

    pIID = NdrGetProxyIID(&pCThis->pProxyVtbl);

    if( memcmp(&riid, pIID, sizeof(IID)) == 0)
    {
        //Increment the reference count.

        pCThis->punkOuter->lpVtbl->AddRef(pCThis->punkOuter);
        *ppv = (void *) &pCThis->pProxyVtbl;
        hr = S_OK;
    }

    return hr;
};


HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_QueryInterface(
    IN  IRpcProxyBuffer *   This,
    IN  REFIID              riid,
    OUT void **             ppv)
/*++

Routine Description:
    Query for an interface on the proxy.  This function provides access
    to both internal and external interfaces.
    
Used for
    CStdAsyncProxyBuffer2 as well.

Arguments:
    riid - Supplies the IID of the requested interface.
        ppv  - Returns a pointer to the requested interface.

Return Value:
    S_OK
        E_NOINTERFACE

--*/
{
    CStdProxyBuffer   * pCThis  = (CStdProxyBuffer *) This;
    HRESULT             hr = E_NOINTERFACE;
    const IID *         pIID;

    *ppv = 0;

    if( (memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcProxyBuffer, sizeof(IID)) == 0))
    {
        //This is an internal interface. Increment the internal reference count.
        InterlockedIncrement( &pCThis->RefCount);
        *ppv = This;
        hr = S_OK;
        return hr;   
    }
    else if ( pCThis->pRMBVtbl && 
              (memcmp(&riid, &IID_IReleaseMarshalBuffers,sizeof(IID)) == 0))
    {
        InterlockedIncrement( &pCThis->RefCount);

        *ppv = (void *) & pCThis->pRMBVtbl;
        hr = S_OK;
        return hr;
    }

    if(memcmp(&riid, &IID_ISynchronize, sizeof(IID)) == 0)
    {
        hr = pCThis->punkOuter->lpVtbl->QueryInterface( pCThis->punkOuter,
                                                        IID_ISynchronize,
                                                        ppv);
    }

    pIID = NdrGetProxyIID(&pCThis->pProxyVtbl);

    if(memcmp(&riid, pIID, sizeof(IID)) == 0)
    {
        //Increment the reference count.
        pCThis->punkOuter->lpVtbl->AddRef(pCThis->punkOuter);
        
        *ppv = (void *) &pCThis->pProxyVtbl;
        hr = S_OK;
    }

    return hr;
};


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_AddRef(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Increment reference count.

Used for
    CStdProxyBuffer2
    CStdAsyncProxyBuffer
    CStdAsuncProxyBuffer2

Arguments:

Return Value:
    Reference count.

--*/
{
    // We do not need to go through punkOuter for ICallFactory.

    CStdProxyBuffer   *  pCThis  = (CStdProxyBuffer *) This;

    InterlockedIncrement(&pCThis->RefCount);

    return (ULONG) pCThis->RefCount;
};



ULONG STDMETHODCALLTYPE
CStdProxyBuffer_Release(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG count;
    IPSFactoryBuffer *pFactory;

    NDR_ASSERT(((CStdProxyBuffer *)This)->RefCount > 0, "Invalid reference count");

    count = (unsigned long) ((CStdProxyBuffer *)This)->RefCount - 1;


    if(InterlockedDecrement(&((CStdProxyBuffer *)This)->RefCount) == 0)
    {
        count = 0;

        pFactory = (IPSFactoryBuffer *) ((CStdProxyBuffer *)This)->pPSFactory;

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release(pFactory);

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset(This,  '\0', sizeof(CStdProxyBuffer));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(This);
    }

    return count;
};


ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_Release(
    IN  IRpcProxyBuffer *   This)
/*++

Routine Description:
    Decrement reference count.  This function is used by proxies
    which delegate to the base interface.

Arguments:
    This - Points to a CStdProxyBuffer2.

Return Value:
    Reference count.

--*/
{
    ULONG               count;
    IPSFactoryBuffer *  pFactory;
    IRpcProxyBuffer *   pBaseProxyBuffer;
    IUnknown *          pBaseProxy;

    NDR_ASSERT(((CStdProxyBuffer2 *)This)->RefCount > 0, "Invalid reference count");

    count = (ULONG) ((CStdProxyBuffer2 *)This)->RefCount - 1;

    if(InterlockedDecrement(&((CStdProxyBuffer2 *)This)->RefCount) == 0)
    {
        count = 0;

        //Delegation support.
        pBaseProxy = ((CStdProxyBuffer2 *)This)->pBaseProxy;
        if(pBaseProxy != 0)
        {
// Shannon - why?
            //This is a weak reference, so we don't release it.
            //pBaseProxy->lpVtbl->Release(pBaseProxy);
        }

        pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

        if( pBaseProxyBuffer != 0)
        {
            pBaseProxyBuffer->lpVtbl->Release(pBaseProxyBuffer);
        }

        //Decrement the DLL reference count.
        pFactory = (IPSFactoryBuffer *) ((CStdProxyBuffer2 *)This)->pPSFactory;
        pFactory->lpVtbl->Release(pFactory);

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset(This,  '\0', sizeof(CStdProxyBuffer2));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(This);
    }

    return count;
};


ULONG STDMETHODCALLTYPE
CStdAsyncProxyBuffer_Release(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    // We do not need to go through punkOuter for ICallFactory
    // and so everything is local.

    CStdAsyncProxyBuffer * pAsyncPB = (CStdAsyncProxyBuffer *)This;
    ULONG                  count;


    NDR_ASSERT( pAsyncPB->RefCount > 0, "Async proxy Invalid reference count");

    count = (unsigned long) pAsyncPB->RefCount - 1;


    if ( InterlockedDecrement(&pAsyncPB->RefCount) == 0)
        {
        IPSFactoryBuffer * pFactory = pAsyncPB->pPSFactory;

        count = 0;

        // Release the pAsyncMsg and the related state
        NdrpAsyncProxyMsgDestructor( pAsyncPB );

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release( pFactory );

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset( pAsyncPB,  '\32', sizeof(CStdAsyncProxyBuffer));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(pAsyncPB);
        }

    return count;
};


ULONG STDMETHODCALLTYPE
CStdAsyncProxyBuffer2_Release(
    IN  IRpcProxyBuffer *   This)
/*++

Routine Description:
    Decrement reference count.  This function is used by proxies
    which delegate to the base interface.

Arguments:
    This - Points to a CStdProxyBuffer2.

Return Value:
    Reference count.

--*/
{
    CStdAsyncProxyBuffer * pAsyncPB = (CStdAsyncProxyBuffer *)This;
    ULONG                  count;

    NDR_ASSERT( pAsyncPB->RefCount > 0, "Invalid reference count");

    count = (ULONG) pAsyncPB->RefCount - 1;

    if ( InterlockedDecrement(&pAsyncPB->RefCount) == 0)
        {
        IRpcProxyBuffer *   pBaseProxyBuffer ;
        IPSFactoryBuffer *  pFactory = pAsyncPB->pPSFactory;

        count = 0;

        // Delegation support - release the base async proxy.

        if( pAsyncPB->map.pBaseProxy != 0)
            {
            // Shannon - why?
            //This is a weak reference, so we don't release it.
            //pBaseProxy->lpVtbl->Release(pBaseProxy);
            }

        pBaseProxyBuffer = pAsyncPB->pBaseProxyBuffer;

        if( pBaseProxyBuffer != 0)
            pBaseProxyBuffer->lpVtbl->Release(pBaseProxyBuffer);

        // Release the pAsyncMsg and the related state
        NdrpAsyncProxyMsgDestructor( (CStdAsyncProxyBuffer*)This );

        // Then clean up the async proxy itself.

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release(pFactory);

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset(pAsyncPB,  '\32', sizeof(CStdAsyncProxyBuffer));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(pAsyncPB);
        }

    return count;
};


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_RMB_QueryInterface(
    IN  IReleaseMarshalBuffers   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub IReleaseMarshalBuffers pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works the same way for ProxyBuffer2 and AsyncProxyBuffer.
--*/
{
    CStdProxyBuffer * pSyncPB = (CStdProxyBuffer *)
                        ((uchar *)This - offsetof(CStdProxyBuffer,pRMBVtbl));

    return pSyncPB->lpVtbl->QueryInterface( (IRpcProxyBuffer *)pSyncPB,
                                            riid,
                                            ppvObject );
}


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_RMB_AddRef(
    IN  IReleaseMarshalBuffers *This)
/*++

Routine Description:
    Implementation of AddRef for interface proxy.

Arguments:

Return Value:
    Reference count.
    
--*/
{
    ULONG  count;

    CStdProxyBuffer * pSyncPB = (CStdProxyBuffer *)
                        ((uchar *)This - offsetof(CStdProxyBuffer,pRMBVtbl));

    // It needs to go through punkOuter.

    count = pSyncPB->lpVtbl->AddRef((IRpcProxyBuffer *) pSyncPB );
    return count;
};


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_RMB_Release(
    IN  IReleaseMarshalBuffers *This)
/*++

Routine Description:
    Implementation of Release for interface proxy.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG               count;

    CStdProxyBuffer2 * pSyncPB = (CStdProxyBuffer2 *)
                        ((uchar *)This - offsetof(CStdProxyBuffer2,pRMBVtbl));

    count = pSyncPB->lpVtbl->Release( (IRpcProxyBuffer *)pSyncPB);

    return count;
};


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_RMB_ReleaseMarshalBuffer(
    IN IReleaseMarshalBuffers *This,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwFlags,
    IN IUnknown *pChnl)
{
    CStdProxyBuffer *      pSyncPB;
    HRESULT hr;
    if (NULL != pChnl)
        return E_INVALIDARG;

    // [in] only in client side.
    if (dwFlags)
        return E_INVALIDARG;
             
    hr = NdrpClientReleaseMarshalBuffer(This,
                                        (RPC_MESSAGE *)pMsg, 
                                        dwFlags,
                                        FALSE );    // SYNC 

    return hr;
}

#define IN_BUFFER           0
#define OUT_BUFFER          1

// the pRMBVtbl member is in the same position is both CStdProxyBuffer(2) and 
//     CStdAsyncProxyBuffer so we can cast it anyway.
HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_RMB_ReleaseMarshalBuffer(
    IN IReleaseMarshalBuffers *This,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwIOFlags,
    IN IUnknown *pChnl)
{
    HRESULT hr;
    if (NULL != pChnl)
        return E_INVALIDARG;

    // [in] only in client side.
    if (dwIOFlags != IN_BUFFER)
        return E_INVALIDARG;
             
    hr = NdrpClientReleaseMarshalBuffer(This,
                                        (RPC_MESSAGE *)pMsg, 
                                        dwIOFlags,
                                        TRUE);      // is async

    return hr;
}



HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_Connect(
    IN  IRpcProxyBuffer *   This,
    IN  IRpcChannelBuffer * pChannel)
/*++

Routine Description:
    Connect the proxy to the channel.

Arguments:
    pChannel - Supplies a pointer to the channel.

Return Value:
    S_OK

--*/
{
    CStdProxyBuffer   *     pCThis  = (CStdProxyBuffer *) This;
    HRESULT                 hr;
    IRpcChannelBuffer *     pTemp = 0;

    //
    // Get a pointer to the new channel.
    //
    hr = pChannel->lpVtbl->QueryInterface(
        pChannel, IID_IRpcChannelBuffer, (void **) &pTemp);

    if(hr == S_OK)
    {
        //
        // Save the pointer to the new channel.
        //
        pTemp = (IRpcChannelBuffer *) InterlockedExchangePointer(
            (PVOID *) &pCThis->pChannel, (PVOID) pTemp);

        if(pTemp != 0)
        {
            //
            //Release the old channel.
            //
            pTemp->lpVtbl->Release(pTemp);
            pTemp = 0;
        }
    }
    return hr;
};


HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_Connect(
    IN  IRpcProxyBuffer *   This,
    IN  IRpcChannelBuffer * pChannel)
/*++

Routine Description:
    Connect the proxy to the channel.

Arguments:
    pChannel - Supplies a pointer to the channel.

Return Value:
    S_OK

--*/
{
    CStdProxyBuffer   *     pCThis  = (CStdProxyBuffer *) This;
    HRESULT                 hr;
    IRpcChannelBuffer *    pTemp = 0;

    // Get a pointer to the new channel.
    // Note, the async proxy is not aggregated with the channel,
    // It simply keeps the channel pointer.
    //
    hr = pChannel->lpVtbl->QueryInterface(
        pChannel, IID_IAsyncRpcChannelBuffer, (void **) &pTemp);

    if(hr == S_OK)
    {
        //
        // Save the pointer to the new channel.
        //
        pTemp = (IRpcChannelBuffer *) InterlockedExchangePointer(
            (PVOID *) &pCThis->pChannel, (PVOID) pTemp);

        if(pTemp != 0)
        {
            //
            //Release the old channel.
            //
            pTemp->lpVtbl->Release(pTemp);
            pTemp = 0;
        }
    }
    return hr;
};



HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_Connect(
    IN  IRpcProxyBuffer *   This,
    IN  IRpcChannelBuffer * pChannel)
/*++

Routine Description:
    Connect the proxy to the channel.  Supports delegation.

Arguments:
    pChannel - Supplies a pointer to the channel.

Return Value:
    S_OK
        E_NOINTERFACE
        E_OUTOFMEMORY

--*/
{
    HRESULT                 hr;
    IRpcProxyBuffer *       pBaseProxyBuffer;
    IRpcChannelBuffer *     pWrapper;
    const IID *             pIID;

    hr = CStdProxyBuffer_Connect(This, pChannel);

    if(SUCCEEDED(hr))
    {
        pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

        if(pBaseProxyBuffer != 0)
        {
           pIID = NdrGetProxyIID(&((CStdProxyBuffer2 *)This)->pProxyVtbl);

            hr = CreateChannelWrapper(pIID,
                                      pChannel,
                                      &pWrapper);
            if(SUCCEEDED(hr))
            {
                hr = pBaseProxyBuffer->lpVtbl->Connect(pBaseProxyBuffer, pWrapper);
                // HACKALERT: OleAutomation returns NULL pv in CreateProxy
                // in cases where they don't know whether to return an NDR
                // proxy or a custom-format proxy. So we have to go connect
                // the proxy first then Query for the real interface once that
                // is done.
                if((NULL == ((CStdProxyBuffer2 *)This)->pBaseProxy) &&
                   SUCCEEDED(hr))
                {
                    IUnknown *pv;

                    hr = pBaseProxyBuffer->lpVtbl->QueryInterface(pBaseProxyBuffer,
                                                                  ((CStdProxyBuffer2 *)This)->iidBase,
                                                                  (void **) &pv);
                    if(SUCCEEDED(hr))
                    {
                        //Release our reference here.
                        pv->lpVtbl->Release(pv);

                        //We keep a weak reference to pv.
                        ((CStdProxyBuffer2 *)This)->pBaseProxy = pv;
                    }
                }
                pWrapper->lpVtbl->Release(pWrapper);
            }
        }
    }

    return hr;
};


HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer2_Connect(
    IN  IRpcProxyBuffer *   This,
    IN  IRpcChannelBuffer * pChannel)
/*++

Routine Description:
    Connect the proxy to the channel.  Supports delegation.

Arguments:
    pChannel - Supplies a pointer to the channel.

Return Value:
    S_OK
        E_NOINTERFACE
        E_OUTOFMEMORY

--*/
{
    HRESULT                 hr;
    IRpcProxyBuffer *       pBaseProxyBuffer;
    IRpcChannelBuffer *     pWrapper;
    const IID *             pIID;

    hr = CStdAsyncProxyBuffer_Connect(This, pChannel);

    if(SUCCEEDED(hr))
    {
        // Note that all the fields from CStdProxyBuffer2 that we indicate below
        // have the same offsets in CStdAsyncProxyBuffer that is being handled.
        // So I leave the cast unchanged to make future code merge easier.
        //
        pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

        if(pBaseProxyBuffer != 0)
        {
            pIID = NdrGetProxyIID(&((CStdProxyBuffer2 *)This)->pProxyVtbl);

            // We need a pChannel that is guaranteed to be IAsyncRpcChannelBuffer -
            // but note, this is exactly what we obtained in the Connect call above.

            hr = CreateAsyncChannelWrapper( pIID,
                                           ((CStdProxyBuffer2*)This)->pChannel,
                                            &pWrapper);
            if(SUCCEEDED(hr))
            {
                hr = pBaseProxyBuffer->lpVtbl->Connect(pBaseProxyBuffer, pWrapper);

                // This hack alert is rather for future.
                // HACKALERT: OleAutomation returns NULL pv in CreateProxy
                // in cases where they don't know whether to return an NDR
                // proxy or a custom-format proxy. So we have to go connect
                // the proxy first then Query for the real interface once that
                // is done.
                if((NULL == ((CStdProxyBuffer2 *)This)->pBaseProxy) &&
                   SUCCEEDED(hr))
                {
                    IUnknown *pv;

                    hr = pBaseProxyBuffer->lpVtbl->QueryInterface(pBaseProxyBuffer,
                                                                  ((CStdProxyBuffer2 *)This)->iidBase,
                                                                  (void **) &pv);
                    if(SUCCEEDED(hr))
                    {
                        //Release our reference here.
                        pv->lpVtbl->Release(pv);

                        //We keep a weak reference to pv.
                        ((CStdProxyBuffer2 *)This)->pBaseProxy = pv;
                    }
                }
                pWrapper->lpVtbl->Release(pWrapper);
            }
        }
    }

    return hr;
};


void STDMETHODCALLTYPE
CStdProxyBuffer_Disconnect(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Disconnect the proxy from the channel.
    
Also used for:
    CStdAsyncProxyBuffer_Disconnect

Arguments:

Return Value:
    None.

--*/
{
    CStdProxyBuffer   * pCThis  = (CStdProxyBuffer *) This;
    IRpcChannelBuffer * pOldChannel;

    pOldChannel = (IRpcChannelBuffer *) InterlockedExchangePointer(
                                        (PVOID *) &pCThis->pChannel, 0);

    if(pOldChannel != 0)
    {
        //Release the old channel.
        //
        pOldChannel->lpVtbl->Release(pOldChannel);
    }
};

void STDMETHODCALLTYPE
CStdProxyBuffer2_Disconnect(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Disconnect the proxy from the channel.

Also used for:
    CStdAsyncProxyBuffer2_Disconnect

Arguments:

Return Value:
    None.

--*/
{
    IRpcProxyBuffer *pBaseProxyBuffer;

    CStdProxyBuffer_Disconnect(This);

    pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

    if(pBaseProxyBuffer != 0)
        pBaseProxyBuffer->lpVtbl->Disconnect(pBaseProxyBuffer);
};


HRESULT
NdrpCreateNonDelegatedAsyncProxy( 
//CStdProxyBuffer_CreateAsyncProxy(
    IN  IRpcProxyBuffer         *This, 
    IN  REFIID                  riid, // async IID
    IN  IUnknown *              punkOuter, // controlling unknown
    OUT CStdAsyncProxyBuffer ** ppAsyncProxy
    )
/*
    Creates a call object, i.e. an async proxy object.
    An async proxy doesn't have a pSynchronize, just passes it.
    
    Note, because the call comes via a CStdProxyBuffer, not Buffer2,
    we know that we need to create only a non-delegated async proxy.
    This is because CStdProxyBuffer itself is a non-delegated proxy.
*/
{
    BOOL                    fFound;
    long                    j;   // if index
    const ProxyFileInfo *   pProxyFileInfo;

    CStdProxyBuffer *       pSyncPB = (CStdProxyBuffer *)This;

    *ppAsyncProxy = 0;
    
    if ( ! pSyncPB->pCallFactoryVtbl  ||  !pSyncPB->pAsyncIID )
        return E_NOINTERFACE;

    // Check if sync and async iids match.

    if ( memcmp( &riid, pSyncPB->pAsyncIID, sizeof(IID)) != 0 )
        return E_NOINTERFACE;

    // same file, so we can use the sync pPSFactory.

    fFound = NdrpFindInterface( ((CStdPSFactoryBuffer *)pSyncPB->pPSFactory)->pProxyFileList, 
                                riid, 
                                &pProxyFileInfo, 
                                & j);
    if ( !fFound )
        return E_NOINTERFACE;

    CStdAsyncProxyBuffer *pAsyncPB = 
        (CStdAsyncProxyBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdAsyncProxyBuffer));
        
    if( ! pAsyncPB )
        return E_OUTOFMEMORY;

    memset( pAsyncPB, 0, sizeof(CStdAsyncProxyBuffer));
    //
    //  Everything gets zeroed out regardless of their position
    //  when mapping CStdBuffer vs. CstdBuffer2 into CStdAsyncBuffer

    // Non-delegated case.

    pAsyncPB->lpVtbl     = & CStdAsyncProxyBufferVtbl;
    pAsyncPB->pProxyVtbl = & pProxyFileInfo->pProxyVtblList[j]->Vtbl;
    pAsyncPB->RefCount   = 1;
    pAsyncPB->punkOuter  = punkOuter ? punkOuter 
                                     : (IUnknown *) pAsyncPB;
                                         
    pAsyncPB->pSyncIID   = NdrGetProxyIID( &pSyncPB->pProxyVtbl );
    // Note, no connection to channel yet.
    // Actually we never call create call on the channel.
                                  
    NdrpAsyncProxyMsgConstructor( pAsyncPB );

    // Increment the DLL reference count for DllCanUnloadNow.
    // Same dll, so we can use the sync pPSFactory.
    //
    pSyncPB->pPSFactory->lpVtbl->AddRef( pSyncPB->pPSFactory );
    // This is in the "map".
    ((CStdProxyBuffer *)pAsyncPB)->pPSFactory = pSyncPB->pPSFactory;

    // Just have it in both places.
    pAsyncPB->pPSFactory = pSyncPB->pPSFactory;

    *ppAsyncProxy = pAsyncPB;

    return S_OK;
}


HRESULT
// CStdProxyBuffer2_CreateAsyncProxy(
NdrpCreateDelegatedAsyncProxy(
    IN  IRpcProxyBuffer         *This, 
    IN  REFIID                  riid, // async IID
    IN  IUnknown *              punkOuter, // controlling unknown
    OUT CStdAsyncProxyBuffer ** ppAsyncProxy   
    )
/*
    Creates a call object, i.e. an async proxy object.
    
    Note, because the call comes via a CStdProxyBuffer2, not Buffer,
    we know that we need to create only a delegated async proxy.
*/
{
    HRESULT                 hr;
    BOOL                    fFound;
    long                     j;   // if index
    const ProxyFileInfo *   pProxyFileInfo;

    CStdProxyBuffer2 *      pSyncPB = (CStdProxyBuffer2 *)This;
    CStdAsyncProxyBuffer    *pBaseAsyncPB;

    ICallFactory *          pCallFactory;

    *ppAsyncProxy = 0;
    
    if ( ! pSyncPB->pCallFactoryVtbl  ||  !pSyncPB->pAsyncIID )
        return E_NOINTERFACE;

    if ( memcmp( &riid, pSyncPB->pAsyncIID, sizeof(IID)) != 0 )
        return E_NOINTERFACE;

    // same file, so we can use the sync pPSFactory.

    fFound = NdrpFindInterface( ((CStdPSFactoryBuffer *)pSyncPB->pPSFactory)->pProxyFileList, 
                                riid, 
                                &pProxyFileInfo, 
                                & j);
    if ( !fFound )
        return E_NOINTERFACE;

    // Create async proxy.

    CStdAsyncProxyBuffer *pAsyncPB = 
        (CStdAsyncProxyBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdAsyncProxyBuffer));
        
    if( ! pAsyncPB )
        return E_OUTOFMEMORY;

    memset( pAsyncPB, 0, sizeof(CStdAsyncProxyBuffer));
    //
    //  Everything gets zeroed out regardless of their position
    //  when mapping CStdBuffer vs. CstdBuffer2 into CStdAsyncBuffer

    // Fill in for a delegated case.

    pAsyncPB->lpVtbl     = & CStdAsyncProxyBuffer2Vtbl;
    pAsyncPB->pProxyVtbl = & pProxyFileInfo->pProxyVtblList[j]->Vtbl;
    pAsyncPB->RefCount   = 1;
    pAsyncPB->punkOuter  = punkOuter ? punkOuter 
                                     : (IUnknown *) pAsyncPB;
    pAsyncPB->iidBase    = *pProxyFileInfo->pDelegatedIIDs[j];
    pAsyncPB->pPSFactory = pSyncPB->pPSFactory;
    pAsyncPB->pSyncIID   = NdrGetProxyIID( &pSyncPB->pProxyVtbl );
                                 
    // Note, no connection to channel yet.
    // So we cannot call create call on the channel.

    NdrpAsyncProxyMsgConstructor( pAsyncPB );

    // Create an async proxy for the base interface.
    // We don't know if the base is delegated, so we have to use base call factory.
    // Get the call factory from the base proxy.

    hr = pSyncPB->pBaseProxyBuffer->lpVtbl->QueryInterface(
                                                   pSyncPB->pBaseProxyBuffer,
                                                   IID_ICallFactory,
                                                   (void**)& pCallFactory );

    if ( SUCCEEDED(hr) )
        {
        const IID * pBaseAsyncIID;

        pBaseAsyncIID = *(const IID **)( (uchar*)pSyncPB->pBaseProxyBuffer
                                         + offsetof(CStdProxyBuffer, pAsyncIID));

        // Aggregate the base async proxy with the current async proxy,
        // not with the channel's punkOuter.
    
        hr = pCallFactory->lpVtbl->CreateCall( pCallFactory,
                                               *pBaseAsyncIID,
                                               (IUnknown*) pAsyncPB,
                                               IID_IUnknown,
                                               (IUnknown**)& pBaseAsyncPB );
        pCallFactory->lpVtbl->Release( pCallFactory );
        }


    if ( SUCCEEDED(hr) )
        {
        // Increment the DLL reference count for DllCanUnloadNow.
        // Same dll, so we can use the sync pPSFactory.
        //
        pSyncPB->pPSFactory->lpVtbl->AddRef( pSyncPB->pPSFactory );

        // Hook up the base async proxy.
    
        pAsyncPB->pBaseProxyBuffer = (IRpcProxyBuffer*) pBaseAsyncPB;
        pAsyncPB->map.pBaseProxy   = (IUnknown *) & pBaseAsyncPB->pProxyVtbl;

        *ppAsyncProxy = pAsyncPB;
        }
    else
        {
        (*pfnCoTaskMemFree)( pAsyncPB );
        }

    return hr;
}


//
//  ICallFactory interface on the sync ProxyBuffer and ProxyBuffer2 objects.
//

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_CF_QueryInterface(
    IN  ICallFactory   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works the same way for ProxyBuffer2 and AsyncProxyBuffer.
--*/
{
    CStdProxyBuffer * pSyncPB = (CStdProxyBuffer *)
                        ((uchar *)This - offsetof(CStdProxyBuffer,pCallFactoryVtbl));

    return pSyncPB->punkOuter->lpVtbl->QueryInterface( pSyncPB->punkOuter,
                                                       riid,
                                                       ppvObject );
}


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_CF_AddRef(
    IN  ICallFactory *This)
/*++

Routine Description:
    Implementation of AddRef for interface proxy.

Arguments:

Return Value:
    Reference count.
    
--*/
{
    ULONG  count;

    CStdProxyBuffer * pSyncPB = (CStdProxyBuffer *)
                        ((uchar *)This - offsetof(CStdProxyBuffer,pCallFactoryVtbl));

    // It needs to go through punkOuter.

    count = pSyncPB->punkOuter->lpVtbl->AddRef( pSyncPB->punkOuter );
    return count;
};


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_CF_Release(
    IN  ICallFactory *This)
/*++

Routine Description:
    Implementation of Release for interface proxy.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG               count;

    CStdProxyBuffer2 * pSyncPB = (CStdProxyBuffer2 *)
                        ((uchar *)This - offsetof(CStdProxyBuffer2,pCallFactoryVtbl));

    count = pSyncPB->punkOuter->lpVtbl->Release( pSyncPB->punkOuter );

    return count;
};


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_CF_CreateCall(
    IN  ICallFactory *This, 
    IN  REFIID        riid, 
    IN  IUnknown *    punkOuter, // controlling unknown
    IN  REFIID        riid2, 
    OUT IUnknown **   ppv   
    )
/*
    Creates a call object, i.e. an async proxy object.
    
    Note, because the call comes via a CStdProxyBuffer, not Buffer2,
    we know that we need to create only a non-delegated async proxy.
*/
{
    CStdProxyBuffer * pSyncPB;

    if ( memcmp( &riid2, &IID_IUnknown, sizeof(IID)) != 0 )
        return E_INVALIDARG;
              
    pSyncPB = (CStdProxyBuffer *)
                  (((uchar *)This) - offsetof( CStdProxyBuffer, pCallFactoryVtbl ));
    
    return NdrpCreateNonDelegatedAsyncProxy( (IRpcProxyBuffer*) pSyncPB, 
                                      riid,
                                      punkOuter,
                                      (CStdAsyncProxyBuffer**) ppv );
}

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_CF_CreateCall(
    IN  ICallFactory *This, 
    IN  REFIID        riid, 
    IN  IUnknown *    punkOuter, // controlling unknown
    IN  REFIID        riid2, 
    OUT IUnknown **   ppv   
    )
/*
    Creates a call object, i.e. an async proxy object.

    Note, because the virtual call comes via a CStdProxyBuffer2,
    we know that we need to create only a delegated async proxy.
*/
{
    CStdProxyBuffer2 *      pSyncPB;

    if ( memcmp( &riid2, &IID_IUnknown, sizeof(IID)) != 0 )
        return E_INVALIDARG;
              
    pSyncPB = (CStdProxyBuffer2 *)
                  (((uchar *)This) - offsetof( CStdProxyBuffer2, pCallFactoryVtbl ));

    return NdrpCreateDelegatedAsyncProxy( (IRpcProxyBuffer*) pSyncPB, 
                                          riid,
                                          punkOuter,
                                          (CStdAsyncProxyBuffer**) ppv );
}
/*
HRESULT STDAPICALLTYPE
NdrClientReleaseMarshalBuffer(
    IN IRpcProxyBuffer *pProxy,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwFlags,
    IN IUnknown *pChnl)
{
    CStdProxyBuffer *      pSyncPB;
    void * This = NULL;
    HRESULT hr;

    if (NULL != pChnl)
        return E_INVALIDARG;

    if (dwFlags)
        return E_INVALIDARG;

    hr = pProxy->lpVtbl->QueryInterface(pProxy,&IID_IReleaseMarshalBuffers, &This);
    if (FAILED(hr))
        return E_NOTIMPL;
             
    pSyncPB = (CStdProxyBuffer *)
                  (((uchar *)This) - offsetof( CStdProxyBuffer, lpVtbl ));

    hr = NdrpClientReleaseMarshalBuffer(pSyncPB,(RPC_MESSAGE *)pMsg, dwFlags);
    ((IRpcProxyBuffer *)This)->lpVtbl->Release(This);

    return hr;
}

*/

//
//   IUknown Query, AddRef and Release.
//
HRESULT STDMETHODCALLTYPE
IUnknown_QueryInterface_Proxy(
    IN  IUnknown *  This,
    IN  REFIID      riid,
    OUT void **     ppv)
/*++

Routine Description:
    Implementation of QueryInterface for interface proxy.

Arguments:
    riid - Supplies the IID of the requested interface.
    ppv  - Returns a pointer to the requested interface.

Return Value:
    S_OK
        E_NOINTERFACE

--*/
{
    HRESULT             hr = E_NOINTERFACE;
    CStdProxyBuffer *   pProxyBuffer;

    pProxyBuffer = NdrGetProxyBuffer(This);

    hr = pProxyBuffer->punkOuter->lpVtbl->QueryInterface(
                                pProxyBuffer->punkOuter, riid, ppv);

    return hr;
};


ULONG STDMETHODCALLTYPE
IUnknown_AddRef_Proxy(
    IN  IUnknown *This)
/*++

Routine Description:
    Implementation of AddRef for interface proxy.

Arguments:

Return Value:
    Reference count.

--*/
{
    CStdProxyBuffer *   pProxyBuffer;
    ULONG               count;

    pProxyBuffer = NdrGetProxyBuffer(This);
    count = pProxyBuffer->punkOuter->lpVtbl->AddRef(pProxyBuffer->punkOuter);

    return count;
};


ULONG STDMETHODCALLTYPE
IUnknown_Release_Proxy(
    IN  IUnknown *This)
/*++

Routine Description:
    Implementation of Release for interface proxy.

Arguments:

Return Value:
    Reference count.

--*/
{
    CStdProxyBuffer *   pProxyBuffer;
    ULONG               count;

    pProxyBuffer = NdrGetProxyBuffer(This);
    count = pProxyBuffer->punkOuter->lpVtbl->Release(pProxyBuffer->punkOuter);

    return count;
};



void RPC_ENTRY
NdrProxyInitialize(
    IN  void * pThis,
    IN  PRPC_MESSAGE        pRpcMsg,
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PMIDL_STUB_DESC     pStubDescriptor,
    IN  unsigned int        ProcNum )
/*++

Routine Description:
    Initialize the MIDL_STUB_MESSAGE.

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pRpcMsg
        pStubMsg
        pStubDescriptor
        ProcNum

Return Value:

--*/
{
    CStdProxyBuffer *   pProxyBuffer;
    HRESULT             hr;

    pProxyBuffer = NdrGetProxyBuffer(pThis);

    //
    // Initialize the stub message fields.
    //
    NdrClientInitializeNew(
        pRpcMsg,
        pStubMsg,
        pStubDescriptor,
        ProcNum );

    //Note that NdrClientInitializeNew sets RPC_FLAGS_VALID_BIT in the ProcNum.
    //We don't want to do this for object interfaces, so we clear the flag here.
    pRpcMsg->ProcNum &= ~RPC_FLAGS_VALID_BIT;

    pStubMsg->pRpcChannelBuffer = pProxyBuffer->pChannel;

    //Check if we are connected to a channel.
    if(pStubMsg->pRpcChannelBuffer != 0)
    {
        //AddRef the channel.
        //We will release it later in NdrProxyFreeBuffer.
        pStubMsg->pRpcChannelBuffer->lpVtbl->AddRef(pStubMsg->pRpcChannelBuffer);

        //Get the destination context from the channel
        hr = pStubMsg->pRpcChannelBuffer->lpVtbl->GetDestCtx(
            pStubMsg->pRpcChannelBuffer, &pStubMsg->dwDestContext, &pStubMsg->pvDestContext);
    }
    else
    {
        //We are not connected to a channel.
        RpcRaiseException(CO_E_OBJNOTCONNECTED);
    }
}


void RPC_ENTRY
NdrProxyGetBuffer(
    IN  void *              pThis,
    IN  PMIDL_STUB_MESSAGE  pStubMsg)
/*++

Routine Description:
    Get a message buffer from the channel

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pStubMsg

Return Value:
    None.  If an error occurs, this function will raise an exception.

--*/
{
    HRESULT     hr;

    const IID * pIID = NdrGetProxyIID(pThis);
    pStubMsg->RpcMsg->BufferLength = pStubMsg->BufferLength;
    pStubMsg->RpcMsg->DataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;
    pStubMsg->dwStubPhase = PROXY_GETBUFFER;

    hr = pStubMsg->pRpcChannelBuffer->lpVtbl->GetBuffer(
        pStubMsg->pRpcChannelBuffer,
        (RPCOLEMESSAGE *) pStubMsg->RpcMsg,
        *pIID);

    pStubMsg->dwStubPhase = PROXY_MARSHAL;

    if(FAILED(hr))
    {
        RpcRaiseException(hr);
    }
    else
    {
        NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                    "marshaling buffer misaligned" );

        pStubMsg->Buffer = (unsigned char *) pStubMsg->RpcMsg->Buffer;
        pStubMsg->fBufferValid = TRUE;
    }
}


void RPC_ENTRY
NdrProxySendReceive(
    IN  void *              pThis,
    IN  MIDL_STUB_MESSAGE * pStubMsg)
/*++

Routine Description:
    Send a message to server, then wait for reply message.

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pStubMsg

Return Value:
        None.  If an error occurs, this function will raise an exception.

--*/
{
    HRESULT hr;
    DWORD   dwStatus;

    //Calculate the number of bytes to send.

    if ( pStubMsg->RpcMsg->BufferLength <
            (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer))
        {
        NDR_ASSERT( 0, "NdrProxySendReceive : buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    pStubMsg->RpcMsg->BufferLength = (ulong)( pStubMsg->Buffer -
                                   (unsigned char *) pStubMsg->RpcMsg->Buffer );

    pStubMsg->fBufferValid = FALSE;
    pStubMsg->dwStubPhase = PROXY_SENDRECEIVE;

    hr = pStubMsg->pRpcChannelBuffer->lpVtbl->SendReceive(
        pStubMsg->pRpcChannelBuffer,
        (RPCOLEMESSAGE *) pStubMsg->RpcMsg, &dwStatus);

    pStubMsg->dwStubPhase = PROXY_UNMARSHAL;

    if(FAILED(hr))
    {
        switch(hr)
        {
        case RPC_E_FAULT:
            RpcRaiseException(dwStatus);
            break;

        default:
            RpcRaiseException(hr);
            break;
        }
    }
    else
    {
        NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                    "marshaling buffer misaligned" );

        pStubMsg->Buffer = (uchar*)pStubMsg->RpcMsg->Buffer;
        pStubMsg->BufferStart = pStubMsg->Buffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pStubMsg->RpcMsg->BufferLength;
        pStubMsg->fBufferValid = TRUE;
    }
}


void RPC_ENTRY
NdrProxyFreeBuffer(
    IN  void *              pThis,
    IN  MIDL_STUB_MESSAGE * pStubMsg)
/*++

Routine Description:
    Free the message buffer.

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pStubMsg

Return Value:
    None.

--*/
{
    if(pStubMsg->pRpcChannelBuffer != 0)
    {
        //Free the message buffer.
        if(pStubMsg->fBufferValid == TRUE)
            {
            // If pipes, we need to reset the partial bit for some reason.

            pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;

            pStubMsg->pRpcChannelBuffer->lpVtbl->FreeBuffer(
                pStubMsg->pRpcChannelBuffer, (RPCOLEMESSAGE *) pStubMsg->RpcMsg);
            }

        //Release the channel.
        pStubMsg->pRpcChannelBuffer->lpVtbl->Release(pStubMsg->pRpcChannelBuffer);
        pStubMsg->pRpcChannelBuffer = 0;
    }
}

HRESULT RPC_ENTRY
NdrProxyErrorHandler(
    IN  DWORD dwExceptionCode)
/*++

Routine Description:
    Maps an exception code into an HRESULT failure code.

Arguments:
    dwExceptionCode

Return Value:
   This function returns an HRESULT failure code.

--*/
{
    HRESULT hr = dwExceptionCode;

    if(FAILED((HRESULT) dwExceptionCode))
        hr = (HRESULT) dwExceptionCode;
    else
        hr = HRESULT_FROM_WIN32(dwExceptionCode);

    return hr;
}


HRESULT STDMETHODCALLTYPE
CreateChannelWrapper
/*++

Routine Description:
    Creates a wrapper for the channel.  The wrapper ensures
        that we use the correct IID when the proxy for the base
        interface calls GetBuffer.

Arguments:
    pIID
        pChannel
        pChannelWrapper

Return Value:
    S_OK
        E_OUTOFMEMORY

--*/
(
    const IID *             pIID,
    IRpcChannelBuffer *     pChannel,
    IRpcChannelBuffer **    ppChannelWrapper
)
{
    HRESULT hr;
    ChannelWrapper *pWrapper = 
        (ChannelWrapper*)(*pfnCoTaskMemAlloc)(sizeof(ChannelWrapper));

    if(pWrapper != 0)
    {
        hr = S_OK;
        pWrapper->lpVtbl = (IRpcChannelBufferVtbl*) &ChannelWrapperVtbl;
        pWrapper->RefCount = 1;
        pWrapper->pIID = pIID;
        pChannel->lpVtbl->AddRef(pChannel);
        pWrapper->pChannel = pChannel;
        *ppChannelWrapper = (IRpcChannelBuffer *) pWrapper;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppChannelWrapper = 0;
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
CreateAsyncChannelWrapper
/*++

Routine Description:
    Creates a wrapper for the channel.  The wrapper ensures
        that we use the correct IID when the proxy for the base
        interface calls GetBuffer.

Arguments:
    pIID
        pChannel
        pChannelWrapper

Return Value:
    S_OK
        E_OUTOFMEMORY

--*/
(
    const IID *             pIID,
    IRpcChannelBuffer *     pChannel,
    IRpcChannelBuffer **    ppChannelWrapper
)
{
    HRESULT hr;
    ChannelWrapper *pWrapper = 
        (ChannelWrapper*)(*pfnCoTaskMemAlloc)(sizeof(ChannelWrapper));

    if(pWrapper != 0)
    {
        hr = S_OK;
        pWrapper->lpVtbl = (IRpcChannelBufferVtbl*) &AsyncChannelWrapperVtbl;
        pWrapper->RefCount = 1;
        pWrapper->pIID = pIID;
        pChannel->lpVtbl->AddRef(pChannel);
        pWrapper->pChannel = pChannel;
        *ppChannelWrapper = (IRpcChannelBuffer *) pWrapper;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppChannelWrapper = 0;
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_QueryInterface
/*++

Routine Description:
    The channel wrapper supports the IUnknown and IRpcChannelBuffer interfaces.

Arguments:
    riid
        ppvObject

Return Value:
    S_OK
        E_NOINTERFACE

--*/
(
    IRpcChannelBuffer3 * This,
    REFIID riid,
    void **ppvObject
)
{
    HRESULT hr;

    if((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer2, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer3, sizeof(IID)) == 0))
    {
        hr = S_OK;
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = 0;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_QueryInterface
/*++

Routine Description:
    The channel wrapper supports the IUnknown and IRpcChannelBuffer interfaces.

Arguments:
    riid
        ppvObject

Return Value:
    S_OK
        E_NOINTERFACE

--*/
    (
    IAsyncRpcChannelBuffer *    This,
    REFIID                      riid,
    void **                     ppvObject
    )
{
    HRESULT hr;

    if((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer2, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IAsyncRpcChannelBuffer, sizeof(IID)) == 0))
    {
        hr = S_OK;
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = 0;
    }

    return hr;
}


ULONG STDMETHODCALLTYPE
ChannelWrapper_AddRef
/*++

Routine Description:
    Increment reference count.

Arguments:

Return Value:
    Reference count.

--*/
(
    IRpcChannelBuffer3 * This
)
{
    ChannelWrapper *pWrapper = (ChannelWrapper *) This;

    InterlockedIncrement(&pWrapper->RefCount);

    return (ULONG) pWrapper->RefCount;

}

ULONG STDMETHODCALLTYPE
AsyncChannelWrapper_AddRef(
    IAsyncRpcChannelBuffer * This
    )
{
    return ChannelWrapper_AddRef( (IRpcChannelBuffer3 *) This );
}


ULONG STDMETHODCALLTYPE
ChannelWrapper_Release
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
(
    IRpcChannelBuffer3 * This
)
{
    unsigned long           count;
    IRpcChannelBuffer *     pChannel;

    NDR_ASSERT(((ChannelWrapper *)This)->RefCount > 0, "Invalid reference count");

    count = (unsigned long) ((ChannelWrapper *)This)->RefCount - 1;

    if(InterlockedDecrement(&((ChannelWrapper *)This)->RefCount) == 0)
    {
        count = 0;

        pChannel = ((ChannelWrapper *)This)->pChannel;

        if(pChannel != 0)
            pChannel->lpVtbl->Release(pChannel);

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset(This,  '\0', sizeof(ChannelWrapper));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(This);
    }

    return count;
}

ULONG STDMETHODCALLTYPE
AsyncChannelWrapper_Release(
    IAsyncRpcChannelBuffer * This
    )
{
    return ChannelWrapper_Release( (IRpcChannelBuffer3 *) This );
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetBuffer
/*++

Routine Description:
    Get a message buffer from the channel.
    
    This is the reason we have the ChannelWrapper at all.
    We replace the riid of the current proxy by the one from the Wrapper.

Arguments:
    pMessage
        riid

Return Value:

--*/
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *      pMessage,
    REFIID               riid
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;
    const IID *         pIID;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    pIID = ((ChannelWrapper *)This)->pIID;

    hr = pChannel->lpVtbl->GetBuffer(pChannel,
                                     pMessage,
                                     *pIID);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetBuffer(
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *      pMessage,
    REFIID               riid
    )
{
    return ChannelWrapper_GetBuffer( (IRpcChannelBuffer3 *) This,
                                     pMessage,
                                     riid );
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_SendReceive
/*++

Routine Description:
    Get a message buffer from the channel

Arguments:
    pMessage
        pStatus

Return Value:
    S_OK

--*/
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *      pMessage,
    ULONG *              pStatus
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->SendReceive(pChannel,
                                       pMessage,
                                       pStatus);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_SendReceive(
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *      pMessage,
    ULONG *              pStatus
    )
{
    // This can never happen for an async call stub.
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_FreeBuffer
/*++

Routine Description:
    Free the message buffer.

Arguments:
    pMessage

Return Value:
    S_OK

--*/
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *pMessage
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->FreeBuffer(pChannel,
                                      pMessage);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_FreeBuffer(
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *         pMessage
    )
{
    return ChannelWrapper_FreeBuffer( (IRpcChannelBuffer3 *) This,
                                      pMessage );
}



HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetDestCtx
/*++

Routine Description:
    Get the destination context from the channel

Arguments:
    pdwDestContext
        ppvDestContext

Return Value:
    S_OK

--*/
(
    IRpcChannelBuffer3 * This,
    DWORD              * pdwDestContext,
    void              ** ppvDestContext
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->GetDestCtx(pChannel,
                                      pdwDestContext,
                                      ppvDestContext);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetDestCtx(
    IAsyncRpcChannelBuffer * This,
    DWORD *                 pdwDestContext,
    void **                 ppvDestContext
    )
{
    return ChannelWrapper_GetDestCtx( (IRpcChannelBuffer3 *) This,
                                      pdwDestContext,
                                      ppvDestContext );
}



HRESULT STDMETHODCALLTYPE
ChannelWrapper_IsConnected
/*++

Routine Description:
    Determines if the channel is connected.

Arguments:

Return Value:
    S_TRUE
        S_FALSE

--*/
(
    IRpcChannelBuffer3 * This
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->IsConnected(pChannel);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_IsConnected(
    IAsyncRpcChannelBuffer * This
    )
{
    return ChannelWrapper_IsConnected( (IRpcChannelBuffer3 *) This );
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetProtocolVersion
/*++

Routine Description:
    Returns the protocol version if available.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
(
    IRpcChannelBuffer3 * This,
    DWORD             * pdwVersion
)
{
    HRESULT             hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer2 * pChannel2;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer2, (void**)&pChannel2);
    if (S_OK == hr)
    {
        hr = pChannel2->lpVtbl->GetProtocolVersion(pChannel2, pdwVersion);
        pChannel2->lpVtbl->Release(pChannel2);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetProtocolVersion(
    IAsyncRpcChannelBuffer * This,
    DWORD                  * pdwVersion
    )
{
    return ChannelWrapper_GetProtocolVersion( (IRpcChannelBuffer3 *) This,
                                              pdwVersion );
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_Send
/*++

Routine Description:
    Executes an asynchronous or partial send.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    (
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG *             pStatus 
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface( pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3 );
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->Send(pChannel3, pMessage, pStatus);
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_Send(
/*++

Routine Description:
    Executes an asynchronous or partial send.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *         pMessage,
    ISynchronize *          pSynchronize,
    ULONG *                 pStatus 
    )
{
    HRESULT                  hr;
    IRpcChannelBuffer  *     pChannel;
    IAsyncRpcChannelBuffer * pAsChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface( pChannel, 
                                           IID_IAsyncRpcChannelBuffer, 
                                           (void**)&pAsChannel );
    if (S_OK == hr)
    {
        hr = pAsChannel->lpVtbl->Send( pAsChannel, 
                                       pMessage, 
                                       pSynchronize,
                                       pStatus);
        pAsChannel->lpVtbl->Release( pAsChannel);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_Receive
/*++

Routine Description:
    Executes an asynchronous or partial receive.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    (
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG               ulSize,
    ULONG *             pStatus 
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->Receive( pChannel3, pMessage, ulSize, pStatus );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_Receive(
/*++

Routine Description:
    Executes an asynchronous or partial receive.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG *             pStatus 
    )
{
    HRESULT                 hr;
    IRpcChannelBuffer  *    pChannel;
    IAsyncRpcChannelBuffer *pAsChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface( pChannel, 
                                           IID_IAsyncRpcChannelBuffer, 
                                           (void**)&pAsChannel);
    if (S_OK == hr)
    {
        hr = pAsChannel->lpVtbl->Receive( pAsChannel, 
                                          pMessage, 
                                          pStatus );
        pAsChannel->lpVtbl->Release(pAsChannel);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_Cancel(
/*++

Routine Description:
    Executes an asynchronous Cancel.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->Cancel( pChannel3, pMessage );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetCallContext(
/*++

Routine Description:
    Gets an asynchronous call context.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    REFIID              riid,
    void    **          ppInterface
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->GetCallContext( pChannel3, pMessage, riid, ppInterface );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetDestCtxEx(
/*++

Routine Description:
    Gets an asynchronous call context.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *         pMessage,
    DWORD *                 pdw,
    void **                 ppv
    )
{
    HRESULT                     hr;
    IRpcChannelBuffer  *        pChannel;
    IAsyncRpcChannelBuffer *    pAsChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface( pChannel, 
                                           IID_IAsyncRpcChannelBuffer, 
                                           (void**)&pAsChannel);
    if (S_OK == hr)
    {
        hr = pAsChannel->lpVtbl->GetDestCtxEx( pAsChannel, 
                                               pMessage, 
                                               pdw, 
                                               ppv );
        pAsChannel->lpVtbl->Release(pAsChannel);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetDestCtxEx(
/*++

Routine Description:
    Gets the new destination context.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    DWORD *             pdwDestContext,
    void **             ppvDestContext
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->GetDestCtxEx( pChannel3, pMessage, pdwDestContext, ppvDestContext );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetState(
/*++

Routine Description:
    Gets the call state.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    DWORD         *     pState
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->GetState( pChannel3, pMessage, pState );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_RegisterAsync(
/*++

Routine Description:
    Registers the async manager object and call with the channel.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    IAsyncManager *     pAsyncMgr
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->RegisterAsync( pChannel3, pMessage, pAsyncMgr );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\round.cxx ===
/* file:  round.c */

/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module is an include file.
**
**      This module rounds CVT floating point data to any specified position.
**      Any of the following rounding modes can be applied:
**
**      Note: None of the following implementations ever perform true truncation
**            on their values.  Whenever truncation becomes necessary - either
**            by being specified directly or by being required indirectly
**            through rounding - values are actually left untouched.  Users
**            of this routine must zero out fractional fields themselves if
**            true truncation is needed.
**
**         VAX ROUNDING
**
**              Input data are rounded such that the representable value nearest
**              the infinitely precise result is delivered; if two representable
**              values are equally near, the one greatest in magnitude is
**              delivered.
**
**         ROUND TO NEAREST
**
**              Input data are rounded such that the representable value nearest
**              the infinitely precise result is delivered; if two representable
**              values are equally near, the one with its least significant bit
**              zero is delivered.
**
**         ROUND TO POSITIVE INFINITY
**
**              Input data are rounded such that the representable value closest
**              to and no less than the infinitely precise result is delivered.
**
**         ROUND TO NEGATIVE INFINITY
**
**              Input data are rounded such that the representable value closest
**              to and no greater than the infinitely precise result is
**              delivered.
**
**         TRUNCATION (ROUND TOWARDS ZERO)
**
**              True truncation is not implemented here.  Input values are
**              delivered in their original, untouched form.
**
**              A definition of "true" truncation follows:  Truncation, or
**              rounding towards zero, implies input data are rounded such
**              that the representable value closest to and no greater in
**              magnitude than the infinitely precise result is delivered.
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.
**              MRTL 5-Dec-1989.
**
**--
*/

/*
**
**  Implicit input/output:
**
**      r                       On input, a valid CVT floating point number.
**                              On output, a rounded representation of the
**                              input.
**
**
**  Implicit input:
**
**      round_bit_position      An integer specifying the position to round to.
**                              0 <= round_bit_position <= 127.
**
**                              Note: Valid CVT mantissa bits are addressed as 1
**                              through 128.  Accordingly, specifying 0 as a
**                              position to round to implies an exponent
**                              increase whenever rounding occurs.  As for
**                              truncation: truncation allways leaves a CVT
**                              number untouched.
**
**      options                 A valid CVT options bit mask in which at least
**                              one, and only one, CVT rounding mode is
**                              specified.  If no rounding mode is specified,
**                              results are unpredictable.  Rounding is
**                              performed in accordance with this mask.
**
**      i                       An uninitialized integer used for indexing.
**
**
**  Note: for efficiency this routine performs no explicit error checking.
**
*/


{
  int roundup, more_bits;
  unsigned long  bit_mask;


      /* Check TRUNCATE option */

  if ( ! (options & CVT_C_TRUNCATE) ) {

           /* Determine which word the round bit resides in */

      i = (round_bit_position >> 5) + 1;

           /* Create a mask isolating the round bit */

      bit_mask = 0x1L << (31 - (round_bit_position & 0x1FL));

           /* Check VAX ROUNDING option */

      if (options & CVT_C_VAX_ROUNDING)
          roundup = r[i] & bit_mask;

      else {
          roundup = 0;
          switch ( r[i] & bit_mask ) {

                /* If round bit is clear, and ROUND TO NEAREST option */
                /* is selected we truncate */

          case  0 : if (options & CVT_C_ROUND_TO_NEAREST)
                      break;

                /* Otherwise, make note of wheather there are any bits set */
                /* after the round bit, and then check the remaining cases */

          default : if ( ! (more_bits = r[i] & (bit_mask - 1)) )
                      switch ( i ) {
                        case  1 : more_bits = r[2];
                        case  2 : more_bits |= r[3];
                        case  3 : more_bits |= r[4];
                        default : break;
                      }

                /* Re-check ROUND TO NEAREST option.  NOTE: if we've reached  */
                /* this point and ROUND TO NEAREST has been selected, the     */
                /* round bit is set. */

                    if (options & CVT_C_ROUND_TO_NEAREST) {
                        if ( ! ( roundup = more_bits ) )
                            if ( bit_mask << 1 )
                               roundup = r[i] & (bit_mask << 1);
                            else if (i != 1)
                               roundup = r[i-1] & 1;

                /* Check ROUND TO POSITIVE INFINITY option */

                    } else if (options & CVT_C_ROUND_TO_POS) {
                        if ( !(r[U_R_FLAGS] & U_R_NEGATIVE) )
                          roundup = (r[i] & bit_mask) | more_bits;

                /* Check ROUND TO NEGITIVE INFINITY option */

                    } else if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        roundup = (r[i] & bit_mask) | more_bits;
          }
      }


      if ( roundup ) {          /* Perform rounding if necessary */

               /* Add 1 at round position */

         bit_mask <<= 1;
         r[i] = (r[i] & ~(bit_mask - 1)) + bit_mask;

               /* Propagate any carry */

         while ( ! r[i] )
           r[--i] += 1;

               /* If carry reaches exponent MSB gets zeroed and must be reset */

         if ( ! i )
           r[1] = 0x80000000L;
      }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\ndr20\rpcssm.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    rpcssm.cxx

Abstract:

    RpcS* memory package routines are implemented here.
    These corespond to DCE rpc_ss_* and rpc_sm_* routines.

Author:

    Michael Montague (mikemon) 12-Apr-1993

Revision History:

    Ryszardk    Nov 30, 1993    added rpc_sm_* package,
                                rewrote rpc_ss_* package

-------------------------------------------------------------------*/

#include <assert.h>
#include <ndrp.h>           // rpcndr.h and  NDR_ASSERT

void NdrRpcDeleteAllocationContext();
void ForceNdrCleanupSegIntoMemory();
#include "util.hxx"
#include "rpcssm.hxx"


// =======================================================================
//      RpcSs Package
// =======================================================================

// This structure is being initialized with (plain) malloc and free
// by an assignement in NdrClientInitializeNew.
// It is used only by the client side.
// We need a pointer, too, because of a C compiler problem on Dos.

MALLOC_FREE_STRUCT      RpcSsDefaults = { 0, 0 };
MALLOC_FREE_STRUCT   * pRpcSsDefaults = &RpcSsDefaults;


EXTERN_C void NdrpSetRpcSsDefaults(RPC_CLIENT_ALLOC *pfnAlloc,
                      RPC_CLIENT_FREE *pfnFree)
{
    pRpcSsDefaults->pfnAllocate = pfnAlloc;
    pRpcSsDefaults->pfnFree     = pfnFree;
}

// These are default allocator and deallocator used by the client side
// when the memory package hasn't been enabled. They map to C-runtime
// malloc and free.
// When the client side executes in an enabled environment, the client
// doesn't use these two routines; instead, it uses the same default
// allocator that the server does (NdrRpcSsDefaultAllocate/Free).
// Those map into I_RpcAllocate/I_RpcFree, and those in turn map into
// system Rtl* routines.

static void * __RPC_API
DefaultAllocate (
    IN size_t Size
    )
{
    if ( RpcSsDefaults.pfnAllocate == NULL )
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

    return( RpcSsDefaults.pfnAllocate( Size ) ) ;
}

static void __RPC_API
DefaultFree (
    IN void * Ptr
    )
{
    if ( RpcSsDefaults.pfnFree == NULL )
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

    RpcSsDefaults.pfnFree( Ptr );
}

// -----------------------------------------------------------------


PALLOCATION_CONTEXT
GetCreateAllocationContext (
    )
/*++

Return Value:

    The allocation information for this thread is returned.  If there is
    no allocation information context for this thread, one gets allocated.
    If there is insufficient memory, an exception is raised.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.

Notes.

    pBlocDescr == 0  means that the memory package is disabled.

--*/
{
    PALLOCATION_CONTEXT  AllocationContext =  GetAllocContext();;

    if ( AllocationContext == 0 )
        {
        if ( NdrpPerformRpcInitialization() == RPC_S_OK )
            {
            AllocationContext = (PALLOCATION_CONTEXT)
                            I_RpcAllocate( sizeof(ALLOCATION_CONTEXT) );
            }

        if ( AllocationContext == 0 )
            {
            RpcRaiseException(RPC_S_OUT_OF_MEMORY);
            }

        InitializeCriticalSection( &(AllocationContext->CriticalSection) );
        AllocationContext->ClientAlloc = DefaultAllocate;
        AllocationContext->ClientFree  = DefaultFree;
        AllocationContext->EnableCount = 0;

        SYSTEM_INFO   SystemInfo;

        AllocationContext->ThreadCount = 1;
        AllocationContext->pInitialStacks = 0;
        AllocationContext->pEnableStack = 0;
        AllocationContext->pBlockDescr = 0;
        GetSystemInfo( &SystemInfo );
        AllocationContext->PageSize = SystemInfo.dwPageSize;
        AllocationContext->Granularity = SystemInfo.dwAllocationGranularity;

        SetAllocContext( AllocationContext );   // Tls
        }

    return( AllocationContext );
}


// -----------------------------------------------------------------

void *
FindBlockForTheChunk(
    PALLOCATION_CONTEXT AllocationContext,
    size_t       Size )
/*++

Routine Description:

    This routine returns the pointer to the allocated chunk of memory.
    If it cannot allocate a chunk it returns NULL.
    This is used only in Win32 version.

Note:

    This is called within the critical section.

--*/
{
    char *              AllocationBlock;
    DWORD               SizeToAllocate;
    unsigned long       i, BlockSize;
    PALLOC_BLOCK_DESCR  pDescrTemp;
    char *              pChunk;

    // Round the size to a multiple of 8, so that
    // each memory chunk is always on an aligned by 8 boundary.

    Size = ALIGN_TO_8( Size );

    // If the size is 0, allocate 8 bytes anyways to guarantee uniqueness
    // and to prevent aliasing problems.

    if ( Size == 0 )
        Size = 8;

    // See if the chunk can be allocated within an existing block.
    // We use the first fit algorithm to do that.

    BlockSize = AllocationContext->PageSize;

    if ( Size < BlockSize )
        {
        for ( i = 0;  i < AllocationContext->FFIndex; i++ )
            {
            pDescrTemp = & AllocationContext->pBlockDescr[i];
            if ( pDescrTemp->SizeLeft >= Size )
                {
                pChunk = pDescrTemp->FirstFree;
                pDescrTemp->FirstFree += Size;
                pDescrTemp->SizeLeft  -= Size;

                #if defined( DEBUGRPC )
                    pDescrTemp->Counter ++;
                #endif

                return( pChunk );
                }
            }
        // Doesn't fit anywhere: allocate a new block.

        SizeToAllocate = BlockSize;
        }
    else
        {
        // Size is too big to fit in leftovers.
        // Round it up to the block size boundary.

        size_t Alignment = BlockSize - 1;

        SizeToAllocate = (Size + Alignment) & ~Alignment;
        }

    //
    // Being here means a need to allocate a new block of pages.
    //

    if ( AllocationContext->FFIndex >= AllocationContext->DescrSize )
        {
        // need to reallocate the array of descriptors first.

        size_t NewDescrSize = AllocationContext->DescrSize +
                                        DESCR_ARRAY_INCR;
        pDescrTemp = (PALLOC_BLOCK_DESCR)
                     I_RpcAllocate( NewDescrSize * sizeof( ALLOC_BLOCK_DESCR ));
        if ( pDescrTemp == 0 )
            {
            return( NULL );
            }

        RpcpMemoryCopy( pDescrTemp,
                        AllocationContext->pBlockDescr,
                        (size_t)(AllocationContext->FFIndex
                                            * sizeof( ALLOC_BLOCK_DESCR )) );

        if ( AllocationContext->pBlockDescr !=
                AllocationContext->pInitialStacks->DescrStack )
            I_RpcFree( AllocationContext->pBlockDescr );

        AllocationContext->pBlockDescr = pDescrTemp;
        AllocationContext->DescrSize = NewDescrSize;
        }

    // Now allocate the new block.

    AllocationBlock = (char *) VirtualAlloc( NULL,  // new pages
                                             SizeToAllocate,
                                             MEM_COMMIT,
                                             PAGE_READWRITE );
    if ( AllocationBlock == 0 )
        {
        return( NULL );
        }

    NDR_ASSERT( ((ULONG_PTR)AllocationBlock & 0x7) == 0,
                "buffer alignment error at allocation time" );

    pDescrTemp = & AllocationContext->pBlockDescr[ AllocationContext->FFIndex ];
    pDescrTemp->AllocationBlock = AllocationBlock;
    pDescrTemp->FirstFree = AllocationBlock + Size;
    pDescrTemp->SizeLeft  = SizeToAllocate - Size;

    #if defined( DEBUGRPC )
        pDescrTemp->Counter = 1;
    #endif

    AllocationContext->FFIndex++;

    return( AllocationBlock );
}


void * RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    )
/*++

Routine Description:

    Allocate memory within the allocation context fot the thread. A call to
    RpcSsEnableAllocate sets up an allocation context for the calling thread.
    When the application (and/or the stubs) call RpcSsDisableAllocate,
    any memory allocated by RpcSsAllocate in the context which has not been
     freed (by RpcSsFree) will be freed, and the context will be freed.

Arguments:

    Size - Supplies the amount of memory required in bytes.

Return Value:

    A pointer to the allocated block of memory will be returned.

Note:

    This is Win32 version.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
                          will be raised.
    RPC_S_INVALID_ARG   - If no allocation context yet.

--*/
{
    void *                  AllocatedChunk = 0;
    PALLOCATION_CONTEXT     AllocationContext = GetAllocContext();

    if ( AllocationContext == 0 )
        {
        RpcRaiseException( RPC_S_INVALID_ARG );
        }

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    if ( AllocationContext->EnableCount )
        AllocatedChunk = FindBlockForTheChunk( AllocationContext, Size );

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    if ( AllocatedChunk == NULL )
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        }

    return( AllocatedChunk );
}


static void
NdrpReleaseMemory(
    PALLOCATION_CONTEXT  AllocationContext
    )
/*++

Routine Description:

    Releases all the memory related to the package except for the
    control block itself.

Note:

    This is Win32 version and is called from the critical section
    in disable allocate and set thread.
--*/
{
    unsigned long i;

    for ( i = 0;  i < AllocationContext->FFIndex; i++ )
        {
        VirtualFree( AllocationContext->pBlockDescr[i].AllocationBlock,
                     0,  // free all of it
                     MEM_RELEASE );
        }
    I_RpcFree( AllocationContext->pInitialStacks );
    if ( AllocationContext->pEnableStack !=
            AllocationContext->pInitialStacks->EnableStack )
        I_RpcFree( AllocationContext->pEnableStack );
    if ( AllocationContext->pBlockDescr !=
            AllocationContext->pInitialStacks->DescrStack )
        I_RpcFree( AllocationContext->pBlockDescr );

    AllocationContext->pInitialStacks = 0;
    AllocationContext->pEnableStack = 0;
    AllocationContext->StackMax = 0;
    AllocationContext->StackTop = 0;
    AllocationContext->pBlockDescr = 0;
    AllocationContext->DescrSize = 0;
    AllocationContext->FFIndex = 0;
    AllocationContext->ClientAlloc = DefaultAllocate;
    AllocationContext->ClientFree  = DefaultFree;

    NDR_ASSERT( AllocationContext->ThreadCount, "when relesing all memory" );
    AllocationContext->ThreadCount--;
}

static void
NdrpDisableAllocate(
    BOOL    fCalledFromStub
    )
/*++

Routine Description:

    Multiple enable/disable are allowed and the EnableCount is used to keep
    track of it.
    We disable only when counter comes back to 0.
    We ignore too many disables.

    This routine will free memory associated with the allocation context
    for this thread as well as the allocation context.

    However, the routine frees only blocks allocated with the default
    allocator. Other blocks are considered to be allocated
    with a swapped/set user allocator and so we leave them alone.
    Allocation context gets freed when process detaches.

Note:

    This is Win32 version.
--*/
{
    PALLOCATION_CONTEXT  AllocationContext = GetAllocContext();
    unsigned long        NewLevel;
    BOOL                 fTooManyDisables = FALSE;
    BOOL                 fLastThreadGoingAway = FALSE;

    if ( AllocationContext == 0 )
        return;

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    if ( fCalledFromStub )
        {
        NDR_ASSERT( AllocationContext->StackTop, "mismatch in stub calls" );
        NewLevel = AllocationContext
                            ->pEnableStack[ -- AllocationContext->StackTop ];
        }
    else
        NewLevel = AllocationContext->EnableCount - 1;

    // We are forcing the EnableCount to get the value from the EnableStack,
    // when possible.

    if ( AllocationContext->EnableCount )
        AllocationContext->EnableCount = NewLevel;
    else
        {
        // doesn't fall below zero.

        fTooManyDisables = TRUE;
        }

    if ( AllocationContext->EnableCount == 0 )
        {
        // First free everything except the control block.

        if ( !fTooManyDisables )
            NdrpReleaseMemory( AllocationContext );

        // Now see if we need to free the context itself.

        // Because of the thread reusage in the runtime, and consequently,
        // some threads hanging around forever, we need to dispose
        // of this, even though it costs a new allocation later.

        if ( AllocationContext->ThreadCount == 0 )
            {
            fLastThreadGoingAway = TRUE;
            SetAllocContext( NULL );
            }
        }

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    if ( fLastThreadGoingAway)
        {
        DeleteCriticalSection( &(AllocationContext->CriticalSection) );
        I_RpcFree( AllocationContext );
        }

}



void RPC_ENTRY
RpcSsDisableAllocate (
    void
    )
/*++

Routine Description:

    See the description of NdrpDisableAllocate.

Note:

    This is Win32 version.
--*/
{
    NdrpDisableAllocate( FALSE );
}


static void
NdrpEnableAllocate (
    BOOL    fCalledFromStub
    )
/*++

Routine Description:

    This routine will set up an allocation context for this thread.

Note:

    The behavior is such that it is valid to call EnableAllocate
    several times in a row without calling DisableAllocate.
    The number to calls to Disable has to much that of Enable.

    This is Win32 version.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.
--*/
{
    PALLOCATION_CONTEXT  AllocationContext =  GetCreateAllocationContext();
    int  Successful = 1;

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    if ( AllocationContext->EnableCount == 0 )
        {
        AllocationContext->pInitialStacks = (INIT_STACKS_BLOCK *)
            I_RpcAllocate( sizeof( INIT_STACKS_BLOCK ) );

        if ( AllocationContext->pInitialStacks )
            {
            AllocationContext->pEnableStack =
                AllocationContext->pInitialStacks->EnableStack;
            AllocationContext->StackMax = ENABLE_STACK_SIZE;
            AllocationContext->StackTop = 0;

            AllocationContext->pBlockDescr =
                AllocationContext->pInitialStacks->DescrStack;
            AllocationContext->DescrSize = DESCR_ARRAY_SIZE;
            AllocationContext->FFIndex = 0;

            AllocationContext->ClientAlloc = RpcSsAllocate;
            AllocationContext->ClientFree  = RpcSsFree;
            }
        else
            Successful = 0;
        }

    if ( Successful )
        {
        if ( fCalledFromStub )
            {
            // Push the current enable level on the EnableStack to have
            // a point to come back when disabling from the server stub.

            if ( AllocationContext->StackTop >= AllocationContext->StackMax )
                {
                // Need to reallocate the EnableStack first.

                ulong   NewMax;
                ulong * pStackTemp;

                NewMax = AllocationContext->StackMax + ENABLE_STACK_SIZE;
                pStackTemp = (ulong *) I_RpcAllocate( NewMax * sizeof(ulong) );

                if ( pStackTemp )
                    {
                    RpcpMemoryCopy( pStackTemp,
                                    AllocationContext->pEnableStack,
                                    AllocationContext->StackMax * sizeof(ulong) );
                    if ( AllocationContext->pEnableStack !=
                             AllocationContext->pInitialStacks->EnableStack )
                         I_RpcFree( AllocationContext->pEnableStack );

                    AllocationContext->pEnableStack = pStackTemp;
                    AllocationContext->StackMax = NewMax;
                    }
                else
                    Successful = 0;
                }

            if ( Successful )
                AllocationContext->pEnableStack[ AllocationContext->StackTop++ ]
                     = AllocationContext->EnableCount;
            else
                if ( AllocationContext->EnableCount == 0 )
                    {
                    // just allocated the stuff ..
                    I_RpcFree( AllocationContext->pInitialStacks );
                    AllocationContext->pInitialStacks = 0;
                    AllocationContext->pEnableStack = 0;
                    AllocationContext->pBlockDescr = 0;
                    }
            }

        // Increment the counter to a new level.

        if ( Successful )
            {
            AllocationContext->EnableCount++;
            }
        }

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    if ( ! Successful )
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        }
}


void RPC_ENTRY
RpcSsEnableAllocate (
    void
    )
/*++

Routine Description:

    This routine will set up an allocation context for this thread.

Note:

    The behavior is such that it is valid to call EnableAllocate
    several times in a row without calling DisableAllocate.
    The number to calls to Disable should much that of Enable.

    This is Win32 version.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.
--*/
{
    NdrpEnableAllocate( FALSE );
}


void RPC_ENTRY
RpcSsFree (
    IN void * NodeToFree
    )
/*++

Routine Description:

    When a block of memory allocated by RpcSsAllocate is no longer needed,
    it can be freed using RpcSsFree.
    Actually, for win32 we do nothing
        -  all blocks will be freed at the Disable time as we want speed.

Arguments:

    NodeToFree - Supplies the block of memory, allocated by RpcSsAllocate, to
        be freed.

Note:

    This is Win32 version.
--*/
{
    PALLOCATION_CONTEXT     AllocationContext = GetAllocContext();

    if ( AllocationContext == 0 )
        {
        #if defined( DEBUGRPC )
            RpcRaiseException( RPC_S_INVALID_ARG );
        #else
            return;
        #endif
        }
}


// -----------------------------------------------------------------


RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSsGetThreadHandle (
    void
    )
/*++

Return Value:

    A handle to the allocation context for this thread will be returned.
    This makes it possible for two threads to share an allocation context.
    See RpcSsSetThreadHandle as well.

    != NULL     - only when the environement is actually enabled.

--*/
{
    PALLOCATION_CONTEXT  AllocationContext = GetAllocContext();
    RPC_SS_THREAD_HANDLE Handle = 0;

    if ( AllocationContext == 0 )
        return( 0 );

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    // Check if the memory environement is enabled.

    if ( AllocationContext->EnableCount > 0 )
         Handle = AllocationContext;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    return( Handle );
}


void RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC * ClientAlloc,
    IN RPC_CLIENT_FREE  * ClientFree
    )
/*++

Routine Description:

    The routines to be used by the client to allocate and free memory can
    be set using this routine.  See also RpcSsSwapClientAllocFree.

Arguments:

    ClientAlloc - Supplies the routine to use to allocate memory.
    ClientFree  - Supplies the routine to use to free memory.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.

Note. Back door to enable.

    DCE (DEC's intrepretation of DCE) has this weird requirement that
    the user can set (or swap in) his private allocator pair without first
    enabling the package. This makes it possible for the client side stub
    to use a private allocator (instead of malloc/free (in osf mode)) to
    allocate when unmarshalling.

    However, that doesn't enable the package. So, issuing a regular API like
    RpcSsAllocate still fails.

    The expected behavior is to Enable the package, set or swap private
    allocators and then RpcSsAllocate is a valid call.

    This has some impact on the disable behavior. The implementation allows
    for multiple enables and disables. To prevent leaking/passing on an
    non-empty memory context with a thread when the thread is reused,
    there is a control mechanism (the enable stack) that makes sure that
    disbling from the stubs resets the enable level to the one at the
    enable time.

    Now, when the (server) stub issues enable, the corresponding disable
    will do the right thing, regardless of what the user might have messed up.
    If there weren't eanough disables, it will free everything; if there were
    too many disables, it would quietly do nothing.

    When the user issues an enable, the matching disable will clean up
    everything. If there is insufficient number of disable call on the client,
    there is a leak and we cannot do anything about it. Too many calls are ok.

    Now at last. If the user issues set/swap, an (empty) context is created
    with the disabled state. If the package has never been enabled, this empty
    context won't be deleted by a disable (this would be a disable too many).
    This is harmul both on client and server so I leave it as it is.


--*/
{
    PALLOCATION_CONTEXT  AllocationContext = GetCreateAllocationContext();

    // The only reason we enter the critical section here is to keep
    // the pair consistent.

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    AllocationContext->ClientAlloc = ClientAlloc;
    AllocationContext->ClientFree = ClientFree;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );
}


void RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    )
/*++

Routine Description:

    The allocation context for this thread will set to be the supplied
    allocation context.
    For 32bit environment, the ThreadReCount is updated.

Arguments:

    Id - Supplies the allocation context to use for this thread.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.

--*/
{
    // This is 32bit and 64b code.

    // DCE doesn't really specify any means to support some kind of thread
    // ref counting and so additional semantics has been defined for this
    // API.
    // In order to define some orderly behavior for the apps passing
    // thread handles around, we keep track of how many threads can
    // access an allocation context. For an app to be clean, each thread
    // that issues set call(s) with non-zero argument should signal it's
    // done with a single set call with 0.

    // The ThreadCount has a special flavor here, which is to
    // count the threads that can access the context, not the references
    // in the sense of set calls.
    // The original thread doesn't issue a set but we still have to
    // account for it. So we start the ThreadCount with 1, and then
    // the last disable (the one that frees the memory) decrements the count.
    // Which means that the thread issuing the last disable effectively
    // does a set to zero at the same time.

    // The rules below support decrementing the ThreadCount by means
    // of calling the routine with thread id == 0, or with thread id being
    // different from the current one.
    // If this happens to be the call that would remove the last chance
    // to reference the context, we force to free everything, including
    // the control block.
    // In other words, set 0 on the last thread does the disable.


    PALLOCATION_CONTEXT pOldContext = GetAllocContext();
    PALLOCATION_CONTEXT pNewContext = (PALLOCATION_CONTEXT) Id;

    if ( pOldContext != pNewContext )
        {
        if ( pOldContext )
            {
            BOOL fLastThreadGoingAway = FALSE;

            EnterCriticalSection( &(pOldContext->CriticalSection) );

            if ( pOldContext->ThreadCount == 1 )
                {
                // delete the memory and decrease the ref count

                NdrpReleaseMemory( pOldContext );

                fLastThreadGoingAway = TRUE;
                SetAllocContext( NULL );
                }

            LeaveCriticalSection( &(pOldContext->CriticalSection) );

            if ( fLastThreadGoingAway)
                {
                DeleteCriticalSection( &(pOldContext->CriticalSection) );
                I_RpcFree( pOldContext );
                }
            }

        if ( pNewContext )
            {
            EnterCriticalSection( &(pNewContext->CriticalSection) );
            pNewContext->ThreadCount++;
            LeaveCriticalSection( &(pNewContext->CriticalSection) );
            }
        }

    SetAllocContext( pNewContext );
}


void RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC  *   ClientAlloc,
    IN RPC_CLIENT_FREE   *   ClientFree,
    OUT RPC_CLIENT_ALLOC * * OldClientAlloc,
    OUT RPC_CLIENT_FREE  * * OldClientFree
    )
/*++

Routine Description:

    The routines to be used by the client to allocate and free memory can
    be set using this routine.  The previous values of these routines will
    be returned.  See also RpcSsSetClientAllocFree.

Arguments:

    ClientAlloc    - Supplies the routine to use to allocate memory.
    ClientFree     - Supplies the routine to use to free memory.
    OldClientAlloc - Returns the old value of the client allocator.
    OldClientFree  - Returns the old value of the client deallocator.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.

--*/
{
    PALLOCATION_CONTEXT  AllocationContext = GetCreateAllocationContext();

    // The only reason we enter the critical section here is to keep
    // the pairs consistent.

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    *OldClientAlloc = AllocationContext->ClientAlloc;
    *OldClientFree = AllocationContext->ClientFree;
    AllocationContext->ClientAlloc = ClientAlloc;
    AllocationContext->ClientFree = ClientFree;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );
}


/*++ -----------------------------------------------------------------------
//
//    RpcSm* functions are wrappers over RpcSs*
//
//    What was earlier: a hen or an egg?
//    We wrap RpcSm* over RpcSs* because RpcSs* are a basic staple for stubs
//    and so this makes the critical path shorter.
//    Admittedly, RpcSm*  take then longer than they could.
//
--*/

void * RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS *    pStatus
    )
/*++

Routine Description:

    Same as RpcSsAllocate, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    Size    - Supplies the amount of memory required in bytes.
    pStatus - Returns an error code:
                RPC_S_OK or RPC_S_OUT_OF_MEMORY

Return Value:

    A pointer to the allocated block of memory or NULL will be returned.

Exceptions:

    This routine catches exceptions and returns an error code.
--*/
{
    void * AllocatedNode = 0;
    RpcTryExcept
        {
        AllocatedNode = RpcSsAllocate( Size );
        *pStatus = RPC_S_OK;
        }
    RpcExcept(1)
        {
        *pStatus = RpcExceptionCode();
        }
    RpcEndExcept
    return( AllocatedNode );
}


RPC_STATUS RPC_ENTRY
RpcSmClientFree (
    IN  void * pNodeToFree
    )
/*++

Routine Description:

    Same as RpcSsClientFree, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    pNodeToFree  - a memory chunk to free

Return Value:

    error code - RPC_S_OK or exception code

Exceptions:

    This routine catches exceptions and returns an error code.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        NdrRpcSmClientFree( pNodeToFree );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept

    return( Status );
}


RPC_STATUS RPC_ENTRY
RpcSmDisableAllocate (
    void
    )
/*++

Routine Description:

    Same as RpcSsDisableAllocate, except that this one returns an error code,
    as opposed to raising an exception.

Return Value:

    error code - RPC_S_OK or exception code

Exceptions:

    Exceptions are catched and an error code is returned.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsDisableAllocate();
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_STATUS RPC_ENTRY
RpcSmDestroyClientContext (
    IN  void * * pContextHandle
    )
/*++

Routine Description:

    Frees the memory related to unused context handle.

Arguments:

    ContextHandle  - a context handle to be destroyed

Return Value:

    error code - RPC_S_OK or exception code

Exceptions:

    This routine catches exceptions and returns an error code.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsDestroyClientContext( pContextHandle );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept

    return( Status );
}


RPC_STATUS RPC_ENTRY
RpcSmEnableAllocate (
    void
    )
/*++

Routine Description:

    Same as RpcSsEnableAllocate, except that this one returns an error code,
    as opposed to raising an exception.

Exceptions:

    Exceptions are catched and an error code is returned.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsEnableAllocate();
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_STATUS  RPC_ENTRY
RpcSmFree (
    IN void * NodeToFree
    )
/*++

Routine Description:

    Same as RpcSsFree, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    NodeToFree - Supplies the block of memory, allocated by RpcSmAllocate, to
                 be freed.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept