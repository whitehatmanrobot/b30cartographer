 Status );
    }

    Status = LsapDsSearchMultiple( Flags,
                                   pContainer,
                                   pAttrsToMatch,
                                   Attrs,
                                   &SearchRes );


    if ( NT_SUCCESS( Status ) ) {


        //
        // See if we found the object
        //
        if ( SearchRes->count == 0 ) {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;

        } else if ( SearchRes->count >= 1 ) {

            //
            // See how big a buffer we need to allocate
            //
            OutputLen = sizeof( PDSNAME ) * SearchRes->count;

            EntInfList = &(SearchRes->FirstEntInf);

            for ( i = 0; i < SearchRes->count ; i++) {

                OutputLen += ROUND_UP_COUNT( EntInfList->Entinf.pName->structLen, ALIGN_WORST );
                EntInfList = EntInfList->pNextEntInf;
            }

            //
            // Allocate it
            //
            *pppFoundNames = LsapAllocateLsaHeap( OutputLen );

            //
            // Copy the names
            //
            if ( *pppFoundNames == NULL ) {

                Status = STATUS_NO_MEMORY;

            } else {

                Buff = ((PBYTE)*pppFoundNames) + (sizeof( PDSNAME ) * SearchRes->count);

                EntInfList = &SearchRes->FirstEntInf;

                for (i = 0; i < SearchRes->count ; i++ ) {

                    (*pppFoundNames)[i] = (PDSNAME)Buff;
                    RtlCopyMemory( Buff,
                                   EntInfList->Entinf.pName,
                                   EntInfList->Entinf.pName->structLen );

                    Buff += ROUND_UP_COUNT( EntInfList->Entinf.pName->structLen, ALIGN_WORST );
                    EntInfList = EntInfList->pNextEntInf;
                }

                *pcNames = SearchRes->count;

           }

        }

    }


    //
    // Destruction of the thread state will delete the memory for pVal
    //
    LsapDsDeleteAllocAsNeededEx( LSAP_DB_READ_ONLY_TRANSACTION |
                                     LSAP_DB_DS_OP_TRANSACTION |
                                     LSAP_DB_NO_LOCK,
                                 PolicyObject,
                                 CloseTransaction );

    return( Status );

}




NTSTATUS
LsapDsBuildObjectPathByType(
    IN LSAP_DSOBJ_TYPE ObjType,
    PUNICODE_STRING ObjectComponent,
    PUNICODE_STRING ObjectPath
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME DsContainer = NULL;

    //
    // For the short term, simply build the name ourselves.  Wait for AttrTypeToKey to be
    // exported from ntdsa.dll
    //
    ObjectPath->MaximumLength = sizeof( LSAP_DS_CONTAINER_PREFIX ) +
                                ObjectComponent->Length +
                                sizeof( LSAP_DS_PATH_SEP ) +
                                sizeof( WCHAR );

    switch ( ObjType ) {
    case LsapDsObjDomainXRef:

        DsContainer = LsaDsStateInfo.DsPartitionsContainer;
        break;

    case LsapDsObjTrustedDomain:
    case LsapDsObjGlobalSecret:

        DsContainer = LsaDsStateInfo.DsSystemContainer;
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
        break;

    }

    if ( NT_SUCCESS( Status ) ) {

        ObjectPath->MaximumLength += (USHORT)(sizeof(WCHAR) * LsapDsNameLenFromDsName( DsContainer ));

        ObjectPath->Buffer = LsapAllocateLsaHeap( ObjectPath->MaximumLength );

        if ( ObjectPath->Buffer == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            swprintf( ObjectPath->Buffer, L"%ws%ws%ws%ws",
                      LSAP_DS_CONTAINER_PREFIX,
                      ObjectComponent->Buffer,
                      LSAP_DS_PATH_SEP_AS_STRING,
                      LsapDsNameFromDsName( DsContainer ) );

            ObjectPath->Length = ObjectPath->MaximumLength - sizeof( WCHAR ) ;
        }
    }

    return(Status);

}


NTSTATUS
LsapDsFixupTrustForXrefChange(
   IN PDSNAME ObjectPath,
   IN BOOLEAN TransactionActive
   );


NTSTATUS
LsapDsMorphTrustsToUplevel(
    VOID
    )
/*++

  Routine Description

  This function will first enumerate all the cross ref's in the partitions container and for
  each Xref will try patching up the corresponding TDO


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ClassId = CLASS_CROSS_REF;
    SEARCHRES       *pSearchRes;
    ENTINFLIST      *CurrentEntInf = NULL;
    BOOLEAN         CloseTransaction = FALSE;
    BOOLEAN         ActiveThreadState = FALSE;

    ATTRVAL XRefAttVals[] = {
        { sizeof(ULONG), (PUCHAR)&ClassId} };

    ATTR XRefAttrs[] = {
        { ATT_OBJECT_CLASS, {1, &XRefAttVals[0] } },
        };

    ULONG           CountOfDomains=0;
    PDSNAME         *ListOfDomains = NULL;
    ULONG           i;

    //
    // Acquire the Trusted domain lock
    //

    LsapDbAcquireLockEx( TrustedDomainObject,
                         0);

    //
    // Begin a Transaction
    //

    Status = LsapDsInitAllocAsNeededEx(
                    LSAP_DB_NO_LOCK,
                    TrustedDomainObject,
                    &CloseTransaction
                    );

    if (!NT_SUCCESS(Status))
        goto Error;

    ActiveThreadState = TRUE;

    Status = LsapDsSearchMultiple(
                0,
                LsaDsStateInfo.DsPartitionsContainer,
                XRefAttrs,
                1,
                &pSearchRes
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // Bail, most likely resource failure
        //

        goto Error;
    }



    ASSERT(NULL!=pSearchRes);

    //
    // At least 1 Xref should be present otherwise there is something odd
    // going on in here
    //

    ASSERT((pSearchRes->count>=1) && "No Xrefs In Partitions Container !!!");

    CountOfDomains = pSearchRes->count;

    ListOfDomains = LsapAllocateLsaHeap(CountOfDomains * sizeof(PDSNAME));
    if (NULL==ListOfDomains)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    RtlZeroMemory(ListOfDomains,CountOfDomains * sizeof(PDSNAME));

    //
    // Walk through the linked list of entries returned by the DS
    // and perform and copy the dsnames for each of the domains that were returned. Copying is
    // required as once the DS thread state is deleted all the memory allocated by it is lost
    //


    for (CurrentEntInf = &(pSearchRes->FirstEntInf),i=0;
        CurrentEntInf!=NULL;
            CurrentEntInf=CurrentEntInf->pNextEntInf,i++)
    {

           ListOfDomains[i] =  LsapAllocateLsaHeap(CurrentEntInf->Entinf.pName->structLen);
           if (NULL==ListOfDomains[i])
           {
               Status = STATUS_INSUFFICIENT_RESOURCES;
               goto Error;
           }


           RtlCopyMemory(
                ListOfDomains[i],
                CurrentEntInf->Entinf.pName,
                CurrentEntInf->Entinf.pName->structLen
                );

    }

    //
    // Close the transaction now so that we may free up resources
    // Closing the transaction and thread state now and opening up a new
    // transaction/thread state per object keeps the memory consumption much
    // lower and also curtails the transaction length. Remember the DS does
    // not free any memory till the thread state is destroyed. If we have to
    // scale to 2000 trust objects, doing it this way provides for better
    // performance
    //

    LsapDsDeleteAllocAsNeededEx2(
        LSAP_DB_NO_LOCK,
        TrustedDomainObject,
        CloseTransaction,
        FALSE // Rollback Transaction
        );


    ASSERT(!SampExistsDsTransaction());
    ASSERT(THVerifyCount(0));

    ActiveThreadState = FALSE;

    //
    // For each DS NAME in the list check cross ref and update
    // TDO if necessary
    //

    for (i=0;i<CountOfDomains;i++)
    {

           Status = LsapDsFixupTrustForXrefChange(
                        ListOfDomains[i],
                        FALSE
                        );

            if (!NT_SUCCESS(Status))
            {
                //
                // Continue on all errors excepting resource errors
                // The caller logs any errors to the event log
                //

                if (!LsapDsIsNtStatusResourceError(Status))
                {


                    Status = STATUS_SUCCESS;
                }
                else
                {
                    //
                    // Break out of the loop and terminate the upgrade
                    //

                    goto Error;
                }
            }


    }



Error:

    //
    // Free up resources
    //

    if (ListOfDomains)
    {
        for (i=0;i<CountOfDomains;i++)
        {
            if (ListOfDomains[i])
            {
                LsapFreeLsaHeap(ListOfDomains[i]);
            }
        }

        LsapFreeLsaHeap(ListOfDomains);
    }

    if (ActiveThreadState)
    {
         BOOLEAN RollbackTransaction = (NT_SUCCESS(Status))?FALSE:TRUE;

        LsapDsDeleteAllocAsNeededEx2(
            LSAP_DB_NO_LOCK,
            TrustedDomainObject,
            CloseTransaction,
            RollbackTransaction // Rollback Transaction
            );
    }

    ASSERT(!SampExistsDsTransaction());
    ASSERT(THVerifyCount(0));

    LsapDbReleaseLockEx( TrustedDomainObject,
                         0);

    return Status;
}



NTSTATUS
LsaIUpgradeRegistryToDs(
    BOOLEAN DeleteOnly
    )
/*++

Routine Description:

    This function will upgrade the policy/trusted domain/secret objects in the registry
    and move them to the Ds.

Arguments:

    VOID

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ReplicatorState = LsapDbState.ReplicatorNotificationEnabled;

    //
    // Lock the database
    //

    LsapDbAcquireLockEx( AllObject,
                         0 );

    //
    // Set the upgrade flag
    //

    LsaDsStateInfo.Nt4UpgradeInProgress = TRUE;

    //
    // Ok, move the accounts...
    //

    LsapDbDisableReplicatorNotification();

    //
    // Upgrade TDO's in registry to DS.
    //

    Status = LsapDsDomainUpgradeRegistryToDs( DeleteOnly );

    if ( !NT_SUCCESS( Status ) ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "Trusted Domain upgrade failed: 0x%lx\n", Status ));
    }

    //
    // Upgrade secrets in registry to DS
    //

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapDsSecretUpgradeRegistryToDs( DeleteOnly );

        if ( !NT_SUCCESS( Status ) ) {

            LsapDsDebugOut(( DEB_ERROR,
                             "Secret upgrade failed: 0x%lx\n", Status ));
        }
    }

    //
    // Upgrade interdomain trust accounts in SAM to DS.
    //

    if ( !DeleteOnly ) {

        if (NT_SUCCESS(Status)) {

            Status = LsapDsDomainUpgradeInterdomainTrustAccountsToDs( );

            if ( !NT_SUCCESS( Status ) ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "InterdomainTrustAccount upgrade failed with  0x%lx\n",
                                 Status ));
            }
        }


        if (NT_SUCCESS(Status))
        {
            Status = LsapDsMorphTrustsToUplevel();

            if (!NT_SUCCESS(Status)) {
                LsapDsDebugOut(( DEB_ERROR,
                                 "Morphing Trusts to NT5 failed  0x%lx\n", Status ));
            }
        }
    }

    if ( ReplicatorState ) {

        LsapDbEnableReplicatorNotification();
    }

    LsapDbReleaseLockEx( AllObject,
                         0 );
    LsaDsStateInfo.Nt4UpgradeInProgress = FALSE;

    ASSERT(!SampExistsDsTransaction());
    ASSERT(THVerifyCount(0));

    return( Status );
}




NTSTATUS
LsapDsGetDefaultSecurityDescriptorForObjectType(
    IN LSAP_DSOBJ_TYPE ObjType,
    IN ULONG Options,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PULONG SecDescSize
    )
/*++

Routine Description:

    This function will determine what the default security descriptor for an object to be
    created should look like.

    Returned security descriptor is allocated via LsapAllocateLsaHeap

Arguments:

    ObjType -- Type of the object

    Options -- Options to control the behavior

    SecurityDescriptor -- Where the allocated self-relative security descriptor is returned.

    SecDescSize -- Size of the returned security descriptor

Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRBLOCK Read, Results;
    BOOLEAN CloseTransaction, CreatedTransaction = FALSE;
    PDSNAME ParentObject = NULL;
    ULONG SDSize;
    BYTE   Buffer[ 512 ];
    PSECURITY_DESCRIPTOR ParentSD = NULL, DefaultSD = (PSECURITY_DESCRIPTOR)Buffer;
    SECURITY_DESCRIPTOR AbsoluteSD;
    ULONG ClassId;

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                        AllObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }

    //
    // Make sure we're coming in as DSA, so the access check that the DS does won't fail
    //
    LsapDsSetDsaFlags( TRUE );


    Read.attrCount = 1;
    Read.pAttr = &LsapDsAttrs[ LsapDsAttrSecDesc ];

    switch ( ObjType ) {
    case SecretObject:
    case TrustedDomainObject:

        ParentObject = LsaDsStateInfo.DsSystemContainer;
        break;

    default:

        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    //
    // Do the read
    //
    if ( NT_SUCCESS( Status ) ) {


#if 0
        if ( !SampExistsDsTransaction() ) {

            CreatedTransaction = TRUE;
            DirTransactControl( TRANSACT_BEGIN_DONT_END );
        }
#endif

        Status =  LsapDsReadByDsName( ParentObject,
                                      0,
                                      &Read,
                                      &Results);

        //
        // Now, the results
        //
        if ( Status == STATUS_SUCCESS ) {

            if ( Results.attrCount != 1 ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "No security descriptor for object %ws!\n",
                                 LsapDsNameFromDsName( ParentObject ) ));
                Status = STATUS_UNSUCCESSFUL;

            } else {

                ParentSD = (PSECURITY_DESCRIPTOR)Results.pAttr[ 0 ].AttrVal.pAVal->pVal;

                ClassId = LsapClassIdFromObjType( ObjType );
                if ( ClassId == 0xFFFFFFFF ) {

                    Status = STATUS_INVALID_PARAMETER;
                }


                //
                // Get the default from the schema
                //
                if ( NT_SUCCESS( Status ) ) {

                    SDSize = sizeof( Buffer );
                    Status = SampGetClassAttribute( ClassId,
                                                    LsapDsAttributeIds[ LsapDsAttrDefaultSecDesc ],
                                                    &SDSize,
                                                    (PVOID)DefaultSD );

                    if ( Status == STATUS_BUFFER_TOO_SMALL ) {

                        DefaultSD = LsapAllocateLsaHeap( SDSize );

                        if ( DefaultSD == NULL ) {

                            Status = STATUS_INSUFFICIENT_RESOURCES;

                        } else {

                            Status = SampGetClassAttribute(
                                        ClassId,
                                        LsapDsAttributeIds[ LsapDsAttrDefaultSecDesc ],
                                        &SDSize,
                                        (PVOID)&DefaultSD );

                        }
                    }

                }

                if ( NT_SUCCESS( Status ) ) {

                    RtlCreateSecurityDescriptor(
                        &AbsoluteSD,
                        SECURITY_DESCRIPTOR_REVISION );

                    //
                    // Set the new DAcl, if present
                    //
                    if ( RtlpAreControlBitsSet ( ( PISECURITY_DESCRIPTOR )DefaultSD,
                                                 SE_DACL_PRESENT ) ) {
                        RtlSetDaclSecurityDescriptor(
                            &AbsoluteSD,
                            TRUE,
                            RtlpDaclAddrSecurityDescriptor( ( PISECURITY_DESCRIPTOR )DefaultSD ),
                            FALSE );
                    }

                    //
                    // Next, the SAcl
                    //
                    if ( RtlpAreControlBitsSet ( ( PISECURITY_DESCRIPTOR )DefaultSD,
                                                 SE_SACL_PRESENT ) ) {

                        RtlSetSaclSecurityDescriptor(
                            &AbsoluteSD,
                            TRUE,
                            RtlpSaclAddrSecurityDescriptor( ( PISECURITY_DESCRIPTOR )DefaultSD ),
                            FALSE );
                    }

                    RtlSetOwnerSecurityDescriptor(
                        &AbsoluteSD,
                        RtlpOwnerAddrSecurityDescriptor( ( PISECURITY_DESCRIPTOR )ParentSD ),
                        FALSE );

                    RtlSetGroupSecurityDescriptor(
                        &AbsoluteSD,
                        RtlpGroupAddrSecurityDescriptor( ( PISECURITY_DESCRIPTOR )ParentSD ),
                        FALSE );
                }

                //
                // Now, compute the size and copy it...
                //
                if ( NT_SUCCESS( Status ) ) {

                    *SecDescSize = RtlLengthSecurityDescriptor( &AbsoluteSD );

                    *SecurityDescriptor = LsapAllocateLsaHeap( *SecDescSize );

                    if ( *SecurityDescriptor == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        Status = RtlMakeSelfRelativeSD( &AbsoluteSD,
                                                        *SecurityDescriptor,
                                                        SecDescSize );

                        ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

                    }
                }

            }
        }

#if 0
        if ( CreatedTransaction ) {

            DirTransactControl( TRANSACT_DONT_BEGIN_END );
        }
#endif
    }

    if ( Buffer != DefaultSD ) {

        LsapFreeLsaHeap( DefaultSD );
    }

    LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                 AllObject,
                                 CloseTransaction );


    return( Status );
}




NTSTATUS
LsapDsRenameObject(
    IN PDSNAME OldObject,
    IN PDSNAME NewParent,
    IN ULONG AttrType,
    IN PUNICODE_STRING NewObject
    )
/*++

Routine Description:

    This function will change the rdn of an object

Arguments:

    OldObject -- Current object name

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN CloseTransaction;
    MODIFYDNARG ModifyDnArg;
    MODIFYDNRES *ModifyRes = NULL;
    ATTR NewDn;
    ATTRVAL NewDnVal;

    ASSERT( OldObject );
    ASSERT( NewObject );

    Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                        AllObject,
                                        &CloseTransaction );

    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }

    RtlZeroMemory( &ModifyDnArg, sizeof( ModifyDnArg ) );

    NewDnVal.valLen = NewObject->Length;
    NewDnVal.pVal = ( PUCHAR )NewObject->Buffer;

    NewDn.attrTyp = AttrType;
    NewDn.AttrVal.valCount = 1;
    NewDn.AttrVal.pAVal = &NewDnVal;

    ModifyDnArg.pObject = OldObject;
    ModifyDnArg.pNewParent = NewParent;
    ModifyDnArg.pNewRDN = &NewDn;
    LsapDsInitializeStdCommArg( &(ModifyDnArg.CommArg), 0 );


    DirModifyDN( &ModifyDnArg, &ModifyRes );

    if ( ModifyRes ) {

        Status = LsapDsMapDsReturnToStatusEx( &ModifyRes->CommRes );

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    LsapDsContinueTransaction();

    LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                 AllObject,
                                 CloseTransaction );

    return( Status );
}




BOOLEAN
LsaIIsClassIdLsaClass(
    IN ULONG ClassId,
    OUT PULONG LsaClass
    )
/*++

Routine Description:

    This function will determine if the given Ds object class Id correlates to an LsaDs object
    class that we care about


Arguments:

    ClassId -- The Ds class Id

    LsaClass -- Where the corresponding Lsa class information is returned

Return Value:

    TRUE -- Success

    FALSE -- Failure

--*/
{
    BOOLEAN Return = FALSE;
    ULONG i;


    for ( i = 0; i < LsapDsClassLast; i++ ) {

        if ( ClassId == LsapDsClassIds[ i ] ) {

            LsapDsDebugOut(( DEB_DSNOTIFY,
                             "Matched id 0x%lx to index %lu\n",
                             ClassId,
                             i ));
            *LsaClass = ClassId;
            Return = TRUE;
            break;
        }
    }

    return( Return );
}

NTSTATUS NetpApiStatusToNtStatus( NET_API_STATUS );



NTSTATUS
LsapDbDomainRenameHandler(
    OUT BOOLEAN * Renamed
    )
/*++

Routine Description:

    Checks the domain name values stored in the registry against those reported
    by the DS.  DS values are treated as master copies and registry is updated
    accordingly.

Parameters:

    None

Returns:

    STATUS_SUCCESS - success
    STATUS_ error code on failure

--*/
{
    NTSTATUS Status;

    LSAP_DB_ATTRIBUTE AttributesReadReg[4];    // attrs read from registry
    LSAP_DB_ATTRIBUTE AttributesReadDsDom[2];  // attrs read from domain XRef
    LSAP_DB_ATTRIBUTE AttributesReadDsRoot[1]; // attrs read from root XRef
    LSAP_DB_ATTRIBUTE AttributesWriteReg[4];   // attrs written to registry
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCountReadReg = 0;
    ULONG AttributeCountReadDsDom = 0;
    ULONG AttributeCountReadDsRoot = 0;
    ULONG AttributeCountWriteReg = 0;
    ULONG AttributeNumber;

    ULONG DomainLen = 0, RootDomainLen = 0;
    PDSNAME DomainXRef = NULL;
    PDSNAME RootDomainXRef = NULL;

    UNICODE_STRING PrimaryDomainNameReg,
                   AccountDomainNameReg,
                   DnsDomainNameReg,
                   RootDnsDomainNameReg,
                   DnsDomainNameDs,
                   NetbiosDomainNameDs,
                   RootDnsDomainNameDs;

    ULONG iPolDnDDN, iPolDnTrN, iPolPrDmN, iPolAcDmN;
    ULONG iXRefDnsRoot, iXRefNetbiosName, iXRefDnsRoot2;

    WCHAR NameBuffer[DNS_MAX_NAME_LENGTH + 1];
    DWORD NameBufferSize = DNS_MAX_NAME_LENGTH + 1;

    WCHAR ErrorCode[16];
    LPWSTR pErrorCode;
    DWORD Reason = LSA_DOMAIN_RENAME_ERROR1;

    LsarpReturnCheckSetup();

    ASSERT( Renamed );
    *Renamed = FALSE;

    //
    // Read the attributes of interest out of the registry
    //

    ASSERT( AttributeCountReadReg == 0 );
    NextAttribute = AttributesReadReg;

    //
    // Request read of the DNS domain name attribute
    //

    LsapDbInitializeAttributeDs(
        NextAttribute,
        PolDnDDN,
        NULL,
        0,
        FALSE
        );

    iPolDnDDN = AttributeCountReadReg;
    NextAttribute++;
    AttributeCountReadReg++;

    //
    // Request read of the Dns Tree Name attribute
    //

    LsapDbInitializeAttributeDs(
        NextAttribute,
        PolDnTrN,
        NULL,
        0,
        FALSE
        );

    iPolDnTrN = AttributeCountReadReg;
    NextAttribute++;
    AttributeCountReadReg++;

    //
    // Request read of the primary domain name attribute
    //

    LsapDbInitializeAttributeDs(
        NextAttribute,
        PolPrDmN,
        NULL,
        0,
        FALSE
        );

    iPolPrDmN = AttributeCountReadReg;
    NextAttribute++;
    AttributeCountReadReg++;

    //
    // Request read of the account domain name attribute
    //

    LsapDbInitializeAttributeDs(
        NextAttribute,
        PolAcDmN,
        NULL,
        0,
        FALSE
        );

    iPolAcDmN = AttributeCountReadReg;
    NextAttribute++;
    AttributeCountReadReg++;

    Status = LsapDbReadAttributesObject(
                 LsapPolicyHandle,
                 0,
                 AttributesReadReg,
                 AttributeCountReadReg
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    LsapDbCopyUnicodeAttributeNoAlloc(
        &PrimaryDomainNameReg,
        &AttributesReadReg[iPolPrDmN],
        TRUE
        );

    LsapDbCopyUnicodeAttributeNoAlloc(
        &AccountDomainNameReg,
        &AttributesReadReg[iPolAcDmN],
        TRUE
        );

    LsapDbCopyUnicodeAttributeNoAlloc(
        &DnsDomainNameReg,
        &AttributesReadReg[iPolDnDDN],
        TRUE
        );

    LsapDbCopyUnicodeAttributeNoAlloc(
        &RootDnsDomainNameReg,
        &AttributesReadReg[iPolDnTrN],
        TRUE
        );

    //
    // Now read the DS to get the values to compare against
    // Start by reading the names of domain and root domain cross-ref objects
    //

    Status = GetConfigurationName(
                 DSCONFIGNAME_DOMAIN_CR,
                 &DomainLen,
                 NULL
                 );

    ASSERT( Status == STATUS_BUFFER_TOO_SMALL );

    DomainXRef = ( PDSNAME )LsapAllocateLsaHeap( DomainLen );

    if ( DomainXRef == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = GetConfigurationName(
                 DSCONFIGNAME_DOMAIN_CR,
                 &DomainLen,
                 DomainXRef
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    Status = GetConfigurationName(
                 DSCONFIGNAME_ROOT_DOMAIN_CR,
                 &RootDomainLen,
                 NULL
                 );

    ASSERT( Status == STATUS_BUFFER_TOO_SMALL );

    RootDomainXRef = ( PDSNAME )LsapAllocateLsaHeap( RootDomainLen );

    if ( RootDomainXRef == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = GetConfigurationName(
                 DSCONFIGNAME_ROOT_DOMAIN_CR,
                 &RootDomainLen,
                 RootDomainXRef
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    //
    // From the domain cross-ref object,
    // read the "NetbiosName" and "DnsRoot" attributes
    //

    ASSERT( AttributeCountReadDsDom == 0 );
    NextAttribute = AttributesReadDsDom;

    LsapDbInitializeAttributeDs(
        NextAttribute,
        XRefDnsRoot,
        NULL,
        0,
        FALSE
        );

    iXRefDnsRoot = AttributeCountReadDsDom;
    NextAttribute++;
    AttributeCountReadDsDom++;

    LsapDbInitializeAttributeDs(
        NextAttribute,
        XRefNetbiosName,
        NULL,
        0,
        FALSE
        );

    iXRefNetbiosName = AttributeCountReadDsDom;
    NextAttribute++;
    AttributeCountReadDsDom++;

    Status = LsapDsReadAttributesByDsName(
                 DomainXRef,
                 0,
                 AttributesReadDsDom,
                 AttributeCountReadDsDom
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    LsapDbCopyUnicodeAttributeNoAlloc(
        &DnsDomainNameDs,
        &AttributesReadDsDom[iXRefDnsRoot],
        TRUE
        );

    LsapDbCopyUnicodeAttributeNoAlloc(
        &NetbiosDomainNameDs,
        &AttributesReadDsDom[iXRefNetbiosName],
        TRUE
        );

    //
    // From the root domain cross-ref object,
    // read the "DnsRoot" attribute
    //

    ASSERT( AttributeCountReadDsRoot == 0 );
    NextAttribute = AttributesReadDsRoot;

    LsapDbInitializeAttributeDs(
        NextAttribute,
        XRefDnsRoot,
        NULL,
        0,
        FALSE
        );

    iXRefDnsRoot2 = AttributeCountReadDsRoot;
    NextAttribute++;
    AttributeCountReadDsRoot++;

    Status = LsapDsReadAttributesByDsName(
                 RootDomainXRef,
                 0,
                 AttributesReadDsRoot,
                 AttributeCountReadDsRoot
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Error;
    }

    LsapDbCopyUnicodeAttributeNoAlloc(
        &RootDnsDomainNameDs,
        &AttributesReadDsRoot[iXRefDnsRoot2],
        TRUE
        );

    //
    // See if the values in the registry match what's in the DS,
    // and if they don't, update the registry
    //

    ASSERT( AttributeCountWriteReg == 0 );
    NextAttribute = AttributesWriteReg;

    //
    // Match the netbios name in the domain object XRef against
    // the primary domain name in the registry
    //

    if ( !RtlEqualUnicodeString(
             &PrimaryDomainNameReg,
             &NetbiosDomainNameDs,
             TRUE )) {

        Status = LsapDbMakeUnicodeAttributeDs(
                     &NetbiosDomainNameDs,
                     PolPrDmN,
                     NextAttribute
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }

        NextAttribute++;
        AttributeCountWriteReg++;
    }

    //
    // Match the netbios name in the domain object XRef against
    // the account domain name in the registry
    //

    if ( !RtlEqualUnicodeString(
             &AccountDomainNameReg,
             &NetbiosDomainNameDs,
             TRUE )) {

        Status = LsapDbMakeUnicodeAttributeDs(
                     &NetbiosDomainNameDs,
                     PolAcDmN,
                     NextAttribute
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }

        NextAttribute++;
        AttributeCountWriteReg++;
    }

    //
    // Match the DNS name in the domain object XRef against
    // the DNS domain name in the registry
    //

    if ( !RtlEqualUnicodeString(
             &DnsDomainNameReg,
             &DnsDomainNameDs,
             TRUE )) {

        Status = LsapDbMakeUnicodeAttributeDs(
                     &DnsDomainNameDs,
                     PolDnDDN,
                     NextAttribute
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }

        NextAttribute++;
        AttributeCountWriteReg++;
    }

    //
    // Match the DNS name in the root domain object XRef against
    // the root DNS domain name in the registry
    //

    if ( !RtlEqualUnicodeString(
             &RootDnsDomainNameReg,
             &RootDnsDomainNameDs,
             TRUE )) {

        Status = LsapDbMakeUnicodeAttributeDs(
                     &RootDnsDomainNameDs,
                     PolDnTrN,
                     NextAttribute
                     );

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }

        NextAttribute++;
        AttributeCountWriteReg++;
    }

    //
    // See if anything in the registry has got to change
    // and if so, update it
    //

    if ( AttributeCountWriteReg > 0 ) {

        Status = LsapDbReferenceObject(
                     LsapPolicyHandle,
                     0,
                     PolicyObject,
                     PolicyObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_START_TRANSACTION
                     );

        if ( NT_SUCCESS( Status )) {

            Status = LsapDbWriteAttributesObject(
                         LsapPolicyHandle,
                         AttributesWriteReg,
                         AttributeCountWriteReg
                         );

            Status = LsapDbDereferenceObject(
                         &LsapPolicyHandle,
                         PolicyObject,
                         PolicyObject,
                         LSAP_DB_LOCK |
                            LSAP_DB_FINISH_TRANSACTION |
                            LSAP_DB_OMIT_REPLICATOR_NOTIFICATION,
                         SecurityDbChange,
                         Status
                         );

            if ( NT_SUCCESS( Status )) {

                *Renamed = TRUE;
            }
        }

        if ( NT_SUCCESS( Status )) {

            //
            // Currently existing logon sessions must be modified with the new
            // domain name
            //

            Status = LsapDomainRenameHandlerForLogonSessions(
                         &PrimaryDomainNameReg,
                         &DnsDomainNameReg,
                         &NetbiosDomainNameDs,
                         &DnsDomainNameDs
                         );
        }

        if ( !NT_SUCCESS( Status )) {

            goto Error;
        }
    }

    //
    // Bug #380437: Since the DC can have a setting that allows it to keep
    //              its DNS suffix across membership changes, this check
    //              may cause the machine to fail to boot.
    //
    //              Thus the following segment of code has been pulled
    //

#if 0

    //
    // One final check: call GetComputerNameEx() and see if what it returns
    // matches what we believe the DNS domain name to be
    //
    // Note that we do NOT ask for the physical DNS domain name,
    // this is done so that the code does not have to be changed for Blackcomb,
    // which is expected to be able to host multiple domains on clusters
    //

    if ( FALSE == GetComputerNameExW(
                      ComputerNameDnsDomain,
                      NameBuffer,
                      &NameBufferSize )) {

        //
        // Must return an NT status code, so map the error code back
        //

        Status = NetpApiStatusToNtStatus( GetLastError());

        //
        // Guard against return values that are not of type 'error'
        //

        if ( NT_SUCCESS( Status )) {

            Status = STATUS_UNSUCCESSFUL;
        }

        goto Error;
        
    } else {

        WCHAR * Buffer;
        BOOLEAN BufferAllocated = FALSE;

        ASSERT( DnsDomainNameDs.Length <= DNS_MAX_NAME_LENGTH );

        if ( DnsDomainNameDs.MaximumLength > DnsDomainNameDs.Length ) {

            Buffer = DnsDomainNameDs.Buffer;
            
        } else {

            SafeAllocaAllocate( Buffer, DnsDomainNameDs.Length + sizeof( WCHAR ));

            if ( Buffer == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            BufferAllocated = TRUE;

            wcsncpy( Buffer, DnsDomainNameDs.Buffer, DnsDomainNameDs.Length );
        }

        Buffer[DnsDomainNameDs.Length / sizeof( WCHAR )] = L'\0';

        if ( !DnsNameCompare_W( NameBuffer, Buffer )) {

            //
            // Can not proceed.
            // The boot sequence must be aborted, and the computer name
            // in the registry corrected manually from the recovery console
            //

            Status = STATUS_INTERNAL_ERROR;
            Reason = LSA_DOMAIN_RENAME_ERROR2;

            if ( BufferAllocated ) {

                SafeAllocaFree( Buffer );
            }

            goto Error;
        }

        if ( BufferAllocated ) {

            SafeAllocaFree( Buffer );
        }
    }

#endif // #if 0

Cleanup:

    LsapDbFreeAttributes( AttributeCountReadReg, AttributesReadReg );
    LsapDbFreeAttributes( AttributeCountReadDsDom, AttributesReadDsDom );
    LsapDbFreeAttributes( AttributeCountReadDsRoot, AttributesReadDsRoot );
    LsapDbFreeAttributes( AttributeCountWriteReg, AttributesWriteReg );

    LsapFreeLsaHeap( DomainXRef );
    LsapFreeLsaHeap( RootDomainXRef );

    LsarpReturnPrologue();

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ));

    //
    // log an explanatory event
    //

    _ltow( Status, ErrorCode, 16 );
    pErrorCode = &ErrorCode[0];

    SpmpReportEvent(
        TRUE,
        EVENTLOG_ERROR_TYPE,
        Reason,
        0,
        0,
        NULL,
        1,
        pErrorCode
        );

    goto Cleanup;
}



NTSTATUS
LsaISamIndicatedDsStarted(
    IN BOOLEAN PerformDomainRenameCheck
    )
/*++

Routine Description:

    This function is a sort of callback from SampInitialize, which is used to tell Lsa that
    the Ds has started.  It is supplied so that the Lsa can initialize enough of its state
    to allow access to Ds stored Lsa information so that Sam can complete initialization

    This function only gets called if the Ds is running

    This function must NOT call any APIs that invoke any SAM calls, since this function gets
    called from SampInitialize, and it causes problems.

Arguments:

    PerformDomainRenameCheck           perform the domain rename check in this iteration?

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Len, i, j;
    BOOLEAN DbLocked = FALSE, CloseTransaction = FALSE;
    ATTRBLOCK SystemContainerRead, SystemContainerResults;
    ATTRVAL AttrVal;
    ATTR SearchAttr;
    PDSNAME SchemaPath = NULL;
    SYNTAX_DISTNAME_STRING *DistnameString;
    SYNTAX_ADDRESS *SyntaxAddress;
    GUID KnownSystemContainerGuid = {
        0xf3301dab, 0x8876, 0xd111, 0xad, 0xed, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xcd
        };
    BOOLEAN DomainRenamed = FALSE;

    LsaDsStateInfo.WriteLocal  = FALSE;
    LsaDsStateInfo.DsRoot      = NULL;
    LsaDsStateInfo.FunctionTableInitialized = FALSE;
    LsaDsStateInfo.UseDs = TRUE;
    LsaDsStateInfo.Nt4UpgradeInProgress = FALSE;
    LsapDsIsRunning = TRUE;


    //
    // Initialize the function table
    //

    LsaDsStateInfo.DsFuncTable.pOpenTransaction  = LsapDsOpenTransaction;
    LsaDsStateInfo.DsFuncTable.pApplyTransaction = LsapDsApplyTransaction;
    LsaDsStateInfo.DsFuncTable.pAbortTransaction = LsapDsAbortTransaction;


    LsaDsStateInfo.FunctionTableInitialized = TRUE;

    //
    // Determine our write state.  At init time, the write is only allowed if
    // we are a DC.  The client write state will be set after we examine the
    // machine object.
    //
    if ( LsapProductType == NtProductLanManNt ) {

        LsaDsStateInfo.WriteLocal = TRUE;
    }

    //
    // Now, build the DS name for the root of the domain.  We do this using the
    // Lsa memory allocations and deallocations, since this structure will outlive
    // any thread state
    //
    Len = 0;
    Status = GetConfigurationName( DSCONFIGNAME_DOMAIN, &Len, NULL );

    ASSERT( Status == STATUS_BUFFER_TOO_SMALL );

    LsaDsStateInfo.DsRoot = LsapAllocateLsaHeap( Len );

    if ( LsaDsStateInfo.DsRoot == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        Status = GetConfigurationName( DSCONFIGNAME_DOMAIN, &Len, LsaDsStateInfo.DsRoot );

        //
        // Get the handle to the domain
        //
        if ( NT_SUCCESS( Status ) ) {

            Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                                PolicyObject,
                                                &CloseTransaction );

            if ( NT_SUCCESS( Status ) ) {

                LsaDsStateInfo.DsDomainHandle = DirGetDomainHandle( LsaDsStateInfo.DsRoot );
                LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                             PolicyObject,
                                             CloseTransaction );
            }

        } else {

            LsapDsDebugOut(( DEB_ERROR,
                             "GetConfigurationName for DOMAIN returned 0x%lx\n", Status ));
        }

    }

    //
    // Now, the Configuration container
    //
    if ( NT_SUCCESS( Status ) ) {

        Len = 0;
        Status = GetConfigurationName( DSCONFIGNAME_CONFIGURATION, &Len, NULL );

        ASSERT( Status == STATUS_BUFFER_TOO_SMALL );

        LsaDsStateInfo.DsConfigurationContainer = LsapAllocateLsaHeap( Len );

        if ( LsaDsStateInfo.DsConfigurationContainer == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            Status = GetConfigurationName( DSCONFIGNAME_CONFIGURATION, &Len,
                                           LsaDsStateInfo.DsConfigurationContainer );
        }

    }

    //
    // Now, the Partitions container
    //
    if ( NT_SUCCESS( Status ) ) {

        Len = 0;
        Status = GetConfigurationName( DSCONFIGNAME_PARTITIONS, &Len, NULL );

        ASSERT( Status == STATUS_BUFFER_TOO_SMALL );

        LsaDsStateInfo.DsPartitionsContainer = LsapAllocateLsaHeap( Len );

        if ( LsaDsStateInfo.DsPartitionsContainer == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            Status = GetConfigurationName( DSCONFIGNAME_PARTITIONS, &Len,
                                           LsaDsStateInfo.DsPartitionsContainer );
        }

    }

    //
    // Build the path to the system container.  We read the wellKnownObjects from the root
    // container and use that to determine which one of these objects is the system
    //
    if ( NT_SUCCESS( Status ) ) {

        //
        // Make sure we have an open transaction
        //
        Status = LsapDsInitAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                            PolicyObject,
                                            &CloseTransaction );

        if ( NT_SUCCESS( Status ) ) {

            SystemContainerRead.attrCount = LsapDsDnsRootWellKnownObjectCount;
            SystemContainerRead.pAttr = LsapDsDnsRootWellKnownObject;
            Status = LsapDsReadByDsName( LsaDsStateInfo.DsRoot,
                                         LSAPDS_READ_NO_LOCK,
                                         &SystemContainerRead,
                                         &SystemContainerResults );
            if ( NT_SUCCESS( Status ) ) {

                //
                // Process all returned information until we find the one that corresponds to
                // the system container
                //
                Status = STATUS_NOT_FOUND;
                for ( i = 0; i < SystemContainerResults.attrCount; i++ ) {

                    for ( j = 0; j < SystemContainerResults.pAttr->AttrVal.valCount; j++ ) {

                        DistnameString = ( SYNTAX_DISTNAME_STRING * )
                                            SystemContainerResults.pAttr->AttrVal.pAVal[ j ].pVal;
                        SyntaxAddress = DATAPTR( DistnameString );

                        if ( RtlCompareMemory( &KnownSystemContainerGuid,
                                               SyntaxAddress->byteVal,
                                               sizeof( GUID ) ) == sizeof( GUID ) ) {

                            Status = LsapDsCopyDsNameLsa( &LsaDsStateInfo.DsSystemContainer,
                                                          NAMEPTR( DistnameString ) );
                            break;
                        }

                    }
                }
            }

            LsapDsDeleteAllocAsNeededEx( LSAP_DB_NO_LOCK,
                                         PolicyObject,
                                         CloseTransaction );
        }

    }

    //
    // Now, build the DS name for the schema container
    //
    Len = 0;
    Status = GetConfigurationName( DSCONFIGNAME_DMD, &Len, NULL );

    ASSERT( Status == STATUS_BUFFER_TOO_SMALL );

    SchemaPath = LsapAllocateLsaHeap( Len );

    if ( SchemaPath == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        Status = GetConfigurationName( DSCONFIGNAME_DMD, &Len, SchemaPath );

        //
        // Query for the info we need to be able to look up items in the system container
        //
        if ( NT_SUCCESS( Status ) ) {

            AttrVal.valLen = sizeof( LSAP_DS_TRUSTED_DOMAIN ) - sizeof( WCHAR );
            AttrVal.pVal = ( PUCHAR )LSAP_DS_TRUSTED_DOMAIN;
            Status = LsapDsFindUnique( 0,
                                       SchemaPath,
                                       AllObject,
                                       &AttrVal,
                                       ATT_LDAP_DISPLAY_NAME,
                                       &LsaDsStateInfo.SystemContainerItems.TrustedDomainObject );

            //
            // If we didn't find it via the DirFind, it could be because the indicies haven't
            // been created yet.  So, we're forced to try it again with an old fashioned search.
            //
            if ( Status == STATUS_NOT_FOUND ) {

                SearchAttr.attrTyp = ATT_LDAP_DISPLAY_NAME;
                SearchAttr.AttrVal.valCount = 1;
                SearchAttr.AttrVal.pAVal = &AttrVal;

                Status = LsapDsSearchUnique(
                             0,
                             SchemaPath,
                             &SearchAttr,
                             1,
                             &LsaDsStateInfo.SystemContainerItems.TrustedDomainObject );
            }

        }

        if ( NT_SUCCESS( Status ) ) {

            AttrVal.valLen = sizeof( LSAP_DS_SECRET ) - sizeof( WCHAR );
            AttrVal.pVal = ( PUCHAR )LSAP_DS_SECRET;
            Status = LsapDsFindUnique( 0,
                                       SchemaPath,
                                       AllObject,
                                       &AttrVal,
                                       ATT_LDAP_DISPLAY_NAME,
                                       &LsaDsStateInfo.SystemContainerItems.SecretObject );

            //
            // If we didn't find it via the DirFind, it could be because the indicies haven't
            // been created yet.  So, we're forced to try it again with an old fashioned search.
            //
            if ( Status == STATUS_NOT_FOUND ) {

                SearchAttr.attrTyp = ATT_LDAP_DISPLAY_NAME;
                SearchAttr.AttrVal.valCount = 1;
                SearchAttr.AttrVal.pAVal = &AttrVal;

                Status = LsapDsSearchUnique(
                             0,
                             SchemaPath,
                             &SearchAttr,
                             1,
                             &LsaDsStateInfo.SystemContainerItems.SecretObject );
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            LsaDsStateInfo.SystemContainerItems.NamesInitialized = TRUE;
        }

        if ( SchemaPath ) {

            LsapFreeLsaHeap( SchemaPath );
        }
    }

    if ( NT_SUCCESS( Status )) {

        LsaDsStateInfo.DsInitializedAndRunning = TRUE;

        //
        // Domain rename support -- synchronize domain name in the DS with what's
        // in the registry
        //

        if ( PerformDomainRenameCheck ) {

            Status = LsapDbDomainRenameHandler( &DomainRenamed );
        }
    }

    if ( NT_SUCCESS (Status ) ) {

        LsapDbAcquireLockEx( AllObject,
                             0 );

        //
        // Rebuild all the caches after setting up the ds and the registry
        //
        Status = LsapDbBuildObjectCaches();

        LsapDbReleaseLockEx( AllObject,
                             0 );
    }

    if ( NT_SUCCESS( Status ) &&
         LsapProductType == NtProductLanManNt &&
         SamIIsRebootAfterPromotion()) {

        //
        // Bug 222800: if this a reboot after promotion, notify the parent
        //             of the trust relationship so netlogon.chg gets updated
        //

        Status = LsapNotifyNetlogonOfTrustWithParent();
    }

    if ( !NT_SUCCESS( Status ) ) {

        LsapDsIsRunning = FALSE;
        LsaDsStateInfo.UseDs = TRUE;
        LsaDsStateInfo.DsInitializedAndRunning = FALSE;

    } else if ( DomainRenamed ) {

        //
        // If everything was successful and the domain has been renamed,
        // then notify Kerberos of domain rename so they can refresh their data
        //

        HINSTANCE hLib = LoadLibraryW( L"Kerberos.dll" );

        if ( hLib ) {

            typedef VOID (*KdccT)(POLICY_NOTIFICATION_INFORMATION_CLASS p);
            KdccT Kdcc = ( KdccT )GetProcAddress( hLib, "KerbDomainChangeCallback" );

            if ( Kdcc ) {

                (*Kdcc)( PolicyNotifyDnsDomainInformation );
            }

            FreeLibrary( hLib );
        }
    }

    return( Status ) ;
}



BOOLEAN
LsapDsIsValidSid(
    IN PSID Sid,
    IN BOOLEAN DsSid
    )
/*++

Routine Description:

    This function determines whether the SID is valid for the Ds or registry based LSA


Arguments:

    Sid - Sid to validate

    DsSid - If TRUE, this is a SID for a DS function

Return Value:

    TRUE - Valid SID

    FALSE - Invalid SID

--*/
{
    BOOLEAN ValidSid;

    ValidSid = RtlValidSid( Sid );

    if ( ValidSid && DsSid ) {

        if ( RtlLengthSid( Sid ) > sizeof( NT4SID ) ) {

            ValidSid = FALSE;
        }
    }

    return( ValidSid );
}

NTSTATUS
LsapRetrieveDnsDomainNameFromHive(
    IN HKEY Hive,
    IN OUT DWORD * Length,
    OUT WCHAR * Buffer
    )
{
    DWORD Status;
    DWORD Win32Err;
    HKEY Hkey;
    DWORD Type;
    DWORD Size = DNS_MAX_NAME_LENGTH * sizeof( WCHAR ) + 8;
    BYTE Value[DNS_MAX_NAME_LENGTH * sizeof( WCHAR ) + 8];

    ASSERT( Hive );
    ASSERT( Length );
    ASSERT( *Length );
    ASSERT( Buffer );

    Win32Err = RegOpenKeyW(
                 Hive,
                 L"Policy\\PolDnDDN",
                 &Hkey
                 );

    if ( Win32Err != ERROR_SUCCESS) {

        return STATUS_NOT_FOUND;
    }

    Win32Err = RegQueryValueExW(
                 Hkey,
                 NULL,
                 NULL,
                 &Type,
                 Value,
                 &Size
                 );

    RegCloseKey( Hkey );

    if ( Win32Err != ERROR_SUCCESS) {

        return STATUS_NOT_FOUND;
    }

    if ( Type != REG_BINARY && Type != REG_NONE ) {

        return STATUS_DATA_ERROR; // should never happen, sanity check only
    }

    if ( Size <= 8 ) {

        return STATUS_DATA_ERROR; // should never happen, sanity check only
    }

    if ( Size - 8 > *Length ) {

        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory( Buffer, Value + 8, Size - 8 );
    *Length = Size - 8;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\exts\newext.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        N E W E X T . C
//
// Contents:    LSA debugger extensions that use the new style 
//              extension API.
//
//
// History:     
//   07-January-2000  kumarp        created
//
// Note:
// 
// If you want to add extensions to this file, read the following
// guidelines from andreva first:
//
// Everyone who debugs or runs stress will expect debugger extensions 
// to work on both 32 bit and 64 bit TARGETS.  The Debugger extensions must 
// therefore be TARGET independent.  We the only viable solution to this is to 
// get structure definitions from the symbol information, instead of 
// from the header file.  So the way we solve this problem is:
//
// - A debugger extension can only include windows.h and wdbgexts.h
// - A debugger extensions NEVER includes header files from 
//   the component it tries to analyze\debug.
// - Debugger extensions use the new routines we provide to query 
//   type information.
//
//------------------------------------------------------------------------

#include <windows.h>
#include <dbghelp.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <ntverp.h>

// ----------------------------------------------------------------------
//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
EXT_API_VERSION         ApiVersion =
{
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER64,
    0
};
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

// ----------------------------------------------------------------------
//
// The following 3 functions must be present in the extension dll.
// They were lifted straight from base\tools\kdexts\kdexts.c
//
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis, // 64Bit Change
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
// ----------------------------------------------------------------------


BOOL
GetGlobalVar (
    IN  PUCHAR   Name, 
    IN  USHORT   Size,
    OUT PVOID    pOutValue
   ) 
/*++

Routine Description:

    Get value of global vars of primitive type OR
    Get the address instead for non-primitive global vars.

    Primitive type is defined as the one not-involving any struct/union
    in its type definition. Pointer to struct/unions are ok.
    for example: USHORT, ULONG, PVOID etc.

Arguments:

    Name      - global var name
                (for example: "lsasrv!LsapAdtContextList")

    Size      - size in bytes for primitive types, 0 otherwise

    pOutValue - pointer to return val.

Return Value:

    TRUE on success, FALSE otherwise

Notes:

--*/
{
    ULONG64 Temp=0;

    SYM_DUMP_PARAM Sym =
    {
        sizeof (SYM_DUMP_PARAM),
        Name,
        DBG_DUMP_NO_PRINT | DBG_DUMP_COPY_TYPE_DATA,
        0, 
        NULL,
        &Temp,
        NULL,
        0,
        NULL
    };

    ULONG RetVal;

    RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

    //
    // store only the correct number of bytes from the value read
    //
    switch(Size)
    {
        default:
        case 0:
            *((PUCHAR*) pOutValue)  = (PUCHAR) Sym.addr;
            break;

        case 1:
            *((UCHAR*) pOutValue)   = (UCHAR) Temp;
            break;
            
        case 2:
            *((USHORT*) pOutValue)  = (USHORT) Temp;
            break;
            
        case 4:
            *((DWORD*) pOutValue)   = (DWORD) Temp;
            break;
            
        case 8:
            *((ULONG64*) pOutValue) = Temp;
            break;
    }
   
   return (RetVal == NO_ERROR);
}

//
// helper macro to get field of AUDIT_CONTEXT struct
//
#define GetAuditContextField(addr,f)    \
          GetFieldData( (ULONG64) addr, \
                        "AUDIT_CONTEXT",\
                        #f,             \
                        sizeof(f),      \
                        &f )

//
// helper macro to get LIST_ENTRY.Flink
//
#define GetFlink(addr,pflink) \
          GetFieldData( addr,\
                        "LIST_ENTRY", \
                        "Flink",\
                        sizeof(ULONG64),\
                        pflink )
void
DumpAuditContextList(
    )
/*++

Routine Description:

    Dump the audit context list.

Arguments:
    None

Return Value:

    None

Notes:
    It appears that there is a built in support for dumping
    lists using SYM_DUMP_PARAM.listLink but I came to know about it too late.

--*/
{
    LIST_ENTRY LsapAdtContextList = { (PLIST_ENTRY) 22, (PLIST_ENTRY) 33 };
    ULONG64    pLsapAdtContextList=0;
    ULONG      LsapAdtContextListCount=0;
    ULONG64    Temp=0;
    ULONG64    Scan=0;
    ULONG64    Link=0;
    USHORT     CategoryId;
    USHORT     AuditId;
    USHORT     ParameterCount;
    
    ULONG Status=NO_ERROR;
    ULONG i;

    if (!GetGlobalVar( "lsasrv!LsapAdtContextListCount",
                       sizeof(LsapAdtContextListCount),
                       &LsapAdtContextListCount ))
    {
        goto Cleanup;
    }

    dprintf( "# contexts: %ld\n", LsapAdtContextListCount );

    if ( ((LONG) LsapAdtContextListCount) < 0 )
    {
        dprintf("...List/ListCount may be corrupt\n");
        goto Cleanup;
    }

    if ( LsapAdtContextListCount == 0 )
    {
        goto Cleanup;
    }

    if (!GetGlobalVar( "lsasrv!LsapAdtContextList",
                       0,
                       &pLsapAdtContextList ))
    {
        dprintf("...error reading lsasrv!LsapAdtContextList\n");
        goto Cleanup;
    }
    
    Status = GetFlink( pLsapAdtContextList, &Scan );
    if ( Status != NO_ERROR )
    {
        dprintf("...error reading lsasrv!LsapAdtContextList.Flink\n");
        goto Cleanup;
    }

    dprintf("LsapAdtContextList @ %p\n", pLsapAdtContextList);
    
    for (i=0; i < LsapAdtContextListCount; i++)
    {
        dprintf("%02d) [%p]: ", i, Scan);
        
        if ( Scan == pLsapAdtContextList )
        {
            dprintf("...pre-mature end of list\nList/ListCount may be corrupt\n");
            break;
        }
        else if ( Scan == 0 )
        {
            dprintf("...NULL list element found!\nList/ListCount may be corrupt\n");
            break;
        }

        Status = GetAuditContextField( Scan, CategoryId );
                        
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.CategoryId\n");
            break;
        }

        dprintf("Category: %03x\t", CategoryId);
        
        Status = GetAuditContextField( Scan, AuditId );
                        
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.AuditId\n");
            break;
        }

        dprintf("AuditId: %03x\t", AuditId);
        
        Status = GetAuditContextField( Scan, Link );
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.Link\n");
            break;
        }
            
        Status = GetFlink( Link, &Scan );
        if ( Status != NO_ERROR )
        {
            goto Cleanup;
        }

        dprintf("\n");
    }

Cleanup:
    if ( Status != NO_ERROR )
    {
        dprintf("...failed\n");
    }
}

DECLARE_API(AuditContexts)
{
    DumpAuditContextList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\exts\berdump.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ber.h"

#define iso_member          0x2a,               // iso(1) memberbody(2)
#define us                  0x86, 0x48,         // us(840)
#define rsadsi              0x86, 0xf7, 0x0d,   // rsadsi(113549)
#define pkcs                0x01,               // pkcs(1)

#define rsa_                iso_member us rsadsi
#define rsa_len             6
#define rsa_text            "iso(2) member-body(2) us(840) rsadsi(113549) "
#define pkcs_1              iso_member us rsadsi pkcs
#define pkcs_len            7
#define pkcs_text           "iso(2) member-body(2) us(840) rsadsi(113549) pkcs(1) "


#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2

typedef struct _ObjectId {
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
    PSTR        Name;
} ObjectId;

ObjectId    KnownObjectIds[] = {
    { {pkcs_1 1, 1}, pkcs_len + 2, pkcs_text "RSA"},
    { {pkcs_1 1, 2}, pkcs_len + 2, pkcs_text "MD2/RSA"},
    { {pkcs_1 1, 4}, pkcs_len + 2, pkcs_text "MD5/RSA"},
    { {rsa_ 3, 4}, rsa_len + 2, rsa_text "RC4"},
    { {attributeType 3}, attrtype_len + 1, "CN="},
    { {attributeType 6}, attrtype_len + 1, "C="},
    { {attributeType 7}, attrtype_len + 1, "L="},
    { {attributeType 8}, attrtype_len + 1, "S="},
    { {attributeType 10}, attrtype_len + 1, "O="},
    { {attributeType 11}, attrtype_len + 1, "OU="},
    };

ObjectId    KnownPrefixes[] = {
    { {pkcs_1}, pkcs_len, pkcs_text},
    { {iso_member us rsadsi}, pkcs_len - 1, "iso(2) member-body(2) us(840) rsadsi(113549) "},
    { {iso_member us}, pkcs_len - 4, "iso(2) member-body(2) us(840) "},
    { {iso_member}, pkcs_len - 6, "iso(2) member-body(2) " }
    };


typedef struct _NameTypes {
    PSTR        Prefix;
    UCHAR       Sequence[8];
    DWORD       SequenceLen;
} NameTypes;

NameTypes   KnownNameTypes[] = { {"CN=", {attributeType 3}, attrtype_len + 1},
                                 {"C=", {attributeType 6}, attrtype_len + 1},
                                 {"L=", {attributeType 7}, attrtype_len + 1},
                                 {"S=", {attributeType 8}, attrtype_len + 1},
                                 {"O=", {attributeType 10}, attrtype_len + 1},
                                 {"OU=", {attributeType 11}, attrtype_len + 1}
                               };
BYTE        Buffer[1024];

BOOL        BerVerbose = FALSE ;

char maparray[] = "0123456789abcdef";

#define MAX_OID_VALS    32

typedef struct _OID {
    unsigned cVal;
    unsigned Val[MAX_OID_VALS];
} OID;

typedef enum _OidResult {
    OidExact,
    OidPartial,
    OidMiss,
    OidError
} OidResult;


extern  PNTSD_EXTENSION_APIS    pExtApis;
extern  HANDLE                  hDbgThread;
extern  HANDLE                  hDbgProcess;

#define DebuggerOut     (pExtApis->lpOutputRoutine)
#define GetSymbol       (pExtApis->lpGetSymbolRoutine)
#define GetExpr         (PVOID) (pExtApis->lpGetExpressionRoutine)
#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

#define ExitIfCtrlC()   if (pExtApis->lpCheckControlCRoutine()) return;
#define BreakIfCtrlC()  if (pExtApis->lpCheckControlCRoutine()) break;


#define LINE_SIZE   192
#define INDENT_SIZE 4

#define OID_VERBOSE 0x0002
#define OID_PARTIAL 0x0001

char * DefaultTree =
   "1 iso\n"
   "    2 memberbody\n"
   "        840 us\n"
   "            113549 rsadsi\n"
   "                1 pkcs\n"
   "                    1 RSA\n"
   "                    3 pkcs-3\n"
   "                        1 dhKeyAgreement\n"
   "                2 digestAlgorithm\n"
   "                    2 MD2\n"
   "                    4 MD4\n"
   "                    5 MD5\n"
   "            113554 mit\n"
   "                1 infosys\n"
   "                    2 gssapi\n"
   "                        1 generic\n"
   "                            1 user_name\n"
   "                            2 machine_uid_name\n"
   "                            3 string_uid_name\n"
   "            113556 microsoft\n"
   "                1 ds\n"
   "    3 org\n"
   "        6 dod\n"
   "            1 internet\n"
   "                4 private\n"
   "                    1 enterprise\n"
   "                        311 microsoft\n"
   "                            1 software\n"
   "                                1 systems\n"
   "                                2 wins\n"
   "                                3 dhcp\n"
   "                                4 apps\n"
   "                                5 mos\n"
   "                                7 InternetServer\n"
   "                                8 ipx\n"
   "                                9 ripsap\n"
   "                            2 security\n"
   "                                1 certificates\n"
   "                                2 mechanisms\n"
   "                                    9 Negotiator\n"
   "                                    10 NTLM\n"
   "                                    12 SSL\n"
   "                5 security\n"
   "                    3 integrity\n"
   "                        1 md5-DES-CBC\n"
   "                        2 sum64-DES-CBC\n"
   "                    5 mechanisms\n"
   "                        1 spkm\n"
   "                            1 spkm-1\n"
   "                            2 spkm-2\n"
   "                            10 spkmGssTokens\n"
   "                    6 nametypes\n"
   "                        2 gss-host-based-services\n"
   "                        3 gss-anonymous-name\n"
   "                        4 gss-api-exported-name\n"
   "        14 oiw\n"
   "            3 secsig\n"
   "                2 algorithm\n"
   "                    7 DES-CBC\n"
   "                    10 DES-MAC\n"
   "                    18 SHA\n"
   "                    22 id-rsa-key-transport\n"
   "2 joint-iso-ccitt\n"
   "    5 ds\n"
   "        4 attribute-type\n"
   "            3 CommonName\n"
   "            6 Country/region\n"
   "            7 Locality\n"
   "            8 State\n"
   "            10 Organization\n"
   "            11 OrgUnit\n"
    ;


typedef struct _TreeFile {
    CHAR *  Buffer;
    CHAR *  Line;
    CHAR *  CurNul;
} TreeFile, * PTreeFile ;


BOOL
TreeFileInit(
    PTreeFile   pFile,
    PSTR        pStr)
{
    int l;


    l = strlen( pStr );

    if ( (pStr[l - 1] != '\r') &&
         (pStr[l - 1] != '\n') )
    {
        l++;
    }

    pFile->Buffer = LocalAlloc( LMEM_FIXED, l );

    if ( pFile->Buffer )
    {
        strcpy( pFile->Buffer, pStr );
        pFile->Line = pFile->Buffer ;
        pFile->CurNul = NULL ;
    }

    return (pFile->Buffer != NULL);

}

VOID
TreeFileDelete(
    PTreeFile   pFile
    )
{
    LocalFree( pFile->Buffer );

}

PSTR
TreeFileGetLine(
    PTreeFile   pFile )
{
    PSTR    Scan;
    PSTR    Line;

    if ( !pFile->Line )
    {
        return( NULL );
    }

    if ( pFile->CurNul )
    {
        *pFile->CurNul = '\n';
    }

    pFile->CurNul = NULL ;

    Scan = pFile->Line ;

    while ( *Scan && (*Scan != '\n') && (*Scan != '\r'))
    {
        Scan++;
    }

    //
    // Okay, get the line to return
    //

    Line = pFile->Line;

    //
    // If this is not the end, touch up the pointers:
    //

    if ( *Scan )
    {
        *Scan = '\0';

        pFile->CurNul = Scan;

        Scan += 1;

        while ( *Scan && ( (*Scan == '\r' ) || ( *Scan == '\n') ))
        {
            Scan++ ;
        }

        //
        // If this is the end, reset line
        //

        if ( *Scan == '\0' )
        {
            pFile->Line = NULL ;
        }
        else
        {
            pFile->Line = Scan;
        }

    }
    else
    {
        pFile->Line = NULL ;
    }

    return( Line );

}

VOID
TreeFileRewind(
    PTreeFile   pFile )
{

    if ( pFile->CurNul )
    {
        *pFile->CurNul = '\n';
    }

    pFile->CurNul = NULL ;

    pFile->Line = pFile->Buffer ;
}

int
tohex(
    BYTE    b,
    PSTR    psz)
{
    BYTE b1, b2;

    b1 = b >> 4;
    b2 = b & 0xF;

    *psz++ = maparray[b1];
    *psz = maparray[b2];

    return(3);
}


//+---------------------------------------------------------------------------
//
//  Function:   DecodeOID
//
//  Synopsis:   Decodes an OID into a simple structure
//
//  Arguments:  [pEncoded] --
//              [len]      --
//              [pOID]     --
//
//  History:    8-07-96   RichardW   Stolen directly from DonH
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DecodeOID(unsigned char *pEncoded, int len, OID *pOID)
{
    unsigned cval;
    unsigned val;
    int i, j;

    if (len <=2) {
        return FALSE;
    }


    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;

    //DebuggerOut("Encoded value %02x turned into %d and %d\n", pEncoded[0],
    //          pOID->Val[0], pOID->Val[1] );

    cval = 2;
    i = 1;

    while (i < len) {
        j = 0;
        val = pEncoded[i] & 0x7f;
        while (pEncoded[i] & 0x80) {
            val <<= 7;
            ++i;
            if (++j > 4 || i >= len) {
                // Either this value is bigger than we can handle (we
                // don't handle values that span more than four octets)
                // -or- the last octet in the encoded string has its
                // high bit set, indicating that it's not supposed to
                // be the last octet.  In either case, we're sunk.
                return FALSE;
            }
            val |= pEncoded[i] & 0x7f;
        }
        //ASSERT(i < len);
        pOID->Val[cval] = val;
        ++cval;
        ++i;
    }
    pOID->cVal = cval;

    return TRUE;
}

PSTR
GetLineWithIndent(
    PTreeFile   ptf,
    DWORD       i)
{
    PSTR    Scan;
    DWORD   test;


    do
    {
        Scan = TreeFileGetLine( ptf );


        if ( Scan && i )
        {
            if ( i < INDENT_SIZE )
            {
                test = 0;
            }
            else
            {
                test = i - INDENT_SIZE ;
            }

            if ( Scan[ test ] != ' ' )
            {
                {
                    Scan = NULL ;
                    break;
                }
            }

        }
        else
            test = 0;

    } while ( Scan && (Scan[i] == ' ')  );

    return( Scan );
}

OidResult
scan_oid_table(
    char *  Table,
    DWORD   Flags,
    PUCHAR  ObjectId,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   MaxRep)
{
    CHAR    OidPath[ MAX_PATH ];
    OID     Oid;
    DWORD   i;
    DWORD   Indent;
    TreeFile    tf;
    PSTR    Scan;
    PSTR    Tag;
    PSTR    SubScan;
    DWORD   Index;
    DWORD   size;
    DWORD   TagSize;

    if (!DecodeOID( ObjectId, Len, &Oid ))
    {
        return( OidError );
    }


    i = 0;

    Indent = 0;

    if ( !TreeFileInit( &tf, Table ) )
    {
        DebuggerOut("Unable to load prefix table\n");
        return OidError ;
    }

    Tag = OidPath;

    size = 0;

    TagSize = 0;


    if ( (Flags & OID_VERBOSE) == 0 )
    {
        while ( i < Oid.cVal )
        {
            TagSize = _snprintf( Tag, MAX_PATH - size, "%d.",
                            Oid.Val[i] );

            size += TagSize;

            Tag += TagSize;

            i++;

        }

        strncpy( pszRep, OidPath, MaxRep );

        TreeFileDelete( &tf );

        return( OidExact );
    }

    while ( i < Oid.cVal )
    {

        do
        {

            Scan = GetLineWithIndent( &tf, Indent );


            if ( Scan )
            {
                Index = atoi(Scan);
            }
            else
            {
                Index = (DWORD) -1;
            }

            if ( Index == Oid.Val[i] )
            {
                break;
            }

        } while ( Scan );


        //
        // If Scan is NULL, we didn't get a match
        //

        if ( !Scan )
        {
            if ( i > 0 )
            {
                if ( Flags & OID_PARTIAL )
                {
                    while ( i < Oid.cVal )
                    {
                        TagSize = _snprintf( Tag, MAX_PATH - size, "%d ",
                                        Oid.Val[i] );

                        size += TagSize;

                        Tag += TagSize;

                        i++;

                    }
                    strncpy( pszRep, OidPath, MaxRep );
                }

                TreeFileDelete( &tf );

                return( OidPartial );

            }

            TreeFileDelete( &tf );

            return( OidMiss );
        }

        //
        // Got a hit:
        //

        SubScan = &Scan[Indent];

        while (*SubScan != ' ')
        {
            SubScan++;
        }

        SubScan++;

        TagSize = _snprintf( Tag, MAX_PATH - size, "%s(%d) ", SubScan, Index );

        size += TagSize;

        Tag += TagSize ;

        Indent += INDENT_SIZE ;

        i ++;


    }

    strncpy( pszRep, OidPath, MaxRep );

    TreeFileDelete( &tf );

    return( OidExact );


}

decode_to_string(
    LPBYTE  pBuffer,
    DWORD   Flags,
    DWORD   Type,
    DWORD   Len,
    PSTR    pszRep,
    DWORD   RepLen)
{
    PSTR    pstr;
    PSTR    lineptr;
    DWORD   i;


    switch (Type)
    {
        case BER_NULL:
            strcpy(pszRep, "<empty>");
            break;

        case BER_OBJECT_ID:
            scan_oid_table( DefaultTree,
                            OID_PARTIAL | (Flags & DECODE_VERBOSE_OIDS ? OID_VERBOSE : 0 ),
                            pBuffer, Len, pszRep, RepLen );

            break;

        case BER_PRINTABLE_STRING:
        case BER_TELETEX_STRING:
        case BER_GRAPHIC_STRING:
        case BER_VISIBLE_STRING:
        case BER_GENERAL_STRING:
            CopyMemory(pszRep, pBuffer, min(Len, RepLen - 1) );
            pszRep[min(Len, RepLen - 1)] = '\0';
            break;

        default:

            pstr = &pszRep[30];
            lineptr = pszRep;
            for (i = 0; i < min(Len, 8) ; i++ )
            {
                lineptr += tohex(*pBuffer, lineptr);
                if ((*pBuffer >= ' ') && (*pBuffer <= '|'))
                {
                    *pstr++ = *pBuffer;
                }
                else
                {
                    *pstr++ = '.';
                }

                pBuffer++;

            }
            *pstr++ = '\0';
    }
    return(0);
}

int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    DWORD   Flags,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth)
{
    char *  TypeName = NULL;
    char    msg[32];
    char *  pstr;
    int     i;
    int     Len;
    int     ByteCount;
    int     Accumulated;
    DWORD   Type;
    int     subsize;
    char    line[ LINE_SIZE ];
    BOOL    Nested;
    BOOL    Leaf;
    int     NewBarDepth;
    char    nonuniversal[ LINE_SIZE ];



    if ((Stop)())
    {
        return(0);
    }

    Type = *pBuffer;


    if ( (Type & 0xC0) == 0 )
    {
        switch ( Type & 0x1F )
        {
            case BER_BOOL:
                TypeName = "Bool";
                break;

            case BER_INTEGER:
                TypeName = "Integer";
                break;

            case BER_BIT_STRING:
                TypeName = "Bit String";
                break;

            case BER_OCTET_STRING:
                TypeName = "Octet String";
                if ( Flags & DECODE_NEST_OCTET_STRINGS )
                {
                    TypeName = "Octet String (Expanding)";
                    Type |= BER_CONSTRUCTED ;
                    Flags &= ~( DECODE_NEST_OCTET_STRINGS );
                }
                break;

            case BER_NULL:
                TypeName = "Null";
                break;

            case BER_OBJECT_ID:
                TypeName = "Object ID";
                break;

            case BER_OBJECT_DESC:
                TypeName = "Object Descriptor";
                break;

            case BER_SEQUENCE:
                TypeName = "Sequence";
                break;

            case BER_SET:
                TypeName = "Set";
                break;

            case BER_NUMERIC_STRING:
                TypeName = "Numeric String";
                break;

            case BER_PRINTABLE_STRING:
                TypeName = "Printable String";
                break;

            case BER_TELETEX_STRING:
                TypeName = "TeleTex String";
                break;

            case BER_VIDEOTEX_STRING:
                TypeName = "VideoTex String";
                break;

            case BER_VISIBLE_STRING:
                TypeName = "Visible String";
                break;

            case BER_GENERAL_STRING:
                TypeName = "General String";
                break;

            case BER_GRAPHIC_STRING:
                TypeName = "Graphic String";
                break;

            case BER_UTC_TIME:
                TypeName = "UTC Time";
                break;


            default:
                TypeName = "Unknown";
                break;
        }
    }
    else
    {
        //
        // Not universal
        //

        switch ( Type & 0xC0 )
        {
            case BER_UNIVERSAL:
                TypeName = "Internal Error!";
                break;

            case BER_APPLICATION:
                sprintf( nonuniversal, "[Application %d]", Type & 0x1F);
                TypeName = nonuniversal;
                break;

            case BER_CONTEXT_SPECIFIC:
                sprintf( nonuniversal, "[Context Specific %d]", Type & 0x1F);
                TypeName = nonuniversal;
                break;

            case BER_PRIVATE:
                sprintf( nonuniversal, "[Private %d]", Type & 0x1F);
                TypeName = nonuniversal ;
                break;

        }
    }


    pstr = msg;
    for (i = 0; i < Indent ; i++ )
    {
        if (i < BarDepth)
        {
            *pstr++ = '\263';
        }
        else
        {
            *pstr++ = ' ';
        }
        *pstr++ = ' ';
    }
    *pstr++ = '\0';

    pBuffer ++;
    Len = 0;

    if (*pBuffer & 0x80)
    {
        ByteCount = *pBuffer++ & 0x7f;

        for (i = 0; i < ByteCount ; i++ )
        {
            Len <<= 8;
            Len += *pBuffer++;
        }
    }
    else
    {
        ByteCount = 0;
        Len = *pBuffer++;
    }

    if (Offset + Len + 2 + ByteCount == TotalLength)
    {
        Leaf = TRUE;
    }
    else
    {
        Leaf = FALSE;
    }
    if (Type & BER_CONSTRUCTED)
    {
        Nested = TRUE;
    }
    else
    {
        Nested = FALSE;
    }

    (Out)("%s%c\304%c[%x] %s(%d) ", msg,
                    Leaf ? 192 : 195,
                        Nested ? 194 : 196,
                        Type, TypeName, Len);

    if ( Type & BER_CONSTRUCTED )
    {
        (Out)("\n");
        Accumulated = 0;
        while (Accumulated < Len)
        {
            if (BarDepth < Indent)
            {
                NewBarDepth = BarDepth;
            }
            else
            {
                NewBarDepth = (Nested && Leaf) ? BarDepth : Indent + 1;
            }

            subsize = ber_decode(Out, Stop, pBuffer, Flags, Indent + 1,
                                    Accumulated, Len, NewBarDepth);
            Accumulated += subsize;
            pBuffer += subsize;
        }
        (Out)("%s%c\n", msg, ((Indent <= BarDepth) && !Leaf) ? 179 : 32);
    }
    else
    {
        memset(line, ' ', LINE_SIZE - 1);
        line[ LINE_SIZE - 1 ] = '\0';

        decode_to_string(pBuffer, Flags, Type, Len, line, LINE_SIZE);

        (Out)("%s\n", line);

    }

    return(Len + 2 + ByteCount);
}

BOOL
NeverStop(void)
{
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\exts\ber.h ===
//+---------------------------------------------------------------------------
//
//
//  File:       ber.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-10-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __BER_H__
#define __BER_H__


#define BER_UNIVERSAL           0x00
#define BER_APPLICATION         0x40
#define BER_CONTEXT_SPECIFIC    0x80
#define BER_PRIVATE             0xC0

#define BER_PRIMITIVE           0x00
#define BER_CONSTRUCTED         0x20

#define BER_BOOL                1
#define BER_INTEGER             2
#define BER_BIT_STRING          3
#define BER_OCTET_STRING        4
#define BER_NULL                5
#define BER_OBJECT_ID           6
#define BER_OBJECT_DESC         7
#define BER_EXTERNAL            8
#define BER_REAL                9
#define BER_ENUMERATED          10

#define BER_SEQUENCE            16
#define BER_SET                 17

#define BER_NUMERIC_STRING      0x12
#define BER_PRINTABLE_STRING    0x13
#define BER_TELETEX_STRING      0x14
#define BER_VIDEOTEX_STRING     0x15
#define BER_GRAPHIC_STRING      0x19
#define BER_VISIBLE_STRING      0x1A
#define BER_GENERAL_STRING      0x1B

#define BER_UTC_TIME            23

typedef VOID (* OutputFn)(char *, ...);
typedef BOOL (* StopFn)(void);

int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    DWORD   Flags,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth);

#define DECODE_NEST_OCTET_STRINGS   0x00000001
#define DECODE_VERBOSE_OIDS         0x00000002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\exts\decode.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       decode.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-10-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include <windows.h>

#include <ntsdexts.h>
#include "ber.h"
#include "rsa.h"


PNTSD_EXTENSION_APIS    pExtApis;
HANDLE                  hDbgThread;
HANDLE                  hDbgProcess;
extern  BOOL            BerVerbose;

#define DebuggerOut     (pExtApis->lpOutputRoutine)
#define GetSymbol       (pExtApis->lpGetSymbolRoutine)
#define GetExpr         (PVOID) (pExtApis->lpGetExpressionRoutine)
#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

#define ExitIfCtrlC()   if (pExtApis->lpCheckControlCRoutine()) return;
#define BreakIfCtrlC()  if (pExtApis->lpCheckControlCRoutine()) break;

int
ReadMemory( PVOID               pvAddress,
            ULONG               cbMemory,
            PVOID               pvLocalMemory)
{
    SIZE_T       cbActual = cbMemory;

    if (ReadProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return(-1);
        }
        return(0);
    }
    return(GetLastError());

}

void
BERDecode(HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    PUCHAR      pbBuffer;
    PVOID       pRemote;
    DWORD       cb;
    UCHAR       Short[8];
    DWORD       len;
    DWORD       i;
    DWORD       Length;
    CHAR        Buf[80];
    PSTR        pBuf;
    PUCHAR      End;
    UCHAR       Type;
    PSTR        pszNext;
    DWORD       Flags;
    DWORD       headerLength ;
    PUCHAR      Scan ;


    InitDebugHelp(hProcess, hThread, lpExt);

    Flags = 0;

    while ( *pszCommand == '-' )
    {
        pszCommand++;
        if ( *pszCommand == 'v' )
        {
            Flags |= DECODE_VERBOSE_OIDS ;
        }
        if ( *pszCommand == 'n' )
        {
            Flags |= DECODE_NEST_OCTET_STRINGS ;
        }

        pszCommand++;

        pszCommand++;

    }

    pszNext = strchr(pszCommand, ' ');
    if (pszNext)
    {
        *pszNext++ = '\0';
    }

    pRemote = GetExpr(pszCommand);

    if (pszNext)
    {
        cb = (DWORD)((ULONG_PTR)GetExpr(pszNext));

    }
    else
    {

        ReadMemory(pRemote, 4, Short);

        if (Short[1] & 0x80)
        {
            headerLength = Short[1] & 0x7F ;

            cb = 0 ;

            Scan = &Short[2];

            ReadMemory( pRemote, headerLength + 1, Short );

            while ( headerLength )
            {
                cb = (cb << 8) + *Scan ;

                headerLength-- ;
                Scan++ ;

            }

        }
        else
        {
            cb = Short[1];
        }
    }

    pbBuffer = LocalAlloc(LMEM_FIXED, cb + 4);
    if (!pbBuffer)
    {
        DebuggerOut("Failed to alloc mem\n");
        return;
    }

    DebuggerOut("Size is %d (%#x) bytes\n", cb, cb);

    ReadMemory(pRemote, cb + 4, pbBuffer);

    ber_decode(lpExt->lpOutputRoutine,
                lpExt->lpCheckControlCRoutine,
                pbBuffer,
                Flags,
                0, 0, cb + 4, 0);

}

void
DumpKey(HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    BSAFE_PUB_KEY   Pub;
    BSAFE_PRV_KEY   Prv;
    PVOID           Key;
    DWORD           KeyType;
    DWORD           Bits;
    BSAFE_KEY_PARTS Parts;
    DWORD           PubSize;
    DWORD           PrvSize;

    InitDebugHelp(hProcess, hThread, lpExt);

    Key = GetExpr(pszCommand);

    ReadMemory( Key, sizeof(DWORD), &KeyType );

    if ((KeyType != RSA1) && (KeyType != RSA2))
    {
        DebuggerOut("not an rsa key\n");
        return;
    }

    ReadMemory( Key, sizeof(BSAFE_PUB_KEY), &Pub );
    Bits = Pub.bitlen;






}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\exts\lsaexts.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:
//
// Contents:
//
//
// History:
//
//------------------------------------------------------------------------


extern "C"
{
#include "lsasrvp.h"
#include "ausrvp.h"
#include "spmgr.h"
#include "sidcache.h"
}
#include <stdio.h>
#include <malloc.h>

#include <dbghelp.h>
#include <ntsdexts.h>

#include <dsysdbg.h>
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <cryptdll.h>

#include "debugp.h"

#include "..\spmgr.h"
#include "..\sphelp.h"
#include "..\sesmgr.h"
#include "..\scavenge.hxx"
#include "..\negotiat.hxx"
#include "..\sht.hxx"
#include "..\lht.hxx"


#define DBP_TYPES_ONLY
#include "..\dspolicy\dbp.h"
#define LSAEXTS
#include "..\dspolicy\dbftrust.h"

#define FlagSize(x)     (sizeof(x) / sizeof(char *))
char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * HandleFlags[] = { "Locked", "DeletePending", "NoCallback" };
char * LhtFlags[] = { "NoSerialize", "Callback", "Unique",
                        "Child", "LimitDepth", "DeletePending", "NoFree"};
char * LhtSubFlags[] = { "SubTable" };
char * ShtFlags[] = {   "NoSerialize", "Callback", "Unique",
                        "NoFree", "DeletePending" };

char * ScavFlags[] = {  "NewThread", "One Shot", "FreeHandle", "",
                        "", "", "", "",
                        "", "", "", "", "", "", "", "",
                        "", "", "", "", "", "", "", "",
                        "", "TriggerFree", "StateChange", "Immediate",
                        "DebugBreak", "AboutToDie", "InProgress", "Seconds" };

char * ScavClasses[] = { "<Invalid>", "PackageChange" };
#define ScavClassName(x)    (x < (sizeof(ScavClasses) / sizeof(char *) ) ? \
                                ScavClasses[ x ] : "<Invalid>" )

char * QueueTypes[] = { "Shared", "Single", "ShareRead", "Zombie" };
#define QueueTypeName(x)    (x < (sizeof( QueueTypes ) / sizeof( char * ) ) ? \
                                QueueTypes[ x ] : "<Invalid>" )

char * SessFlags[] = {  "Queue", "TcbPriv", "Clone", "Impersonate",
                        "Desktop", "Untrusted", "InProc", "Autonomous",
                        "Default", "Unload", "Scavenger", "Cleanup",
                        "Kernel", "Restricted", "MaybeKernel", "EFS",
                        "Shadow", "Wow64", "", "",
                        "", "", "", "",
                        "", "", "", "",
                        "", "", "", "" };

char * PackageFlags[] = {"Invalid", "Unload", "Never Load", "Internal", "Never Call",
                         "Preferred", "Delete", "Info", "ContextThunk", "Shutdown Pending",
                         "Shutdown", "WowSupport", "", "", "", "", "AuthPkg"
                        };

char * Capabilities[] = {"Sign/Verify", "Seal/Unseal", "Token Only", "Datagram",
                         "Connection", "Multi-Required", "ClientOnly", "ExtError",
                         "Impersonation", "Win32Name", "Stream", "Negotiable",
                         "GSS Compat", "Logon", "AsciiBuffer", "Fragment",
                         "MutualAuth", "Delegation", "", "",
                         "", "", "", ""
                         };

char * APIFlags[] = {"Error", "Memory", "PrePack", "GetState",
                     "AnsiCall", "HandleChange", "CallBack", "VmAlloc",
                     "ExecNow", "Win32Error", "KMap Mem", ""
                    };

char * CallInfoFlags[] = { "Kernel", "Ansi", "Urgent", "Recursive",
                           "InProc", "Cleanup", "WowClient", ""
                         };

char * LsaCallInfoFlags[] = { "Impersonating", "InProcCall", "SupressAudits", 
                            "NoHandleCheck", "KernelPool", "KMap Used" };


char * NegCredFlags[] = { "DefaultPlaceholder","Default","Multi",
                          "UseSnego","Kernel","Explicit", "MultiPart",
                          "AllowNtlm", "NegNtlm", "NtlmLoopback" };
char * NegContextFlags[] = { "PackageCalled", "FreeEachMech",
                             "Negotiating", "Fragmenting",
                             "FragInbound", "FragOutbound",
                             "Uplevel", "MutualAuth", };

char * NegPackageFlags[] = { "Preferred", "NT4", "ExtraOID", "Inbound",
                             "Outbound", "Loopback" };

char * SDFlags[] = {"OwnerDef","GroupDef","DaclPresent","DaclDef","SaclPresent",
                    "SaclDef","SelfRelative"};

char * ImpLevels[] = {"Anonymous", "Identification", "Impersonation", "Delegation"};
#define ImpLevel(x) ((x < (sizeof(ImpLevels) / sizeof(char *))) ? ImpLevels[x] : "Illegal!")

char * SecBufferTypes[] = {"Empty", "Data", "Token", "Package", "Missing", "Extra",
                           "Trailer", "Header" };
#define SecBufferType(x) (((x & ~(SECBUFFER_ATTRMASK)) < (sizeof(SecBufferTypes) / sizeof(char *))) ? \
                            SecBufferTypes[ (x & ~(SECBUFFER_ATTRMASK)) ] : "Invalid" )

char * LogonTypes[] = {"Invalid", "Invalid",
                       "Interactive",
                       "Network",
                       "Batch",
                       "Service",
                       "Proxy",
                       "Unlock",
                       "NetworkCleartext",
                       "NewCredentials" };

#define LogonTypeName( x )  ( ( x < sizeof( LogonTypes ) / sizeof( char * )) ? \
                              LogonTypes[ x ] : "Invalid" )

char * MessageNames[] = {       "<Disconnect>",
                                "<Connect>",
                                "LsaLookupPackage",
                                "LsaLogonUser",
                                "LsaCallPackage",
                                "LsaDeregisterLogonProcess",
                                "<empty>",
                                "(I) GetBinding",
                                "(I) SetSession",
                                "(I) FindPackage",
                                "EnumeratePackages",
                                "AcquireCredentialHandle",
                                "EstablishCredentials",
                                "FreeCredentialHandle",
                                "InitializeSecurityContext",
                                "AcceptSecurityContext",
                                "ApplyControlToken",
                                "DeleteSecurityContext",
                                "QueryPackage",
                                "GetUserInfo",
                                "GetCredentials",
                                "SaveCredentials",
                                "DeleteCredentials",
                                "QueryCredAttributes",
                                "AddPackage",
                                "DeletePackage",
                                "GenerateKey",
                                "GenerateDirEfs",
                                "DecryptFek",
                                "GenerateSessionKey",
                                "Callback",
                                "QueryContextAttributes",
                                "PolicyChangeNotify",
                                "GetUserName",
                                "AddCredential",
                                "EnumLogonSession",
                                "GetLogonSessionData",
                                "SetContextAttribute",
                                "LookupAccountSid",
                                "LookupAccountName",
                                "<empty>" };
#define ApiLabel(x) (((x+2) < sizeof(MessageNames) / sizeof(char *)) ?  \
                        MessageNames[(x+2)] : "[Illegal API Number!]")

#define NAME_BASE       "lsasrv"
#define PACKAGE_LIST    NAME_BASE "!pPackageControlList"
#define PACKAGE_COUNT   NAME_BASE "!PackageControlCount"
#define DLL_COUNT       NAME_BASE "!PackageDllCount"
#define DLL_LIST        NAME_BASE "!pPackageDllList"
#define SESSION_LIST    NAME_BASE "!SessionList"
#define MEMORY_LIST     NAME_BASE "!pLastBlock"
#define TLS_SESSION     NAME_BASE "!dwSession"
#define PFASTMEM        NAME_BASE "!pFastMem"
#define CFASTMEM        NAME_BASE "!cFastMem"
#define FFASTMEM        NAME_BASE "!fFastMemStats"

#define MAXPOOLTHREADS  NAME_BASE "!MaxPoolThreads"
#define GLOBALQUEUE     NAME_BASE "!GlobalQueue"

#define SCAVLIST        NAME_BASE "!ScavList"
#define NOTIFYLIST      NAME_BASE "!NotifyList"


#define LPC_APILOG      NAME_BASE "!LpcApiLog"
#define INTERNAL_APILOG NAME_BASE "!InternalApiLog"

#define FAULTINGTID     NAME_BASE "!FaultingTid"
#define THREADCONTEXT   NAME_BASE "!dwThreadContext"
#define LASTERROR       NAME_BASE "!dwLastError"
#define EXCEPTIONINFO   NAME_BASE "!dwExceptionInfo"
#define TLS_CALLINFO    NAME_BASE "!dwCallInfo"


WCHAR *Packages[]     = {L"Kerberos", L"NTLM", L"MSV" };

#define AllocHeap(x)    RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, x)
#define FreeHeap(x) RtlFreeHeap(RtlProcessHeap(), 0, x)
void    PrintToken(HANDLE, PNTSD_EXTENSION_APIS);
void    LocalDumpSid(PSID);

PNTSD_EXTENSION_APIS    pExtApis;
HANDLE                  hDbgThread;
HANDLE                  hDbgProcess;

#define DebuggerOut     (pExtApis->lpOutputRoutine)
#define LsaGetSymbol       (pExtApis->lpGetSymbolRoutine)
#define GetExpr         (PVOID) (pExtApis->lpGetExpressionRoutine)
#define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

#define DBG_STACK_TRACE 8

CHAR*
SidNameUseXLate(
    INT i
    )
{
    switch ( i ) {

        case SidTypeUser:
            return "User";
        case SidTypeGroup:
            return "Group";
        case SidTypeDomain:
            return "Domain";
        case SidTypeAlias:
            return "Alias";
        case SidTypeWellKnownGroup:
            return "WellKnownGroup";
        case SidTypeDeletedAccount:
            return "Deleted Account";
        case SidTypeInvalid:
            return "Invalid Sid";
        case SidTypeUnknown:
            return "Unknown Type";
        case SidTypeComputer:
            return "Computer";
        default:
            return "Really Unknown -- This is a bug";
    }

}

SECURITY_STATUS
LsaReadMemory( PVOID               pvAddress,
            ULONG               cbMemory,
            PVOID               pvLocalMemory)
{
    SIZE_T       cbActual = cbMemory;

    if (ReadProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return(-1);
        }
        return(0);
    }
    return(GetLastError());

}

SECURITY_STATUS
LsaWriteMemory(PVOID           pvLocalMemory,
            ULONG           cbMemory,
            PVOID           pvAddress)
{
    SIZE_T       cbActual = cbMemory;

    if (WriteProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return(-1);
        }
        return(0);
    }
    return(GetLastError());
}

DWORD
GetDword(PVOID  pvMemory)
{
    DWORD   dwVal;
    SIZE_T   cbActual = sizeof(DWORD);

    if (ReadProcessMemory(hDbgProcess, pvMemory, &dwVal, sizeof(DWORD), &cbActual))
    {
        if (cbActual != sizeof(DWORD))
        {
            return((DWORD) -1);
        }
        return(dwVal);
    }
    return((DWORD) -1);
}

TEB *
GetTeb(HANDLE   hThread)
{
    NTSTATUS                    Status;
    THREAD_BASIC_INFORMATION    ThreadInfo;
    ULONG                       cbReturned;
    PTEB                        Teb;

    Status = NtQueryInformationThread(  hThread,
                                        ThreadBasicInformation,
                                        &ThreadInfo,
                                        sizeof(ThreadInfo),
                                        &cbReturned);

    if (!NT_SUCCESS(Status))
    {
        DebuggerOut("Failed to read Teb, %x\n", Status);
        return(NULL);
    }

    Teb = (PTEB) AllocHeap(sizeof(TEB));

    if ( Teb )
    {
        LsaReadMemory(ThreadInfo.TebBaseAddress, sizeof(TEB), Teb);
    }


    return(Teb);

}

PVOID
GetTlsFromTeb(
            ULONG   Index,
            TEB *   Teb)
{
    return(Teb->TlsSlots[Index]);
}

SECURITY_STATUS
GetTlsEntry(ULONG       TlsValue,
            PVOID *     ppvValue)
{
    TEB *                       Teb;

    Teb = GetTeb(hDbgThread);

    if (!Teb)
    {
        DebuggerOut("Could not read teb for thread\n");
        return(STATUS_UNSUCCESSFUL);
    }

    *ppvValue = GetTlsFromTeb(TlsValue, Teb);

    FreeHeap(Teb);

    return(0);

}




void DisplayFlags(  DWORD       Flags,
                    DWORD       FlagLimit,
                    char        *flagset[],
                    UCHAR *      buffer)
{
   char *         offset;
   DWORD          mask, test, i;
   DWORD          scratch;

   if (!Flags) {
      strcpy((CHAR *)buffer, "None");
      return;
   }
   buffer[0] = '0';

   mask = 0;
   offset = (CHAR *) buffer;
   test = 1;
   for (i = 0 ; i < FlagLimit ; i++ ) {
      if (Flags & test) {
         scratch = sprintf(offset, "%s", flagset[i]);
         offset += scratch;
         mask |= test;
         if (Flags & (~mask)) {
            *offset++ = ',';
         }
      }
      test <<= 1;
   }
}

#define TIMEBUF_SZ  64
char *Months[]      = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
            "Aug", "Sep", "Oct", "Nov", "Dec" };
void CTimeStamp(
    PTimeStamp      ptsTime,
    LPSTR           pszTimeBuf,
    BOOL            LocalOnly)
{
    SYSTEMTIME      stTime;
    FILETIME        tLocal;
    SYSTEMTIME      stLocal;

    if (ptsTime->HighPart == 0)
    {
        strcpy(pszTimeBuf, "<Zero>");
        return;
    }
    else if (ptsTime->HighPart >= 0x7FFFFFFF)
    {
        strcpy(pszTimeBuf, "<Never>");
        return;
    }
    FileTimeToLocalFileTime((LPFILETIME) ptsTime, &tLocal);
    FileTimeToSystemTime((LPFILETIME) ptsTime, &stTime);
    FileTimeToSystemTime(&tLocal, &stLocal);
    if ( LocalOnly )
    {
        sprintf( pszTimeBuf, "%02d:%02d:%02d.%03d",
                stLocal.wHour, stLocal.wMinute, stLocal.wSecond, stLocal.wMilliseconds);

    }
    else
    {
        sprintf(pszTimeBuf, "%02d:%02d:%02d.%03d, %s %02d, %d UTC (%02d:%02d %s %02d Local)", stTime.wHour,
            stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
            Months[stTime.wMonth], stTime.wDay, stTime.wYear,
            stLocal.wHour, stLocal.wMinute, Months[stLocal.wMonth], stLocal.wDay);

    }
}

void
MapString(
    PSECURITY_STRING  pClientString,
    PSECURITY_STRING  pLocalString)
{
    if (!pLocalString->Buffer)
    {
        pLocalString->Buffer = (PWSTR) AllocHeap(pClientString->Length + 2);
        pLocalString->MaximumLength = pClientString->Length + 2;
    }

    if ( !pLocalString->Buffer )
    {
        return;
    }

    RtlZeroMemory(pLocalString->Buffer, pLocalString->MaximumLength);

    if (!LsaReadMemory(pClientString->Buffer, pClientString->Length, pLocalString->Buffer))
    {
        pLocalString->Length = pClientString->Length;
    }
    else
    {
        DebuggerOut("\nWarning: could not read string @%p\n", pClientString->Buffer);
    }

}

BOOL
MapSid(
    PSID RemoteSid,
    PSID * LocalSid
    )
{
    SID Temp ;
    PSID Copy ;

    *LocalSid = NULL ;

    if ( RemoteSid == NULL )
    {
        return FALSE ;
    }

    if ( !LsaReadMemory( RemoteSid, sizeof( SID ), &Temp ) )
    {
        return FALSE ;
    }

    Copy = AllocHeap( RtlLengthSid( &Temp ) );

    if ( !Copy )
    {
        return FALSE ;
    }

    if ( !LsaReadMemory( RemoteSid, RtlLengthSid( &Temp ), Copy ) )
    {
        FreeHeap( Copy );
        return FALSE ;
    }

    *LocalSid = Copy ;

    return TRUE ;


}

WCHAR * GetPackageName(
    DWORD_PTR    dwPackageId)
{
    switch (dwPackageId)
    {
        case SPMGR_ID:
            return(L"SPMgr");

        default:
            return(L"");

    }
}


#define PACKAGE_VERBOSE 0x00000001
#define PACKAGE_NOISY   0x00000002
#define PACKAGE_TITLE   0x00000004
void
ShowPackageControl(
    PVOID           Base,
    PLSAP_SECURITY_PACKAGE     pSecPkgCtrl,
    DWORD           fVerbose)
{
    SECURITY_STRING sLocal;
    UCHAR            buffer[ MAX_PATH ];
    ULONG_PTR       Disp;
    PSECPKG_FUNCTION_TABLE  pTable;

    sLocal.Buffer = NULL;

    MapString(&pSecPkgCtrl->Name, &sLocal);

    if (fVerbose & PACKAGE_TITLE)
    {
        DebuggerOut("Security Package Control structure at %p\n", Base);
    }

    DebuggerOut("ID         \t%d\n", pSecPkgCtrl->dwPackageID);
    DebuggerOut("Name       \t%ws\n", sLocal.Buffer);
    FreeHeap(sLocal.Buffer);
    if (fVerbose & PACKAGE_VERBOSE)
    {
        DisplayFlags(pSecPkgCtrl->fPackage, FlagSize(PackageFlags), PackageFlags, buffer);
        DebuggerOut("  Flags    \t%#x: %s\n", pSecPkgCtrl->fPackage, buffer);
        DisplayFlags(pSecPkgCtrl->fCapabilities, 18, Capabilities, buffer);
        DebuggerOut("  Capabilities\t%#x: %s\n", pSecPkgCtrl->fCapabilities, buffer);
        DebuggerOut("  RPC ID   \t%d\n", pSecPkgCtrl->dwRPCID);
        DebuggerOut("  Version  \t%d\n", pSecPkgCtrl->Version );
        DebuggerOut("  TokenSize\t%d\n", pSecPkgCtrl->TokenSize );
        DebuggerOut("  Thunks   \t%p\n", pSecPkgCtrl->Thunks );
    }

    sLocal.Buffer = NULL;

    if (fVerbose & PACKAGE_NOISY)
    {
        pTable = &pSecPkgCtrl->FunctionTable;
        DebuggerOut("  Function table:\n");
        LsaGetSymbol((ULONG_PTR)pTable->Initialize,   buffer, &Disp);
        DebuggerOut("   Initialize         \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->GetInfo, buffer, &Disp);
        DebuggerOut("   GetInfo            \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->LogonUser, buffer, &Disp);
        DebuggerOut("   LogonUser          \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->AcceptCredentials, buffer, &Disp);
        DebuggerOut("   AcceptCreds        \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->AcquireCredentialsHandle, buffer, &Disp);
        DebuggerOut("   AcquireCreds       \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->FreeCredentialsHandle, buffer, &Disp);
        DebuggerOut("   FreeCreds          \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->SaveCredentials, buffer, &Disp);
        DebuggerOut("   SaveCredentials    \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->GetCredentials, buffer, &Disp);
        DebuggerOut("   GetCredentials     \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->DeleteCredentials, buffer, &Disp);
        DebuggerOut("   DeleteCredentials  \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->InitLsaModeContext, buffer, &Disp);
        DebuggerOut("   InitLsaModeContext \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->LogonTerminated, buffer, &Disp);
        DebuggerOut("   LogonTerminated    \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->AcceptLsaModeContext, buffer, &Disp);
        DebuggerOut("   AcceptLsaModeContext\t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->DeleteContext, buffer, &Disp);
        DebuggerOut("   DeleteContext      \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->ApplyControlToken, buffer, &Disp);
        DebuggerOut("   ApplyControlToken  \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->Shutdown, buffer, &Disp);
        DebuggerOut("   Shutdown           \t%s\n", buffer);
        LsaGetSymbol((ULONG_PTR)pTable->GetUserInfo, buffer, &Disp);
        DebuggerOut("   GetUserInfo        \t%s\n", buffer);

    }

}

void
ShowSession(
    PVOID   pvSessionStart,
    PSession    pSession)
{
    UCHAR Buffer[128];
    ULONG_PTR Disp;
    LSAP_SESSION_RUNDOWN Rundown ;
    LSAP_SHARED_SECTION Section ;
    int i;
    PUCHAR ListEnd ;
    PVOID There ;
    DWORD   Tag;
    LARGE_HANDLE_TABLE  Large ;
    SMALL_HANDLE_TABLE  Small ;
    PVOID   Table ;



    DebuggerOut("Session @%p:\n", pvSessionStart);
    DebuggerOut("  Process ID\t%x\n", pSession->dwProcessID);
    DebuggerOut("  LPC Port  \t%x\n", pSession->hPort);

    DisplayFlags(pSession->fSession,    // Flags
                 32,                    // Flag limit
                 SessFlags,             // Flag set
                 Buffer);


    DebuggerOut("  Flags     \t%x: %s\n", pSession->fSession, Buffer);

    Table = pSession->SharedData->CredTable ;
    LsaReadMemory( Table, sizeof(DWORD), &Tag );

    if ( Tag == LHT_TAG )
    {
        LsaReadMemory( Table, sizeof( Large ), &Large );

        DebuggerOut("  CredTable \t%p, %d handles\n", Table, Large.Count );

    }
    else if ( Tag == SHT_TAG )
    {
        LsaReadMemory( Table, sizeof( Small ), &Small );

        DebuggerOut("  CredTable \t%p, %d handles\n", Table, Small.Count );

    }
    else
    {
        DebuggerOut("  CredTable \t%p, not a valid table\n", Table );
    }

    Table = pSession->SharedData->ContextTable ;

    LsaReadMemory( Table, sizeof(DWORD), &Tag );

    if ( Tag == LHT_TAG )
    {
        LsaReadMemory( Table, sizeof( Large ), &Large );

        DebuggerOut("  ContextTable\t%p, %d handles\n", Table, Large.Count );

    }
    else if ( Tag == SHT_TAG )
    {
        LsaReadMemory( Table, sizeof( Small ), &Small );

        DebuggerOut("  ContextTable\t%p, %d handles\n", Table, Small.Count );

    }
    else
    {
        DebuggerOut("  ContextTable\t%p, not a valid table\n", Table );
    }
    DebuggerOut("  RefCount  \t%d\n", pSession->RefCount );

    ListEnd = (PUCHAR) pvSessionStart + FIELD_OFFSET( Session, RundownList ) ;

    if ( pSession->RundownList.Flink == (PLIST_ENTRY) ListEnd )
    {
        DebuggerOut("  No rundown functions\n" );
    }
    else
    {
        DebuggerOut("  Rundown Functions:\n" );

        There = pSession->RundownList.Flink ;

        do
        {
            LsaReadMemory( There,
                        sizeof( LSAP_SESSION_RUNDOWN ),
                        &Rundown );

            LsaGetSymbol( (ULONG_PTR) Rundown.Rundown, Buffer, &Disp );
            DebuggerOut("    %s( %p )\n", Buffer, Rundown.Parameter );

            There = Rundown.List.Flink ;

            if (pExtApis->lpCheckControlCRoutine())
            {
                break;
            }

        } while ( There != ListEnd );

    }

    ListEnd = (PUCHAR) pvSessionStart + FIELD_OFFSET( Session, SectionList ) ;

    if ( pSession->SectionList.Flink == (PLIST_ENTRY) ListEnd )
    {
        DebuggerOut("  No shared sections\n");
    }
    else
    {
        DebuggerOut("  Shared Sections\n");

        There = pSession->SectionList.Flink ;

        do
        {
            LsaReadMemory( There,
                        sizeof( LSAP_SHARED_SECTION ),
                        &Section );

            DebuggerOut("    Section %p, base at %p\n",
                            Section.Section, Section.Base );

            There = Section.List.Flink ;

            if (pExtApis->lpCheckControlCRoutine())
            {
                break;
            }

        } while ( There != ListEnd );
    }


    if (pSession->fSession & SESFLAG_TASK_QUEUE)
    {
        DebuggerOut("  Ded. Thread\t%d (%#x)\n", pSession->ThreadId,
                            pSession->ThreadId);
    }
}


void
DumpSessionList(HANDLE                  hProcess,
                HANDLE                  hThread,
                DWORD                   dwCurrentPc,
                PNTSD_EXTENSION_APIS    lpExt,
                LPSTR                   pszCommand)
{
    PVOID       pvSessionStart;
    PVOID       pvAddress;
    Session     Sess;
    NTSTATUS    Status;
    LSAP_SHARED_SESSION_DATA SharedData ;

    InitDebugHelp(hProcess, hThread, lpExt);

    pvAddress = (PVOID) GetExpr(SESSION_LIST);
    (void) LsaReadMemory(pvAddress, sizeof(PVOID), &pvSessionStart);
    DebuggerOut("psSessionList (@%p) = %p\n", pvAddress, pvSessionStart);

    do
    {
        Status = LsaReadMemory(pvSessionStart, sizeof(Session), &Sess);
        if (Status != 0)
        {
            DebuggerOut("Failed reading memory @%p\n", pvSessionStart);
            break;
        }

        LsaReadMemory( Sess.SharedData, sizeof( SharedData ), &SharedData );

        Sess.SharedData = &SharedData ;

        ShowSession(pvSessionStart, &Sess);

        pvSessionStart = Sess.List.Flink ;

    } while (pvSessionStart != pvAddress );

    return;

}

void
DumpSession(HANDLE                  hProcess,
            HANDLE                  hThread,
            DWORD                   dwCurrentPc,
            PNTSD_EXTENSION_APIS    lpExt,
            LPSTR                   pszCommand)
{
    PVOID       pvAddress;
    PVOID       BaseAddress ;
    Session     Sess;
    NTSTATUS    Status;
    UINT_PTR    id;
    LSAP_SHARED_SESSION_DATA SharedData ;
    BOOL Found;

    InitDebugHelp(hProcess, hThread, lpExt);

    pvAddress = GetExpr( pszCommand );

    id = ( UINT_PTR ) pvAddress;
    if ( id < 0x00010000 )
    {
        //
        // Search by process id:
        //

        pvAddress = (PVOID) GetExpr( SESSION_LIST );
        BaseAddress = pvAddress ;
        LsaReadMemory( pvAddress, sizeof( PVOID ), &pvAddress );
        Found = FALSE ;

        do
        {
            Status = LsaReadMemory(pvAddress, sizeof(Session), &Sess);
            if (Status != 0)
            {
                DebuggerOut("Failed reading memory @%p\n", pvAddress );
                break;
            }

            if ( Sess.dwProcessID == id )
            {
                LsaReadMemory( Sess.SharedData, sizeof( SharedData ), &SharedData );

                Sess.SharedData = &SharedData ;

                ShowSession( pvAddress, &Sess );
                Found = TRUE ;
            }

            pvAddress = Sess.List.Flink ;

        } while (pvAddress != BaseAddress );

        if ( !Found )
        {
            DebuggerOut( "No session found with process id == %x\n", id );
        }

    }
    else
    {
        Status = LsaReadMemory(pvAddress, sizeof(Session), &Sess);

        LsaReadMemory( Sess.SharedData, sizeof( SharedData ), &SharedData );

        Sess.SharedData = &SharedData ;

        ShowSession(pvAddress, &Sess);


    }

}

NTSTATUS
ReadCallInfo(
    PLSA_CALL_INFO CallInfo
    )
{
    DWORD TlsValue ;
    PVOID pvInfo ;
    NTSTATUS Status ;

    TlsValue =  GetDword(GetExpr(TLS_CALLINFO));

    Status = GetTlsEntry(TlsValue, &pvInfo);

    if (Status != 0)
    {
        DebuggerOut("Could not get TLS %d for Thread\n", TlsValue);
        return Status ;
    }

    if ( pvInfo )
    {
        Status = LsaReadMemory( pvInfo, sizeof( LSA_CALL_INFO ), CallInfo );
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL ;
    }

    return Status ;
}

VOID
ShowCallInfo(
    PVOID pv,
    PLSA_CALL_INFO CallInfo
    )
{
    ULONG i;
    CHAR Flags[ 128 ];


    DisplayFlags(CallInfo->CallInfo.Attributes,    // Flags
                 8,                    // Flag limit
                 CallInfoFlags,             // Flag set
                 (PUCHAR) Flags );


    DebuggerOut("LSA_CALL_INFO at %p\n", pv );
    DebuggerOut("  Message              %p\n", CallInfo->Message );
    DebuggerOut("  Session              %p\n", CallInfo->Session );
    DebuggerOut("   CallInfo.ThreadId       %x\n", CallInfo->CallInfo.ThreadId );
    DebuggerOut("   CallInfo.ProcessId      %x\n", CallInfo->CallInfo.ProcessId );
    DebuggerOut("   CallInfo.Attributes     %x : %s\n", CallInfo->CallInfo.Attributes, Flags );
    DebuggerOut("  InProcToken          %x\n", CallInfo->InProcToken );
    DebuggerOut("  InProcCall           %x\n", CallInfo->InProcCall );
    DisplayFlags(CallInfo->Flags, 6, LsaCallInfoFlags, (PUCHAR) Flags );
    DebuggerOut("  Flags                %x : %s\n", CallInfo->Flags, Flags );
    DebuggerOut("  Allocs               %d\n", CallInfo->Allocs );
    for (i = 0 ; i < CallInfo->Allocs ; i++ )
    {
        DebuggerOut("     Buffers[%d]      %p\n", CallInfo->Buffers[i]);
    }
    DebuggerOut("  KMap                 %p\n", CallInfo->KMap );
}

VOID
DumpThreadCallInfo(
    HANDLE hProcess,
    HANDLE hThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExt,
    LPSTR pszCommand
    )
{
    LSA_CALL_INFO CallInfo ;
    NTSTATUS Status ;

    InitDebugHelp(hProcess, hThread, lpExt);

    Status = ReadCallInfo( &CallInfo );

    if ( Status == 0 )
    {
        ShowCallInfo( NULL, &CallInfo );
    }
}

VOID
DumpCallInfo(
    HANDLE hProcess,
    HANDLE hThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExt,
    LPSTR pszCommand
    )
{
    LSA_CALL_INFO CallInfo ;
    NTSTATUS Status ;
    PVOID pv ;

    InitDebugHelp(hProcess, hThread, lpExt);

    pv = GetExpr( pszCommand );

    if ( pv )
    {
        LsaReadMemory( pv, sizeof( LSA_CALL_INFO ), &CallInfo );

        ShowCallInfo( pv, &CallInfo );
    }
}

void
DumpThreadSession(  HANDLE                  hProcess,
                    HANDLE                  hThread,
                    DWORD                   dwCurrentPc,
                    PNTSD_EXTENSION_APIS    lpExt,
                    LPSTR                   pszCommand)
{
    PVOID       pvSessionStart;
    Session     Session;
    NTSTATUS    Status;
    DWORD       TlsValue;
    LSAP_SHARED_SESSION_DATA SharedData ;

    InitDebugHelp(hProcess, hThread, lpExt);

    TlsValue =  GetDword(GetExpr(TLS_SESSION));

    Status = GetTlsEntry(TlsValue, &pvSessionStart);

    if (Status != 0)
    {
        DebuggerOut("Could not get TLS %d for Thread\n", TlsValue);
        return;
    }

    if (pvSessionStart)
    {

        Status = LsaReadMemory(pvSessionStart, sizeof(Session), &Session);

        LsaReadMemory( Session.SharedData, sizeof( SharedData ), &SharedData );

        Session.SharedData = &SharedData ;

        ShowSession(pvSessionStart, &Session);

    }
    else
    {
        DebuggerOut("TLS entry was NULL!\n");

    }


    return;
}

void
DumpPackage(        HANDLE                  hProcess,
                    HANDLE                  hThread,
                    DWORD                   dwCurrentPc,
                    PNTSD_EXTENSION_APIS    lpExt,
                    LPSTR                   pszCommand)
{
    PVOID           pvSPC = NULL;
    PVOID           pSPC;
    PLSAP_SECURITY_PACKAGE  pControl;
    UINT_PTR        dwExpr;
    PVOID           pcPackage;
    DWORD           cPackages;
    DWORD           cb;
    DWORD           fDump;
    BOOLEAN         fDumpAll;
    BOOLEAN         fDumpSingle;
    UINT_PTR        Index;
    LSAP_SECURITY_PACKAGE   Package;
    PLSAP_SECURITY_PACKAGE * pPackageList ;

    InitDebugHelp(hProcess, hThread, lpExt);

    fDump = 0;
    dwExpr = 0;
    fDumpAll = FALSE;
    fDumpSingle = FALSE;
    pSPC = NULL;
    Index = 0;

    pcPackage = GetExpr(PACKAGE_COUNT);
    LsaReadMemory(pcPackage, sizeof(DWORD), &cPackages);
    DebuggerOut("  There are %d package in the system\n", cPackages);

    if (pszCommand && *pszCommand != '\0' )
    {
        DebuggerOut("Processing '%s'\n", pszCommand);

        while (*pszCommand)
        {
            while (*pszCommand == ' ')
            {
                pszCommand++;
            }

            if (*pszCommand == '-')
            {
                pszCommand++;
                switch (*pszCommand)
                {
                    case 'V':
                    case 'v':
                        fDump |= PACKAGE_VERBOSE;
                        break;
                    case 'B':
                    case 'b':
                        fDump |= PACKAGE_NOISY;
                        break;
                    case 'a':
                    case 'A':
                        fDumpAll = TRUE;
                        break;
                    default:
                        DebuggerOut("Invalid switch '%c'\n", *pszCommand);
                        break;
                }
                pszCommand++;
                continue;
            }

            dwExpr = (UINT_PTR) GetExpr(pszCommand);
            fDumpAll = FALSE;
            if (dwExpr < cPackages)
            {
                Index = dwExpr;
                fDumpSingle = TRUE;
            }
            else if (dwExpr < 0x00010000)
            {
                DebuggerOut("Invalid package ID (%d)\n", dwExpr);
                return;
            } else
                pSPC = (PVOID) dwExpr;

            while (*pszCommand && *pszCommand != ' ')
            {
                pszCommand++;
            }
        }

    }
    else
    {
        fDumpAll = TRUE;
    }

    if (pSPC == NULL)
    {
        pvSPC = GetExpr(PACKAGE_LIST);

        LsaReadMemory(pvSPC, sizeof(PVOID), &pSPC);

    }
    DebuggerOut("  Package table pointer is at %p, address is %p\n", pvSPC, pSPC);

    pPackageList = (PLSAP_SECURITY_PACKAGE *) AllocHeap( sizeof(PVOID) * cPackages );

    if ( pPackageList )
    {
        LsaReadMemory( pSPC, sizeof(PVOID) * cPackages, pPackageList );

    }
    else
    {
        DebuggerOut("Out of memory\n");
        return;
    }


    if (fDumpSingle)
    {

        LsaReadMemory( pPackageList[ Index ], sizeof( LSAP_SECURITY_PACKAGE ), &Package );

        ShowPackageControl( pPackageList[ Index ],
                            &Package,
                            fDump | PACKAGE_TITLE );

    }
    else
    {
       for ( Index = 0 ; Index < cPackages ; Index++ )
       {
          LsaReadMemory( pPackageList[ Index ], sizeof( LSAP_SECURITY_PACKAGE ), &Package );

          ShowPackageControl( pPackageList[ Index ], &Package, fDump );
       }
    }

    FreeHeap( pPackageList );

}


BOOL
ShowScavItem(
    PVOID Base,
    PLSAP_SCAVENGER_ITEM Item
    )
{
    ULONG_PTR Disp ;
    UCHAR Symbol[ MAX_PATH ];
    DWORD Handle ;
    PVOID HandleTable ;

    if ( (Item->ScavCheck != SCAVMAGIC_ACTIVE) &&
         (Item->ScavCheck != SCAVMAGIC_FREE) )
    {
        DebuggerOut("Invalid scavenger item (check value not matched)\n");
        return FALSE ;
    }

    DebuggerOut( "LSAP_SCAVENGER_ITEM at %#x\n", Base );

    LsaGetSymbol((ULONG_PTR)Item->Function, Symbol, &Disp);

    DebuggerOut( "  Function        \t%s\n", Symbol );
    DebuggerOut( "  Parameter       \t%p\n", Item->Parameter );

    DisplayFlags(Item->Flags, 32, ScavFlags, (PUCHAR) Symbol );
    DebuggerOut( "  Flags           \t%x:%s\n", Item->Flags, Symbol );
    DebuggerOut( "  PackageId       \t%d\n", Item->PackageId );
    if ( Item->TimerHandle )
    {
        DebuggerOut( "  TimerHandle     \t%x\n", Item->TimerHandle );
    }

    switch ( Item->Type )
    {
        case NOTIFIER_TYPE_INTERVAL:
            DebuggerOut( "  Type            \tInterval\n" );
            break;

        case NOTIFIER_TYPE_HANDLE_WAIT:
            DebuggerOut( "  Type            \tHandle Wait\n");
            break;

        case NOTIFIER_TYPE_NOTIFY_EVENT:
            DebuggerOut( "  Type            \tNotify Event\n" );
            DebuggerOut( "  Class           \t%x\n", Item->Class );
            break;

        default:
            DebuggerOut( "  Type            \tUNKNOWN\n" );
            break;

    }

    return TRUE ;
}

void
DumpScavList(   HANDLE                  hProcess,
                HANDLE                  hThread,
                DWORD                   dwCurrentPc,
                PNTSD_EXTENSION_APIS    lpExt,
                LPSTR                   pszCommand)
{
    LSAP_SCAVENGER_ITEM Item ;
    PVOID ListAddress ;
    LIST_ENTRY List ;
    PLIST_ENTRY Scan ;
    UINT_PTR index = 0 ;
    BOOL DumpAll = FALSE ;
    DWORD max = 0 ;

    InitDebugHelp(hProcess, hThread, lpExt);

    if ( _strnicmp( pszCommand, "notify", 6 ) == 0 )
    {
        ListAddress = GetExpr( NOTIFYLIST );
    }
    else
    {
        ListAddress = GetExpr( SCAVLIST );
    }

    LsaReadMemory( ListAddress, sizeof( LIST_ENTRY ), &List );

    Scan = List.Flink ;

    while ( Scan != ListAddress )
    {
        LsaReadMemory( Scan, sizeof( LSAP_SCAVENGER_ITEM ), &Item );

        if ( !ShowScavItem( Scan, &Item ) )
        {
            break;

        }

        Scan = Item.List.Flink ;

        if (pExtApis->lpCheckControlCRoutine())
        {
            break;
        }
    }


}




void
PrintSid(   HANDLE      hProcess,
            HANDLE      hThread,
            PNTSD_EXTENSION_APIS    lpExt,
            PVOID       pvSid )
{
    SID Sid;
    PSID pSid;

    if (LsaReadMemory(pvSid, sizeof(SID), &Sid))
    {
        DebuggerOut("Could not read from %p\n", pvSid);
    }

    pSid = AllocHeap(RtlLengthRequiredSid(Sid.SubAuthorityCount));

    if (pSid == NULL)
    {
        DebuggerOut("Unable to allocate memory to print SID\n");
    }
    else
    {
        if (LsaReadMemory(pvSid, RtlLengthRequiredSid(Sid.SubAuthorityCount), pSid))
        {
            DebuggerOut("Could not read from %p\n", pvSid);
        }

        LocalDumpSid(pSid);
        DebuggerOut("\n");

        FreeHeap(pSid);
    }
}

void
DumpSid(    HANDLE                  hProcess,
            HANDLE                  hThread,
            DWORD                   dwCurrentPc,
            PNTSD_EXTENSION_APIS    lpExt,
            LPSTR                   pszCommand)
{
    PVOID   pvSid;

    InitDebugHelp(hProcess, hThread, lpExt);
    pvSid = GetExpr(pszCommand);

    PrintSid(hProcess, hThread, lpExt, pvSid );
}


void
DumpToken(  HANDLE                  hProcess,
            HANDLE                  hThread,
            DWORD                   dwCurrentPc,
            PNTSD_EXTENSION_APIS    lpExt,
            LPSTR                   pszCommand)
{
    DWORD   fDump = 0;
    HANDLE  hToken;
    HANDLE  hRemoteToken;

#define DUMP_HEX    1

    InitDebugHelp(hProcess, hThread, lpExt);

    while (*pszCommand == '-')
    {
        pszCommand++;
        if (*pszCommand == 'x')
        {
            fDump |= DUMP_HEX;
        }
        if (*pszCommand == 'a')
        {
            fDump |= 0x80;  // Dump SD
        }
        pszCommand++;
    }

    hRemoteToken = GetExpr(pszCommand);

    if (DuplicateHandle(hProcess,
                        hRemoteToken,
                        GetCurrentProcess(),
                        &hToken,
                        0, FALSE,
                        DUPLICATE_SAME_ACCESS) )
    {
        PrintToken(hToken, lpExt);

        CloseHandle(hToken);
    }
    else
    {
        DebuggerOut("Error %d duplicating token handle\n", GetLastError());
    }
}

void
DumpThreadToken(  HANDLE                  hProcess,
            HANDLE                  hThread,
            DWORD                   dwCurrentPc,
            PNTSD_EXTENSION_APIS    lpExt,
            LPSTR                   pszCommand)
{
    DWORD   fDump = 0;
    HANDLE  hToken;
    HANDLE  hRemoteToken = NULL;
    PVOID   pad;
    NTSTATUS Status;

#define DUMP_HEX    1

    InitDebugHelp(hProcess, hThread, lpExt);

    while (*pszCommand == '-')
    {
        pszCommand++;
        if (*pszCommand == 'x')
        {
            fDump |= DUMP_HEX;
        }
        if (*pszCommand == 'a')
        {
            fDump |= 0x80;  // Dump SD
        }
        pszCommand++;
    }

    Status = NtOpenThreadToken(hThread, TOKEN_QUERY, FALSE, &hRemoteToken);

    if ((Status == STATUS_NO_TOKEN) || (hRemoteToken == NULL))
    {
        DebuggerOut("Thread is not impersonating.  Using process token.\n");

        Status = NtOpenProcessToken(hProcess, TOKEN_QUERY, &hRemoteToken);

    }

    hToken = hRemoteToken;

    if (NT_SUCCESS(Status))
    {
        PrintToken(hToken, lpExt);

        CloseHandle(hToken);
    }
    else
    {
        DebuggerOut("Error %#x getting thread token\n", Status);
    }
}




#define SATYPE_USER     1
#define SATYPE_GROUP    2
#define SATYPE_PRIV     3

void
LocalDumpSid(PSID    pxSid)
{
    PISID   pSid = (PISID) pxSid;
    UNICODE_STRING  ucsSid;
#if 0
    if (fHex)
    {

        DebuggerOut("  S-%d-0x", pSid->Revision);
        for (i = 0;i < 6 ; i++ )
        {
            if (j)
            {
                DebuggerOut("%x", pSid->IdentifierAuthority.Value[i]);
            }
            else
            {
                if (pSid->IdentifierAuthority.Value[i])
                {
                    j = 1;
                    DebuggerOut("%x", pSid->IdentifierAuthority.Value[i]);
                }
            }
            if (i==4)
            {
                j = 1;
            }
        }
        for (i = 0; i < pSid->SubAuthorityCount ; i++ )
        {
            DebuggerOut("-0x%x", pSid->SubAuthority[i]);
        }
    }
    else
#endif // 0
    {
        RtlConvertSidToUnicodeString(&ucsSid, pxSid, TRUE);
        DebuggerOut("  %wZ", &ucsSid);
        RtlFreeUnicodeString(&ucsSid);
    }
}

void
DumpSidAttr(PSID_AND_ATTRIBUTES pSA,
            int                 SAType)
{
    LocalDumpSid(pSA->Sid);

    if (SAType == SATYPE_GROUP)
    {
        DebuggerOut("\tAttributes - ");
        if (pSA->Attributes & SE_GROUP_MANDATORY)
        {
            DebuggerOut("Mandatory ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED_BY_DEFAULT)
        {
            DebuggerOut("Default ");
        }
        if (pSA->Attributes & SE_GROUP_ENABLED)
        {
            DebuggerOut("Enabled ");
        }
        if (pSA->Attributes & SE_GROUP_OWNER)
        {
            DebuggerOut("Owner ");
        }
        if (pSA->Attributes & SE_GROUP_LOGON_ID)
        {
            DebuggerOut("LogonId ");
        }
    }

}

WCHAR *  GetPrivName(PLUID   pPriv)
{
    switch (pPriv->LowPart)
    {
        case SE_CREATE_TOKEN_PRIVILEGE:
            return(SE_CREATE_TOKEN_NAME);
        case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
            return(SE_ASSIGNPRIMARYTOKEN_NAME);
        case SE_LOCK_MEMORY_PRIVILEGE:
            return(SE_LOCK_MEMORY_NAME);
        case SE_INCREASE_QUOTA_PRIVILEGE:
            return(SE_INCREASE_QUOTA_NAME);
        case SE_UNSOLICITED_INPUT_PRIVILEGE:
            return(SE_UNSOLICITED_INPUT_NAME);
        case SE_TCB_PRIVILEGE:
            return(SE_TCB_NAME);
        case SE_SECURITY_PRIVILEGE:
            return(SE_SECURITY_NAME);
        case SE_TAKE_OWNERSHIP_PRIVILEGE:
            return(SE_TAKE_OWNERSHIP_NAME);
        case SE_LOAD_DRIVER_PRIVILEGE:
            return(SE_LOAD_DRIVER_NAME);
        case SE_SYSTEM_PROFILE_PRIVILEGE:
            return(SE_SYSTEM_PROFILE_NAME);
        case SE_SYSTEMTIME_PRIVILEGE:
            return(SE_SYSTEMTIME_NAME);
        case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
            return(SE_PROF_SINGLE_PROCESS_NAME);
        case SE_INC_BASE_PRIORITY_PRIVILEGE:
            return(SE_INC_BASE_PRIORITY_NAME);
        case SE_CREATE_PAGEFILE_PRIVILEGE:
            return(SE_CREATE_PAGEFILE_NAME);
        case SE_CREATE_PERMANENT_PRIVILEGE:
            return(SE_CREATE_PERMANENT_NAME);
        case SE_BACKUP_PRIVILEGE:
            return(SE_BACKUP_NAME);
        case SE_RESTORE_PRIVILEGE:
            return(SE_RESTORE_NAME);
        case SE_SHUTDOWN_PRIVILEGE:
            return(SE_SHUTDOWN_NAME);
        case SE_DEBUG_PRIVILEGE:
            return(SE_DEBUG_NAME);
        case SE_AUDIT_PRIVILEGE:
            return(SE_AUDIT_NAME);
        case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
            return(SE_SYSTEM_ENVIRONMENT_NAME);
        case SE_CHANGE_NOTIFY_PRIVILEGE:
            return(SE_CHANGE_NOTIFY_NAME);
        case SE_REMOTE_SHUTDOWN_PRIVILEGE:
            return(SE_REMOTE_SHUTDOWN_NAME);
        case SE_UNDOCK_PRIVILEGE:
            return(SE_UNDOCK_NAME);
        case SE_SYNC_AGENT_PRIVILEGE:
            return(SE_SYNC_AGENT_NAME);
        case SE_ENABLE_DELEGATION_PRIVILEGE:
            return(SE_ENABLE_DELEGATION_NAME);
        default:
            return(L"Unknown Privilege");
    }
}

void
DumpLuidAttr(PLUID_AND_ATTRIBUTES   pLA,
             int                    LAType)
{

    DebuggerOut("0x%x%08x", pLA->Luid.HighPart, pLA->Luid.LowPart);
    DebuggerOut(" %-32ws", GetPrivName(&pLA->Luid));

    if (LAType == SATYPE_PRIV)
    {
        DebuggerOut("  Attributes - ");
        if (pLA->Attributes & SE_PRIVILEGE_ENABLED)
        {
            DebuggerOut("Enabled ");
        }

        if (pLA->Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT)
        {
            DebuggerOut("Default ");
        }
    }

}

void
PrintToken(HANDLE    hToken,
            PNTSD_EXTENSION_APIS    lpExt)
{
    PTOKEN_USER         pTUser;
    PTOKEN_GROUPS       pTGroups;
    PTOKEN_PRIVILEGES   pTPrivs;
    PTOKEN_PRIMARY_GROUP    pTPrimaryGroup;
    TOKEN_STATISTICS    TStats;
    ULONG               cbRetInfo;
    NTSTATUS            status;
    DWORD               i;
    DWORD               dwSessionId;

    pTUser = (PTOKEN_USER) alloca (256);
    pTGroups = (PTOKEN_GROUPS) alloca (4096);
    pTPrivs = (PTOKEN_PRIVILEGES) alloca (1024);
    pTPrimaryGroup  = (PTOKEN_PRIMARY_GROUP) alloca (128);

    if ( pTUser == NULL ||
         pTGroups == NULL ||
         pTPrivs == NULL ||
         pTPrimaryGroup == NULL ) {

        DebuggerOut( "Failed to allocate memory\n" );
        return;
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenSessionId,
                                        &dwSessionId,
                                        sizeof(dwSessionId),
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        DebuggerOut("Failed to query token:  %#x\n", status);
        return;
    }
    DebuggerOut("TS Session ID: %x\n", dwSessionId);

    status = NtQueryInformationToken(   hToken,
                                        TokenUser,
                                        pTUser,
                                        256,
                                        &cbRetInfo);

    if (!NT_SUCCESS(status))
    {
        DebuggerOut("Failed to query token:  %#x\n", status);
        return;
    }

    DebuggerOut("User\n  ");
    DumpSidAttr(&pTUser->User, SATYPE_USER);

    DebuggerOut("\nGroups");
    status = NtQueryInformationToken(   hToken,
                                        TokenGroups,
                                        pTGroups,
                                        4096,
                                        &cbRetInfo);

    for (i = 0; i < pTGroups->GroupCount ; i++ )
    {
        DebuggerOut("\n %02d ", i);
        DumpSidAttr(&pTGroups->Groups[i], SATYPE_GROUP);
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenPrimaryGroup,
                                        pTPrimaryGroup,
                                        128,
                                        &cbRetInfo);

    DebuggerOut("\nPrimary Group:\n  ");
    LocalDumpSid(pTPrimaryGroup->PrimaryGroup);

    DebuggerOut("\nPrivs\n");
    status = NtQueryInformationToken(   hToken,
                                        TokenPrivileges,
                                        pTPrivs,
                                        1024,
                                        &cbRetInfo);
    if (!NT_SUCCESS(status))
    {
        printf("NtQueryInformationToken returned %#x\n", status);
        return;
    }
    for (i = 0; i < pTPrivs->PrivilegeCount ; i++ )
    {
        DebuggerOut("\n %02d ", i);
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }

    status = NtQueryInformationToken(   hToken,
                                        TokenStatistics,
                                        &TStats,
                                        sizeof(TStats),
                                        &cbRetInfo);

    DebuggerOut("\n\nAuth ID  %x:%x\n", TStats.AuthenticationId.HighPart, TStats.AuthenticationId.LowPart);
    DebuggerOut("Impersonation Level:  %s\n", ImpLevel(TStats.ImpersonationLevel));
    DebuggerOut("TokenType  %s\n", TStats.TokenType == TokenPrimary ? "Primary" : "Impersonation");
}

VOID
ElapsedTimeToString(
    PLARGE_INTEGER Time,
    CHAR * String
    )
{
    TIME_FIELDS     ElapsedTime ;


    RtlTimeToElapsedTimeFields( Time, &ElapsedTime );

    if ( ElapsedTime.Hour )
    {
        sprintf( String, "%d:%02d:%02d.%03d",
                 ElapsedTime.Hour,
                 ElapsedTime.Minute,
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds );
    }
    else if ( ElapsedTime.Minute )
    {
        sprintf( String, "%02d:%02d.%03d",
                 ElapsedTime.Minute,
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds );
    }
    else if ( ElapsedTime.Second )
    {
        sprintf( String, "%02.%03d",
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds );
    }
    else if ( ElapsedTime.Milliseconds )
    {
        sprintf( String, "0.%03d",
                 ElapsedTime.Milliseconds );
    }
    else
    {
        strcpy( String, "0" );
    }

}

void
DumpLpc(        HANDLE                  hProcess,
                HANDLE                  hThread,
                DWORD                   dwCurrentPc,
                PNTSD_EXTENSION_APIS    lpExt,
                LPSTR                   pszCommand)
{

    PVOID           pRemote;
    DWORD           i;
    PLSAP_API_LOG   pLog ;
    LSAP_API_LOG    LocalLog ;
    ULONG           Size ;
    FILETIME        LocalTime ;
    PLSAP_API_LOG_ENTRY Entry ;
    PVOID           Table ;
    CHAR            timebuf[ 128 ];
    CHAR            timebuf2[ 64 ];

    InitDebugHelp(hProcess, hThread, lpExt);

    if ( _stricmp( pszCommand, "internal" ) == 0 )
    {
        pRemote = GetExpr( INTERNAL_APILOG );
    }
    else
    {
        pRemote = GetExpr( LPC_APILOG );

    }

    LsaReadMemory( pRemote, sizeof( PVOID ), &Table );

    LsaReadMemory( Table, sizeof( LocalLog ), &LocalLog );

    Size = (LocalLog.TotalSize - 1) * sizeof( LSAP_API_LOG_ENTRY ) +
            sizeof( LSAP_API_LOG ) ;

    pLog = (PLSAP_API_LOG) LocalAlloc( LMEM_FIXED, Size );

    if ( !pLog )
    {
        DebuggerOut( "no memory\n" );
        return;
    }

    LsaReadMemory( Table, Size, pLog );


    DebuggerOut("MessageId\tStatus and Time\n");
    for (i = 0; i < pLog->TotalSize ; i++ )
    {
        Entry = &pLog->Entries[ i ];
        DebuggerOut("%08x%c\t", Entry->MessageId,
                        ( i == pLog->Current ? '*' : ' ') );

        if (Entry->ThreadId == 0)
        {
            CTimeStamp( (PTimeStamp) &Entry->QueueTime, timebuf, TRUE );
            DebuggerOut("Queued, Message @%p, Task @%p (%s)\n",
                            Entry->pvMessage,
                            Entry->WorkItem,
                            timebuf );

        }
        else if (Entry->ThreadId == 0xFFFFFFFF)
        {
            // CTimeStamp( (PTimeStamp) &Entry->QueueTime, timebuf, TRUE );
            timebuf[0] = '\0';

            ElapsedTimeToString( &Entry->WorkTime, timebuf2 );

            DebuggerOut("Completed, (%s, status %x), %s [%s]\n",
                            ApiLabel( (UINT_PTR) Entry->pvMessage ),
                            Entry->WorkItem,
                            timebuf,
                            timebuf2 );
        }
        else
        {
            CTimeStamp( (PTimeStamp) &Entry->WorkTime, timebuf, TRUE );
            DebuggerOut("Active, thread %x, Message @%p, %s\n",
                            Entry->ThreadId,
                            Entry->pvMessage,
                            timebuf );
        }

    }


}


VOID
ShowSecBuffer(
    PSTR    Banner,
    PSecBuffer  Buffer)
{
    DWORD   Mask;

    Mask = Buffer->BufferType & SECBUFFER_ATTRMASK ;

    DebuggerOut("%s\t", Banner);
    DebuggerOut("%s%s%s %d bytes, %p\n",
                    Mask & SECBUFFER_READONLY ? "[RO]" : "",
                    Mask & SECBUFFER_UNMAPPED ? "[!Map]" : "",
                    SecBufferType( Buffer->BufferType ),
                    Buffer->cbBuffer,
                    Buffer->pvBuffer );
}

VOID
ShowLpcMessage(
    PVOID pvMessage,
    PSPM_LPC_MESSAGE pMessage)
{
    SPMInitContextAPI * pInit;
    SPMAcceptContextAPI * pAccept;
    SPMDeleteContextAPI * pDelete ;
    SPMFreeCredHandleAPI * pFreeCred ;
    SPMAcquireCredsAPI * pAcquire;
    SPMCallbackAPI * pCallback ;
    SPMAddCredentialAPI * pAddCred ;
    SPMQueryCredAttributesAPI * pQueryCred ;
    SPMEfsGenerateKeyAPI * pGenKey ;
    SPMEfsGenerateDirEfsAPI * pGenDir ;
    SPMEfsDecryptFekAPI * pDecryptFek ;
    SPMGetBindingAPI * pGetBinding ;
    DWORD           i;
    UCHAR       Flags[ 80 ];

    DebuggerOut("SPM_LPC_MESSAGE at %p\n", pvMessage);
    DebuggerOut("  Message id   \t%x\n", pMessage->pmMessage.MessageId);
    DebuggerOut("  From         \t%x.%x\n", pMessage->pmMessage.ClientId.UniqueProcess,pMessage->pmMessage.ClientId.UniqueThread);
    DebuggerOut("  API Number   \t%d\n", pMessage->ApiMessage.dwAPI);
    DebuggerOut("  Result       \t%#x\n",pMessage->ApiMessage.scRet);
    DebuggerOut("  LSA Args     \t%p\n", (PUCHAR) pvMessage + (DWORD_PTR) ((PUCHAR) &pMessage->ApiMessage.Args) - ((PUCHAR) pMessage));
    DebuggerOut("  SPM Args     \t%p\n", (PUCHAR) pvMessage + (DWORD_PTR) ((PUCHAR) &pMessage->ApiMessage.Args.SpmArguments.API) - ((PUCHAR) pMessage));
    DebuggerOut("  Data         \t%p\n", (PUCHAR) pvMessage + (DWORD_PTR) (&pMessage->ApiMessage.bData[0]) - ((PUCHAR) pMessage));
    if ( pMessage->ApiMessage.dwAPI > LsapAuMaxApiNumber)
    {
        Flags[0] = '\0';

        DisplayFlags( pMessage->ApiMessage.Args.SpmArguments.fAPI,
                      12,
                      APIFlags,
                      Flags );

        DebuggerOut("  Flags        \t%x: %s\n",
                    pMessage->ApiMessage.Args.SpmArguments.fAPI,
                    Flags );
        DebuggerOut("  Context      \t%p\n",
                    pMessage->ApiMessage.Args.SpmArguments.ContextPointer );
    }

    switch (pMessage->ApiMessage.dwAPI)
    {
        case LsapAuLookupPackageApi:
            DebuggerOut("  LsapAuLookupPackageApi\n");
            DebuggerOut("   (o) Number  \t%d\n",pMessage->ApiMessage.Args.LsaArguments.LookupPackage.AuthenticationPackage);
            DebuggerOut("   (i) Length  \t%d\n",pMessage->ApiMessage.Args.LsaArguments.LookupPackage.PackageNameLength);
            DebuggerOut("   (i) Name    \t%s\n",pMessage->ApiMessage.Args.LsaArguments.LookupPackage.PackageName);
            break;

        case LsapAuLogonUserApi:
            DebuggerOut("  LsapAuLogonUserApi\n");
            DebuggerOut("   (i) Origin  \t{%d,%d,%p}\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.OriginName.Length,
                                                        pMessage->ApiMessage.Args.LsaArguments.LogonUser.OriginName.MaximumLength,
                                                        pMessage->ApiMessage.Args.LsaArguments.LogonUser.OriginName.Buffer);
            DebuggerOut("   (i) LogonTyp\t%d\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.LogonType);
            DebuggerOut("   (i) Package \t%d\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.AuthenticationPackage);
            DebuggerOut("   (i) AuthInfo\t%p\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.AuthenticationInformation);
            DebuggerOut("   (i) AuthInfo\t%d\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.AuthenticationInformationLength);
            DebuggerOut("   (i) GroupCou\t%d\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.LocalGroupsCount);
            DebuggerOut("   (i) Groups  \t%p\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.LocalGroups);
            DebuggerOut("   (i) Source  \t%s\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.SourceContext.SourceName);
            DebuggerOut("   (o) SubStat \t%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.SubStatus);
            DebuggerOut("   (o) Profile \t%p\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.ProfileBuffer);
            DebuggerOut("   (o) ProfLen \t%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.ProfileBufferLength);
            DebuggerOut("   (o) LogonId \t%x:%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.LogonId.HighPart,pMessage->ApiMessage.Args.LsaArguments.LogonUser.LogonId.LowPart);
            DebuggerOut("   (o) Token   \t%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.Token);
            DebuggerOut("   (o) Quota   \t%x\n",pMessage->ApiMessage.Args.LsaArguments.LogonUser.Quotas.PagedPoolLimit);
            break;

        case LsapAuCallPackageApi:
            DebuggerOut("   LsapCallPackageApi\n");
            DebuggerOut("    (i) Package\t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.AuthenticationPackage);
            DebuggerOut("    (i) Buffer \t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.ProtocolSubmitBuffer);
            DebuggerOut("    (i) Length \t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.SubmitBufferLength);
            DebuggerOut("    (o) Status \t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.ProtocolStatus);
            DebuggerOut("    (o) RBuffer\t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.ProtocolReturnBuffer);
            DebuggerOut("    (o) Length \t%d\n",pMessage->ApiMessage.Args.LsaArguments.CallPackage.ReturnBufferLength);
            break;

        case LsapAuDeregisterLogonProcessApi:
            DebuggerOut("   LsapAuDeregisterLogonProcessApi\n");
            break;

        case SPMAPI_GetBinding:
            DebuggerOut("   GetBinding\n");
            pGetBinding = &pMessage->ApiMessage.Args.SpmArguments.API.GetBinding ;
            DebuggerOut("    (i) ulPackageId    \t%p\n", pGetBinding->ulPackageId) ;

            break;

        case SPMAPI_InitContext:
            DebuggerOut("   InitContext\n");
            pInit = &pMessage->ApiMessage.Args.SpmArguments.API.InitContext;
            DebuggerOut("    (i) hCredentials   \t%p:%p\n", pInit->hCredential.dwUpper, pInit->hCredential.dwLower);
            DebuggerOut("    (i) hContext       \t%p:%p\n", pInit->hContext.dwUpper, pInit->hContext.dwLower);
            DebuggerOut("    (i) ssTarget       \t%p\n", pInit->ssTarget.Buffer);
            DebuggerOut("    (i) fContextReq    \t%x\n", pInit->fContextReq);
            DebuggerOut("    (i) Reserved1      \t%x\n", pInit->dwReserved1);
            DebuggerOut("    (i) TargetDataRep  \t%x\n", pInit->TargetDataRep);
            DebuggerOut("    (i) sbdInput       \t%d : %p\n", pInit->sbdInput.cBuffers, pInit->sbdInput.pBuffers );
            DebuggerOut("    (i) Reserved2      \t%x\n", pInit->dwReserved2);
            DebuggerOut("    (o) hNewContext    \t%p:%p\n", pInit->hNewContext.dwUpper, pInit->hNewContext.dwLower );
            DebuggerOut("    (b) sbdOutput      \t%d : %p\n", pInit->sbdOutput.cBuffers, pInit->sbdOutput.pBuffers );
            DebuggerOut("    (o) fContextAttr   \t%x\n", pInit->fContextAttr );
            DebuggerOut("    (o) tsExpiry       \t%s\n","");
            DebuggerOut("    (o) MappedContext  \t%x\n", pInit->MappedContext );
            ShowSecBuffer("    (o) ContextData  \t", &pInit->ContextData );
            for ( i = 0 ; i < pInit->sbdInput.cBuffers ; i++ )
            {
                ShowSecBuffer("     (i) InputBuffer\t", &pInit->sbData[i]);
            }
            for ( i = 0; i < pInit->sbdOutput.cBuffers ; i++ )
            {
                ShowSecBuffer("     (b) OutputBuffer\t", &pInit->sbData[i + pInit->sbdInput.cBuffers]);
            }

            break;

        case SPMAPI_AcceptContext:
            DebuggerOut("   AcceptContext\n");
            pAccept = &pMessage->ApiMessage.Args.SpmArguments.API.AcceptContext;
            DebuggerOut("    (i) hCredentials   \t%p : %p\n", pAccept->hCredential.dwUpper, pAccept->hCredential.dwLower );
            DebuggerOut("    (i) hContext       \t%p : %p\n", pAccept->hContext.dwUpper, pAccept->hContext.dwLower );
            DebuggerOut("    (i) sbdInput       \t%d : %p\n", pAccept->sbdInput.cBuffers, pAccept->sbdInput.pBuffers );
            DebuggerOut("    (i) fContextReq    \t%x\n", pAccept->fContextReq );
            DebuggerOut("    (i) TargetDataRep  \t%x\n", pAccept->TargetDataRep );
            DebuggerOut("    (o) hNewContext    \t%p : %p\n", pAccept->hNewContext.dwUpper, pAccept->hNewContext.dwLower );
            DebuggerOut("    (b) sbdOutput      \t%d : %p\n", pAccept->sbdOutput.cBuffers, pAccept->sbdOutput.pBuffers );
            DebuggerOut("    (o) fContextAttr   \t%x \n", pAccept->fContextAttr );
            DebuggerOut("    (o) MappedContext  \t%x\n", pAccept->MappedContext );
            ShowSecBuffer("    (o) ContextData  \t", &pAccept->ContextData );
            for ( i = 0 ; i < pAccept->sbdInput.cBuffers ; i++ )
            {
                ShowSecBuffer("     (i) InputBuffer\t", &pAccept->sbData[i]);
            }
            for ( i = 0; i < pAccept->sbdOutput.cBuffers ; i++ )
            {
                ShowSecBuffer("     (b) OutputBuffer\t", &pAccept->sbData[i + pAccept->sbdInput.cBuffers]);
            }
            break;

        case SPMAPI_FindPackage:
            DebuggerOut("  FindPackage\n");
            break;

        case SPMAPI_EnumPackages:
            DebuggerOut("  EnumPackages\n");
            break;

        case SPMAPI_AcquireCreds:
            DebuggerOut("   AcquireCreds\n");
            pAcquire = &pMessage->ApiMessage.Args.SpmArguments.API.AcquireCreds ;
            DebuggerOut("    (i) fCredentialUse \t%x\n", pAcquire->fCredentialUse );
            DebuggerOut("    (i) LogonId        \t%x : %x\n", pAcquire->LogonID.LowPart, pAcquire->LogonID.HighPart );
            DebuggerOut("    (i) pvAuthData     \t%p\n", pAcquire->pvAuthData );
            DebuggerOut("    (i) pvGetKeyFn     \t%p\n", pAcquire->pvGetKeyFn );
            DebuggerOut("    (i) ulGetKeyArgs   \t%p\n", pAcquire->ulGetKeyArgument );
            DebuggerOut("    (o) hCredentials   \t%p : %p\n", pAcquire->hCredential.dwUpper, pAcquire->hCredential.dwLower );
            break;

        case SPMAPI_EstablishCreds:
            DebuggerOut("  EstablishCreds\n");
            break;

        case SPMAPI_FreeCredHandle:
            DebuggerOut("  FreeCredHandle\n");
            pFreeCred = &pMessage->ApiMessage.Args.SpmArguments.API.FreeCredHandle ;
            DebuggerOut("    (i) hCredential    \t%p : %p\n", pFreeCred->hCredential.dwUpper, pFreeCred->hCredential.dwLower );
            break;

        case SPMAPI_ApplyToken:
            DebuggerOut("  ApplyToken\n");
            break;

        case SPMAPI_DeleteContext:
            DebuggerOut("  DeleteContext\n");
            pDelete = &pMessage->ApiMessage.Args.SpmArguments.API.DeleteContext ;
            DebuggerOut("    (i) hContext       \t%p : %p\n", pDelete->hContext.dwUpper, pDelete->hContext.dwLower );
            break;

        case SPMAPI_QueryPackage:
            DebuggerOut("  QueryPackage\n");
            break;

        case SPMAPI_GetUserInfo:
            DebuggerOut("  GetUserInfo\n");
            break;

        case SPMAPI_GetCreds:
            DebuggerOut("  GetCreds\n");
            break;

        case SPMAPI_SaveCreds:
            DebuggerOut("  SaveCreds\n");
            break;

        case SPMAPI_DeleteCreds:
            DebuggerOut("  DeleteCreds\n");
            break;

        case SPMAPI_QueryCredAttributes:
            DebuggerOut("  QueryCredAttributes\n");
            pQueryCred = &pMessage->ApiMessage.Args.SpmArguments.API.QueryCredAttributes ;
            DebuggerOut("    (i) hCredentials   \t%p : %p\n", pQueryCred->hCredentials.dwUpper, pQueryCred->hCredentials.dwLower );
            DebuggerOut("    (i) ulAttribute    \t%d\n", pQueryCred->ulAttribute );
            DebuggerOut("    (i) pBuffer        \t%p\n", pQueryCred->pBuffer );
            DebuggerOut("    (o) Allocs         \t%d\n", pQueryCred->Allocs );
            for ( i = 0 ; i < pQueryCred->Allocs ; i++ )
            {
                DebuggerOut("    (o) Buffers[%d]    \t  %p\n", pQueryCred->Buffers[ i ] );
            }
            break;

        case SPMAPI_AddPackage:
            DebuggerOut("  AddPackage\n");
            break;

        case SPMAPI_DeletePackage:
            DebuggerOut("  DeletePackage\n");
            break;

        case SPMAPI_EfsGenerateKey:
            DebuggerOut("  EfsGenerateKey\n" );
            pGenKey = &pMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateKey ;
            DebuggerOut("    (i) EfsStream      \t%p\n", pGenKey->EfsStream );
            DebuggerOut("    (i) DirectoryEfsStream\t%p\n", pGenKey->DirectoryEfsStream);
            DebuggerOut("    (i) DirectoryStreamLen\t%#x\n", pGenKey->DirectoryEfsStreamLength );
            DebuggerOut("    (i) Fek            \t%p\n", pGenKey->Fek );
            DebuggerOut("    (o) BufferLength   \t%#x\n", pGenKey->BufferLength );
            DebuggerOut("    (o) BufferBase     \t%p\n", pGenKey->BufferBase );
            break;

        case SPMAPI_EfsGenerateDirEfs:
            DebuggerOut("  EfsGenerateDirEfs\n" );
            pGenDir = &pMessage->ApiMessage.Args.SpmArguments.API.EfsGenerateDirEfs ;
            DebuggerOut("    (i) DirectoryEfsStream\t%p\n", pGenDir->DirectoryEfsStream);
            DebuggerOut("    (i) DirectoryStreamLen\t%#x\n", pGenDir->DirectoryEfsStreamLength );
            DebuggerOut("    (i) EfsStream      \t%p\n", pGenDir->EfsStream );
            DebuggerOut("    (o) BufferBase     \t%p\n", pGenDir->BufferBase );
            DebuggerOut("    (o) BufferLength   \t%#x\n", pGenDir->BufferLength );
            break;

        case SPMAPI_EfsDecryptFek:
            DebuggerOut("  EfsDecryptFek\n" );
            pDecryptFek = &pMessage->ApiMessage.Args.SpmArguments.API.EfsDecryptFek ;
            DebuggerOut("    (i) Fek            \t%p\n", pDecryptFek->Fek );
            DebuggerOut("    (i) EfsStream      \t%p\n", pDecryptFek->EfsStream );
            DebuggerOut("    (i) EfsStreamLength\t%p\n", pDecryptFek->EfsStreamLength );
            DebuggerOut("    (i) OpenType       \t%#x\n", pDecryptFek->OpenType );
            DebuggerOut("    (?) NewEfs         \t%p\n", pDecryptFek->NewEfs );
            DebuggerOut("    (o) BufferBase     \t%p\n", pDecryptFek->BufferBase );
            DebuggerOut("    (o) BufferLength   \t%#x\n", pDecryptFek->BufferLength );
            break;

        case SPMAPI_EfsGenerateSessionKey:
            DebuggerOut("  EfsGenerateSessionKey\n" );
            break;

        case SPMAPI_Callback:
            DebuggerOut("  Callback\n" );
            pCallback = &pMessage->ApiMessage.Args.SpmArguments.API.Callback ;
            DebuggerOut("    (i) Type       \t%x\n", pCallback->Type );
            DebuggerOut("    (i) CallbackFunction\t%p\n", pCallback->CallbackFunction );
            DebuggerOut("    (i) Argument1  \t%p\n", pCallback->Argument1 );
            DebuggerOut("    (i) Argument2  \t%p\n", pCallback->Argument2 );
            ShowSecBuffer("    (i) Input      \t", &pCallback->Input );
            ShowSecBuffer("    (o) Output     \t", &pCallback->Output );

            break;

        case SPMAPI_QueryContextAttr:
            DebuggerOut("  QueryContextAttributes\n" );
            break;

        case SPMAPI_LsaPolicyChangeNotify:
            DebuggerOut("  LsaPolicyChangeNotify\n" );
            break;

        case SPMAPI_GetUserNameX:
            DebuggerOut("  GetUserName\n" );
            break;

        case SPMAPI_AddCredential:
            DebuggerOut("  AddCredential\n" );
            pAddCred = &pMessage->ApiMessage.Args.SpmArguments.API.AddCredential ;
            DebuggerOut("    (i) hCredentials   \t%p : %p\n",
                                    pAddCred->hCredentials.dwUpper, pAddCred->hCredentials.dwLower );
            DebuggerOut("    (i) fCredentialUse \t%x\n", pAddCred->fCredentialUse );
            DebuggerOut("    (i) LogonId        \t%x : %x\n", pAddCred->LogonID.LowPart, pAddCred->LogonID.HighPart );
            DebuggerOut("    (i) pvAuthData     \t%p\n", pAddCred->pvAuthData );
            DebuggerOut("    (i) pvGetKeyFn     \t%p\n", pAddCred->pvGetKeyFn );
            DebuggerOut("    (i) ulGetKeyArgs   \t%p\n", pAddCred->ulGetKeyArgument );
            break;

        case SPMAPI_EnumLogonSession:
            DebuggerOut("  EnumLogonSession\n" );
            break;

        case SPMAPI_GetLogonSessionData:
            DebuggerOut("  GetLogonSessionData\n" );
            break;

        case SPMAPI_SetContextAttr:
            DebuggerOut("  SetContextAttr\n" );
            break;

        case SPMAPI_LookupAccountSidX:
            DebuggerOut("  LookupAccountSid\n");
            break;

        case SPMAPI_LookupAccountNameX:
            DebuggerOut("  LookupAccountName\n");
            break;

        default:
            DebuggerOut("No message parsing for this message\n");
            break;
    }
}

void
DumpLpcMessage( HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    SPM_LPC_MESSAGE Message;
    PVOID           pvMessage;

    InitDebugHelp(hProcess, hThread, lpExt);

    pvMessage = GetExpr(pszCommand);

    if (!pvMessage)
    {
        DebuggerOut("no message\n");
        return;
    }

    LsaReadMemory(pvMessage, sizeof(SPM_LPC_MESSAGE), &Message);

    ShowLpcMessage( pvMessage, &Message );

}


void
DumpThreadLpc(
        HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    SPM_LPC_MESSAGE Message;
    PVOID           pvMessage;
    NTSTATUS    Status;
    LSA_CALL_INFO CallInfo ;


    InitDebugHelp(hProcess, hThread, lpExt);

    Status = ReadCallInfo( &CallInfo );

    if (Status != 0)
    {
        return;
    }

    if ( CallInfo.Message )
    {
        Status = LsaReadMemory(CallInfo.Message, sizeof(SPM_LPC_MESSAGE), &Message);

        ShowLpcMessage(CallInfo.Message, &Message);

    }
    else
    {
        DebuggerOut("TLS entry was NULL!\n");

    }
}

extern"C"
void
GetTls( HANDLE           hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    TEB *   Teb;
    DWORD   Index;

    InitDebugHelp(hProcess, hThread, lpExt);

    Index = (DWORD)((ULONG_PTR)GetExpr(pszCommand));

    Teb = GetTeb(hThread);
    if (!Teb)
    {
        DebuggerOut("Could not read TEB\n");
    }
    else
    {
        DebuggerOut("TLS %#x is %p\n", Index, Teb->TlsSlots[Index]);

        FreeHeap(Teb);
    }

}

PVOID
ShowTask(
    PVOID       pTask)
{
    LSAP_THREAD_TASK  Task;
    UCHAR           Symbol[256];
    ULONG_PTR       Disp;

    if (pTask)
    {
        LsaReadMemory(pTask, sizeof(LSAP_THREAD_TASK), &Task);
    }
    else
    {
        return (NULL);
    }

    DebuggerOut("Task at %p:\n", pTask);
    LsaGetSymbol((ULONG_PTR)Task.pFunction, Symbol, &Disp);
    DebuggerOut("  Function     \t%s\n", Symbol);
    DebuggerOut("  Parameter    \t%p\n", Task.pvParameter);
    DebuggerOut("  Session      \t%p\n", Task.pSession);

    return(Task.Next.Flink);
}

void
DumpQueue( HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    LSAP_TASK_QUEUE       Queue;
    PVOID           pTask;
    PVOID           pQueue;
    BOOL            Single = FALSE;
    UCHAR           Symbol[ MAX_PATH ];
    ULONG_PTR       Offset;

    InitDebugHelp(hProcess, hThread, lpExt);

    pQueue = GetExpr(pszCommand);

    if (!pQueue)
    {
        pQueue = (PVOID) GetExpr(GLOBALQUEUE);
    }

    LsaReadMemory(pQueue, sizeof(Queue), &Queue);

    DebuggerOut("Queue at %p\n", pQueue);
    DebuggerOut("  Type     \t%d : %s\n", Queue.Type, QueueTypeName( Queue.Type ) );
    DebuggerOut("  Semaphore\t%d\n", Queue.hSemaphore);
    DebuggerOut("  Tasks    \t%d\n", Queue.Tasks);
    DebuggerOut("  pTasks   \t%p %p\n", Queue.pTasks.Flink,
                                        Queue.pTasks.Blink);
    DebuggerOut("  pNext    \t%p\n", Queue.pNext);
    DebuggerOut("  pShared  \t%p\n", Queue.pShared);
    DebuggerOut("  TotalThd \t%d\n", Queue.TotalThreads);
    DebuggerOut("  IdleThd  \t%d\n", Queue.IdleThreads);
    if ( Queue.OwnerSession )
    {
    DebuggerOut("  Session  \t%p\n", Queue.OwnerSession );
    }
    LsaGetSymbol((ULONG_PTR) Queue.pOriginal, Symbol, &Offset );
    if ( Offset )
    {
        DebuggerOut("  Parent   \t%p\n", Queue.pOriginal );
    }
    else
    {
        DebuggerOut("  Parent   \t%s\n", Symbol );
    }
    DebuggerOut("  Tasks Queued\t%d\n", Queue.QueuedCounter);
    DebuggerOut("  Tasks Read\t%d\n", Queue.TaskCounter);
    DebuggerOut("  Tasks Missed\t%d\n", Queue.MissedTasks );
    DebuggerOut("  Tasks High Water\t%d\n", Queue.TaskHighWater );
    DebuggerOut("  StartSync\t%x\n", Queue.StartSync );
    DebuggerOut("  Req Thread\t%d\n", Queue.ReqThread );
    DebuggerOut("  Max Threads\t%d\n", Queue.MaxThreads );

    pTask = Queue.pTasks.Flink;

    while ((pTask != NULL) && (pTask != (PLSAP_THREAD_TASK) Queue.pTasks.Blink))
    {
        pTask = ShowTask(pTask);

        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }
    }

}

void
DumpThreadTask( HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    LSAP_THREAD_TASK      Task;
    PVOID           pTask;
    BOOL            Single = FALSE;

    InitDebugHelp(hProcess, hThread, lpExt);

    pTask = GetExpr(pszCommand);
    if (!pTask)
    {
        return;
    }
    else
    {
        Single = TRUE;
    }

    do
    {
        pTask = ShowTask( pTask );

        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }

    } while ( pTask && !Single  );



}


VOID
ShowNegCreds(
    PNEG_CREDS  pCreds,
    PVOID       pOriginalAddr)
{
    DWORD   i;
    UCHAR Buffer[ MAX_PATH ];

    DebuggerOut("NEG_CREDS at %p\n", pOriginalAddr );

    DebuggerOut("  List         \t%p %p\n", pCreds->List.Flink, pCreds->List.Blink );
    DebuggerOut("  RefCount     \t%d\n", pCreds->RefCount );
    DebuggerOut("  Process      \t%x\n", pCreds->ClientProcessId );
    DebuggerOut("  LogonId      \t%x %x\n",
                    pCreds->ClientLogonId.HighPart, pCreds->ClientLogonId.LowPart );

    DisplayFlags( pCreds->Flags, 5, NegCredFlags, Buffer );
    DebuggerOut("  Flags        \t%x : %s\n", pCreds->Flags, Buffer );
    if ( pCreds->Flags & NEGCRED_MULTI )
    {
        DebuggerOut("  AdditionalCreds\t%p %p\n",
                        pCreds->AdditionalCreds.Flink, pCreds->AdditionalCreds.Blink );
    }

    DebuggerOut("  Count        \t%d\n", pCreds->Count );
    for ( i = 0 ; i < pCreds->Count ; i++ )
    {
        DebuggerOut("   Creds[%2d]   \tPackage %p, Handle %p : %p \n", i,
            pCreds->Creds[i].Package, pCreds->Creds[i].Handle.dwUpper,
            pCreds->Creds[i].Handle.dwLower );
    }
}

PVOID
ReadAndDumpNegCred(
    PVOID Address
    )
{
#define CRED_SIZE   (sizeof( NEG_CREDS ) + 16 * sizeof( NEG_CRED_HANDLE ) )

    UCHAR   Buffer[ CRED_SIZE ];
    PNEG_CREDS  pCreds ;
    DWORD   Size;



    LsaReadMemory( Address, sizeof( NEG_CREDS ), Buffer );

    pCreds = (PNEG_CREDS) Buffer ;

    Size = sizeof( NEG_CREDS ) + (pCreds->Count - 1) * sizeof( NEG_CRED_HANDLE );


    if ( Size <= CRED_SIZE )
    {
        LsaReadMemory( Address, Size, Buffer );
    }
    else
    {
        LsaReadMemory( Address, CRED_SIZE, Buffer );
        pCreds->Count = 16;
    }

    ShowNegCreds( pCreds, Address );

    return pCreds->List.Flink ;

}

VOID
DumpNegCred(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID Base ;
    PVOID Next ;
    PVOID p ;

    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    if ( p != 0 )
    {
        ReadAndDumpNegCred( p );
    }
    else
    {
        p = GetExpr( "lsasrv!NegCredList" );

        LsaReadMemory( p, sizeof(PVOID), &Next );

        while ( Next != p )
        {
            Next = ReadAndDumpNegCred( Next );

            if (lpExt->lpCheckControlCRoutine())
            {
                break;
            }
        }
    }

}




VOID
ShowNegContext(
    PNEG_CONTEXT    Context,
    PVOID           pOriginalAddr)
{
    UCHAR TimeBuf[ MAX_PATH ];

    if ( ( Context->CheckMark != NEGCONTEXT_CHECK ) &&
         ( Context->CheckMark != NEGCONTEXT2_CHECK ) )
    {
        DebuggerOut("****** Invalid Context Record *******\n");
        return;
    }

    DebuggerOut("NEG_CONTEXT at %p\n", pOriginalAddr);
    DebuggerOut("  Creds        \t%#x\n", Context->Creds );
    DebuggerOut("  CredIndex    \t%d\n", Context->CredIndex );
    DebuggerOut("  Handle       \t%p : %p\n", Context->Handle.dwUpper, Context->Handle.dwLower );
    DebuggerOut("  Target at    \t%p \n", Context->Target.Buffer );
    DebuggerOut("  Attributes   \t%x\n", Context->Attributes );
    ShowSecBuffer("  MappedBuffer ",&Context->MappedBuffer );
    DebuggerOut("  Mapped       \t%s\n", Context->Mapped ? "TRUE" : "FALSE");
    DebuggerOut("  CallCount    \t%d\n", Context->CallCount );
    DebuggerOut("  LastStatus   \t%x\n", Context->LastStatus );
    DebuggerOut("  Check        \t%p\n", Context->Check );
    DebuggerOut("  Buffer       \t%p\n", Context->Buffer );
    CTimeStamp( &Context->Expiry, (PCHAR)TimeBuf, FALSE );
    DebuggerOut("  Expiry       \t%s\n", TimeBuf );
    DisplayFlags( Context->Flags, 7, NegContextFlags, TimeBuf );
    DebuggerOut("  Flags        \t%x : %s\n", Context->Flags, TimeBuf );
    DebuggerOut("  Message      \t%p\n", Context->Message );
    DebuggerOut("  CurrentSize  \t%#x\n", Context->CurrentSize );
    DebuggerOut("  TotalSize    \t%#x\n", Context->TotalSize );
    DebuggerOut("  SupportedMechs\t%p\n", Context->SupportedMechs );
}

VOID
DumpNegContext(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{

    NEG_CONTEXT Context ;
    PVOID   p;


    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    LsaReadMemory( p, sizeof( NEG_CONTEXT ), &Context );

    ShowNegContext( &Context, p );
}


VOID
DumpSecBuffer(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    SecBuffer   Buf;
    PVOID       p;

    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    LsaReadMemory( p, sizeof(SecBuffer), &Buf );

    ShowSecBuffer("Buffer\t", &Buf );

}

VOID
DumpSecBufferDesc(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    SecBuffer   Buf[16];
    SecBufferDesc Desc;
    PVOID       p;
    ULONG   i;

    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    LsaReadMemory( p, sizeof(SecBufferDesc), &Desc );

    LsaReadMemory( Desc.pBuffers, sizeof(SecBuffer) * min(Desc.cBuffers, 16), Buf);

    DebuggerOut("SecBufferDesc at %p\n", p);
    DebuggerOut(" ulVersion     \t%d\n", Desc.ulVersion );
    DebuggerOut(" pBuffers      \t%p\n", Desc.pBuffers );
    DebuggerOut(" cBuffers      \t%x\n", Desc.cBuffers );
    for (i = 0 ; i < min(Desc.cBuffers, 16) ; i++ )
    {
        ShowSecBuffer("  Buffer\t", &Buf[i] );
    }

}

VOID
DumpHandleList(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    SEC_HANDLE_ENTRY List ;
    PVOID       p;
    ULONG   i;

    InitDebugHelp(hProcess, hThread, lpExt);

    p = GetExpr(pszCommand);

    List.List.Flink = (PLIST_ENTRY) p;

    do
    {
        LsaReadMemory( List.List.Flink, sizeof( List ), &List );
        DebuggerOut("  Handle   %p : %p, Ref = %d, Context = %p \n",
                    List.Handle.dwLower,
                    List.Handle.dwUpper,
                    List.RefCount,
                    List.Context );

        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }
    } while ( List.List.Flink != p );
}

VOID
ShowSmallTable(
    PSMALL_HANDLE_TABLE Table,
    LONG   Indent
    )
{
    UCHAR   Buffer[ 64 ];
    UCHAR   IndentString[ 80 ];
    ULONG_PTR i;

    for ( i = 0 ; i < ( DWORD )Indent; i++)
    {
        IndentString[ i ] = ' ';
    }
    IndentString[ Indent ] = '\0' ;

    DisplayFlags( Table->Flags, 3, ShtFlags, Buffer );
    DebuggerOut("%s  Flags  \t%x: %s\n", IndentString, Table->Flags, Buffer );
    DebuggerOut("%s  Count  \t%d\n", IndentString, Table->Count );
    DebuggerOut("%s  Pending\t%p\n", IndentString, Table->PendingHandle );
    DebuggerOut("%s  ListHead\t%p\n", IndentString, Table->List.Flink );

    if ( Table->DeleteCallback )
    {
        LsaGetSymbol((ULONG_PTR) Table->DeleteCallback, Buffer, &i );
        DebuggerOut( "%s  Callback\t%s\n", IndentString, Buffer );
    }

}

VOID
ShowLargeTable(
    int indent,
    PLARGE_HANDLE_TABLE Table
    )
{
    LARGE_HANDLE_TABLE  SubTable ;
    UCHAR Buffer[ 64 ];
    UCHAR Indent[ 64 ];
    ULONG_PTR i;

    for (i = 0 ; i < ( ULONG )indent ; i++ )
    {
        Indent[i] = ' ';
    }
    Indent[indent] = '\0';

    DisplayFlags( Table->Flags, 3, LhtFlags, Buffer );
    DebuggerOut("%s  Flags    \t%x: %s\n", Indent, Table->Flags, Buffer );
    DebuggerOut("%s  Depth    \t%d\n", Indent, Table->Depth );
    DebuggerOut("%s  Parent   \t%p\n", Indent, Table->Parent );
    DebuggerOut("%s  Count    \t%d\n", Indent, Table->Count );
    if ( Table->DeleteCallback )
    {
        LsaGetSymbol((ULONG_PTR) Table->DeleteCallback, Buffer, &i );
        DebuggerOut("%s  Callback \t%s\n", Indent, Buffer );
    }
    DebuggerOut("%s  Lists\n", Indent );
    for ( i = 0 ; i < HANDLE_TABLE_SIZE ; i++ )
    {
        if ( Table->Lists[i].Flags & LHT_SUB_TABLE )
        {
            if ( Table->Lists[i].Flags & (~LHT_SUB_TABLE))
            {
                DebuggerOut("%s    CORRUPT\n", Indent);
            }
            else
            {
                DebuggerOut("%s    %x : Sub Table at %p\n", Indent, i, Table->Lists[i].List.Flink );
                LsaReadMemory( Table->Lists[i].List.Flink,
                            sizeof( LARGE_HANDLE_TABLE),
                            &SubTable );

                ShowLargeTable( 4+indent, &SubTable );

            }

        }
        else
        {
            DebuggerOut("%s    List %x\n", Indent, i );
            ShowSmallTable( &Table->Lists[i], 4+indent );
        }

    }

}


VOID
DumpHandleTable(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    DWORD   Tag;
    LARGE_HANDLE_TABLE  Large ;
    SMALL_HANDLE_TABLE  Small ;
    PVOID   Table ;

    InitDebugHelp(hProcess, hThread, lpExt);

    Table = GetExpr( pszCommand );

    if ( Table == NULL )
    {
        return;
    }

    LsaReadMemory( Table, sizeof(DWORD), &Tag );

    if ( Tag == LHT_TAG )
    {
        DebuggerOut("LARGE_HANDLE_TABLE at %p\n", Table );

        LsaReadMemory( Table, sizeof( Large ), &Large );

        ShowLargeTable( 0, &Large );

    }
    else if ( Tag == SHT_TAG )
    {
        DebuggerOut("SMALL_HANDLE_TABLE at %p\n", Table );

        LsaReadMemory( Table, sizeof( Small ), &Small );

        ShowSmallTable( &Small, 0 );
    }
    else
    {
        DebuggerOut("%p - not a handle table\n", Table );
    }
}


VOID
ShowLogonSession(
    PVOID Base,
    PLSAP_LOGON_SESSION LogonSession,
    BOOL Verbose
    )
{
    SECURITY_STRING LocalString = { 0 };
    PWSTR Temp ;
    SECURITY_STRING LocalCopy = { 0 };
    CHAR Buffer[ 80 ];

    DebuggerOut( "LSAP_LOGON_SESSION at %p\n", Base );

    MapString( &LogonSession->AuthorityName, &LocalString );

    Temp = LocalString.Buffer ;
    LocalString.Buffer = NULL ;

    MapString( &LogonSession->AccountName, &LocalString );

    DebuggerOut( "  LogonId %x:%x (%s)  %ws \\ %ws \n",
            LogonSession->LogonId.HighPart,
            LogonSession->LogonId.LowPart,
            LogonTypeName( LogonSession->LogonType),
            Temp, LocalString.Buffer );

    FreeHeap( Temp );
    FreeHeap( LocalString.Buffer );

    if ( Verbose )
    {
        DebuggerOut( "  Package %d,  caller <%x>, attr = %x\n",
                LogonSession->CreatingPackage,
                LogonSession->Process,
                LogonSession->ContextAttr );

        DebuggerOut( "  SID\t" );
        LocalDumpSid( LogonSession->UserSid );
        CTimeStamp( &LogonSession->LogonTime, Buffer, TRUE );
        DebuggerOut( "  Logon Time\t%s\n", Buffer );


    }

}

VOID
DumpLogonSession(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID p, p1;
    PVOID Actual ;
    PSTR Colon ;
    LSAP_LOGON_SESSION LogonSession ;
    LUID Luid ;
    BOOLEAN DumpAll;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Colon = strchr( pszCommand, ':' );

    if ( Colon )
    {
        if (2 != sscanf( pszCommand, "%x:%x", &Luid.HighPart, &Luid.LowPart ))
        {
            DebuggerOut( "Invalid argument: '%s'\n", pszCommand );
        }

        DumpAll = TRUE ;
        p = NULL ;
    }
    else
    {
        Luid.HighPart = Luid.LowPart = 0 ;
        p = GetExpr( pszCommand );
        DumpAll = FALSE ;
    }

    if ( p == NULL )
    {
        p1 = GetExpr( "lsasrv!logonsessionlist" );
        LsaReadMemory( p1, sizeof( PVOID ), &p );
        DumpAll = TRUE ;
    }
    else
    {
        p1 = NULL ;
    }

    if ( p == NULL )
    {
        DebuggerOut( "Unable to get value of lsasrv!logonsessionlist\n" );
        return;
    }

    while ( p != p1 )
    {
        if ( DumpAll )
        {
            Actual = CONTAINING_RECORD( p, LSAP_LOGON_SESSION, List );
        }
        else
        {
            Actual = p ;
        }

        LsaReadMemory( Actual, sizeof( LSAP_LOGON_SESSION ), &LogonSession );

        if ( RtlIsZeroLuid( &Luid) ||
             RtlEqualLuid( &Luid, &LogonSession.LogonId) ||
             (!DumpAll) )
        {
            ShowLogonSession( Actual, &LogonSession, (!DumpAll) );

        }
        p = LogonSession.List.Flink ;

        if ( (!DumpAll) || ( p1 == NULL ) )
        {
            break;
        }
    }




}


void
ShowLsaHandle(
    IN LSAP_DB_HANDLE DbHandle,
    IN BOOLEAN Index
    )
{
    SECURITY_STRING LocalString;
#ifdef DBG
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    NTSTATUS Status;
#endif


    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Next          \t0x%lp\n", DbHandle->Next );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Previous      \t0x%lp\n", DbHandle->Previous );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "UserHandleList Flink      \t0x%lp\n", DbHandle->UserHandleList.Flink );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "UserHandleList Blink      \t0x%lp\n", DbHandle->UserHandleList.Blink );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Allocated     \t%s\n", DbHandle->Allocated ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "ReferenceCount\t%lu\n", DbHandle->ReferenceCount );
    DebuggerOut( "%c", Index ? '\t' : '\0' );

    LocalString.Buffer = NULL;
    MapString( ( PSECURITY_STRING )( &DbHandle->LogicalNameU ),
                &LocalString );
    DebuggerOut( "LogicalNameU  \t%ws\n", LocalString.Buffer );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    FreeHeap( LocalString.Buffer );

    LocalString.Buffer = NULL;
    MapString( ( PSECURITY_STRING )( &DbHandle->PhysicalNameU ),
                &LocalString );
    DebuggerOut( "PhysicalNameU \t%ws\n", LocalString.Buffer );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    FreeHeap( LocalString.Buffer );

    if ( DbHandle->Sid ) {

        DebuggerOut( "Sid       \t" );
        LocalDumpSid( DbHandle->Sid );
        DebuggerOut( "\n" );
        DebuggerOut( "%c", Index ? '\t' : '\0' );

    } else {

        DebuggerOut( "Sid           \t%s\n", "<NULL>" );
        DebuggerOut( "%c", Index ? '\t' : '\0' );
    }

    DebuggerOut( "KeyHandle     \t0x%lx\n", DbHandle->KeyHandle );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "ObjectTypeId  \t0x%lu\n", DbHandle->ObjectTypeId );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "ContainerHandle\t0x%lp\n", DbHandle->ContainerHandle );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "DesiredAccess \t0x%08lx\n", DbHandle->DesiredAccess );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "GrantedAccess \t0x%08lx\n", DbHandle->GrantedAccess );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "RequestAccess \t0x%08lx\n", DbHandle->RequestedAccess );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "GenerateOnClose\t%s\n",DbHandle->GenerateOnClose ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Trusted       \t%s\n", DbHandle->Trusted ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "DeletedObject \t%s\n", DbHandle->DeletedObject ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "NetworkClient \t%s\n",DbHandle->NetworkClient ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "Options       \t0x%08lx\n", DbHandle->Options);
    DebuggerOut( "%c", Index ? '\t' : '\0' );

    if ( DbHandle->PhysicalNameDs.Length == 0 ) {

        DebuggerOut( "PhysicalNameDs\t%s\n", "<NULL>" );
        DebuggerOut( "%c", Index ? '\t' : '\0' );

    } else {

        LocalString.Buffer = NULL;
        MapString( ( PSECURITY_STRING )( &DbHandle->PhysicalNameDs ),
                    &LocalString );

        DebuggerOut( "PhysicalNameDs\t%ws\n", LocalString.Buffer );
        DebuggerOut( "%c", Index ? '\t' : '\0' );
        FreeHeap( LocalString.Buffer );
    }

    DebuggerOut( "fWriteDs      \t%s\n", DbHandle->fWriteDs ? "TRUE" : "FALSE" );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "ObjectOptions \t0x%08lx\n", DbHandle->ObjectOptions );
    DebuggerOut( "%c", Index ? '\t' : '\0' );
    DebuggerOut( "UserEntry \t0x%lp\n", DbHandle->UserEntry );
#ifdef DBG

    Status = RtlSystemTimeToLocalTime( &DbHandle->HandleCreateTime, &LocalTime );
    if ( !NT_SUCCESS( Status ) ) {

        DebuggerOut( "Can't convert create time from GMT to Local time: 0x%lx\n", Status );

    } else {

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        DebuggerOut( "%c", Index ? '\t' : '\0' );
        DebuggerOut( "HandleCreateTime \t%ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                     TimeFields.Month,
                     TimeFields.Day,
                     TimeFields.Year,
                     TimeFields.Hour,
                     TimeFields.Minute,
                     TimeFields.Second,
                     DbHandle->HandleCreateTime.LowPart,
                     DbHandle->HandleCreateTime.HighPart );
    }

    Status = RtlSystemTimeToLocalTime( &DbHandle->HandleLastAccessTime, &LocalTime );
    if ( !NT_SUCCESS( Status ) ) {

        DebuggerOut( "Can't convert LastAccess time from GMT to Local time: 0x%lx\n", Status );

    } else {

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        DebuggerOut( "%c", Index ? '\t' : '\0' );
        DebuggerOut( "HandleLastAccessTime \t%ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                     TimeFields.Month,
                     TimeFields.Day,
                     TimeFields.Year,
                     TimeFields.Hour,
                     TimeFields.Minute,
                     TimeFields.Second,
                     DbHandle->HandleLastAccessTime.LowPart,
                     DbHandle->HandleLastAccessTime.HighPart );
    }
#endif
}

VOID
DumpLsaHandle(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    _LSAP_DB_HANDLE DbHandle;
    PVOID Handle;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Handle = GetExpr( pszCommand );

    if ( Handle == NULL ) {

        return;
    }

    LsaReadMemory( Handle,
                sizeof( _LSAP_DB_HANDLE ),
                &DbHandle );

    ShowLsaHandle( &DbHandle, FALSE );
}


void
ShowLsaHandleTable(
    IN LSAP_DB_HANDLE HandleTable
    )
{
    _LSAP_DB_HANDLE ThisHandle, *Stop;
    ULONG i = 0;

    LsaReadMemory( HandleTable->Next,
                sizeof( _LSAP_DB_HANDLE ),
                &ThisHandle );
    Stop = ThisHandle.Previous;

    while ( ThisHandle.Next != Stop ) {

        DebuggerOut( "LsaHandleTable entry %lu\n", i++ );
        ShowLsaHandle( &ThisHandle, TRUE );

        LsaReadMemory( ThisHandle.Next,
                    sizeof( _LSAP_DB_HANDLE ),
                    &ThisHandle );
    }

    return;
}

VOID
DumpLsaHandleTable(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    _LSAP_DB_HANDLE HandleTable;
    PVOID Table;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Table = GetExpr( pszCommand );

    if ( Table == NULL ) {

        return;
    }

    LsaReadMemory( Table,
                sizeof( _LSAP_DB_HANDLE ),
                &HandleTable );

    ShowLsaHandleTable( &HandleTable );
}


VOID
DumpLsaSidCache(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{

    PVOID RawAddress;
    PVOID pEntry;
    LSAP_DB_SID_CACHE_ENTRY Entry;
    NTSTATUS Status;

    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;

    UNICODE_STRING Dummy;
    WCHAR NameBuffer[256];

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    pEntry = GetExpr( pszCommand );

    if ( pEntry == NULL ) {
        //
        // Find the address of the sid cache
        //
        RawAddress = (VOID *) GetExpr("lsasrv!LsapSidCache");

        if ( NULL == RawAddress ) {

           DebuggerOut( "Can't locate the variable lsasrv!SidCache\nPlease get correct symbols or update this debugger extension\n" );

           return;
        }

        pEntry = RawAddress;

        (VOID) LsaReadMemory( RawAddress, sizeof(pEntry), (PVOID) &pEntry );

        if ( NULL == pEntry ) {

            DebuggerOut( "Sid cache is empty!\n" );

            return;

        }
    } else {

        RtlZeroMemory( &Entry, sizeof( Entry ) );
        (VOID) LsaReadMemory( pEntry, sizeof(Entry), (PVOID) &Entry );
        pEntry = Entry.Next;

    }

    //
    // The first is the head and as such is empty
    //
    DebuggerOut( "Head of list located at address 0x%p\n", pEntry );

    if ( !pEntry ) {
        DebuggerOut( "Sid cache is empty!\n" );

        return;
    }

    while ( pEntry ) {

        //
        // Read the entry
        //
        RtlZeroMemory( &Entry, sizeof( Entry ) );
        (VOID) LsaReadMemory( pEntry, sizeof(Entry), (PVOID) &Entry );

        //
        // Print the entry
        //
        DebuggerOut( "New entry located at address 0x%p, next entry 0x%p\n", pEntry, Entry.Next );

        if ( Entry.AccountName.Buffer ) {

            RtlZeroMemory( NameBuffer, sizeof(NameBuffer) );
            (VOID) LsaReadMemory( Entry.AccountName.Buffer,
                               Entry.AccountName.MaximumLength,
                               (PVOID) NameBuffer );

            RtlInitUnicodeString( &Dummy, NameBuffer );

            DebuggerOut( "Account Name:   %wZ\n", &Dummy );

        } else {

            DebuggerOut( "No Account Name\n" );
        }

        if ( Entry.Sid ) {

            DebuggerOut( "Account Sid:  " );

            PrintSid( hProcess,
                      hThread,
                      lpExt,
                      Entry.Sid );

        } else {

            DebuggerOut( "No Account Sid\n" );

        }

        if ( Entry.DomainName.Buffer ) {

            RtlZeroMemory( NameBuffer, sizeof(NameBuffer) );
            (VOID) LsaReadMemory( Entry.DomainName.Buffer,
                               Entry.DomainName.MaximumLength,
                               (PVOID) NameBuffer );

            RtlInitUnicodeString( &Dummy, NameBuffer );

            DebuggerOut( "Domain Name:    %wZ\n", &Dummy );

        } else {

            DebuggerOut( "No Domain Name\n" );
        }

        if ( Entry.DomainSid ) {

            DebuggerOut( "Domain Sid:   " );

            PrintSid( hProcess,
                      hThread,
                      lpExt,
                      Entry.DomainSid );

        }

            DebuggerOut( "Sid Type:       %s\n", SidNameUseXLate( Entry.SidType ) );

        Status = RtlSystemTimeToLocalTime( &Entry.CreateTime, &LocalTime );
        if ( !NT_SUCCESS( Status ) ) {

            DebuggerOut( "Can't convert create time from GMT to Local time: 0x%lx\n", Status );

        } else {

            RtlTimeToTimeFields( &LocalTime, &TimeFields );

            DebuggerOut( "Create Time     %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second,
                         Entry.CreateTime.LowPart,
                         Entry.CreateTime.HighPart );
        }

        Status = RtlSystemTimeToLocalTime( &Entry.RefreshTime, &LocalTime );
        if ( !NT_SUCCESS( Status ) ) {

            DebuggerOut( "Can't convert Last Use time from GMT to Local time: 0x%lx\n", Status );

        } else {

            RtlTimeToTimeFields( &LocalTime, &TimeFields );

            DebuggerOut( "Refresh Time    %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second,
                         Entry.LastUse.LowPart,
                         Entry.LastUse.HighPart );
        }

        Status = RtlSystemTimeToLocalTime( &Entry.ExpirationTime, &LocalTime );
        if ( !NT_SUCCESS( Status ) ) {

            DebuggerOut( "Can't convert expiration time from GMT to Local time: 0x%lx\n", Status );

        } else {

            RtlTimeToTimeFields( &LocalTime, &TimeFields );

            DebuggerOut( "Expiration Time %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second,
                         Entry.ExpirationTime.LowPart,
                         Entry.ExpirationTime.HighPart );
        }

        Status = RtlSystemTimeToLocalTime( &Entry.LastUse, &LocalTime );
        if ( !NT_SUCCESS( Status ) ) {

            DebuggerOut( "Can't convert Last Use time from GMT to Local time: 0x%lx\n", Status );

        } else {

            RtlTimeToTimeFields( &LocalTime, &TimeFields );

            DebuggerOut( "Last Used       %ld/%ld/%ld %ld:%2.2ld:%2.2ld (%8.8lx %8.8lx)\n",
                         TimeFields.Month,
                         TimeFields.Day,
                         TimeFields.Year,
                         TimeFields.Hour,
                         TimeFields.Minute,
                         TimeFields.Second,
                         Entry.LastUse.LowPart,
                         Entry.LastUse.HighPart );
        }

        DebuggerOut( "Flags: %d\n", Entry.Flags );

        DebuggerOut( "\n" );

        //
        // Get the next entry
        //
        pEntry = Entry.Next;

    }  // while

    return;

}


void
DumpLsaHandleTypeList(
    IN PLIST_ENTRY ListEntry
    )
{
    PLIST_ENTRY Next, Read;
    _LSAP_DB_HANDLE Handle, *HandlePtr;
    ULONG i = 0;

    Next = ListEntry->Flink;

    while ( Next != ListEntry ) {

        HandlePtr = CONTAINING_RECORD( Next,
                                       struct _LSAP_DB_HANDLE,
                                       Next );

        LsaReadMemory( HandlePtr,
                    sizeof( _LSAP_DB_HANDLE ),
                    &Handle );
        DebuggerOut( "Handle entry %lu\n", i++);
        ShowLsaHandle( &Handle, TRUE );

        Next = HandlePtr->UserHandleList.Flink;
    }


}
void
ShowLsaHandleTableEx(
    IN PLSAP_DB_HANDLE_TABLE HandleTable
    )
{
    PLIST_ENTRY HandleEntry;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY CurrentUserEntry = NULL;
    LSAP_DB_HANDLE_TABLE_USER_ENTRY ThisUserEntry;
    ULONG i = 0;

    HandleEntry = HandleTable->UserHandleList.Flink;
    for ( i = 0; i < HandleTable->UserCount; i++ ) {

        CurrentUserEntry = CONTAINING_RECORD( HandleEntry,
                                              LSAP_DB_HANDLE_TABLE_USER_ENTRY,
                                              Next );

        LsaReadMemory( CurrentUserEntry,
                    sizeof( LSAP_DB_HANDLE_TABLE_USER_ENTRY ),
                    &ThisUserEntry );

        DebuggerOut( "HandleTable Entry #%lu\n", i );
        DebuggerOut( "User id %x:%x\n",
                     ThisUserEntry.LogonId.HighPart,
                     ThisUserEntry.LogonId.LowPart);

#if DBG
        DebuggerOut( "UserToken 0x%lx\n", ThisUserEntry.UserToken );
#endif
        DebuggerOut( "Policy Handle List:\n" );
        DumpLsaHandleTypeList( &ThisUserEntry.PolicyHandles );

        DebuggerOut( "Object Handle List:\n" );
        DumpLsaHandleTypeList( &ThisUserEntry.ObjectHandles );

        HandleEntry = &ThisUserEntry.Next;
    }

}


VOID
DumpLsaHandleTableEx(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    LSAP_DB_HANDLE_TABLE HandleTableEx;
    PVOID Table;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Table = GetExpr( pszCommand );

    if ( Table == NULL ) {

        return;
    }

    LsaReadMemory( Table,
                sizeof( LSAP_DB_HANDLE_TABLE ),
                &HandleTableEx );

    ShowLsaHandleTableEx( &HandleTableEx );
}


VOID
ShowTopLevelNameEntry(
    IN FTCache::TLN_ENTRY * EntryAddr,
    IN FTCache::TLN_ENTRY * EntryData
    )
{
    FTCache::TDO_ENTRY TdoEntry;
    FTCache::TLN_KEY TlnKey;
    SECURITY_STRING sLocal;

    DebuggerOut( "TopLevelNameEntry: %p\n", EntryAddr );
    DebuggerOut( "TdoListEntry: %p %p\n", EntryData->TdoListEntry.Flink, EntryData->TdoListEntry.Blink );
    DebuggerOut( "AvlListEntry: %p %p\n", EntryData->AvlListEntry.Flink, EntryData->TdoListEntry.Blink );
    DebuggerOut( "Excluded: %s\n", ( EntryData->Excluded ? "Yes" : "No" ));
    DebuggerOut( "Flags: %d\n", EntryData->m_Flags );

    if ( EntryData->Excluded ) {

        FTCache::TLN_ENTRY TlnEntry;

        LsaReadMemory(
            EntryData->SuperiorEntry,
            sizeof( FTCache::TLN_ENTRY ),
            &TlnEntry
            );

        LsaReadMemory(
            TlnEntry.TlnKey,
            sizeof( FTCache::TLN_KEY ),
            &TlnKey
            );

        sLocal.Buffer = NULL;
        MapString( &TlnKey.TopLevelName, &sLocal );
        DebuggerOut( "SuperiorEntry: %p (%ws)\n", EntryData->SuperiorEntry, sLocal.Buffer );
        FreeHeap( sLocal.Buffer );

    } else if ( EntryData->SubordinateEntry ) {

        FTCache::TLN_ENTRY TlnEntry;

        LsaReadMemory(
            EntryData->SubordinateEntry,
            sizeof( FTCache::TLN_ENTRY ),
            &TlnEntry
            );

        LsaReadMemory(
            TlnEntry.TlnKey,
            sizeof( FTCache::TLN_KEY ),
            &TlnKey
            );

        sLocal.Buffer = NULL;
        MapString( &TlnKey.TopLevelName, &sLocal );
        DebuggerOut( "SubordinateEntry: %p (%ws)\n", EntryData->SubordinateEntry, sLocal.Buffer );
        FreeHeap( sLocal.Buffer );

    } else {

        DebuggerOut( "SubordinateEntry: NULL\n" );
    }

    LsaReadMemory(
        EntryData->TdoEntry,
        sizeof( FTCache::TDO_ENTRY ),
        &TdoEntry
        );

    sLocal.Buffer = NULL;
    MapString( &TdoEntry.TrustedDomainName, &sLocal );
    DebuggerOut( "TdoEntry: %p (%ws)\n", EntryData->TdoEntry, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    LsaReadMemory(
        EntryData->TlnKey,
        sizeof( FTCache::TLN_KEY ),
        &TlnKey
        );

    sLocal.Buffer = NULL;
    MapString( &TlnKey.TopLevelName, &sLocal );
    DebuggerOut( "TlnKey: %p (%ws)\n", EntryData->TlnKey, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    DebuggerOut( "\n" );
}

VOID
ShowDomainInfoEntry(
    IN FTCache::DOMAIN_INFO_ENTRY * EntryAddr,
    IN FTCache::DOMAIN_INFO_ENTRY * EntryData
    )
{
    FTCache::TDO_ENTRY TdoEntry;
    FTCache::TLN_ENTRY SubordinateTo;
    FTCache::TLN_KEY TlnKey;
    FTCache::DNS_NAME_KEY DnsKey;
    FTCache::NETBIOS_NAME_KEY NetbiosKey;
    SECURITY_STRING sLocal;

    DebuggerOut( "DomainInfoEntry: %p\n", EntryAddr );
    DebuggerOut( "TdoListEntry: %p %p", EntryData->TdoListEntry.Flink, EntryData->TdoListEntry.Blink );
    DebuggerOut( "SidAvlListEntry: %p\n", EntryData->SidAvlListEntry.Flink, EntryData->SidAvlListEntry.Blink );
    DebuggerOut( "DnsAvlListEntry: %p\n", EntryData->DnsAvlListEntry.Flink, EntryData->DnsAvlListEntry.Blink );
    DebuggerOut( "NetbiosAvlListEntry: %p\n", EntryData->NetbiosAvlListEntry.Flink, EntryData->NetbiosAvlListEntry.Blink );
    DebuggerOut( "Flags: %d\n", EntryData->m_Flags );
    DebuggerOut( "Time: %x-%x\n", EntryData->Time.HighPart, EntryData->Time.LowPart );
    DebuggerOut( "Sid: " );
    LocalDumpSid( EntryData->Sid );
    DebuggerOut( "\n" );

    LsaReadMemory(
        EntryData->TdoEntry,
        sizeof( FTCache::TDO_ENTRY ),
        &TdoEntry
        );

    sLocal.Buffer = NULL;
    MapString( &TdoEntry.TrustedDomainName, &sLocal );
    DebuggerOut( "TdoEntry: %p (%ws)\n", EntryData->TdoEntry, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    LsaReadMemory(
        EntryData->SubordinateTo,
        sizeof( FTCache::TLN_ENTRY ),
        &SubordinateTo
        );

    LsaReadMemory(
        SubordinateTo.TlnKey,
        sizeof( FTCache::TLN_KEY ),
        &TlnKey
        );

    sLocal.Buffer = NULL;
    MapString( &TlnKey.TopLevelName, &sLocal );
    DebuggerOut( "SubordinateTo: %p (%ws)\n", EntryData->SubordinateTo, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    DebuggerOut( "SidKey: %p\n", EntryData->SidKey );

    LsaReadMemory(
        EntryData->SidKey,
        sizeof( FTCache::DNS_NAME_KEY ),
        &DnsKey
        );

    sLocal.Buffer = NULL;
    MapString( &DnsKey.DnsName, &sLocal );
    DebuggerOut( "DnsKey: %p (%ws)\n", EntryData->DnsKey, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    if ( EntryData->NetbiosKey ) {

        LsaReadMemory(
            EntryData->NetbiosKey,
            sizeof( FTCache::NETBIOS_NAME_KEY ),
            &NetbiosKey
            );

        sLocal.Buffer = NULL;
        MapString( &NetbiosKey.NetbiosName, &sLocal );
        DebuggerOut( "NetbiosKey: %p (%ws)\n", EntryData->NetbiosKey, sLocal.Buffer );
        FreeHeap( sLocal.Buffer );

    } else {

        DebuggerOut( "NetbiosKey: NULL\n" );
    }

    DebuggerOut( "\n" );
}

VOID
ShowFtcTdoEntry(
    IN PVOID TdoEntryAddr,
    IN FTCache::TDO_ENTRY * TdoEntryData
    )
{
    ULONG Displayed;
    PUCHAR ListEnd;
    SECURITY_STRING sLocal;

    DebuggerOut( "<------------------->\n" );

    sLocal.Buffer = NULL;
    MapString( &TdoEntryData->TrustedDomainName, &sLocal );
    DebuggerOut( "TrustedDomainName: %ws\n", &TdoEntryData->TrustedDomainName, sLocal.Buffer );
    FreeHeap( sLocal.Buffer );

    DebuggerOut( "Record count: %lu\n\n", TdoEntryData->RecordCount );

    DebuggerOut( "\n===> Top Level Name Entries <===\n\n" );
    Displayed = 0;

    ListEnd = ( PUCHAR )TdoEntryAddr + FIELD_OFFSET( FTCache::TDO_ENTRY, TlnList );
    if ( TdoEntryData->TlnList.Flink == ( PLIST_ENTRY )ListEnd ) {

        DebuggerOut( "<none>\n" );

    } else {

        FTCache::TLN_ENTRY TlnEntryData;
        FTCache::TLN_ENTRY * TlnEntryAddr;

        TlnEntryAddr = FTCache::TLN_ENTRY::EntryFromTdoEntry( TdoEntryData->TlnList.Flink );

        do {

            LsaReadMemory(
                TlnEntryAddr,
                sizeof( FTCache::TLN_ENTRY ),
                &TlnEntryData
                );

            Displayed += 1;
            DebuggerOut( "Entry #%lu\n", Displayed );
            ShowTopLevelNameEntry( TlnEntryAddr, &TlnEntryData );

            TlnEntryAddr = FTCache::TLN_ENTRY::EntryFromTdoEntry( TlnEntryData.TdoListEntry.Flink );

        } while ( TlnEntryAddr != FTCache::TLN_ENTRY::EntryFromTdoEntry(( PLIST_ENTRY )ListEnd ));
    }

    DebuggerOut( "\n===> Domain Info Entries <===\n\n" );
    Displayed = 0;

    ListEnd = ( PUCHAR )TdoEntryAddr + FIELD_OFFSET( FTCache::TDO_ENTRY, DomainInfoList );
    if ( TdoEntryData->DomainInfoList.Flink == ( PLIST_ENTRY )ListEnd ) {

        DebuggerOut( "<none>\n" );

    } else {

        FTCache::DOMAIN_INFO_ENTRY DomainInfoData;
        FTCache::DOMAIN_INFO_ENTRY * DomainInfoAddr;

        DomainInfoAddr = FTCache::DOMAIN_INFO_ENTRY::EntryFromTdoEntry( TdoEntryData->DomainInfoList.Flink );

        do {

            LsaReadMemory(
                DomainInfoAddr,
                sizeof( FTCache::DOMAIN_INFO_ENTRY ),
                &DomainInfoData
                );

            Displayed += 1;
            DebuggerOut( "Entry #%lu\n", Displayed );
            ShowDomainInfoEntry( DomainInfoAddr, &DomainInfoData );

            DomainInfoAddr = FTCache::DOMAIN_INFO_ENTRY::EntryFromTdoEntry( DomainInfoData.TdoListEntry.Flink );

        } while ( DomainInfoAddr != FTCache::DOMAIN_INFO_ENTRY::EntryFromTdoEntry(( PLIST_ENTRY )ListEnd ));
    }

    return;
}


VOID
ShowForestTrustCache(
    IN FTCache * Ftc
    )
{
    DebuggerOut( "Forest Trust Cache si %s\n",
                 ( Ftc->m_Initialized ? "valid" : "invalid" ));

    DebuggerOut( "Forest Trust Cache is %s\n",
                 ( Ftc->m_Valid ? "valid" : "invalid" ));

    if ( !Ftc->m_Initialized || !Ftc->m_Valid ) {

        return;
    }

    return;
}


VOID
DumpFtcTdoEntry(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID TdoEntryAddr;
    FTCache::TDO_ENTRY TdoEntryData;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    TdoEntryAddr = GetExpr( pszCommand );

    if ( TdoEntryAddr == NULL ) {

        return;
    }

    LsaReadMemory( TdoEntryAddr,
                   sizeof( FTCache::TDO_ENTRY ),
                   &TdoEntryData );

    ShowFtcTdoEntry( TdoEntryAddr, &TdoEntryData );
}


VOID
DumpForestTrustCache(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    BYTE Ftc[sizeof(FTCache)];
    PVOID Cache;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    Cache = GetExpr( pszCommand );

    if ( Cache == NULL ) {

        return;
    }

    LsaReadMemory( Cache,
                   sizeof( FTCache ),
                   &Ftc );

    ShowForestTrustCache( ( FTCache * )Ftc );
}


VOID
LocalPrintGuid(
    GUID *Guid
    )
{
    if ( Guid ) {

        DebuggerOut( "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                     Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0],
                     Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4],
                     Guid->Data4[5], Guid->Data4[6], Guid->Data4[7] );

    }
}

VOID
ReadAndDumpSid(
    IN PVOID SidPtr
    )
{
    UNICODE_STRING StringSid;
    SID Sid;
    PSID ReadSid;

    LsaReadMemory( SidPtr, sizeof( SID ), &Sid );

    ReadSid = AllocHeap( RtlLengthRequiredSid( Sid.SubAuthorityCount ) );

    if ( ReadSid ) {

        LsaReadMemory( SidPtr, RtlLengthRequiredSid( Sid.SubAuthorityCount ), ReadSid );
        RtlConvertSidToUnicodeString( &StringSid, ReadSid, TRUE );
        DebuggerOut( "%wZ", &StringSid );
        RtlFreeUnicodeString( &StringSid );
        FreeHeap( ReadSid );
    }

}

VOID
ShowAcl(
    IN PVOID AclPtr
    )
{
    ULONG i, SkipSize;
    PVOID AcePtr;
    ACE_HEADER Ace;
    KNOWN_ACE KnownAce;
    KNOWN_OBJECT_ACE KnownObjectAce;
    PSID SidStart = NULL, ReadSid;
    SID Sid;
    UNICODE_STRING StringSid;
    GUID *DisplayGuid;
    ACL ReadAcl;
    PACL Acl = &ReadAcl;

    LsaReadMemory( AclPtr, sizeof( ACL ), &ReadAcl );

    DebuggerOut( "AclRevision %lu\n", ReadAcl.AclRevision );
    DebuggerOut( "Sbz1 %lu\n", ReadAcl.Sbz1 );
    DebuggerOut( "AclSize %lu\n", ReadAcl.AclSize );
    DebuggerOut( "AceCount %lu\n", ReadAcl.AceCount );
    DebuggerOut( "Sbz2 %lu\n", ReadAcl.Sbz2 );

    AcePtr = ( PUCHAR )AclPtr + sizeof( ACL );
    for ( i = 0; i < ReadAcl.AceCount; i++ ) {

        //
        // First, we need to read the Size/Type of the ace
        //
        LsaReadMemory( AcePtr, sizeof( ACE_HEADER ), &Ace );

        DebuggerOut( "Ace[ %lu ]\n", i );
        DebuggerOut( "\tAceType %lu\n", Ace.AceType );
        DebuggerOut( "\tAceFlags %lu\n", Ace.AceFlags );
        DebuggerOut( "\tAceSize %lu\n", Ace.AceSize );

        switch ( Ace.AceType ) {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            LsaReadMemory( AcePtr, sizeof( KNOWN_ACE ), &KnownAce );
            DebuggerOut( "\tAccessMask 0x%lx\n", KnownAce.Mask );
            SidStart = ( PSID )( ( PUCHAR )AcePtr + sizeof( KNOWN_ACE ) - sizeof( ULONG ) );
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            SkipSize = sizeof( KNOWN_OBJECT_ACE );
            LsaReadMemory( AcePtr, sizeof( KNOWN_OBJECT_ACE ) + 2 * sizeof( GUID ), &KnownObjectAce );
            DebuggerOut( "\tAccessMask 0x%lx\n", KnownObjectAce.Mask );
            DisplayGuid = RtlObjectAceObjectType( &KnownObjectAce );
            if ( DisplayGuid ) {

                DebuggerOut( "\tObjectGuid ");
                LocalPrintGuid( DisplayGuid );
                DebuggerOut( "\n");
                SkipSize += sizeof( GUID );
            }

            DisplayGuid = RtlObjectAceInheritedObjectType( &KnownObjectAce );
            if ( DisplayGuid ) {

                DebuggerOut( "\tObjectGuid ");
                LocalPrintGuid( DisplayGuid );
                DebuggerOut( "\n");
                SkipSize += sizeof( GUID );
            }

            SidStart = ( PSID )( ( PUCHAR )AcePtr + SkipSize - sizeof( ULONG ) );
            break;


        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        default:
            DebuggerOut( "Unsupported AceType %lu encountered... skipping\n", Ace.AceType );
            break;
        }


        AcePtr = ( PUCHAR )AcePtr + Ace.AceSize;

        LsaReadMemory( SidStart, sizeof( SID ), &Sid );

        ReadSid = AllocHeap( RtlLengthRequiredSid( Sid.SubAuthorityCount ) );

        if ( ReadSid ) {

            LsaReadMemory( SidStart, RtlLengthRequiredSid( Sid.SubAuthorityCount ), ReadSid );
            RtlConvertSidToUnicodeString( &StringSid, ReadSid, TRUE );
            DebuggerOut( "\t%wZ\n", &StringSid );
            RtlFreeUnicodeString( &StringSid );
            FreeHeap( ReadSid );
        }

    }

}

VOID
DumpAcl(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    ACL Acl;
    PVOID AclPtr;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    AclPtr = GetExpr( pszCommand );

    if ( AclPtr == NULL ) {

        return;
    }

    ShowAcl( AclPtr );
}

VOID
ShowSD(
    IN PVOID SDPtr
    )
{
    SECURITY_DESCRIPTOR SD;
    PSID Owner = NULL, Group = NULL;
    PACL Dacl = NULL, Sacl = NULL;

    LsaReadMemory( SDPtr, sizeof( SECURITY_DESCRIPTOR ), &SD );

    DebuggerOut( "Revision %lu\n", SD.Revision );
    DebuggerOut( "Sbz1 %lu\n", SD.Sbz1 );
    DebuggerOut( "Control 0x%lx\n", SD.Control );

    if (  ( SD.Control & SE_SELF_RELATIVE ) == SE_SELF_RELATIVE ) {

        if ( SD.Owner != 0 ) {

            Owner = ( PSID )( ( PUCHAR )SDPtr + ( ULONG_PTR )SD.Owner );
        }

        if ( SD.Group != 0 ) {

            Group = ( PSID )( ( PUCHAR )SDPtr + ( ULONG_PTR )SD.Group );
        }

        if ( SD.Dacl != 0 ) {

            Dacl = ( PACL )( ( PUCHAR )SDPtr + ( ULONG_PTR )SD.Dacl );
        }

        if ( SD.Sacl != 0 ) {

            Sacl = ( PACL )( ( PUCHAR )SDPtr + ( ULONG_PTR )SD.Sacl );
        }

    } else {

        Owner = SD.Owner;
        Group = SD.Group;
        Dacl = SD.Dacl;
        Sacl = SD.Sacl;
    }

    DebuggerOut( "Owner: ");
    if ( Owner ) {

        ReadAndDumpSid( Owner );

    } else {

        DebuggerOut( "<NULL>" );
    }
    DebuggerOut( "\n" );

    DebuggerOut( "Group: ");
    if ( Group ) {

        ReadAndDumpSid( Group );

    } else {

        DebuggerOut( "<NULL>" );
    }
    DebuggerOut( "\n" );

    DebuggerOut( "DACL:\n");
    if ( Dacl ) {

        ShowAcl( Dacl );

    } else {

        DebuggerOut( "<NULL>" );
    }

    DebuggerOut( "SACL:\n");
    if ( Sacl ) {

        ShowAcl( Sacl );

    } else {

        DebuggerOut( "<NULL>" );
    }
    DebuggerOut( "\n" );

}

VOID
DumpSD(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    PVOID SDPtr;

    InitDebugHelp( hProcess,
                   hThread,
                   lpExt);

    SDPtr = GetExpr( pszCommand );

    if ( SDPtr == NULL ) {

        return;
    }

    ShowSD( SDPtr );

}


VOID
setevent(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    HANDLE h ;
    HANDLE hThere ;

    InitDebugHelp( hProcess, hThread, lpExt );

    hThere = GetExpr( pszCommand );

    if ( DuplicateHandle( hProcess,
                          hThere,
                          GetCurrentProcess(),
                          &h,
                          0,
                          FALSE,
                          DUPLICATE_SAME_ACCESS ) )
    {
        SetEvent( h );
        CloseHandle( h );
    }
}


/*
+-------------------------------------------------------------------+

    NAME:       DumpSID

    FUNCTION:   Prints out a SID, with the padding provided.

    ARGS:       pad         --  Padding to print before the SID.
                sid_to_dump --  Pointer to the SID to print.
                Flag        --  To control options.

    RETURN:     N/A

    NOTE***:    It right now, doesn't lookup the sid.
                In future, you might want ot use the Flag
                parameter to make that optional.

+-------------------------------------------------------------------+
*/


VOID    DumpSID(
    CHAR        *pad,
    PSID        sid_to_dump,
    ULONG       Flag
    )
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      us;

    if (sid_to_dump)
    {
        ntstatus = RtlConvertSidToUnicodeString(&us, sid_to_dump, TRUE);

        if (NT_SUCCESS(ntstatus))
        {
            DebuggerOut("%s%wZ\n", pad, &us);
            RtlFreeUnicodeString(&us);
        }
        else
        {
            DebuggerOut("0x%08lx: Can't Convert SID to UnicodeString\n", ntstatus);
        }
    }
    else
    {
        DebuggerOut("%s is NULL\n", pad);
    }
}

/*
+-------------------------------------------------------------------+

    NAME:       DumpACL

    FUNCTION:   Prints out a ACL, with the padding provided.

    ARGS:       pad         --  Padding to print before the ACL.
                acl_to_dump --  Pointer to the ACL to print.
                Flag        --  To control options.

    RETURN:     N/A

+-------------------------------------------------------------------+
*/

BOOL
DumpACL (
    IN  char     *pad,
    IN  ACL      *pacl,
    IN  ULONG    Flags
    )
{
    USHORT       x;

    if (pacl == NULL)
    {
        DebuggerOut("%s is NULL\n", pad);
        return FALSE;
    }

    DebuggerOut("%s\n", pad);
    DebuggerOut("%s->AclRevision: 0x%x\n", pad, pacl->AclRevision);
    DebuggerOut("%s->Sbz1       : 0x%x\n", pad, pacl->Sbz1);
    DebuggerOut("%s->AclSize    : 0x%x\n", pad, pacl->AclSize);
    DebuggerOut("%s->AceCount   : 0x%x\n", pad, pacl->AceCount);
    DebuggerOut("%s->Sbz2       : 0x%x\n", pad, pacl->Sbz2);

    for (x = 0; x < pacl->AceCount; x ++)
    {
        PACE_HEADER     ace;
        CHAR        temp_pad[MAX_PATH];
        NTSTATUS    result;

        sprintf(temp_pad, "%s->Ace[%u]: ", pad, x);

        result = RtlGetAce(pacl, x, (PVOID *) &ace);
        if (! NT_SUCCESS(result))
        {
            DebuggerOut("%sCan't GetAce, 0x%08lx\n", temp_pad, result);
            return FALSE;
        }

        DebuggerOut("%s->AceType: ", temp_pad);

#define BRANCH_AND_PRINT(x) case x: DebuggerOut(#x "\n"); break

        switch (ace->AceType)
        {
            BRANCH_AND_PRINT(ACCESS_ALLOWED_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_COMPOUND_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_OBJECT_ACE_TYPE);

            default:
                DebuggerOut("0x%08lx <-- *** Unknown AceType\n", ace->AceType);
                continue; // With the next ace
        }

#undef BRANCH_AND_PRINT

        DebuggerOut("%s->AceFlags: 0x%x\n", temp_pad, ace->AceFlags);

#define BRANCH_AND_PRINT(x) if (ace->AceFlags & x){ DebuggerOut("%s            %s\n", temp_pad, #x); }

        BRANCH_AND_PRINT(OBJECT_INHERIT_ACE)
        BRANCH_AND_PRINT(CONTAINER_INHERIT_ACE)
        BRANCH_AND_PRINT(NO_PROPAGATE_INHERIT_ACE)
        BRANCH_AND_PRINT(INHERIT_ONLY_ACE)
        BRANCH_AND_PRINT(INHERITED_ACE)
        BRANCH_AND_PRINT(SUCCESSFUL_ACCESS_ACE_FLAG)
        BRANCH_AND_PRINT(FAILED_ACCESS_ACE_FLAG)

#undef BRANCH_AND_PRINT

        DebuggerOut("%s->AceSize: 0x%x\n", temp_pad, ace->AceSize);

        /*
            From now on it is ace specific stuff.
            Fortunately ACEs can be split into 3 groups,
            with the ACE structure being the same within the group
        */

        switch (ace->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                {
                    CHAR        more_pad[MAX_PATH];
                    SYSTEM_AUDIT_ACE    *tace = (SYSTEM_AUDIT_ACE *) ace;

                    DebuggerOut("%s->Mask : 0x%08lx\n", temp_pad, tace->Mask);

                    sprintf(more_pad, "%s->SID: ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);
                }
                break;

            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                {
                    CHAR                            more_pad[MAX_PATH];
                    COMPOUND_ACCESS_ALLOWED_ACE     *tace = (COMPOUND_ACCESS_ALLOWED_ACE *) ace;
                    PBYTE                           ptr;

                    DebuggerOut("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                    DebuggerOut("%s->CompoundAceType : 0x%08lx\n", temp_pad, tace->CompoundAceType);
                    DebuggerOut("%s->Reserved        : 0x%08lx\n", temp_pad, tace->Reserved);

                    sprintf(more_pad, "%s->SID(1)          : ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);

                    ptr = (PBYTE)&(tace->SidStart);
                    ptr += RtlLengthSid((PSID)ptr); /* Skip this & get to next sid */

                    sprintf(more_pad, "%s->SID(2)          : ", temp_pad);
                    DumpSID(more_pad, ptr, Flags);
                }
                break;
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                {
                    CHAR                            more_pad[MAX_PATH];
                    ACCESS_ALLOWED_OBJECT_ACE       *tace = (ACCESS_ALLOWED_OBJECT_ACE *) ace;
                    PBYTE                           ptr;
                    GUID                            *obj_guid = NULL, *inh_obj_guid = NULL;

                    DebuggerOut("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                    DebuggerOut("%s->Flags           : 0x%08lx\n", temp_pad, tace->Flags);

                    ptr = (PBYTE)&(tace->ObjectType);

                    if (tace->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        DebuggerOut("%s                  : ACE_OBJECT_TYPE_PRESENT\n", temp_pad);
                        obj_guid = &(tace->ObjectType);
                        ptr = (PBYTE)&(tace->InheritedObjectType);
                    }

                    if (tace->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        DebuggerOut("%s                  : ACE_INHERITED_OBJECT_TYPE_PRESENT\n", temp_pad);
                        inh_obj_guid = &(tace->InheritedObjectType);
                        ptr = (PBYTE)&(tace->SidStart);
                    }

                    if (obj_guid)
                    {
                        DebuggerOut("%s->ObjectType      : (in HEX)", temp_pad);
                        DebuggerOut("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                            obj_guid->Data1,
                            obj_guid->Data2,
                            obj_guid->Data3,
                            obj_guid->Data4[0],
                            obj_guid->Data4[1],
                            obj_guid->Data4[2],
                            obj_guid->Data4[3],
                            obj_guid->Data4[4],
                            obj_guid->Data4[5],
                            obj_guid->Data4[6],
                            obj_guid->Data4[7]
                            );
                    }

                    if (inh_obj_guid)
                    {
                        DebuggerOut("%s->InhObjTYpe      : (in HEX)", temp_pad);
                        DebuggerOut("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                            inh_obj_guid->Data1,
                            inh_obj_guid->Data2,
                            inh_obj_guid->Data3,
                            inh_obj_guid->Data4[0],
                            inh_obj_guid->Data4[1],
                            inh_obj_guid->Data4[2],
                            inh_obj_guid->Data4[3],
                            inh_obj_guid->Data4[4],
                            inh_obj_guid->Data4[5],
                            inh_obj_guid->Data4[6],
                            inh_obj_guid->Data4[7]
                            );
                    }

                    sprintf(more_pad, "%s->SID             : ", temp_pad);
                    DumpSID(more_pad, ptr, Flags);
                }
        }
        DebuggerOut("\n");
    }

    return TRUE;
}

VOID
objsec(
    HANDLE                  hProcess,
    HANDLE                  hThread,
    DWORD                   dwCurrentPc,
    PNTSD_EXTENSION_APIS    lpExt,
    LPSTR                   pszCommand)
{
    HANDLE h ;
    HANDLE hThere ;
    NTSTATUS Status ;
    ULONG Length ;
    PVOID SecurityDescriptor ;
    PACL Acl ;

    InitDebugHelp( hProcess, hThread, lpExt );

    hThere = GetExpr( pszCommand );

    if ( DuplicateHandle( hProcess,
                          hThere,
                          GetCurrentProcess(),
                          &h,
                          0,
                          FALSE,
                          DUPLICATE_SAME_ACCESS ) )
    {
        Status = NtQuerySecurityObject(
                    h,
                    DACL_SECURITY_INFORMATION,
                    NULL,
                    0,
                    &Length );

        SecurityDescriptor = LocalAlloc( LMEM_FIXED, Length );

        if ( SecurityDescriptor )
        {
            Status = NtQuerySecurityObject(
                        h,
                        DACL_SECURITY_INFORMATION,
                        SecurityDescriptor,
                        Length,
                        &Length );

            if ( NT_SUCCESS( Status ) )
            {
                BOOLEAN Present, defaulted;

                RtlGetDaclSecurityDescriptor( SecurityDescriptor,
                                              &Present,
                                              &Acl,
                                              &defaulted );

                DumpACL( "", Acl, 0);

            }

            LocalFree( SecurityDescriptor );
        }


    }
}

void
Help(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    DebuggerOut("SPM Debug Help\n");
    DebuggerOut("   DumpPackage [-v][-b]] [id | addr]\tDump Package Control\n");
    DebuggerOut("   DumpSessionList <addr>      \tDump Session List\n");
    DebuggerOut("   DumpThreadSession           \tDump Thread's session\n");
    DebuggerOut("   DumpLogonSession <addr>     \tDump Logon Session list\n");
    DebuggerOut("   DumpSession <addr>          \tDump Session\n");
    DebuggerOut("   DumpHandleList <addr>       \tDump a Handle List from a session\n");
    DebuggerOut("   DumpBlock <addr>            \tDump a memory block (DBGMEM only)\n");
    DebuggerOut("   DumpScavList [<addr>[+]]    \tDump the scavenger list\n");
    DebuggerOut("   DumpToken <handle>          \tDump a token\n");
    DebuggerOut("   DumpThreadToken             \tDump token of thread\n");
    DebuggerOut("   DumpActives [-p|a|t] [file] \tDump active memory to file\n");
    DebuggerOut("   DumpFastMem                 \tDump FastMem usage\n");
    DebuggerOut("   Except                      \tShow exception for thread\n");
    DebuggerOut("   DumpLpc                     \tDump Lpc Dispatch record\n");
    DebuggerOut("   DumpLpcMessage <addr>       \tDump Lpc Message at address\n");
    DebuggerOut("   DumpThreadTask <addr>       \tDump thread pool\n");
    DebuggerOut("   DumpQueue [<addr>]          \tDump Queue\n");
    DebuggerOut("   DumpSecBuffer <addr>        \tDump SecBuffer struct\n");
    DebuggerOut("   DumpSecBufferDesc <addr>    \tDump SecBufferDesc struct \n");
    DebuggerOut("   DumpThreadLpc               \tDump thread's LPC message\n");
    DebuggerOut("   DumpNegContext <addr>       \tDump NEG_CONTEXT structure\n");
    DebuggerOut("   DumpNegCred <addr>          \tDump NEG_CRED structure\n");
    DebuggerOut("   BERDecode <addr>            \tDecode BER-encoded data\n");
    DebuggerOut("   GetTls <slot>               \tGet the TLS value from slot\n");
    DebuggerOut("   DumpHandleTable <addr>      \tDump handle table at addr\n");
    DebuggerOut("   DumpLsaHandle <addr>        \tDump the Lsa policy handle at addr\n");
    DebuggerOut("   DumpLsaHandleTable <addr>   \tDump the Lsa policy handle table at addr\n");
    DebuggerOut("   DumpLsaHandleTableEx <addr> \tDump the Lsa policy handle table at addr\n");
    DebuggerOut("   DumpSD <addr>               \tDump a security descriptor\n");
    DebuggerOut("   DumpAcl <addr>              \tDump the ACL at addr\n" );
    DebuggerOut("   DumpSid <addr>              \tDump the SID at addr\n" );
    DebuggerOut("   DumpLsaSidCache [<addr>]    \tDump the LSA sid cache\n" );
    DebuggerOut("   DumpFtcTdoEntry <addr>      \tDump the LSA FTC TDO entry\n" );
    DebuggerOut("   DumpForestTrustCache <addr> \tDump the LSA forest trust cache\n");

    DebuggerOut("\n\nShortcuts\n");
    DebuggerOut("   sb              DumpSecBuffer\n");
    DebuggerOut("   sbd             DumpSecBufferDesc\n");
    DebuggerOut("   lpc             DumpLpcMessage\n");
    DebuggerOut("   sess            DumpSession\n");
    DebuggerOut("   ber             BERDecode\n");
    DebuggerOut("   q               DumpQueue\n");
    DebuggerOut("   task            DumpThreadTask\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\rpcnotif.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dslookup.c

Abstract:

    Implementation of server side RPC notify routines

Author:

    Mac McLain          (MacM)       May 17, 1998

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>

VOID
LsapServerRpcThreadReturnNotify(
    LPWSTR CallingFunction
    );


VOID
LsarClose_notify(
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarClose" );
}

VOID
LsarDelete_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarDelete" );
}

VOID
LsarEnumeratePrivileges_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumeratePrivileges" );
}

VOID
LsarQuerySecurityObject_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQuerySecurityObject" );
}

VOID
LsarSetSecurityObject_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateTrustedDomainsEx" );
}

VOID
LsarChangePassword_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarChangePassword" );
}

VOID
LsarOpenPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenPolicy" );
}

VOID
LsarQueryInformationPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryInformationPolicy" );
}

VOID
LsarSetInformationPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetInformationPolicy" );
}

VOID
LsarClearAuditLog_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarClearAuditLog" );
}

VOID
LsarCreateAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarCreateAccount" );
}

VOID
LsarEnumerateAccounts_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateAccounts" );
}

VOID
LsarCreateTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarCreateTrustedDomain" );
}

VOID
LsarEnumerateTrustedDomains_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateTrustedDomains" );
}

VOID
LsarLookupNames_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupNames" );
}

VOID
LsarLookupSids_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupSids" );
}

VOID
LsarCreateSecret_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarCreateSecret" );
}

VOID
LsarOpenAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenAccount" );
}

VOID
LsarEnumeratePrivilegesAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumeratePrivilegesAccount" );
}

VOID
LsarAddPrivilegesToAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarAddPrivilegesToAccount" );
}

VOID
LsarRemovePrivilegesFromAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarRemovePrivilegesFromAccount" );
}

VOID
LsarGetQuotasForAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarAddPrivilegesToAccount" );
}

VOID
LsarSetQuotasForAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetQuotasForAccount" );
}

VOID
LsarGetSystemAccessAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarGetSystemAccessAccount" );
}

VOID
LsarSetSystemAccessAccount_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetSystemAccessAccount" );
}

VOID
LsarOpenTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenTrustedDomain" );
}

VOID
LsarQueryInfoTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryInfoTrustedDomain" );
}

VOID
LsarSetInformationTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetInformationTrustedDomain" );
}

VOID
LsarOpenSecret_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenSecret" );
}

VOID
LsarSetSecret_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetSecret" );
}

VOID
LsarQuerySecret_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQuerySecret" );
}

VOID
LsarLookupPrivilegeValue_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupPrivilegeValue" );
}

VOID
LsarLookupPrivilegeName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupPrivilegeName" );
}

VOID
LsarLookupPrivilegeDisplayName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupPrivilegeDisplayName" );
}

VOID
LsarDeleteObject_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarDeleteObject" );
}

VOID
LsarEnumerateAccountsWithUserRight_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateAccountsWithUserRight" );
}

VOID
LsarEnumerateAccountRights_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateAccountRights" );
}

VOID
LsarAddAccountRights_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarAddAccountRights" );
}

VOID
LsarRemoveAccountRights_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarRemoveAccountRights" );
}

VOID
LsarQueryTrustedDomainInfo_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryTrustedDomainInfo" );
}

VOID
LsarSetTrustedDomainInfo_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetTrustedDomainInfo" );
}

VOID
LsarDeleteTrustedDomain_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarDeleteTrustedDomain" );
}

VOID
LsarStorePrivateData_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarStorePrivateData" );
}

VOID
LsarRetrievePrivateData_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarRetrievePrivateData" );
}

VOID
LsarOpenPolicy2_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenPolicy2" );
}

VOID
LsarOpenPolicySce_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenPolicySce" );
}

VOID
LsarGetUserName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarGetUserName" );
}

VOID
LsarQueryInformationPolicy2_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryInformationPolicy2" );
}

VOID
LsarSetInformationPolicy2_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetInformationPolicy2" );
}

VOID
LsarQueryTrustedDomainInfoByName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryTrustedDomainInfoByName" );
}

VOID
LsarSetTrustedDomainInfoByName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetTrustedDomainInfoByName" );
}

VOID
LsarEnumerateTrustedDomainsEx_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarEnumerateTrustedDomainsEx" );
}

VOID
LsarCreateTrustedDomainEx_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarCreateTrustedDomainEx" );
}

VOID
LsarQueryDomainInformationPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryDomainInformationPolicy" );
}

VOID
LsarSetDomainInformationPolicy_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetDomainInformationPolicy" );
}

VOID
LsarOpenTrustedDomainByName_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarOpenTrustedDomainByName" );
}

VOID
LsarSetPolicyReplicationHandle_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetPolicyReplicationHandle" );
}

VOID
LsarLookupNames3_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarLookupNames3" );
}

VOID
LsarQueryForestTrustInformation_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarQueryForestTrustInformation" );
}

VOID
LsarSetForestTrustInformation_notify (
    VOID
    )
{
    LsapServerRpcThreadReturnNotify( L"LsarSetForestTrustInformation" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\reglayer.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    reglayer.c

Abstract:

    Implemntation of LSA/Registry interface and support routines

Author:

    Mac McLain          (MacM)       Jan 17, 1997

Environment:

    User Mode

Revision History:

--*/
#include <lsapch2.h>
#include <dbp.h>


NTSTATUS
LsapRegReadObjectSD(
    IN  LSAPR_HANDLE            ObjectHandle,
    OUT PSECURITY_DESCRIPTOR   *ppSD
    )
/*++

Routine Description:

    This function will ready the security descriptor from the specified object

Arguments:

    ObjectHandle - Object to read the SD from
    ppSD -- Where the allocated security descriptor is returned.  Allocated via
            LsapAllocateLsaHeap.

Return Value:

    Pointer to allocated memory on success or NULL on failure

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    SecurityDescriptorLength = 0;

    Status = LsapDbReadAttributeObject(
                 ObjectHandle,
                 &LsapDbNames[SecDesc],
                 NULL,
                 &SecurityDescriptorLength
                 );

    if ( NT_SUCCESS(Status ) ) {

        //
        // Allocate a buffer from the Lsa Heap for the existing object's SD.
        //

        *ppSD = LsapAllocateLsaHeap( SecurityDescriptorLength );


        if ( *ppSD == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // Read the SD.  It is the value of the SecDesc subkey.
            //

            Status = LsapDbReadAttributeObject(
                         ObjectHandle,
                         &LsapDbNames[SecDesc],
                         *ppSD,
                         &SecurityDescriptorLength
                         );

            if ( !NT_SUCCESS( Status ) ) {

                LsapFreeLsaHeap( *ppSD );
                *ppSD = NULL;
            }

        }

    }


    return( Status );
}

NTSTATUS
LsapRegGetPhysicalObjectName(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN PUNICODE_STRING  LogicalNameU,
    OUT OPTIONAL PUNICODE_STRING PhysicalNameU
    )

/*++

Routine Description:

    This function returns the Physical Name of an object
    given an object information buffer.  Memory will be allocated for
    the Unicode String Buffers that will receive the name(s).


    The Physical Name of an object is the full path of the object relative
    to the root ot the Database.  It is computed by concatenating the Physical
    Name of the Container Object (if any), the Classifying Directory
    corresponding to the object type id, and the Logical Name of the
    object.

    <Physical Name of Object> =
        [<Physical Name of Container Object> "\"]
        [<Classifying Directory> "\"] <Logical Name of Object>

    If there is no Container Object (as in the case of the Policy object)
    the <Physical Name of Container Object> and following \ are omitted.
    If there is no Classifying Directory (as in the case of the Policy object)
    the <Classifying Directory> and following \ are omitted.  If neither
    Container Object not Classifying Directory exist, the Logical and Physical
    names coincide.

    Note that memory is allocated by this routine for the output
    Unicode string buffer(s).  When the output Unicode String(s) are no
    longer needed, the memory must be freed by call(s) to
    RtlFreeUnicodeString().


Arguments:

    ObjectInformation - Pointer to object information containing as a minimum
        the object's Logical Name, Container Object's handle and object type
        id.

    LogicalNameU - Optional pointer to Unicode String structure which will
        receive the Logical Name of the object.  A buffer will be allocated
        by this routine for the name text.  This memory must be freed when no
        longer needed by calling RtlFreeUnicodeString() wiht a pointer such
        as LogicalNameU to the Unicode String structure.

    PhysicalNameU - Optional pointer to Unicode String structure which will
       receive the Physical Name of the object.  A buffer will be allocated by
       this routine for the name text.  This memory must be freed when no
       longer needed by calling RtlFreeUnicodeString() with a pointer such as
       PhysicalNameU to the Unicode String structure.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources to
            allocate the name string buffer for the Physical Name or
            Logical Name.
--*/
{
    NTSTATUS    Status;
    PUNICODE_STRING ContainerPhysicalNameU = NULL;
    PUNICODE_STRING ClassifyingDirU = NULL;
    UNICODE_STRING IntermediatePath1U;
    PUNICODE_STRING JoinedPath1U = &IntermediatePath1U;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId = ObjectInformation->ObjectTypeId;
    POBJECT_ATTRIBUTES ObjectAttributes = &ObjectInformation->ObjectAttributes;

    //
    // Initialize
    //

    RtlInitUnicodeString( &IntermediatePath1U, NULL );

    //
    // The Physical Name of the object is requested.  Construct this
    // in stages.  First, get the Container Object Physical Name from
    // the handle stored inside ObjectAttributes.
    //

    if (ObjectAttributes->RootDirectory != NULL) {

        ContainerPhysicalNameU =
            &(((LSAP_DB_HANDLE)
                ObjectAttributes->RootDirectory)->PhysicalNameU);
    }

    //
    // Next, get the Classifying Directory name appropriate to the
    // object type.
    //

    if (LsapDbContDirs[ObjectTypeId].Length != 0) {

        ClassifyingDirU = &LsapDbContDirs[ObjectTypeId];
    }

    //
    // Now join the Physical Name of the Container Object and Classifying
    // Directory together.  If there is no Container Object and no
    // Classifying Directory, just set the result to NULL.
    //

    if (ContainerPhysicalNameU == NULL && ClassifyingDirU == NULL) {

        JoinedPath1U = NULL;

    } else {

        Status = LsapDbJoinSubPaths(
                     ContainerPhysicalNameU,
                     ClassifyingDirU,
                     JoinedPath1U
                     );

        if (!NT_SUCCESS(Status)) {

            goto GetNamesError;
        }
    }

    //
    // Now join the Physical Name of the Containing Object, Classifying
    // Directory  and Logical Name of the object together.  Note that
    // JoinedPath1U may be NULL, but LogicalNameU is never NULL.
    //

    Status = LsapDbJoinSubPaths(
                 JoinedPath1U,
                 LogicalNameU,
                 PhysicalNameU
                 );
    if (JoinedPath1U != NULL) {

        RtlFreeUnicodeString( JoinedPath1U );
        JoinedPath1U = NULL;  // so we don't try to free it again
    }

    if (!NT_SUCCESS(Status)) {

        goto GetNamesError;
    }

    goto GetNamesFinish;

GetNamesError:

    //
    // If necessary, free any string buffer allocated to JoinedPath1U
    //

    if (JoinedPath1U != NULL) {

        RtlFreeUnicodeString( JoinedPath1U );
    }

GetNamesFinish:

    return( Status );
}


NTSTATUS
LsapRegOpenObject(
    IN LSAP_DB_HANDLE  ObjectHandle,
    IN ULONG  OpenMode,
    OUT PVOID  *pvKey
    )
/*++

Routine Description:

    Opens the object in the LSA registry database

Arguments:

    ObjectHandle - Internal LSA object handle

    OpenMode - How to open the object

    pvKey - Where the key is returned

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES OpenKeyObjectAttributes;


    //
    // Setup Object Attributes structure for opening the Registry key of
    // the object.  Specify as path the Physical Name of the object, this
    // being the path of the object's Registry Key relative to the
    // LSA Database root key.
    //

    InitializeObjectAttributes(
        &OpenKeyObjectAttributes,
        &(ObjectHandle->PhysicalNameU),
        OBJ_CASE_INSENSITIVE,
        LsapDbState.DbRootRegKeyHandle,
        NULL
        );

    //
    // Now attempt to open the object's Registry Key.  Store the Registry
    // Key handle in the object's handle.
    //

    Status = RtlpNtOpenKey(
                 (PHANDLE) pvKey,
                 KEY_READ | KEY_WRITE,
                 &OpenKeyObjectAttributes,
                 0L
                 );

    return( Status );
}


NTSTATUS
LsapRegOpenTransaction(
    )
/*++

Routine Description:

    This function starts a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegOpenTransaction\n" ));

    LsapDbLockAcquire( &LsapDbState.RegistryLock );

    ASSERT( LsapDbState.RegistryTransactionOpen == FALSE );


    Status = RtlStartRXact(LsapDbState.RXactContext);

    ASSERT( NT_SUCCESS( Status ) || Status == STATUS_NO_MEMORY );

    if ( NT_SUCCESS( Status ) ) {

        LsapDbState.RegistryTransactionOpen = TRUE;
        LsapDbState.RegistryModificationCount = 0;
    } else {

        LsapDbLockRelease( &LsapDbState.RegistryLock );
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegOpenTransaction: 0x%lx\n", Status ));

    return Status;
}


NTSTATUS
LsapRegApplyTransaction(
    )

/*++

Routine Description:

    This function applies a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    ObjectHandle - Handle to an LSA object.  This is expected to have
        already been validated.

    Options - Specifies optional actions to be taken.  The following
        options are recognized, other options relevant to calling routines
        are ignored.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit notification to
            Replicator.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegApplyTransaction\n" ));

    //
    ASSERT( LsapDbState.RegistryTransactionOpen == TRUE );

    //
    // Apply the Registry Transaction.
    //

    if ( LsapDbState.RegistryModificationCount > 0 ) {

        Status = RtlApplyRXact(LsapDbState.RXactContext);

    } else {

        Status = RtlAbortRXact(LsapDbState.RXactContext);
    }



#if 0
    if( Status != STATUS_INSUFFICIENT_RESOURCES ) {

        ASSERT( NT_SUCCESS( Status ) );
    }
#endif


    if ( NT_SUCCESS( Status ) ) {

        LsapDbState.RegistryTransactionOpen = FALSE;
        LsapDbState.RegistryModificationCount = 0;

        LsapDbLockRelease( &LsapDbState.RegistryLock );
    }


    LsapDsDebugOut(( DEB_FTRACE, "LsapRegApplyTransaction: 0x%lx\n", Status ));

    return( Status );
}



NTSTATUS
LsapRegAbortTransaction(
    )

/*++

Routine Description:

    This function aborts a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegAbortTransaction\n" ));

    ASSERT( LsapDbState.RegistryTransactionOpen == TRUE );

    Status = RtlAbortRXact(LsapDbState.RXactContext);
    if ( NT_SUCCESS( Status ) ) {

        LsapDbState.RegistryTransactionOpen = FALSE;
        LsapDbState.RegistryModificationCount = 0;
    }

    ASSERT( NT_SUCCESS( Status ) );

    LsapDbLockRelease( &LsapDbState.RegistryLock );

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegAbortTransaction: 0x%lx\n", Status ));

    return( Status );
}




NTSTATUS
LsapRegCreateObject(
    IN PUNICODE_STRING  ObjectPath,
    IN LSAP_DB_OBJECT_TYPE_ID   ObjectType
    )
{
    NTSTATUS    Status;

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegCreateObject\n" ));

    Status = RtlAddActionToRXact(
                 LsapDbState.RXactContext,
                 RtlRXactOperationSetValue,
                 ObjectPath,
                 ObjectType,
                 NULL,        // No Key Value needed
                 0L
                 );

    if ( NT_SUCCESS( Status ) ) {
        LsapDbState.RegistryModificationCount++;
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegCreateObjectL 0x%lx\n", Status ));

    return( Status );
}





NTSTATUS
LsapRegDeleteObject(
    IN PUNICODE_STRING  ObjectPath
    )
{
    NTSTATUS    Status;

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegDeleteObject\n" ));

    Status = RtlAddActionToRXact(
                 LsapDbState.RXactContext,
                 RtlRXactOperationDelete,
                 ObjectPath,
                 0L,
                 NULL,
                 0
                 );

    if ( NT_SUCCESS( Status ) ) {
        LsapDbState.RegistryModificationCount++;
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegDeleteObject: 0x%lx\n", Status ));

    return( Status );
}



NTSTATUS
LsapRegWriteAttribute(
    IN PUNICODE_STRING  AttributePath,
    IN PVOID            pvAttribute,
    IN ULONG            AttributeLength
    )
{
    NTSTATUS    Status;

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegWriteAttribute\n" ));

    Status = RtlAddActionToRXact(
                 LsapDbState.RXactContext,
                 RtlRXactOperationSetValue,
                 AttributePath,
                 0L,
                 pvAttribute,
                 AttributeLength
                 );

    if ( NT_SUCCESS( Status ) ) {
        LsapDbState.RegistryModificationCount++;
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegWriteAttribute: 0x%lx\n", Status ));

    return( Status );
}



NTSTATUS
LsapRegDeleteAttribute(
    IN PUNICODE_STRING  AttributePath,
    IN BOOLEAN DeleteSecurely,
    IN ULONG AttributeLength
    )
/*++

Routine Description:

    Deletes a registry attribute

Arguments:

    AttributePath      full pathname of attribute to delete

    DeleteSecurely     fill value with zero prior to deletion?

    AttributeLength    number of bytes to fill with zero (must be equal to
                       actual length of the attribute for secure deletion to
                       work); ignored if DeleteSecurely is FALSE

Returns:

    STATUS_SUCCESS if happy

    STATUS_ error code otherwise

--*/
{
    NTSTATUS    Status;
    PBYTE       Buffer = NULL;

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegDeleteAttribute\n" ));

    if ( DeleteSecurely &&
         AttributeLength > 0 ) {

        Buffer = ( PBYTE )LsapAllocateLsaHeap( AttributeLength );

        if ( Buffer == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // NOTE: LsapAllocateLsaHeap returns memory that is zero-filled
        //       but even if it didn't, filling the secret value with
        //       random junk is just as good
        //

        Status = LsapRegWriteAttribute(
                     AttributePath,
                     Buffer,
                     AttributeLength
                     );

        if ( !NT_SUCCESS( Status )) {

            LsapFreeLsaHeap( Buffer );
            return Status;
        }
    }

    Status = RtlAddActionToRXact(
                 LsapDbState.RXactContext,
                 RtlRXactOperationDelete,
                 AttributePath,
                 0L,
                 NULL,
                 0
                 );

    if ( NT_SUCCESS( Status ) ) {
        LsapDbState.RegistryModificationCount++;
    }

    LsapDsDebugOut(( DEB_FTRACE, "LsapRegDeleteAttribute: 0x%lx\n", Status ));

    LsapFreeLsaHeap( Buffer );

    return( Status );
}

NTSTATUS
LsapRegReadAttribute(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeName,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength
    )
{
    //
    // The LSA Database is implemented as a subtree of the Configuration
    // Registry.  In this implementation, Lsa Database objects correspond
    // to Registry keys and "attributes" and their "values" correspond to
    // Registry "subkeys" and "values" of the Registry key representing the
    // object.
    //

    NTSTATUS Status, SecondaryStatus;
    ULONG SubKeyValueActualLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SubKeyHandle = NULL;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;

    //
    // Reading an attribute of an object is simpler than writing one,
    // because the Registry Transaction package is not used.  Since an
    // attribute is stored as the value of a subkey of the object's
    // Registry Key, we can simply call the Registry API RtlpNtReadKey
    // specifying the relative name of the subkey and the parent key's
    // handle.
    //
    // Prior to opening the subkey in the Registry, setup ObjectAttributes
    // containing the SubKey name and the Registry Handle for the LSA Database
    // Root.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        AttributeName,
        OBJ_CASE_INSENSITIVE,
        InternalHandle->KeyHandle,
        NULL
        );

    //
    // Open the subkey
    //

    Status = RtlpNtOpenKey(
                 &SubKeyHandle,
                 KEY_READ,
                 &ObjectAttributes,
                 0L
                 );

    if (!NT_SUCCESS(Status)) {

        SubKeyHandle = NULL; //For error processing
        return(Status);
    }

    //
    // Now query the size of the buffer required to read the subkey's
    // value.
    //

    SubKeyValueActualLength = *AttributeValueLength;


    //
    // If a NULL buffer parameter has been supplied or the size of the
    // buffer given is 0, this is just a size query.
    //

    if (!ARGUMENT_PRESENT(AttributeValue) || *AttributeValueLength == 0) {

        Status = RtlpNtQueryValueKey(
                     SubKeyHandle,
                     NULL,
                     NULL,
                     &SubKeyValueActualLength,
                     NULL
                     );

        if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) {

            *AttributeValueLength = SubKeyValueActualLength;
            Status = STATUS_SUCCESS;
            goto ReadAttError;

        } else {

            goto ReadAttError;
        }


    }

    //
    // Supplied buffer is large enough to hold the SubKey's value.
    // Query the value.
    //

    Status = RtlpNtQueryValueKey(
                 SubKeyHandle,
                 NULL,
                 AttributeValue,
                 &SubKeyValueActualLength,
                 NULL
                 );


    if( (Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status) ) {

        //
        // Return the length of the Sub Key.
        //

        *AttributeValueLength = SubKeyValueActualLength;

    }


ReadAttFinish:

    //
    // If necessary, close the Sub Key
    //

    if (SubKeyHandle != NULL) {

        SecondaryStatus = NtClose( SubKeyHandle );
    }

    return(Status);

ReadAttError:

    goto ReadAttFinish;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\crclient.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    crclient.c

Abstract:

    Local Security Authority - Client Cipher Routines

    These routines interface the LSA client side with the Cipher
    Routines.  They perform RPC-style memory allocation.

Author:

    Scott Birrell       (ScottBi)   	December 13, 1991

Environment:

Revision History:

--*/

#include <lsaclip.h>


NTSTATUS
LsapCrClientGetSessionKey(
    IN LSA_HANDLE ObjectHandle,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    )

/*++

Routine Description:

    This function obtains the Session Key, allocates an Cipher Key
    structure and returns the key.

Arguments:

    ObjectHandle - Handle from an LsaOpen<ObjectType> call.

    SessionKey - Receives a pointer to a structure containing the
       Session Key in which the memory has been allocated via
       MIDL_user_allocate().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            (e.g memory) to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_CR_CIPHER_KEY OutputSessionKey = NULL;
    ULONG OutputSessionKeyBufferLength;

    //
    // Allocate memory for the Session Key buffer and LSAP_CR_CIPHER_KEY
    // structure.
    //

    OutputSessionKeyBufferLength = sizeof (USER_SESSION_KEY);

    Status = STATUS_INSUFFICIENT_RESOURCES;

    OutputSessionKey = MIDL_user_allocate(
                           OutputSessionKeyBufferLength +
                           sizeof (LSAP_CR_CIPHER_KEY)
                           );

    if (OutputSessionKey == NULL) {

        goto ClientGetSessionKeyError;
    }

    //
    // Fill in the Cipher key structure, making the buffer point to
    // just beyond the header.
    //

    OutputSessionKey->Length = OutputSessionKeyBufferLength;
    OutputSessionKey->MaximumLength = OutputSessionKeyBufferLength;
    OutputSessionKey->Buffer = (PUCHAR) (OutputSessionKey + 1);

    Status = RtlGetUserSessionKeyClient(
                 ObjectHandle,
                 (PUSER_SESSION_KEY) OutputSessionKey->Buffer
                 );

    if (!NT_SUCCESS(Status)) {

        goto ClientGetSessionKeyError;
    }


ClientGetSessionKeyFinish:

    *SessionKey = OutputSessionKey;
    return(Status);

ClientGetSessionKeyError:

    goto ClientGetSessionKeyFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\crconv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    crconv.c

Abstract:

    This module contains credential conversion routines shared between advapi32.dll and crtest.exe

Author:

    Cliff Van Dyke (CliffV)    February 25, 2000

Revision History:

--*/


DWORD
CredpConvertStringSize (
    IN WTOA_ENUM WtoA,
    IN LPWSTR String OPTIONAL
    )

/*++

Routine Description:

    Determines the size of the converted string

Arguments:

    WtoA - Specifies the direction of the string conversion.

    String - The string to convert

Return Values:

    Returns the size (in bytes) of the converted string.

--*/

{
    ULONG Size = 0;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    if ( String == NULL ) {
        return Size;
    }

    switch ( WtoA ) {
    case DoWtoA:
        RtlInitUnicodeString( &UnicodeString, String );
        Size = RtlUnicodeStringToAnsiSize( &UnicodeString );
        break;

    case DoAtoW:
        RtlInitAnsiString( &AnsiString, (LPSTR)String );
        Size = RtlAnsiStringToUnicodeSize( &AnsiString );
        break;
    case DoWtoW:
        Size = (wcslen( String ) + 1) * sizeof(WCHAR);
        break;
    }

    return Size;

}

DWORD
CredpConvertString (
    IN WTOA_ENUM WtoA,
    IN LPWSTR String OPTIONAL,
    OUT LPWSTR *OutString,
    IN OUT LPBYTE *WherePtr
    )

/*++

Routine Description:

    Determines the size of the converted string

Arguments:

    WtoA - Specifies the direction of the string conversion.

    String - The string to convert

    OutString - Returns the pointer to the marshaled string

    WherePtr - Specifies the address of the first byte to write the string to.
        Returns a pointer to the first byte after the marshaled string

Return Values:

    Returns the status of the conversion


--*/

{
    NTSTATUS Status;

    ULONG Size;

    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPBYTE Where = *WherePtr;

    if ( String == NULL ) {
        *OutString = NULL;
        return NO_ERROR;
    }

    *OutString = (LPWSTR)Where;

    switch ( WtoA ) {
    case DoWtoA:
        RtlInitUnicodeString( &UnicodeString, String );
        AnsiString.Buffer = (PCHAR)Where;
        AnsiString.MaximumLength = 0xFFFF;
        Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );

        if ( !NT_SUCCESS(Status) ) {
            return RtlNtStatusToDosError( Status );
        }

        Where += AnsiString.Length + sizeof(CHAR);
        break;

    case DoAtoW:
        RtlInitAnsiString( &AnsiString, (LPSTR)String );
        UnicodeString.Buffer = (LPWSTR)Where;
        UnicodeString.MaximumLength = 0xFFFF;

        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );

        if ( !NT_SUCCESS(Status) ) {
            return RtlNtStatusToDosError( Status );
        }

        Where += UnicodeString.Length + sizeof(WCHAR);

        break;
    case DoWtoW:
        Size = (wcslen( String ) + 1) * sizeof(WCHAR);

        RtlCopyMemory( Where, String, Size );
        Where += Size;
        break;
    }

    *WherePtr = Where;
    return NO_ERROR;

}

DWORD
CredpConvertOneCredentialSize (
    IN WTOA_ENUM WtoA,
    IN PCREDENTIALW InCredential
    )

/*++

Routine Description:

    Computes the size of a converted credential

Arguments:

    WtoA - Specifies the direction of the string conversion.

    InCredential - Input credential

Return Values:

    Returns the size (in bytes) the CredpConvertOneCredential will need to
        copy this credential into a buffer.

--*/

{
    DWORD WinStatus;
    ULONG Size;

    ULONG i;

    //
    // Compute the initial size
    //

    Size = ROUND_UP_COUNT( sizeof(ENCRYPTED_CREDENTIALW), ALIGN_WORST ) +
           ROUND_UP_COUNT( InCredential->AttributeCount * sizeof(CREDENTIAL_ATTRIBUTEW), ALIGN_WORST );

    if ( InCredential->CredentialBlobSize != 0 ) {
        ULONG CredBlobSize;

        // Leave room for the encoding over the wire
        CredBlobSize = AllocatedCredBlobSize( InCredential->CredentialBlobSize );

        // Align the data following the credential blob
        Size += ROUND_UP_COUNT( CredBlobSize, ALIGN_WORST );
    }


    //
    // Compute the size of the strings in the right character set.
    //

    Size += CredpConvertStringSize( WtoA, InCredential->TargetName );
    Size += CredpConvertStringSize( WtoA, InCredential->Comment );
    Size += CredpConvertStringSize( WtoA, InCredential->TargetAlias );
    Size += CredpConvertStringSize( WtoA, InCredential->UserName );

    //
    // Compute the size of the attributes
    //

    if ( InCredential->AttributeCount != 0 ) {

        for ( i=0; i<InCredential->AttributeCount; i++ ) {

            Size += CredpConvertStringSize( WtoA, InCredential->Attributes[i].Keyword );

            Size += ROUND_UP_COUNT(InCredential->Attributes[i].ValueSize, ALIGN_WORST);

        }
    }

    Size = ROUND_UP_COUNT( Size, ALIGN_WORST );

    return Size;

}

DWORD
CredpConvertOneCredential (
    IN WTOA_ENUM WtoA,
    IN ENCODE_BLOB_ENUM DoDecode,
    IN PCREDENTIALW InCredential,
    IN OUT LPBYTE *WherePtr
    )

/*++

Routine Description:

    Converts one credential from Ansi to Unicode or vice-versa.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    DoDecode - Specifies whether CredentialBlob should be encoded, decoded, or neither.
        If DoBlobDecode, then InCredential really points to a PENCRYPTED_CREDENTIALW.

    InCredential - Input credentials

    WherePtr - Specifies the address of the first byte to write the credential to.
        On input, the strucure should be aligned ALIGN_WORST.
        Returns a pointer to the first byte after the marshaled credential.
        The output credential is actually a ENCRYPTED_CREDENTIALW.  The caller
        can use it as a CREDENTIALW depending on the DoDecode value.


Return Values:

    Window status code

--*/

{
    DWORD WinStatus;

    ULONG i;
    LPBYTE Where = *WherePtr;
    LPBYTE OldWhere;
    PENCRYPTED_CREDENTIALW OutCredential;


    //
    // Initialize the base structure
    //

    OutCredential = (PENCRYPTED_CREDENTIALW) Where;

    RtlZeroMemory( OutCredential, sizeof(*OutCredential) );
    Where += sizeof(*OutCredential);

    // Align the running pointer again
    OldWhere = Where;
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );


    //
    // Copy the fixed size data
    //

    OutCredential->Cred.Flags = InCredential->Flags;
    OutCredential->Cred.Type = InCredential->Type;
    OutCredential->Cred.LastWritten = InCredential->LastWritten;
    OutCredential->Cred.CredentialBlobSize = InCredential->CredentialBlobSize;
    OutCredential->Cred.Persist = InCredential->Persist;
    OutCredential->Cred.AttributeCount = InCredential->AttributeCount;

    //
    // Copy the data we don't know the alignment for.
    //  (ALIGN_WORST so our caller can't blame us.)
    //

    if ( InCredential->CredentialBlobSize != 0 ) {
        ULONG CredBlobSize;

        OutCredential->Cred.CredentialBlob = Where;
        RtlCopyMemory( Where, InCredential->CredentialBlob, InCredential->CredentialBlobSize );
        Where += InCredential->CredentialBlobSize;

        // Leave room for the encoding over the wire
        CredBlobSize = AllocatedCredBlobSize( InCredential->CredentialBlobSize );

        // Align the running pointer again
        OldWhere = Where;
        // Align the data following the credential blob
        Where = (LPBYTE) ROUND_UP_POINTER( OldWhere+(CredBlobSize-InCredential->CredentialBlobSize), ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );

        //
        //  Encode or decode the Credential blob as requested
        //

        switch (DoDecode) {
        case DoBlobDecode:
            OutCredential->ClearCredentialBlobSize = ((PENCRYPTED_CREDENTIALW)InCredential)->ClearCredentialBlobSize;
#ifndef _CRTEST_EXE_
            CredpDecodeCredential( OutCredential );
#endif // _CRTEST_EXE_
            break;
        case DoBlobEncode:
            OutCredential->ClearCredentialBlobSize = InCredential->CredentialBlobSize;
#ifndef _CRTEST_EXE_
            if (!CredpEncodeCredential( OutCredential ) ) {
                return ERROR_INVALID_PARAMETER;
            }
#endif // _CRTEST_EXE_
            break;
        case DoBlobNeither:
            OutCredential->ClearCredentialBlobSize = InCredential->CredentialBlobSize;
            break;
        default:
            return ERROR_INVALID_PARAMETER;
        }
    }

    if ( InCredential->AttributeCount != 0 ) {

        //
        // Push an array of attribute structs
        //
        OutCredential->Cred.Attributes = (PCREDENTIAL_ATTRIBUTEW) Where;
        Where += InCredential->AttributeCount * sizeof(CREDENTIAL_ATTRIBUTEW);

        // Align the running pointer again
        OldWhere = Where;
        Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );

        //
        // Fill it in.
        //

        for ( i=0; i<InCredential->AttributeCount; i++ ) {

            OutCredential->Cred.Attributes[i].Flags = InCredential->Attributes[i].Flags;
            OutCredential->Cred.Attributes[i].ValueSize = InCredential->Attributes[i].ValueSize;

            if ( InCredential->Attributes[i].ValueSize != 0 ) {
                OutCredential->Cred.Attributes[i].Value = Where;
                RtlCopyMemory( Where, InCredential->Attributes[i].Value, InCredential->Attributes[i].ValueSize );
                Where += InCredential->Attributes[i].ValueSize;

                // Align the running pointer again
                OldWhere = Where;
                Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
                RtlZeroMemory( OldWhere, Where-OldWhere );
            } else {
                OutCredential->Cred.Attributes[i].Value = NULL;
            }

        }
    }


    //
    // Convert the strings to the right character set.
    //

    WinStatus = CredpConvertString( WtoA, InCredential->TargetName, &OutCredential->Cred.TargetName, &Where );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpConvertString( WtoA, InCredential->Comment, &OutCredential->Cred.Comment, &Where );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpConvertString( WtoA, InCredential->TargetAlias, &OutCredential->Cred.TargetAlias, &Where );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpConvertString( WtoA, InCredential->UserName, &OutCredential->Cred.UserName, &Where );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    if ( InCredential->AttributeCount != 0 ) {

        for ( i=0; i<InCredential->AttributeCount; i++ ) {

            WinStatus = CredpConvertString( WtoA, InCredential->Attributes[i].Keyword, &OutCredential->Cred.Attributes[i].Keyword, &Where );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        }
    }

    // Align the running pointer again
    OldWhere = Where;
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );

    *WherePtr = Where;
    WinStatus = NO_ERROR;

    //
    // Be tidy
    //
Cleanup:

    return WinStatus;

}

#ifndef _CRTEST_EXE_
DWORD
APIENTRY
CredpConvertCredential (
    IN WTOA_ENUM WtoA,
    IN ENCODE_BLOB_ENUM DoDecode,
    IN PCREDENTIALW InCredential,
    OUT PCREDENTIALW *OutCredential
    )

/*++

Routine Description:

    Converts a credential from Ansi to Unicode or vice-versa.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    DoDecode - Specifies whether CredentialBlob should be encoded, decoded, or neither.

    InCredential - Input credentials

    OutCredential - Output credential
        This credential should be freed using MIDL_user_free.

Return Values:

    Window status code

--*/

{
    DWORD WinStatus;
    ULONG Size = 0;

    LPBYTE Where;

    //
    // BVTs pass NULL explicitly.  We could let the AV be caught in the try/except, but
    //  that would prevent them from being able to run under a debugger.  So, handle NULL
    //  explicitly.
    //

    if ( InCredential == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Use an exception handle to prevent bad user parameter from AVing in our code.
    //

#ifndef _CRTEST_EXE_
    try {
#endif // _CRTEST_EXE_

        //
        // Compute the size needed for the output credential
        //

        Size = CredpConvertOneCredentialSize( WtoA, InCredential );


        //
        // Allocate a buffer for the resultant credential
        //

        *OutCredential = (PCREDENTIALW) MIDL_user_allocate( Size );

        if ( *OutCredential == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Convert the credential into the allocated buffer
        //

        Where = (LPBYTE) *OutCredential;

        WinStatus = CredpConvertOneCredential( WtoA, DoDecode, InCredential, &Where );

        if ( WinStatus != NO_ERROR ) {
            MIDL_user_free( *OutCredential );
            *OutCredential = NULL;
        } else {
            ASSERT( (ULONG)(Where - ((LPBYTE)*OutCredential)) == Size );
        }
Cleanup: NOTHING;
#ifndef _CRTEST_EXE_
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = ERROR_INVALID_PARAMETER;
    }
#endif // _CRTEST_EXE_

    return WinStatus;

}

DWORD
APIENTRY
CredpConvertTargetInfo (
    IN WTOA_ENUM WtoA,
    IN PCREDENTIAL_TARGET_INFORMATIONW InTargetInfo,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *OutTargetInfo,
    OUT PULONG OutTargetInfoSize OPTIONAL
    )

/*++

Routine Description:

    Converts a target info from Ansi to Unicode or vice-versa.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    InTargetInfo - Input TargetInfo

    OutTargetInfo - Output TargetInfo
        This TargetInfo should be freed using CredFree.

    OutTargetInfoSize - Size (in bytes) of the buffer returned in OutTargetInfo

Return Values:

    Window status code

--*/

{
    DWORD WinStatus;
    ULONG Size;

    LPBYTE Where;

    *OutTargetInfo = NULL;

    //
    // BVTs pass NULL explicitly.  We could let the AV be caught in the try/except, but
    //  that would prevent them from being able to run under a debugger.  So, handle NULL
    //  explicitly.
    //

    if ( InTargetInfo == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Use an exception handle to prevent bad user parameter from AVing in our code.
    //
#ifndef _CRTEST_EXE_
    try {
#endif // _CRTEST_EXE_
        //
        // Compute the size needed for the output target info
        //

        Size = sizeof(CREDENTIAL_TARGET_INFORMATIONW);


        //
        // Compute the size of the strings in the right character set.
        //

        Size += CredpConvertStringSize( WtoA, InTargetInfo->TargetName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->NetbiosServerName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->DnsServerName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->NetbiosDomainName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->DnsDomainName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->DnsTreeName );
        Size += CredpConvertStringSize( WtoA, InTargetInfo->PackageName );
        Size += InTargetInfo->CredTypeCount * sizeof(DWORD);


        //
        // Allocate a buffer for the resultant credential
        //

        *OutTargetInfo = (PCREDENTIAL_TARGET_INFORMATIONW) MIDL_user_allocate( Size );

        if ( *OutTargetInfo == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( ARGUMENT_PRESENT(OutTargetInfoSize) ) {
            *OutTargetInfoSize = Size;
        }
        Where = (LPBYTE)((*OutTargetInfo) + 1);


        //
        // Copy the fixed size data
        //

        (*OutTargetInfo)->Flags = InTargetInfo->Flags;

        //
        // Copy the DWORD aligned data
        //

        (*OutTargetInfo)->CredTypeCount = InTargetInfo->CredTypeCount;
        if ( InTargetInfo->CredTypeCount != 0 ) {
            (*OutTargetInfo)->CredTypes = (LPDWORD) Where;
            RtlCopyMemory( Where, InTargetInfo->CredTypes, InTargetInfo->CredTypeCount * sizeof(DWORD) );
            Where += InTargetInfo->CredTypeCount * sizeof(DWORD);
        } else {
            (*OutTargetInfo)->CredTypes = NULL;
        }


        //
        // Convert the strings to the right character set.
        //

        WinStatus = CredpConvertString( WtoA, InTargetInfo->TargetName, &(*OutTargetInfo)->TargetName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->NetbiosServerName, &(*OutTargetInfo)->NetbiosServerName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->DnsServerName, &(*OutTargetInfo)->DnsServerName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->NetbiosDomainName, &(*OutTargetInfo)->NetbiosDomainName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->DnsDomainName, &(*OutTargetInfo)->DnsDomainName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->DnsTreeName, &(*OutTargetInfo)->DnsTreeName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        WinStatus = CredpConvertString( WtoA, InTargetInfo->PackageName, &(*OutTargetInfo)->PackageName, &Where );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        ASSERT( (ULONG)(Where - ((LPBYTE)*OutTargetInfo)) == Size );
Cleanup: NOTHING;
#ifndef _CRTEST_EXE_
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = ERROR_INVALID_PARAMETER;
    }
#endif // _CRTEST_EXE_

    //
    // Be tidy
    //
    if ( WinStatus != NO_ERROR ) {
        if ( *OutTargetInfo != NULL ) {
            MIDL_user_free( *OutTargetInfo );
            *OutTargetInfo = NULL;
        }
    }

    return WinStatus;

}
#endif // _CRTEST_EXE_

DWORD
CredpConvertCredentials (
    IN WTOA_ENUM WtoA,
    IN ENCODE_BLOB_ENUM DoDecode,
    IN PCREDENTIALW *InCredential,
    IN ULONG InCredentialCount,
    OUT PCREDENTIALW **OutCredential
    )

/*++

Routine Description:

    Converts a set of credentials from Ansi to Unicode or vice-versa.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    DoDecode - Specifies whether CredentialBlob should be encoded, decoded, or neither.

    InCredential - Input credentials

    OutCredential - Output credential
        This credential should be freed using MIDL_user_free.

Return Values:

    Window status code

--*/

{
    DWORD WinStatus;
    ULONG Size = 0;
    ULONG i;

    LPBYTE Where;
    LPBYTE OldWhere;

    *OutCredential = NULL;

    //
    // Use an exception handle to prevent bad user parameter from AVing in our code.
    //
#ifndef _CRTEST_EXE_
    try {
#endif // _CRTEST_EXE_

        //
        // Compute the size needed for the output credentials
        //

        for ( i=0; i<InCredentialCount; i++ ) {
            Size += CredpConvertOneCredentialSize( WtoA, InCredential[i] );
        }


        //
        // Allocate a buffer for the resultant credential array
        //

        Size += ROUND_UP_COUNT( InCredentialCount * sizeof(PCREDENTIALW), ALIGN_WORST );

        *OutCredential = (PCREDENTIALW *)MIDL_user_allocate( Size );

        if ( *OutCredential == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Convert the credential into the allocated buffer
        //

        Where = (LPBYTE) *OutCredential;
        Where += InCredentialCount * sizeof(PCREDENTIALW);

        // Align the running pointer again
        OldWhere = Where;
        Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );

        for ( i=0; i<InCredentialCount; i++ ) {

            //
            // Save a pointer to this credential
            //

            (*OutCredential)[i] = (PCREDENTIALW) Where;

            //
            // Marshal the credential
            //

            WinStatus = CredpConvertOneCredential( WtoA, DoDecode, InCredential[i], &Where );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }
        }

        ASSERT( (ULONG)(Where - ((LPBYTE)*OutCredential)) == Size );
        WinStatus = NO_ERROR;

Cleanup: NOTHING;
#ifndef _CRTEST_EXE_
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = ERROR_INVALID_PARAMETER;
    }
#endif // _CRTEST_EXE_

    if ( WinStatus != NO_ERROR ) {
        if ( *OutCredential != NULL ) {
            MIDL_user_free( *OutCredential );
            *OutCredential = NULL;
        }
    }

    return WinStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\ctlklsa.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ctlklsa.c

Abstract:

    Local Security Authority Subsystem - Short CT for Lsa LookupAccountName/Sid

    This is a small test that simply calls the LsaLookupName/Sid API once.

Usage:

    ctlklsa \\ServerName [-p] -a AccountName ... AccountName

        -p - pause before name and sid lookup operation
        -a - start of list of account names


Building Instructions:

    nmake UMTEST=ctlklsa UMTYPE=console

Author:


Environment:

Revision History:

--*/

#include "lsaclip.h"


VOID
DumpSID(
    IN PSID        s
    );

VOID
CtPause(
    );

#define LSA_WIN_STANDARD_BUFFER_SIZE           0x000000200L

VOID __cdecl
main(argc, argv)
int argc;
char **argv;
{
    NTSTATUS
        Status = STATUS_SUCCESS,
        SidStatus;

    ULONG
        Index,
        ArgCount = (ULONG) argc,
        DomainIndex,
        NameIndex,
        NameCount,
        DomainSidLength;

    ANSI_STRING
        NamesAnsi[ LSA_WIN_STANDARD_BUFFER_SIZE],
        SystemNameAnsi;

    UNICODE_STRING
        Names[ LSA_WIN_STANDARD_BUFFER_SIZE],
        SystemName;

    PUNICODE_STRING
        DomainName;

    PSID
        Sid = NULL,
        *Sids = NULL;

    SECURITY_QUALITY_OF_SERVICE
        SecurityQualityOfService;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    LSA_HANDLE
        PolicyHandle;

    PLSA_REFERENCED_DOMAIN_LIST
        ReferencedDomains = NULL,
        ReferencedSidsDomains = NULL;

    PLSA_TRANSLATED_SID
        TranslatedSids = NULL;

    PLSA_TRANSLATED_NAME
        TranslatedNames = NULL;

    UCHAR
        SubAuthorityCount;

    BOOLEAN
        Pause = FALSE,
        DoLookupSids = TRUE;

    if (argc < 4) {

        printf("usage:  ctlkacct <ServerName> [-p] -a <AccountName> [<AccountName> ...]\n\n");
        printf("        -p - pause before name and sid lookup operations\n");
        printf("        -a - start of list of account names\n\n");
        printf("example:\n");
        printf("        ctlklsa \\\\jimk -p -a interactive \"domain guests\" administrators\n\n");
        return;
    }

    NameIndex = 0;

    //
    // Capture argument 1, the Server Name
    //

    RtlInitString( &SystemNameAnsi, (PUCHAR) argv[1] );

    Status = RtlAnsiStringToUnicodeString(
                 &SystemName,
                 &SystemNameAnsi,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        goto MainError;
    }

    for (Index = 2; Index < ArgCount; Index++) {

        if (strncmp(argv[Index], "-p", 2) == 0) {

            //
            // The caller wants a pause before each lookup call.
            //

            Pause = TRUE;
        } else if (strncmp(argv[Index], "-a", 2) == 0) {

            Index++;

            while (Index < ArgCount) {

                if (strncmp(argv[Index], "-", 1) == 0) {

                    Index--;
                    break;
                }

                //
                // Capture the Account Name as a Unicode String.
                //

                RtlInitString( &NamesAnsi[ NameIndex ], argv[Index] );

                Status = RtlAnsiStringToUnicodeString(
                             &Names[ NameIndex ],
                             &NamesAnsi[ NameIndex ],
                             TRUE
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }

                NameIndex++;
                Index++;
            }

            if (Index == ArgCount) {

                break;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto MainError;
    }

    NameCount = NameIndex;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the LSA Policy Database for the target system.  This is the
    // starting point for the Name Lookup operation.
    //

    Status = LsaOpenPolicy(
                 &SystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if (!NT_SUCCESS(Status)) {

        goto MainError;
    }

    if (Pause) {

        printf( "\n\n..... Pausing before name lookup \n      ");
        CtPause(  );
    }


    //
    // Attempt to translate the Names to Sids.
    //

    Status = LsaLookupNames(
                 PolicyHandle,
                 NameCount,
                 Names,
                 &ReferencedDomains,
                 &TranslatedSids
                 );

    if (!NT_SUCCESS(Status)) {

        goto MainError;
    }

    //
    // Build the Sids from the output.
    //

    Sids = (PSID *) LocalAlloc( 0, NameCount * sizeof (PSID) );


    if (Sids == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto MainError;
    }


    for (NameIndex = 0; NameIndex < NameCount; NameIndex++) {

        if (TranslatedSids[NameIndex].Use == SidTypeUnknown) {

            Sids[NameIndex] = NULL;
            DoLookupSids = FALSE;

        } else {
            DomainIndex = TranslatedSids[NameIndex].DomainIndex;

            DomainSidLength = RtlLengthSid(
                                 ReferencedDomains->Domains[DomainIndex].Sid
                                 );


        
            Sid = (PSID) LocalAlloc( (UINT) 0, (UINT) (DomainSidLength + sizeof(ULONG)) );
        
            if (Sid == NULL) {
                printf(" ** ERROR - couldn't allocate heap !!\n");
                return;
            }
        
            RtlMoveMemory(
                Sid,
                ReferencedDomains->Domains[DomainIndex].Sid,
                DomainSidLength
                );

            if (TranslatedSids[NameIndex].Use != SidTypeDomain) {

                (*RtlSubAuthorityCountSid( Sid ))++;
                SubAuthorityCount = *RtlSubAuthorityCountSid( Sid );
                *RtlSubAuthoritySid(Sid,SubAuthorityCount - (UCHAR) 1) =
                    TranslatedSids[NameIndex].RelativeId;
            }

            Sids[NameIndex] = Sid;
        }
    }


    //
    // Pause before SID lookup...
    //

    if (!DoLookupSids) {
        printf("\n\n      Unknown Name causing sid lookup to be skipped\n");
    } else {
        if (Pause) {
        
            printf( "\n\n..... Pausing before SID lookup \n      ");
            CtPause();
        }
        
        //
        // Now translate the Sids back to Names
        //
        
        SidStatus = LsaLookupSids(
                        PolicyHandle,
                        NameCount,
                        (PSID *) Sids,
                        &ReferencedSidsDomains,
                        &TranslatedNames
                        );
    }

    /*
     * Print information returned by LookupAccountName
     */


    printf(
        "*********************************************\n"
        "Information returned by LookupAccountName\n"
        "*********************************************\n\n"
        );

    for (NameIndex = 0; NameIndex < NameCount; NameIndex++) {


        printf("   Name looked up:  *%wZ*\n", &Names[NameIndex]);

        printf("          Use = ");
        
        switch (TranslatedSids[NameIndex].Use) {
        
        case SidTypeUser:
        
              printf("SidTypeUser\n");
              break;
        
        case SidTypeGroup:
        
              printf("SidTypeGroup\n");
              break;
        
        case SidTypeDomain:
        
              printf("SidTypeDomain\n");
              break;
        
        case SidTypeAlias:
        
              printf("SidTypeAlias\n");
              break;
        
        case SidTypeWellKnownGroup:
        
            printf("SidTypeWellKnownGroup\n");
            break;
        
        case SidTypeDeletedAccount:
        
            printf("SidTypeDeletedAccount\n");
            break;
        
        case SidTypeInvalid:
        
            printf("SidTypeInvalid\n");
            break;
        
        case SidTypeUnknown:
        
            printf("SidTypeUnknown\n\n");
            break;
        
        default:
        
            printf("Hmmm - something unusual came back !!!! \n\n");
            break;
        
        }

        if (TranslatedSids[NameIndex].Use != SidTypeUnknown) {
        
            printf("          Sid = " );
            DumpSID((PSID) Sids[NameIndex]);
        
            DomainIndex = TranslatedSids[NameIndex].DomainIndex;
            DomainName = &ReferencedDomains->Domains[ DomainIndex ].Name;
        
            printf("          Referenced Domain Name = *%wZ*\n\n", DomainName );
        }
    }


    if (DoLookupSids) {
        printf(
            "*********************************************\n"
            "Information returned by LookupAccountSid\n"
            "*********************************************\n\n"
            );

        if (!NT_SUCCESS(SidStatus)) {
            printf(" Sid lookup failed.  Status 0x%lx\n"
                   " Dumping sids that were being looked up...\n",
                   SidStatus);
        }
        
        for (NameIndex = 0; NameIndex < NameCount; NameIndex++) {
        

            printf("   Sid = " );
            DumpSID((PSID) Sids[NameIndex]);

            if (NT_SUCCESS(SidStatus)) {
        
                printf("          Sid Use = ");
            
                switch (TranslatedNames[NameIndex].Use) {
                      
                case SidTypeUser:
              
                    printf("SidTypeUser\n");
                    break;
              
                case SidTypeGroup:
              
                    printf("SidTypeGroup\n");
                    break;
              
                case SidTypeDomain:
              
                    printf("SidTypeDomain\n");
                    break;
              
                case SidTypeAlias:
              
                    printf("SidTypeAlias\n");
                    break;
              
                case SidTypeWellKnownGroup:
              
                    printf("SidTypeWellKnownGroup\n");
                    break;
              
                case SidTypeDeletedAccount:
              
                    printf("SidTypeDeletedAccount\n");
                    break;
              
                case SidTypeInvalid:
              
                    printf("SidTypeInvalid\n");
                    break;
              
                case SidTypeUnknown:
              
                    printf("SidTypeUnknown\n");
                    break;
              
                default:
            
                    printf("Hmmm - unexpected value !!!\n");
                    break;
                }

                DomainIndex = TranslatedNames[NameIndex].DomainIndex;
                DomainName = &ReferencedSidsDomains->Domains[ DomainIndex ].Name;
                if (TranslatedNames[NameIndex].Use == SidTypeDomain) {
                    printf(
                        "          Domain Name = *%wZ*\n\n",
                        DomainName
                        );
                } else {
                    printf(
                        "          Account Name = *%wZ*\n"
                        "          Referenced Domain Name = *%wZ*\n\n",
                        &TranslatedNames[NameIndex].Name,
                        DomainName
                        );
                }
            }
        }
    }


MainFinish:

    return;

MainError:

    printf("Error: status = 0x%lx\n", Status);

    goto MainFinish;
}


VOID
DumpSID(
    IN PSID s
    )

{
    SID_IDENTIFIER_AUTHORITY
        *a;

    ULONG
        id = 0,
        i;

    BOOLEAN
        PrintValue = FALSE;

    try {


        a = GetSidIdentifierAuthority(s);

        printf("s-1-");

        for (i=0; i<5; i++) {
            if ((a->Value[i] != 0) || PrintValue) {
                printf("%02x", a->Value[i]);
                PrintValue = TRUE;
            }
        }
        printf("%02x", a->Value[5]);


        for (i = 0; i < (ULONG) *GetSidSubAuthorityCount(s); i++) {

            printf("-0x%lx", *GetSidSubAuthority(s, i));
        }


    } except (EXCEPTION_EXECUTE_HANDLER) {

        printf("<invalid pointer (0x%lx)>\n", s);
    }
    printf("\n");
}

VOID
CtPause(
    )
{
    CHAR
        IgnoreInput[300];

    printf("Press <ENTER> to continue . . .");
    gets( &IgnoreInput[0] );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\ctreg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ctreg.c

Abstract:

    Configuration Registry component test

    Needs to move from here

Author:

    Scott Birrell       (ScottBi)    June 5, 1991

Environment:

Revision History:

--*/


#include <string.h>
#include <nt.h>
#include <ntrtl.h>


#define CT_REG_INITIAL_KEY_COUNT 8L
#define CT_REG_INITIAL_LEVEL_COUNT 4L
#define CT_REG_KEY_VALUE_MAX_LENGTH 0x00000100L

//
// List of initial Registry keys to be set up.  The list must be
// kept so that moving linearly through it visits key nodes with top
// to bottom key traversal taking precedence over left-to-right.
//

typedef struct _CT_TEST_REGISTRY_KEY {
    ULONG KeyLevel;
    PUCHAR KeyName;
    ULONG KeyValueType;
    PUCHAR KeyValue;
    ULONG KeyValueLengthToQuery;
    ULONG KeyValueLengthToSet;
    NTSTATUS ExpectedStatus;
    HANDLE KeyHandle;
    HANDLE ParentKeyHandle;
} CT_TEST_REGISTRY_KEY, *PCT_TEST_REGISTRY_KEY;

CT_TEST_REGISTRY_KEY RegistryKeys[ CT_REG_INITIAL_KEY_COUNT ];

UCHAR KeyValue[CT_REG_KEY_VALUE_MAX_LENGTH];
ULONG KeyValueLengthToQuery;
ULONG KeyValueType;
LARGE_INTEGER LastWriteTime;

HANDLE ParentKeyHandle[CT_REG_INITIAL_LEVEL_COUNT + 1] =
   { NULL, NULL, NULL, NULL, NULL };

VOID
InitTestKey(
    IN ULONG KeyNumber,
    IN ULONG KeyLevel,
    IN PUCHAR KeyName,
    IN ULONG KeyNameLength,
    IN ULONG KeyValueType,
    IN PUCHAR KeyValue,
    IN ULONG KeyValueLengthToQuery,
    IN ULONG KeyValueLengthToSet,
    IN NTSTATUS ExpectedStatus
    );


VOID
CtRegExamineResult(
    IN ULONG KeyNumber,
    IN ULONG KeyValueType,
    IN PUCHAR KeyValue,
    IN ULONG KeyValueLength,
    IN NTSTATUS ReturnedStatus
    );


VOID
CtCreateSetQueryKey();

VOID
CtOpenMakeTempCloseKey();


VOID
main ()
{
    CtCreateSetQueryKey();

    CtOpenMakeTempCloseKey();

}




VOID
CtCreateSetQueryKey(
    )

/*++

Routine Description:

    This function tests the RtlpNtOpenKey RtlpNtCreateKey and NtClose API.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    //
    // Set up a test hierarchy of keys
    //

    ULONG KeyNumber;
    ULONG ZeroLength;
    STRING Name;
    UNICODE_STRING UnicodeName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    ZeroLength = 0L;

    DbgPrint("Start of Create, Set, Query Registry Key Test\n");

    //
    // Initialize the test array.  I did it this way because a statically
    // initialized table is harder to read.
    //

    InitTestKey(
        0,
        0,
        "\\Registry\\RLM",
        sizeof ("\\Registry\\RLM"),
        0,
        "Level 0 - RLM",
        sizeof ("\\Registry\\RLM") - 1,
        sizeof ("\\Registry\\RLM") - 1,
        STATUS_SUCCESS
        );

    InitTestKey(
        1,
        1,
        "Test",
        sizeof ("Test"),
        1,
        "Keyname Test - this value too big",
        6,
        sizeof ("Keyname Test - this value too big") -1,
        STATUS_BUFFER_OVERFLOW
        );

    InitTestKey(
        2,
        2,
        "SubTestA",
        sizeof("SubTestA"),
        2,
        "Keyname SubTestA - value small",
        30,
        sizeof ("Keyname SubTestA - value small") - 1,
        STATUS_SUCCESS
        );


    InitTestKey(
        3,
        3,
        "SSTestA",
        sizeof("SSTestA"),
        3,
        "Keyname SSTestA - zero length buffer",
        30,
        sizeof("Keyname SSTestA - zero length buffer") - 1,
        STATUS_BUFFER_OVERFLOW
        );

    InitTestKey(
        4,
        3,
        "SSTestB",
        sizeof("SSTestB"),
        4,
        "Keyname SSTestB - value exact fit",
        sizeof ("Keyname SSTestB - value exact fit")  -1,
        sizeof ("Keyname SSTestB - value exact fit")  -1,
        STATUS_SUCCESS
        );

    InitTestKey(
        5,
        3,
        "SSTestC",
        sizeof("SSTestC"),
        5,
        "Keyname SSTestC - value small",
        40,
        sizeof ("Keyname SSTestC - value small")  -1,
        STATUS_SUCCESS
        );

    InitTestKey(
        6,
        3,
        "SSTestD",
        sizeof("SSTestD"),
        6,
        "Keyname SSTestD - value small",
        40,
        sizeof ("Keyname SSTestD - value small")  -1,
        STATUS_SUCCESS
        );

    InitTestKey(
        7,
        3,
        "SSTestE",
        sizeof("SSTestD"),
        0,
        "Keyname SSTestD - no value set",
        40,
        0,
        STATUS_SUCCESS
        );

    DbgPrint("Start of Registry Test\n");

    //
    // Create all of the initial test registry keys
    //


    for (KeyNumber = 0; KeyNumber < CT_REG_INITIAL_KEY_COUNT; KeyNumber++) {

        RtlInitString(
            &Name,
            RegistryKeys[KeyNumber].KeyName
            );

        Status = RtlAnsiStringToUnicodeString(
                     &UnicodeName,
                     &Name,
                     TRUE );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("Security: Registry Init Ansi to Unicode failed 0x%lx\n",
                Status);
            return;
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeName,
            OBJ_CASE_INSENSITIVE,
            ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel],
            NULL
            );

        //
        // Remember the Parent Key handle
        //

        RegistryKeys[KeyNumber].ParentKeyHandle =
            ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel];

        //
        // Create the key if it does not already exist.  If key does exist,
        // continue trying to create all of the other keys needed (for now).
        // Store the returned key handle as the parent key handle for the
        // next higher (child) level.
        //

        Status = RtlpNtCreateKey(
                     &RegistryKeys[KeyNumber].KeyHandle,
                     (KEY_READ | KEY_WRITE),
                     &ObjectAttributes,
                     0L,			// No options
                     NULL, 			// Default provider
                     NULL
                     );

        //
        // Save the Key's handle as the next level's parent handle.
        //

        ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1] =
            RegistryKeys[KeyNumber].KeyHandle;

        //
        // Free the memory allocated for the Unicode name
        //

        RtlFreeUnicodeString( &UnicodeName );

        if (NT_SUCCESS(Status) || Status == STATUS_OBJECT_NAME_COLLISION) {

            //
            // Set the key's value unless the length to set is zero.
            //

            if (RegistryKeys[KeyNumber].KeyValueLengthToSet != 0) {

                Status=RtlpNtSetValueKey(
                           ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel+1],
                           RegistryKeys[KeyNumber].KeyValueType,
                           RegistryKeys[KeyNumber].KeyValue,
                           RegistryKeys[KeyNumber].KeyValueLengthToSet
                           );
            }

            //
            // Read the key's value back
            //

            KeyValueLengthToQuery =
                RegistryKeys[KeyNumber].KeyValueLengthToQuery;

            Status = RtlpNtQueryValueKey(
                         ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1],
                         &KeyValueType,
                         KeyValue,
                         &KeyValueLengthToQuery,
                         &LastWriteTime
                         );

            //
            // Verify that the expected KeyValue, KeyLength and Status
            // were returned.
            //

            CtRegExamineResult(
                KeyNumber,
                KeyValueType,
                KeyValue,
                KeyValueLengthToQuery,
                Status
                );

            //
            // Test null pointer cases don't crash NtQueryValueKey
            //

            Status = RtlpNtQueryValueKey(
                         ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1],
                         NULL,   // No type
                         KeyValue,
                         &KeyValueLengthToQuery,
                         &LastWriteTime
                         );

            Status = RtlpNtQueryValueKey(
                         ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1],
                         &KeyValueType,
                         NULL,   // No value
                         &KeyValueLengthToQuery,
                         &LastWriteTime
                         );

            Status = RtlpNtQueryValueKey(
                         ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1],
                         &KeyValueType,
                         KeyValue,
                         NULL,    // No length
                         &LastWriteTime
                         );

            Status = RtlpNtQueryValueKey(
                         ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1],
                         &KeyValueType,
                         KeyValue,
                         &ZeroLength,  // Zero length
                         &LastWriteTime
                         );

            Status = RtlpNtQueryValueKey(
                         ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1],
                         &KeyValueType,
                         KeyValue,
                         &KeyValueLengthToQuery,
                         NULL   // No time
                         );
            //
            // Test null pointer cases don't crash NtSetValueKey
            //

            Status = RtlpNtSetValueKey(
                         ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel+1],
                         RegistryKeys[KeyNumber].KeyValueType,
                         NULL,  // No value, setting type only
                         RegistryKeys[KeyNumber].KeyValueLengthToSet
                         );
        } else {

            DbgPrint(
                "Key number %d creation failed 0x%lx\n",
                KeyNumber,
                Status
                );
        }
    }

    //
    // Close all the keys in the table
    //

    for (KeyNumber = 0; KeyNumber < CT_REG_INITIAL_KEY_COUNT; KeyNumber++) {

        Status = NtClose(
                     RegistryKeys[KeyNumber].KeyHandle
                     );

        if (!NT_SUCCESS(Status)) {

            DbgPrint("Closing KeyNumber %d failed 0x%lx\n", Status);
        }
    }

    DbgPrint("End of Create, Set, Query Registry Key Test\n");
}


VOID
CtRegExamineResult(
    IN ULONG KeyNumber,
    IN ULONG KeyValueType,
    IN PUCHAR KeyValue,
    IN ULONG KeyValueLengthReturned,
    IN NTSTATUS ReturnedStatus
    )

{
    ULONG KeyValueLengthToCompare;

    //
    // Check the status.  If bad, skip the other checks.
    //

    if (ReturnedStatus != RegistryKeys[KeyNumber].ExpectedStatus) {

        DbgPrint(
            "KeyNumber %d: RtlpNtQueryValueKey returned 0x%lx, expected 0x%lx\n",
            KeyNumber,
            ReturnedStatus,
            RegistryKeys[KeyNumber].ExpectedStatus
            );

    } else {

        //
        // Check that the Key Type is as expected.
        //


        if (KeyValueType != RegistryKeys[KeyNumber].KeyValueType) {

            DbgPrint(
                "KeyNumber %d: RtlpNtQueryValueKey returned KeyValueType 0x%lx, \
                expected 0x%lx\n",
                KeyNumber,
                KeyValueType,
                RegistryKeys[KeyNumber].KeyValueType
                );

        }

        //
        // Check that the Key Length is as expected.
        //


        if (KeyValueLengthReturned !=
            RegistryKeys[KeyNumber].KeyValueLengthToSet) {

            DbgPrint(
                "KeyNumber %d: RtlpNtQueryValueKey returned ValLength 0x%lx, \
                expected 0x%lx\n",
                KeyNumber,
                KeyValueLengthReturned,
                RegistryKeys[KeyNumber].KeyValueLengthToSet
                );

        }

        //
        // Check that the Key Value is as expected.  Distinguish between
        // Buffer truncated cases and regular cases.
        //

        if (RegistryKeys[KeyNumber].KeyValueLengthToSet != 0L) {

            //
            // Determine the length of returned key value to compare.  This is
            // the min of the set length and and the size of the return
            // buffer.
            //

            KeyValueLengthToCompare =
                RegistryKeys[KeyNumber].KeyValueLengthToSet;

            if (KeyValueLengthToCompare >
                RegistryKeys[KeyNumber].KeyValueLengthToQuery) {

                KeyValueLengthToCompare =
                     RegistryKeys[KeyNumber].KeyValueLengthToQuery;
            }


            if (strncmp(
                    KeyValue,
                    RegistryKeys[KeyNumber].KeyValue,
                    KeyValueLengthToCompare
                    ) != 0) {

                //
                // Output approriate error message.  Message contains
                // "truncated.." if key value should have been truncated
                //

                if (RegistryKeys[KeyNumber].KeyValueLengthToSet >
                    RegistryKeys[KeyNumber].KeyValueLengthToQuery) {

                    DbgPrint(
                        "KeyNumber %d: RtlpNtQueryValueKey returned KeyValue %s, \
                        expected %s truncated to %d characters\n",
                        KeyNumber,
                        KeyValue,
                        RegistryKeys[KeyNumber].KeyValue,
                        RegistryKeys[KeyNumber].KeyValueLengthToQuery
                        );

                } else {

                    DbgPrint(
                        "KeyNumber %d: RtlpNtQueryValueKey returned KeyValue %s, \
                        expected %s\n",
                        KeyNumber,
                        KeyValue,
                        RegistryKeys[KeyNumber].KeyValue
                        );
                }
            }
        }
    }
}




VOID
CtOpenMakeTempCloseKey()

/*++

Routine Description:

    This function tests NtDeleteKey by deleting the CT configuration

Arguments:

    None.

Return Value:

    None

--*/

{
    ULONG KeyNumber;
    ULONG KeyLevel;
    STRING Name;
    UNICODE_STRING UnicodeName;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;

    //
    // Open all of the initial test registry keys for write and delete
    // access, set, query and delete each key.
    //

    DbgPrint("Start of Open Make Temp and Close Delete Registry Key Test\n");

    //
    // First, set all of the Parent handles to NULL
    //

    for (KeyNumber = 0; KeyNumber < CT_REG_INITIAL_KEY_COUNT; KeyNumber++) {

        RegistryKeys[KeyNumber].ParentKeyHandle = NULL;
    }

    for (KeyLevel = 0; KeyLevel < CT_REG_INITIAL_LEVEL_COUNT; KeyLevel++) {

        ParentKeyHandle[KeyLevel] = NULL;
    }

    for (KeyNumber = 0; KeyNumber < CT_REG_INITIAL_KEY_COUNT; KeyNumber++) {

        RtlInitString(
            &Name,
            RegistryKeys[KeyNumber].KeyName
            );

        Status = RtlAnsiStringToUnicodeString(
                     &UnicodeName,
                     &Name,
                     TRUE );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("Security: Registry Init Ansi to Unicode failed 0x%lx\n",
                Status);
            return;
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeName,
            OBJ_CASE_INSENSITIVE,
            ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel],
            NULL
            );

        //
        // Open the key and store the returned key handle as the parent key
        // handle for the next higher (child) level.
        //

        Status = RtlpNtOpenKey(
                     &RegistryKeys[KeyNumber].KeyHandle,
                     (KEY_READ | KEY_WRITE | DELETE),
                     &ObjectAttributes,
                     0L   			// No options
                     );

        if (!NT_SUCCESS(Status)) {

            DbgPrint(
                "NtOpenKey - KeyNumber %d failed 0x%lx\n",
                KeyNumber,
                Status
                );
        }

        //
        // Save the Key's handle as the next level's parent handle.
        //

        ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1] =
            RegistryKeys[KeyNumber].KeyHandle;

        //
        // Free the memory allocated for the Unicode name
        //

        RtlFreeUnicodeString( &UnicodeName );

        if (NT_SUCCESS(Status) || Status == STATUS_OBJECT_NAME_COLLISION) {

            //
            // Set the key's value unless the length to set is zero.
            //

            if (RegistryKeys[KeyNumber].KeyValueLengthToSet != 0) {

                Status=RtlpNtSetValueKey(
                           ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel+1],
                           RegistryKeys[KeyNumber].KeyValueType,
                           RegistryKeys[KeyNumber].KeyValue,
                           RegistryKeys[KeyNumber].KeyValueLengthToSet
                           );
            }

            //
            // Read the key's value back
            //

            KeyValueLengthToQuery =
                RegistryKeys[KeyNumber].KeyValueLengthToQuery;

            Status = RtlpNtQueryValueKey(
                         ParentKeyHandle[RegistryKeys[KeyNumber].KeyLevel + 1],
                         &KeyValueType,
                         KeyValue,
                         &KeyValueLengthToQuery,
                         &LastWriteTime
                         );

            //
            // Verify that the expected KeyValue, KeyLength and Status
            // were returned.
            //

            CtRegExamineResult(
                KeyNumber,
                KeyValueType,
                KeyValue,
                KeyValueLengthToQuery,
                Status
                );

        } else {

            DbgPrint(
                "Key number %d open failed 0x%lx\n",
                KeyNumber,
                Status
                );
        }
    }

    //
    // Make Temporary and Close all the keys in the table
    //

    for (KeyNumber = CT_REG_INITIAL_KEY_COUNT-1; KeyNumber != 0L; KeyNumber--) {

        Status = RtlpNtMakeTemporaryKey( RegistryKeys[KeyNumber].KeyHandle );

        if (!NT_SUCCESS(Status)) {

            DbgPrint(
                "Making Temporary KeyNumber %d failed 0x%lx\n",
                KeyNumber,
                Status
                );
        }

        Status = NtClose(
                     RegistryKeys[KeyNumber].KeyHandle
                     );

        if (!NT_SUCCESS(Status)) {

            DbgPrint(
                "Closing KeyNumber %d failed 0x%lx\n",
                KeyNumber,
                Status
                );
        }
    }

    DbgPrint("End of Open Mk Temp and Close Registry Key Test\n");
}


VOID
InitTestKey(
    IN ULONG KeyNumber,
    IN ULONG KeyLevel,
    IN PUCHAR KeyName,
    IN ULONG KeyNameLength,
    IN ULONG KeyValueType,
    IN PUCHAR KeyValue,
    IN ULONG KeyValueLengthToQuery,
    IN ULONG KeyValueLengthToSet,
    IN NTSTATUS ExpectedStatus
    )

/*++

Routine Description:

    This function initializes an entry in the array of test keys

Arguments:

    TBS.

Return Value:

--*/

{
     RegistryKeys[KeyNumber].KeyLevel = KeyLevel;
     RegistryKeys[KeyNumber].KeyName = KeyName;
     RegistryKeys[KeyNumber].KeyValueType = KeyValueType;
     RegistryKeys[KeyNumber].KeyValue = KeyValue;
     RegistryKeys[KeyNumber].KeyValueLengthToSet = KeyValueLengthToSet;
     RegistryKeys[KeyNumber].KeyValueLengthToQuery = KeyValueLengthToQuery;
     RegistryKeys[KeyNumber].ExpectedStatus = ExpectedStatus;
     RegistryKeys[KeyNumber].KeyHandle = NULL;
     RegistryKeys[KeyNumber].ParentKeyHandle = NULL;


     DBG_UNREFERENCED_PARAMETER (KeyNameLength);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\lsaclip.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaclip.h

Abstract:

    LSA - Client Side private includes

Author:

    Scott Birrell       (ScottBi)      January 23, 1992

Environment:

Revision History:

--*/

#include <lsacomp.h>
// #include "lsarpc_c.h"
#include <rpcndr.h>

NTSTATUS
LsapEncryptAuthInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION ClearAuthInfo,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL *EncryptedAuthInfo
);

NTSTATUS
LsapApiReturnResult(
    IN ULONG ExceptionCode
    );


NTSTATUS
LsapApiReturnResult(
    IN ULONG ExceptionCode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\ctlkacct.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ctlkacct.c

Abstract:

    Local Security Authority Subsystem - Short CT for Win 32 LookupAccountName/Sid

    This is a small test that simply calls the Win 32 LookupAccountName/Sid
    API once.

Usage:

    ctlkacct \\ServerName AccountName

Building Instructions:

    nmake UMTEST=ctlkacc UMTYPE=console

Author:

    Scott Birrell       (ScottBi)    July 20, 1992
    [ Adapted from a test written by TimF, not completely to Nt standards ]

Environment:

Revision History:

--*/

#include     <stdio.h>
#include     <windows.h>


VOID
DumpSID(
    IN PSID        s
    );

#define LSA_WIN_STANDARD_BUFFER_SIZE           0x000000200L

VOID __cdecl
main(argc, argv)
int argc;
char **argv;
{
    char                    SidFromLookupName[LSA_WIN_STANDARD_BUFFER_SIZE];
    char                    RefDFromLookupName[LSA_WIN_STANDARD_BUFFER_SIZE];
    DWORD                   cbSidFromLookupName, cchRefDFromLookupName;
    SID_NAME_USE            UseFromLookupName;

    DWORD                   cchNameFromLookupSid;
    char                    NameFromLookupSid[LSA_WIN_STANDARD_BUFFER_SIZE];
    char                    RefDFromLookupSid[LSA_WIN_STANDARD_BUFFER_SIZE];
    DWORD                   cchRefDFromLookupSid;
    SID_NAME_USE            UseFromLookupSid;
    BOOL                    BoolStatus = TRUE;
    DWORD                   LastError;

    if (argc != 3) {

        printf("usage:  ctlkacct <(char *)SystemName> <(char *)AccountName>\n");
        return(0);
    }

    cbSidFromLookupName = 0;
    cchRefDFromLookupName = 0;

    BoolStatus = LookupAccountName(argv[1],
                     argv[2],
                     (PSID)SidFromLookupName,
                     &cbSidFromLookupName,
                     RefDFromLookupName,
                     &cchRefDFromLookupName,
                     &UseFromLookupName
                     );

    if (BoolStatus) {

        printf(
            "LookupAccountName() with zero buffer sizes returned TRUE\n"
            );
    }

    //
    // Get the Last Error (in DOS errorcode from).
    //

    LastError = GetLastError();

    if (LastError != ERROR_INSUFFICIENT_BUFFER) {

        printf(
            "Unexpected Last Error %d returned from LookupAccountName\n"
            "Expected %d (ERROR_INSUFFICIENT_BUFFER)\n",
            LastError
            );
    }

    //
    // Now call LookupAccountName() again, using the buffer sizes returned.
    //

    BoolStatus = LookupAccountName(argv[1],
                     argv[2],
                     (PSID)SidFromLookupName,
                     &cbSidFromLookupName,
                     RefDFromLookupName,
                     &cchRefDFromLookupName,
                     &UseFromLookupName
                     );

    if (!BoolStatus) {

        printf(
            "LookupAccountName failed - \n"
            "LastError = %d\n",
            GetLastError()
            );

        return(0);
    }

    /*
     * Print information returned by LookupAccountName
     */

    printf(
        "*********************************************\n"
        "Information returned by LookupAccountName\n"
        "*********************************************\n\n"
        );

    printf( "Sid = " );
    DumpSID((PSID) SidFromLookupName);
    printf(
        "Size of Sid = %d\n",
        cbSidFromLookupName
        );

    printf(
        "Referenced Domain Name = %s\n"
        "Size of Referenced Domain Name = %d\n",
        RefDFromLookupName,
        cchRefDFromLookupName
        );

    printf("Name Use = ");

    switch (UseFromLookupName) {

    case SidTypeUser:

          printf("SidTypeUser\n");
          break;

    case SidTypeGroup:

          printf("SidTypeGroup\n");
          break;

    case SidTypeDomain:

          printf("SidTypeDomain\n");
          break;

    case SidTypeAlias:

          printf("SidTypeAlias\n");
          break;

    case SidTypeWellKnownGroup:

        printf("SidTypeWellKnownGroup\n");
        break;

    case SidTypeDeletedAccount:

        printf("SidTypeDeletedAccount\n");
        break;

    case SidTypeInvalid:

        printf("SidTypeInvalid\n");
        break;

    case SidTypeUnknown:

        printf("SidTypeUnknown\n");
        break;

    default:

        break;

    }

    cchNameFromLookupSid = 0;
    cchRefDFromLookupSid = 0;

    //
    // Now lookup the Sid we just obtained and see if we get the name back.
    // First, provide zero buffer sizes so that we get the sizes needed
    // returned.
    //

    cchNameFromLookupSid = 0;
    cchRefDFromLookupSid = 0;

    BoolStatus = LookupAccountSid(argv[1],
                     (PSID) SidFromLookupName,
                     NameFromLookupSid,
                     &cchNameFromLookupSid,
                     RefDFromLookupSid,
                     &cchRefDFromLookupSid,
                     &UseFromLookupSid
                     );

    if (BoolStatus) {

        printf("LookupAccountSid() with zero buffer sizes returned TRUE\n");
    }

    //
    // Get the Last Error (in DOS errorcode from).
    //

    LastError = GetLastError();

    if (LastError != ERROR_INSUFFICIENT_BUFFER) {

        printf(
            "Unexpected Last Error %d returned from LookupAccountSid\n"
            "Expected %d (ERROR_INSUFFICIENT_BUFFER)\n",
            LastError
            );
    }

    //
    // Now call LookupAccountSid() again, using the buffer sizes obtained
    // from the previous call.
    //

    if (!LookupAccountSid(argv[1],
            (PSID) SidFromLookupName,
            NameFromLookupSid,
            &cchNameFromLookupSid,
            RefDFromLookupSid,
            &cchRefDFromLookupSid,
            &UseFromLookupSid
            )) {

        printf(
            "LookupAccountSid failed\n"
            "LastError = %d\n",
            GetLastError()
            );

        return(0);
    }

    /*
     * Print information returned by LookupAccountSid
     */

    printf(
        "*********************************************\n"
        "Information returned by LookupAccountSid\n"
        "*********************************************\n\n"
        );

    printf(
        "Account Name = %s\n"
        "Account Name Size (chars) = %d\n"
        "Referenced Domain Name = %s\n"
        "Referenced Domain Size (chars) = %d\n",
        NameFromLookupSid,
        cchNameFromLookupSid,
        RefDFromLookupSid,
        cchRefDFromLookupSid
        );

    printf("Sid Use = ");

    switch (UseFromLookupSid) {

    case SidTypeUser:

        printf("SidTypeUser\n");
        break;

    case SidTypeGroup:

        printf("SidTypeGroup\n");
        break;

    case SidTypeDomain:

        printf("SidTypeDomain\n");
        break;

    case SidTypeAlias:

        printf("SidTypeAlias\n");
        break;

    case SidTypeWellKnownGroup:

        printf("SidTypeWellKnownGroup\n");
        break;

    case SidTypeDeletedAccount:

        printf("SidTypeDeletedAccount\n");
        break;

    case SidTypeInvalid:

        printf("SidTypeInvalid\n");
        break;

    case SidTypeUnknown:

        printf("SidTypeUnknown\n");
        break;

    default:

        break;
    }

    return(0);
}


VOID
DumpSID(
    IN PSID s
    )

{
    static char b[128];

    SID_IDENTIFIER_AUTHORITY *a;
    ULONG     id = 0, i;

    try {

        b[0] = '\0';

        a = GetSidIdentifierAuthority(s);

        sprintf(b, "s-0x1-%02x%02x%02x%02x%02x%02x", a -> Value[0],
        a -> Value[1], a -> Value[2], a -> Value[3], a ->
            Value[4], a -> Value[5]);

        for (i = 0; i < *GetSidSubAuthorityCount(s); i++) {

            sprintf(b, "%s-0x%lx", b, *GetSidSubAuthority(s, i));
        }

        printf("%s\n", b);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        if (*b) {

            printf("%s", b);
        }

        printf("<invalid pointer (0x%lx)>\n", s);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\credapi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credapi.c

Abstract:

    This module contains the RPC client side routines for the credential manager.

Author:

    Cliff Van Dyke (CliffV)    January 11, 2000

Revision History:

--*/

#include "lsaclip.h"
#include "align.h"
#include "credp.h"
#include <rpcasync.h>

DWORD
CredpNtStatusToWinStatus(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    Covert an NT Status code to a windows status code.

    There a enough funky status codes to justify this routine.

Arguments:

    Status - NT Status code to convert

Return Values:

    Windows status code.

--*/

{

    //
    // Some HRESULTS should simply be returned to the caller
    //

    if ( HRESULT_FACILITY(Status) == FACILITY_SCARD ) {
        return Status;
    }


    //
    // Translate all other status codes
    //
    switch ( Status ) {
    case STATUS_SUCCESS:
        return NO_ERROR;
    case STATUS_INVALID_ACCOUNT_NAME:
        return ERROR_BAD_USERNAME;
    case STATUS_INVALID_PARAMETER_1:
        return ERROR_INVALID_FLAGS;
    default:
        return RtlNtStatusToDosError( Status );
    }
}

BOOL
APIENTRY
CredpEncodeCredential (
    IN OUT PENCRYPTED_CREDENTIALW Credential
    )

/*++

Routine Description:

    This routine encodes sensitive credential data for passing via LPC to
    the LSA process.

Arguments:

    Credential - Specifies the credential to be encode.
        Encode the buffer in-place.  The caller must ensure there is extra space
        available in the buffer pointed to by Credential->CredentialBlob by allocating
        a buffer AlocatedCredBlobSize() bytes long.


Return Values:

    TRUE on success
    None

--*/

{
    NTSTATUS Status;

    //
    // If there is no credential blob,
    //  we're done.
    //

    if ( Credential->Cred.CredentialBlob == NULL ||
         Credential->Cred.CredentialBlobSize == 0 ) {

        Credential->Cred.CredentialBlob = NULL;
        Credential->Cred.CredentialBlobSize = 0;
        Credential->ClearCredentialBlobSize = 0;

    //
    // Otherwise RtlEncryptMemory it.
    //  (That's all we need since we're passing the buffer via LPC.)
    //

    } else {

        ULONG PaddingSize;

        //
        // Compute the real size of the passed in buffer
        //
        Credential->Cred.CredentialBlobSize = AllocatedCredBlobSize( Credential->ClearCredentialBlobSize );

        //
        // Clear the padding at the end to ensure we can compare encrypted blobs
        //
        PaddingSize = Credential->Cred.CredentialBlobSize -  Credential->ClearCredentialBlobSize;

        if ( PaddingSize != 0 ) {
            RtlZeroMemory( &Credential->Cred.CredentialBlob[Credential->ClearCredentialBlobSize],
                           PaddingSize );
        }

        Status = RtlEncryptMemory( Credential->Cred.CredentialBlob,
                                   Credential->Cred.CredentialBlobSize,
                                   RTL_ENCRYPT_OPTION_CROSS_PROCESS );

        if ( !NT_SUCCESS(Status)) {
            return FALSE;
        }


    }

    return TRUE;

}

BOOL
APIENTRY
CredpDecodeCredential (
    IN OUT PENCRYPTED_CREDENTIALW Credential
    )

/*++

Routine Description:

    This routine decodes sensitive credential data passed via LPC from
    the LSA process.

    The credential is decoded in-place.

Arguments:

    Credential - Specifies the credential to be decode.


Return Values:

    None

--*/

{
    NTSTATUS Status;

    //
    // Only decode data if it is there
    //

    if ( Credential->Cred.CredentialBlobSize != 0 ) {

        //
        // Sanity check the data
        //

        if ( Credential->Cred.CredentialBlobSize <
             Credential->ClearCredentialBlobSize ) {
            return FALSE;
        }


        //
        // Decrypt the data.
        //

        Status = RtlDecryptMemory( Credential->Cred.CredentialBlob,
                                   Credential->Cred.CredentialBlobSize,
                                   RTL_ENCRYPT_OPTION_CROSS_PROCESS );

        if ( !NT_SUCCESS(Status)) {
            return FALSE;
        }

        //
        // Set the used size of the buffer.
        //
        Credential->Cred.CredentialBlobSize = Credential->ClearCredentialBlobSize;

    }

    return TRUE;

}

//
// Include shared credential conversion ruotines
//

#include <crconv.c>

DWORD
CredpAllocStrFromStr(
    IN WTOA_ENUM WtoA,
    IN LPCWSTR InputString,
    IN BOOLEAN NullOk,
    OUT LPWSTR *OutString
    )

/*++

Routine Description:

    Convert a string to another format.

    Exceptions are caught.  So this routine can be used to capture user data.

Arguments:

    WtoA - Specifies the direction of the string conversion.

    InputString - Specifies the zero terminated string to convert.

    NullOk - if TRUE, a NULL string or zero length string is OK.

    OutputString - Converted zero terminated string.
        The buffer must be freed using MIDL_user_free.


Return Value:

    Status of the operation.

--*/

{
    DWORD WinStatus;
    ULONG Size;
    LPWSTR LocalString = NULL;
    LPBYTE Where;

    *OutString = NULL;

    //
    // Use an exception handle to prevent bad user parameter from AVing in our code.
    //
    try {

        //
        // Determine the size of the string buffer.
        //

        Size = CredpConvertStringSize ( WtoA, (LPWSTR)InputString );

        if ( Size == 0 ) {
            if ( NullOk ) {
                WinStatus = NO_ERROR;
            } else {
                WinStatus = ERROR_INVALID_PARAMETER;
            }
            goto Cleanup;
        }


        //
        // Allocate a buffer for the converted string
        //

        *OutString = MIDL_user_allocate( Size );

        if ( *OutString == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Covert the string
        //

        Where = (LPBYTE) *OutString;
        WinStatus = CredpConvertString ( WtoA,
                                         (LPWSTR)InputString,
                                         OutString,
                                         &Where );

Cleanup: NOTHING;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = ERROR_INVALID_PARAMETER;
    }

    //
    // Clean up
    //

    if ( WinStatus != NO_ERROR ) {
        if ( *OutString != NULL ) {
            MIDL_user_free( *OutString );
            *OutString = NULL;
        }
    }

    return WinStatus;

}



BOOL
APIENTRY
CredWriteA (
    IN PCREDENTIALA Credential,
    IN DWORD Flags
    )

/*++

Routine Description:

    The ANSI version of CredWriteW.

Arguments:

    See CredWriteW.

Return Values:

    See CredWriteW.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW EncodedCredential = NULL;

    //
    // Encode the credential before LPCing it to the LSA process and convert to UNICODE
    //

    WinStatus = CredpConvertCredential ( DoAtoW,                    // Ansi to Unicode
                                         DoBlobEncode,              // Encode
                                         (PCREDENTIALW)Credential,  // Input credential
                                         &EncodedCredential );      // Output credential

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrWrite(
                            NULL,   // This API is always local.
                            (PENCRYPTED_CREDENTIALW)EncodedCredential,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    MIDL_user_free( EncodedCredential );

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
CredWriteW (
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    )

/*++

Routine Description:

    The CredWrite API creates a new credential or modifies an existing
    credential in the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    The CredWrite API creates a credential if none already exists by the
    specified TargetName.  If the specified TargetName already exists, the
    specified credential replaces the existing one.

    The CredWrite API is available in ANSI and UNICODE versions.

Arguments:

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        ERROR_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        ERROR_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW EncodedCredential = NULL;

    //
    // Encode the credential before LPCing it to the LSA process.
    //

    WinStatus = CredpConvertCredential ( DoWtoW,                    // Unicode to Unicode
                                         DoBlobEncode,              // Encode
                                         (PCREDENTIALW)Credential,  // Input credential
                                         &EncodedCredential );      // Output credential

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrWrite(
                            NULL,   // This API is always local.
                            (PENCRYPTED_CREDENTIALW)EncodedCredential,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    MIDL_user_free( EncodedCredential );

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredReadA (
    IN LPCSTR TargetName,
    IN ULONG Type,
    IN DWORD Flags,
    OUT PCREDENTIALA *Credential
    )

/*++

Routine Description:

    The ANSI version of CredReadW.

Arguments:

    See CredReadW.

Return Values:

    See CredReadW.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW LocalCredential = NULL;
    LPWSTR UnicodeTargetName = NULL;

    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR) TargetName, FALSE, &UnicodeTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrRead(
                            NULL,   // This API is always local.
                            UnicodeTargetName,
                            Type,
                            Flags,
                            (PENCRYPTED_CREDENTIALW *)&LocalCredential );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;



    //
    // Decode the returned credential and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredential ( DoWtoA,        // Unicode to Ansi
                                             DoBlobDecode,  // Decode the credential blob
                                             LocalCredential,
                                             (PCREDENTIALW *)Credential );
    }


Cleanup:
    if ( UnicodeTargetName != NULL ) {
        MIDL_user_free( UnicodeTargetName );
    }
    if ( LocalCredential != NULL ) {
        MIDL_user_free( LocalCredential );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredReadW (
    IN LPCWSTR TargetName,
    IN ULONG Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    )

/*++

Routine Description:

    The CredRead API reads a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    The CredRead API is available in ANSI and UNICODE versions.

Arguments:

    TargetName - Specifies the name of the credential to read.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Credential - Returns a pointer to the credential.  The returned buffer
        must be freed by calling CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no credential with the specified TargetName.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW LocalCredential = NULL;
    LPWSTR UnicodeTargetName = NULL;

    //
    // Capture the input args
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, TargetName, FALSE, &UnicodeTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrRead(
                            NULL,   // This API is always local.
                            UnicodeTargetName,
                            Type,
                            Flags,
                            (PENCRYPTED_CREDENTIALW *)&LocalCredential );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    //
    // Decode the returned credential and align appropriate blobs to ALIGN_WORST bounday
    //
    if ( WinStatus == NO_ERROR ) {

        WinStatus = CredpConvertCredential ( DoWtoW,        // Unicode to Unicode
                                             DoBlobDecode,  // Decode the credential blob
                                             LocalCredential,
                                             Credential );
    }


Cleanup:
    if ( UnicodeTargetName != NULL ) {
        MIDL_user_free( UnicodeTargetName );
    }
    if ( LocalCredential != NULL ) {
        MIDL_user_free( LocalCredential );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredEnumerateA (
    IN LPCSTR Filter,
    IN DWORD Flags,
    OUT LPDWORD Count,
    OUT PCREDENTIALA **Credentials
    )

/*++

Routine Description:

    The ANSI version of CredEnumerateW

Arguments:

    See CredEnumerateW

Return Values:

    See CredEnumerateW

--*/

{
    DWORD WinStatus;
    CREDENTIAL_ARRAY CredentialArray;
    LPWSTR UnicodeFilter = NULL;

    //
    // Force RPC to allocate the return structure
    //

    *Count = 0;
    *Credentials = NULL;
    CredentialArray.CredentialCount = 0;
    CredentialArray.Credentials = NULL;


    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR)Filter, TRUE, &UnicodeFilter );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrEnumerate(
                            NULL,   // This API is always local.
                            UnicodeFilter,
                            Flags,
                            &CredentialArray );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    //
    // Decode the returned credentials and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredentials ( DoWtoA,        // Unicode to Ansi
                                              DoBlobDecode,  // Decode the credential blob
                                              (PCREDENTIALW *)CredentialArray.Credentials,
                                              CredentialArray.CredentialCount,
                                              (PCREDENTIALW **)Credentials );

        if ( WinStatus == NO_ERROR ) {
            *Count = CredentialArray.CredentialCount;
        }

    }


Cleanup:
    if ( CredentialArray.Credentials != NULL ) {
        MIDL_user_free( CredentialArray.Credentials );
    }

    if ( UnicodeFilter != NULL ) {
        MIDL_user_free( UnicodeFilter );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus) ;
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredEnumerateW (
    IN LPCWSTR Filter,
    IN DWORD Flags,
    OUT LPDWORD Count,
    OUT PCREDENTIALW **Credentials
    )

/*++

Routine Description:

    The CredEnumerate API enumerates the credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    The CredEnumerate API is available in ANSI and UNICODE versions.

Arguments:

    Filter - Specifies a filter for the returned credentials.  Only credentials
        with a TargetName matching the filter will be returned.  The filter specifies
        a name prefix followed by an asterisk.  For instance, the filter "FRED*" will
        return all credentials with a TargetName beginning with the string "FRED".

        If NULL is specified, all credentials will be returned.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The returned buffer must be freed by calling CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no credentials matching the specified Filter.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    CREDENTIAL_ARRAY CredentialArray;
    LPWSTR UnicodeFilter = NULL;

    //
    // Force RPC to allocate the return structure
    //

    *Count = 0;
    *Credentials = NULL;
    CredentialArray.CredentialCount = 0;
    CredentialArray.Credentials = NULL;


    //
    // Capture the user's input parameters
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, Filter, TRUE, &UnicodeFilter );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrEnumerate(
                            NULL,   // This API is always local.
                            UnicodeFilter,
                            Flags,
                            &CredentialArray );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;




    //
    // Decode the returned credentials and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredentials ( DoWtoW,        // Unicode to Unicode
                                              DoBlobDecode,  // Decode the credential blob
                                              (PCREDENTIALW *)CredentialArray.Credentials,
                                              CredentialArray.CredentialCount,
                                              Credentials );

        if ( WinStatus == NO_ERROR ) {
            *Count = CredentialArray.CredentialCount;
        }

    }


Cleanup:
    if ( CredentialArray.Credentials != NULL ) {
        MIDL_user_free( CredentialArray.Credentials );
    }

    if ( UnicodeFilter != NULL ) {
        MIDL_user_free( UnicodeFilter );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus) ;
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredWriteDomainCredentialsA (
    IN PCREDENTIAL_TARGET_INFORMATIONA TargetInfo,
    IN PCREDENTIALA Credential,
    IN DWORD Flags
    )

/*++

Routine Description:

    The ANSI version of CredWriteDomainCredentialsW

Arguments:

    See CredWriteDomainCredentialsW

Return Values:

    See CredWriteDomainCredentialsW

--*/

{
    DWORD WinStatus;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;
    PCREDENTIALW EncodedCredential = NULL;

    //
    // Encode the credential before LPCing it to the LSA process and convert to UNICODE
    //

    WinStatus = CredpConvertCredential ( DoAtoW,                    // Ansi to Unicode
                                         DoBlobEncode,              // Encode
                                         (PCREDENTIALW)Credential,  // Input credential
                                         &EncodedCredential );      // Output credential

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the target info to Unicode
    //

    WinStatus = CredpConvertTargetInfo( DoAtoW,                    // Ansi to Unicode
                                        (PCREDENTIAL_TARGET_INFORMATIONW) TargetInfo,
                                        &UnicodeTargetInfo,
                                        NULL );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrWriteDomainCredentials(
                            NULL,   // This API is always local.
                            UnicodeTargetInfo,
                            (PENCRYPTED_CREDENTIALW)EncodedCredential,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

Cleanup:
    if ( EncodedCredential != NULL ) {
        MIDL_user_free( EncodedCredential );
    }

    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}

BOOL
APIENTRY
CredWriteDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    )

/*++

Routine Description:

    The CredWriteDomainCredentials API writes a new domain
    credential to the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    CredWriteDomainCredentials differs from CredWrite in that it handles
    the idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsForestName.

    The CredWriteDomainCredentials API is available in ANSI and UNICODE versions.

Arguments:

    TargetInfo - Specifies the target information identifying the target server.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.


Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        ERROR_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        ERROR_INVALID_PARAMETER - None of the naming parameters were specified
            or the credential specified did not have the Type field set to
            CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE.

--*/

{
    DWORD WinStatus;
    PCREDENTIALW EncodedCredential = NULL;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Encode the credential before LPCing it to the LSA process
    //

    WinStatus = CredpConvertCredential ( DoWtoW,                    // Unicode to Unicode
                                         DoBlobEncode,              // Encode
                                         (PCREDENTIALW)Credential,  // Input credential
                                         &EncodedCredential );      // Output credential

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Capture the target info to prevent us from AVing in our code.
    //

    WinStatus = CredpConvertTargetInfo( DoWtoW,                    // Unicode to Unicode
                                        (PCREDENTIAL_TARGET_INFORMATIONW) TargetInfo,
                                        &UnicodeTargetInfo,
                                        NULL );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrWriteDomainCredentials(
                            NULL,   // This API is always local.
                            TargetInfo,
                            (PENCRYPTED_CREDENTIALW)EncodedCredential,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


Cleanup:
    if ( EncodedCredential != NULL ) {
        MIDL_user_free( EncodedCredential );
    }

    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}



BOOL
APIENTRY
CredReadDomainCredentialsA (
    IN PCREDENTIAL_TARGET_INFORMATIONA TargetInfo,
    IN DWORD Flags,
    OUT LPDWORD Count,
    OUT PCREDENTIALA **Credentials
    )

/*++

Routine Description:

    The ANSI version of CredReadDomainCredentialsW

Arguments:

    See CredReadDomainCredentialsW

Return Values:

    See CredReadDomainCredentialsW

--*/

{
    DWORD WinStatus;
    CREDENTIAL_ARRAY CredentialArray;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Force RPC to allocate the return structure
    //

    *Count = 0;
    *Credentials = NULL;
    CredentialArray.CredentialCount = 0;
    CredentialArray.Credentials = NULL;

    //
    // Convert the target info to Unicode
    //

    WinStatus = CredpConvertTargetInfo( DoAtoW,                    // Ansi to Unicode
                                        (PCREDENTIAL_TARGET_INFORMATIONW) TargetInfo,
                                        &UnicodeTargetInfo,
                                        NULL );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        NTSTATUS Status;

        //
        // Call RPC version of the API.

        Status = CredrReadDomainCredentials(
                            NULL,   // This API is always local.
                            UnicodeTargetInfo,
                            Flags,
                            &CredentialArray );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    //
    // Decode the returned credentials and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredentials ( DoWtoA,        // Unicode to Ansi
                                              DoBlobDecode,  // Decode the credential blob
                                              (PCREDENTIALW *)CredentialArray.Credentials,
                                              CredentialArray.CredentialCount,
                                              (PCREDENTIALW **)Credentials );

        if ( WinStatus == NO_ERROR ) {
            *Count = CredentialArray.CredentialCount;
        }

    }


Cleanup:
    if ( CredentialArray.Credentials != NULL ) {
        MIDL_user_free( CredentialArray.Credentials );
    }

    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus) ;
        return FALSE;
    }

    return TRUE;

}



BOOL
APIENTRY
CredReadDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN DWORD Flags,
    OUT LPDWORD Count,
    OUT PCREDENTIALW **Credentials
    )

/*++

Routine Description:

    The CredReadDomainCredentials API reads the domain credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    CredReadDomainCredentials differs from CredRead in that it handles the
    idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsForestName. This API returns
    the most specific credentials that match the naming parameters.  That is, if there
    is a credential that matches the target server name and a credential that matches
    the target domain name, only the server specific credential is returned.  This is
    the credential that would be used.

    The CredReadDomainCredentials API is available in ANSI and UNICODE versions.

Arguments:

    TargetInfo - Specifies the target information identifying the target ser

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_CACHE_TARGET_INFORMATION: The TargetInfo should be cached for a subsequent read via
            CredGetTargetInfo.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The most specific existing credential matching the TargetInfo is returned.
        If there is both a CRED_TYPE_DOMAIN_PASSWORD and CRED_TYPE_DOMAIN_CERTIFICATE
        credential, both are returned. If a connection were to be made to the named
        target, this most-specific credential would be used.

        The returned buffer must be freed by calling CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_INVALID_PARAMETER - None of the naming parameters were specified.

        ERROR_NOT_FOUND - There are no credentials matching the specified naming parameters.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    CREDENTIAL_ARRAY CredentialArray;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Force RPC to allocate the return structure
    //

    *Count = 0;
    *Credentials = NULL;
    CredentialArray.CredentialCount = 0;
    CredentialArray.Credentials = NULL;

    //
    // Capture the user's parameters to prevent AVing in our code.
    //

    WinStatus = CredpConvertTargetInfo( DoWtoW,                    // Unicode to Unicode
                                        (PCREDENTIAL_TARGET_INFORMATIONW) TargetInfo,
                                        &UnicodeTargetInfo,
                                        NULL );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        NTSTATUS Status;

        //
        // Call RPC version of the API.

        Status = CredrReadDomainCredentials(
                            NULL,   // This API is always local.
                            TargetInfo,
                            Flags,
                            &CredentialArray );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    //
    // Decode the returned credentials and align appropriate blobs to ALIGN_WORST bounday
    //

    if ( WinStatus == NO_ERROR ) {
        WinStatus = CredpConvertCredentials ( DoWtoW,        // Unicode to Unicode
                                              DoBlobDecode,  // Decode the credential blob
                                              (PCREDENTIALW *)CredentialArray.Credentials,
                                              CredentialArray.CredentialCount,
                                              Credentials );
        if ( WinStatus == NO_ERROR ) {
            *Count = CredentialArray.CredentialCount;
        }

    }

Cleanup:
    if ( CredentialArray.Credentials != NULL ) {
        MIDL_user_free( CredentialArray.Credentials );
    }

    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus) ;
        return FALSE;
    }

    return TRUE;

}


BOOL
APIENTRY
CredDeleteA (
    IN LPCSTR TargetName,
    IN ULONG Type,
    IN DWORD Flags
    )

/*++

Routine Description:

    The ANSI version of CredDeleteW

Arguments:

    See CredDeleteW

Return Values:

    See CredDeleteW

--*/

{
    DWORD WinStatus;
    LPWSTR UnicodeTargetName = NULL;

    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR)TargetName, FALSE, &UnicodeTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //
        Status = CredrDelete(
                            NULL,   // This API is always local.
                            UnicodeTargetName,
                            Type,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Be Tidy
    //
Cleanup:

    if ( UnicodeTargetName != NULL ) {
        MIDL_user_free( UnicodeTargetName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredDeleteW (
    IN LPCWSTR TargetName,
    IN ULONG Type,
    IN DWORD Flags
    )

/*++

Routine Description:

    The CredDelete API deletes a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    The CredDelete API is available in ANSI and UNICODE versions.

Arguments:

    TargetName - Specifies the name of the credential to delete.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no credential with the specified TargetName.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    LPWSTR UnicodeTargetName = NULL;

    //
    // Capture the input arguments
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, TargetName, FALSE, &UnicodeTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //
        Status = CredrDelete(
                            NULL,   // This API is always local.
                            UnicodeTargetName,
                            Type,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Be Tidy
    //
Cleanup:

    if ( UnicodeTargetName != NULL ) {
        MIDL_user_free( UnicodeTargetName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredRenameA (
    IN LPCSTR OldTargetName,
    IN LPCSTR NewTargetName,
    IN ULONG Type,
    IN DWORD Flags
    )

/*++

Routine Description:

    The ANSI version of CredRenameW

Arguments:

    See CredRenameW

Return Values:

    See CredRenameW

--*/

{
    DWORD WinStatus;
    LPWSTR UnicodeOldTargetName = NULL;
    LPWSTR UnicodeNewTargetName = NULL;

    //
    // Capture the input arguments
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPCWSTR)OldTargetName, FALSE, &UnicodeOldTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPCWSTR)NewTargetName, FALSE, &UnicodeNewTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //
        Status = CredrRename(
                            NULL,   // This API is always local.
                            UnicodeOldTargetName,
                            UnicodeNewTargetName,
                            Type,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Be Tidy
    //
Cleanup:

    if ( UnicodeOldTargetName != NULL ) {
        MIDL_user_free( UnicodeOldTargetName );
    }

    if ( UnicodeNewTargetName != NULL ) {
        MIDL_user_free( UnicodeNewTargetName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredRenameW (
    IN LPCWSTR OldTargetName,
    IN LPCWSTR NewTargetName,
    IN ULONG Type,
    IN DWORD Flags
    )

/*++

Routine Description:

    The CredRename API renames a credential in the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    The CredRename API is available in ANSI and UNICODE versions.

Arguments:

    OldTargetName - Specifies the current name of the credential to rename.

    NewTargetName - Specifies the new name of the credential.

    Type - Specifies the Type of the credential to rename
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no credential with the specified OldTargetName.

        ERROR_ALREADY_EXISTS - There is already a credential named NewTargetName.

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;
    LPWSTR UnicodeOldTargetName = NULL;
    LPWSTR UnicodeNewTargetName = NULL;

    //
    // Capture the input arguments
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, OldTargetName, FALSE, &UnicodeOldTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    WinStatus = CredpAllocStrFromStr( DoWtoW, NewTargetName, FALSE, &UnicodeNewTargetName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //
        Status = CredrRename(
                            NULL,   // This API is always local.
                            UnicodeOldTargetName,
                            UnicodeNewTargetName,
                            Type,
                            Flags );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Be Tidy
    //
Cleanup:

    if ( UnicodeOldTargetName != NULL ) {
        MIDL_user_free( UnicodeOldTargetName );
    }

    if ( UnicodeNewTargetName != NULL ) {
        MIDL_user_free( UnicodeNewTargetName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

VOID
APIENTRY
CredFree (
    IN PVOID Buffer
    )

/*++

Routine Description:

    The CredFree API de-allocates a buffer returned from the various other Credential API.

Arguments:

    Buffer -Specifies the buffer to be de-allocated.

Return Values:

    None


--*/

{
    MIDL_user_free( Buffer );
}


BOOL
APIENTRY
CredGetTargetInfoA (
    IN LPCSTR ServerName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONA *TargetInfo
    )

/*++

Routine Description:

    The ANSI version of CredGetTargetInfoW

Arguments:

    See CredGetTargetInfoW

Return Values:

    See CredGetTargetInfoW

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeServerName = NULL;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR)ServerName, FALSE, &UnicodeServerName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrGetTargetInfo(
                            NULL,   // This API is always local.
                            UnicodeServerName,
                            Flags,
                            &UnicodeTargetInfo );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the target info to ANSI
    //

    WinStatus = CredpConvertTargetInfo( DoWtoA,                    // Unicode to Ansi
                                        UnicodeTargetInfo,
                                        (PCREDENTIAL_TARGET_INFORMATIONW *)TargetInfo,
                                        NULL );


Cleanup:
    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }
    if ( UnicodeServerName != NULL ) {
        MIDL_user_free( UnicodeServerName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}

BOOL
APIENTRY
CredGetTargetInfoW (
    IN LPCWSTR ServerName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    )

/*++

Routine Description:

    The CredGetTargetInfo API gets all of the known target name information
    for the named target machine.  This executed locally
    and does not need any particular privilege.  The information returned is expected
    to be passed to the CredReadDomainCredentials and CredWriteDomainCredentials APIs.
    The information should not be used for any other purpose.

    Authentication packages compute TargetInfo when attempting to authenticate to
    ServerName.  The authentication packages cache this target information to make it
    available to CredGetTargetInfo.  Therefore, the target information will only be
    available if we've recently attempted to authenticate to ServerName.

Arguments:

    ServerName - This parameter specifies the name of the machine to get the information
        for.

    Flags - Specifies flags to control the operation of the API.

        CRED_ALLOW_NAME_RESOLUTION - Specifies that if no target info can be found for
            TargetName, then name resolution should be done on TargetName to convert it
            to other forms.  If target info exists for any of those other forms, that
            target info is returned.  Currently only DNS name resolution is done.

            This bit is useful if the application doesn't call the authentication package
            directly.  The application might pass the TargetName to another layer of software
            to authenticate to the server.  That layer of software might resolve the name and
            pass the resolved name to the authentication package.  As such, there will be no
            target info for the original TargetName.

    TargetInfo - Returns a pointer to the target information.
        At least one of the returned fields of TargetInfo will be non-NULL.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NOT_FOUND - There is no target info for the named server.

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeServerName = NULL;
    PCREDENTIAL_TARGET_INFORMATIONW UnicodeTargetInfo = NULL;

    //
    // Capture the input arguments
    //

    WinStatus = CredpAllocStrFromStr( DoWtoW, ServerName, FALSE, &UnicodeServerName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrGetTargetInfo(
                            NULL,   // This API is always local.
                            UnicodeServerName,
                            Flags,
                            &UnicodeTargetInfo );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the target info to ANSI
    //

    WinStatus = CredpConvertTargetInfo( DoWtoW,                    // Unicode to Unicode
                                        UnicodeTargetInfo,
                                        TargetInfo,
                                        NULL );


Cleanup:
    if ( UnicodeTargetInfo != NULL ) {
        MIDL_user_free( UnicodeTargetInfo );
    }
    if ( UnicodeServerName != NULL ) {
        MIDL_user_free( UnicodeServerName );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}


BOOL
APIENTRY
CredGetSessionTypes (
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    )

/*++

Routine Description:

    CredGetSessionTypes returns the maximum persistence supported by the current logon
    session.

    For whistler, CRED_PERSIST_LOCAL_MACHINE and CRED_PERSIST_ENTERPRISE credentials can not
    be stored for sessions where the profile is not loaded.  If future releases, credentials
    might not be associated with the user's profile.

Arguments:

    MaximumPersistCount - Specifies the number of elements in the MaximumPersist array.
        The caller should specify CRED_TYPE_MAXIMUM for this parameter.

    MaximumPersist - Returns the maximum persistance supported by the current logon session for
        each credential type.  Index into the array with one of the CRED_TYPE_* defines.
        Returns CRED_PERSIST_NONE if no credential of this type can be stored.
        Returns CRED_PERSIST_SESSION if only session specific credential may be stored.
        Returns CRED_PERSIST_LOCAL_MACHINE if session specific and machine specific credentials
            may be stored.
        Returns CRED_PERSIST_ENTERPRISE if any credential may be stored.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    DWORD WinStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrGetSessionTypes(
                            NULL,   // This API is always local.
                            MaximumPersistCount,
                            MaximumPersist );

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;


    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredProfileLoaded (
    VOID
    )

/*++

Routine Description:

    The CredProfileLoaded API is a private API used by LoadUserProfile to notify the
    credential manager that the profile for the current user has been loaded.

    The caller must be impersonating the logged on user.

Arguments:

    None.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/
{
    DWORD WinStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        NTSTATUS Status;

        //
        // Call RPC version of the API.
        //

        Status = CredrProfileLoaded(
                            NULL );   // This API is always local.

        WinStatus = CredpNtStatusToWinStatus( Status );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        WinStatus = RpcExceptionCode();

    } RpcEndExcept;

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;

}

VOID
CredpMarshalChar(
    IN OUT LPWSTR *Current,
    IN ULONG Byte
    )
/*++

Routine Description:

    This routine marshals 6 bits into a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    Byte - Specifies the 6 bits to marshal

Return Values:

    None.

--*/
{
    UCHAR MappingTable[] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
        'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '#', '-'
    };

    if ( Byte > 0x3F ) {
        *(*Current) = '=';
    } else {
        *(*Current) = MappingTable[Byte];
    }
    (*Current)++;
}

ULONG
CredpMarshalSize(
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine returns the number of bytes that would be marshaled by
    CredpMarshalBytes when passed a buffer ByteCount bytes long.

Arguments:

    ByteCount - Specifies the number of bytes to marshal


Return Values:

    The number of bytes that would be marshaled.

--*/
{
    ULONG CharCount;
    ULONG ExtraBytes;

    //
    // If byte count is a multiple of 3, the char count is straight forward
    //
    CharCount = ByteCount / 3 * 4;

    ExtraBytes = ByteCount % 3;

    if ( ExtraBytes == 1 ) {
        CharCount += 2;
    } else if ( ExtraBytes == 2 ) {
        CharCount += 3;
    }

    return CharCount * sizeof(WCHAR);

}

VOID
CredpMarshalBytes(
    IN OUT LPWSTR *Current,
    IN LPBYTE Bytes,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine marshals bytes into a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    Bytes - Specifies the buffer to marshal

    ByteCount - Specifies the number of bytes to marshal


Return Values:

    None.

--*/
{
    ULONG i;

    union {
        BYTE ByteValues[3];
        struct {
            ULONG Bits1 :6;
            ULONG Bits2 :6;
            ULONG Bits3 :6;
            ULONG Bits4 :6;
        } BitValues;
    } Bits;

    //
    // Loop through marshaling 3 bytes at a time.
    //

    for ( i=0; i<ByteCount; i+=3 ) {
        ULONG BytesToCopy;

        //
        // Grab up to 3 bytes from the input buffer.
        //
        BytesToCopy = min( 3, ByteCount-i );

        if ( BytesToCopy != 3 ) {
            RtlZeroMemory( Bits.ByteValues, 3);
        }
        RtlCopyMemory( Bits.ByteValues, &Bytes[i], BytesToCopy );

        //
        // Marshal the first twelve bits
        //
        CredpMarshalChar( Current, Bits.BitValues.Bits1 );
        CredpMarshalChar( Current, Bits.BitValues.Bits2 );

        //
        // Optionally marshal the next bits.
        //

        if ( BytesToCopy > 1 ) {
            CredpMarshalChar( Current, Bits.BitValues.Bits3 );
            if ( BytesToCopy > 2 ) {
                CredpMarshalChar( Current, Bits.BitValues.Bits4 );
            }
        }

    }

}

BOOL
CredpUnmarshalChar(
    IN OUT LPWSTR *Current,
    IN LPCWSTR End,
    OUT PULONG Value
    )
/*++

Routine Description:

    This routine unmarshals 6 bits from a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    End - Points to the first character beyond the end of the marshaled buffer.

    Value - returns the unmarshaled 6 bits value.

Return Values:

    TRUE - if the bytes we're unmarshaled sucessfully

    FALSE - if the byte could not be unmarshaled from the buffer.

--*/
{
    WCHAR CurrentChar;

    //
    // Ensure the character is available in the buffer
    //

    if ( *Current >= End ) {
        return FALSE;

    }

    //
    // Grab the character
    //

    CurrentChar = *(*Current);
    (*Current)++;

    //
    // Map it the 6 bit value
    //

    switch ( CurrentChar ) {
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
        *Value = CurrentChar - 'A';
        break;

    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 's':
    case 't':
    case 'u':
    case 'v':
    case 'w':
    case 'x':
    case 'y':
    case 'z':
        *Value = CurrentChar - 'a' + 26;
        break;

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        *Value = CurrentChar - '0' + 26 + 26;
        break;
    case '#':
        *Value = 26 + 26 + 10;
        break;
    case '-':
        *Value = 26 + 26 + 10 + 1;
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
CredpUnmarshalBytes(
    IN OUT LPWSTR *Current,
    IN LPCWSTR End,
    IN LPBYTE Bytes,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine unmarshals bytes bytes from a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    End - Points to the first character beyond the end of the marshaled buffer.

    Bytes - Specifies the buffer to unmarsal into

    ByteCount - Specifies the number of bytes to unmarshal


Return Values:

    TRUE - if the bytes we're unmarshaled sucessfully

    FALSE - if the byte could not be unmarshaled from the buffer.

--*/
{
    ULONG i;
    ULONG Value;

    union {
        BYTE ByteValues[3];
        struct {
            ULONG Bits1 :6;
            ULONG Bits2 :6;
            ULONG Bits3 :6;
            ULONG Bits4 :6;
        } BitValues;
    } Bits;

    //
    // Loop through unmarshaling 3 bytes at a time.
    //

    for ( i=0; i<ByteCount; i+=3 ) {
        ULONG BytesToCopy;

        //
        // Grab up to 3 bytes from the input buffer.
        //
        BytesToCopy = min( 3, ByteCount-i );

        if ( BytesToCopy != 3 ) {
            RtlZeroMemory( Bits.ByteValues, 3);
        }

        //
        // Unarshal the first twelve bits
        //
        if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
            return FALSE;
        }
        Bits.BitValues.Bits1 = Value;

        if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
            return FALSE;
        }
        Bits.BitValues.Bits2 = Value;


        //
        // Optionally marshal the next bits.
        //

        if ( BytesToCopy > 1 ) {
            if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
                return FALSE;
            }
            Bits.BitValues.Bits3 = Value;
            if ( BytesToCopy > 2 ) {
                if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
                    return FALSE;
                }
                Bits.BitValues.Bits4 = Value;
            }
        }

        //
        // Copy the unmarshaled bytes to the caller's buffer.
        //

        RtlCopyMemory( &Bytes[i], Bits.ByteValues, BytesToCopy );

    }

    return TRUE;
}

BOOL
APIENTRY
CredMarshalCredentialA(
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPSTR *MarshaledCredential
    )
/*++

Routine Description:

    The ANSI version of CredMarshalCredentialW

Arguments:

    See CredMarshalCredentialW.

Return Values:

    See CredMarshalCredentialW.

--*/
{
    BOOL RetVal;
    DWORD WinStatus;
    LPWSTR UnicodeMarshaledCredential;

    RetVal = CredMarshalCredentialW( CredType, Credential, &UnicodeMarshaledCredential );

    if ( RetVal ) {

        //
        // Convert the value to ANSI.
        //

        WinStatus = CredpAllocStrFromStr( DoWtoA, UnicodeMarshaledCredential, FALSE, (LPWSTR *)MarshaledCredential );

        if ( WinStatus != NO_ERROR ) {
            SetLastError( WinStatus );
            RetVal = FALSE;
        }

        CredFree( UnicodeMarshaledCredential );
    }

    return RetVal;
}

BOOL
APIENTRY
CredMarshalCredentialW(
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPWSTR *MarshaledCredential
    )
/*++

Routine Description:

    The CredMarshalCredential API is a private API used by the keyring UI to marshal a
    credential.  The keyring UI needs to be able to pass a certificate credential through
    interfaces (e.g., NetUseAdd) that have historically accepted DomainName UserName and Password.

Arguments:

    CredType - Specifies the type of credential to marshal.
        This enum will be expanded in the future.

    Credential - Specifies the credential to marshal.
        If CredType is CertCredential, then Credential points to a CERT_CREDENTIAL_INFO structure.

    MarshaledCredential - Returns a text string containing the marshaled credential.
        The marshaled credential should be passed as the UserName string to any API that
        is currently passed credentials.  If that API is currently passed a
        password, the password should be passed as NULL or empty.  If that API is
        currently passed a domain name, that domain name should be passed as NULL or empty.

        The caller should free the returned buffer using CredFree.


Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_INVALID_PARAMETER - CredType is invalid.

--*/
{
    DWORD WinStatus;
    ULONG Size;
    LPWSTR RetCredential = NULL;
    LPWSTR Current;
    PCERT_CREDENTIAL_INFO CertCredentialInfo = NULL;
    PUSERNAME_TARGET_CREDENTIAL_INFO UsernameTargetCredentialInfo = NULL;
    ULONG UsernameTargetUserNameSize;
#define CRED_MARSHAL_HEADER L"@@"
#define CRED_MARSHAL_HEADER_LENGTH 2

    //
    // Ensure credential isn't null
    //

    if ( Credential == NULL ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Validate CredType
    //

    Size = (CRED_MARSHAL_HEADER_LENGTH+2) * sizeof(WCHAR);
    switch ( CredType ) {
    case CertCredential:
        CertCredentialInfo = (PCERT_CREDENTIAL_INFO) Credential;

        if ( CertCredentialInfo->cbSize < sizeof(CERT_CREDENTIAL_INFO) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Size += CredpMarshalSize( sizeof(CertCredentialInfo->rgbHashOfCert) );
        break;

    case UsernameTargetCredential:
        UsernameTargetCredentialInfo = (PUSERNAME_TARGET_CREDENTIAL_INFO) Credential;

        if ( UsernameTargetCredentialInfo->UserName == NULL ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        UsernameTargetUserNameSize = wcslen(UsernameTargetCredentialInfo->UserName)*sizeof(WCHAR);

        if ( UsernameTargetUserNameSize == 0 ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Size += CredpMarshalSize( sizeof(UsernameTargetUserNameSize) ) +
                CredpMarshalSize( UsernameTargetUserNameSize );
        break;

    default:
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Allocate a buffer to put the marshaled string into.
    //

    RetCredential = (LPWSTR) MIDL_user_allocate( Size );

    if ( RetCredential == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Add the header onto the marshaled string
    //


    Current = RetCredential;

    RtlCopyMemory( Current, CRED_MARSHAL_HEADER, CRED_MARSHAL_HEADER_LENGTH*sizeof(WCHAR) );
    Current += CRED_MARSHAL_HEADER_LENGTH;

    //
    // Add the CredType
    //

    CredpMarshalChar( &Current, CredType );

    //
    // Marshal the CredType specific data
    //

    switch ( CredType ) {
    case CertCredential:
        CredpMarshalBytes( &Current, CertCredentialInfo->rgbHashOfCert, sizeof(CertCredentialInfo->rgbHashOfCert) );
        break;
    case UsernameTargetCredential:
        CredpMarshalBytes( &Current, (LPBYTE)&UsernameTargetUserNameSize, sizeof(UsernameTargetUserNameSize) );
        CredpMarshalBytes( &Current, (LPBYTE)UsernameTargetCredentialInfo->UserName, UsernameTargetUserNameSize );
        break;
    }

    //
    // Finally, zero terminate the string
    //

    *Current = L'\0';
    Current ++;

    //
    // Return the marshaled credential to the caller.
    //

    ASSERT( Current == &RetCredential[Size/sizeof(WCHAR)] );


    *MarshaledCredential = RetCredential;
    RetCredential = NULL;
    WinStatus = NO_ERROR;

Cleanup:
    if ( RetCredential != NULL ) {
        MIDL_user_free( RetCredential );
    }
    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredUnmarshalCredentialA(
    IN LPCSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    )
/*++

Routine Description:

    The ANSI version of CredUnmarshalCredentialW

Arguments:

    See CredUnmarshalCredentialW.

Return Values:

    See CredUnmarshalCredentialW.

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeMarshaledCredential = NULL;

    //
    // Convert input args to Unicode
    //

    WinStatus = CredpAllocStrFromStr( DoAtoW, (LPWSTR)MarshaledCredential, FALSE, &UnicodeMarshaledCredential );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Do the unmarshaling
    //
    if ( !CredUnmarshalCredentialW( UnicodeMarshaledCredential,
                                    CredType,
                                    Credential ) ) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

Cleanup:
    if ( UnicodeMarshaledCredential != NULL ) {
        MIDL_user_free( UnicodeMarshaledCredential );
    }

    if ( WinStatus != NO_ERROR ) {
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
CredUnmarshalCredentialW(
    IN LPCWSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    )
/*++

Routine Description:

    The CredMarshalCredential API is a private API used by an authentication package to unmarshal a
    credential.  The keyring UI needs to be able to pass a certificate credential through
    interfaces (e.g., NetUseAdd) that have historically accepted DomainName UserName and Password.

Arguments:

    MarshaledCredential - Specifies a text string containing the marshaled credential.

    CredType - Returns the type of credential.

    Credential - Returns a pointer to the unmarshaled credential.
        If CredType is CertCredential, then the returned pointer is to a CERT_CREDENTIAL_INFO structure.

        The caller should free the returned buffer using CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        ERROR_INVALID_PARAMETER - MarshaledCredential is not valid

--*/
{
    DWORD WinStatus;
    LPWSTR Current;
    LPCWSTR End;
    PCERT_CREDENTIAL_INFO CertCredentialInfo;
    PUSERNAME_TARGET_CREDENTIAL_INFO UsernameTargetCredentialInfo;
    PVOID RetCredential = NULL;
    ULONG UsernameTargetUserNameSize;
    LPBYTE Where;
    ULONG MarshaledCredentialLength;

    //
    // Validate the passed in buffer.
    //

    if ( MarshaledCredential == NULL ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Ensure the first few bytes are the appropriate header
    //

    if ( MarshaledCredential[0] != CRED_MARSHAL_HEADER[0] || MarshaledCredential[1] != CRED_MARSHAL_HEADER[1] ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the credential type
    //

    MarshaledCredentialLength = wcslen(MarshaledCredential);
    Current = (LPWSTR) &MarshaledCredential[2];
    End = &MarshaledCredential[MarshaledCredentialLength];

    if ( !CredpUnmarshalChar( &Current, End, (PULONG)CredType ) ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch ( *CredType ) {
    case CertCredential:

        //
        // Allocate a buffer that will be more than big enough
        //

        CertCredentialInfo = MIDL_user_allocate(
                                sizeof(*CertCredentialInfo) +
                                MarshaledCredentialLength*sizeof(WCHAR) );

        if ( CertCredentialInfo == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RetCredential = CertCredentialInfo;
        CertCredentialInfo->cbSize = sizeof(*CertCredentialInfo);

        //
        // Unmarshal the data
        //


        if ( !CredpUnmarshalBytes( &Current, End, CertCredentialInfo->rgbHashOfCert, sizeof(CertCredentialInfo->rgbHashOfCert) ) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        break;

    case UsernameTargetCredential:


        //
        // Allocate a buffer that will be more than big enough
        //

        UsernameTargetCredentialInfo = MIDL_user_allocate(
                                sizeof(*UsernameTargetCredentialInfo) +
                                MarshaledCredentialLength*sizeof(WCHAR) +
                                sizeof(WCHAR) );

        if ( UsernameTargetCredentialInfo == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RetCredential = UsernameTargetCredentialInfo;
        Where = (LPBYTE)(UsernameTargetCredentialInfo+1);

        //
        // Unmarshal the size of the data
        //

        if ( !CredpUnmarshalBytes( &Current, End, (LPBYTE)&UsernameTargetUserNameSize, sizeof(UsernameTargetUserNameSize) ) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( UsernameTargetUserNameSize != ROUND_UP_COUNT( UsernameTargetUserNameSize, sizeof(WCHAR)) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( UsernameTargetUserNameSize == 0 ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }



        //
        // Unmarshal the data
        //

        UsernameTargetCredentialInfo->UserName = (LPWSTR)Where;

        if ( !CredpUnmarshalBytes( &Current, End, Where, UsernameTargetUserNameSize ) ) {
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Where += UsernameTargetUserNameSize;

        //
        // Zero terminate it
        //
        *((PWCHAR)Where) = L'\0';

        break;

    default:
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Ensure we've unmarshalled the entire string
    //

    if ( Current != End ) {
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    WinStatus = NO_ERROR;
    *Credential = RetCredential;

Cleanup:
    if ( WinStatus != NO_ERROR ) {
        *Credential = NULL;
        if ( RetCredential != NULL ) {
            MIDL_user_free( RetCredential );
        }
        SetLastError( WinStatus );
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
CredIsMarshaledCredentialA(
    IN LPCSTR MarshaledCredential
    )
/*++

Routine Description:

    The ANSI version of CredIsMarshaledCredentialW

Arguments:

    MarshaledCredential - Specifies a text string containing the marshaled credential.

Return Values:

    Returns TRUE if the credential is a marshalled credential.

--*/
{
    DWORD WinStatus;
    CRED_MARSHAL_TYPE CredType;
    PVOID UnmarshalledUsername;

    if ( !CredUnmarshalCredentialA( MarshaledCredential, &CredType, &UnmarshalledUsername ) ) {
        return FALSE;
    }

    CredFree( UnmarshalledUsername );

    return TRUE;
}

BOOL
APIENTRY
CredIsMarshaledCredentialW(
    IN LPCWSTR MarshaledCredential
    )
/*++

Routine Description:

    The CredIsMarshaledCredential API is a private API used by an authentication package to
    determine if a credential is a unmarshaled credential or not.

Arguments:

    MarshaledCredential - Specifies a text string containing the marshaled credential.

Return Values:

    Returns TRUE if the credential is a marshalled credential.

--*/
{
    DWORD WinStatus;
    CRED_MARSHAL_TYPE CredType;
    PVOID UnmarshalledUsername;

    if ( !CredUnmarshalCredentialW( MarshaledCredential, &CredType, &UnmarshalledUsername ) ) {
        return FALSE;
    }

    CredFree( UnmarshalledUsername );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\efsrpc_c_stub.c ===
#include "efsrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\eclient.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    eclient.c

Abstract:

    EFS RPC client code.

Author:

    Robert Gu       (RobertG)    Aug, 1997

Environment:

Revision History:

--*/


#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <wincrypt.h>
#include <efsrpc.h>
#include <efsstruc.h>
#include <dfsfsctl.h>
#include <rpcasync.h>

#define  WEBPROV    L"Web Client Network"
#define  DAVHEADER  0x01

//
// Internal prototypes
//

void __RPC_FAR
EfsPipeAlloc(
    char __RPC_FAR * State,
    unsigned long ReqSize,
    unsigned char __RPC_FAR * __RPC_FAR * Buf,
    unsigned long __RPC_FAR * RealSize
    );

void __RPC_FAR
EfsPipeRead (
    char __RPC_FAR * State,
    unsigned char __RPC_FAR * DataBuf,
    unsigned long ByteCount
    );

void __RPC_FAR
EfsPipeWrite (
    char __RPC_FAR * State,
    unsigned char __RPC_FAR * DataBuf,
    unsigned long ByteRequested,
    unsigned long *ByteFromCaller
    );

DWORD
GetFullName(
    LPCWSTR FileName,
    LPWSTR *FullName,
    LPWSTR *ServerName,
    ULONG   Flags,
    DWORD   dwCreationDistribution, 
    DWORD   dwAttributes, 
    PSECURITY_DESCRIPTOR pRelativeSD,
    BOOL    bInheritHandle
    );

DWORD
EnablePrivilege(
    ULONG   Flags,
    HANDLE *TokenHandle,
    PTOKEN_PRIVILEGES *OldPrivs
    );

VOID
RestorePrivilege(
    HANDLE *TokenHandle,
    PTOKEN_PRIVILEGES *OldPrivs
    );


DWORD
EnablePrivilege(
    ULONG   Flags,
    HANDLE *TokenHandle,
    PTOKEN_PRIVILEGES *OldPrivs
    )
{

    TOKEN_PRIVILEGES    Privs;
    DWORD   RetCode = ERROR_SUCCESS;

    BOOL    b;
    DWORD   ReturnLength;

    *TokenHandle = NULL;
    *OldPrivs = NULL;

    *OldPrivs = ( TOKEN_PRIVILEGES *) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof( TOKEN_PRIVILEGES )
                            );


    if ( *OldPrivs == NULL ){

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // We're impersonating, use the thread token.
    //

    b = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            FALSE,
            TokenHandle
            );

    if (!b) {
        b = OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TokenHandle
            );
    }

    if ( b ) {

        //
        // We've got a token handle
        //

        //
        // If we're doing a create for import, enable restore privilege,
        // otherwise enable backup privilege.
        //


        Privs.PrivilegeCount = 1;
        Privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if ( !(Flags & CREATE_FOR_IMPORT) ){

            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_BACKUP_PRIVILEGE);

        } else {

            Privs.Privileges[0].Luid = RtlConvertLongToLuid(SE_RESTORE_PRIVILEGE);
        }

        ReturnLength = sizeof( TOKEN_PRIVILEGES );

        (VOID) AdjustTokenPrivileges (
                    *TokenHandle,
                    FALSE,
                    &Privs,
                    sizeof( TOKEN_PRIVILEGES ),
                    *OldPrivs,
                    &ReturnLength
                    );

        if ( ERROR_SUCCESS != (RetCode = GetLastError()) ) {

            //
            // Privilege adjust failed
            //

            CloseHandle( *TokenHandle );
            *TokenHandle = NULL;
            RtlFreeHeap( RtlProcessHeap(), 0, *OldPrivs );
            *OldPrivs = NULL;

        }

    } else {
        *TokenHandle = NULL;
        RtlFreeHeap( RtlProcessHeap(), 0, *OldPrivs );
        *OldPrivs = NULL;
    }

    return RetCode;
}


VOID
RestorePrivilege(
    HANDLE *TokenHandle,
    PTOKEN_PRIVILEGES *OldPrivs
    )
{
    if (!TokenHandle || !OldPrivs || !(*TokenHandle) || !(*OldPrivs)) {
        return;
    }
    (VOID) AdjustTokenPrivileges (
                *TokenHandle,
                FALSE,
                *OldPrivs,
                0,
                NULL,
                NULL
                );

    CloseHandle( *TokenHandle );
    *TokenHandle = 0;
    RtlFreeHeap( RtlProcessHeap(), 0, *OldPrivs );
    *OldPrivs = NULL;
}

DWORD
EfsOpenFileRawRPCClient(
    IN  LPCWSTR    FileName,
    IN  ULONG   Flags,
    OUT PVOID * Context
    )

/*++

Routine Description:

    This routine is the client side of EfsOpenFileRaw. It establishes the
    connection to the server. And then call the server to finish the task.

Arguments:

    FileName  --  File name of the file to be exported

    Flags -- Indicating if open for export or import; for directory or file.

    Context - Export context to be used by READ operation later. Caller should
              pass this back in ReadRaw().


Return Value:

    Result of the operation.

--*/
{
   DWORD RetCode;
   handle_t  binding_h;
   NTSTATUS Status;
   PEXIMPORT_CONTEXT_HANDLE RawContext;
   LPWSTR  FullName;
   LPWSTR  Server;
   HANDLE  TokenHandle;
   PTOKEN_PRIVILEGES OldPrivs;

   *Context = NULL;
   RetCode = GetFullName(
                     FileName,
                     &FullName,
                     &Server,
                     Flags,
                     0,
                     0,
                     NULL,
                     FALSE
                     );

   if ( RetCode == ERROR_SUCCESS ){

       (VOID) EnablePrivilege(
                    Flags,
                    &TokenHandle,
                    &OldPrivs
                    );

       Status = RpcpBindRpc (
                    Server,
                    L"lsarpc",
                    L"security=Impersonation static true",
                    &binding_h
                    );

       if (NT_SUCCESS(Status)){
           RpcTryExcept {
               RetCode = EfsRpcOpenFileRaw(
                                   binding_h,
                                   &RawContext,
                                   FullName,
                                   Flags
                                   );
               if ( ERROR_SUCCESS == RetCode ){

                   //
                   //  Send the context handle back to the user
                   //

                   *Context = (PVOID) RawContext;
               }
           } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
               RetCode = RpcExceptionCode();
           } RpcEndExcept;

           //
           // Free the binding handle
           //

           RpcpUnbindRpc( binding_h );
       } else {
           RetCode = RtlNtStatusToDosError( Status );
       }

       RestorePrivilege(
           &TokenHandle,
           &OldPrivs
       );

       RtlFreeHeap( RtlProcessHeap(), 0, FullName );
       RtlFreeHeap( RtlProcessHeap(), 0, Server );
   }

   return RetCode;
}

VOID
EfsCloseFileRawRPCClient(
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine is the client side of EfsCloseFileRaw.

Arguments:

    Context - Export/Import context used by READ/WRITE raw data.


Return Value:

    None.

--*/
{

    PEXIMPORT_CONTEXT_HANDLE phContext;

    phContext = (PEXIMPORT_CONTEXT_HANDLE) Context;
    RpcTryExcept {
        EfsRpcCloseRaw(
            &phContext
            );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
    } RpcEndExcept;

}

DWORD
EfsReadFileRawRPCClient(
    IN      PFE_EXPORT_FUNC ExportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine is the client side of EfsReadFileRaw.

Arguments:

    ExportCallback - Caller provided callback function.

    CallbackContext - Caller's context.

    Context - Export context used by READ raw data.


Return Value:

    None.
*/
{
    PEXIMPORT_CONTEXT_HANDLE phContext;
    EFS_EXIM_STATE  Pipe_State;
    EFS_EXIM_PIPE   ExportPipe;
    DWORD RetCode;

    if ( NULL == Context){
        return ERROR_ACCESS_DENIED;
    }

    phContext = ( PEXIMPORT_CONTEXT_HANDLE ) Context;

    //
    // Try to allocate a reasonable size buffer. The size can be fine tuned later, but should
    // at least one page plus 4K.  FSCTL_OUTPUT_LESS_LENGTH should be n * page size.
    // FSCTL_OUTPUT_MIN_LENGTH can be fine tuned later. It should be at least one page
    // plus 4K.
    //

    Pipe_State.BufLength = FSCTL_OUTPUT_INITIAL_LENGTH;
    Pipe_State.WorkBuf = NULL;

    while ( !Pipe_State.WorkBuf  &&
                (Pipe_State.BufLength >= FSCTL_OUTPUT_MIN_LENGTH)
               ){

        Pipe_State.WorkBuf = RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                Pipe_State.BufLength
                                );
        if ( !Pipe_State.WorkBuf ){

            //
            // Memory allocation failed.
            // Try smaller allocation.
            //

            Pipe_State.BufLength -= FSCTL_OUTPUT_LESS_LENGTH;

        }

    }
    if (!Pipe_State.WorkBuf){
        return ERROR_OUTOFMEMORY;
    }

    Pipe_State.ExImCallback = (PVOID) ExportCallback;
    Pipe_State.CallbackContext = CallbackContext;
    Pipe_State.Status = NO_ERROR;
    ExportPipe.state = (char *) &Pipe_State;
    ExportPipe.alloc = EfsPipeAlloc;
    ExportPipe.pull = NULL;
    ExportPipe.push = EfsPipeRead;

    RpcTryExcept{

        RetCode = EfsRpcReadFileRaw(
                                phContext,
                                &ExportPipe
                                );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
            if ( NO_ERROR == Pipe_State.Status ){
                RetCode = RpcExceptionCode();
            } else {
                RetCode =   Pipe_State.Status;
            }
    } RpcEndExcept;

    RtlFreeHeap( RtlProcessHeap(), 0, Pipe_State.WorkBuf );

    return RetCode;
}

DWORD
EfsWriteFileRawRPCClient(
    IN      PFE_IMPORT_FUNC ImportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine is the client side of EfsWriteFileRaw.

Arguments:

    ImportCallback - Caller provided callback function.

    CallbackContext - Caller's context.

    Context - Import context used by WRITE raw data.


Return Value:

    None.
*/
{
    PEXIMPORT_CONTEXT_HANDLE phContext;
    EFS_EXIM_STATE  Pipe_State;
    EFS_EXIM_PIPE   ImportPipe;
    DWORD RetCode;

    HANDLE  TokenHandle;
    PTOKEN_PRIVILEGES OldPrivs;

    if ( NULL == Context){
        return ERROR_ACCESS_DENIED;
    }
    phContext = ( PEXIMPORT_CONTEXT_HANDLE ) Context;

    //
    // Try to allocate a reasonable size buffer. The size can be fine tuned later, but should
    // at least one page plus 4K.  FSCTL_OUTPUT_LESS_LENGTH should be n * page size.
    // FSCTL_OUTPUT_MIN_LENGTH can be fine tuned later. It should be at least one page
    // plus 4K.
    //

    Pipe_State.BufLength = FSCTL_OUTPUT_INITIAL_LENGTH;
    Pipe_State.WorkBuf = RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            Pipe_State.BufLength
                            );

    if (!Pipe_State.WorkBuf){
        return ERROR_OUTOFMEMORY;
    }

    Pipe_State.ExImCallback = (PVOID) ImportCallback;
    Pipe_State.CallbackContext = CallbackContext;
    Pipe_State.Status = NO_ERROR;
    ImportPipe.state = (char *) &Pipe_State;
    ImportPipe.alloc = EfsPipeAlloc;
    ImportPipe.pull = EfsPipeWrite;
    ImportPipe.push = NULL;


    (VOID) EnablePrivilege(
                 CREATE_FOR_IMPORT,
                 &TokenHandle,
                 &OldPrivs
                 );

    RpcTryExcept{
        RetCode = EfsRpcWriteFileRaw(
                                phContext,
                                &ImportPipe
                                );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
            if ( NO_ERROR == Pipe_State.Status ){
                RetCode = RpcExceptionCode();
            } else {
                RetCode =   Pipe_State.Status;
            }
    } RpcEndExcept;

    RestorePrivilege(
        &TokenHandle,
        &OldPrivs
    );

    RtlFreeHeap( RtlProcessHeap(), 0, Pipe_State.WorkBuf );

    return RetCode;
}

void __RPC_FAR
EfsPipeAlloc(
    char __RPC_FAR * State,
    unsigned long ReqSize,
    unsigned char __RPC_FAR * __RPC_FAR * Buf,
    unsigned long __RPC_FAR * RealSize
    )
/*++

Routine Description:

    This routine is required by the RPC pipe. It allocates the memory
    for the push and pull routines.

Arguments:

    State - Pipe status.

    ReqSize - Required buffer sixe in bytes.

    Buf - Buffer pointer.

    RealSize - Size of allocated buffer in bytes.

Return Value:

    None.
*/
{

    PEFS_EXIM_STATE  Pipe_State = (PEFS_EXIM_STATE) State;
    //
    //  If error had occured, this is the chance to tell the RPC LIB to
    //  stop the pipe work.
    //
    if ( NO_ERROR != Pipe_State->Status){
        *RealSize = 0;
        *Buf = NULL;
    } else {
        if ( ReqSize > Pipe_State->BufLength ){
            *RealSize = Pipe_State->BufLength;
        } else {
            *RealSize = ReqSize;
        }
        *Buf = Pipe_State->WorkBuf;
    }

}

void __RPC_FAR
EfsPipeRead (
    char __RPC_FAR * State,
    unsigned char __RPC_FAR * DataBuf,
    unsigned long ByteCount
    )
/*++

Routine Description:

    This routine is called by the RPC pipe. It send the exported data to the caller.

Arguments:

    State - Pipe status.

    DataBuf - Buffer pointer.

    ByteCount - Number of bytes to be sent out.

Return Value:

    None.
*/
{
    DWORD HResult;
    PEFS_EXIM_STATE  Pipe_State = (PEFS_EXIM_STATE) State;
    PFE_EXPORT_FUNC ExportCallback;
    PVOID   CallbackContext;

    ExportCallback = Pipe_State->ExImCallback;
    CallbackContext = Pipe_State->CallbackContext;
    HResult = (*ExportCallback)( DataBuf, CallbackContext, ByteCount);
    if ( NO_ERROR != HResult ){
        Pipe_State->Status = HResult;
    }
}

void __RPC_FAR
EfsPipeWrite (
    char __RPC_FAR * State,
    unsigned char __RPC_FAR * DataBuf,
    unsigned long ByteRequested,
    unsigned long *ByteFromCaller
    )
/*++

Routine Description:

    This routine is called by the RPC pipe. It send the exported data to the caller.

Arguments:

    State - Pipe status.

    DataBuf - Buffer pointer.

    ByteRequested - Number of bytes requested to write to the pipe.

    ByteFromCaller - Number of bytes available for writing to the pipe.

Return Value:

    None.


*/
{
    DWORD HResult;
    PEFS_EXIM_STATE  Pipe_State = (PEFS_EXIM_STATE) State;
    PFE_IMPORT_FUNC ImportCallback;
    PVOID   CallbackContext;

    ImportCallback = Pipe_State->ExImCallback;
    CallbackContext = Pipe_State->CallbackContext;
    *ByteFromCaller = ByteRequested;
    HResult = (*ImportCallback)( DataBuf, CallbackContext, ByteFromCaller);
    if ( NO_ERROR != HResult ){
        Pipe_State->Status = HResult;
    }
}


DWORD
EfsEncryptFileRPCClient(
    UNICODE_STRING *FullFileNameU
    )
/*++

Routine Description:

    This routine is the client side of Encryption API. It establishes the
    connection to the server. And then call the server to finish the task.

Arguments:

    FullFileNameU - Supplies the name of the file to be encrypted.

Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{


    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    RetCode = GetFullName(
        FullFileNameU->Buffer,
        &FullName,
        &Server,
        0,
        0,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ){
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcEncryptFileSrv(
                                    binding_h,
                                    FullName
                                    );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );
        } else {
            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}

DWORD
EfsDecryptFileRPCClient(
    UNICODE_STRING *FullFileNameU,
    DWORD        dwRecovery
    )
/*++

Routine Description:

    This routine is the client side of Decryption API. It establishes the
    connection to the server. And then call the server to finish the task.

Arguments:

    FullFileNameU - Supplies the name of the file to be encrypted.

Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{

    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    RetCode = GetFullName(
        FullFileNameU->Buffer,
        &FullName,
        &Server,
        0,
        0,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ){
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcDecryptFileSrv(
                                binding_h,
                                FullName,
                                dwRecovery
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;
            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );
        } else {
            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}

DWORD
GetFullName(
    LPCWSTR FileName,
    LPWSTR *FullName,
    LPWSTR *ServerName,
    ULONG   Flags,
    DWORD   dwCreationDistribution, 
    DWORD   dwAttributes, 
    PSECURITY_DESCRIPTOR pRelativeSD,
    BOOL    bInheritHandle
    )
/*++

Routine Description:

    This routine will extract the server name and the file UNC name from the
    passed in file name.

Arguments:

    FileName - Supplies the name of the file to be parsed.
    FullName - File name used on the server.
    ServerName - The server machine name where the file lives.
    Flags - Indicates if the object is a directory or a file. CREATE_FOR_DIR for directory.
    dwCreationDistribution - How the file should be created.
    dwAtrributes - The attributes for creating a new object.
    pRelativeSD - Security Descriptor.
    bInheritHandle - If the file to be created should inherit the security.

Return Value:

    ERROR_SUCCESS on success, other on failure.

--*/
{

    HANDLE FileHdl = 0;
    HANDLE DriverHandle;
    UNICODE_STRING DfsDriverName;
    DWORD RetCode = ERROR_SUCCESS;
    LPWSTR  TmpFullName;
    DWORD FullNameLength;
    DWORD FileNameLength;


    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileNtName;
    NTSTATUS NtStatus;
    BOOL    b = TRUE;
    DWORD   FileAttributes = 0;
    DWORD   CreationDistribution = 0;
    DWORD   CreateOptions = 0;
    ULONG ii, jj;
    BOOL    GotRoot;
    WCHAR *PathName;
    UINT   DriveType;
    PFILE_NAME_INFORMATION FileNameInfo;
    WCHAR  WorkBuffer[MAX_PATH+4];
    DWORD  BufSize;
    DWORD  BufferLength;

    NETRESOURCEW RemotePathResource;
    NETRESOURCEW *pNetInfo;

    FileNameLength = wcslen(FileName);

    BufferLength = (FileNameLength + 1) <= MAX_PATH ?
                            (MAX_PATH + 1) * sizeof(WCHAR) : (FileNameLength + 1) * sizeof (WCHAR);
    PathName = (WCHAR *) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            BufferLength
                            );

    if ( !PathName  ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    GotRoot = GetVolumePathNameW(
                    FileName,
                    PathName,
                    BufferLength
                    );

    if (!GotRoot) {
        RetCode = GetLastError();
        RtlFreeHeap( RtlProcessHeap(), 0, PathName );
        return RetCode;
    }

    DriveType = GetDriveTypeW(PathName);
    RtlFreeHeap( RtlProcessHeap(), 0, PathName );

    if (DriveType == DRIVE_REMOTE){

        if ((Flags & CREATE_FOR_IMPORT) || (dwAttributes !=0) ) {

            //
            // Called from OpenRaw or DuplicateInfo.
            // Use NtCreateFile()
            //

            FileAttributes = GetFileAttributesW( FileName );

            if (dwAttributes) {

                //
                // From dup
                //

    
                if (-1 != FileAttributes) {

                    //
                    // File existed
                    //

                    if ( dwCreationDistribution == CREATE_NEW ){
        
                        return ERROR_FILE_EXISTS;
        
                    }

                    CreationDistribution = FILE_OPEN;
                    if (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                        if ((Flags & CREATE_FOR_DIR) == 0) {
                            return ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH;
                        }
                        CreateOptions |= FILE_DIRECTORY_FILE;
                        
                    }
    
                } else {

                    //
                    // Destination not existing
                    //

                    CreationDistribution = FILE_CREATE;
                    if (Flags & CREATE_FOR_DIR) {
                        CreateOptions |= FILE_DIRECTORY_FILE;
                        dwAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                    } else {
                        CreateOptions |= FILE_NO_COMPRESSION;
                    }


                }

            } else {

                //
                // From OpenRaw import
                //

                dwAttributes = FILE_ATTRIBUTE_NORMAL;
                CreateOptions = FILE_OPEN_FOR_BACKUP_INTENT;

                if (-1 == FileAttributes) {

                    CreationDistribution = FILE_CREATE;
                    if (Flags & CREATE_FOR_DIR) {
                        CreateOptions |= FILE_DIRECTORY_FILE;
                        dwAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                    } else {
                        CreateOptions |= FILE_NO_COMPRESSION;
                    }

                } else {

                    //
                    // File already existing
                    //

                    CreationDistribution = FILE_OPEN;
                    if (Flags & CREATE_FOR_DIR) {
                        CreateOptions |= FILE_DIRECTORY_FILE;
                        dwAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                    }
                }


            }


            RtlInitUnicodeString(
                &FileNtName,
                NULL
                );

            b =  RtlDosPathNameToNtPathName_U(
                                FileName,
                                &FileNtName,
                                NULL,
                                NULL
                                );

            if (b) {

                dwAttributes &= ~(FILE_ATTRIBUTE_ENCRYPTED | FILE_ATTRIBUTE_READONLY);
        
                InitializeObjectAttributes(
                            &Obja,
                            &FileNtName,
                            bInheritHandle ? OBJ_INHERIT | OBJ_CASE_INSENSITIVE : OBJ_CASE_INSENSITIVE,
                            0,
                            pRelativeSD? ((PEFS_RPC_BLOB)pRelativeSD)->pbData:NULL
                            );
        
                NtStatus = NtCreateFile(
                                &FileHdl,
                                FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                &Obja,
                                &IoStatusBlock,
                                NULL,
                                dwAttributes,
                                0,
                                CreationDistribution,
                                CreateOptions,
                                NULL,
                                0
                                );


                RtlFreeHeap(
                    RtlProcessHeap(),
                    0,
                    FileNtName.Buffer
                    );

                if (!NT_SUCCESS(NtStatus)) {
                    return (RtlNtStatusToDosError( NtStatus ));
                }
            }


        } else {

            FileHdl = CreateFileW(
                FileName,
                FILE_READ_ATTRIBUTES,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS,
                NULL
                );
            if (INVALID_HANDLE_VALUE == FileHdl) {
                RetCode = GetLastError();
                return RetCode;
            }

        }


        FileNameInfo = (PFILE_NAME_INFORMATION) WorkBuffer;
        BufSize = sizeof (WorkBuffer);

        do {

          NtStatus = NtQueryInformationFile(
                         FileHdl,
                         &IoStatusBlock,
                         FileNameInfo,
                         BufSize,
                         FileNameInformation
                         );
          if ( NtStatus == STATUS_BUFFER_OVERFLOW || NtStatus == STATUS_BUFFER_TOO_SMALL ) {

              BufSize *= 2;
              if (FileNameInfo != (PFILE_NAME_INFORMATION)WorkBuffer) {
                  RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );
              }
              FileNameInfo = (PFILE_NAME_INFORMATION) RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                BufSize
                                );
              if (!FileNameInfo) {
                  CloseHandle(FileHdl);
                  return ERROR_NOT_ENOUGH_MEMORY;
              }

          }
        } while (NtStatus == STATUS_BUFFER_OVERFLOW || NtStatus == STATUS_BUFFER_TOO_SMALL);

        CloseHandle(FileHdl);
        if (!NT_SUCCESS(NtStatus)) {
            if (FileNameInfo != (PFILE_NAME_INFORMATION)WorkBuffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );
                return RtlNtStatusToDosError(NtStatus);
            }
        }

        //
        // We got the UNC name
        //

        *FullName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    FileNameInfo->FileNameLength+2*sizeof (WCHAR)
                    );
    
        *ServerName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    ( MAX_PATH + 1) * sizeof (WCHAR)
                    );

        if ( (NULL == *FullName) || (NULL == *ServerName) ){
    
            if ( *FullName ){
                RtlFreeHeap( RtlProcessHeap(), 0, *FullName );
                *FullName = NULL;
            }
            if ( *ServerName ){
                RtlFreeHeap( RtlProcessHeap(), 0, *ServerName );
                *ServerName = NULL;
            }

            if (FileNameInfo != (PFILE_NAME_INFORMATION)WorkBuffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );
            }
    
            return ERROR_NOT_ENOUGH_MEMORY;
    
        }

    } else {

        //
        // The path is local
        //

        *FullName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    (FileNameLength + 1) * sizeof (WCHAR)
                    );
    
        *ServerName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    8 * sizeof (WCHAR)
                    );

        //
        // Use . for local case.
        //

        if ( (NULL == *FullName) || (NULL == *ServerName) ){
    
            if ( *FullName ){
                RtlFreeHeap( RtlProcessHeap(), 0, *FullName );
                *FullName = NULL;
            }
            if ( *ServerName ){
                RtlFreeHeap( RtlProcessHeap(), 0, *ServerName );
                *ServerName = NULL;
            }
    
            return ERROR_NOT_ENOUGH_MEMORY;
    
        }

        wcscpy ( *ServerName, L".");
        wcscpy ( *FullName, FileName);
        return ERROR_SUCCESS;

    }


    //
    // Let's get the UNC server and path name
    //


    FullNameLength = FileNameInfo->FileNameLength;
    ii = jj = 0;

    while ( (FileNameInfo->FileName)[ jj ] == L'\\' ) {
        jj ++;
    }
    while ( jj < FullNameLength/sizeof(WCHAR) && ((FileNameInfo->FileName)[ jj ] != L'\\') ){
        (*ServerName)[ii++] = (FileNameInfo->FileName)[ jj++ ];
    }
    (*ServerName)[ii] = 0;

    if (FileNameInfo->FileName[0] == L'\\' && FileNameInfo->FileName[1] != L'\\' ) {

        //
        // NtQueryInformationFile returns \server\share\...
        //

        (*FullName)[0] = L'\\';
        wcsncpy( &((*FullName)[1]), &FileNameInfo->FileName[0], FullNameLength/sizeof(WCHAR) );
        (*FullName)[1+FullNameLength/sizeof(WCHAR)] = 0;
    } else{

        //
        // Just in case we get \\server\share\...
        //

        wcsncpy( &((*FullName)[0]), &FileNameInfo->FileName[0], FullNameLength/sizeof(WCHAR) );
        (*FullName)[FullNameLength/sizeof(WCHAR)] = 0;
    }

    
    if (FileNameInfo != (PFILE_NAME_INFORMATION)WorkBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );
    }

    //
    // Let's see if the path is a WEB DAV path or not
    //

    BufSize = 1024; //If not enough, we will allocate more

    pNetInfo =  (NETRESOURCEW *) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            BufSize
                            );

    //
    // If we can't decide if the path is WEBDAV path, we assume not.
    // Error will be returned later if it turns out to be a WEBDAV Share.
    //

    if (pNetInfo) {
    
        LPWSTR  lpSysName;

        RemotePathResource.dwScope = RESOURCE_CONNECTED;
        RemotePathResource.dwType = RESOURCETYPE_DISK;
        RemotePathResource.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
        RemotePathResource.dwUsage = 0;
        RemotePathResource.lpLocalName = NULL;
        RemotePathResource.lpRemoteName = *FullName;
        RemotePathResource.lpComment = NULL;
        RemotePathResource.lpProvider = NULL;
        RetCode = WNetGetResourceInformationW (
                      &RemotePathResource, // network resource
                      (LPVOID) pNetInfo,   // information buffer
                      (LPDWORD) &BufSize,  // size of information buffer
                      &lpSysName           
                      );
        if (RetCode == ERROR_MORE_DATA) {

            //
            // This is not likely to happen
            //

            RtlFreeHeap( RtlProcessHeap(), 0, pNetInfo );

            pNetInfo =  (NETRESOURCEW *) RtlAllocateHeap(
                                    RtlProcessHeap(),
                                    0,
                                    BufSize
                                    );
            if (pNetInfo) {

                RetCode = WNetGetResourceInformationW (
                              &RemotePathResource, // network resource
                              (LPVOID) pNetInfo,   // information buffer
                              (LPDWORD) &BufSize,  // size of information buffer
                              &lpSysName           
                              );

            }


        }

        if (ERROR_SUCCESS == RetCode) {

            //
            // Check to see if the provider is WEBDAV
            //

            if (!wcscmp(WEBPROV, pNetInfo->lpProvider)){

                //
                // This is the WEBDAV. Let's redo the name.
                //

                RtlFreeHeap( RtlProcessHeap(), 0, *FullName );
                
                *FullName = RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            (FileNameLength + 3) * sizeof (WCHAR)
                            );
            
        
                //
                // Use . for local case.
                //
        
                wcscpy ( *ServerName, L".");
                (*FullName)[0] = DAVHEADER;
                (*FullName)[1] = 0;
                wcscat ( *FullName, FileName);
                return ERROR_SUCCESS;

            }

        }


    }
    //
    //  This is a workaround.
    //  Let's see if this could be a DFS name
    //


    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);
    InitializeObjectAttributes(
         &Obja,
         &DfsDriverName,
         OBJ_CASE_INSENSITIVE,
         NULL,
         NULL
    );
    NtStatus = NtCreateFile(
                        &DriverHandle,
                        SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_OPEN_IF,
                        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
                        );

    if ( NT_SUCCESS( NtStatus ) ){

        //
        // DfsDriver opened successfully
        //

        TmpFullName = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    FullNameLength + 2*sizeof (WCHAR)
                    );

        if (TmpFullName) {

            NtStatus = NtFsControlFile(
                                DriverHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_DFS_GET_SERVER_NAME,
                                *FullName,
                                FullNameLength + 2*sizeof (WCHAR) ,
                                TmpFullName,
                                FullNameLength + 2* sizeof (WCHAR)
                                );
    
            if ( STATUS_BUFFER_OVERFLOW == NtStatus ){
                FullNameLength = *(ULONG *)TmpFullName + sizeof (WCHAR);
                RtlFreeHeap( RtlProcessHeap(), 0, TmpFullName );
                TmpFullName = RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                FullNameLength
                                );
    
                if (NULL == TmpFullName){

                    //
                    // Remember this is just a workaround.
                    // Let's assume this is not DFS path. If it is, it will fail later anyway.
                    //
                    
                    NtClose( DriverHandle );
    
                    return ERROR_SUCCESS;
                }
    
                NtStatus = NtFsControlFile(
                                DriverHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_DFS_GET_SERVER_NAME,
                                *FullName,
                                FullNameLength + 2*sizeof (WCHAR) ,
                                TmpFullName,
                                FullNameLength
                                );
    
            }

            if ( NT_SUCCESS( NtStatus ) ){
        
                //
                // The name is a DFS file name. Use the name in the TmpFullName
                //
        
                RtlFreeHeap( RtlProcessHeap(), 0, *FullName );
                *FullName = TmpFullName;

                //
                // Reset the server name
                //

                ii = jj = 0;
            
                while ( (*FullName)[ jj ] == L'\\' ) {
                    jj ++;
                }
                while ( ((*FullName)[ jj ]) && ((*FullName)[ jj ] != L'\\') ){
                    (*ServerName)[ii++] = (*FullName)[ jj++ ];
                }
                (*ServerName)[ii] = 0;
            
            }  else {

                //
                // Not a DFS name
                //

                RtlFreeHeap( RtlProcessHeap(), 0, TmpFullName );

            }

        }


        NtClose( DriverHandle );
    }

    return ERROR_SUCCESS;


}

//
// Beta 2 API
//

DWORD
EfsAddUsersRPCClient(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    RetCode = GetFullName(
        lpFileName,
        &FullName,
        &Server,
        0,
        0,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ) {
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcAddUsersToFile(
                                binding_h,
                                FullName,
                                pEncryptionCertificates
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );
        } else {
            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}



DWORD
EfsRemoveUsersRPCClient(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    RetCode = GetFullName(
        lpFileName,
        &FullName,
        &Server,
        0,
        0,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ){
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcRemoveUsersFromFile(
                                binding_h,
                                FullName,
                                pHashes
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );

        } else {

            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}

DWORD
EfsQueryRecoveryAgentsRPCClient(
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{

    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;

    //
    // Clear out this parameter, or RPC will choke on the server
    // side.
    //

    *pRecoveryAgents = NULL;

    RetCode = GetFullName(
        lpFileName,
        &FullName,
        &Server,
        0,
        0,
        0,
        NULL,
        FALSE
        );

    if ( RetCode == ERROR_SUCCESS ){
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );

        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcQueryRecoveryAgents(
                                binding_h,
                                FullName,
                                pRecoveryAgents
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;

            //
            // Free the binding handle
            //

            RpcpUnbindRpc( binding_h );

        } else {

            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }

    return RetCode;
}


DWORD
EfsQueryUsersRPCClient(
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
   DWORD RetCode;
   handle_t  binding_h;
   NTSTATUS Status;
   LPWSTR  FullName;
   LPWSTR  Server;

   //
   // Clear out this parameter, or RPC will choke on the server
   // side.
   //

   *pUsers = NULL;

   RetCode = GetFullName(
       lpFileName,
       &FullName,
       &Server,
       0,
       0,
       0,
       NULL,
       FALSE
       );

   if ( RetCode == ERROR_SUCCESS ){

       Status = RpcpBindRpc (
                    Server,
                    L"lsarpc",
                    0,
                    &binding_h
                    );

       if (NT_SUCCESS(Status)){
           RpcTryExcept {
               RetCode = EfsRpcQueryUsersOnFile(
                               binding_h,
                               FullName,
                               pUsers
                               );
           } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
               RetCode = RpcExceptionCode();
           } RpcEndExcept;

           //
           // Free the binding handle
           //

           RpcpUnbindRpc( binding_h );

       } else {

           RetCode = RtlNtStatusToDosError( Status );
       }
       RtlFreeHeap( RtlProcessHeap(), 0, FullName );
       RtlFreeHeap( RtlProcessHeap(), 0, Server );
   }

   return RetCode;
}


DWORD
EfsSetEncryptionKeyRPCClient(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
{
   DWORD RetCode;
   handle_t  binding_h;
   NTSTATUS Status;
   WCHAR ServerName[3 ];


   wcscpy(&ServerName[0], L".");

   Status = RpcpBindRpc (
                 &ServerName[0],
                 L"lsarpc",
                 0,
                 &binding_h
                 );

   if (NT_SUCCESS(Status)){
       RpcTryExcept {

           RetCode = EfsRpcSetFileEncryptionKey(
                          binding_h,
                          pEncryptionCertificate
                          );

       } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
           RetCode = RpcExceptionCode();
       } RpcEndExcept;

       //
       // Free the binding handle
       //

       RpcpUnbindRpc( binding_h );

    } else {

        RetCode = RtlNtStatusToDosError( Status );
    }


    return RetCode;
}


DWORD
EfsDuplicateEncryptionInfoRPCClient(
    IN LPCWSTR lpSrcFileName,
    IN LPCWSTR lpDestFileName,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN PEFS_RPC_BLOB pRelativeSD,
    IN BOOL bInheritHandle
    )
{
   DWORD RetCode;
   handle_t  binding_h;
   NTSTATUS Status;
   LPWSTR  SrcServer;
   LPWSTR  DestServer;

   LPWSTR FullSrcName;
   LPWSTR FullDestName;
   DWORD  FileAttribute;
   DWORD  Flags = 0;

   RetCode = GetFullName(
               lpSrcFileName,
               &FullSrcName,
               &SrcServer,
               0,
               0,
               0,
               NULL,
               FALSE
               );

   if (RetCode == ERROR_SUCCESS) {

       FileAttribute = GetFileAttributesW(lpSrcFileName);
       if (-1 != FileAttribute) {
           if (FileAttribute & FILE_ATTRIBUTE_DIRECTORY) {
               Flags = CREATE_FOR_DIR;
           }
       }

       if (dwAttributes == 0) {
           FileAttribute = FILE_ATTRIBUTE_NORMAL;
       } else {
           FileAttribute = dwAttributes; 
       }

       RetCode = GetFullName(
                   lpDestFileName,
                   &FullDestName,
                   &DestServer,
                   Flags,
                   dwCreationDistribution,
                   FileAttribute,
                   pRelativeSD,
                   bInheritHandle
                   );

       if (RetCode == ERROR_SUCCESS) {

           BOOL SamePC = TRUE;

           //
           // Only do this if they're on the same server.
           //

           SamePC = (_wcsicmp( SrcServer, DestServer ) == 0);
           if (!SamePC) {

               //
               //  Check loopback case.
               //

               if ((wcscmp( SrcServer, L".") == 0) || (wcscmp( DestServer, L".") == 0)){

                   WCHAR MyComputerName[( MAX_COMPUTERNAME_LENGTH + 1) * sizeof (WCHAR)];
                   DWORD WorkBufferLength = MAX_COMPUTERNAME_LENGTH + 1;
                   BOOL  b;
    
                   b = GetComputerNameW(
                               MyComputerName,
                               &WorkBufferLength
                               );
                   if (b) {
                       if (wcscmp( SrcServer, L".") == 0) {
                           SamePC = (_wcsicmp( MyComputerName, DestServer ) == 0); 
                       } else {
                           SamePC = (_wcsicmp( MyComputerName, SrcServer ) == 0); 
                       }
                   }

               }
           }

           if (SamePC) {

               Status = RpcpBindRpc (
                            SrcServer,
                            L"lsarpc",
                            0,
                            &binding_h
                            );

               if (NT_SUCCESS(Status)){
                   RpcTryExcept {

                       RetCode = EfsRpcDuplicateEncryptionInfoFile(
                                     binding_h,
                                     FullSrcName,
                                     FullDestName,
                                     dwCreationDistribution, 
                                     dwAttributes, 
                                     pRelativeSD,
                                     bInheritHandle
                                     );

                   } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                       RetCode = RpcExceptionCode();
                   } RpcEndExcept;

                   //
                   // Free the binding handle
                   //

                   RpcpUnbindRpc( binding_h );

               } else {

                   RetCode = RtlNtStatusToDosError( Status );
               }

           } else {

               RetCode = ERROR_INVALID_PARAMETER;
           }

           RtlFreeHeap( RtlProcessHeap(), 0, FullDestName );
           RtlFreeHeap( RtlProcessHeap(), 0, DestServer );
       }

       if ((RetCode != ERROR_SUCCESS) && (RetCode != ERROR_FILE_EXISTS) && (CREATE_NEW == dwCreationDistribution)) {

           //
           // Let's delete the file. This is the best effort. No return code is to be
           // checked.
           //

           DeleteFileW(lpDestFileName);

       }

       RtlFreeHeap( RtlProcessHeap(), 0, FullSrcName );
       RtlFreeHeap( RtlProcessHeap(), 0, SrcServer );
   }


   return RetCode;
}


DWORD
EfsFileKeyInfoRPCClient(
    IN LPCWSTR lpFileName,
    IN DWORD   InfoClass,
    OUT PEFS_RPC_BLOB *KeyInfo
    )
{

    DWORD RetCode;
    handle_t  binding_h;
    NTSTATUS Status;
    LPWSTR  FullName;
    LPWSTR  Server;
 
    //
    // Clear out this parameter, or RPC will choke on the server
    // side.
    //
 
    *KeyInfo = NULL;
 
    RetCode = GetFullName(
        lpFileName,
        &FullName,
        &Server,
        0,
        0,
        0,
        NULL,
        FALSE
        );
 
    if ( RetCode == ERROR_SUCCESS ){
 
        Status = RpcpBindRpc (
                     Server,
                     L"lsarpc",
                     0,
                     &binding_h
                     );
 
        if (NT_SUCCESS(Status)){
            RpcTryExcept {
                RetCode = EfsRpcFileKeyInfo(
                                binding_h,
                                FullName,
                                InfoClass,
                                KeyInfo
                                );
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                RetCode = RpcExceptionCode();
            } RpcEndExcept;
 
            //
            // Free the binding handle
            //
 
            RpcpUnbindRpc( binding_h );
 
        } else {
 
            RetCode = RtlNtStatusToDosError( Status );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, FullName );
        RtlFreeHeap( RtlProcessHeap(), 0, Server );
    }
 
    return RetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\ctsamdb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ctsamdb.c

Abstract:

    CT for loading a SAM Accounts Database

    This test creates a number of users in the local SAM Database

    To build this test:

    cd \nt\private\lsa\uclient
    nmake UMTYPE=console UMTEST=ctsamdb

    To run this test:

    1.  Build lsasrv.dll with LSA_SAM_ACCOUNTS_DOMAIN_TEST flag
        enabled in file \nt\private\lsa\server\dbp.h

    2.  On your test system, replace lsasrv.dll in \nt\system32 and reboot.

    3.  Type ctsamdb n to load SAM Database with n users

    4.  Type ctsamdb -1 to delete the users you created.

Author:

    Scott Birrell       (ScottBi)    October 19, 1992

Environment:

Revision History:

--*/

#include "lsaclip.h"


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// LSA Component Test for RPC API - main program                           //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


VOID
CtLsaInitObjectAttributes(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
    )

/*++

Routine Description:

    This function initializes the given Object Attributes structure, including
    Security Quality Of Service.  Memory must be allcated for both
    ObjectAttributes and Security QOS by the caller.

Arguments:

    ObjectAttributes - Pointer to Object Attributes to be initialized.

    SecurityQualityOfService - Pointer to Security QOS to be initialized.

Return Value:

    None.

--*/

{
    SecurityQualityOfService->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService->ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService->EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
    );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes->SecurityQualityOfService = SecurityQualityOfService;
}

VOID __cdecl
main (argc, argv)
int argc;
char **argv;

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING NumberOfAccounts;
    ANSI_STRING NumberOfAccountsAnsi;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE PolicyHandle;

    if (argc != 2) {

        printf("\n");
        printf("Instructions for using SAM Accounts Domain Test Load\n");
        printf("----------------------------------------------------\n");
        printf("\n\n");
        printf("This program can be used to create n users in a SAM\n");
        printf("Accounts domain, or update user information in a domain.\n");
        printf("Usernames and other information are pseudo-randomized\n");
        printf("and Relative Ids begin at 4096, to avoid conflict with\n");
        printf("existing installed accounts\n");
        printf("\n");
        printf("NOTE: \\\\popcorn\\public\\scottbi\\runsamdb temporarily\n");
        printf("contains 340-compatible x86 versions of the four files\n");
        printf("described in steps 1. 2. and 3 below.\n");
        printf("\n");
        printf("1.  Replace lsasrv.dll with one compiled with the\n");
        printf("    LSA_SAM_ACCOUNTS_DOMAIN_TEST #define enabled\n");
        printf("    in file lsa\\server\\dbpolicy.c.\n");
        printf("\n");
        printf("2.  Replace samsrv.dll with one containing chads\n");
        printf("    mondo level SamSetInformationUser changes.\n");
        printf("\n");
        printf("3.  Copy runsamdb.cmd and ctsamdb.exe to a directory\n");
        printf("    on your path\n");
        printf("\n");
        printf("4.  Reboot system with debugger enabled.  Debugger terminal\n");
        printf("    will display a message for each 100 users created\n");
        printf("    plus the time taken to create the last 100 users.\n");
        printf("    If any attempt is made to create an existing user,\n");
        printf("    or a user that conflicts with an existing account, the\n");
        printf("    total number of occurrences of these to date is displayed.\n");
        printf("\n");
        printf("5.  To load a SAM database with n > 0 users, type:\n");
        printf("\n");
        printf("    runsamdb n\n");
        printf("\n");
        printf("6.  To update the SAM database with identical information\n");
        printf("    to that loaded, repeat the command in 5.\n");
        printf("\n");
        printf("7.  To delete the users you created, type\n");
        printf("\n");
        printf("    runsamdb -1\n");
        printf("\n");
        printf("8.  Existing accounts not created by the test will not\n");
        printf("    normally be affected.\n");
        printf("\n");
        printf("9.  To repeat these instructions, type\n");
        printf("\n");
        printf("    runsamdb\n");
        return;
    }

    RtlInitAnsiString( &NumberOfAccountsAnsi, argv[1] );
    RtlAnsiStringToUnicodeString(
        &NumberOfAccounts,
        &NumberOfAccountsAnsi,
        TRUE
        );

    CtLsaInitObjectAttributes(
        &ObjectAttributes,
        &SecurityQualityOfService
        );

    //
    // Open a handle to the local Policy Object.  Use a benign access
    // mask, because we won't check it.
    //

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 &PolicyHandle
                 );

    if (!NT_SUCCESS(Status)) {

        printf("LSA RPC CT - LsaOpenPolicy failed 0x%lx\n", Status);
        return;
    }

    //
    // Use an information class in LsaSetInformationPolicy() that can't be
    // specified normally on a set operation.
    //

    Status = LsaSetInformationPolicy(
                 PolicyHandle,
                 PolicyPdAccountInformation,
                 &NumberOfAccounts
                 );

    Status = LsaClose( PolicyHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\lsarpc_c_stub.c ===
#include "lsarpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=lsa
MINORCOMP=uclient

TARGETTYPE=LIBRARY

INCLUDES=..;..\..\inc;        \
         ..\..\idl;           \
         ..\..\idl\$(O);      \
         $(SECURITY_INC);     \
         $(BASE_INC_PATH);    \
         $(NET_INC_PATH);     \
         $(DS_INC_PATH);      \
         $(DS_INC_PATH)\crypto; \
         $(COM_INC_PATH);     \
         $(DRIVERS_INC_PATH);

UMTYPE=windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\rpcclimm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rpcclimm.c

Abstract:

    LSA - Client RPC Memory Management Routines

    NOTE: These routines use windows API, so are different from
          their server counterparts.
Author:

    Scott Birrell       (ScottBi)      May 1, 1991

Environment:

Revision History:

--*/

#include "lsaclip.h"
/*
#include <nt.h>      // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <rpc.h>        // DataTypes and runtime APIs
#include <lsarpc.h>     // generated by the MIDL complier
#include <nturtl.h>     // needed for windows.h
#include <windows.h>    // LocalAlloc
#include <string.h>     // for strcpy strcat strlen memcmp
*/


PVOID
MIDL_user_allocate (
    unsigned int   NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC server transactions.  The RPC stubs will
    either call MIDL_user_allocate when it needs to un-marshall data into a
    buffer that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    return (LocalAlloc(LMEM_FIXED,NumBytes));
}



VOID
MIDL_user_free (
    void    *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/

{
    LocalFree(MemPointer);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\tlookup.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    tlookup.c

Abstract:

    Test for a leak in LsaLookupName().


    nmake UMTYPE=console UMTEST=tlookup

Author:

    Jim Kelly (JimK) Mar-31-1994


Revision History:

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#include <nt.h>
#include <ntlsa.h>
#include <ntrtl.h>
#include <stdio.h>
#include <string.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

ULONG
    TLsapLoopLimit = 1000;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Local routine definitions                                           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Routines                                                            //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

VOID __cdecl
main(argc, argv)
int argc;
char **argv;
{

    NTSTATUS
        NtStatus,
        LookupSidStatus = STATUS_SUCCESS;

    ULONG
        i;

    LSA_HANDLE
        PolicyHandle;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    UNICODE_STRING
        NameBuffer,
        SystemName;

    PUNICODE_STRING
        Names;

    PLSA_REFERENCED_DOMAIN_LIST
        ReferencedDomains;

    PLSA_TRANSLATED_SID
        Sids;

    ULONG
        SidLength;

    PSID
        LookupSid;

    BOOLEAN
        DoSidTest;

    PLSA_TRANSLATED_NAME
        TranslatedNames;


    Names = &NameBuffer;
    RtlInitUnicodeString( &NameBuffer, L"jimk_dom2\\Jimk_d2_t1" );
    RtlInitUnicodeString( &SystemName, L"" );


    printf("\n\nLsaLookupName() and LsaLookupSid() test.\n"
           "This test is good to use when looking for leaks\n"
           "in the lookup paths.\n\n");


    //
    // open the policy object and then loop, looking up names.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0L, NULL, NULL );
    NtStatus = LsaOpenPolicy(
                   &SystemName,
                   &ObjectAttributes,
                   POLICY_EXECUTE,
                   &PolicyHandle
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get a sid to lookup
        //

        ReferencedDomains = NULL;
        Sids = NULL;
        NtStatus = LsaLookupNames(
                       PolicyHandle,
                       1,                   //Count
                       Names,
                       &ReferencedDomains,
                       &Sids
                       );
        if (NT_SUCCESS(NtStatus)) {

            //
            // Build a sid to use in the lookup
            // This is done by copying the ReferencedDomain sid,
            // then adding one more relative ID.
            //

            ASSERT(ReferencedDomains != NULL);
            ASSERT(Sids != NULL);

            SidLength =
                sizeof(ULONG) +
                RtlLengthSid( &ReferencedDomains->Domains[Sids[0].DomainIndex].Sid );

            LookupSid = RtlAllocateHeap( RtlProcessHeap(), 0, SidLength );
            ASSERT(LookupSid != NULL);

            RtlCopySid( SidLength,
                        LookupSid,
                        ReferencedDomains->Domains[Sids[0].DomainIndex].Sid );
            (*RtlSubAuthoritySid(
                LookupSid,
                (ULONG)(*RtlSubAuthorityCountSid(LookupSid))
                )) = Sids[0].RelativeId;
            (*RtlSubAuthorityCountSid(LookupSid)) += 1;

            DoSidTest = TRUE;

        } else {
        
            printf("ERROR: Couldn't get SID value to lookup.\n"
                   "       Won't perform SID lookup part of test.\n\n");
            DoSidTest = FALSE;
        }

        if (ReferencedDomains != NULL) {
            LsaFreeMemory( ReferencedDomains );
        }
        if (Sids != NULL) {
            LsaFreeMemory( Sids );
        }


        printf("\nLooping %d times...\n", TLsapLoopLimit);
        for (i=0; i<TLsapLoopLimit; i++) {

        printf("\r Loop Count %#4d  LookupName Status: 0x%08lx  LookupSid Status: 0x%08lx",
               i, NtStatus, LookupSidStatus);

            //
            // Lookup name
            //

            ReferencedDomains = NULL;
            Sids = NULL;
            NtStatus = LsaLookupNames(
                           PolicyHandle,
                           1,                   //Count
                           Names,
                           &ReferencedDomains,
                           &Sids
                           );

            if (ReferencedDomains != NULL) {
                LsaFreeMemory( ReferencedDomains );
            }
            if (Sids != NULL) {
                LsaFreeMemory( Sids );
            }



            //
            // Lookup SID
            //

            if (DoSidTest) {
                ReferencedDomains = NULL;
                Sids = NULL;
                LookupSidStatus = LsaLookupSids(
                                      PolicyHandle,
                                      1,                   //Count
                                      &LookupSid,
                                      &ReferencedDomains,
                                      &TranslatedNames
                                      );
        
                if (ReferencedDomains != NULL) {
                    LsaFreeMemory( ReferencedDomains );
                }
                if (TranslatedNames != NULL) {
                    LsaFreeMemory( TranslatedNames );
                }

            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\rpcbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    LSA - Client RPC Binding Routines

Author:

    Scott Birrell       (ScottBi)      April 30, 1991

Environment:

Revision History:

--*/

#include "lsaclip.h"

#include <ntrpcp.h>     // prototypes for MIDL user functions

#include "adtgen.h"

handle_t
PLSAPR_SERVER_NAME_bind (
    IN OPTIONAL PLSAPR_SERVER_NAME   ServerName
    )

/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to bind to the LSA on some server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/

{
    handle_t    BindingHandle;
    NTSTATUS  Status;

    Status = RpcpBindRpc (
                 ServerName,
                 L"lsarpc",
                 0,
                 &BindingHandle
                 );

    if (!NT_SUCCESS(Status)) {

        // DbgPrint("PLSAPR_SERVER_NAME_bind: RpcpBindRpc failed 0x%lx\n", Status);

    }

    return( BindingHandle);
}


VOID
PLSAPR_SERVER_NAME_unbind (
    IN OPTIONAL PLSAPR_SERVER_NAME  ServerName,
    IN handle_t           BindingHandle
    )

/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to unbind from the LSA server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RpcpUnbindRpc ( BindingHandle );
    return;

    UNREFERENCED_PARAMETER( ServerName );     // This parameter is not used
}



DWORD
LsaNtStatusToWinError(
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine converts and NTSTATUS to an win32 error code.  It is used
    by people who want to call the LSA APIs but are writing for a win32
    environment.

Arguments:

    Status - The status code to be mapped

Return Value:

    The return from RtlNtStatusToDosError.  If the error could not be
    mapped, then ERROR_MR_MID_NOT_FOUND is returned.

--*/

{
    return(RtlNtStatusToDosError(Status));
}



NTSTATUS
LsapApiReturnResult(
    ULONG ExceptionCode
    )

/*++

Routine Description:

    This function converts an exception code or status value returned
    from the client stub to a value suitable for return by the API to
    the client.

Arguments:

    ExceptionCode - The exception code to be converted.

Return Value:

    NTSTATUS - The converted Nt Status code.

--*/

{
    //
    // Return the actual value if compatible with Nt status codes,
    // otherwise, return STATUS_UNSUCCESSFUL.
    //

    if (!NT_SUCCESS((NTSTATUS) ExceptionCode)) {

        return (NTSTATUS) ExceptionCode;

    } else {

        return STATUS_UNSUCCESSFUL;
    }
}

handle_t
PAUTHZ_AUDIT_EVENT_TYPE_OLD_bind (
    IN PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType
    )
/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to bind to local LSA.

Arguments:

    AuditInfo -- ignored

Return Value:

    The binding handle is returned to the stub routine.
    If the binding is unsuccessful, a NULL will be returned.

--*/

{
    handle_t   hBinding=NULL;
    NTSTATUS   Status;
    PWSTR      pszBinding;
    RPC_STATUS RpcStatus;
    
    //
    // the first param takes a server-name. use NULL
    // to force a local binding
    //

    RpcStatus = RpcStringBindingComposeW(
                    NULL,               // uuid of lsarpc
                    L"ncalrpc",         // we want to use LRPC
                    NULL,               // network address (local machine)
                    L"audit",           // endpoint name
                    L"",                // options
                    &pszBinding );

    if ( RpcStatus == RPC_S_OK )
    {
        RpcStatus = RpcBindingFromStringBindingW(
                        pszBinding,
                        &hBinding
                        );
    
        RpcStringFreeW( &pszBinding );
    }

    Status = I_RpcMapWin32Status( RpcStatus );

    if (!NT_SUCCESS(Status)) {

        DbgPrint("PAUDIT_AUTHZ_AUDIT_EVENT_OLD_bind: failed 0x%lx\n", Status);

    }

    UNREFERENCED_PARAMETER( pAuditEventType );

    return( hBinding );
}


VOID
PAUTHZ_AUDIT_EVENT_TYPE_OLD_unbind (
    IN PAUTHZ_AUDIT_EVENT_TYPE_OLD  pAuditEventType,    OPTIONAL
    IN handle_t                     BindingHandle
    )

/*++

Routine Description:

    This routine is called from the LSA client stubs when
    it is necessary to unbind from the LSA server.


Arguments:

    AuditInfo     - ignored

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RpcpUnbindRpc ( BindingHandle );

    UNREFERENCED_PARAMETER( pAuditEventType );     // This parameter is not used

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\rpcapi2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rpcapi2.c

Abstract:

    This module contains the routines for the LSA API that use RPC.  The
    routines in this module are merely wrappers that work as follows:

    o Client program calls LsaFoo in this module
    o LsaFoo calls RPC client stub interface routine LsapFoo with
      similar parameters.  Some parameters are translated from types
      (e.g structures containing PVOIDs or certain kinds of variable length
      parameters such as pointers to SID's) that are not specifiable on an
      RPC interface, to specifiable form.
    o RPC client stub LsapFoo calls interface specific marshalling routines
      and RPC runtime to marshal parameters into a buffer and send them over
      to the server side of the LSA.
    o Server side calls RPC runtime and interface specific unmarshalling
      routines to unmarshal parameters.
    o Server side calls worker LsapFoo to perform API function.
    o Server side marshals response/output parameters and communicates these
      back to client stub LsapFoo
    o LsapFoo exits back to LsaFoo which returns to client program.

Author:

    Mike Swift      (MikeSw)    December 7, 1994

Revision History:

--*/

#define UNICODE         // required for TEXT() to be defined properly
#include "lsaclip.h"

#include <lmcons.h>
#include <logonmsv.h>
#include <rc4.h>
#include <rpcasync.h>

typedef struct _LSAP_DB_RIGHT_AND_ACCESS {
    UNICODE_STRING UserRight;
    ULONG SystemAccess;
} LSAP_DB_RIGHT_AND_ACCESS, *PLSAP_DB_RIGHT_AND_ACCESS;

#define LSAP_DB_SYSTEM_ACCESS_TYPES 4

LSAP_DB_RIGHT_AND_ACCESS LsapDbRightAndAccess[LSAP_DB_SYSTEM_ACCESS_TYPES] = {
    {{sizeof(SE_INTERACTIVE_LOGON_NAME)-sizeof(WCHAR),
      sizeof(SE_INTERACTIVE_LOGON_NAME),
      SE_INTERACTIVE_LOGON_NAME},
      SECURITY_ACCESS_INTERACTIVE_LOGON},
    {{sizeof(SE_NETWORK_LOGON_NAME)-sizeof(WCHAR),
      sizeof(SE_NETWORK_LOGON_NAME),
      SE_NETWORK_LOGON_NAME},
      SECURITY_ACCESS_NETWORK_LOGON},
    {{sizeof(SE_BATCH_LOGON_NAME)-sizeof(WCHAR),
      sizeof(SE_BATCH_LOGON_NAME),
      SE_BATCH_LOGON_NAME},
      SECURITY_ACCESS_BATCH_LOGON},
    {{sizeof(SE_SERVICE_LOGON_NAME)-sizeof(WCHAR),
      sizeof(SE_SERVICE_LOGON_NAME),
      SE_SERVICE_LOGON_NAME},
      SECURITY_ACCESS_SERVICE_LOGON}
    };

//
// Structure to maintain list of enumerated accounts
//

typedef struct _SID_LIST_ENTRY {
    struct _SID_LIST_ENTRY * Next;
    PSID Sid;
} SID_LIST_ENTRY, *PSID_LIST_ENTRY;

//
// Functions private to this module
//

NTSTATUS
LsapApiReturnResult(
    IN ULONG ExceptionCode
    );

NTSTATUS
LsapApiConvertRightsToPrivileges(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING UserRights,
    IN ULONG RightCount,
    OUT PPRIVILEGE_SET * Privileges,
    OUT PULONG SystemAccess
    );

NTSTATUS
LsapApiConvertPrivilegesToRights(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN OPTIONAL ULONG SystemAccess,
    OUT PUNICODE_STRING * UserRights,
    OUT PULONG RightCount
    );


//////////////////////////////////////////////////////////////////////
//
// This set of routines implements the same functionality as the APIs
// below but do it with the APIs present through NT 3.5
//
/////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
LsapEnumerateAccountsWithUserRight(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PUNICODE_STRING UserRights,
    OUT PVOID *EnumerationBuffer,
    OUT PULONG CountReturned
    )

/*++

Routine Description:


    The LsaEnumerateAccountsWithUserRight API returns information about
    the accounts in the target system's Lsa Database.  This call requires
    LSA_ENUMERATE_ACCOUNTS access to the Policy object.  Since this call
    accesses the privileges of an account, you must have ACCOUNT_VIEW access
    access to all accounts.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    UserRight - Name of the right that the account must have.

    Buffer - Receives a pointer to a LSA_ENUMERATION_INFORMATION structure
        containing the SIDs of all the accounts.

    CountReturned - Receives the number of sids returned.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects are enumerated because the
            EnumerationContext value passed in is too high.
--*/


{
    NTSTATUS Status;
    PLSA_ENUMERATION_INFORMATION Accounts = NULL;
    PPRIVILEGE_SET DesiredPrivilege = NULL;
    ULONG DesiredAccess = 0;
    PPRIVILEGE_SET Privileges = NULL;
    ULONG SystemAccess;
    LSA_ENUMERATION_HANDLE EnumContext = 0;
    ULONG AccountCount;
    ULONG AccountIndex;
    LSA_HANDLE AccountHandle = NULL;
    PSID_LIST_ENTRY AccountList = NULL;
    PSID_LIST_ENTRY NextAccount = NULL;
    ULONG AccountSize;
    PUCHAR Where;
    ULONG PrivilegeIndex;

    Status = LsapApiConvertRightsToPrivileges(
                PolicyHandle,
                UserRights,
                (UserRights ? 1 : 0),
                &DesiredPrivilege,
                &DesiredAccess
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Enumerate all the accounts.
    //

    do
    {
        Status = LsaEnumerateAccounts(
                    PolicyHandle,
                    &EnumContext,
                    &Accounts,
                    32000,
                    &AccountCount
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // For each account, check that it has the desired right
        //

        for (AccountIndex = 0; AccountIndex < AccountCount ; AccountIndex++ ) {

            if ((DesiredPrivilege != NULL) || (DesiredAccess != 0)) {

                Status = LsaOpenAccount(
                            PolicyHandle,
                            Accounts[AccountIndex].Sid,
                            ACCOUNT_VIEW,
                            &AccountHandle
                            );

                if (!NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

                //
                // If a privilege was requested, get the privilegs
                //

                if (DesiredPrivilege != NULL) {

                    Privileges = NULL;
                    Status = LsaEnumeratePrivilegesOfAccount(
                                AccountHandle,
                                &Privileges
                                );
                    if (!NT_SUCCESS(Status)) {
                        goto Cleanup;
                    }

                    //
                    // Search for the desired privilege
                    //

                    for (PrivilegeIndex = 0;
                         PrivilegeIndex < Privileges->PrivilegeCount ;
                         PrivilegeIndex++) {

                        if (RtlEqualLuid(&Privileges->Privilege[PrivilegeIndex].Luid,
                                         &DesiredPrivilege->Privilege[0].Luid)) {
                                break;
                        }
                    }

                    //
                    // If we found the privilege, add it to the list.
                    //

                    if (PrivilegeIndex != Privileges->PrivilegeCount) {

                        //
                        // Add this account to the enumeration.
                        //

                        NextAccount = MIDL_user_allocate(sizeof(SID_LIST_ENTRY));
                        if (NextAccount == NULL) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                        NextAccount->Sid = MIDL_user_allocate(RtlLengthSid(Accounts[AccountIndex].Sid));
                        if (NextAccount->Sid == NULL) {
                            MIDL_user_free(NextAccount);
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                        RtlCopyMemory(
                            NextAccount->Sid,
                            Accounts[AccountIndex].Sid,
                            RtlLengthSid(Accounts[AccountIndex].Sid)
                            );
                        NextAccount->Next = AccountList;
                        AccountList = NextAccount;

                    }
                    LsaFreeMemory(Privileges);
                    Privileges = NULL;

                } else {

                    //
                    // Otherwise get the system access
                    //

                    ASSERT(DesiredAccess != 0);

                    Status = LsaGetSystemAccessAccount(
                                AccountHandle,
                                &SystemAccess
                                );

                    if (!NT_SUCCESS(Status)) {
                        goto Cleanup;
                    }

                    //
                    // Check for the desired access
                    //

                    if ((SystemAccess & DesiredAccess) != 0) {

                        //
                        // Add this account to the enumeration.
                        //

                        NextAccount = MIDL_user_allocate(sizeof(SID_LIST_ENTRY));
                        if (NextAccount == NULL) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                        NextAccount->Sid = MIDL_user_allocate(RtlLengthSid(Accounts[AccountIndex].Sid));
                        if (NextAccount->Sid == NULL) {
                            MIDL_user_free(NextAccount);
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                        RtlCopyMemory(
                            NextAccount->Sid,
                            Accounts[AccountIndex].Sid,
                            RtlLengthSid(Accounts[AccountIndex].Sid)
                            );
                        NextAccount->Next = AccountList;
                        AccountList = NextAccount;

                    }
                }

                LsaClose(AccountHandle);
                AccountHandle = NULL;


            } else {
                //
                // always add the account if the caller didn't want
                // filtering.
                //

                NextAccount = MIDL_user_allocate(sizeof(SID_LIST_ENTRY));
                if (NextAccount == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                NextAccount->Sid = MIDL_user_allocate(RtlLengthSid(Accounts[AccountIndex].Sid));
                if (NextAccount->Sid == NULL) {
                    MIDL_user_free(NextAccount);
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                RtlCopyMemory(
                    NextAccount->Sid,
                    Accounts[AccountIndex].Sid,
                    RtlLengthSid(Accounts[AccountIndex].Sid)
                    );
                NextAccount->Next = AccountList;
                AccountList = NextAccount;
            }

        }
        LsaFreeMemory(Accounts);
        Accounts = NULL;

    } while ( 1 );

    if (Status != STATUS_NO_MORE_ENTRIES) {
        goto Cleanup;
    }

    AccountSize = 0;
    AccountCount = 0;
    for (NextAccount = AccountList ; NextAccount != NULL; NextAccount = NextAccount->Next) {
        AccountSize += sizeof(LSA_ENUMERATION_INFORMATION) +
                        RtlLengthSid(NextAccount->Sid);
        AccountCount++;
    }

    //
    // If there were no accounts return a warning now.
    //

    if (AccountCount == 0) {
        *EnumerationBuffer = NULL;
        *CountReturned = 0;
        Status = STATUS_NO_MORE_ENTRIES;
        goto Cleanup;
    }

    Accounts = MIDL_user_allocate(AccountSize);
    if (Accounts == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Marshall all the sids into the array.
    //

    Where = (PUCHAR) Accounts + AccountCount * sizeof(LSA_ENUMERATION_INFORMATION);

    for (   NextAccount = AccountList,AccountIndex = 0 ;
            NextAccount != NULL;
            NextAccount = NextAccount->Next, AccountIndex++) {

        Accounts[AccountIndex].Sid = (PSID) Where;
        RtlCopyMemory(
            Where,
            NextAccount->Sid,
            RtlLengthSid(NextAccount->Sid)
            );
        Where += RtlLengthSid(NextAccount->Sid);
    }
    ASSERT(AccountIndex == AccountCount);
    ASSERT(Where - (PUCHAR) Accounts == (LONG) AccountSize);
    *EnumerationBuffer = Accounts;
    Accounts = NULL;
    *CountReturned = AccountCount;
    Status = STATUS_SUCCESS;


Cleanup:
    if (AccountList != NULL) {
        while (AccountList != NULL) {
            NextAccount = AccountList->Next;
            MIDL_user_free(AccountList->Sid);
            MIDL_user_free(AccountList);
            AccountList = NextAccount;
        }
    }

    if (Accounts != NULL) {
        MIDL_user_free(Accounts);
    }

    if (Privileges != NULL) {
        LsaFreeMemory(Privileges);
    }
    return(Status);
}



NTSTATUS
NTAPI
LsapEnumerateAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    OUT PUNICODE_STRING *UserRights,
    OUT PULONG CountOfRights
    )

/*++

Routine Description:

    Returns all the rights of an account.  This is done by gathering the
    privileges and system access of an account and translating that into
    an array of strings.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  This API requires
        no special access.

    AccountSid - Sid of account to open.

    UserRights - receives an array of user rights (UNICODE_STRING) for
        the account.

    CountOfRights - receives the number of rights returned.


Return Value:

    STATUS_ACCESS_DENIED - the caller did not have sufficient access to
        return the privileges or system access of the account.

    STATUS_OBJECT_NAME_NOT_FOUND - the specified account did not exist.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the
        request.

--*/
{
    NTSTATUS Status;
    PPRIVILEGE_SET Privileges = NULL;
    ULONG SystemAccess = 0;
    PUNICODE_STRING Rights = NULL;
    ULONG RightCount = 0;
    LSA_HANDLE AccountHandle = NULL;

    Status = LsaOpenAccount(
                PolicyHandle,
                AccountSid,
                ACCOUNT_VIEW,
                &AccountHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Query the privilegs and system access
    //

    Status = LsaEnumeratePrivilegesOfAccount(
                AccountHandle,
                &Privileges
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaGetSystemAccessAccount(
                AccountHandle,
                &SystemAccess
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Convert the privileges and access to rights
    //

    Status = LsapApiConvertPrivilegesToRights(
                PolicyHandle,
                Privileges,
                SystemAccess,
                &Rights,
                &RightCount
                );
    if (NT_SUCCESS(Status)) {
        *CountOfRights = RightCount;
        *UserRights = Rights;
    }
Cleanup:
    if (Privileges != NULL) {
        LsaFreeMemory(Privileges);
    }
    if (AccountHandle != NULL) {
        LsaClose(AccountHandle);
    }

    return(Status);

}

NTSTATUS
NTAPI
LsapAddAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN PUNICODE_STRING UserRights,
    IN ULONG CountOfRights
    )
/*++

Routine Description:

    Adds rights to the account specified by the account sid.  If the account
    does not exist, it creates the account.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must have
        POLICY_CREATE_ACCOUNT access if this is the first call for this
        AccountSid.

    AccountSid - Sid of account to add rights to

    UserRights - Array of unicode strings naming rights to add to the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/
{
    LSA_HANDLE AccountHandle = NULL;
    NTSTATUS Status;
    PPRIVILEGE_SET Privileges = NULL;
    ULONG SystemAccess;
    ULONG OldAccess;

    //
    // Convert the rights into privileges and system access.
    //

    Status = LsapApiConvertRightsToPrivileges(
                PolicyHandle,
                UserRights,
                CountOfRights,
                &Privileges,
                &SystemAccess
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Open the account.  If it does not exist ,create the account.
    //

    Status = LsaOpenAccount(
                PolicyHandle,
                AccountSid,
                ACCOUNT_ADJUST_PRIVILEGES |
                    ACCOUNT_ADJUST_SYSTEM_ACCESS |
                    ACCOUNT_VIEW,
                &AccountHandle
                );

    //
    // if the account did not exist, try to create it.
    //

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = LsaCreateAccount(
                    PolicyHandle,
                    AccountSid,
                    ACCOUNT_ADJUST_PRIVILEGES |
                        ACCOUNT_ADJUST_SYSTEM_ACCESS |
                        ACCOUNT_VIEW,
                    &AccountHandle
                    );
    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaGetSystemAccessAccount(
                AccountHandle,
                &OldAccess
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaSetSystemAccessAccount(
                AccountHandle,
                OldAccess | SystemAccess
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaAddPrivilegesToAccount(
                AccountHandle,
                Privileges
                );
Cleanup:

    if (Privileges != NULL) {
        MIDL_user_free(Privileges);
    }
    if (AccountHandle != NULL) {
        LsaClose(AccountHandle);
    }
    return(Status);
}

NTSTATUS
NTAPI
LsapRemoveAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN BOOLEAN AllRights,
    IN PUNICODE_STRING UserRights,
    IN ULONG CountOfRights
    )

/*++

Routine Description:

    Removes rights to the account specified by the account sid.  If the
    AllRights flag is set or if all the rights are removed, the account
    is deleted.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call

    AccountSid - Sid of account to remove rights from

    UserRights - Array of unicode strings naming rights to remove from the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/
{
    LSA_HANDLE AccountHandle = NULL;
    NTSTATUS Status;
    PPRIVILEGE_SET Privileges = NULL;
    PPRIVILEGE_SET NewPrivileges = NULL;
    ULONG SystemAccess = 0 ;
    ULONG OldAccess;
    ULONG DesiredAccess;
    ULONG NewAccess;

    //
    // Convert the rights into privileges and system access.
    //

    if (!AllRights) {
        Status = LsapApiConvertRightsToPrivileges(
                    PolicyHandle,
                    UserRights,
                    CountOfRights,
                    &Privileges,
                    &SystemAccess
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        DesiredAccess = ACCOUNT_ADJUST_PRIVILEGES |
                            ACCOUNT_ADJUST_SYSTEM_ACCESS |
                            ACCOUNT_VIEW | DELETE;
    } else {
        DesiredAccess = DELETE;
    }



    //
    // Open the account.
    //

    Status = LsaOpenAccount(
                PolicyHandle,
                AccountSid,
                DesiredAccess,
                &AccountHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If we are to remove all rights, just delete the account ,and if that
    // succeeds, zero the handle so we don't try to close it later.
    //

    if (AllRights) {
        Status = LsaDelete(
                    AccountHandle
                    );
        if (NT_SUCCESS(Status)) {
            AccountHandle = NULL;
        }
        goto Cleanup;
    }

    //
    // Get the old system access to adjust
    //

    Status = LsaGetSystemAccessAccount(
                AccountHandle,
                &OldAccess
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    NewAccess = OldAccess & ~SystemAccess;
    Status = LsaSetSystemAccessAccount(
                AccountHandle,
                NewAccess
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaRemovePrivilegesFromAccount(
                AccountHandle,
                FALSE,          // don't remove all
                Privileges
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Now query the privilegs to see if they are zero.  If so, and
    // system access is zero, delete the account.
    //

    Status = LsaEnumeratePrivilegesOfAccount(
                AccountHandle,
                &NewPrivileges
                );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // If the account has no privileges or access, delete it.
    //

    if ((NewPrivileges->PrivilegeCount == 0) &&
        (NewAccess == 0)) {

        Status = LsaDelete(
                    AccountHandle
                    );
        if (NT_SUCCESS(Status)) {
            AccountHandle = NULL;
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if (Privileges != NULL) {
        MIDL_user_free(Privileges);
    }
    if (AccountHandle != NULL) {
        LsaClose(AccountHandle);
    }
    if (NewPrivileges != NULL) {
        LsaFreeMemory(NewPrivileges);
    }
    return(Status);

}


NTSTATUS
LsapApiBuildSecretName(
    PTRUSTED_DOMAIN_NAME_INFO NameInfo,
    PUNICODE_STRING OutputSecretName
    )
{
    UNICODE_STRING SecretName;

    //
    // The secret name is G$$domain name, where G$ is the global prefix and
    // $ is the ssi prefix
    //

    SecretName.Length = NameInfo->Name.Length +
                        (SSI_SECRET_PREFIX_LENGTH +
                         LSA_GLOBAL_SECRET_PREFIX_LENGTH) * sizeof(WCHAR);
    SecretName.MaximumLength = SecretName.Length;
    SecretName.Buffer = (LPWSTR) MIDL_user_allocate( SecretName.Length );

    if (SecretName.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    wcscpy(
        SecretName.Buffer,
        LSA_GLOBAL_SECRET_PREFIX
        );

    wcscat(
        SecretName.Buffer,
        SSI_SECRET_PREFIX
        );
    RtlCopyMemory(
        SecretName.Buffer +
            LSA_GLOBAL_SECRET_PREFIX_LENGTH +
            SSI_SECRET_PREFIX_LENGTH,
        NameInfo->Name.Buffer,
        NameInfo->Name.Length
        );
    *OutputSecretName = SecretName;
    return(STATUS_SUCCESS);

}

NTSTATUS
NTAPI
LsapQueryTrustedDomainInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    The LsaQueryTrustedDomainInfo API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).  It also
    may query the secret object (for the TrustedDomainPasswordInformation
    class).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to query.

    InformationClass - Specifies the information to be returned.

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/
{
    NTSTATUS Status;
    LSA_HANDLE DomainHandle = NULL;
    LSA_HANDLE SecretHandle = NULL;
    PUNICODE_STRING OldPassword = NULL;
    PUNICODE_STRING Password = NULL;
    PTRUSTED_PASSWORD_INFO PasswordInfo = NULL;
    PTRUSTED_DOMAIN_NAME_INFO NameInfo = NULL;
    ULONG DesiredAccess;
    PVOID LocalBuffer = NULL;
    TRUSTED_INFORMATION_CLASS LocalInfoClass;
    UNICODE_STRING SecretName;
    PUCHAR Where;
    ULONG PasswordSize;

    SecretName.Buffer = NULL;

    //
    // Find the desired access type for the info we are
    // querying.
    //

    LocalInfoClass = InformationClass;

    switch(InformationClass) {
    case TrustedDomainNameInformation:
        DesiredAccess = TRUSTED_QUERY_DOMAIN_NAME;
        break;
    case TrustedPosixOffsetInformation:
        DesiredAccess = TRUSTED_QUERY_POSIX;
        break;
    case TrustedPasswordInformation:
        DesiredAccess = TRUSTED_QUERY_DOMAIN_NAME;
        LocalInfoClass = TrustedDomainNameInformation;
        break;
    default:
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Open the domain for the desired access
    //


    Status = LsaOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                DesiredAccess,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaQueryInfoTrustedDomain(
                DomainHandle,
                LocalInfoClass,
                &LocalBuffer
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If the class wasn't trusted password information, return here.
    //

    if (InformationClass != TrustedPasswordInformation) {
        *Buffer = LocalBuffer;
        LocalBuffer = NULL;
        goto Cleanup;
    }
    NameInfo = (PTRUSTED_DOMAIN_NAME_INFO) LocalBuffer;

    //
    // Get the secret name
    //

    Status = LsapApiBuildSecretName(
                NameInfo,
                &SecretName
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaOpenSecret(
                PolicyHandle,
                &SecretName,
                SECRET_QUERY_VALUE,
                &SecretHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Query the secret
    //

    Status = LsaQuerySecret(
                SecretHandle,
                &Password,
                NULL,
                &OldPassword,
                NULL
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Marshall the passwords into the output structure.
    //

    PasswordSize = sizeof(TRUSTED_PASSWORD_INFO);
    if (Password != NULL) {
        PasswordSize += Password->MaximumLength;
    }

    if (OldPassword != NULL) {
        PasswordSize += OldPassword->MaximumLength;
    }

    PasswordInfo = (PTRUSTED_PASSWORD_INFO) MIDL_user_allocate(PasswordSize);
    if (PasswordInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        PasswordInfo,
        PasswordSize
        );

    Where = (PUCHAR) (PasswordInfo+1);

    if (Password != NULL) {
        PasswordInfo->Password = *Password;
        PasswordInfo->Password.Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            Password->Buffer,
            Password->MaximumLength
            );
        Where += Password->MaximumLength;
    }

    if (OldPassword != NULL) {
        PasswordInfo->OldPassword = *OldPassword;
        PasswordInfo->OldPassword.Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            OldPassword->Buffer,
            OldPassword->MaximumLength
            );
        Where += OldPassword->MaximumLength;
    }

    ASSERT(Where - (PUCHAR) PasswordInfo == (LONG) PasswordSize);

    *Buffer = PasswordInfo;
    Status = STATUS_SUCCESS;

Cleanup:
    if (DomainHandle != NULL) {
        LsaClose(DomainHandle);
    }

    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }

    if (LocalBuffer != NULL) {
        LsaFreeMemory(LocalBuffer);
    }

    if (SecretName.Buffer != NULL) {
        MIDL_user_free(SecretName.Buffer);
    }

    return(Status);

}

NTSTATUS
NTAPI
LsapSetTrustedDomainInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )
/*++

Routine Description:


    The LsaSetTrustedDomainInformation API modifies information in the Trusted
    Domain Object and in the Secret Object.  The caller must have access
    appropriate to the information to be changed in the Policy Object, see
    the InformationClass parameter.

    If the domain does not yet exist and the information class is
    TrustedDomainNameInformation, then the domain is created.  If the
    domain exists and the class is TrustedDomainNameInformation, an
    error is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to modify.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedDomainNameInformation      POLICY_TRUST_ADMIN
        TrustedPosixOffsetInformation     none
        TrustedPasswordInformation        POLICY_CREATE_SECRET

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/
{
    LSA_HANDLE DomainHandle = NULL;
    LSA_HANDLE SecretHandle = NULL;
    NTSTATUS Status;
    PUNICODE_STRING OldPassword;
    PUNICODE_STRING Password;
    LSA_TRUST_INFORMATION DomainInformation;
    PTRUSTED_DOMAIN_NAME_INFO NameInfo = NULL;
    PTRUSTED_PASSWORD_INFO PasswordInfo;
    UNICODE_STRING SecretName;

    SecretName.Buffer = NULL;

    //
    // If the information is the domain name, try to create the domain.
    //

    if (InformationClass == TrustedDomainNameInformation) {
        DomainInformation.Sid = TrustedDomainSid;
        DomainInformation.Name = ((PTRUSTED_DOMAIN_NAME_INFO) Buffer)->Name;

        Status = LsaCreateTrustedDomain(
                    PolicyHandle,
                    &DomainInformation,
                    0,  //desired access,
                    &DomainHandle
                    );
        goto Cleanup;
    }

    //
    // For posix offset, open the domain for SET_POSIX and call the old
    // LSA API to set the offset.
    //

    if (InformationClass == TrustedPosixOffsetInformation) {
        Status = LsaOpenTrustedDomain(
                    PolicyHandle,
                    TrustedDomainSid,
                    TRUSTED_SET_POSIX,
                    &DomainHandle
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        Status = LsaSetInformationTrustedDomain(
                    DomainHandle,
                    InformationClass,
                    Buffer
                    );
        goto Cleanup;
    }

    //
    // The only only remaining allowed class is password information.
    //

    if (InformationClass != TrustedPasswordInformation) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = LsaOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                TRUSTED_QUERY_DOMAIN_NAME,
                &DomainHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Get the name so we can find the secret name.
    //

    Status = LsaQueryInfoTrustedDomain(
                DomainHandle,
                TrustedDomainNameInformation,
                &NameInfo
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Get the secret name
    //

    Status = LsapApiBuildSecretName(
                NameInfo,
                &SecretName
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaOpenSecret(
                PolicyHandle,
                &SecretName,
                SECRET_SET_VALUE,
                &SecretHandle
                );

    //
    // If the secret didn't exist, create it now.
    //
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        Status = LsaCreateSecret(
                    PolicyHandle,
                    &SecretName,
                    SECRET_SET_VALUE,
                    &SecretHandle
                    );

    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If the old password wasn't specified, set it to be the new
    // password.
    //

    PasswordInfo = (PTRUSTED_PASSWORD_INFO) Buffer;
    Password = &PasswordInfo->Password;
    if (PasswordInfo->OldPassword.Buffer == NULL) {
        OldPassword = Password;
    } else {
        OldPassword = &PasswordInfo->OldPassword;
    }

    Status = LsaSetSecret(
                SecretHandle,
                Password,
                OldPassword
                );
Cleanup:
    if (SecretName.Buffer != NULL) {
        MIDL_user_free(SecretName.Buffer);
    }

    if (DomainHandle != NULL) {
        LsaClose(DomainHandle);
    }

    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }

    if (NameInfo != NULL) {
        LsaFreeMemory(NameInfo);
    }

    return(Status);


}

NTSTATUS
NTAPI
LsapDeleteTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid
    )

/*++

Routine Description:

    This routine deletes a trusted domain and the associated secret.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to delete

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to delete
        the requested domain.

    STATUS_OBJECT_NAME_NOT_FOUND - The requested domain does not exist.

--*/
{
    UNICODE_STRING SecretName;
    NTSTATUS Status;
    PTRUSTED_DOMAIN_NAME_INFO NameInfo = NULL;
    LSA_HANDLE DomainHandle = NULL;
    LSA_HANDLE SecretHandle = NULL;


    SecretName.Buffer = NULL;

    //
    // Open the domain for query name and delete access. We need query name
    // to find the secret name.
    //

    Status = LsaOpenTrustedDomain(
                PolicyHandle,
                TrustedDomainSid,
                TRUSTED_QUERY_DOMAIN_NAME | DELETE,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Get the name so we can find the secret name.
    //

    Status = LsaQueryInfoTrustedDomain(
                DomainHandle,
                TrustedDomainNameInformation,
                &NameInfo
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaDelete(DomainHandle);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Zero the handle so we don't try to free it again.
    //

    DomainHandle = NULL;

    //
    // Get the secret name
    //

    Status = LsapApiBuildSecretName(
                NameInfo,
                &SecretName
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    Status = LsaOpenSecret(
                PolicyHandle,
                &SecretName,
                DELETE,
                &SecretHandle
                );
    if (!NT_SUCCESS(Status)) {
        //
        // If the secret does not exist, that is o.k. - it means the password
        // was never set.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    Status = LsaDelete(SecretHandle);
    if (NT_SUCCESS(Status)) {
        //
        // Zero the handle so we don't try to free it again.
        //
        SecretHandle = NULL;
    }

Cleanup:
    if (NameInfo != NULL) {
        LsaFreeMemory(NameInfo);
    }
    if (SecretName.Buffer != NULL) {
        MIDL_user_free(SecretName.Buffer);
    }
    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }
    if (DomainHandle != NULL) {
        LsaClose(DomainHandle);
    }

    return(Status);



}


NTSTATUS
NTAPI
LsapStorePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING KeyName,
    IN OPTIONAL PUNICODE_STRING PrivateData
    )

/*++

Routine Description:

    This routine stores private data in a secret named KeyName.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  If this is the
        first call, it requres POLICY_CREATE_SECRET access.

    KeyName - Name of secret to store

    PrivateData - Private data to store.  If this is null, the secret is
        deleted.

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient privilege to set
        the workstation password.

--*/

{
    LSA_HANDLE SecretHandle = NULL;
    NTSTATUS Status;
    ULONG DesiredAccess;
    BOOLEAN DeleteSecret = FALSE;

    //
    // check whether to delete the secret or not.
    //

    if (ARGUMENT_PRESENT(PrivateData)) {
        DesiredAccess = SECRET_SET_VALUE;
    } else {
        DesiredAccess = DELETE;
        DeleteSecret = TRUE;
    }


    Status = LsaOpenSecret(
                PolicyHandle,
                KeyName,
                DesiredAccess,
                &SecretHandle
                );

    if ((Status == STATUS_OBJECT_NAME_NOT_FOUND) && !DeleteSecret) {
        Status = LsaCreateSecret(
                    PolicyHandle,
                    KeyName,
                    DesiredAccess,
                    &SecretHandle
                    );


    }
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    if (DeleteSecret) {
        Status = LsaDelete(
                    SecretHandle
                    );

        if (NT_SUCCESS(Status)) {
            SecretHandle = NULL;
        }
        goto Cleanup;

    }

    Status = LsaSetSecret(
                SecretHandle,
                PrivateData,
                PrivateData
                );

Cleanup:
    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }

    return(Status);


}

NTSTATUS
NTAPI
LsapRetrievePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING KeyName,
    OUT PUNICODE_STRING * PrivateData
    )

/*++

Routine Description:

    This routine returns the secret data stored under KeyName.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall

    KeyName - Name of secret data to retrieve

    PrivateData - Receives a pointer private data

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to get the
        workstation password.

    STATUS_OBJECT_NAME_NOT_FOUND - there is no workstation password.

--*/
{
    LSA_HANDLE SecretHandle = NULL;
    NTSTATUS Status;

    //
    // Make the secret name
    //


    Status = LsaOpenSecret(
                PolicyHandle,
                KeyName,
                SECRET_QUERY_VALUE,
                &SecretHandle
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsaQuerySecret(
                SecretHandle,
                PrivateData,
                NULL,
                NULL,
                NULL
                );
Cleanup:
    if (SecretHandle != NULL) {
        LsaClose(SecretHandle);
    }

    return(Status);

}

/////////////////////////////////////////////////////////////////////////
//
// RPC wrappers for LSA APIs added in nt3.51.  This routines call the
// LSA, and if the interface doesn't exist, calls the LsapXXX routine
// to accomplish the same task using the older routines.
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaEnumerateAccountsWithUserRight(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PUNICODE_STRING UserRight,
    OUT PVOID *Buffer,
    OUT PULONG CountReturned
    )

/*++

Routine Description:


    The LsaEnumerateAccounts API returns information about the accounts
    in the target system's Lsa Database.  This call requires
    LSA_ENUMERATE_ACCOUNTS access to the Policy object.  Since this call
    accesses the privileges of an account, you must have PRIVILEGE_VIEW
    access to the pseudo-privilege object.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    UserRight - Name of the right that the account must have.

    Buffer - Receives a pointer to a LSA_ENUMERATION_INFORMATION structure
        containing the SIDs of all the accounts.

    CountReturned - Receives the number of sids returned.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects are enumerated because the
            EnumerationContext value passed in is too high.
--*/

{
    NTSTATUS   Status;

    LSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer;

    EnumerationBuffer.EntriesRead = 0;
    EnumerationBuffer.Information = NULL;

    RpcTryExcept {

        //
        // Enumerate the Accounts.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Accounts enumerated this call
        // and a pointer to an array of Account Information Entries.
        //
        // EnumerationBuffer ->  EntriesRead
        //                       Information -> Account Info for Domain 0
        //                                      Account Info for Domain 1
        //                                      ...
        //                                      Account Info for Domain
        //                                         (EntriesRead - 1)
        //

        Status = LsarEnumerateAccountsWithUserRight(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) UserRight,
                     &EnumerationBuffer
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.EntriesRead;
        *Buffer = EnumerationBuffer.Information;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Account Information array,
        // free it.
        //

        if (EnumerationBuffer.Information != NULL) {

            MIDL_user_free(EnumerationBuffer.Information);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the RPC server stub didn't exist, use the old version of the
    // API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapEnumerateAccountsWithUserRight(
                    PolicyHandle,
                    UserRight,
                    Buffer,
                    CountReturned
                    );
    }

    return Status;

}



NTSTATUS
NTAPI
LsaEnumerateAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    OUT PUNICODE_STRING *UserRights,
    OUT PULONG CountOfRights
    )


/*++

Routine Description:

    Returns all the rights of an account.  This is done by gathering the
    privileges and system access of an account and translating that into
    an array of strings.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  This API requires
        no special access.

    AccountSid - Sid of account to open.

    UserRights - receives an array of user rights (UNICODE_STRING) for
        the account.

    CountOfRights - receives the number of rights returned.


Return Value:

    STATUS_ACCESS_DENIED - the caller did not have sufficient access to
        return the privileges or system access of the account.

    STATUS_OBJECT_NAME_NOT_FOUND - the specified account did not exist.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the
        request.

--*/

{
    NTSTATUS   Status;
    LSAPR_USER_RIGHT_SET UserRightSet;

    UserRightSet.Entries = 0;
    UserRightSet.UserRights = NULL;

    RpcTryExcept {


        Status = LsarEnumerateAccountRights(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     &UserRightSet
                     );

        *CountOfRights = UserRightSet.Entries;
        *UserRights = (PUNICODE_STRING) UserRightSet.UserRights;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));
        if (UserRightSet.UserRights != NULL) {
            MIDL_user_free(UserRightSet.UserRights);
        }

    } RpcEndExcept;

    //
    // If the RPC server stub didn't exist, use the old version of the
    // API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapEnumerateAccountRights(
                    PolicyHandle,
                    AccountSid,
                    UserRights,
                    CountOfRights
                    );

    }

    return Status;
}


NTSTATUS
NTAPI
LsaAddAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN PUNICODE_STRING UserRights,
    IN ULONG CountOfRights
    )

/*++

Routine Description:

    Adds rights to the account specified by the account sid.  If the account
    does not exist, it creates the account.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must have
        POLICY_CREATE_ACCOUNT access if this is the first call for this
        AccountSid.

    AccountSid - Sid of account to add rights to

    UserRights - Array of unicode strings naming rights to add to the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/

{
    NTSTATUS   Status;
    LSAPR_USER_RIGHT_SET UserRightSet;

    UserRightSet.Entries = CountOfRights;
    UserRightSet.UserRights = (PLSAPR_UNICODE_STRING) UserRights;

    RpcTryExcept {

        Status = LsarAddAccountRights(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     &UserRightSet
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the RPC server stub didn't exist, use the old version of the
    // API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapAddAccountRights(
                    PolicyHandle,
                    AccountSid,
                    UserRights,
                    CountOfRights
                    );
    }
    return Status;
}


NTSTATUS
NTAPI
LsaRemoveAccountRights(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN BOOLEAN AllRights,
    IN PUNICODE_STRING UserRights,
    IN ULONG CountOfRights
    )

/*++

Routine Description:

    Removes rights to the account specified by the account sid.  If the
    AllRights flag is set or if all the rights are removed, the account
    is deleted.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call

    AccountSid - Sid of account to remove rights from

    UserRights - Array of unicode strings naming rights to remove from the
        account.

Return Value:
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to process the request

    STATUS_INVALID_PARAMTER - one of the parameters was not present

    STATUS_NO_SUCH_PRIVILEGE - One of the user rights was invalid

    STATUS_ACCESS_DENIED - the caller does not have sufficient access to the
        account to add privileges.

--*/
{
    NTSTATUS   Status;
    LSAPR_USER_RIGHT_SET UserRightSet;

    UserRightSet.Entries = CountOfRights;
    UserRightSet.UserRights = (PLSAPR_UNICODE_STRING) UserRights;

    RpcTryExcept {

        Status = LsarRemoveAccountRights(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     AllRights,
                     &UserRightSet
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapRemoveAccountRights(
                    PolicyHandle,
                    AccountSid,
                    AllRights,
                    UserRights,
                    CountOfRights
                    );
    }

    return Status;
}

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    The LsaQueryTrustedDomainInfo API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).  It also
    may query the secret object (for the TrustedDomainPasswordInformation
    class).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to query.

    InformationClass - Specifies the information to be returned.

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/
{
    NTSTATUS Status;
    PLSAP_CR_CIPHER_VALUE CipherPassword = NULL;
    PLSAP_CR_CIPHER_VALUE CipherOldPassword = NULL;
    PLSAP_CR_CLEAR_VALUE ClearPassword = NULL;
    PLSAP_CR_CLEAR_VALUE ClearOldPassword = NULL;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;
    ULONG DomainInfoSize;
    PUCHAR Where = NULL;
    PTRUSTED_PASSWORD_INFO PasswordInformation = NULL;

    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation = NULL;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:
        return STATUS_INVALID_INFO_CLASS;
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaQueryInformationTrustedDomain.
        //

        Status = LsarQueryTrustedDomainInfo(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) TrustedDomainSid,
                     InformationClass,
                     &TrustedDomainInformation
                     );

        //
        // Return pointer to Policy Information for the given class, or NULL.
        //


    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the returned Trusted Domain Information,
        // free it.
        //

        if (TrustedDomainInformation != NULL) {

            MIDL_user_free(TrustedDomainInformation);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // if we aren't getting passwords, skip out here. Otherwise we need to
    // decrypt the passwords.
    //

    if (InformationClass != TrustedPasswordInformation) {
        *Buffer = TrustedDomainInformation;
        TrustedDomainInformation = NULL;
        goto Cleanup;
    }

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value and/or Old Values.
    //

    RpcTryExcept {

        Status = LsapCrClientGetSessionKey( PolicyHandle, &SessionKey );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // If the Current Value is requested and a Current Value exists,
    // decrypt it using the Session key.  Otherwise store NULL for return.
    //

    if (TrustedDomainInformation->TrustedPasswordInfo.Password != NULL) {

        Status = LsapCrDecryptValue(
                     (PLSAP_CR_CIPHER_VALUE)
                        TrustedDomainInformation->TrustedPasswordInfo.Password,
                     SessionKey,
                     &ClearPassword
                     );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        //
        // Convert Clear Current Value to Unicode
        //

        LsapCrClearValueToUnicode(
            ClearPassword,
            (PUNICODE_STRING) ClearPassword
            );


    }

    //
    // Get the old password
    //

    if (TrustedDomainInformation->TrustedPasswordInfo.OldPassword != NULL) {

        Status = LsapCrDecryptValue(
                    (PLSAP_CR_CIPHER_VALUE)
                        TrustedDomainInformation->TrustedPasswordInfo.OldPassword,
                    SessionKey,
                    &ClearOldPassword
                    );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        //
        // Convert Clear Current Value to Unicode
        //

        LsapCrClearValueToUnicode(
            ClearOldPassword,
            (PUNICODE_STRING) ClearOldPassword
            );


    }


    MIDL_user_free(TrustedDomainInformation);
    TrustedDomainInformation = NULL;


    //
    // Allocate a buffer for the two passwords and marshall the
    // passwords into the buffer.
    //

    DomainInfoSize = sizeof(TRUSTED_PASSWORD_INFO);

    if (ClearPassword != NULL) {

        DomainInfoSize += ((PUNICODE_STRING) ClearPassword)->MaximumLength;
    }
    if (ClearOldPassword != NULL) {

        DomainInfoSize += ((PUNICODE_STRING) ClearOldPassword)->MaximumLength;
    }

    PasswordInformation = (PTRUSTED_PASSWORD_INFO) MIDL_user_allocate(DomainInfoSize);
    if (PasswordInformation == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Where = (PUCHAR) (PasswordInformation+1);

    if (ClearPassword != NULL)
    {
        PasswordInformation->Password = *(PUNICODE_STRING) ClearPassword;
        PasswordInformation->Password.Buffer = (LPWSTR) Where;
        Where += PasswordInformation->Password.MaximumLength;
        RtlCopyUnicodeString(
            &PasswordInformation->Password,
            (PUNICODE_STRING) ClearPassword
            );
    }

    if (ClearOldPassword != NULL)
    {
        PasswordInformation->OldPassword = *(PUNICODE_STRING) ClearOldPassword;
        PasswordInformation->OldPassword.Buffer = (LPWSTR) Where;
        Where += PasswordInformation->OldPassword.MaximumLength;
        RtlCopyUnicodeString(
            &PasswordInformation->OldPassword,
            (PUNICODE_STRING) ClearOldPassword
            );
    }
    ASSERT(Where - (PUCHAR) PasswordInformation == (LONG) DomainInfoSize);

    *Buffer = PasswordInformation;
    PasswordInformation = NULL;
    Status = STATUS_SUCCESS;

Cleanup:
    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Current Value.
    //

    if (CipherPassword != NULL) {

        LsapCrFreeMemoryValue(CipherPassword);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Old Value.
    //

    if (CipherOldPassword != NULL) {

        LsapCrFreeMemoryValue(CipherOldPassword);
    }
    if (ClearPassword != NULL) {

        LsapCrFreeMemoryValue(ClearPassword);
    }
    if (ClearOldPassword != NULL) {

        LsapCrFreeMemoryValue(ClearOldPassword);
    }

    if (TrustedDomainInformation != NULL) {
        MIDL_user_free(TrustedDomainInformation);
    }

    if (PasswordInformation != NULL) {
        MIDL_user_free(PasswordInformation);
    }

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapQueryTrustedDomainInfo(
                    PolicyHandle,
                    TrustedDomainSid,
                    InformationClass,
                    Buffer
                    );
    }

    return Status;
}

NTSTATUS
NTAPI
LsaSetTrustedDomainInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )


/*++

Routine Description:


    The LsaSetTrustedDomainInformation API modifies information in the Trusted
    Domain Object and in the Secret Object.  The caller must have access
    appropriate to the information to be changed in the Policy Object, see
    the InformationClass parameter.

    If the domain does not yet exist and the information class is
    TrustedDomainNameInformation, then the domain is created.  If the
    domain exists and the class is TrustedDomainNameInformation, an
    error is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to modify.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedDomainNameInformation      POLICY_TRUST_ADMIN
        TrustedPosixOffsetInformation     none
        TrustedPasswordInformation        POLICY_CREATE_SECRET

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_INFO_CLASS - Setting information for specified information class
            is not supported

        Others TBS
--*/

{
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_INFO DomainInformation;
    LSAPR_TRUSTED_PASSWORD_INFO LsaPasswordInfo;
    PTRUSTED_PASSWORD_INFO PasswordInformation;
    PLSAP_CR_CIPHER_VALUE CipherPassword = NULL;
    LSAP_CR_CLEAR_VALUE ClearPassword;
    PLSAP_CR_CIPHER_VALUE CipherOldPassword = NULL;
    LSAP_CR_CLEAR_VALUE ClearOldPassword;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;
    PUNICODE_STRING OldPassword;

    //
    // If the infotype is TrustedPasswordInformation, then we need to
    // setup a secure channel to transmit the secret passwords.
    //

    switch ( InformationClass ) {
    case TrustedPasswordInformation:

        PasswordInformation = (PTRUSTED_PASSWORD_INFO) Buffer;
        LsaPasswordInfo.Password = NULL;
        LsaPasswordInfo.OldPassword = NULL;

        //
        // Obtain the Session Key to be used to two-way encrypt the
        // Current Value.
        //

        RpcTryExcept {

            Status = LsapCrClientGetSessionKey( PolicyHandle, &SessionKey );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        //
        // The password must be specified, even if it is an empty string.
        //

        if (PasswordInformation->Password.Buffer != NULL) {

            //
            // Convert input from Unicode Structures to Clear Value Structures.
            //

            LsapCrUnicodeToClearValue(
                &PasswordInformation->Password,
                &ClearPassword
                );



            //
            // Encrypt the Current Value if specified and not too long.
            //


            Status = LsapCrEncryptValue(
                         &ClearPassword,
                         SessionKey,
                         &CipherPassword
                         );

            if (!NT_SUCCESS(Status)) {

                goto Cleanup;
            }
            LsaPasswordInfo.Password = (PLSAPR_CR_CIPHER_VALUE) CipherPassword;

            //
            // If the old password wasn't specified, set it to be the
            // new password.
            //

            if (PasswordInformation->OldPassword.Buffer == NULL) {
                OldPassword = &PasswordInformation->Password;
            } else {
                OldPassword = &PasswordInformation->OldPassword;
            }


            //
            // Convert input from Unicode Structures to Clear Value Structures.
            //

            LsapCrUnicodeToClearValue(
                OldPassword,
                &ClearOldPassword
                );



            //
            // Encrypt the Current Value if specified and not too long.
            //


            Status = LsapCrEncryptValue(
                         &ClearOldPassword,
                         SessionKey,
                         &CipherOldPassword
                         );

            if (!NT_SUCCESS(Status)) {

                goto Cleanup;
            }
            LsaPasswordInfo.OldPassword = (PLSAPR_CR_CIPHER_VALUE) CipherOldPassword;
        } else {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        DomainInformation = (PLSAPR_TRUSTED_DOMAIN_INFO) &LsaPasswordInfo;
        break;

    //
    // There are only two other info levels handled
    //

    case TrustedPosixOffsetInformation:
    case TrustedDomainNameInformation:
        DomainInformation = (PLSAPR_TRUSTED_DOMAIN_INFO) Buffer;
        break;

    //
    // No other info levels are supported
    //
    default:
        return STATUS_INVALID_INFO_CLASS;
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaSetInformationTrustedDomain
        //

        Status = LsarSetTrustedDomainInfo
        (
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) TrustedDomainSid,
                     InformationClass,
                     DomainInformation
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

Cleanup:
    if (SessionKey != NULL) {
        MIDL_user_free(SessionKey);
    }
    if (CipherPassword != NULL) {
        LsaFreeMemory(CipherPassword);
    }
    if (CipherOldPassword != NULL) {
        LsaFreeMemory(CipherOldPassword);
    }

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapSetTrustedDomainInformation(
                    PolicyHandle,
                    TrustedDomainSid,
                    InformationClass,
                    Buffer
                    );
    }

    return Status;
}


NTSTATUS
NTAPI
LsaDeleteTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid
    )

/*++

Routine Description:

    This routine deletes a trusted domain and the associated secret.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainSid - Sid of domain to delete

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to delete
        the requested domain.

    STATUS_OBJECT_NAME_NOT_FOUND - The requested domain does not exist.

--*/
{
    NTSTATUS Status;

    RpcTryExcept {


        Status = LsarDeleteTrustedDomain(
                    (LSAPR_HANDLE) PolicyHandle,
                    (PLSAPR_SID) TrustedDomainSid
                    );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapDeleteTrustedDomain(
                    PolicyHandle,
                    TrustedDomainSid
                    );
    }

    return(Status);
}

//
// This API sets the workstation password (equivalent of setting/getting
// the SSI_SECRET_NAME secret)
//

NTSTATUS
NTAPI
LsaStorePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING KeyName,
    IN OPTIONAL PUNICODE_STRING PrivateData
    )

/*++

Routine Description:

    This routine stores private data in an LSA secret named KeyName.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall.  If this is the
        first call, it requres POLICY_CREATE_SECRET access.

    KeyName - Name of secret to store.

    PrivateData - Data to store. If not present, the secret is deleted.

Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient privilege to set
        the workstation password.

--*/


{
    NTSTATUS Status;

    PLSAP_CR_CIPHER_VALUE CipherCurrentValue = NULL;
    LSAP_CR_CLEAR_VALUE ClearCurrentValue;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    if (ARGUMENT_PRESENT(PrivateData)) {

        //
        // Convert input from Unicode Structures to Clear Value Structures.
        //


        LsapCrUnicodeToClearValue( PrivateData, &ClearCurrentValue );

        //
        // Obtain the Session Key to be used to two-way encrypt the
        // Current Value.
        //

        RpcTryExcept {

            Status = LsapCrClientGetSessionKey( PolicyHandle, &SessionKey );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }

        //
        // Encrypt the Current Value if specified and not too long.
        //


        Status = LsapCrEncryptValue(
                     &ClearCurrentValue,
                     SessionKey,
                     &CipherCurrentValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto Cleanup;
        }


    }

    //
    // Set the Secret Values.
    //

    RpcTryExcept {

        Status = LsarStorePrivateData(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) KeyName,
                     (PLSAPR_CR_CIPHER_VALUE) CipherCurrentValue
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

Cleanup:

    //
    // If necessary, free memory allocated for the Encrypted Current Value.
    //

    if (CipherCurrentValue != NULL) {

        LsaFreeMemory(CipherCurrentValue);
    }

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapStorePrivateData(
                    PolicyHandle,
                    KeyName,
                    PrivateData
                    );
    }


    return(Status);

}


NTSTATUS
NTAPI
LsaRetrievePrivateData(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING KeyName,
    OUT PUNICODE_STRING *PrivateData
    )

/*++

Routine Description:

    This routine returns the secret stored in KeyName.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall

    KeyName - Name of secret to retrieve

    PrivateData - Receives private data, should be freed with LsaFreeMemory.


Return Value:

    STATUS_ACCESS_DENIED - caller has insufficient access to get the
        private data.

    STATUS_OBJECT_NAME_NOT_FOUND - there is no private data stored under
        KeyName.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PLSAP_CR_CIPHER_VALUE CipherCurrentValue = NULL;
    PLSAP_CR_CLEAR_VALUE ClearCurrentValue = NULL;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    RpcTryExcept {

        Status = LsarRetrievePrivateData(
                     (PLSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) KeyName,
                     (PLSAPR_CR_CIPHER_VALUE *) &CipherCurrentValue
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;
    }

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value and/or Old Values.
    //

    RpcTryExcept {

        Status = LsapCrClientGetSessionKey( PolicyHandle, &SessionKey );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;
    }

    //
    // If the Current Value is requested and a Current Value exists,
    // decrypt it using the Session key.  Otherwise store NULL for return.
    //

    if (CipherCurrentValue != NULL) {

        Status = LsapCrDecryptValue(
                     CipherCurrentValue,
                     SessionKey,
                     &ClearCurrentValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto QuerySecretError;
        }

        //
        // Convert Clear Current Value to Unicode
        //

        LsapCrClearValueToUnicode(
            ClearCurrentValue,
            (PUNICODE_STRING) ClearCurrentValue
            );
        *PrivateData = (PUNICODE_STRING) ClearCurrentValue;

    } else {

        *PrivateData = NULL;
    }




QuerySecretFinish:

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Current Value.
    //

    if (CipherCurrentValue != NULL) {

        LsapCrFreeMemoryValue(CipherCurrentValue);
    }


    //
    // If the error was that the server stub didn't exist, call
    // the old version of the API.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        Status = LsapRetrievePrivateData(
                    PolicyHandle,
                    KeyName,
                    PrivateData
                    );
    }



    return(Status);

QuerySecretError:

    //
    // If necessary, free memory allocated for the Clear Current Value
    //

    if (ClearCurrentValue != NULL) {

        LsapCrFreeMemoryValue(ClearCurrentValue);
    }


    *PrivateData = NULL;


    goto QuerySecretFinish;
}



NTSTATUS
LsapApiConvertRightsToPrivileges(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING UserRights,
    IN ULONG RightCount,
    OUT PPRIVILEGE_SET * Privileges,
    OUT PULONG SystemAccess
    )
/*++

Routine Description:

    Converts an array of user rights (unicode strings) into a privilege set
    and a system access flag.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicyCall, requires POLICY_LOOKUP_NAME
        access.

    UserRights - Array of user rights

    RightCount - Count of user rights

    Privileges - Receives privilege set, should be freed with MIDL_user_free

    SystemAccess - Receives system access flags.

Return Value:

--*/

{
    ULONG RightIndex;
    ULONG PrivilegeIndex;
    ULONG AccessIndex;
    PPRIVILEGE_SET PrivilegeSet = NULL;
    ULONG Access = 0;
    ULONG PrivilegeSetSize = 0;
    NTSTATUS Status;
    LUID PrivilegeValue;

    //
    // if we weren't passed any privileges, don't allocate anything.
    //

    if (RightCount == 0) {

        *Privileges = NULL;
        *SystemAccess = 0;
        return(STATUS_SUCCESS);
    }

    //
    // Compute the size of the privilege set.  We actually over estimate
    // by assuming that all the rights are privileges.  We subtract one
    // from RightCount to take into account the fact that a PRIVILEGE_SET
    // has one LUID_AND_ATTRIBUTE in it.
    //


    PrivilegeSetSize = sizeof(PRIVILEGE_SET) +
                        (RightCount-1) * sizeof(LUID_AND_ATTRIBUTES);

    PrivilegeSet = (PPRIVILEGE_SET) MIDL_user_allocate(PrivilegeSetSize);

    if (PrivilegeSet == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Try looking up every right.  If we find it as a privilege,
    // add it to the privilege set.
    //

    PrivilegeIndex = 0;

    for (RightIndex = 0; RightIndex < RightCount ; RightIndex++) {
        Status = LsaLookupPrivilegeValue(
                    PolicyHandle,
                    &UserRights[RightIndex],
                    &PrivilegeValue
                    );
        if (NT_SUCCESS(Status)) {
            PrivilegeSet->Privilege[PrivilegeIndex].Luid = PrivilegeValue;
            PrivilegeSet->Privilege[PrivilegeIndex].Attributes = 0;
            PrivilegeIndex++;

        } else if (Status != STATUS_NO_SUCH_PRIVILEGE) {
            //
            // This is a more serious error - bail here.
            //

            goto Cleanup;
        } else {

            //
            // Try looking up the right as a system access type.
            //

            for (AccessIndex = 0; AccessIndex < LSAP_DB_SYSTEM_ACCESS_TYPES ; AccessIndex++) {
                if (RtlCompareUnicodeString(
                        &UserRights[RightIndex],
                        &LsapDbRightAndAccess[AccessIndex].UserRight,
                        FALSE   // case sensitive
                        ) == 0) {
                    Access |= LsapDbRightAndAccess[AccessIndex].SystemAccess;
                    break;
                }
            }

            //
            // If we went through the access types without finding the right,
            // it must not be valid so escape here.
            //

            if (AccessIndex == LSAP_DB_SYSTEM_ACCESS_TYPES) {
                Status = STATUS_NO_SUCH_PRIVILEGE;
                goto Cleanup;
            }

        }
    }

    PrivilegeSet->Control = 0;
    PrivilegeSet->PrivilegeCount = PrivilegeIndex;

    *Privileges = PrivilegeSet;
    *SystemAccess = Access;

    Status = STATUS_SUCCESS;

Cleanup:
    if (!NT_SUCCESS(Status)) {
        if (PrivilegeSet != NULL) {
            LsaFreeMemory(PrivilegeSet);
        }
    }

    return(Status);

}

NTSTATUS
LsapApiConvertPrivilegesToRights(
    IN LSA_HANDLE PolicyHandle,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN OPTIONAL ULONG SystemAccess,
    OUT PUNICODE_STRING * UserRights,
    OUT PULONG RightCount
    )
/*++

Routine Description:

    Converts a privilege set and a system access flag into an array of
    user rights (unicode strings).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call, must have
        POLICY_LOOKUP_NAMES access.

    Privileges - Privilege set to convert

    SystemAccess - System access flags to convert

    UserRights - Receives an array of user rights (unicode strings).  Should
        be freed with MIDL_user_free

    RightCount - Receives count of rights in UserRights array


Return Value:

--*/

{
    NTSTATUS Status;
    PUNICODE_STRING OutputRights = NULL;
    PUNICODE_STRING * PrivilegeNames = NULL;
    UNICODE_STRING AccessNames[LSAP_DB_SYSTEM_ACCESS_TYPES];
    ULONG RightSize;
    ULONG PrivilegeSize;
    ULONG Count;
    ULONG PrivilegeIndex;
    ULONG AccessIndex;
    ULONG RightIndex;
    ULONG AccessCount = 0;
    PUCHAR Where;

    //
    // Compute the size of the temporary array. This is just an array of
    // pointers to unicode strings to hold the privilege names until
    // we reallocate them into one big buffer.
    //

    RightSize = 0;
    Count = 0;
    if (ARGUMENT_PRESENT(Privileges)) {

        PrivilegeSize = Privileges->PrivilegeCount * sizeof(PUNICODE_STRING);
        PrivilegeNames = (PUNICODE_STRING *) MIDL_user_allocate(PrivilegeSize);

        if (PrivilegeNames == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlZeroMemory(
            PrivilegeNames,
            PrivilegeSize
            );

        //
        // Lookup the privilge name and store it in the temporary array
        //

        for (PrivilegeIndex = 0; PrivilegeIndex < Privileges->PrivilegeCount ;PrivilegeIndex++ ) {

            Status = LsaLookupPrivilegeName(
                        PolicyHandle,
                        &Privileges->Privilege[PrivilegeIndex].Luid,
                        &PrivilegeNames[PrivilegeIndex]
                        );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            RightSize += sizeof(UNICODE_STRING) + PrivilegeNames[PrivilegeIndex]->MaximumLength;
        }
    }

    //
    // Now convert the system access flags to user rights.
    //

    if (ARGUMENT_PRESENT( (ULONG_PTR)SystemAccess )) {

        AccessCount = 0;
        for (AccessIndex = 0; AccessIndex < LSAP_DB_SYSTEM_ACCESS_TYPES ; AccessIndex++) {

            if ((SystemAccess & LsapDbRightAndAccess[AccessIndex].SystemAccess) != 0) {

                AccessNames[AccessCount] = LsapDbRightAndAccess[AccessIndex].UserRight;
                RightSize += sizeof(UNICODE_STRING) + AccessNames[AccessCount].MaximumLength;
                AccessCount++;
            }
        }
    }

    //
    // Allocate the output buffer and start copying the strings into the
    // buffer.
    //

    Count = Privileges->PrivilegeCount + AccessCount;

    OutputRights = (PUNICODE_STRING) MIDL_user_allocate(RightSize);
    if (OutputRights == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Where = (PUCHAR) OutputRights + (Count * sizeof(UNICODE_STRING));

    //
    // Copy in the privileges first
    //

    RightIndex = 0;
    for (PrivilegeIndex = 0; PrivilegeIndex < Privileges->PrivilegeCount ; PrivilegeIndex ++) {

        OutputRights[RightIndex] = *PrivilegeNames[PrivilegeIndex];
        OutputRights[RightIndex].Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            PrivilegeNames[PrivilegeIndex]->Buffer,
            OutputRights[RightIndex].MaximumLength
            );
        Where += OutputRights[RightIndex].MaximumLength;
        RightIndex++;
    }

    //
    // Now copy in the access types
    //

    for (AccessIndex = 0; AccessIndex < AccessCount; AccessIndex++) {

        OutputRights[RightIndex] = AccessNames[AccessIndex];
        OutputRights[RightIndex].Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            AccessNames[AccessIndex].Buffer,
            OutputRights[RightIndex].MaximumLength
            );
        Where += OutputRights[RightIndex].MaximumLength;
        RightIndex++;
    }

    ASSERT(RightIndex == Count);

    *UserRights = OutputRights;
    OutputRights = NULL;
    *RightCount = Count;

    Status = STATUS_SUCCESS;

Cleanup:

    if (PrivilegeNames != NULL) {
        for (PrivilegeIndex = 0; PrivilegeIndex < Privileges->PrivilegeCount ; PrivilegeIndex++) {
            if (PrivilegeNames[PrivilegeIndex] != NULL) {
                LsaFreeMemory(PrivilegeNames[PrivilegeIndex]);
            }
        }
        MIDL_user_free(PrivilegeNames);
    }

    if (OutputRights != NULL) {
        MIDL_user_free(OutputRights);
    }

    return(Status);
}



NTSTATUS
NTAPI
LsaQueryTrustedDomainInfoByName(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
{
    NTSTATUS Status;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:
        return STATUS_INVALID_INFO_CLASS;
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaClearAuditLog.
        //

        Status = LsarQueryTrustedDomainInfoByName(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) TrustedDomainName,
                     InformationClass,
                     (PLSAPR_TRUSTED_DOMAIN_INFO *) Buffer
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsapRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
)
/*++

Routine Description:

    This routine fills a buffer with random data.

Parameters:

    BufferSize - Length of the input buffer, in bytes.

    Buffer - Input buffer to be filled with random data.

Return Values:

    Errors from NtQuerySystemTime()


--*/
{
    ULONG Index;
    LARGE_INTEGER Time;
    ULONG Seed;
    NTSTATUS NtStatus;


    NtStatus = NtQuerySystemTime(&Time);
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    Seed = Time.LowPart ^ Time.HighPart;

    for (Index = 0 ; Index < BufferSize ; Index++ )
    {
        *Buffer++ = (UCHAR) (RtlRandom(&Seed) % 256);
    }
    return(STATUS_SUCCESS);

}


NTSTATUS
LsapEncryptAuthInfo(
    IN LSA_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION ClearAuthInfo,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL *EncryptedAuthInfo
)

/*++

Routine Description:

    This routine takes a cleartext auth info and returns an encrypted auth info.

Parameters:

    PolicyHandle - Handle to the LSA policy.

    ClearAuthInfo - Cleartext of the authentication info.

    EncryptedAuthInfo - Returns an allocated buffer containing the encrypted form
        of the auth info.  The caller should free this buffer using LocalFree.

Return Values:

    STATUS_SUCCESS - the routine has completed successfully.


--*/
{
    NTSTATUS Status;
    USER_SESSION_KEY UserSessionKey;

    ULONG IncomingAuthInfoSize = 0;
    PUCHAR IncomingAuthInfo = NULL;
    ULONG OutgoingAuthInfoSize = 0;
    PUCHAR OutgoingAuthInfo = NULL;

    ULONG EncryptedSize;
    PUCHAR EncryptedBuffer;
    PUCHAR AllocatedBuffer = NULL;

    PUCHAR Where;

    struct RC4_KEYSTRUCT Rc4Key;

    //
    // Get the encryption key
    //

    Status = RtlGetUserSessionKeyClient(
                   (RPC_BINDING_HANDLE)PolicyHandle,
                   &UserSessionKey );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Marshal the incoming and outgoing auth info halfs into contiguous buffers
    //

    Status = LsapDsMarshalAuthInfoHalf(
                LsapDsAuthHalfFromAuthInfo( ClearAuthInfo, TRUE ),
                &IncomingAuthInfoSize,
                &IncomingAuthInfo );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = LsapDsMarshalAuthInfoHalf(
                LsapDsAuthHalfFromAuthInfo( ClearAuthInfo, FALSE ),
                &OutgoingAuthInfoSize,
                &OutgoingAuthInfo );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Build a buffer of:
    //  512 random bytes
    //  The Outgoing auth info buffer.
    //  The Incoming auth info buffer.
    //  The length of the outgoing auth info buffer.
    //  The length of the incoming auth info buffer.
    //
    // (Notice that a hacker might surmise the length of the auth data by
    // observing the length of the encrypted blob. However, the auth data is typically
    // fixed length anyway.  So the above seems adequate.)
    //

   EncryptedSize = LSAP_ENCRYPTED_AUTH_DATA_FILL +
                   OutgoingAuthInfoSize +
                   IncomingAuthInfoSize +
                   sizeof(ULONG) +
                   sizeof(ULONG);

    AllocatedBuffer = LocalAlloc( 0, sizeof(LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL) + EncryptedSize );

    if ( AllocatedBuffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    EncryptedBuffer = AllocatedBuffer + sizeof(LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL);
    Where = EncryptedBuffer;

    Status = LsapRandomFill( LSAP_ENCRYPTED_AUTH_DATA_FILL,
                             Where );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Where += LSAP_ENCRYPTED_AUTH_DATA_FILL;

    RtlCopyMemory( Where, OutgoingAuthInfo, OutgoingAuthInfoSize );
    Where += OutgoingAuthInfoSize;

    RtlCopyMemory( Where, IncomingAuthInfo, IncomingAuthInfoSize );
    Where += IncomingAuthInfoSize;

    RtlCopyMemory( Where, &OutgoingAuthInfoSize, sizeof(ULONG) );
    Where += sizeof(ULONG);

    RtlCopyMemory( Where, &IncomingAuthInfoSize, sizeof(ULONG) );
    Where += sizeof(ULONG);


    //
    // Encrypt the result.
    //

    rc4_key( &Rc4Key,
             sizeof(USER_SESSION_KEY),
             (PUCHAR) &UserSessionKey );

    rc4( &Rc4Key,
         EncryptedSize,
         EncryptedBuffer );

    //
    // Return the result to the caller.
    //

    *EncryptedAuthInfo =
        (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL) AllocatedBuffer;
    (*EncryptedAuthInfo)->AuthBlob.AuthBlob = EncryptedBuffer;
    (*EncryptedAuthInfo)->AuthBlob.AuthSize = EncryptedSize;

    Status = STATUS_SUCCESS;

Cleanup:

    if ( !NT_SUCCESS(Status) ) {
        if ( AllocatedBuffer != NULL ) {
            LocalFree( AllocatedBuffer );
        }
        *EncryptedAuthInfo = NULL;
    }

    if ( IncomingAuthInfo != NULL ) {
        MIDL_user_free( IncomingAuthInfo );
    }
    if ( OutgoingAuthInfo != NULL ) {
        MIDL_user_free( OutgoingAuthInfo );
    }
    return Status;
}

NTSTATUS
NTAPI
LsaSetTrustedDomainInfoByName(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )
{
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL InternalAuthBuffer = NULL;
    PVOID InternalBuffer;
    TRUSTED_INFORMATION_CLASS InternalInformationClass;

    LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL InternalFullBuffer;

    //
    // Initialization
    //

    InternalInformationClass = InformationClass;
    InternalBuffer = Buffer;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedPasswordInformation:
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:

    //
    // TrustedDomainNameInformation is not allowed, either (RAID #416784)
    //
    case TrustedDomainNameInformation:
        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;

    //
    // Handle the info classes that need to be encrypted on the wire
    //
    case TrustedDomainAuthInformation: {

        //
        // Encrypt the data into an internal buffer.
        //

        Status = LsapEncryptAuthInfo( PolicyHandle,
                                      (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION) Buffer,
                                      &InternalAuthBuffer );

        if ( !NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Use an internal info level to tell the server that the data is
        //  encrypted.
        //

        InternalInformationClass = TrustedDomainAuthInformationInternal;
        InternalBuffer = InternalAuthBuffer;
        break;

    }

    //
    // Handle the info classes that need to be encrypted on the wire
    //
    case TrustedDomainFullInformation: {
        PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION FullBuffer =
                    (PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION) Buffer;

        //
        // Encrypt the data into an internal buffer.
        //

        Status = LsapEncryptAuthInfo( PolicyHandle,
                                      &FullBuffer->AuthInformation,
                                      &InternalAuthBuffer );

        if ( !NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Copy all of the information into a single new structure.
        //

        InternalFullBuffer.Information = FullBuffer->Information;
        InternalFullBuffer.PosixOffset = FullBuffer->PosixOffset;
        InternalFullBuffer.AuthInformation = *InternalAuthBuffer;

        //
        // Use an internal info level to tell the server that the data is
        //  encrypted.
        //

        InternalInformationClass = TrustedDomainFullInformationInternal;
        InternalBuffer = &InternalFullBuffer;
        break;

    }
    }

    //
    // If the information class was morphed,
    //  try the morphed class.
    //

    if ( InternalInformationClass != InformationClass ) {
        RpcTryExcept {

            //
            // Call the Client Stub
            //

            Status = LsarSetTrustedDomainInfoByName(
                         (LSAPR_HANDLE) PolicyHandle,
                         (PLSAPR_UNICODE_STRING) TrustedDomainName,
                         InternalInformationClass,
                         (PLSAPR_TRUSTED_DOMAIN_INFO) InternalBuffer
                         );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        //
        // If the morphed info class is valid,
        //  we're all done with this call.
        //  (Otherwise, drop through to try the non-morphed class.)
        //

        if ( Status != RPC_NT_INVALID_TAG ) {
            goto Cleanup;
        }
    }


    //
    // Handle non-morphed information classes.
    //

    RpcTryExcept {

        //
        // Call the Client Stub
        //

        Status = LsarSetTrustedDomainInfoByName(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) TrustedDomainName,
                     InformationClass,
                     (PLSAPR_TRUSTED_DOMAIN_INFO) Buffer
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

Cleanup:
    if ( InternalAuthBuffer != NULL ) {
        LocalFree( InternalAuthBuffer );
    }
    return(Status);
}


NTSTATUS
NTAPI
LsaEnumerateTrustedDomainsEx(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )
{
    NTSTATUS Status;
    LSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer;
    EnumerationBuffer.EntriesRead = 0;
    EnumerationBuffer.EnumerationBuffer = NULL;

    //
    // Verify that caller has provided a return buffer pointer.
    //

    if (!ARGUMENT_PRESENT(Buffer)) {

        return(STATUS_INVALID_PARAMETER);
    }


    RpcTryExcept {

        //
        // Enumerate the Trusted Domains.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Trusted Domains enumerated this call
        // and a pointer to an array of Trust Information Entries.
        //
        // EnumerationBuffer ->  EntriesRead
        //                       Information -> Trust Info for Domain 0
        //                                      Trust Info for Domain 1
        //                                      ...
        //                                      Trust Info for Domain
        //                                         (EntriesRead - 1)
        //
        //

        Status = LsarEnumerateTrustedDomainsEx(
                     (LSAPR_HANDLE) PolicyHandle,
                     EnumerationContext,
                     &EnumerationBuffer,
                     PreferedMaximumLength
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.EntriesRead;
        *Buffer = EnumerationBuffer.EnumerationBuffer;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Trust Information array,
        // free it.
        //

        if (EnumerationBuffer.EnumerationBuffer != NULL) {

            MIDL_user_free(EnumerationBuffer.EnumerationBuffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    return(Status);
}


NTSTATUS
NTAPI
LsaCreateTrustedDomainEx(
    IN LSA_HANDLE PolicyHandle,
    IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
{
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL InternalAuthBuffer = NULL;

    //
    // Encrypt the auth data
    //

    Status = LsapEncryptAuthInfo( PolicyHandle,
                                  (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION) AuthenticationInformation,
                                  &InternalAuthBuffer );

    if ( !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Try the version of the API that takes encrypted data
    //

    RpcTryExcept {

        //
        // Call the Client Stub
        //

        Status = LsarCreateTrustedDomainEx2(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX) TrustedDomainInformation,
                     InternalAuthBuffer,
                     DesiredAccess,
                     (PLSAPR_HANDLE) TrustedDomainHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the server doesn't accept the new api,
    //  try the old one.
    // (The old API was only supported in beta versions of NT 5.
    // After NT 5 ships we no longer need to be able to fall back.)
    //

    if (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) {

        RpcTryExcept {

            //
            // Call the Client Stub
            //

            Status = LsarCreateTrustedDomainEx(
                         (LSAPR_HANDLE) PolicyHandle,
                         (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX) TrustedDomainInformation,
                         (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION) AuthenticationInformation,
                         DesiredAccess,
                         (PLSAPR_HANDLE) TrustedDomainHandle
                         );

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;
    }

Cleanup:
    if ( InternalAuthBuffer != NULL ) {
        LocalFree( InternalAuthBuffer );
    }
    return(Status);
}



NTSTATUS
NTAPI
LsaQueryDomainInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
{
    NTSTATUS Status;
    PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation = NULL;

    RpcTryExcept {


        Status = LsarQueryDomainInformationPolicy(
                     (LSAPR_HANDLE) PolicyHandle,
                     InformationClass,
                     &PolicyDomainInformation
                     );

        *Buffer = PolicyDomainInformation;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);

}




NTSTATUS
NTAPI
LsaSetDomainInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )
{
    NTSTATUS Status;

    if ( InformationClass == PolicyDomainKerberosTicketInformation &&
         Buffer == NULL ) {

        return STATUS_INVALID_PARAMETER;
    }

    RpcTryExcept {

        Status = LsarSetDomainInformationPolicy(
                     (LSAPR_HANDLE) PolicyHandle,
                     InformationClass,
                     Buffer
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);

}


NTSTATUS
LsaOpenTrustedDomainByName(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaOpenTrustedDomain API opens an existing TrustedDomain object
    using the Name as the primary key value.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainName - Name of the trusted domain

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarOpenTrustedDomainByName(
                     ( LSAPR_HANDLE ) PolicyHandle,
                     ( PLSAPR_UNICODE_STRING )TrustedDomainName,
                     DesiredAccess,
                     ( PLSAPR_HANDLE )TrustedDomainHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}



NTSTATUS
LsaQueryForestTrustInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    OUT PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    )
/*++

Routine Description

    The LsaQueryForestTrustInformation API returns forest trust information
    for the given trusted domain object.

Arguments:

    PolicyHandle - An open handle to a Policy object

    TrustedDomainName - Name of the trusted domain object

    ForestTrustInfo - Used to return forest trust information

Returns:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS

    STATUS_INVALID_PARAMETER          Parameters were somehow invalid
                                      Most likely, the TRUST_ATTRIBUTE_FOREST_TRANSITIVE
                                      trust attribute bit is not set on the TDO

    STATUS_NOT_FOUND                  Forest trust information does not exist for this TDO

    STATUS_NO_SUCH_DOMAIN             The specified TDO does not exist

    STATUS_INSUFFICIENT_RESOURCES     Ran out of memory

    STATUS_INVALID_DOMAIN_STATE       Operation is only legal on domain controllers in root domain

--*/
{
    NTSTATUS Status;

    RpcTryExcept {

        Status = LsarQueryForestTrustInformation(
                     PolicyHandle,
                     TrustedDomainName,
                     ForestTrustRecordTypeLast,
                     ForestTrustInfo
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

         Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}




NTSTATUS
LsaSetForestTrustInformation(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo,
    IN BOOLEAN CheckOnly,
    OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    )
/*++

Routine Description

    The LsarSetForestTrustInformation API sets forest trust information
    on the given trusted domain object.

    In case if it fails the operation due to a collision, it will return
    the list of entries that conflicted.

Arguments:

    PolicyHandle - An open handle to a Policy object

    TrustedDomainName - Name of the trusted domain object

    ForestTrustInfo - Contains forest trust information to set

    CheckOnly - Check for collisions only, do not commit changes to disk

    CollisionInfo - In case of collisoin error, used to return collision info

Returns:

    STATUS_SUCCESS                  operation completed successfully

    STATUS_INVALID_PARAMETER        did not like one of the parameters

    STATUS_INSUFFICIENT_RESOURCES   out of memory

    STATUS_INVALID_DOMAIN_STATE     Operation is only legal on domain
                                    controllers in the root domain

    STATUS_INVALID_DOMAIN_ROLE      Operation is only legal on the primary
                                    domain controller

    STATUS_INVALID_SERVER_STATE     The server is shutting down and can not
                                    process the request

--*/
{
    NTSTATUS Status;

    RpcTryExcept {

        Status = LsarSetForestTrustInformation(
                     PolicyHandle,
                     TrustedDomainName,
                     ForestTrustRecordTypeLast,
                     ForestTrustInfo,
                     CheckOnly,
                     CollisionInfo
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

         Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}

#ifdef TESTING_MATCHING_ROUTINE

#include <sddl.h> // ConvertStringSidToSidW



NTSTATUS
NTAPI
LsaForestTrustFindMatch(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Type,
    IN PLSA_UNICODE_STRING Name,
    OUT PLSA_UNICODE_STRING * Match
    )
/*++

Routine Description:

    A debug-only hook for testing the LsaIForestTrustFindMatch API

Arguments:

    Type         type of match

    Name         name to match

    Match        used to return the name of match

Returns:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status;

    RpcTryExcept {

        Status = LsarForestTrustFindMatch(
                     PolicyHandle,
                     Type,
                     Name,
                     Match
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\rpcapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rpcapi.c

Abstract:

    This module contains the routines for the LSA API that use RPC.  The
    routines in this module are merely wrappers that work as follows:

    o Client program calls LsaFoo in this module
    o LsaFoo calls RPC client stub interface routine LsapFoo with
      similar parameters.  Some parameters are translated from types
      (e.g structures containing PVOIDs or certain kinds of variable length
      parameters such as pointers to SID's) that are not specifiable on an
      RPC interface, to specifiable form.
    o RPC client stub LsapFoo calls interface specific marshalling routines
      and RPC runtime to marshal parameters into a buffer and send them over
      to the server side of the LSA.
    o Server side calls RPC runtime and interface specific unmarshalling
      routines to unmarshal parameters.
    o Server side calls worker LsapFoo to perform API function.
    o Server side marshals response/output parameters and communicates these
      back to client stub LsapFoo
    o LsapFoo exits back to LsaFoo which returns to client program.

Author:

    Scott Birrell     (ScottBi)    April 24, 1991

Revision History:

--*/

#include "lsaclip.h"
#include <align.h>
#include <rpcasync.h>

//
// The following limit on the maximum number of Sids or Names is tentative,
// so it is not being published.
//

#define LSAP_DB_TRIAL_MAXIMUM_SID_COUNT   ((ULONG) 0x00005000L)
#define LSAP_DB_TRIAL_MAXIMUM_NAME_COUNT   ((ULONG) 0x00005000L)


//
// Functions private to this module
//

NTSTATUS
LsapApiReturnResult(
    IN ULONG ExceptionCode
    );

BOOLEAN
LsapNeutralizeNt4Emulation()
{
    BOOLEAN Result = FALSE;
    NTSTATUS Status;
    HKEY hkey;
    DWORD Type;
    DWORD Value;
    DWORD Size = sizeof( Value );
    static DWORD AmIDC = 0xFFFFFFFF;
    ULONG i;
    CHAR * Paths[] = {
        "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters\\GpParameters",
        "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters"
    };

    //
    // NT4 emulation is always disabled on domain controllers
    //

    if ( AmIDC == 0xFFFFFFFF ) {

        NT_PRODUCT_TYPE ProductType = NtProductWinNt;

        if ( TRUE == RtlGetNtProductType( &ProductType )) {

            if ( ProductType == NtProductLanManNt ) {

                AmIDC = TRUE;

            } else {

                AmIDC = FALSE;
            }
        }
    }

    if ( AmIDC == TRUE ) {

        return TRUE;
    }

    //
    // This is not a DC; must go to the registry for the special "neutralize" value
    // which could be either under NetLogon or NetLogon/GroupPolicy parameters key
    //

    for ( i = 0; i < sizeof( Paths ) / sizeof( Paths[0] ); i++ ) {

        if ( ERROR_SUCCESS != RegOpenKeyEx(
                                  HKEY_LOCAL_MACHINE,
                                  Paths[i],
                                  0,
                                  KEY_READ,
                                  &hkey )) {

            continue;
        }

        if ( ERROR_SUCCESS != RegQueryValueEx(
                                  hkey,
                                  "NeutralizeNt4Emulator",
                                  NULL,
                                  &Type,
                                  (LPBYTE)&Value,
                                  &Size ) ||
             Type != REG_DWORD ||
             Size != sizeof( DWORD )) {

            RegCloseKey( hkey );
            continue;

        } else {

            RegCloseKey( hkey );
            Result = ( Value != 0 );
            break;
        }
    }

    return Result;
}

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy Administration API function prototypes           //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsaOpenPolicy(
    IN PUNICODE_STRING SystemName OPTIONAL,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    )

/*++

Routine Description:

    To administer the Local Security Policy of a local or remote system,
    this API must be called to establish a session with that system's
    Local Security Authority (LSA) subsystem.  This API connects to
    the LSA of the target system and opens the object representing
    the target system's Local Security Policy database.  A handle to
    the object is returned.  This handle must be used on all subsequent API
    calls to administer the Local Security Policy information for the
    target system.

Arguments:

    SystemName - Name of the target system to be administered.
        Administration of the local system is assumed if NULL is specified.

    ObjectAttributes - Pointer to the set of attributes to use for this
        connection.  The security Quality Of Service information is used and
        normally should provide Security Identification level of
        impersonation.  Some operations, however, require Security
        Impersonation level of impersonation.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the LSA Subsystem's LSA Database.  These access types
        are reconciled with the Discretionary Access Control List of the
        target LsaDatabase object to determine whether the
        accesses will be granted or denied.

    PolicyHandle - Receives a handle to be used in future requests to
        access the Local Security Policy of the target system.  This handle
        represents both the handle to the LsaDatabase object and
        the RPC Context Handle for the connection to the target LSA
        susbsystem.


Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have access to the target
        system's LSA Database, or does not have other desired accesses.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_SERVER_NAME ServerName = NULL;
    USHORT NullTerminatedServerNameLength;
    LSA_HANDLE LocalHandle = NULL ;

    RpcTryExcept {

        //
        // Get the Server Name as a Unicode String buffer.  Set it to
        // NULL (i.e. local machine) if a zero length or NULL Unicode String
        // structure us passed.  If a non NULL server name is given, we must
        // ensure that it is terminated with a NULL wide character.  Allocate
        // a buffer that is one wide character longer than the server name
        // buffer, copy the server name to that buffer and append a trailing
        // NULL wide character.
        //

        if (ARGUMENT_PRESENT(SystemName) &&
            (SystemName->Buffer != NULL) &&
            (SystemName->Length > 0)) {

            NullTerminatedServerNameLength = SystemName->Length + (USHORT) sizeof (WCHAR);

            ServerName = MIDL_user_allocate( NullTerminatedServerNameLength );

            if (ServerName != NULL) {

                RtlZeroMemory( ServerName, NullTerminatedServerNameLength );

                RtlMoveMemory(
                    ServerName,
                    SystemName->Buffer,
                    SystemName->Length
                    );

            } else {

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status)) {

            *PolicyHandle = NULL;

            ObjectAttributes->RootDirectory = NULL;

            Status = LsarOpenPolicy2(
                         ServerName,
                         (PLSAPR_OBJECT_ATTRIBUTES) ObjectAttributes,
                         DesiredAccess,
                         (PLSAPR_HANDLE)&LocalHandle
                         );
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If the open failed because the new API doesn't exist, try the
    // old one.
    //

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {
            ASSERT(*PolicyHandle == NULL);
            ASSERT(ObjectAttributes->RootDirectory == NULL);

            Status = LsarOpenPolicy(
                         ServerName,
                         (PLSAPR_OBJECT_ATTRIBUTES) ObjectAttributes,
                         DesiredAccess,
                         (PLSAPR_HANDLE)&LocalHandle
                         );


        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

    }

    //
    // If necessary, free the NULL-terminated server name buffer.
    //

    if (ServerName != NULL) {

        MIDL_user_free( ServerName );
    }

    if ( NT_SUCCESS( Status ) ) {

        *PolicyHandle = LocalHandle;
    }

    return Status;
}


NTSTATUS
LsaOpenPolicySce(
    IN PUNICODE_STRING SystemName OPTIONAL,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    )

/*++

Routine Description:

    Essentially the same as LsaOpenPolicy, except used only by SCE
    to obtain a special "synchronized" policy handle that would serialize
    access to policy operations.

Arguments:

    Same as LsaOpenPolicy

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have access to the target
        system's LSA Database, or does not have other desired accesses.

        STATUS_PRIVILEGE_NOT_HELD - Caller must come in with TCB privilege.

        STATUS_TIMEOUT - Timed out waiting on SCE to send pending changes

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_SERVER_NAME ServerName = NULL;
    USHORT NullTerminatedServerNameLength;
    LSA_HANDLE LocalHandle = NULL ;

    RpcTryExcept {

        //
        // Get the Server Name as a Unicode String buffer.  Set it to
        // NULL (i.e. local machine) if a zero length or NULL Unicode String
        // structure us passed.  If a non NULL server name is given, we must
        // ensure that it is terminated with a NULL wide character.  Allocate
        // a buffer that is one wide character longer than the server name
        // buffer, copy the server name to that buffer and append a trailing
        // NULL wide character.
        //

        if (ARGUMENT_PRESENT(SystemName) &&
            (SystemName->Buffer != NULL) &&
            (SystemName->Length > 0)) {

            NullTerminatedServerNameLength = SystemName->Length + (USHORT) sizeof (WCHAR);

            ServerName = MIDL_user_allocate( NullTerminatedServerNameLength );

            if (ServerName != NULL) {

                RtlZeroMemory( ServerName, NullTerminatedServerNameLength );

                RtlMoveMemory(
                    ServerName,
                    SystemName->Buffer,
                    SystemName->Length
                    );

            } else {

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status)) {

            *PolicyHandle = NULL;

            ObjectAttributes->RootDirectory = NULL;

            Status = LsarOpenPolicySce(
                         ServerName,
                         (PLSAPR_OBJECT_ATTRIBUTES) ObjectAttributes,
                         DesiredAccess,
                         (PLSAPR_HANDLE)&LocalHandle
                         );
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If necessary, free the NULL-terminated server name buffer.
    //

    if (ServerName != NULL) {

        MIDL_user_free( ServerName );
    }

    if ( NT_SUCCESS( Status ) ) {

        *PolicyHandle = LocalHandle;
    }

    return Status;
}


NTSTATUS
LsaQueryInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    The LsaQueryInformationPolicy API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        PolicyAuditLogInformation         POLICY_VIEW_AUDIT_INFORMATION
        PolicyAuditEventsInformation      POLICY_VIEW_AUDIT_INFORMATION
        PolicyPrimaryDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyAccountDomainInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyPdAccountInformation        POLICY_GET_PRIVATE_INFORMATION
        PolicyLsaServerRoleInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyReplicaSourceInformation    POLICY_VIEW_LOCAL_INFORMATION
        PolicyDefaultQuotaInformation     POLICY_VIEW_LOCAL_INFORMATION

    Buffer - receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        Others TBS
--*/

{
    NTSTATUS   Status;
    PLSAPR_POLICY_INFORMATION PolicyInformation;

    if ( InformationClass == PolicyDnsDomainInformationInt ) {

        return STATUS_INVALID_PARAMETER;
    }

Retry:

    PolicyInformation = NULL;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaQueryInformationPolicy.
        //

        switch (InformationClass)
        {
        case PolicyDnsDomainInformation:
        case PolicyDnsDomainInformationInt:
            Status = LsarQueryInformationPolicy2(
                         (LSAPR_HANDLE) PolicyHandle,
                         InformationClass,
                         &PolicyInformation
                         );
            break;

        default:
            Status = LsarQueryInformationPolicy(
                         (LSAPR_HANDLE) PolicyHandle,
                         InformationClass,
                         &PolicyInformation
                         );
        }

        //
        // Return pointer to Policy Information for the given class, or NULL.
        //

        *Buffer = PolicyInformation;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the returned Policy Information,
        // free it.
        //

        if (PolicyInformation != NULL) {

            MIDL_user_free(PolicyInformation);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If we suspect that the call failed due to NT4 emulation by the server,
    // and we're configured to neutralize emulation, try the call again, neutralizing
    //

    if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE &&
         InformationClass == PolicyDnsDomainInformation &&
         LsapNeutralizeNt4Emulation()) {

         InformationClass = PolicyDnsDomainInformationInt;
         goto Retry;
    }

    return Status;
}


NTSTATUS
LsaSetInformationPolicy(
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The LsaSetInformationPolicy API modifies information in the Policy Object.
    The caller must have access appropriate to the information to be changed
    in the Policy Object, see the InformationClass parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        PolicyAuditLogInformation         POLICY_AUDIT_LOG_ADMIN
        PolicyAuditEventsInformation      POLICY_SET_AUDIT_REQUIREMENTS
        PolicyPrimaryDomainInformation    POLICY_TRUST_ADMIN
        PolicyAccountDomainInformation    POLICY_TRUST_ADMIN
        PolicyPdAccountInformation        Not settable by this API
        PolicyLsaServerRoleInformation    POLICY_SERVER_ADMIN
        PolicyReplicaSourceInformation    POLICY_SERVER_ADMIN
        PolicyDefaultQuotaInformation     POLICY_SET_DEFAULT_QUOTA_LIMITS
        PolicyDnsDomainInformation        POLICY_DNS_DOMAIN_INFO
        PolicyDnsDomainInformationInt     POLICY_DNS_DOMAIN_INFO

    Buffer - Points to a structure containing the information appropriate
        to the information type specified by the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/

{
    NTSTATUS   Status;

    if ( InformationClass == PolicyDnsDomainInformationInt ) {

        return STATUS_INVALID_PARAMETER;
    }

Retry:

    RpcTryExcept {

        //
        // Call the Client Stub for LsaSetInformationPolicy.
        //

        switch (InformationClass)
        {
        case PolicyDnsDomainInformation:
        case PolicyDnsDomainInformationInt:
            Status = LsarSetInformationPolicy2(
                         (LSAPR_HANDLE) PolicyHandle,
                         InformationClass,
                         (PLSAPR_POLICY_INFORMATION) Buffer
                         );
            break;

        default:
            Status = LsarSetInformationPolicy(
                         (LSAPR_HANDLE) PolicyHandle,
                         InformationClass,
                         (PLSAPR_POLICY_INFORMATION) Buffer
                         );
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    //
    // If we suspect that the call failed due to NT4 emulation by the server,
    // and we're configured to neutralize emulation, try the call again, neutralizing
    //

    if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE &&
         InformationClass == PolicyDnsDomainInformation &&
         LsapNeutralizeNt4Emulation()) {

         InformationClass = PolicyDnsDomainInformationInt;
         goto Retry;
    }

    return Status;
}


NTSTATUS
LsaClearAuditLog(
    IN LSA_HANDLE PolicyHandle
    )

/*++

Routine Description:

    This function clears the Audit Log.  Caller must have POLICY_AUDIT_LOG_ADMIN
    access to the Policy Object to perform this operation.

Arguments:

    PolicyHandle - handle from an LsaOpenPolicy call.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the required access
            to perform the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INVALID_HANDLE - PolicyHandle is not a valid handle to
            a Policy Object.
--*/

{
    NTSTATUS Status;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaClearAuditLog.
        //

        Status = LsarClearAuditLog(
                     (LSAPR_HANDLE) PolicyHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}



NTSTATUS
LsaLookupPrivilegeValue(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING Name,
    OUT PLUID Value
    )

/*++

Routine Description:

    This function retrieves the value used on the target system
    to locally represent the specified privilege.  The privilege
    is specified by programmatic name.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Name - Is the privilege's programmatic name.

    Value - Receives the locally unique ID the privilege is known by on the
        target machine.



Return Value:

    NTSTATUS - The privilege was found and returned.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{
    NTSTATUS Status;
    LUID Buffer;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaLookupPrivilegeValue.
        //

        Status = LsarLookupPrivilegeValue(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING)Name,
                     &Buffer
                     );

        *Value = Buffer;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaLookupPrivilegeName(
    IN LSA_HANDLE PolicyHandle,
    IN PLUID Value,
    OUT PUNICODE_STRING *Name
    )

/*++

Routine Description:

    This function programmatic name corresponding to the privilege
    represented on the target system by the provided LUID.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Value - is the locally unique ID the privilege is known by on the
        target machine.

    Name - Receives the privilege's programmatic name.



Return Value:

    NTSTATUS - The privilege was found and returned.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/

{

    NTSTATUS Status;
    PLSAPR_UNICODE_STRING Buffer = NULL;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaLookupPrivilegeName.
        //

        Status = LsarLookupPrivilegeName(
                     (LSAPR_HANDLE) PolicyHandle,
                     Value,
                     &Buffer
                     );

        (*Name) = (PUNICODE_STRING)Buffer;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the return buffer, free it.
        //

        if (Buffer != NULL) {

            MIDL_user_free(Buffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    return(Status);


}



NTSTATUS
LsaLookupPrivilegeDisplayName(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING Name,
    OUT PUNICODE_STRING *DisplayName,
    OUT PSHORT LanguageReturned
    )

/*++

Routine Description:

    This function retrieves a displayable name representing the
    specified privilege.


Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.  This handle
        must be open for POLICY_LOOKUP_NAMES access.

    Name - The programmatic privilege name to look up.

    DisplayName - Receives a pointer to the privilege's displayable
        name.

    LanguageReturned - Receives the language of the returned displayable
        name.


Return Value:

    NTSTATUS - The privilege text was found and returned.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.


    STATUS_NO_SUCH_PRIVILEGE -  The specified privilege could not be
        found.

--*/
{

    NTSTATUS Status;
    SHORT ClientLanguage, ClientSystemDefaultLanguage;
    PLSAPR_UNICODE_STRING Buffer = NULL;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaLookupPrivilegeDisplayName.
        //

        ClientLanguage = (SHORT)NtCurrentTeb()->CurrentLocale;
        ClientSystemDefaultLanguage = ClientLanguage; //no sys default yet
        Status = LsarLookupPrivilegeDisplayName(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING)Name,
                     ClientLanguage,
                     ClientSystemDefaultLanguage,
                     &Buffer,
                     (PWORD)LanguageReturned
                     );

        (*DisplayName) = (PUNICODE_STRING)Buffer;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the return buffer, free it.
        //

        if (Buffer != NULL) {

            MIDL_user_free(Buffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    return(Status);
}




NTSTATUS
LsaClose(
    IN LSA_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This API closes a handle to the LsaDatabase object or open object within
    the database.  If a handle to the LsaDatabase object is closed and there
    are no objects still open within the current connection to the LSA, the
    connection is closed.  If a handle to an object within the database is
    closed and the object is marked for DELETE access, the object will be
    deleted when the last handle to that object is closed.

Arguments:

    ObjectHandle - This parameter is either a handle to the LsaDatabase
        object, which represents the entire LSA Database and also a
        connection to the LSA of a target system, or a handle to an
        object within the database.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS   Status;

    LSAPR_HANDLE Handle = (LSAPR_HANDLE) ObjectHandle;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaClose.  Note that an additional
        // level of indirection for the context handle parameter is required
        // for the stub, because the server returns a NULL pointer to the handle
        // so that the handle will be unbound by the stub.
        //

        Status = LsarClose( &Handle );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        ULONG Code = RpcExceptionCode();
        // Don't assert on bad handles -- this will cause bogus stress breaks
        // ASSERT(Code != RPC_X_SS_CONTEXT_MISMATCH);
        ASSERT(Code != RPC_S_INVALID_BINDING);
        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));


    } RpcEndExcept;


    if (  !NT_SUCCESS(Status)
       && (0 != Handle)) {
        //
        // Make sure in all error cases to remove the client side resources
        // consumed by this handle.
        //
        RpcTryExcept  {
            (void) RpcSsDestroyClientContext(&Handle);
        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
            //
            // The try/except is for app compat so that bad handles don't bring
            // the process down
            //
            NOTHING;
        } RpcEndExcept;
    }

    ASSERT( Status != STATUS_INVALID_PARAMETER_12 );
    ASSERT( Status != STATUS_INVALID_HANDLE );
    return Status;
}



NTSTATUS
LsaDelete(
    IN LSA_HANDLE ObjectHandle
    )

/*++

Routine Description:

    The LsaDelete API deletes an object.  The object must be
    open for DELETE access.

Arguments:

    ObjectHandle - Handle from an LsaOpen<object-type> call.

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified handle is not valid.

        Result codes from RPC.
--*/

{
    NTSTATUS Status;

    RpcTryExcept {

        //
        // Try calling the new worker routine LsarDeleteObject().  If
        // this fails because it does not exist (versions 1.369 and earlier)
        // then call the old routine LsarDelete().
        //

        Status = LsarDeleteObject((LSAPR_HANDLE *) &ObjectHandle);

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if ((Status == RPC_NT_UNKNOWN_IF) ||
        (Status == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        RpcTryExcept {

            Status = LsarDelete((LSAPR_HANDLE) ObjectHandle);

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;
    }

    return(Status);
}


NTSTATUS
LsaQuerySecurityObject(
    IN LSA_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    The LsaQuerySecurityObject API returns security information assigned
    to an LSA Database object.

    Based on the caller's access rights and privileges, this procedure will
    return a security descriptor containing any or all of the object's owner
    ID, group ID, discretionary ACL or system ACL.  To read the owner ID,
    group ID, or the discretionary ACL, the caller must be granted
    READ_CONTROL access to the object.  To read the system ACL, the caller must
    have SeSecurityPrivilege privilege.

    This API is modelled after the NtQuerySecurityObject() system service.

Arguments:

    ObjectHandle - A handle to an existing object in the LSA Database.

    SecurityInformation - Supplies a value describing which pieces of
        security information are being queried.  The values that may be
        specified are the same as those defined in the NtSetSecurityObject()
        API section.

    SecurityDescriptor - receives a pointer to a buffer containing the
        requested security information.  This information is returned in
        the form of a security descriptor.  The caller is responsible for
        freeing the returned buffer using LsaFreeMemory() when no longer
        needed.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified.
--*/

{
    NTSTATUS Status;
    LSAPR_SR_SECURITY_DESCRIPTOR ReturnedSD;
    PLSAPR_SR_SECURITY_DESCRIPTOR PReturnedSD;

    //
    // The retrieved security descriptor is returned via a data structure that
    // looks like:
    //
    //             +-----------------------+
    //             | Length (bytes)        |
    //             |-----------------------|          +--------------+
    //             | SecurityDescriptor ---|--------->| Self-Relative|
    //             +-----------------------+          | Security     |
    //                                                | Descriptor   |
    //                                                +--------------+
    //
    // The first of these buffers is a local stack variable.  The buffer containing
    // the self-relative security descriptor is allocated by the RPC runtime.  The
    // pointer to the self-relative security descriptor is what is passed back to our
    // caller.
    //
    //

    //
    // To prevent RPC from trying to marshal a self-relative security descriptor,
    // make sure its field values are appropriately initialized to zero and null.
    //

    ReturnedSD.Length = 0;
    ReturnedSD.SecurityDescriptor = NULL;

    //
    // Call the server ...
    //


    RpcTryExcept{

        PReturnedSD = &ReturnedSD;

        Status = LsarQuerySecurityObject(
                     (LSAPR_HANDLE) ObjectHandle,
                     SecurityInformation,
                     &PReturnedSD
                     );

        if (NT_SUCCESS(Status)) {

            (*SecurityDescriptor) = ReturnedSD.SecurityDescriptor;

        } else {

            (*SecurityDescriptor) = NULL;
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecurityObjectError;
    }

QuerySecurityObjectFinish:

    return(Status);

QuerySecurityObjectError:

    goto QuerySecurityObjectFinish;
}


NTSTATUS
LsaSetSecurityObject(
    IN LSA_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    The LsaSetSecurityObject API takes a well formaed Security Descriptor
    and assigns specified portions of it to an object.  Based on the flags set
    in the SecurityInformation parameter and the caller's access rights, this
    procedure will replace any or alll of the security information associated
    with the object.

    The caller must have WRITE_OWNER access to the object to change the
    owner or Primary group of the object.  The caller must have WRITE_DAC
    access to the object to change the Discretionary ACL.  The caller must
    have SeSecurityPrivilege to assign a system ACL to an object.

    This API is modelled after the NtSetSecurityObject() system service.

Arguments:

    ObjectHandle - A handle to an existing object in the LSA Database.

    SecurityInformation - Indicates which security information is to be
        applied to the object.  The values that may be specified are the
        same as those defined in the NtSetSecurityObject() API section.
        The value(s) to be assigned are passed in the SecurityDescriptor
        parameter.

    SecurityDescriptor - A pointer to a well formed Security Descriptor.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified.
--*/

{
    NTSTATUS Status;
    ULONG SDLength;
    LSAPR_SR_SECURITY_DESCRIPTOR DescriptorToPass = { 0 };

    //
    // Make a self relative security descriptor for use in the RPC call..
    //

    SDLength = 0;

    Status = RtlMakeSelfRelativeSD( SecurityDescriptor, NULL, &SDLength);

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        Status = STATUS_INVALID_PARAMETER;
        goto SetSecurityObjectError;
    }

    DescriptorToPass.SecurityDescriptor = MIDL_user_allocate( SDLength );

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (DescriptorToPass.SecurityDescriptor == NULL) {

        goto SetSecurityObjectError;

    }

    //
    // Make an appropriate self-relative security descriptor
    //

    Status = RtlMakeSelfRelativeSD(
                 SecurityDescriptor,
                 (PSECURITY_DESCRIPTOR)DescriptorToPass.SecurityDescriptor,
                 &SDLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSecurityObjectError;
    }

    DescriptorToPass.Length = SDLength;

    RpcTryExcept{

        Status = LsarSetSecurityObject(
                     (LSAPR_HANDLE) ObjectHandle,
                     SecurityInformation,
                     &DescriptorToPass
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto SetSecurityObjectError;
    }

SetSecurityObjectFinish:

    //
    // If necessary, free the Self Relative SD passed to the worker.
    //

    if (DescriptorToPass.SecurityDescriptor != NULL) {

        MIDL_user_free( DescriptorToPass.SecurityDescriptor );

        DescriptorToPass.SecurityDescriptor = NULL;
    }

    return(Status);

SetSecurityObjectError:

    goto SetSecurityObjectFinish;
}


NTSTATUS
LsaChangePassword(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
    )

/*++

Routine Description:

    The LsaChangePassword API is used to change a user account's password.
    The user must have appropriate access to the user account and must
    know the current password value.


Arguments:

    ServerName - The name of the Domain Controller at which the password
        can be changed.

    DomainName - The name of the domain in which the account exists.

    AccountName - The name of the account whose password is to be changed.

    NewPassword - The new password value.

    OldPassword - The old (current) password value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed, e.g.
            contains characters that can't be entered from the keyboard.

        STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
            from being changed.  This may be for an number of reasons,
            including time restrictions on how often a password may be changed
            or length restrictions on the provided (new) password.

            This error might also be returned if the new password matched
            a password in the recent history log for the account.  Security
            administrators indicate how many of the most recently used
            passwords may not be re-used.

        STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
            current password.

        STATUS_NO_SUCH_USER - The SID provided does not lead to a user
            account.

        STATUS_CANT_UPDATE_MASTER - An attempt to update the master copy
            of the password was unsuccessful.  Please try again later.

--*/

{
    NTSTATUS Status;

    DBG_UNREFERENCED_PARAMETER( ServerName );
    DBG_UNREFERENCED_PARAMETER( DomainName );
    DBG_UNREFERENCED_PARAMETER( AccountName );
    DBG_UNREFERENCED_PARAMETER( OldPassword );
    DBG_UNREFERENCED_PARAMETER( NewPassword );

    Status = STATUS_NOT_IMPLEMENTED;

    return(Status);
}


NTSTATUS
LsaCreateAccount(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE AccountHandle
    )

/*++

Routine Description:

    The LsaCreateAccount API adds a user or group account to the
    list of accounts in the target system's LsaDatabase object.  The
    newly added account object is initially placed in the opened state and
    a handle to it is returned.  The caller must have LSA_CREATE_ACCOUNT
    access to the LsaDatabase object.

    Note that no check is made to determine whether there is an account
    of the given Sid in the target system's Primary Domain (if any), nor
    is any check made to verify that the Sid and name describe the same
    account.

Arguments:

    PolicyHandle -  Handle from an LsaOpenLsa call.

    AccountSid - Points to the SID of the Account object.

    DesiredAccess - Specifies the accesses to be granted to the newly
        created and opened account.

    AccountHandle - Receives a handle to the newly created and opened
        account.  This handle is used on subsequent accesses to the account
        until closed.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_ACCOUNT_ALREADY_EXISTS - A user or group account object having
            the Sid given in AccountInformation already exists.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified,
            one or more of the following apply.

            - CreateDisposition not valid
            - A user or group account having the Sid given AccountInformation
              already exists, but CreateDisposition = LSA_OBJECT_CREATE.
--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarCreateAccount(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     DesiredAccess,
                     (PLSAPR_HANDLE) AccountHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaEnumerateAccounts(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    The LsaEnumerateAccounts API returns information about
    Account objects.  This call requires
    POLICY_VIEW_LOCAL_INFORMATION access to the Policy object.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.  To
    support this feature, the caller is provided with a handle that can
    be used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.

Arguments:

    PolicyHandle -  Handle from an LsaOpenLsa call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationInformation - Receives a pointer to an array of structures
       each describing an Account object.  Currently, each structure contains
       a pointer to the Account Sid.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Pointer to location which receives the number of entries
        returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully, there may be
            more entries.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if there are no more objects to enumerate.  Note that
            one or more objects may be enumerated on a call that returns this
            reply.

        STATUS_INVALID_PARAMETER - Invalid parameter.

            - NULL return pointer for enumeration buffer.
--*/

{
    NTSTATUS   Status;

    LSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer;

    EnumerationBuffer.EntriesRead = 0;
    EnumerationBuffer.Information = NULL;

    RpcTryExcept {

        //
        // Enumerate the Accounts.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Accounts enumerated this call
        // and a pointer to an array of Account Information Entries.
        //
        // EnumerationBuffer ->  EntriesRead
        //                       Information -> Account Info for Domain 0
        //                                      Account Info for Domain 1
        //                                      ...
        //                                      Account Info for Domain
        //                                         (EntriesRead - 1)
        //

        Status = LsarEnumerateAccounts(
                     (LSAPR_HANDLE) PolicyHandle,
                     EnumerationContext,
                     &EnumerationBuffer,
                     PreferedMaximumLength
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.EntriesRead;
        *Buffer = EnumerationBuffer.Information;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Account Information array,
        // free it.
        //

        if (EnumerationBuffer.Information != NULL) {

            MIDL_user_free(EnumerationBuffer.Information);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaCreateTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaCreateTrustedDomain API creates a new TrustedDomain object.  The
    caller must have POLICY_TRUST_ADMIN access to the Policy Object.

    Note that NO verification is done to check that the given domain name
    matches the given SID or that the SID or name represent an actual domain.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainInformation - Pointer to structure containing the name and
        SID of the new Trusted Domain.

    DesiredAccess - Specifies the accesses to be granted for the newly
        created object.

    TrustedDomainHandle - receives a handle referencing the newly created
        object.  This handle is used on subsequent accesses to the object.

--*/

{
    NTSTATUS   Status;

    *TrustedDomainHandle = NULL;

    RpcTryExcept {

        Status = LsarCreateTrustedDomain(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_TRUST_INFORMATION) TrustedDomainInformation,
                     DesiredAccess,
                     (PLSAPR_HANDLE) TrustedDomainHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaOpenTrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaOpenTrustedDomain API opens an existing TrustedDomain object
    using the SID as the primary key value.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarOpenTrustedDomain(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) TrustedDomainSid,
                     DesiredAccess,
                     (PLSAPR_HANDLE) TrustedDomainHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaQueryInfoTrustedDomain(
    IN LSA_HANDLE TrustedDomainHandle,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    The LsaQueryInfoTrustedDomain API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).

Arguments:

    TrustedDomainHandle - Handle from an LsaOpenTrustedDomain or
        LsaCreateTrustedDomain call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        TrustedAccountNameInformation     TRUSTED_QUERY_ACCOUNT_NAME
        TrustedControllersInformation     TRUSTED_QUERY_CONTROLLERS
        TrustedPosixInformation           TRUSTED_QUERY_POSIX

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status;

    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation = NULL;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:
    case TrustedDomainInformationEx2Internal:
    case TrustedDomainFullInformation2Internal:
        return STATUS_INVALID_INFO_CLASS;
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaQueryInformationTrustedDomain.
        //

        Status = LsarQueryInfoTrustedDomain(
                     (LSAPR_HANDLE) TrustedDomainHandle,
                     InformationClass,
                     &TrustedDomainInformation
                     );

        //
        // Return pointer to Policy Information for the given class, or NULL.
        //

        *Buffer = TrustedDomainInformation;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the returned Trusted Domain Information,
        // free it.
        //

        if (TrustedDomainInformation != NULL) {

            MIDL_user_free(TrustedDomainInformation);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    return Status;
}


NTSTATUS
LsaSetInformationTrustedDomain(
    IN LSA_HANDLE TrustedDomainHandle,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The LsaSetInformationTrustedDomain API modifies information in the Trusted
    Domain Object.  The caller must have access appropriate to the
    information to be changedin the Policy Object, see the InformationClass
    parameter.

Arguments:

    TrustedDomainHandle -  Handle from an LsaOpenTrustedDomain or
        LsaCreateTrustedDomain call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedAccountInformation         ( Cannot be set )
        TrustedControllersInformation     TRUSTED_SET_CONTROLLERS
        TrustedPosixOffsetInformation     TRUSTED_POSIX_INFORMATION

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - Call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INVALID_HANDLE - Handle is invalid or is of the wrong type.

        STATUS_INVALID_PARAMETER - Invalid parameter:
            Information class invalid
            Information class cannot be set
--*/

{
    NTSTATUS Status;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL InternalAuthBuffer = NULL;
    PVOID InternalBuffer;
    TRUSTED_INFORMATION_CLASS InternalInformationClass;

    LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL InternalFullBuffer;

    //
    // Initialization
    //

    InternalInformationClass = InformationClass;
    InternalBuffer = Buffer;

    //
    // Avoid the internal info levels that represent the encrypted version on
    //  the wire.
    //
    switch ( InformationClass ) {
    case TrustedPasswordInformation:
    case TrustedDomainInformationBasic:
    case TrustedDomainAuthInformationInternal:
    case TrustedDomainFullInformationInternal:
    case TrustedDomainInformationEx2Internal:
    case TrustedDomainFullInformation2Internal:
        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;

    //
    // Handle the info classes that need to be encrypted on the wire
    //
    case TrustedDomainAuthInformation: {

        //
        // Encrypt the data into an internal buffer.
        //

        Status = LsapEncryptAuthInfo( TrustedDomainHandle,
                                      (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION) Buffer,
                                      &InternalAuthBuffer );

        if ( !NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Use an internal info level to tell the server that the data is
        //  encrypted.
        //

        InternalInformationClass = TrustedDomainAuthInformationInternal;
        InternalBuffer = InternalAuthBuffer;
        break;

    }

    //
    // Handle the info classes that need to be encrypted on the wire
    //
    case TrustedDomainFullInformation: {
        PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION FullBuffer =
                    (PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION) Buffer;

        //
        // Encrypt the data into an internal buffer.
        //

        Status = LsapEncryptAuthInfo( TrustedDomainHandle,
                                      &FullBuffer->AuthInformation,
                                      &InternalAuthBuffer );

        if ( !NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Copy all of the information into a single new structure.
        //

        InternalFullBuffer.Information = FullBuffer->Information;
        InternalFullBuffer.PosixOffset = FullBuffer->PosixOffset;
        InternalFullBuffer.AuthInformation = *InternalAuthBuffer;

        //
        // Use an internal info level to tell the server that the data is
        //  encrypted.
        //

        InternalInformationClass = TrustedDomainFullInformationInternal;
        InternalBuffer = &InternalFullBuffer;
        break;

    }
    }

    //
    // If the information class was morphed,
    //  try the morphed class.
    //

    if ( InternalInformationClass != InformationClass ) {
        RpcTryExcept {

            //
            // Call the Client Stub
            //

            Status = LsarSetInformationTrustedDomain(
                         (LSAPR_HANDLE) TrustedDomainHandle,
                         InternalInformationClass,
                         (PLSAPR_TRUSTED_DOMAIN_INFO) InternalBuffer
                         );


        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        //
        // If the morphed info class is valid,
        //  we're all done with this call.
        //  (Otherwise, drop through to try the non-morphed class.)
        //

        if ( Status != RPC_NT_INVALID_TAG ) {
            goto Cleanup;
        }
    }


    //
    // Handle non-morphed information classes.
    //

    RpcTryExcept {

        //
        // Call the Client Stub
        //

        Status = LsarSetInformationTrustedDomain(
                     (LSAPR_HANDLE) TrustedDomainHandle,
                     InformationClass,
                     (PLSAPR_TRUSTED_DOMAIN_INFO) Buffer
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

Cleanup:
    if ( InternalAuthBuffer != NULL ) {
        LocalFree( InternalAuthBuffer );
    }
    return(Status);
}


NTSTATUS
LsaEnumerateTrustedDomains(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    The LsaEnumerateTrustedDomains API returns information about the accounts
    in the target system's Policy object.  This call requires
    POLICY_VIEW_LOCAL_INFORMATION access to the Policy object.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.  To
    support this feature, the caller is provided with a handle that can
    be used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    Buffer - Receives a pointer to a buffer containing enumeration
        information.  This buffer is an array of structures of type
        LSA_TRUST_INFORMATION.  If no trusted domains are found,
        NULL is returned.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Pointer to variable which will receive a count of the
        entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully, there may be
            more entries.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if there are no more objects to enumerate.  Note that
            one or more objects may be enumerated on a call that returns this
            reply.

        STATUS_INVALID_PARAMETER - Invalid parameter.

            - NULL return pointer for enumeration buffer.
--*/

{
    NTSTATUS   Status;

    LSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer;
    EnumerationBuffer.EntriesRead = 0;
    EnumerationBuffer.Information = NULL;

    //
    // Verify that caller has provided a return buffer pointer.
    //

    if (!ARGUMENT_PRESENT(Buffer)) {

        return(STATUS_INVALID_PARAMETER);
    }


    RpcTryExcept {

        //
        // Enumerate the Trusted Domains.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Trusted Domains enumerated this call
        // and a pointer to an array of Trust Information Entries.
        //
        // EnumerationBuffer ->  EntriesRead
        //                       Information -> Trust Info for Domain 0
        //                                      Trust Info for Domain 1
        //                                      ...
        //                                      Trust Info for Domain
        //                                         (EntriesRead - 1)
        //
        //

        Status = LsarEnumerateTrustedDomains(
                     (LSAPR_HANDLE) PolicyHandle,
                     EnumerationContext,
                     &EnumerationBuffer,
                     PreferedMaximumLength
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.EntriesRead;
        *Buffer = EnumerationBuffer.Information;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Trust Information array,
        // free it.
        //

        if (EnumerationBuffer.Information != NULL) {

            MIDL_user_free(EnumerationBuffer.Information);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    return Status;
}

NTSTATUS
LsaEnumeratePrivileges(
    IN LSA_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This function returnes information about privileges known on this
    system.  This call requires POLICY_VIEW_LOCAL_INFORMATION access
    to the Policy Object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls
    can be made to get all of the information.  To support this feature,
    the caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    variable that has been initialized to 0.

    WARNING!  CURRENTLY, THIS FUNCTION ONLY RETURNS INFORMATION ABOUT
              WELL-KNOWN PRIVILEGES.  LATER, IT WILL RETURN INFORMATION
              ABOUT LOADED PRIVILEGES.
Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy() call.

    EnumerationContext - API specific handle to allow multiple calls
        (see Routine Description).

    Buffer - Receives a pointer to a buffer containing information for
        one or more Privileges.  This information is an array of structures
        of type POLICY_PRIVILEGE_DEFINITION.

        When this information is no longer needed, it must be released by
        passing the returned pointer to LsaFreeMemory().

    PreferedMaximumLength - Prefered maximim length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves as
        a guide.  Due to data conversion between systems with different
        natural data sizes, the actual amount of data returned may be
        greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

        STATUS_INVALID_HANDLE - PolicyHandle is not a valid handle to
            a Policy object.

        STATUS_ACCESS_DENIED - The caller does not have the necessary
            access to perform the operation.

        STATUS_MORE_ENTRIES - There are more entries, so call again.  This
            is an informational status only.

        STATUS_NO_MORE_ENTRIES - No entries were returned because there
            are no more.

        Errors from RPC.

--*/

{
    NTSTATUS   Status;
    LSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer;

    EnumerationBuffer.Entries = 0;
    EnumerationBuffer.Privileges = NULL;

    RpcTryExcept {

        //
        // Enumerate the Privileges.  On successful return,
        // the Enumeration Buffer structure will receive a count
        // of the number of Privileges enumerated this call
        // and a pointer to an array of Privilege Definition Entries.
        //
        // EnumerationBuffer ->  Entries
        //                       Privileges -> Privilege Definition 0
        //                                      Privilege Definition 1
        //                                      ...
        //                                      Privilege Definition
        //                                         (Entries - 1)
        //

        Status = LsarEnumeratePrivileges(
                     (LSAPR_HANDLE) PolicyHandle,
                     EnumerationContext,
                     &EnumerationBuffer,
                     PreferedMaximumLength
                     );

        //
        // Return enumeration information or NULL to caller.
        //
        // NOTE:  "Information" is allocated by the called client stub
        // as a single block via MIDL_user_allocate, because Information is
        // allocated all-nodes.  We can therefore pass back the pointer
        // directly to the client, who will be able to free the memory after
        // use via LsaFreeMemory() [which makes a MIDL_user_free call].
        //

        *CountReturned = EnumerationBuffer.Entries;
        *Buffer = EnumerationBuffer.Privileges;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the Account Information array,
        // free it.
        //

        if (EnumerationBuffer.Privileges != NULL) {

            MIDL_user_free(EnumerationBuffer.Privileges);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaCreateSecret(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE SecretHandle
    )

/*++

Routine Description:

    The LsaCreateSecretInLsa API creates a named Secret object in the
    Lsa Database.  Each Secret Object can have two values assigned,
    called the Current Value and the Old Value.  The meaning of these
    values is known to the Secret object creator.  The caller must have
    LSA_CREATE_SECRET access to the LsaDatabase object.

Arguments:

    PolicyHandle -  Handle from an LsaOpenLsa call.

    SecretName - Pointer to Unicode String specifying the name of the
        secret.

    DesiredAccess - Specifies the accesses to be granted to the newly
        created and opened secret.

    SecretHandle - Receives a handle to the newly created and opened
        Secret object.  This handle is used on subsequent accesses to
        the object until closed.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_COLLISION - A Secret object having the given name
            already exists.

        STATUS_TOO_MANY_SECRETS - The maximum number of Secret objects in the
            system has been reached.

        STATUS_PRIVILEGE_NOT_HELD - ACCESS_SYSTEM_SECURITY was specified as part
            of DesiredAccess mask, but the caller does not hold SE_SECURITY_PRIVILEGE
--*/

{
    NTSTATUS   Status;

    *SecretHandle = NULL;

    RpcTryExcept {

        //
        // Verify that the given SecretName has non-null length.  Currently
        // midl cannot handle this.
        //

        if ((SecretName == NULL) ||
            (SecretName->Buffer == NULL) ||
            (SecretName->Length == 0) ||
            (SecretName->Length > SecretName->MaximumLength)) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            Status = LsarCreateSecret(
                         (LSAPR_HANDLE) PolicyHandle,
                         (PLSAPR_UNICODE_STRING) SecretName,
                         DesiredAccess,
                         (PLSAPR_HANDLE) SecretHandle
                         );
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}




NTSTATUS
LsaLookupNames2(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Flags,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID2 *Sids
    )

/*++

Routine Description:

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNamesInLsa API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Flags - LSA_LOOKUP_ISOLATED_AS_LOCAL
                       
    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Sids - Receives a pointer to an array of records describing each
        translated Sid.  The nth entry in this array provides a translation
        for (the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.

        STATUS_TOO_MANY_NAMES - Too many Names have been specified.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MappedCount = 0;
    ULONG i;

    if ( (NULL == Sids)
      || (NULL == ReferencedDomains  ) ) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Init the out parameters since LsaICLookupNames expects this
    //
    *ReferencedDomains = NULL;
    *Sids = NULL;

    Status = LsaICLookupNames(
                 PolicyHandle,
                 Flags,
                 Count,
                 Names,
                 (PLSA_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                 (PLSA_TRANSLATED_SID_EX2*)Sids,
                 LsapLookupWksta,
                 0,
                 &MappedCount,
                 NULL
                 );

    return(Status);
}


NTSTATUS
LsaLookupNames(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID *Sids
    )

/*++

Routine Description:

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNamesInLsa API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Sids - Receives a pointer to an array of records describing each
        translated Sid.  The nth entry in this array provides a translation
        for (the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.

        STATUS_TOO_MANY_NAMES - Too many Names have been specified.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MappedCount = 0;
    PLSA_TRANSLATED_SID_EX2 SidsEx = NULL;
    ULONG i;

    if ( (NULL == Sids)
      || (NULL == ReferencedDomains  ) ) {

        return STATUS_INVALID_PARAMETER;

    }
    *Sids = NULL;
    *ReferencedDomains = NULL;

    Status = LsaICLookupNames(
                 PolicyHandle,
                 0,
                 Count,
                 Names,
                 (PLSA_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                 &SidsEx,
                 LsapLookupWksta,
                 LSAIC_NO_LARGE_SID,
                 &MappedCount,
                 NULL
                 );

    if ( SidsEx ) {

        //
        // Some sids were returned -- map the new structure to the old one
        //
        ULONG SizeNeeded = 0;
        PLSA_TRANSLATED_SID TempSids = NULL;

        SizeNeeded = Count * sizeof( LSA_TRANSLATED_SID );
        TempSids = midl_user_allocate( SizeNeeded );
        if ( TempSids ) {

            RtlZeroMemory( TempSids, SizeNeeded );
            for ( i = 0; i < Count; i++ ) {

                TempSids[i].Use = SidsEx[i].Use;

                if (SidTypeDomain == SidsEx[i].Use) {

                    TempSids[i].RelativeId = LSA_UNKNOWN_ID;

                } else if (SidsEx[i].Sid) {

                    ULONG SubAuthCount = (ULONG) *RtlSubAuthorityCountSid(SidsEx[i].Sid);
                    TempSids[i].RelativeId = *RtlSubAuthoritySid(SidsEx[i].Sid, (SubAuthCount - 1));

                } else {
                    TempSids[i].RelativeId = 0;
                }
                TempSids[i].DomainIndex = SidsEx[i].DomainIndex;
            }

            *Sids = TempSids;

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            if ( *ReferencedDomains ) {

                midl_user_free( *ReferencedDomains );
                *ReferencedDomains = NULL;
            }
        }

        midl_user_free( SidsEx );


    }

    return(Status);
}

NTSTATUS
LsaICLookupNames(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG Flags,
    IN OUT PULONG MappedCount,
    IN OUT PULONG ServerRevision
    )

/*++

Routine Description:

    This function is the internal client side version of the LsaLookupNames
    API.  It is called both from the client side of the Lsa and also
    the server side of the LSA (when calling out to another LSA).  The
    function is identical to the LsaLookupNames API except that there is an
    additional parameter, the LookupLevel parameter.

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNamesInLsa API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.
    
    LookupOptions - Values to pass through to LsarLookupNames2 and above    

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Sids - Receives a pointer to an array of records describing each
        translated Sid.  The nth entry in this array provides a translation
        for (the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on the
        target machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.
            
    Flags - flags to control the operation of the function.  Currently defined:
    
            LSAIC_NO_LARGE_SID -- implies only call interfaces that will return
                                  the old style format SID (no more than 
                                  28 bytes)
                                  
            LSAIC_NT4_TARGET -- target server is known to be NT4
            
            LSAIC_WIN2K_TARGET -- target server is known to be Win2k

    MappedCount - Pointer to location that contains a count of the Names
        mapped so far.  On exit, this count will be updated.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS  Status = STATUS_SUCCESS;

    ULONG  LsaLookupNameRevision = 3;

    LSAPR_TRANSLATED_SIDS_EX2 ReturnedSidsEx2 = { 0, NULL };

    LSAPR_TRANSLATED_SIDS_EX  ReturnedSidsEx  = { 0, NULL };

    LSAPR_TRANSLATED_SIDS     ReturnedSids    = { 0, NULL };

    ULONG Size, SidCount = 0;
    PBYTE NextSid;
    ULONG i;

    ULONG StartingRevision = 3;

    //
    // There are no known clients who pass in a value here
    //
    ASSERT( *ReferencedDomains == NULL );
    ASSERT( *Sids == NULL );

    //
    // Init to NULL since these are considered to be a IN/OUT parameters
    // for the Lsar Lookup API's
    //
    *ReferencedDomains = NULL;
    *Sids = NULL;

    //
    // Check that we have not specfied more than the maximum number of names
    // allowed.
    //

    if (Count > LSAP_DB_TRIAL_MAXIMUM_NAME_COUNT) {

        return(STATUS_TOO_MANY_NAMES);
    }

    if ( ServerRevision ) {
        // The latest client's will prefer the latest servers
        *ServerRevision = LSA_LOOKUP_REVISION_LATEST;
    }

    //
    // Adjust the starting version
    //
    StartingRevision = 3;
    if ((Flags & LSAIC_NO_LARGE_SID)
     || (Flags & LSAIC_WIN2K_TARGET) ) {
        StartingRevision = 2;
    }
    if (Flags & LSAIC_NT4_TARGET) {
        StartingRevision = 1;
    }

    switch (StartingRevision) {
    case 3:

        RpcTryExcept {
    
            Status = LsarLookupNames3(
                         (LSAPR_HANDLE) PolicyHandle,
                         Count,
                         (PLSAPR_UNICODE_STRING) Names,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &ReturnedSidsEx2,
                         LookupLevel,
                         MappedCount,
                         LookupOptions,
                         LSA_LOOKUP_REVISION_LATEST
                         );
    
        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
    
            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));
    
        } RpcEndExcept;

        if ( (Status == RPC_NT_UNKNOWN_IF) ||
             (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ) {
            //
            // Continue on to next block;
            //
            NOTHING;
        } else {
            //
            // The interface was supported; leave
            //
            break;
        }

    case 2:

        RpcTryExcept {
    
            Status = LsarLookupNames2(
                         (LSAPR_HANDLE) PolicyHandle,
                         Count,
                         (PLSAPR_UNICODE_STRING) Names,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &ReturnedSidsEx,
                         LookupLevel,
                         MappedCount,
                         LookupOptions,
                         LSA_LOOKUP_REVISION_LATEST
                         );

            LsaLookupNameRevision = 2;
            if ( ReturnedSidsEx.Sids ) {
                // Memory can be allocated on !NT_SUCCESS, namely
                // STATUS_NONE_MAPPED
                SidCount = ReturnedSidsEx.Entries;
            }
    
        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
    
            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));
    
        } RpcEndExcept;

        if ( (Status == RPC_NT_UNKNOWN_IF) ||
             (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ) {
            //
            // Continue on to next block;
            //
            NOTHING;
        } else {
            //
            // The interface was supported; leave
            //
            break;
        }

    case 1:

        if ( ServerRevision ) {
            *ServerRevision = LSA_LOOKUP_REVISION_1;
        }

        RpcTryExcept {
    
            Status = LsarLookupNames(
                         (LSAPR_HANDLE) PolicyHandle,
                         Count,
                         (PLSAPR_UNICODE_STRING) Names,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &ReturnedSids,
                         LookupLevel,
                         MappedCount
                         );

            LsaLookupNameRevision = 1;
            if ( ReturnedSids.Sids ) {
                // Memory can be allocated on !NT_SUCCESS, namely
                // STATUS_NONE_MAPPED
                SidCount = ReturnedSids.Entries;
            }
    
        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
    
            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));
    
        } RpcEndExcept;

        break;

    default:

        ASSERT(FALSE && "Programming error -- invalid revision" );
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Prevent against network hacks
    //
    if (   NT_SUCCESS( Status )
        && (Count > 0)
        && (   (LsaLookupNameRevision == 1) && ((ReturnedSids.Entries == 0)
                                             || (ReturnedSids.Sids == NULL))
            || (LsaLookupNameRevision == 2) && ((ReturnedSidsEx.Entries == 0)
                                             || (ReturnedSidsEx.Sids == NULL))
            || (LsaLookupNameRevision == 3) && ((ReturnedSidsEx2.Entries == 0)
                                             || (ReturnedSidsEx2.Sids == NULL)))) {
        //
        // This is bogus -- an NT server would never return this
        //
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto Cleanup;
    }

    //
    // Ok at this point, we have a success -- map the return values
    // to the latest revision: LSA_TRANSLATES_SID_EX2
    // 

    if (  ((LsaLookupNameRevision == 2) && ReturnedSidsEx.Sids != NULL)
       || ((LsaLookupNameRevision == 1) && ReturnedSids.Sids != NULL) ) {

        //
        // There should be a ReferencedDomains
        //
        ASSERT( NULL != *ReferencedDomains);

        //
        // Calculate the size necessary.  All SID's from non Sid-Extended domains
        // will be less than 28 bytes.  However, we still sanity check the values
        // returned from the untrusted net before copying in (see below).
        //
    
    #define MAX_DOWNLEVEL_SID_SIZE 28
    
        //
        // Since we are returning a buffer containing all allocations, make sure
        // everything aligned properly
        //

        ASSERT(MAX_DOWNLEVEL_SID_SIZE == 
               ROUND_UP_COUNT(MAX_DOWNLEVEL_SID_SIZE, ALIGN_DWORD));
        ASSERT(sizeof(LSA_TRANSLATED_SID_EX2) == 
               ROUND_UP_COUNT(sizeof(LSA_TRANSLATED_SID_EX2), ALIGN_DWORD));
    
        Size =  SidCount * sizeof(LSA_TRANSLATED_SID_EX2);
        Size += SidCount * MAX_DOWNLEVEL_SID_SIZE;
        ReturnedSidsEx2.Sids = MIDL_user_allocate(Size);
        if (NULL == ReturnedSidsEx2.Sids) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(ReturnedSidsEx2.Sids, Size);
        NextSid = (PBYTE) ReturnedSidsEx2.Sids;
        NextSid += (SidCount * sizeof(LSA_TRANSLATED_SID_EX2));
    
        for ( i = 0; i < SidCount; i++ ) {
    
            BYTE  Buffer[MAX_DOWNLEVEL_SID_SIZE];
            PSID  Sid = (PSID)Buffer;
            ULONG SidLength;
            ULONG DomainIndex;
            ULONG Rid;
            SID_NAME_USE SidNameUse;
            ULONG Flags;
            PSID  DomainSid;
    
            if (1 == LsaLookupNameRevision) {
    
                DomainIndex = ReturnedSids.Sids[i].DomainIndex;
                Rid = ReturnedSids.Sids[i].RelativeId;
                SidNameUse = ReturnedSids.Sids[i].Use;
                Flags = 0;
    
            } else  {
    
                ASSERT( 2 == LsaLookupNameRevision );
    
                DomainIndex = ReturnedSidsEx.Sids[i].DomainIndex;
                Rid = ReturnedSidsEx.Sids[i].RelativeId;
                SidNameUse = ReturnedSidsEx.Sids[i].Use;
                Flags = ReturnedSidsEx.Sids[i].Flags;
            }
    
            //
            // Copy over the simple values
            //
            ReturnedSidsEx2.Sids[i].Use = SidNameUse;
            ReturnedSidsEx2.Sids[i].DomainIndex = DomainIndex;
            ReturnedSidsEx2.Sids[i].Flags = Flags;
    
            //
            // Copy over the sid if possible
            //
            // To support possible additions in the future, check for the negative cases.
            // These types will never have any SIDs; all others must have a SID portion.
            //
            if ( (SidNameUse != SidTypeDeletedAccount)
              && (SidNameUse != SidTypeInvalid)
              && (SidNameUse != SidTypeUnknown)  ) {

                if (DomainIndex == LSA_UNKNOWN_INDEX) {
                    //
                    // This is a bogus return value
                    //
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                    goto Cleanup;
                }

                //
                // N.B.  For domain names, the RID is set to LSA_UNKNOWN_ID and
                // to be compatible with the LsarLookupName3 routine, return
                // a SID in ReturedSidsEx2 structure.
                //
                DomainSid = (*ReferencedDomains)->Domains[DomainIndex].Sid;
                if (RtlLengthSid(DomainSid) > (MAX_DOWNLEVEL_SID_SIZE - sizeof(DWORD))){
                    //
                    // This is a bogus return value
                    //
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                    goto Cleanup;
                }
        
                RtlCopySid(sizeof(Buffer), Sid, DomainSid);
                if ( Rid != LSA_UNKNOWN_ID ) {
                    ULONG RidAuthority;
                    RidAuthority= (*(RtlSubAuthorityCountSid(Sid)))++;
                    *RtlSubAuthoritySid(Sid,RidAuthority) = Rid;
                }

                SidLength = RtlLengthSid(Sid);
                RtlCopySid(SidLength, (PSID)NextSid, Sid);
        
                ReturnedSidsEx2.Sids[i].Sid = (PSID)NextSid;
                NextSid += RtlLengthSid(Sid);

            } else {

                //
                // Either no domain SID, or account is unknown
                //
                ReturnedSidsEx2.Sids[i].Sid = NULL;

            }
    
        }
    }

    *Sids = (PLSA_TRANSLATED_SID_EX2) ReturnedSidsEx2.Sids;
    ReturnedSidsEx2.Sids = NULL;

Cleanup:

    if ( (STATUS_INVALID_NETWORK_RESPONSE == Status)
     ||  (STATUS_NO_MEMORY == Status)    ) {
        if ( *ReferencedDomains ) {
            MIDL_user_free( *ReferencedDomains );
            *ReferencedDomains = NULL;
        }
        *Sids = NULL;
    }

    if ( ReturnedSids.Sids ) {
        MIDL_user_free( ReturnedSids.Sids );
    }
    if ( ReturnedSidsEx.Sids ) {
        MIDL_user_free( ReturnedSidsEx.Sids );
    }
    if ( ReturnedSidsEx2.Sids ) {
        MIDL_user_free( ReturnedSidsEx2.Sids );
    }

    return(Status);
}


NTSTATUS
LsaLookupSids(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME *Names
    )

/*++

Routine Description:

    The LsaLookupSids API attempts to find names corresponding to Sids.
    If a name can not be mapped to a Sid, the Sid is converted to character
    form.  The caller must have POLICY_LOOKUP_NAMES access to the Policy
    object.

    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of Sids to be translated.

    Sids - Pointer to an array of Count pointers to Sids to be mapped
        to names.  The Sids may be well_known SIDs, SIDs of User accounts
        Group Accounts, Alias accounts, or Domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the strutcure returned via the Names parameter.
        Unlike the Names paraemeter, which contains an array entry
        for (each translated name, this strutcure will only contain
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Names - Receives a pointer to array records describing each translated
        name.  The nth entry in this array provides a translation for
        the nth entry in the Sids parameter.

        All of the returned names will be isolated names or NULL strings
        (domain names are returned as NULL strings).  If the caller needs
        composite names, they can be generated by prepending the
        isolated name with the domain name and a backslash.  For example,
        if (the name Sally is returned, and it is from the domain Manufact,
        then the composite name would be "Manufact" + "\" + "Sally" or
        "Manufact\Sally".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

        If a Sid is not translatable, then the following will occur:

        1) If the SID's domain is known, then a reference domain record
           will be generated with the domain's name.  In this case, the
           name returned via the Names parameter is a Unicode representation
           of the relative ID of the account, such as "(314)" or the null
           string, if the Sid is that of a domain.  So, you might end up
           with a resultant name of "Manufact\(314) for the example with
           Sally above, if Sally's relative id is 314.

        2) If not even the SID's domain could be located, then a full
           Unicode representation of the SID is generated and no domain
           record is referenced.  In this case, the returned string might
           be something like: "(S-1-672194-21-314)".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could not be
            mapped.  This is a warning only.

        Rest TBS
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MappedCount = 0;
    PLSA_TRANSLATED_NAME_EX NamesEx = NULL;
    ULONG i;

    if ( NULL == Names ) {

        return STATUS_INVALID_PARAMETER;

    }

    Status = LsaICLookupSids(
                 PolicyHandle,
                 Count,
                 Sids,
                 ReferencedDomains,
                 &NamesEx,
                 LsapLookupWksta,
                 0,
                 &MappedCount,
                 NULL
                 );

    if ( NamesEx != NULL ) {

        //
        // Some names were returned -- map the new structure to the old one
        // and keep allocations in the same block of memory so existing clients
        // won't have memory leaks
        //
        ULONG SizeNeeded = 0;
        PBYTE NextBuffer;
        PLSA_TRANSLATED_NAME TempNames = NULL;

        SizeNeeded = Count * sizeof( LSA_TRANSLATED_NAME );
        for ( i = 0; i < Count; i++ ) {
            SizeNeeded += NamesEx[i].Name.MaximumLength;
        }

        TempNames = MIDL_user_allocate( SizeNeeded );
        if ( TempNames ) {

            RtlZeroMemory( TempNames, SizeNeeded );
            NextBuffer = ((PBYTE)TempNames) + (Count * sizeof( LSA_TRANSLATED_NAME ));

            for ( i = 0; i < Count; i++ ) {

                TempNames[i].Use = NamesEx[i].Use;
                TempNames[i].DomainIndex = NamesEx[i].DomainIndex;

                TempNames[i].Name = NamesEx[i].Name;
                RtlCopyMemory( NextBuffer, NamesEx[i].Name.Buffer, NamesEx[i].Name.Length );
                TempNames[i].Name.Buffer = (WCHAR*)NextBuffer;

                NextBuffer += NamesEx[i].Name.MaximumLength;
            }

        } else {

            //
            // The call succeeded but the extra allocation didn't
            //
            if ( *ReferencedDomains ) {
                MIDL_user_free( *ReferencedDomains );
                *ReferencedDomains = NULL;
            }
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Return the results (or NULL)
        //
        *Names = TempNames;

        MIDL_user_free( NamesEx );

    } else {

        *Names = NULL;

    }

    return(Status);
}


NTSTATUS
LsapVerifyReturnedNames(
    IN  LSAPR_TRANSLATED_NAMES_EX *ReturnedNames,
    IN  ULONG Count,
    IN  PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains
    )
/*++

Routine Description:

    This routine validates the returned names structure from the server.
    There are some checks that RPC can't make that the client assumes are
    true and will AV otherwise.

Arguments:

    Count -- the number of elements the client asked the server to resolve
                                                                                
    ReturnedNames -- the structure holding the data returned from the server
    
    ReferencedDomains -- the array of domains that ReturnedNames points into
                         (also returned from the server)

Return Values:

    STATUS_SUCCESS
    
    STATUS_INVALID_NETWORK_RESPONSE
    
--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;

    if (ReturnedNames->Entries != Count) {

        //
        // Entries returned should always equal the number of items asked for
        //

        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto Finish;
    }

    if ( Count > 0
     && (ReturnedNames->Names == NULL))  {

        //
        // If there are entries, then there must be an array
        //

        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto Finish;

    }

    for (i = 0; i < Count; i++) {

        //
        // All resolved names must have a valid domain index
        //
        if ( (ReturnedNames->Names[i].Use != SidTypeInvalid) &&
             (ReturnedNames->Names[i].Use != SidTypeDeletedAccount) &&
             (ReturnedNames->Names[i].Use != SidTypeUnknown) ) {

            if (NULL == ReferencedDomains) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
                goto Finish;
            } else if ( (ReturnedNames->Names[i].DomainIndex == LSA_UNKNOWN_INDEX)
                    ||  (ReturnedNames->Names[i].DomainIndex < 0)
                    ||  ((ULONG)ReturnedNames->Names[i].DomainIndex >= ReferencedDomains->Entries)) {
                ASSERT(FALSE && "Invalid network response!");
                Status = STATUS_INVALID_NETWORK_RESPONSE;
                goto Finish;
            }
        }
    }

Finish:

    return Status;

}



NTSTATUS
LsaICLookupSids(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG Flags,
    IN OUT PULONG MappedCount,
    OUT ULONG *ServerRevision OPTIONAL
    )

/*++

Routine Description:

    This function is the internal client side version of the LsaLookupSids
    API.  It is called both from the client side of the Lsa and also
    the server side of the LSA (when calling out to another LSA).  The
    function is identical to the LsaLookupSids API except that there is an
    additional parameter, the LookupLevel parameter.

    The LsaLookupSids API attempts to find names corresponding to Sids.
    If a name can not be mapped to a Sid, the Sid is converted to character
    form.  The caller must have POLICY_LOOKUP_NAMES access to the Policy
    object.

    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of Sids to be translated.

    Sids - Pointer to an array of Count pointers to Sids to be mapped
        to names.  The Sids may be well_known SIDs, SIDs of User accounts
        Group Accounts, Alias accounts, or Domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the strutcure returned via the Names parameter.
        Unlike the Names paraemeter, which contains an array entry
        for (each translated name, this strutcure will only contain
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Names - Receives a pointer to array records describing each translated
        name.  The nth entry in this array provides a translation for
        the nth entry in the Sids parameter.

        All of the retruned names will be isolated names or NULL strings
        (domain names are returned as NULL strings).  If the caller needs
        composite names, they can be generated by prepending the
        isolated name with the domain name and a backslash.  For example,
        if (the name Sally is returned, and it is from the domain Manufact,
        then the composite name would be "Manufact" + "\" + "Sally" or
        "Manufact\Sally".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

        If a Sid is not translatable, then the following will occur:

        1) If the SID's domain is known, then a reference domain record
           will be generated with the domain's name.  In this case, the
           name returned via the Names parameter is a Unicode representation
           of the relative ID of the account, such as "(314)" or the null
           string, if the Sid is that of a domain.  So, you might end up
           with a resultant name of "Manufact\(314) for the example with
           Sally above, if Sally's relative id is 314.

        2) If not even the SID's domain could be located, then a full
           Unicode representation of the SID is generated and no domain
           record is referenced.  In this case, the returned string might
           be something like: "(S-1-672194-21-314)".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on the
        target machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.
            
    Flags:
            LSAIC_NT4_TARGET -- target server is known to be NT4
            
            LSAIC_WIN2K_TARGET -- target server is known to be Win2k

    MappedCount - Pointer to location that contains a count of the Sids
        mapped so far.  On exit, this count will be updated.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could not be
            mapped.  This is a warning only.

        STATUS_TOO_MANY_SIDS - Too many Sids have been specified.

--*/

{
    NTSTATUS  Status;

    BOOLEAN NamesArraySpecified = FALSE;

    LSAPR_SID_ENUM_BUFFER SidEnumBuffer;

    LSAPR_TRANSLATED_NAMES_EX ReturnedNames = {0, NULL};

    LSAPR_TRANSLATED_NAMES    DownlevelNames  = {0, NULL};

    ULONG StartingRevision = 2;

    if ( ServerRevision ) {
        // The latest client's will prefer the latest servers
        *ServerRevision = LSA_CLIENT_LATEST;
    }

    //
    // Verify that the Count is positive and not too high
    //

    if (Count == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    if (Count > LSAP_DB_TRIAL_MAXIMUM_SID_COUNT) {

        return STATUS_TOO_MANY_SIDS;
    }

    SidEnumBuffer.Entries = Count;
    SidEnumBuffer.SidInfo = (PLSAPR_SID_INFORMATION) Sids;

    //
    // If this is a Workstation-Level lookup, the Names and
    // ReferencedDomain Lists have not been created.  Since these
    // are input parameters in the general case, we need to set them
    // to NULL.
    //

    if (LookupLevel == LsapLookupWksta) {

        *ReferencedDomains = NULL;
        *Names = NULL;
    }

    //
    // There may already be a name translation array in cases where
    // we are called internally (i.e. with lookup level higher than
    // LsapLookupWksta).  Initialize the ReturnedNames structure
    // accordingly.
    //

    ReturnedNames.Entries = 0;
    ReturnedNames.Names = NULL;

    if (*Names != NULL) {

        ReturnedNames.Entries = Count;
        ReturnedNames.Names = (PLSAPR_TRANSLATED_NAME_EX) *Names;
        NamesArraySpecified = TRUE;
    }

    //
    // Adjust the StartingRevision
    //
    StartingRevision = 2;
    if (Flags & LSAIC_NT4_TARGET) {
        StartingRevision = 1;
    }

    //
    // Lookup Sids on the Server..
    //

    switch (StartingRevision) {
    case 2:

        RpcTryExcept {
            Status = LsarLookupSids2(
                         (LSAPR_HANDLE) PolicyHandle,
                         &SidEnumBuffer,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &ReturnedNames,
                         LookupLevel,
                         MappedCount,
                         0,
                         LSA_CLIENT_NT5
                         );
    
            //
            // Return the array of translation to name info or NULL.
            //
            // NOTE:  The array of name translations is allocated by the called
            // client stub as a single block via MIDL_user_allocate, because
            // Information is allocated all-nodes.  We can therefore pass back the pointer
            // directly to the client, who will be able to free the memory after
            // use via LsaFreeMemory() [which makes a MIDL_user_free call].
            //
    
            *Names = (PLSA_TRANSLATED_NAME_EX) ReturnedNames.Names;
    
        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
    
            //
            // If memory was allocated for the name translation array,
            // free it.
            //
    
            if ((!NamesArraySpecified) && ReturnedNames.Names != NULL) {
    
                MIDL_user_free( ReturnedNames.Names );
                ReturnedNames.Names = NULL;
            }
    
            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));
    
        } RpcEndExcept;

        if ( (Status == RPC_NT_UNKNOWN_IF) ||
             (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ) {
            //
            // Continue on to next block;
            //
            NOTHING;
        } else {
            //
            // The interface was supported; leave
            //
            break;
        }

    case 1:

        if ( ServerRevision ) {
            // This is pre nt5
            *ServerRevision = LSA_CLIENT_PRE_NT5;
        }

        RpcTryExcept {

            //
            // Ok, lower down to the previous version
            //
            Status = LsarLookupSids(
                         (LSAPR_HANDLE) PolicyHandle,
                         &SidEnumBuffer,
                         (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                         &DownlevelNames,
                         LookupLevel,
                         MappedCount
                         );

            if ( DownlevelNames.Names != NULL ) {

                ULONG i;
                ULONG SizeNeeded = 0;
                PBYTE NextBuffer;

                //
                // Package the results into a new structure.  Note all memory
                // must be in the same block as LSA_TRANSLATED_NAMES and
                // LSA_TRANSLATED_NAMES_EX are NOT allocate all nodes
                //
                SizeNeeded = DownlevelNames.Entries * sizeof( LSA_TRANSLATED_NAME_EX );
                for ( i = 0; i < DownlevelNames.Entries; i++ ) {
                    SizeNeeded += DownlevelNames.Names[i].Name.MaximumLength;
                }
                if ( !NamesArraySpecified ) {
                    ReturnedNames.Names = MIDL_user_allocate( SizeNeeded );
                    if ( !ReturnedNames.Names ) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        _leave;
                    }
                    RtlZeroMemory( ReturnedNames.Names, SizeNeeded );
                    ReturnedNames.Entries = Count;
                }
                NextBuffer = ((PBYTE)ReturnedNames.Names) + (Count * sizeof( LSA_TRANSLATED_NAME_EX ));

                ReturnedNames.Entries = DownlevelNames.Entries;
                for ( i = 0; i < DownlevelNames.Entries; i++ ) {

                    ReturnedNames.Names[i].Use = DownlevelNames.Names[i].Use;
                    ReturnedNames.Names[i].Name = DownlevelNames.Names[i].Name;
                    RtlCopyMemory( NextBuffer, DownlevelNames.Names[i].Name.Buffer, DownlevelNames.Names[i].Name.Length );
                    ReturnedNames.Names[i].Name.Buffer = (WCHAR*)NextBuffer;
                    ReturnedNames.Names[i].DomainIndex = DownlevelNames.Names[i].DomainIndex;
                    NextBuffer += DownlevelNames.Names[i].Name.MaximumLength;
                }
            }

        } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

            if ( DownlevelNames.Names ) {

                MIDL_user_free( DownlevelNames.Names );
                DownlevelNames.Names = NULL;
            }

            if ((!NamesArraySpecified) && ReturnedNames.Names != NULL) {

                MIDL_user_free( ReturnedNames.Names );
                ReturnedNames.Names = NULL;
            }

            Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

        } RpcEndExcept;

        break;

    default:
        ASSERT(FALSE && "Programming error -- wrong revision");
        Status = STATUS_INVALID_PARAMETER;

    }

    //
    // Return the array of translation to name info or NULL.
    //
    // NOTE:  The array of name translations is allocated by the called
    // client stub as a single block via MIDL_user_allocate, because
    // Information is allocated all-nodes.  We can therefore pass back the pointer
    // directly to the client, who will be able to free the memory after
    // use via LsaFreeMemory() [which makes a MIDL_user_free call].
    //

    *Names = (PLSA_TRANSLATED_NAME_EX) ReturnedNames.Names;

    //
    // This memory, if allocated is never returned to the caller, so free
    //
    if ( DownlevelNames.Names ) {

        MIDL_user_free( DownlevelNames.Names );

    }

    //
    // Prevent against network hacks
    //
    if (NT_SUCCESS(Status)) {

        Status = LsapVerifyReturnedNames(&ReturnedNames,
                                         Count,
                                         *ReferencedDomains);

        if (!NT_SUCCESS(Status)) {
    
            if ( (!NamesArraySpecified) && ReturnedNames.Names ) {
                MIDL_user_free( ReturnedNames.Names );
            }
    
            if ( *ReferencedDomains ) {
                MIDL_user_free( *ReferencedDomains );
                *ReferencedDomains = NULL;
            }
        }
    }

    return(Status);
}


NTSTATUS
LsaOpenAccount(
    IN LSA_HANDLE PolicyHandle,
    IN PSID AccountSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE AccountHandle
    )

/*++

Routine Description:

    The LsaOpenAccount API opens an account object in the Lsa Database of the
    target system.  An account must be opened before any operation can be
    performed, including deletion of the account.  A handle to the account
    object is returned for use on subsequent API calls that access the
    account.  Before calling this API, the caller must have connected to
    the target system's LSA and opened the Policy object by means
    of a preceding call to LsaOpenPolicy.

Arguments:

    PolicyHandle - Handle from an LsaOpenLsa call.

    AccountSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the LSA Subsystem's LSA Database.  These access types
        are reconciled with the Discretionary Access Control List of the
        target Account object to determine whether the accesses will be
        granted or denied.

    AccountHandle - Pointer to location in which a handle to the opened
        account object will be returned if the call succeeds.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_ACCOUNT_DOES_NOT_EXIST - There is no account object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarOpenAccount(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_SID) AccountSid,
                     DesiredAccess,
                     (PLSAPR_HANDLE) AccountHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaEnumeratePrivilegesOfAccount(
    IN LSA_HANDLE AccountHandle,
    OUT PPRIVILEGE_SET *Privileges
    )

/*++

Routine Description:

    The LsaEnumeratePrivilegesOfAccount API obtains information which
    describes the privileges assigned to an account.  This call requires
    LSA_ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose privilege
        information is to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Receives a pointer to a buffer containing the Privilege
        Set.  The Privilege Set is an array of structures, one for each
        privilege.  Each structure contains the LUID of the privilege and
        a mask of the privilege's attributes.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        *Privileges = NULL;

        Status = LsarEnumeratePrivilegesAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     (PLSAPR_PRIVILEGE_SET *) Privileges
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaAddPrivilegesToAccount(
    IN LSA_HANDLE AccountHandle,
    IN PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    The LsaAddPrivilegesToAccount API adds privileges and their attributes
    to an account object.  If any provided privilege is already assigned
    to the account object, the attributes of that privilege are replaced
    by the newly rpovided values.  This API call requires
    LSA_ACCOUNT_ADJUST_PRIVILEGES access to the account object.

Arguments:

    AccountHandle - The handle to the open account object to which
        privileges are to be added.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Points to a set of privileges (and their attributes) to
        be assigned to the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarAddPrivilegesToAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     (PLSAPR_PRIVILEGE_SET) Privileges
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaRemovePrivilegesFromAccount(
    IN LSA_HANDLE AccountHandle,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    The LsaRemovePrivilegesFromAccount API removes privileges from an
    account object.  This API call requires LSA_ACCOUNT_ADJUST_PRIVILEGES
    access to the account object.  Note that if all privileges are removed
    from the account object, the account object remains in existence until
    deleted explicitly via a call to the LsaDelete API.

Arguments:

    AccountHandle - The handle to the open account object to which
        privileges are to be removed.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    AllPrivileges - If TRUE, then all privileges are to be removed from
        the account.  In this case, the Privileges parameter must be
        specified as NULL.  If FALSE, the Privileges parameter specifies
        the privileges to be removed, and must be non NULL.

    Privileges - Optionally points to a set of privileges (and their
        attributes) to be removed from the account object.  The attributes
        fields of this structure are ignored.  This parameter must
        be specified as non-NULL if and only if AllPrivileges is set to
        FALSE.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

        STATUS_INVALID_PARAMETER - The optional Privileges paraemter was
            specified as NULL and AllPrivileges was set to FALSE.

--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarRemovePrivilegesFromAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     AllPrivileges,
                     (PLSAPR_PRIVILEGE_SET) Privileges
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaGetQuotasForAccount(
    IN LSA_HANDLE AccountHandle,
    OUT PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    The LsaGetQuotasForAccount API obtains the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota and explicit value is returned.  This
    call requires LSA_ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure in which the system resource
        quota limits applicable to each session logged on to this account
        will be returned.  Note that all quotas, including those specified
        as being the system default values, are returned as actual values.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.
--*/

{
    NTSTATUS   Status;

    RpcTryExcept{

        Status = LsarGetQuotasForAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     QuotaLimits
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaSetQuotasForAccount(
    IN LSA_HANDLE AccountHandle,
    IN PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    The LsaSetQuotasForAccount API sets the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota an explicit value or the system default
    may be specified.  This call requires LSA_ACCOUNT_ADJUST_QUOTAS
    access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be set.  This handle will have been returned from a prior
        LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure containing the system resource
        quota limits applicable to each session logged on to this account.
        A zero value specified in any field indicates that the current
        System Default Quota Limit is to be applied.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.
--*/

{
    NTSTATUS   Status;

    RpcTryExcept {

        Status = LsarSetQuotasForAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     QuotaLimits
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return Status;
}


NTSTATUS
LsaGetSystemAccessAccount(
    IN LSA_HANDLE AccountHandle,
    OUT PULONG SystemAccess
    )

/*++

Routine Description:

    The LsaGetSystemAccessAccount() service returns the System Access
    account flags for an Account object.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_VIEW access.

    SystemAccess - Points to location that will receive the system access
        flags for the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

--*/

{
    NTSTATUS   Status;

    //
    // Avoid RPC stub code raising exception on NULL handle so that
    // we can return the error code STATUS_INVALID_HANDLE in this case
    // too.
    //

    if (!ARGUMENT_PRESENT(AccountHandle)) {

        return(STATUS_INVALID_HANDLE);
    }

    RpcTryExcept{

        Status = LsarGetSystemAccessAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     SystemAccess
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaSetSystemAccessAccount(
    IN LSA_HANDLE AccountHandle,
    IN ULONG SystemAccess
    )

/*++

Routine Description:

    The LsaSetSystemAccessAccount() service sets the System Access
    account flags for an Account object.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_ADJUST_SYSTEM_ACCESS access.

    SystemAccess - A mask of the system access flags to assign to the
        Account object.  The valid access flags include:

        POLICY_MODE_INTERACTIVE - Account can be accessed interactively

        POLICY_MODE_NETWORK - Account can be accessed remotely

        POLICY_MODE_SERVICE - TBS

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

        STATUS_INVALID_PARAMETER - The specified Access Flags are invalid.
--*/

{
    NTSTATUS Status;

    //
    // Avoid RPC stub code raising exception on NULL handle so that
    // we can return the error code STATUS_INVALID_HANDLE in this case
    // too.
    //

    if (!ARGUMENT_PRESENT(AccountHandle)) {

        return(STATUS_INVALID_HANDLE);
    }

    RpcTryExcept {

        Status = LsarSetSystemAccessAccount(
                     (LSAPR_HANDLE) AccountHandle,
                     SystemAccess
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaFreeMemory(
    IN PVOID Buffer
    )

/*++

Routine Description:


    Some LSA services that return a potentially large amount of memory,
    such as an enumeration might, allocate the buffer in which the data
    is returned.  This function is used to free those buffers when they
    are no longer needed.

Parameters:

    Buffer - Pointer to the buffer to be freed.  This buffer must
        have been allocated by a previous LSA service call.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    MIDL_user_free( Buffer );

    return Status;
}



NTSTATUS
LsaOpenSecret(
    IN LSA_HANDLE PolicyHandle,
    IN PUNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE SecretHandle
    )

/*++

Routine Description:

    The LsaOpenSecret API opens a Secret Object within the LSA Database.
    A handle is returned which must be used to perform operations on the
    secret object.

Arguments:

    PolicyHandle - Handle from an LsaOpenLsa call.

    SecretName - Pointer to a Unicode String structure that references the
        name of the Secret object to be opened.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the secret object being opened.  These access types
        are reconciled with the Discretionary Access Control List of the
        target secret object to determine whether the accesses will be
        granted or denied.


    SecretHandle - Pointer to location that will receive a handle to the
        newly opened Secret object.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no Secret object in the
            target system's LSA Database having the specified SecretName.

--*/

{
    NTSTATUS Status;

    RpcTryExcept {

        Status = LsarOpenSecret(
                     (LSAPR_HANDLE) PolicyHandle,
                     (PLSAPR_UNICODE_STRING) SecretName,
                     DesiredAccess,
                     (PLSAPR_HANDLE) SecretHandle
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    return(Status);
}


NTSTATUS
LsaSetSecret(
    IN LSA_HANDLE SecretHandle,
    IN OPTIONAL PUNICODE_STRING CurrentValue,
    IN OPTIONAL PUNICODE_STRING OldValue
    )

/*++

Routine Description:

    The LsaSetSecret API optionally sets one or both values associated with
    a secret.  These values are known as the "current value" and "old value"
    of the secret and have a meaning known to the creator of the Secret
    object.  The values given are stored in encrypted form.

Arguments:

    SecretHandle - Handle from an LsaOpenSecret or LsaCreateSecret call.

    CurrentValue - Optional pointer to Unicode String containing the
        value to be assigned as the "current value" of the Secret
        object.  The meaning of "current value" is dependent on the
        purpose for which the Secret object is being used.

    OldValue - Optional pointer to Unicode String containing the
        value to be assigned as the "old value" of the Secret object.
        The meaning of "old value" is dependent on the purpose for
        which the Secret object is being used.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no Secret object in the
            target system's LSA Database having the specified SecretName.
--*/

{
    NTSTATUS Status;

    PLSAP_CR_CIPHER_VALUE CipherCurrentValue = NULL;
    PLSAP_CR_CIPHER_VALUE CipherOldValue = NULL;
    LSAP_CR_CLEAR_VALUE ClearCurrentValue;
    LSAP_CR_CLEAR_VALUE ClearOldValue;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    //
    // Convert input from Unicode Structures to Clear Value Structures.
    //

    LsapCrUnicodeToClearValue( CurrentValue, &ClearCurrentValue );
    LsapCrUnicodeToClearValue( OldValue, &ClearOldValue );

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value and/or Old Values.
    //

    RpcTryExcept {

        Status = LsapCrClientGetSessionKey( SecretHandle, &SessionKey );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto SetSecretError;
    }

    //
    // Encrypt the Current Value if specified and not too long.
    //

    if (ARGUMENT_PRESENT(CurrentValue)) {

        Status = LsapCrEncryptValue(
                     &ClearCurrentValue,
                     SessionKey,
                     &CipherCurrentValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto SetSecretError;
        }
    }

    //
    // Encrypt the Old Value if specified and not too long.
    //

    if (ARGUMENT_PRESENT(OldValue)) {

        Status = LsapCrEncryptValue(
                     (PLSAP_CR_CLEAR_VALUE) &ClearOldValue,
                     SessionKey,
                     &CipherOldValue
                     );

        if (!NT_SUCCESS(Status)) {

            goto SetSecretError;
        }
    }

    //
    // Set the Secret Values.
    //

    RpcTryExcept {

        Status = LsarSetSecret(
                     (LSAPR_HANDLE) SecretHandle,
                     (PLSAPR_CR_CIPHER_VALUE) CipherCurrentValue,
                     (PLSAPR_CR_CIPHER_VALUE) CipherOldValue
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto SetSecretError;
    }

SetSecretFinish:

    //
    // If necessary, free memory allocated for the Encrypted Current Value.
    //

    if (CipherCurrentValue != NULL) {

        LsaFreeMemory(CipherCurrentValue);
    }

    //
    // If necessary, free memory allocated for the Encrypted Old Value.
    //

    if (CipherOldValue != NULL) {

        LsaFreeMemory(CipherOldValue);
    }

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    return(Status);

SetSecretError:

    goto SetSecretFinish;
}


NTSTATUS
LsaQuerySecret(
    IN LSA_HANDLE SecretHandle,
    IN OUT OPTIONAL PUNICODE_STRING *CurrentValue,
    OUT PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PUNICODE_STRING *OldValue,
    OUT PLARGE_INTEGER OldValueSetTime
    )

/*++

Routine Description:

    The LsaQuerySecret API optionally returns one or both of the values
    assigned to a Secret object.  These values are known as the "current value"
    and the "old value", and they have a meaning known to the creator of the
    Secret object.  The values are returned in their original unencrypted form.
    The caller must have LSA_QUERY_SECRET access to the Secret object.

Arguments:

    SecretHandle - Handle from an LsaOpenSecret or LsaCreateSecret call.

    CurrentValue - Optional pointer to location which will receive a pointer
        to a Unicode String containing the value assigned as the "current
        value" of the secret object.  If no "current value" is assigned to
        the Secret object, a NULL pointer is returned.

    CurrentValueSetTime - The date/time at which the current secret value
        was established.

    OldValue - Optional pointer to location which will receive a pointer
        to a Unicode String containing the value assigned as the "old
        value" of the secret object.  If no "current value" is assigned to
        the Secret object, a NULL pointer is returned.

    OldValueSetTime - The date/time at which the old secret value
        was established.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no Secret object in the
            target system's LSA Database having the specified SecretName.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PLSAP_CR_CIPHER_VALUE CipherCurrentValue = NULL;
    PLSAP_CR_CIPHER_VALUE CipherOldValue = NULL;
    PLSAP_CR_CLEAR_VALUE ClearCurrentValue = NULL;
    PLSAP_CR_CLEAR_VALUE ClearOldValue = NULL;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    RpcTryExcept {

        Status = LsarQuerySecret(
                     (PLSAPR_HANDLE) SecretHandle,
                     (PLSAPR_CR_CIPHER_VALUE *) &CipherCurrentValue,
                     CurrentValueSetTime,
                     (PLSAPR_CR_CIPHER_VALUE *) &CipherOldValue,
                     OldValueSetTime
                     );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;
    }

    //
    // Obtain the Session Key to be used to two-way encrypt the
    // Current Value and/or Old Values.
    //

    RpcTryExcept {

        Status = LsapCrClientGetSessionKey( SecretHandle, &SessionKey );

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(Status)) {

        goto QuerySecretError;
    }

    //
    // If the Current Value is requested and a Current Value exists,
    // decrypt it using the Session key.  Otherwise store NULL for return.
    //

    if (ARGUMENT_PRESENT(CurrentValue)) {

        if (CipherCurrentValue != NULL) {

            Status = LsapCrDecryptValue(
                         CipherCurrentValue,
                         SessionKey,
                         &ClearCurrentValue
                         );

            if (!NT_SUCCESS(Status)) {

                goto QuerySecretError;
            }

            //
            // Convert Clear Current Value to Unicode
            //

            LsapCrClearValueToUnicode(
                ClearCurrentValue,
                (PUNICODE_STRING) ClearCurrentValue
                );
            *CurrentValue = (PUNICODE_STRING) ClearCurrentValue;

        } else {

            *CurrentValue = NULL;
        }
    }

    //
    // If the Old Value is requested and an Old Value exists,
    // decrypt it using the Session key.  Otherwise store NULL for return.
    //

    if (ARGUMENT_PRESENT(OldValue)) {

        if (CipherOldValue != NULL) {

            Status = LsapCrDecryptValue(
                         CipherOldValue,
                         SessionKey,
                         &ClearOldValue
                         );

            if (!NT_SUCCESS(Status)) {

                goto QuerySecretError;
            }

            //
            // Convert Clear Old Value to Unicode
            //

            LsapCrClearValueToUnicode(
                ClearOldValue,
                (PUNICODE_STRING) ClearOldValue
                );

            *OldValue = (PUNICODE_STRING) ClearOldValue;

        } else {

            *OldValue = NULL;
        }
    }

    //
    // Getting here means that the operation completed successfully,
    // but Status can be something other than STATUS_SUCCESS.
    // For instance, if both output buffers are NULL, the value of Status
    // at this point will be STATUS_LOCAL_USER_SESSION_KEY.
    // Explicitly clear Status here and avoid confusion for the client.
    //

    Status = STATUS_SUCCESS;

QuerySecretFinish:

    //
    // If necessary, free memory allocated for the Session Key.
    //

    if (SessionKey != NULL) {

        MIDL_user_free(SessionKey);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Current Value.
    //

    if (CipherCurrentValue != NULL) {

        LsapCrFreeMemoryValue(CipherCurrentValue);
    }

    //
    // If necessary, free memory allocated for the returned Encrypted
    // Old Value.
    //

    if (CipherOldValue != NULL) {

        LsapCrFreeMemoryValue(CipherOldValue);
    }

    return(Status);

QuerySecretError:

    //
    // If necessary, free memory allocated for the Clear Current Value
    //

    if (ClearCurrentValue != NULL) {

        LsapCrFreeMemoryValue(ClearCurrentValue);
    }

    //
    // If necessary, free memory allocated for the Clear Old Value
    // Unicode string (buffer and structure).
    //

    if (ClearOldValue != NULL) {

        LsapCrFreeMemoryValue(ClearOldValue);
    }


    if (ARGUMENT_PRESENT(CurrentValue)) {

        *CurrentValue = NULL;
    }

    if (ARGUMENT_PRESENT(OldValue)) {

        *OldValue = NULL;
    }

    goto QuerySecretFinish;
}


NTSTATUS
LsaGetUserName(
    OUT PUNICODE_STRING * UserName,
    OUT OPTIONAL PUNICODE_STRING * DomainName
    )

/*++

Routine Description:

    This function returns the callers user name and domain name


Arguments:

    UserName - Receives a pointer to the user's name.

    DomainName - Optionally receives a pointer to the user's domain name.


Return Value:

    NTSTATUS - The privilege was found and returned.


--*/

{

    NTSTATUS Status;
    PLSAPR_UNICODE_STRING UserNameBuffer = NULL;
    PLSAPR_UNICODE_STRING DomainNameBuffer = NULL;

    RpcTryExcept {

        //
        // Call the Client Stub for LsaGetUserName
        //

        Status = LsarGetUserName(
                     NULL,
                     &UserNameBuffer,
                     ARGUMENT_PRESENT(DomainName) ? &DomainNameBuffer : NULL
                     );

        (*UserName) = (PUNICODE_STRING)UserNameBuffer;

        if (ARGUMENT_PRESENT(DomainName)) {
            (*DomainName) = (PUNICODE_STRING)DomainNameBuffer;
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the return buffer, free it.
        //

        if (UserNameBuffer != NULL) {

            MIDL_user_free(UserNameBuffer);
        }

        if (DomainNameBuffer != NULL) {

            MIDL_user_free(DomainNameBuffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    return(Status);


}


NTSTATUS
LsaGetRemoteUserName(
    IN PUNICODE_STRING SystemName,
    OUT PUNICODE_STRING * UserName,
    OUT OPTIONAL PUNICODE_STRING * DomainName
    )

/*++

Routine Description:

    This function returns the callers user name and domain name


Arguments:

    SystemName  - Name of system on which to obtain the user name.

    UserName - Receives a pointer to the user's name.

    DomainName - Optionally receives a pointer to the user's domain name.


Return Value:

    NTSTATUS - The privilege was found and returned.


--*/

{

    NTSTATUS Status;
    PLSAPR_UNICODE_STRING UserNameBuffer = NULL;
    PLSAPR_UNICODE_STRING DomainNameBuffer = NULL;
    PLSAPR_SERVER_NAME ServerName = NULL;
    USHORT NullTerminatedServerNameLength;

    if (ARGUMENT_PRESENT(SystemName) &&
        (SystemName->Buffer != NULL) &&
        (SystemName->Length > 0)) {

        NullTerminatedServerNameLength = SystemName->Length + (USHORT) sizeof (WCHAR);

        ServerName = MIDL_user_allocate( NullTerminatedServerNameLength );

        if (ServerName != NULL) {

            RtlZeroMemory( ServerName, NullTerminatedServerNameLength );

            RtlMoveMemory(
                ServerName,
                SystemName->Buffer,
                SystemName->Length
                );

        } else {

            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    RpcTryExcept {

        //
        // Call the Client Stub for LsaGetUserName
        //

        Status = LsarGetUserName(
                     ServerName,
                     &UserNameBuffer,
                     ARGUMENT_PRESENT(DomainName) ? &DomainNameBuffer : NULL
                     );

        (*UserName) = (PUNICODE_STRING)UserNameBuffer;

        if (ARGUMENT_PRESENT(DomainName)) {
            (*DomainName) = (PUNICODE_STRING)DomainNameBuffer;
        }

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        //
        // If memory was allocated for the return buffer, free it.
        //

        if (UserNameBuffer != NULL) {

            MIDL_user_free(UserNameBuffer);
        }

        if (DomainNameBuffer != NULL) {

            MIDL_user_free(DomainNameBuffer);
        }

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (ServerName != NULL) {
        MIDL_user_free(ServerName);
    }

    return(Status);


}

NTSTATUS
LsaICLookupNamesWithCreds(
    IN LPWSTR ServerName,
    IN LPWSTR ServerPrincipalName,
    IN ULONG  AuthnLevel,
    IN ULONG  AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN ULONG  AuthzSvc,
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    This routine performs a lookup with the using an LSA context handle.
    Its purpose is to facilitate lookups over NETLOGON's secure channel.
    
    N.B. The routine uses only TCP/IP as the transport.

Arguments:

    ServerName             -- the destination server, NULL terminated
    
    ServerPrincipalName, 
    AuthnLevel,
    AuthSvc,
    AuthIdentity,
    AuthzSvc               -- see RpcSetAuthInfo
    
    Rset of the parameters -- see LsaLookupNames2

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{

    NTSTATUS              Status = STATUS_SUCCESS;
    DWORD                 RpcError = 0;
    RPC_BINDING_HANDLE    BindingHandle = NULL;
    WCHAR                *StringBinding = NULL;
    LSAPR_TRANSLATED_SIDS_EX2 ReturnedSidsEx2 = { 0, NULL };

    //
    // Init to NULL since these are considered to be a IN/OUT parameters
    // for the Lsar Lookup API's
    //
    if ((ServerName == NULL)
     ||  (ReferencedDomains == NULL)
     || (Sids == NULL)
     || (MappedCount == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }
    *ReferencedDomains = NULL;
    *Sids = NULL;
    *MappedCount = 0;

    if ( 0 == wcsncmp(ServerName, L"\\\\", 2) ) {
       ServerName += 2;
    }

    RpcError = RpcStringBindingComposeW(
                           NULL,
                           L"ncacn_ip_tcp",
                           ServerName,
                           NULL,
                           NULL,
                           &StringBinding);
    
    if (RPC_S_OK == RpcError) {
    
       RpcError = RpcBindingFromStringBindingW(
                           StringBinding,
                           &BindingHandle);
    
       if ( RPC_S_OK == RpcError ) {
    
           RpcError = RpcEpResolveBinding(BindingHandle,
                                          lsarpc_ClientIfHandle);
    
           if ( RPC_S_OK == RpcError ) {
    
               RpcError = RpcBindingSetAuthInfoW(
                           BindingHandle,
                           ServerPrincipalName,
                           AuthnLevel,
                           AuthnSvc,
                           AuthIdentity,
                           AuthzSvc
                           );
           }
       }
    }
    
    if (RPC_S_OK != RpcError) {
        //
        // This is fatal
        //
        Status = I_RpcMapWin32Status(RpcError);
        goto Cleanup;
    }


    RpcTryExcept {

        ReturnedSidsEx2.Entries = 0;
        ReturnedSidsEx2.Sids = NULL;

        Status = LsarLookupNames4(
                     BindingHandle,
                     Count,
                     (PLSAPR_UNICODE_STRING) Names,
                     (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                     &ReturnedSidsEx2,
                     LookupLevel,
                     MappedCount,
                     0,            // no flags currently defined
                     LSA_LOOKUP_REVISION_LATEST
                     );

        *Sids = (PLSA_TRANSLATED_SID_EX2)ReturnedSidsEx2.Sids;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

Cleanup:

    //
    // Make the handling of this unsupported condition simpler by returning 
    // one error code
    //
    if ( (Status == RPC_NT_UNKNOWN_IF) ||
         (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ||
         (Status == EPT_NT_NOT_REGISTERED) ) {

        Status = STATUS_NOT_SUPPORTED;

    }

    if (BindingHandle) {
       RpcBindingFree(&BindingHandle);
    }
    
    if (StringBinding){
       RpcStringFreeW(&StringBinding);
    }

    return(Status);
}

NTSTATUS
LsaICLookupSidsWithCreds(
    IN LPWSTR ServerName,
    IN LPWSTR ServerPrincipalName,
    IN ULONG  AuthnLevel,
    IN ULONG  AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN ULONG  AuthzSvc,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    This routine performs a lookup with the using an LSA context handle.
    Its purpose is to facilitate lookups over NETLOGON's secure channel.
    
    N.B. The routine uses only TCP/IP as the transport.

Arguments:

    ServerName             -- the destination server, NULL terminated
    
    ServerPrincipalName, 
    AuthnLevel,
    AuthSvc,
    AuthIdentity,
    AuthzSvc               -- see RpcSetAuthInfo
    
    Rset of the parameters -- see LsaLookupSids

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/
{

    NTSTATUS              Status = STATUS_SUCCESS;
    DWORD                 RpcError = 0;
    RPC_BINDING_HANDLE    BindingHandle = NULL;
    WCHAR                *StringBinding = NULL;
    LSAPR_TRANSLATED_NAMES_EX ReturnedNames = { 0, NULL };
    LSAPR_SID_ENUM_BUFFER SidEnumBuffer;

    //
    // Init to NULL since these are considered to be a IN/OUT parameters
    // for the Lsar Lookup API's
    //
    if ((ServerName == NULL)
     || (ReferencedDomains == NULL)
     || (Names == NULL)
     || (MappedCount == NULL)
     || (Count == 0)  ) {
        return STATUS_INVALID_PARAMETER;
    }
    *ReferencedDomains = NULL;
    *Names = NULL;
    *MappedCount = 0;

    SidEnumBuffer.Entries = Count;
    SidEnumBuffer.SidInfo = (PLSAPR_SID_INFORMATION) Sids;

    if ( 0 == wcsncmp(ServerName, L"\\\\", 2) ) {
       ServerName += 2;
    }

    RpcError = RpcStringBindingComposeW(
                           NULL,
                           L"ncacn_ip_tcp",
                           ServerName,
                           NULL,
                           NULL,
                           &StringBinding);
    
    if (RPC_S_OK == RpcError) {
    
       RpcError = RpcBindingFromStringBindingW(
                           StringBinding,
                           &BindingHandle);
    
       if ( RPC_S_OK == RpcError ) {
    
           RpcError = RpcEpResolveBinding(BindingHandle,
                                          lsarpc_ClientIfHandle);
    
           if ( RPC_S_OK == RpcError ) {
    
               RpcError = RpcBindingSetAuthInfoW(
                           BindingHandle,
                           ServerPrincipalName,
                           AuthnLevel,
                           AuthnSvc,
                           AuthIdentity,
                           AuthzSvc
                           );
           }
       }
    }
    
    if (RPC_S_OK != RpcError) {
        Status = I_RpcMapWin32Status(RpcError);
        goto Cleanup;
    }


    RpcTryExcept {

        ReturnedNames.Entries = 0;
        ReturnedNames.Names = NULL;

        //
        // Lookup Sids on the Server..
        //

        Status = LsarLookupSids3(
                     BindingHandle,
                     &SidEnumBuffer,
                     (PLSAPR_REFERENCED_DOMAIN_LIST *) ReferencedDomains,
                     &ReturnedNames,
                     LookupLevel,
                     MappedCount,
                     0,
                     LSA_CLIENT_NT5
                     );

       *Names = (PLSA_TRANSLATED_NAME_EX) ReturnedNames.Names;

    } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {

        Status = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;


    //
    // Prevent against network hacks
    //
    if (NT_SUCCESS(Status)) {

        Status = LsapVerifyReturnedNames(&ReturnedNames,
                                         Count,
                                         *ReferencedDomains);

        if (!NT_SUCCESS(Status)) {
    
            if (*Names) {
                MIDL_user_free(*Names);
                *Names = NULL;
            }
    
            if ( *ReferencedDomains ) {
                MIDL_user_free( *ReferencedDomains );
                *ReferencedDomains = NULL;
            }
        }
    }

Cleanup:

    //
    // Make the handling of this unsupported condition simpler by returning 
    // one error code
    //
    if ( (Status == RPC_NT_UNKNOWN_IF) ||
         (Status == RPC_NT_PROCNUM_OUT_OF_RANGE) ||
         (Status == EPT_NT_NOT_REGISTERED) ) {

        Status = STATUS_NOT_SUPPORTED;

    }

    if (BindingHandle) {
       RpcBindingFree(&BindingHandle);
    }
    
    if (StringBinding){
       RpcStringFreeW(&StringBinding);
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\tgetsid.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tgetsid.c

Abstract:

    This file is a temporary test for querying the machine's SID.

Author:

    Jim Kelly    (JimK)  8-10-1994

Environment:

    User Mode - Win32

        to build:  nmake UMTYPE=console UMTEST=tgetsid

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#include <nt.h>
#include <ntrtl.h>
#include <ntlsa.h>
#include <stdio.h>
#include <string.h>

BOOLEAN
GetMachineSid(
    OUT PSID *Sid,
    OUT PULONG SidLength
    );

VOID __cdecl
main( VOID )

{

    BOOLEAN
        Result;

    PSID
        Sid;

    PISID
        ISid;

    ULONG
        i,
        SubCount,
        Tmp,
        SidLength;


    Result = GetMachineSid( &Sid, &SidLength );

    if (Result) {

        ISid = (PISID)Sid;  // pointer to opaque structure

        printf("S-%u-", (USHORT)ISid->Revision );
        
        if (  (ISid->IdentifierAuthority.Value[0] != 0)  ||
              (ISid->IdentifierAuthority.Value[1] != 0)     ){
            printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                        (USHORT)ISid->IdentifierAuthority.Value[0],
                        (USHORT)ISid->IdentifierAuthority.Value[1],
                        (USHORT)ISid->IdentifierAuthority.Value[2],
                        (USHORT)ISid->IdentifierAuthority.Value[3],
                        (USHORT)ISid->IdentifierAuthority.Value[4],
                        (USHORT)ISid->IdentifierAuthority.Value[5] );
        } else {
            Tmp = (ULONG)ISid->IdentifierAuthority.Value[5]          +
                  (ULONG)(ISid->IdentifierAuthority.Value[4] <<  8)  +
                  (ULONG)(ISid->IdentifierAuthority.Value[3] << 16)  +
                  (ULONG)(ISid->IdentifierAuthority.Value[2] << 24);
            printf("%lu", Tmp);
        }

        SubCount = (ULONG)(*RtlSubAuthorityCountSid( Sid ));
        for (i = 0; i<SubCount; i++) {
            printf("-0x%lx", (*RtlSubAuthoritySid( Sid, i)));
        }

    }

    printf("\n\n  Th Tha That's all folks\n");



}


BOOLEAN
GetMachineSid(
    OUT PSID *Sid,
    OUT PULONG SidLength
    )

/*++

Routine Description:

    This routine retrieves the sid of this machine's account
    domain and returns it in memory allocated with RtlAllocateHeap().
    If this machine is a server in a domain, then this SID will
    be domain's SID.


Arguments:

    Sid - receives a pointer to the returned SID.

    SidLength - Receives the length (in bytes) of the returned SID.


Return Value:

    TRUE - The SID was allocated and returned.

    FALSE - Some error prevented the SID from being returned.

--*/

{
    NTSTATUS
        Status;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    LSA_HANDLE
        PolicyHandle;

    POLICY_ACCOUNT_DOMAIN_INFO
        *DomainInfo = NULL;

    PSID
        ReturnSid;

    BOOLEAN
        ReturnStatus = FALSE;



    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,       // No name
                                0,          // No attributes
                                0,          // No root handle
                                NULL        // No SecurityDescriptor
                                );

    Status = LsaOpenPolicy( NULL,           // Local System
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle
                            );

    if (NT_SUCCESS(Status)) {

        Status = LsaQueryInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     &DomainInfo
                     );
        
        if (NT_SUCCESS(Status)) {

            ASSERT(DomainInfo != NULL);

            //
            // Allocate the return buffer
            //

            (*SidLength) = RtlLengthSid( DomainInfo->DomainSid );
            ReturnSid = RtlAllocateHeap( RtlProcessHeap(), 0, (*SidLength) );

            if (ReturnSid != NULL) {

                //
                // Copy the sid
                //

                RtlMoveMemory( ReturnSid, DomainInfo->DomainSid, (*SidLength) );
                (*Sid) = ReturnSid;
                ReturnStatus = TRUE;
            }


            LsaFreeMemory( DomainInfo );
        }

        Status = LsaClose( PolicyHandle );
        ASSERT(NT_SUCCESS(Status));
    }

    return(ReturnStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\tsecomm.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tsecomm.c

Abstract:

    Common security definitions and routines.

    This module defines macros that provide a mode-independent
    interface for security test procedures.

    The mode must be specified by defining one, but not both,
    of:
         _TST_USER_    (for user mode tests)
         _TST_KERNEL_  (for kernel mode tests)

Author:

    Jim Kelly       (JimK)     23-Mar-1990

Environment:

    Test of security.

Revision History:

--*/

#ifndef _TSECOMM_
#define _TSECOMM_


////////////////////////////////////////////////////////////////
//                                                            //
// Common Definitions                                         //
//                                                            //
////////////////////////////////////////////////////////////////

#define SEASSERT_SUCCESS(s) {                                                 \
            if (!NT_SUCCESS((s))) {                                              \
                DbgPrint("** ! Failed ! **\n");                               \
                DbgPrint("Status is: 0x%lx \n", (s));                         \
            }                                                                 \
            ASSERT(NT_SUCCESS(s)); }



////////////////////////////////////////////////////////////////
//                                                            //
// Kernel Mode Definitions                                    //
//                                                            //
////////////////////////////////////////////////////////////////

#ifdef _TST_KERNEL_

#define TstAllocatePool(PoolType,NumberOfBytes)  \
    (ExAllocatePool( (PoolType), (NumberOfBytes) ))

#define TstDeallocatePool(Pointer, NumberOfBytes) \
    (ExFreePool( (Pointer) ))

#endif // _TST_KERNEL_


////////////////////////////////////////////////////////////////
//                                                            //
// User Mode Definitions                                      //
//                                                            //
////////////////////////////////////////////////////////////////


#ifdef _TST_USER_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


// #include "sep.h"

#define TstAllocatePool(IgnoredPoolType,NumberOfBytes)    \
    (ITstAllocatePool( (NumberOfBytes) ))

#define TstDeallocatePool(Pointer, NumberOfBytes) \
    (ITstDeallocatePool((Pointer),(NumberOfBytes) ))

PVOID
ITstAllocatePool(
    IN ULONG NumberOfBytes
    )
{
    NTSTATUS Status;
    PVOID PoolAddress = NULL;
    ULONG RegionSize;

    RegionSize = NumberOfBytes;

    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      &PoolAddress,
                                      0,
                                      &RegionSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );

    return PoolAddress;
}

VOID
ITstDeallocatePool(
    IN PVOID Pointer,
    IN ULONG NumberOfBytes
    )
{
    NTSTATUS Status;
    PVOID PoolAddress;
    ULONG RegionSize;

    RegionSize = NumberOfBytes;
    PoolAddress = Pointer;

    Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                  &PoolAddress,
                                  &RegionSize,
                                  MEM_DECOMMIT
                                  );

    return;
}
#endif // _TST_USER_

#endif //_TSECOMM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\tsevars.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tsevars.c

Abstract:

    This Module contains variables used in security test routines.


Author:

    Jim Kelly       (JimK)     23-Mar-1990

Environment:

    Test.

Revision History:

--*/

#include "tsecomm.c"    // Mode dependent macros and routines.


#ifndef _TSEVARS_
#define _TSEVARS_




typedef enum _USERS {
    Fred,
    Wilma,
    Pebbles,
    Barney,
    Betty,
    Bambam,
    Dino
} USERS;


//
// Define the Bedrock domain and its inhabitants
//
//     Bedrock Domain      S-1-39824-21-3-17
//     Fred                S-1-39824-21-3-17-2
//     Wilma               S-1-39824-21-3-17-3
//     Pebbles             S-1-39824-21-3-17-4
//     Dino                S-1-39824-21-3-17-5
//     Barney              S-1-39824-21-3-17-6
//     Betty               S-1-39824-21-3-17-7
//     Bambam              S-1-39824-21-3-17-8
//     Flintstone          S-1-39824-21-3-17-9
//     Rubble              S-1-39824-21-3-17-10
//     Adult               S-1-39824-21-3-17-11
//     Child               S-1-39824-21-3-17-12
//     Neanderthol         S-1-39824-21-3-17-13
//

#define BEDROCK_AUTHORITY               {0,0,0,0,155,144}

#define BEDROCKA_AUTHORITY               {0,0,0,0,155,145}
#define BEDROCKB_AUTHORITY               {0,0,0,0,155,146}
#define BEDROCKC_AUTHORITY               {0,0,0,0,155,147}
#define BEDROCKD_AUTHORITY               {0,0,0,0,155,148}
#define BEDROCKE_AUTHORITY               {0,0,0,0,155,149}

#define BEDROCK_SUBAUTHORITY_0          0x00000015L
#define BEDROCK_SUBAUTHORITY_1          0x00000003L
#define BEDROCK_SUBAUTHORITY_2          0x00000011L

#define BEDROCKA_SUBAUTHORITY_0          0x00000015L
#define BEDROCKA_SUBAUTHORITY_1          0x00000003L
#define BEDROCKA_SUBAUTHORITY_2          0x00000111L

#define BEDROCKB_SUBAUTHORITY_0          0x00000015L
#define BEDROCKB_SUBAUTHORITY_1          0x00000003L
#define BEDROCKB_SUBAUTHORITY_2          0x00000211L

#define BEDROCKC_SUBAUTHORITY_0          0x00000015L
#define BEDROCKC_SUBAUTHORITY_1          0x00000003L
#define BEDROCKC_SUBAUTHORITY_2          0x00000311L

#define BEDROCKD_SUBAUTHORITY_0          0x00000015L
#define BEDROCKD_SUBAUTHORITY_1          0x00000003L
#define BEDROCKD_SUBAUTHORITY_2          0x00000411L

#define BEDROCKE_SUBAUTHORITY_0          0x00000015L
#define BEDROCKE_SUBAUTHORITY_1          0x00000003L
#define BEDROCKE_SUBAUTHORITY_2          0x00000511L

#define FRED_RID                        0x00000002L
#define WILMA_RID                       0x00000003L
#define PEBBLES_RID                     0x00000004L
#define DINO_RID                        0x00000005L

#define BARNEY_RID                      0x00000006L
#define BETTY_RID                       0x00000007L
#define BAMBAM_RID                      0x00000008L

#define FLINTSTONE_RID                  0x00000009L
#define RUBBLE_RID                      0x0000000AL

#define ADULT_RID                       0x0000000BL
#define CHILD_RID                       0x0000000CL

#define NEANDERTHOL_RID                 0x0000000DL


PSID BedrockDomainSid;

PSID BedrockADomainSid;
PSID BedrockBDomainSid;
PSID BedrockCDomainSid;
PSID BedrockDDomainSid;
PSID BedrockEDomainSid;

PSID  FredSid;
PSID  WilmaSid;
PSID  PebblesSid;
PSID  DinoSid;

PSID  BarneySid;
PSID  BettySid;
PSID  BambamSid;

PSID  FlintstoneSid;
PSID  RubbleSid;

PSID  AdultSid;
PSID  ChildSid;

PSID  NeandertholSid;


//
// Universal well known SIDs
//

PSID  NullSid;
PSID  WorldSid;
PSID  LocalSid;
PSID  CreatorOwnerSid;
PSID  CreatorGroupSid;

//
// Sids defined by NT
//

PSID NtAuthoritySid;

PSID DialupSid;
PSID NetworkSid;
PSID BatchSid;
PSID InteractiveSid;
PSID LocalSystemSid;





////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Define the well known privileges                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////


LUID CreateTokenPrivilege;
LUID AssignPrimaryTokenPrivilege;
LUID LockMemoryPrivilege;
LUID IncreaseQuotaPrivilege;
LUID UnsolicitedInputPrivilege;
LUID TcbPrivilege;
LUID SecurityPrivilege;

LUID TakeOwnershipPrivilege;
LUID LpcReplyBoostPrivilege;
LUID CreatePagefilePrivilege;
LUID IncreaseBasePriorityPrivilege;
LUID SystemProfilePrivilege;
LUID SystemtimePrivilege;
LUID ProfileSingleProcessPrivilege;

LUID RestorePrivilege;
LUID BackupPrivilege;
LUID CreatePermanentPrivilege;
LUID ShutdownPrivilege;
LUID DebugPrivilege;





BOOLEAN
TSeVariableInitialization()
/*++

Routine Description:

    This function initializes the global variables used in security
    tests.

Arguments:

    None.

Return Value:

    TRUE if variables successfully initialized.
    FALSE if not successfully initialized.

--*/
{
    ULONG SidWithZeroSubAuthorities;
    ULONG SidWithOneSubAuthority;
    ULONG SidWithThreeSubAuthorities;
    ULONG SidWithFourSubAuthorities;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;


    SID_IDENTIFIER_AUTHORITY BedrockAuthority = BEDROCK_AUTHORITY;

    SID_IDENTIFIER_AUTHORITY BedrockAAuthority = BEDROCKA_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY BedrockBAuthority = BEDROCKB_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY BedrockCAuthority = BEDROCKC_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY BedrockDAuthority = BEDROCKD_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY BedrockEAuthority = BEDROCKE_AUTHORITY;

    //
    //  The following SID sizes need to be allocated
    //

    SidWithZeroSubAuthorities  = RtlLengthRequiredSid( 0 );
    SidWithOneSubAuthority     = RtlLengthRequiredSid( 1 );
    SidWithThreeSubAuthorities = RtlLengthRequiredSid( 3 );
    SidWithFourSubAuthorities  = RtlLengthRequiredSid( 4 );

    //
    //  Allocate and initialize the universal SIDs
    //

    NullSid    = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);
    WorldSid   = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);
    LocalSid   = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);
    CreatorOwnerSid = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);
    CreatorGroupSid = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);

    RtlInitializeSid( NullSid,    &NullSidAuthority, 1 );
    RtlInitializeSid( WorldSid,   &WorldSidAuthority, 1 );
    RtlInitializeSid( LocalSid,   &LocalSidAuthority, 1 );
    RtlInitializeSid( CreatorOwnerSid, &CreatorSidAuthority, 1 );
    RtlInitializeSid( CreatorGroupSid, &CreatorSidAuthority, 1 );

    *(RtlSubAuthoritySid( NullSid, 0 ))    = SECURITY_NULL_RID;
    *(RtlSubAuthoritySid( WorldSid, 0 ))   = SECURITY_WORLD_RID;
    *(RtlSubAuthoritySid( LocalSid, 0 ))   = SECURITY_LOCAL_RID;
    *(RtlSubAuthoritySid( CreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;
    *(RtlSubAuthoritySid( CreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //

    NtAuthoritySid  = (PSID)TstAllocatePool(PagedPool,SidWithZeroSubAuthorities);
    DialupSid       = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);
    NetworkSid      = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);
    BatchSid        = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);
    InteractiveSid  = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);
    LocalSystemSid  = (PSID)TstAllocatePool(PagedPool,SidWithOneSubAuthority);

    RtlInitializeSid( NtAuthoritySid,   &NtAuthority, 0 );
    RtlInitializeSid( DialupSid,        &NtAuthority, 1 );
    RtlInitializeSid( NetworkSid,       &NtAuthority, 1 );
    RtlInitializeSid( BatchSid,         &NtAuthority, 1 );
    RtlInitializeSid( InteractiveSid,   &NtAuthority, 1 );
    RtlInitializeSid( LocalSystemSid,   &NtAuthority, 1 );

    *(RtlSubAuthoritySid( DialupSid,       0 )) = SECURITY_DIALUP_RID;
    *(RtlSubAuthoritySid( NetworkSid,      0 )) = SECURITY_NETWORK_RID;
    *(RtlSubAuthoritySid( BatchSid,        0 )) = SECURITY_BATCH_RID;
    *(RtlSubAuthoritySid( InteractiveSid,  0 )) = SECURITY_INTERACTIVE_RID;
    *(RtlSubAuthoritySid( LocalSystemSid,  0 )) = SECURITY_LOCAL_SYSTEM_RID;



    //
    // Allocate and initialize the Bedrock SIDs
    //

    BedrockDomainSid  = (PSID)TstAllocatePool(PagedPool,SidWithThreeSubAuthorities);
    BedrockADomainSid  = (PSID)TstAllocatePool(PagedPool,SidWithThreeSubAuthorities);
    BedrockBDomainSid  = (PSID)TstAllocatePool(PagedPool,SidWithThreeSubAuthorities);
    BedrockCDomainSid  = (PSID)TstAllocatePool(PagedPool,SidWithThreeSubAuthorities);
    BedrockDDomainSid  = (PSID)TstAllocatePool(PagedPool,SidWithThreeSubAuthorities);
    BedrockEDomainSid  = (PSID)TstAllocatePool(PagedPool,SidWithThreeSubAuthorities);

    FredSid           = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);
    WilmaSid          = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);
    PebblesSid        = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);
    DinoSid           = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);

    BarneySid         = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);
    BettySid          = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);
    BambamSid         = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);

    FlintstoneSid     = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);
    RubbleSid         = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);

    AdultSid          = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);
    ChildSid          = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);

    NeandertholSid    = (PSID)TstAllocatePool(PagedPool,SidWithFourSubAuthorities);

    RtlInitializeSid( BedrockDomainSid,   &BedrockAuthority, 3 );
    *(RtlSubAuthoritySid( BedrockDomainSid, 0)) = BEDROCK_SUBAUTHORITY_0;
    *(RtlSubAuthoritySid( BedrockDomainSid, 1)) = BEDROCK_SUBAUTHORITY_1;
    *(RtlSubAuthoritySid( BedrockDomainSid, 2)) = BEDROCK_SUBAUTHORITY_2;

    RtlInitializeSid( BedrockADomainSid,   &BedrockAAuthority, 3 );
    *(RtlSubAuthoritySid( BedrockADomainSid, 0)) = BEDROCKA_SUBAUTHORITY_0;
    *(RtlSubAuthoritySid( BedrockADomainSid, 1)) = BEDROCKA_SUBAUTHORITY_1;
    *(RtlSubAuthoritySid( BedrockADomainSid, 2)) = BEDROCKA_SUBAUTHORITY_2;


    RtlInitializeSid( BedrockBDomainSid,   &BedrockBAuthority, 3 );
    *(RtlSubAuthoritySid( BedrockBDomainSid, 0)) = BEDROCKB_SUBAUTHORITY_0;
    *(RtlSubAuthoritySid( BedrockBDomainSid, 1)) = BEDROCKB_SUBAUTHORITY_1;
    *(RtlSubAuthoritySid( BedrockBDomainSid, 2)) = BEDROCKB_SUBAUTHORITY_2;

    RtlInitializeSid( BedrockCDomainSid,   &BedrockCAuthority, 3 );
    *(RtlSubAuthoritySid( BedrockCDomainSid, 0)) = BEDROCKC_SUBAUTHORITY_0;
    *(RtlSubAuthoritySid( BedrockCDomainSid, 1)) = BEDROCKC_SUBAUTHORITY_1;
    *(RtlSubAuthoritySid( BedrockCDomainSid, 2)) = BEDROCKC_SUBAUTHORITY_2;

    RtlInitializeSid( BedrockDDomainSid,   &BedrockDAuthority, 3 );
    *(RtlSubAuthoritySid( BedrockDDomainSid, 0)) = BEDROCKD_SUBAUTHORITY_0;
    *(RtlSubAuthoritySid( BedrockDDomainSid, 1)) = BEDROCKD_SUBAUTHORITY_1;
    *(RtlSubAuthoritySid( BedrockDDomainSid, 2)) = BEDROCKD_SUBAUTHORITY_2;

    RtlInitializeSid( BedrockEDomainSid,   &BedrockEAuthority, 3 );
    *(RtlSubAuthoritySid( BedrockEDomainSid, 0)) = BEDROCKE_SUBAUTHORITY_0;
    *(RtlSubAuthoritySid( BedrockEDomainSid, 1)) = BEDROCKE_SUBAUTHORITY_1;
    *(RtlSubAuthoritySid( BedrockEDomainSid, 2)) = BEDROCKE_SUBAUTHORITY_2;

    RtlCopySid( SidWithFourSubAuthorities, FredSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( FredSid )) += 1;
    *(RtlSubAuthoritySid( FredSid, 3)) = FRED_RID;

    RtlCopySid( SidWithFourSubAuthorities, WilmaSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( WilmaSid )) += 1;
    *(RtlSubAuthoritySid( WilmaSid, 3)) = WILMA_RID;

    RtlCopySid( SidWithFourSubAuthorities, PebblesSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( PebblesSid )) += 1;
    *(RtlSubAuthoritySid( PebblesSid, 3)) = PEBBLES_RID;

    RtlCopySid( SidWithFourSubAuthorities, DinoSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( DinoSid )) += 1;
    *(RtlSubAuthoritySid( DinoSid, 3)) = DINO_RID;

    RtlCopySid( SidWithFourSubAuthorities, BarneySid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( BarneySid )) += 1;
    *(RtlSubAuthoritySid( BarneySid, 3)) = BARNEY_RID;

    RtlCopySid( SidWithFourSubAuthorities, BettySid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( BettySid )) += 1;
    *(RtlSubAuthoritySid( BettySid, 3)) = BETTY_RID;

    RtlCopySid( SidWithFourSubAuthorities, BambamSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( BambamSid )) += 1;
    *(RtlSubAuthoritySid( BambamSid, 3)) = BAMBAM_RID;

    RtlCopySid( SidWithFourSubAuthorities, FlintstoneSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( FlintstoneSid )) += 1;
    *(RtlSubAuthoritySid( FlintstoneSid, 3)) = FLINTSTONE_RID;

    RtlCopySid( SidWithFourSubAuthorities, RubbleSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( RubbleSid )) += 1;
    *(RtlSubAuthoritySid( RubbleSid, 3)) = RUBBLE_RID;

    RtlCopySid( SidWithFourSubAuthorities, AdultSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( AdultSid )) += 1;
    *(RtlSubAuthoritySid( AdultSid, 3)) = ADULT_RID;

    RtlCopySid( SidWithFourSubAuthorities, ChildSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( ChildSid )) += 1;
    *(RtlSubAuthoritySid( ChildSid, 3)) = CHILD_RID;

    RtlCopySid( SidWithFourSubAuthorities, NeandertholSid, BedrockDomainSid);
    *(RtlSubAuthorityCountSid( NeandertholSid )) += 1;
    *(RtlSubAuthoritySid( NeandertholSid, 3)) = NEANDERTHOL_RID;

    CreateTokenPrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_TOKEN_PRIVILEGE);
    AssignPrimaryTokenPrivilege =
        RtlConvertLongToLargeInteger(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE);
    LockMemoryPrivilege =
        RtlConvertLongToLargeInteger(SE_LOCK_MEMORY_PRIVILEGE);
    IncreaseQuotaPrivilege =
        RtlConvertLongToLargeInteger(SE_INCREASE_QUOTA_PRIVILEGE);
    UnsolicitedInputPrivilege =
        RtlConvertLongToLargeInteger(SE_UNSOLICITED_INPUT_PRIVILEGE);
    TcbPrivilege =
        RtlConvertLongToLargeInteger(SE_TCB_PRIVILEGE);
    SecurityPrivilege =
        RtlConvertLongToLargeInteger(SE_SECURITY_PRIVILEGE);
    TakeOwnershipPrivilege =
        RtlConvertLongToLargeInteger(SE_TAKE_OWNERSHIP_PRIVILEGE);
    LpcReplyBoostPrivilege =
        RtlConvertLongToLargeInteger(SE_LPC_REPLY_BOOST_PRIVILEGE);
    CreatePagefilePrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_PAGEFILE_PRIVILEGE);
    IncreaseBasePriorityPrivilege =
        RtlConvertLongToLargeInteger(SE_INC_BASE_PRIORITY_PRIVILEGE);
    SystemProfilePrivilege =
        RtlConvertLongToLargeInteger(SE_SYSTEM_PROFILE_PRIVILEGE);
    SystemtimePrivilege =
        RtlConvertLongToLargeInteger(SE_SYSTEMTIME_PRIVILEGE);
    ProfileSingleProcessPrivilege =
        RtlConvertLongToLargeInteger(SE_PROF_SINGLE_PROCESS_PRIVILEGE);
    CreatePermanentPrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_PERMANENT_PRIVILEGE);
    BackupPrivilege =
        RtlConvertLongToLargeInteger(SE_BACKUP_PRIVILEGE);
    RestorePrivilege =
        RtlConvertLongToLargeInteger(SE_RESTORE_PRIVILEGE);
    ShutdownPrivilege =
        RtlConvertLongToLargeInteger(SE_SHUTDOWN_PRIVILEGE);
    DebugPrivilege =
        RtlConvertLongToLargeInteger(SE_DEBUG_PRIVILEGE);


    return TRUE;

}
#endif  // _TSEVARS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\tests\crti.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    crti.c

Abstract:

    Component test for marshaling and unmarshaling target info

Author:

    Cliff Van Dyke       (CliffV)    October 14, 2000

Environment:

Revision History:

--*/


#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincred.h>
#include <security.h>
#include <secpkg.h>
#include <stdio.h>
#include <align.h>
// #include <winnetwk.h>

// #include <lmerr.h>

#define MAX_PRINTF_LEN 1024        // Arbitrary.
#define NlPrint(_x_) NlPrintRoutine _x_

VOID
NlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
{
    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    (VOID) vsprintf(OutputBuffer, Format, arglist);
    va_end(arglist);

    printf( "%s", OutputBuffer );
    return;
    UNREFERENCED_PARAMETER( DebugFlag );
}


VOID
NlpDumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to NlPrintRoutine

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    IN DWORD DebugFlag;
    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            NlPrint((0,"%02x ", BufferPtr[i]));

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            NlPrint((0,"   "));
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            NlPrint((0,"  %s\n", TextBuffer));
        }

    }

    UNREFERENCED_PARAMETER( DebugFlag );
}

LPWSTR TypeArray[] = {
    L"Generic",
    L"Password",
    L"Certificate",
    L"VisiblePassword",
    NULL
};
#define TYPE_COUNT (sizeof(TypeArray)/sizeof(TypeArray[0]))

VOID
PrintTargetInfo(
    PCREDENTIAL_TARGET_INFORMATION TargetInformation
    )
/*++

Routine Description:

    Print a Target Info

Arguments:

    TargetInfo to print

Return Value:

    None

--*/
{
    ULONG i;

    printf( "TargetInformation:\n" );
    if ( TargetInformation->TargetName != NULL ) {
        printf( "           TargetName: %ls\n", TargetInformation->TargetName );
    }
    if ( TargetInformation->NetbiosServerName != NULL ) {
        printf( "    NetbiosServerName: %ls\n", TargetInformation->NetbiosServerName );
    }
    if ( TargetInformation->DnsServerName != NULL ) {
        printf( "        DnsServerName: %ls\n", TargetInformation->DnsServerName );
    }
    if ( TargetInformation->NetbiosDomainName != NULL ) {
        printf( "    NetbiosDomainName: %ls\n", TargetInformation->NetbiosDomainName );
    }
    if ( TargetInformation->DnsDomainName != NULL ) {
        printf( "        DnsDomainName: %ls\n", TargetInformation->DnsDomainName );
    }
    if ( TargetInformation->DnsTreeName != NULL ) {
        printf( "          DnsTreeName: %ls\n", TargetInformation->DnsTreeName );
    }
    if ( TargetInformation->PackageName != NULL ) {
        printf( "          PackageName: %ls\n", TargetInformation->PackageName );
    }

    if ( TargetInformation->Flags != 0 ) {
        DWORD LocalFlags = TargetInformation->Flags;

        printf( "                Flags:" );

        if ( LocalFlags & CRED_TI_SERVER_FORMAT_UNKNOWN ) {
            printf(" ServerFormatUnknown");
            LocalFlags &= ~CRED_TI_SERVER_FORMAT_UNKNOWN;
        }
        if ( LocalFlags & CRED_TI_DOMAIN_FORMAT_UNKNOWN ) {
            printf(" DomainFormatUnknown");
            LocalFlags &= ~CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        }
        if ( LocalFlags != 0 ) {
            printf( " 0x%lx", LocalFlags );
        }
        printf( "\n" );
    }

    if ( TargetInformation->CredTypeCount != 0 ) {
        printf( "                Types:" );

        for ( i=0; i<TargetInformation->CredTypeCount; i++ ) {
            if ( TargetInformation->CredTypes[i] >= 1 && TargetInformation->CredTypes[i] <= TYPE_COUNT ) {
                printf(" %ls", TypeArray[TargetInformation->CredTypes[i]-1]);
            } else {
                printf("<Unknown>");
            }
        }
        printf( "\n" );
    }

}

int __cdecl
main ()
{
    NTSTATUS Status;

    CREDENTIAL_TARGET_INFORMATIONW Ti1;
    PCREDENTIAL_TARGET_INFORMATIONW RetTargetInfo;
    PUSHORT Buffer;
    ULONG BufferSize;
    ULONG CredTypes[] = { 1, 3, 0, 7, 2 };


    //
    // Do a trivial target info
    //

    RtlZeroMemory( &Ti1, sizeof(Ti1) );

    Ti1.TargetName = L"The name";


    printf( "\n\nInput:\n");
    PrintTargetInfo( &Ti1 );
    ?? This APi really isn't exported from secur32.dll yet.
    Status = CredMarshalTargetInfo( &Ti1, &Buffer, &BufferSize );

    if ( !NT_SUCCESS(Status) ) {
        fprintf( stderr, "Cannot convert 0x%lx\n", Status );
    } else {
        printf( "\nBinary:\n");
        NlpDumpBuffer( Buffer, BufferSize );

        Status = CredUnmarshalTargetInfo ( Buffer,
                                           BufferSize,
                                           NULL );

        if ( !NT_SUCCESS(Status) ) {
            fprintf( stderr, "Cannot check format 0x%lx\n", Status );
        } else {

            Status = CredUnmarshalTargetInfo ( Buffer,
                                               BufferSize,
                                               &RetTargetInfo );

            if ( !NT_SUCCESS(Status) ) {
                fprintf( stderr, "Cannot convert back 0x%lx\n", Status );
            } else {
                printf( "\n\nOutput:\n");
                PrintTargetInfo( RetTargetInfo );
            }
        }
    }


    //
    // More complicated
    //

    RtlZeroMemory( &Ti1, sizeof(Ti1) );

    Ti1.TargetName = L"TargetName";
    Ti1.NetbiosServerName = L"NetbiosServerName";
    Ti1.DnsServerName = L"DnsServerName";
    Ti1.NetbiosDomainName = L"NetbiosDomainName";
    Ti1.DnsDomainName = L"DnsDomainName";
    Ti1.DnsTreeName = L"DnsTreeName";
    Ti1.PackageName = L"PackageName";
    Ti1.Flags=0x12345678;
    Ti1.CredTypeCount = sizeof(CredTypes)/sizeof(DWORD);
    Ti1.CredTypes = CredTypes;


    PrintTargetInfo( &Ti1 );
    Status = CredMarshalTargetInfo( &Ti1, &Buffer, &BufferSize );

    if ( !NT_SUCCESS(Status) ) {
        fprintf( stderr, "Cannot convert 0x%lx\n", Status );
    } else {
        printf( "\nBinary:\n");
        NlpDumpBuffer( Buffer, BufferSize );

        Status = CredUnmarshalTargetInfo ( Buffer,
                                           BufferSize,
                                           NULL );

        if ( !NT_SUCCESS(Status) ) {
            fprintf( stderr, "Cannot check format 0x%lx\n", Status );
        } else {

            Status = CredUnmarshalTargetInfo ( Buffer,
                                               BufferSize,
                                               &RetTargetInfo );

            if ( !NT_SUCCESS(Status) ) {
                fprintf( stderr, "Cannot convert back 0x%lx\n", Status );
            } else {
                printf( "\n\nOutput:\n");
                PrintTargetInfo( RetTargetInfo );
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\tests\ctcred.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ctcred.c

Abstract:

    Component test for cred marshaling and unmarshaling

Author:

    Cliff Van Dyke       (CliffV)    March 22, 2000

Environment:

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincred.h>
#include <credp.h>
#include <stdio.h>
#include <winnetwk.h>

#include <lmerr.h>

int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
{
    DWORD WinStatus;
    NTSTATUS Status;
    UCHAR Buffer[1024];
    UCHAR Buffer2[1024];
    PCERT_CREDENTIAL_INFO CertCred1 = (PCERT_CREDENTIAL_INFO)Buffer;
    PCERT_CREDENTIAL_INFO CertCred2;
    PUSERNAME_TARGET_CREDENTIAL_INFO UsernameTargetCred1 = (PUSERNAME_TARGET_CREDENTIAL_INFO)Buffer;
    PUSERNAME_TARGET_CREDENTIAL_INFO UsernameTargetCred2;
    LONG Size;
    ULONG i;
    int j;
    NETRESOURCEW NetRes;

    LPWSTR MarshaledCredential;

    LPSTR argument;
    BOOLEAN TestCert = FALSE;
    BOOLEAN TestUsernameTarget = FALSE;
    BOOLEAN TestValidateTarget = FALSE;
    BOOLEAN TestNetUse = FALSE;
    BOOLEAN TestAll = TRUE;


    //
    // Loop through the arguments handle each in turn
    //

    for ( j=1; j<argc; j++ ) {

        argument = argv[j];


        //
        // Handle /Cert
        //

        if ( _stricmp( argument, "/Cert" ) == 0 ) {
            TestCert = TRUE;
            TestAll = FALSE;

        //
        // Handle /UsernameTarget
        //

        }else if ( _stricmp( argument, "/UsernameTarget" ) == 0 ) {
            TestUsernameTarget = TRUE;
            TestAll = FALSE;

        //
        // Handle /ValidateTarget
        //

        }else if ( _stricmp( argument, "/ValidateTarget" ) == 0 ) {
            TestValidateTarget = TRUE;
            TestAll = FALSE;

        //
        // Handle /NetUse
        //

        }else if ( _stricmp( argument, "/NetUse" ) == 0 ) {
            TestNetUse = TRUE;
            TestAll = FALSE;



        //
        // Handle all other parameters
        //

        } else {
//Usage:
            fprintf( stderr, "Usage: ctcred [/Cert] [/UsernameTarget] [ValidateTarget] [/NetUse]\n\n" );
            return(1);
        }
    }


    //
    // Test cert marshaling
    //

    if ( TestCert || TestAll ) {
        //
        // NULL cred should fail
        //

        if ( CredMarshalCredentialW( CertCredential,
                                     NULL,
                                     &MarshaledCredential ) ) {
            printf( "Cert: Marshal NULL cred should have failed\n" );
            return 1;
        } else if ( GetLastError() != ERROR_INVALID_PARAMETER ) {
            printf( "Cert: Marshal NULL cred failed with wrong status: %ld\n", GetLastError() );
            return 1;
        }


        //
        // Short cred should fail
        //

        RtlZeroMemory( CertCred1, sizeof(*CertCred1) );

        if ( CredMarshalCredentialW( CertCredential,
                                     CertCred1,
                                     &MarshaledCredential ) ) {
            printf( "Cert: Marshal Short cred should have failed\n" );
            return 1;
        } else if ( GetLastError() != ERROR_INVALID_PARAMETER ) {
            printf( "Cert: Marshal Short cred failed with wrong status: %ld\n", GetLastError() );
            return 1;
        }


        //
        // Loop marshalling buffers of various sizes
        //

        for ( Size=0; Size<512; Size ++ ) {
            CRED_MARSHAL_TYPE CredType;

            //
            // Build a cred to marshal
            //

            CertCred1->cbSize = sizeof(*CertCred1);

            for ( i=0; i<sizeof(CertCred1->rgbHashOfCert); i++ ) {
                CertCred1->rgbHashOfCert[i] = (BYTE)Size;
            }


            //
            // Marshal it.
            //

            if ( !CredMarshalCredentialW( CertCredential,
                                          CertCred1,
                                          &MarshaledCredential ) ) {
                printf( "Cert: Cannot marshal cred: %ld %ld\n", Size, GetLastError() );
                return 1;
            }

            printf( "Cert: %ld: %ws\n", Size, MarshaledCredential );

            //
            // Ensure it is a marshaled cred
            //

            if ( !CredIsMarshaledCredentialW( MarshaledCredential ) ) {
                printf( "Cert: Cred isn't marshaled: %ld\n", Size );
                return 1;
            }

            //
            // Unmarshal it
            //

            CredType = (CRED_MARSHAL_TYPE) 87;
            if ( !CredUnmarshalCredentialW( MarshaledCredential,
                                            &CredType,
                                            &CertCred2 ) ) {
                printf( "Cert: Cannot unmarshal cred: %ld %ld\n", Size, GetLastError() );
                return 1;
            }

            //
            // Verify it
            //

            if ( CredType != CertCredential ) {
                printf( "Cert: Bad CredType: %ld\n", Size );
                return 1;
            }

            if ( !RtlEqualMemory( CertCred1, CertCred2, sizeof(*CertCred1) - 3 * sizeof(ULONG) ) ) {
                printf( "Cert: Bad Cred structure: %ld\n", Size );
                return 1;
            }

            if ( TestNetUse || TestAll ) {
                NetRes.dwType = RESOURCETYPE_ANY;
                NetRes.lpLocalName = NULL;
                NetRes.lpRemoteName = L"\\\\CLIFFV1\\d$";
                NetRes.lpProvider = NULL;

                WinStatus = WNetAddConnection2W( &NetRes,
                                                 L"",   // no password
                                                 MarshaledCredential,
                                                 0 );

                if ( WinStatus != NO_ERROR ) {
                    printf( "Cert: Cannot connect: %ld %ld\n", Size, WinStatus );
                }
            }


            CredFree( CertCred2 );
            CredFree( MarshaledCredential );
        }
    }


    //
    // Test UsernameTarget marshaling
    //

    if ( TestUsernameTarget || TestAll ) {
        //
        // NULL cred should fail
        //

        if ( CredMarshalCredentialW( UsernameTargetCredential,
                                     NULL,
                                     &MarshaledCredential ) ) {
            printf( "UsernameTarget: Marshal NULL cred should have failed\n" );
            return 1;
        } else if ( GetLastError() != ERROR_INVALID_PARAMETER ) {
            printf( "UsernameTarget: Marshal NULL cred failed with wrong status: %ld\n", GetLastError() );
            return 1;
        }


        //
        // Empty cred should fail
        //

        RtlZeroMemory( UsernameTargetCred1, sizeof(*UsernameTargetCred1) );

        if ( CredMarshalCredentialW( UsernameTargetCredential,
                                     UsernameTargetCred1,
                                     &MarshaledCredential ) ) {
            printf( "UsernameTarget: Marshal Short cred should have failed\n" );
            return 1;
        } else if ( GetLastError() != ERROR_INVALID_PARAMETER ) {
            printf( "UsernameTarget: Marshal Short cred failed with wrong status: %ld\n", GetLastError() );
            return 1;
        }

        //
        // Loop marshalling buffers of various sizes
        //

        for ( Size=-3; Size<255; Size ++ ) {
            CRED_MARSHAL_TYPE CredType;

            //
            // Build a cred to marshal
            //

            UsernameTargetCred1->UserName = (LPWSTR)Buffer2;

            if ( Size == -3 ) {
                wcscpy( UsernameTargetCred1->UserName, L"a" );
            } else if ( Size == -2 ) {
                wcscpy( UsernameTargetCred1->UserName, L"ntdev\\cliffv" );
            } else if ( Size == -1 ) {
                wcscpy( UsernameTargetCred1->UserName, L"cliffv@ms.com" );
            } else {
                for ( i=0; i<Size*sizeof(WCHAR); i++ ) {
                    Buffer2[i] = (BYTE)Size;
                }
                Buffer2[i*sizeof(WCHAR)] = 0;
                Buffer2[i*sizeof(WCHAR)+1] = 0;
            }



            //
            // Marshal it.
            //

            if ( !CredMarshalCredentialW( UsernameTargetCredential,
                                          UsernameTargetCred1,
                                          &MarshaledCredential ) ) {
                WinStatus = GetLastError();
                if ( Size == 0 && WinStatus == ERROR_INVALID_PARAMETER ) {
                    // This is OK
                    continue;
                } else {
                    printf( "UsernameTarget: Cannot marshal cred: %ld %ld\n", Size, WinStatus );
                    return 1;
                }
            } else {
                if ( Size == 0 ) {
                    printf( "UsernameTarget: Marshal empty cred should have failed\n" );
                    return 1;
                }
            }

            if ( Size < 0 ) {
                printf( "UsernameTarget: %ld: %ws: %ws\n", Size, Buffer2, MarshaledCredential );
            } else {
                printf( "UsernameTarget: %ld: %ws\n", Size, MarshaledCredential );
            }

            //
            // Ensure it is a marshaled cred
            //

            if ( !CredIsMarshaledCredentialW( MarshaledCredential ) ) {
                printf( "UsernameTarget: Cred isn't marshaled: %ld\n", Size );
                return 1;
            }

            //
            // Unmarshal it
            //

            CredType = (CRED_MARSHAL_TYPE) 87;
            if ( !CredUnmarshalCredentialW( MarshaledCredential,
                                            &CredType,
                                            &UsernameTargetCred2 ) ) {
                printf( "UsernameTarget: Cannot unmarshal cred: %ld %ld\n", Size, GetLastError() );
                return 1;
            }

            //
            // Verify it
            //

            if ( CredType != UsernameTargetCredential ) {
                printf( "UsernameTarget: Bad CredType: %ld\n", Size );
                return 1;
            }

            if ( Size < 0 ) {

                if ( wcscmp( UsernameTargetCred1->UserName, UsernameTargetCred2->UserName ) != 0 ) {
                    printf( "UsernameTarget: %ws: Bad Cred structure: %ld\n", UsernameTargetCred1->UserName, Size );
                    return 1;
                }

            } else {

                if ( !RtlEqualMemory( UsernameTargetCred1->UserName, UsernameTargetCred2->UserName, Size*sizeof(WCHAR) ) ) {
                    printf( "UsernameTarget: Bad Cred structure: %ld\n", Size );
                    return 1;
                }
            }

            //
            // Connect using the credential
            //

            if ( TestNetUse || TestAll ) {
                NetRes.dwType = RESOURCETYPE_ANY;
                NetRes.lpLocalName = NULL;
                NetRes.lpRemoteName = L"\\\\CLIFFV1\\d$";
                NetRes.lpProvider = NULL;

                WinStatus = WNetAddConnection2W( &NetRes,
                                                 L"",   // no password
                                                 MarshaledCredential,
                                                 0 );

                if ( WinStatus != NO_ERROR ) {
                    printf( "UsernameTarget: Cannot connect: %ld %ld\n", Size, WinStatus );
                }
            }


            CredFree( UsernameTargetCred2 );
            CredFree( MarshaledCredential );
        }
    }


    //
    // Test ValidateTargetName
    //

    if ( TestValidateTarget || TestAll ) {

struct {
    LPWSTR TargetName;
    ULONG Type;
    TARGET_NAME_TYPE TargetNameType;
    LPWSTR UserName;
    DWORD Persist;
} ValidTests[] = {
    L"DfsRoot\\DfsShare", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"www.dfsroot.com\\DfsShare", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"www.dfsroot.com.\\DfsShare", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"www.ms.com", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"www.ms.com.", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"products1", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"*.acme.com", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"*.acme.com.", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"redmond\\*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"redmond.\\*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"corp.ms.com\\*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"corp.ms.com.\\*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"*Session", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"*", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"cliffv@ms.com", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
    L"cliffv@ms.com.", CRED_TYPE_DOMAIN_PASSWORD, MightBeUsernameTarget, NULL, 0,
};



        for ( i=0; i<sizeof(ValidTests)/sizeof(ValidTests[0]); i++ ) {

            WCHAR TargetName[1024];
            ULONG TargetNameSize;
            WILDCARD_TYPE WildcardType;
            UNICODE_STRING NonWildcardedTargetName;

            // Copy to a buffer that can be canonicalized
            wcscpy( TargetName, ValidTests[i].TargetName );
            printf("Target %ws: ", TargetName );

            Status = CredpValidateTargetName(
                                TargetName,
                                ValidTests[i].Type,
                                ValidTests[i].TargetNameType,
                                ValidTests[i].UserName == NULL ? NULL : &ValidTests[i].UserName,
                                ValidTests[i].Persist == 0 ? NULL : &ValidTests[i].Persist,
                                &TargetNameSize,
                                &WildcardType,
                                &NonWildcardedTargetName );


            if ( !NT_SUCCESS(Status) ) {
                printf("is not valid: 0x%lx\n", Status );
            } else {
                printf("\n       %ws: ", TargetName );
                printf("(%ld) %ld %wZ\n", TargetNameSize, WildcardType, &NonWildcardedTargetName );
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\crc32new.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created

--*/

#include "crc32.h"

//
// This code comes from Dr. Dobbs Journal, May 1992
//


unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


void
Crc32(  unsigned long dwCrc,
        unsigned long cbBuffer,
        void * pvBuffer,
        unsigned long * pNewCrc)
{
    unsigned char * pbBuffer = (unsigned char *) pvBuffer;

    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ CRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    *pNewCrc = dwCrc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\cryptmgr.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        cryptmgr.c
//
// Contents:    Crypto manager
//
//
// History:     xx Dec 91   RichardW    Created
//              04 Jun 92   RichardW    NTized
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <security.h>

#include <cryptdll.h>


#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDRegisterCSystem )
#pragma alloc_text( PAGEMSG, CDBuildVect )
#pragma alloc_text( PAGEMSG, CDBuildIntegrityVect )
#pragma alloc_text( PAGEMSG, CDLocateCSystem )
#pragma alloc_text( PAGEMSG, CDFindCommonCSystem )
#pragma alloc_text( PAGEMSG, CDFindCommonCSystemWithKey )
#endif 

#define MAX_CSYSTEMS    16

CRYPTO_SYSTEM    CSystems[MAX_CSYSTEMS];
ULONG           cCSystems = 0;
ULONG           cIntegrityCSystems = 0;

// Register the crypto system

NTSTATUS NTAPI
CDRegisterCSystem(  PCRYPTO_SYSTEM   pcsNewSystem)
{
    if (cCSystems + 1 < MAX_CSYSTEMS)
    {
        CSystems[cCSystems++] = *pcsNewSystem;
        if ((pcsNewSystem->Attributes & CSYSTEM_INTEGRITY_PROTECTED) != 0)
        {
            cIntegrityCSystems++;
        }
        return(S_OK);
    }
    return(STATUS_INSUFFICIENT_RESOURCES);
}


NTSTATUS NTAPI
CDBuildVect(    ULONG *     pcCSystems,
                ULONG *     pdwEtypes)
{
    ULONG   iCS;

    *pcCSystems = cCSystems;
    if (!pdwEtypes)
    {
        return(S_OK);
    }
    for (iCS = 0; iCS < cCSystems; iCS++)
    {
        *pdwEtypes++ = CSystems[iCS].EncryptionType;
    }
    return(S_OK);
}

NTSTATUS NTAPI
CDBuildIntegrityVect(
    PULONG      pcCSystems,
    PULONG      pdwEtypes)
{
    ULONG   iCS;

    *pcCSystems = cIntegrityCSystems;
    if (!pdwEtypes)
    {
        return(S_OK);
    }
    for (iCS = 0; iCS < cCSystems; iCS++)
    {
        if ((CSystems[iCS].Attributes & CSYSTEM_INTEGRITY_PROTECTED) != 0)
        {
            *pdwEtypes++ = CSystems[iCS].EncryptionType;
        }
    }
    return(S_OK);
}

NTSTATUS NTAPI
CDLocateCSystem(ULONG           dwEtype,
                PCRYPTO_SYSTEM * ppcsSystem)
{
    ULONG   iCS = cCSystems;

    while (iCS--)
    {
        if (CSystems[iCS].EncryptionType == dwEtype)
        {
            *ppcsSystem = &CSystems[iCS];
            return(S_OK);
        }
    }
    return(SEC_E_ETYPE_NOT_SUPP);
}


NTSTATUS NTAPI
CDFindCommonCSystem(ULONG   cEntries,
                    ULONG * pdwEtypes,
                    ULONG * pdwCommonEtype)
{
    ULONG   i, j;

    *pdwCommonEtype = 0;

    for (i = 0; i < cEntries ; i++)
    {
        for (j = 0 ; j < cCSystems ; j++ )
        {
            if (pdwEtypes[i] == CSystems[j].EncryptionType)
            {
                *pdwCommonEtype = pdwEtypes[i];
                return(STATUS_SUCCESS);
            }
        }
    }

    return(SEC_E_ETYPE_NOT_SUPP);
}

NTSTATUS NTAPI
CDFindCommonCSystemWithKey(
    IN ULONG EncryptionEntries,
    IN PULONG EncryptionTypes,
    IN ULONG KeyTypeCount,
    IN PULONG KeyTypes,
    OUT PULONG CommonEtype)
{
    ULONG   i, j, k;

    *CommonEtype = 0;

    for (i = 0; i < EncryptionEntries ; i++)
    {
        for (j = 0 ; j < cCSystems ; j++ )
        {
            if (EncryptionTypes[i] == CSystems[j].EncryptionType)
            {

                //
                // Make sure we have a key for this encryption type
                //

                for (k = 0; k < KeyTypeCount ; k++ )
                {
                    if (KeyTypes[k] == EncryptionTypes[i])
                    {
                        *CommonEtype = EncryptionTypes[i];
                        return(STATUS_SUCCESS);

                    }
                }
            }
        }
    }

    return(SEC_E_ETYPE_NOT_SUPP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\uclient\tests\ssptest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ssptest.c

Abstract:

    Test program for the NtLmSsp service.

Author:

    28-Jun-1993 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#define UNICODE 1
#define SECURITY_WIN32 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>     // Needed for service controller APIs
#include <wincred.h>
#include <credp.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <stdio.h>      // printf
#include <stdlib.h>     // strtoul
#include <tstring.h>    // NetpAllocWStrFromWStr


#include <security.h>   // General definition of a Security Support Provider
#include <ntmsv1_0.h>
// #include <ntlmsspd.h>   // Common definitions between client and server
// #include <ntlmssp.h>    // External definition of the NtLmSsp service
// #include <ntlmcomn.h>

BOOLEAN QuietMode = FALSE; // Don't be verbose


VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}


VOID
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    }

    printf( "\n" );
}

//
// Entries in this list must have offsets that match the corresponding values
//  of the CRED_TYPE_* defines in wincred.h
//
LPWSTR TypeArray[] = {
    L"Generic",
    L"Password",
    L"Certificate",
    NULL
};
#define TYPE_COUNT (sizeof(TypeArray)/sizeof(TypeArray[0]))

VOID
PrintTargetInfo(
    PCREDENTIAL_TARGET_INFORMATION TargetInformation
    )
/*++

Routine Description:

    Print a Target Info

Arguments:

    TargetInfo to print

Return Value:

    None

--*/
{
    ULONG i;

    printf( "TargetInformation:\n" );
    if ( TargetInformation->TargetName != NULL ) {
        printf( "           TargetName: %ls\n", TargetInformation->TargetName );
    }
    if ( TargetInformation->NetbiosServerName != NULL ) {
        printf( "    NetbiosServerName: %ls\n", TargetInformation->NetbiosServerName );
    }
    if ( TargetInformation->DnsServerName != NULL ) {
        printf( "        DnsServerName: %ls\n", TargetInformation->DnsServerName );
    }
    if ( TargetInformation->NetbiosDomainName != NULL ) {
        printf( "    NetbiosDomainName: %ls\n", TargetInformation->NetbiosDomainName );
    }
    if ( TargetInformation->DnsDomainName != NULL ) {
        printf( "        DnsDomainName: %ls\n", TargetInformation->DnsDomainName );
    }
    if ( TargetInformation->DnsTreeName != NULL ) {
        printf( "          DnsTreeName: %ls\n", TargetInformation->DnsTreeName );
    }
    if ( TargetInformation->PackageName != NULL ) {
        printf( "          PackageName: %ls\n", TargetInformation->PackageName );
    }

    if ( TargetInformation->Flags != 0 ) {
        DWORD LocalFlags = TargetInformation->Flags;

        printf( "                Flags:" );

        if ( LocalFlags & CRED_TI_SERVER_FORMAT_UNKNOWN ) {
            printf(" ServerFormatUnknown");
            LocalFlags &= ~CRED_TI_SERVER_FORMAT_UNKNOWN;
        }
        if ( LocalFlags & CRED_TI_DOMAIN_FORMAT_UNKNOWN ) {
            printf(" DomainFormatUnknown");
            LocalFlags &= ~CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        }
        if ( LocalFlags != 0 ) {
            printf( " 0x%lx", LocalFlags );
        }
        printf( "\n" );
    }

    if ( TargetInformation->CredTypeCount != 0 ) {
        printf( "                Types:" );

        for ( i=0; i<TargetInformation->CredTypeCount; i++ ) {
            if ( TargetInformation->CredTypes[i] >= 1 && TargetInformation->CredTypes[i] <= TYPE_COUNT ) {
                printf(" %ls", TypeArray[TargetInformation->CredTypes[i]-1]);
            } else {
                printf("<Unknown>");
            }
        }
        printf( "\n" );
    }

}

VOID
TestLpcRoutine(
    LPWSTR DomainName,
    LPWSTR UserName,
    LPWSTR Password
    )
/*++

Routine Description:

    Test base LPC functionality

Arguments:

    None

Return Value:

    None

--*/
{
    SECURITY_STATUS SecStatus;
    DWORD WinStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount;
    PSecPkgInfo PackageInfo = NULL;
    HANDLE Token = NULL;
    ULONG i;
    ULONG UseValidated;

    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+UNLEN*sizeof(WCHAR)];
    PSecPkgContext_Names ContextNames = (PSecPkgContext_Names) ContextNamesBuffer;

    SecPkgContext_CredentialName ContextCredentialName;
    UCHAR ContextCredNameBuffer[sizeof(SecPkgContext_CredentialName)+1024];
    PSecPkgContext_CredentialName ContextCredNamePtr = (PSecPkgContext_CredentialName) ContextCredNameBuffer;
    SecPkgContext_CredentialNameA ContextCredentialNameA;
    PSecPkgContext_CredentialNameA ContextCredNamePtrA = (PSecPkgContext_CredentialNameA) ContextCredNameBuffer;

    SecPkgContext_TargetInformation ContextTargetInfo;
    SecPkgContext_TargetInformationA ContextTargetInfoA;

    SecBufferDesc SignMessage;
    SecBuffer SigBuffers[2];
    BYTE    bDataBuffer[20];
    BYTE    bSigBuffer[100];

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    SigBuffers[1].pvBuffer = bSigBuffer;
    SigBuffers[1].cbBuffer = sizeof(bSigBuffer);
    SigBuffers[1].BufferType = SECBUFFER_TOKEN;

    SigBuffers[0].pvBuffer = bDataBuffer;
    SigBuffers[0].cbBuffer = sizeof(bDataBuffer);
    SigBuffers[0].BufferType = SECBUFFER_DATA;
    memset(bDataBuffer,0xeb,sizeof(bDataBuffer));

    SignMessage.pBuffers = SigBuffers;
    SignMessage.cBuffers = 2;
    SignMessage.ulVersion = 0;

    //
    // Get info about the security packages.
    //

    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "EnumerateSecurityPackages failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "PackageCount: %ld\n", PackageCount );
        for ( i=0; i<PackageCount; i++ ) {
            printf( "%ld: \"%ws\" \"%ws\"\n", i, PackageInfo[i].Name, PackageInfo[i].Comment );
            printf( "   Cap: 0x%lx Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                    PackageInfo[i].fCapabilities,
                    PackageInfo[i].wVersion,
                    PackageInfo[i].wRPCID,
                    PackageInfo[i].cbMaxToken );
        }
    }

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( NTLMSP_NAME, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityPackageInfo failed:" );
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", PackageInfo->Name, PackageInfo->Comment );
        printf( "Cap: 0x%lx Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                PackageInfo->fCapabilities,
                PackageInfo->wVersion,
                PackageInfo->wRPCID,
                PackageInfo->cbMaxToken );
    }



    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: ");
        PrintStatus( SecStatus );
        return;
    }

    if ( !QuietMode ) {
        printf( "CredentialHandle1: 0x%lx 0x%lx   ",
                CredentialHandle1.dwLower, CredentialHandle1.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    //
    // Acquire a credential handle for the client side
    //


    RtlZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );
// #define DO_OEM 1
#ifndef DO_OEM
    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
    //
    // BUGBUG: memory leak here
    //

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = (LPWSTR) NetpAllocStrFromWStr(DomainName);
        AuthIdentity.DomainLength = wcslen(DomainName);
    }
    if ( UserName != NULL ) {
        AuthIdentity.User = (LPWSTR) NetpAllocStrFromWStr(UserName);
        AuthIdentity.UserLength = wcslen(UserName);
    }
    if ( Password != NULL ) {
        AuthIdentity.Password = (LPWSTR) NetpAllocStrFromWStr(Password);
        AuthIdentity.PasswordLength = wcslen(Password);
    }
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    NTLMSP_NAME,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcquireCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    if ( !QuietMode ) {
        printf( "CredentialHandle2: 0x%lx 0x%lx   ",
                CredentialHandle2.dwLower, CredentialHandle2.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }



    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        printf( "Allocate NegotiateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    L"\\\\Frank\\IPC$",  // Faked target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "InitializeSecurityContext (negotiate): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nNegotiate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
    }






    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        printf( "Allocate ChallengeMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        if ( !QuietMode || !NT_SUCCESS(SecStatus) ) {
            printf( "AcceptSecurityContext (Challenge): " );
            PrintStatus( SecStatus );
        }
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nChallenge Message:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
    }






    //
    // Get the AuthenticateMessage (ClientSide)
    //

    ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
    AuthenticateDesc.ulVersion = 0;
    AuthenticateDesc.cBuffers = 1;
    AuthenticateDesc.pBuffers = &AuthenticateBuffer;

    AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
    AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
    if ( AuthenticateBuffer.pvBuffer == NULL ) {
        printf( "Allocate AuthenticateMessage failed: 0x%ld\n", GetLastError() );
        return;
    }

    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    &ChallengeDesc,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nAuthenticate Message:\n" );

        printf( "ClientContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ClientContextHandle.dwLower, ClientContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );

        DumpBuffer( AuthenticateBuffer.pvBuffer, AuthenticateBuffer.cbBuffer );
    }

// #if 0



    //
    // Query as many attributes as possible
    //


    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_SIZES,
                    &ContextSizes );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (sizes): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QuerySizes: %ld %ld %ld %ld\n",
                    ContextSizes.cbMaxToken,
                    ContextSizes.cbMaxSignature,
                    ContextSizes.cbBlockSize,
                    ContextSizes.cbSecurityTrailer );
    }

    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (names): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );
    }

    //
    // Try getting the built in credential name
    //
    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    &ContextCredentialName );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (credentialname): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryCredentialName: %ld %ws\n",
                ContextCredentialName.CredentialType,
                ContextCredentialName.sCredentialName );
    }

    //
    // Set UseValidated
    //
    UseValidated = 5;
    SecStatus = SetContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_USE_VALIDATED,
                    &UseValidated,
                    sizeof(UseValidated) );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "SetContextAttributes (usevalidated): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "Setting use validate to %ld worked\n", UseValidated );
    }

    //
    // Set CredentialName
    //
    ContextCredNamePtr->CredentialType = 0x15;
    ContextCredNamePtr->sCredentialName = (LPWSTR)(ContextCredNamePtr+1);
    wcscpy( ContextCredNamePtr->sCredentialName, L"Frederick" );

    SecStatus = SetContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    ContextCredNamePtr,
                    sizeof(*ContextCredNamePtr) +
                        (wcslen(ContextCredNamePtr->sCredentialName) + 1) * sizeof(WCHAR) );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "SetContextAttributes (credentialname): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "Setting credentialname to %ld %ls worked\n", ContextCredNamePtr->CredentialType, ContextCredNamePtr->sCredentialName );
    }

    //
    // Try getting the credential name we just wrote
    //
    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    &ContextCredentialName );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (credentialname): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryCredentialName: %ld %ws\n",
                ContextCredentialName.CredentialType,
                ContextCredentialName.sCredentialName );
    }

    //
    // Try getting the target info
    //
    SecStatus = QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_TARGET_INFORMATION,
                    &ContextTargetInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (targetinformation): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryCredentialName:\n" );
        PrintTargetInfo( ContextTargetInfo.TargetInformation );
    }

    //
    // Set UseValidated
    //
    UseValidated = 34;
    SecStatus = SetContextAttributesA(
                    &ClientContextHandle,
                    SECPKG_ATTR_USE_VALIDATED,
                    &UseValidated,
                    sizeof(UseValidated) );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "SetContextAttributes (usevalidated ANSI): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "Setting use validate ANSI to %ld worked\n", UseValidated );
    }

    //
    // Set CredentialName
    //
    ContextCredNamePtrA->CredentialType = 0x18;
    ContextCredNamePtrA->sCredentialName = (LPSTR)(ContextCredNamePtrA+1);
    strcpy( ContextCredNamePtrA->sCredentialName, "Waldo" );

    SecStatus = SetContextAttributesA(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    ContextCredNamePtrA,
                    sizeof(*ContextCredNamePtrA) +
                        (strlen(ContextCredNamePtrA->sCredentialName) + 1) );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "SetContextAttributes (credentialname ANSI): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "Setting credentialname ANSI to %ld %s worked\n", ContextCredNamePtrA->CredentialType, ContextCredNamePtrA->sCredentialName );
    }

    //
    // Try getting the credential name we just wrote
    //
    SecStatus = QueryContextAttributesA(
                    &ClientContextHandle,
                    SECPKG_ATTR_CREDENTIAL_NAME,
                    &ContextCredentialNameA );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (credentialname ANSI): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "QueryCredentialName ANSI: %ld %s\n",
                ContextCredentialNameA.CredentialType,
                ContextCredentialNameA.sCredentialName );
    }

    //
    // Try getting the target info
    //
    SecStatus = QueryContextAttributesA(
                    &ClientContextHandle,
                    SECPKG_ATTR_TARGET_INFORMATION,
                    &ContextTargetInfoA );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QueryContextAttributes (targetinformation ANSI): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        PCREDENTIAL_TARGET_INFORMATION TargetInformation;

        WinStatus = CredpConvertTargetInfo( DoAtoW,
                                            (PCREDENTIAL_TARGET_INFORMATIONW)ContextTargetInfoA.TargetInformation,
                                            &TargetInformation,
                                            NULL );

        if ( WinStatus != NO_ERROR ) {
            printf( "QueryContextAttributes (targetinformation ANSI): cannot convert to unicode" );
            PrintStatus( WinStatus );
            return;
        }

        printf( "QueryCredentialName ANSI:\n" );
        PrintTargetInfo( TargetInformation );
    }

// #endif



    //
    // Finally authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if (STATUS_SUCCESS == QueryContextAttributes(
                    &ClientContextHandle,
                    SECPKG_ATTR_NAMES,
                    ContextNamesBuffer )) {
        printf( "QueryNames: %ws\n", ContextNames->sUserName );

    }


    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Challenge): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {
        printf( "\n\nFinal Authentication:\n" );

        printf( "ServerContextHandle: 0x%lx 0x%lx   Attributes: 0x%lx ",
                ServerContextHandle.dwLower, ServerContextHandle.dwUpper,
                ContextAttributes );
        PrintTime( "Lifetime: ", Lifetime );
        printf(" \n" );
    }


    //
    // Now make a third call to Initialize to check that RPC can
    // reauthenticate.
    //

    AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;


    SecStatus = InitializeSecurityContext(
                    NULL,
                    &ClientContextHandle,
                    L"\\\\Frank\\IPC$",     // Faked target name
                    0,
                    0,                      // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &AuthenticateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "InitializeSecurityContext (Re-Authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Now try to re-authenticate the user (ServerSide)
    //

    AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

    SecStatus = AcceptSecurityContext(
                    NULL,
                    &ServerContextHandle,
                    &AuthenticateDesc,
                    0,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    NULL,
                    &ContextAttributes,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "AcceptSecurityContext (Re-authenticate): " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Impersonate the client (ServerSide)
    //

    SecStatus = ImpersonateSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "ImpersonateSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

    SecStatus = RevertSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "RevertSecurityContext: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }


    //
    // Impersonate the client manually
    //

    SecStatus = QuerySecurityContextToken( &ServerContextHandle,&Token );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "QuerySecurityContextToken: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if (!ImpersonateLoggedOnUser(Token))
    {
        printf("Impersonate logged on user failed: %d\n",GetLastError());
        return;
    }
    //
    // Do something while impersonating (Access the token)
    //

    {
        NTSTATUS Status;
        HANDLE TokenHandle = NULL;
        WCHAR UserName[100];
        ULONG NameLength = 100;

        //
        // Open the token,
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    (BOOLEAN) TRUE, // Not really using the impersonation token
                    &TokenHandle );

        if ( !NT_SUCCESS(Status) ) {
            printf( "Access Thread token while impersonating: " );
            PrintStatus( Status );
            return;
        } else {
            (VOID) NtClose( TokenHandle );
        }
        if (!GetUserName(UserName, &NameLength))
        {
            printf("Failed to get username: %d\n",GetLastError());
            return;
        }
        else
        {
            printf("Username = %ws\n",UserName);
        }
    }


    //
    // RevertToSelf (ServerSide)
    //

    if (!RevertToSelf())
    {
        printf( "RevertToSelf failed: %d\n ",GetLastError() );
        return;
    }
    CloseHandle(Token);

    //
    // Check password expiry
    //
#ifdef notdef
    SecStatus = SspQueryPasswordExpiry(
                    &ServerContextHandle,
                    &Lifetime
                    );
    if (!NT_SUCCESS(SecStatus))
    {
        printf("Failed to query password expiry: 0x%x\n",SecStatus);
    }
    else
    {
        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields(
            &Lifetime,
            &TimeFields
            );
        printf("Password expires %d-%d-%d %d:%d:%d\n",
            TimeFields.Day,
            TimeFields.Month,
            TimeFields.Year,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second
            );
    }
#endif
    //
    // Sign a message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }


    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }



    //
    // Sign a message, this time to check if it can detect a change in the
    // message
    //

    SecStatus = MakeSignature(
                        &ClientContextHandle,
                        0,
                        &SignMessage,
                        0 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "MakeSignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    if ( !QuietMode ) {

        printf("\n Signature: \n");
        DumpBuffer(SigBuffers[1].pvBuffer,SigBuffers[1].cbBuffer);

    }

    //
    // Mess up the message to see if VerifySignature works
    //

    bDataBuffer[10] = 0xec;

    //
    // Verify the signature
    //

    SecStatus = VerifySignature(
                        &ServerContextHandle,
                        &SignMessage,
                        0,
                        0 );

    if ( SecStatus != SEC_E_MESSAGE_ALTERED ) {
        printf( "VerifySignature: " );
        PrintStatus( SecStatus );
        if ( !NT_SUCCESS(SecStatus) ) {
            return;
        }
    }

    //
    // Delete both contexts.
    //


    SecStatus = DeleteSecurityContext( &ClientContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = DeleteSecurityContext( &ServerContextHandle );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "DeleteSecurityContext failed: " );
        PrintStatus( SecStatus );
        return;
    }



    //
    // Free both credential handles
    //

    SecStatus = FreeCredentialsHandle( &CredentialHandle1 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }

    SecStatus = FreeCredentialsHandle( &CredentialHandle2 );

    if ( SecStatus != STATUS_SUCCESS ) {
        printf( "FreeCredentialsHandle failed: " );
        PrintStatus( SecStatus );
        return;
    }


    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
}



int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the NtLmSsp service

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    LPSTR argument;
    int i;
    ULONG j;
    ULONG Iterations = 0;

    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR Password = NULL;

#if DBG
    ULONG FunctionCode;
    ULONG Data;
#endif // DBG

    enum {
        NoAction,
        TestLpc,
#define TESTLPC_PARAM "/TestLpc"
#define TESTLPC2_PARAM "/TestLpc:"
    } Action = NoAction;
#define QUIET_PARAM "/Q"





    //
    // Loop through the arguments handle each in turn
    //

    for ( i=1; i<argc; i++ ) {

        argument = argv[i];


        //
        // Handle /TestLpc
        //

        if ( _stricmp( argument, TESTLPC_PARAM ) == 0 ) {
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLpc;
            Iterations = 1;

        //
        // Handle /TestLpc:
        //

        } else if ( _strnicmp( argument,
                              TESTLPC2_PARAM,
                              sizeof(TESTLPC2_PARAM)-1 ) == 0 ){
            char *end;
            if ( Action != NoAction ) {
                goto Usage;
            }

            Action = TestLpc;

            Iterations = strtoul( &argument[sizeof(TESTLPC2_PARAM)-1], &end, 10 );

            i++;
            if ( i < argc ) {
                argument = argv[i];
                DomainName = NetpAllocWStrFromStr( argument );

                i++;
                if ( i < argc ) {
                    argument = argv[i];
                    UserName = NetpAllocWStrFromStr( argument );

                    i++;
                    if ( i < argc ) {
                        argument = argv[i];
                        Password = NetpAllocWStrFromStr( argument );
                    }
                }
            }


        //
        // Handle /Quiet
        //

        } else if ( _stricmp( argument, QUIET_PARAM ) == 0 ) {
            QuietMode = TRUE;



        //
        // Handle all other parameters
        //

        } else {
Usage:
            fprintf( stderr, "Usage: ssptest [/OPTIONS]\n\n" );

            fprintf(
                stderr,
                "\n"
                "    " TESTLPC_PARAM "[:<iterations> <DomainName> <UserName> <Password>] - Test basic LPC to NtLmSsp service.\n"
                "    " QUIET_PARAM " - Don't be so verbose\n"
                "\n"
                "\n" );
            return(1);
        }
    }

    //
    // Perform the action requested
    //

    switch ( Action ) {
    case TestLpc: {
        for ( j=0; j<Iterations ; j++ ) {
            TestLpcRoutine( DomainName, UserName, Password );
        }
        break;
    }
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\crc32.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.c

Abstract:

    CRC-32 alogorithm

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created
    25-Jul-96       ChandanS    Copied from net\svcdlls\ntlmssp\client\crc32.c
    27-Jan-07       MikeSw      Incorporated x86 ASM code for performance

--*/

#ifndef KERNEL_MODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntifs.h>
#include <winerror.h>

#endif


#include <string.h>
#include <malloc.h>


#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>



#define CRC32_LEN 4


NTSTATUS
Crc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS
KerbCrc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS
Crc32Sum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS
Crc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);
NTSTATUS
KerbCrc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS
Crc32InitializeEx(  PUCHAR Key,
                    ULONG KeySize,
                    ULONG MessageType,
                    PCHECKSUM_BUFFER *pcsBuffer);
NTSTATUS
KerbCrc32InitializeEx(  PUCHAR Key,
                        ULONG KeySize,
                        ULONG MessageType,
                        PCHECKSUM_BUFFER *pcsBuffer);

NTSTATUS
Crc32Finish(PCHECKSUM_BUFFER *   ppcsBuffer);

CHECKSUM_FUNCTION csfCRC32 = {
    KERB_CHECKSUM_REAL_CRC32,
    CRC32_LEN,
    0,
    Crc32Initialize,
    Crc32Sum,
    Crc32Finalize,
    Crc32Finish,
    Crc32InitializeEx,
    NULL
};


CHECKSUM_FUNCTION csfKERB_CRC32 = {
    KERB_CHECKSUM_CRC32,
    CRC32_LEN,
    0,
    KerbCrc32Initialize,
    Crc32Sum,
    KerbCrc32Finalize,
    Crc32Finish,
    KerbCrc32InitializeEx,
    NULL
};

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, Crc32Initialize )
#pragma alloc_text( PAGEMSG, Crc32Sum )
#pragma alloc_text( PAGEMSG, Crc32Finalize )
#pragma alloc_text( PAGEMSG, Crc32Finish )
#pragma alloc_text( PAGEMSG, Crc32InitializeEx )
#pragma alloc_text( PAGEMSG, KerbCrc32Initialize )
#pragma alloc_text( PAGEMSG, KerbCrc32Finalize )
#pragma alloc_text( PAGEMSG, KerbCrc32InitializeEx )
#endif

typedef struct _CRC32_CONTEXT {
    ULONG  crc;
} CRC32_CONTEXT, *PCRC32_CONTEXT;



//
// This code comes from Dr. Dobbs Journal, May 1992
//


static unsigned long CRCTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


NTSTATUS
Crc32Sum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbBuffer,
            PUCHAR          pvBuffer )
{
    PCRC32_CONTEXT pContext = pcsBuffer;
    unsigned long dwCrc = pContext->crc;
    unsigned char * pbBuffer;

#ifdef _X86_
_asm
{
  mov     ecx, DWORD PTR cbBuffer
  shr     ecx, 2
  mov     eax, ecx
  dec     ecx
  mov     esi, DWORD PTR pvBuffer

  mov     edx, DWORD PTR dwCrc
  test    eax, eax
  je      SHORT $LABEL2
  inc     ecx
$LABEL1:
  mov     ebx, DWORD PTR [esi]
  add     esi, 4

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
  shr     ebx, 8
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  mov     eax, ebx
;  shr     ebx, 8  -- Not needed on last byte
  xor     eax, edx
  and     eax, 0FFh
  shr     edx, 8
  mov     edi, DWORD PTR CRCTable[eax*4]
  xor     edx, edi

  dec     ecx
  jne     SHORT $LABEL1
$LABEL2:
  mov     DWORD PTR dwCrc, edx
  mov     DWORD PTR pbBuffer, esi
}

    cbBuffer &= 0x3;
#else // _X86_
    pbBuffer = (unsigned char *) pvBuffer;
#endif
    while (cbBuffer-- != 0)
    {
        dwCrc = (dwCrc >> 8) ^ CRCTable[(unsigned char) dwCrc ^ *pbBuffer++];
    }
    pContext->crc= dwCrc;
    return(STATUS_SUCCESS);

}

NTSTATUS
Crc32Initialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer)
{
    PCRC32_CONTEXT pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool(NonPagedPool, sizeof(CRC32_CONTEXT));
#else
    pContext = malloc(sizeof(CRC32_CONTEXT));
#endif
    if (!pContext)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    pContext->crc = 0xffffffff;

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
    return(STATUS_SUCCESS);
}


NTSTATUS
KerbCrc32Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    PCRC32_CONTEXT pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool(NonPagedPool, sizeof(CRC32_CONTEXT));
#else
    pContext = malloc(sizeof(CRC32_CONTEXT));
#endif
    if (!pContext)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    pContext->crc = 0;

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
    return(STATUS_SUCCESS);
}


NTSTATUS
Crc32Finalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum)
{
    *(PULONG)pbSum = ((PCRC32_CONTEXT)pcsBuffer)->crc ^ 0xffffffff;
    return(STATUS_SUCCESS);
}

NTSTATUS
KerbCrc32Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum
    )
{
    *(PULONG)pbSum = ((PCRC32_CONTEXT)pcsBuffer)->crc;
    return(STATUS_SUCCESS);
}

NTSTATUS
Crc32Finish(PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS
Crc32InitializeEx(  PUCHAR Key,
                    ULONG KeySize,
                    ULONG MessageType,
                    PCHECKSUM_BUFFER *pcsBuffer)
{
    return(Crc32Initialize(0, pcsBuffer));
}

NTSTATUS
KerbCrc32InitializeEx(  PUCHAR Key,
                        ULONG KeySize,
                        ULONG MessageType,
                        PCHECKSUM_BUFFER *pcsBuffer)
{
    return(KerbCrc32Initialize(0, pcsBuffer));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\cryptdll.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        crypt.c
//
// Contents:    Root DLL file
//
//
// History:     04 Jun 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <security.h>
#include <cryptdll.h>
#include <kerbcon.h>

//#define DONT_SUPPORT_OLD_ETYPES 1

//  List Default CryptoSystems here.  If you add anything, be sure to add it
//  in the LoadCSystems() function


extern CRYPTO_SYSTEM     csRC4_HMAC;
extern CRYPTO_SYSTEM     csRC4_HMAC_EXP;
extern CRYPTO_SYSTEM     csRC4_LM;
extern CRYPTO_SYSTEM     csRC4_PLAIN;
extern CRYPTO_SYSTEM     csRC4_PLAIN_EXP;
#ifndef DONT_SUPPORT_OLD_ETYPES
extern CRYPTO_SYSTEM     csRC4_MD4;
extern CRYPTO_SYSTEM     csRC4_HMAC_OLD;
extern CRYPTO_SYSTEM     csRC4_HMAC_OLD_EXP;
extern CRYPTO_SYSTEM     csRC4_PLAIN_OLD;
extern CRYPTO_SYSTEM     csRC4_PLAIN_OLD_EXP;
#endif

extern CRYPTO_SYSTEM     csDES_MD5;
extern CRYPTO_SYSTEM     csDES_CRC32;
extern CRYPTO_SYSTEM     csDES_PLAIN;
extern CRYPTO_SYSTEM     csNULL;

extern CHECKSUM_FUNCTION csfMD4;
extern CHECKSUM_FUNCTION csfMD5;
extern CHECKSUM_FUNCTION csfCRC32;
extern CHECKSUM_FUNCTION csfKERB_CRC32;
extern CHECKSUM_FUNCTION csfSHA;
extern CHECKSUM_FUNCTION csfLM;
extern CHECKSUM_FUNCTION csfRC4_MD5;
extern CHECKSUM_FUNCTION csfDES_MAC_MD5;
extern CHECKSUM_FUNCTION csfMD5_HMAC;
extern CHECKSUM_FUNCTION csfHMAC_MD5;
extern CHECKSUM_FUNCTION csfMD25;
extern CHECKSUM_FUNCTION csfDesMac;
extern CHECKSUM_FUNCTION csfDesMacK;
extern CHECKSUM_FUNCTION csfDesMac1510;
extern CHECKSUM_FUNCTION csfDES_MAC_MD5_1510;

extern RANDOM_NUMBER_GENERATOR    DefaultRng;

SECURITY_STATUS   LoadCSystems(void);
SECURITY_STATUS   LoadCheckSums(void);
BOOLEAN              LoadRngs(void);

#ifdef WIN32_CHICAGO
BOOL Sys003Initialize (PVOID hInstance, ULONG dwReason, PVOID lpReserved);
#endif // WIN32_CHICAGO

int
LibAttach(
    HANDLE  hInstance,
    PVOID   lpReserved)
{
    SECURITY_STATUS   scRet;


    scRet = LoadCSystems();
    scRet = LoadCheckSums();
    (void) LoadRngs();

    if (scRet)
        return(0);
    else
        return(1);
}

#ifndef KERNEL_MODE
#define _DECL_DLLMAIN
#include <process.h>

BOOL WINAPI DllMain (
    HANDLE          hInstance,
    ULONG           dwReason,
    PVOID           lpReserved)
{
#ifdef WIN32_CHICAGO
    if (!Sys003Initialize ((PVOID) hInstance, dwReason, NULL ))
    {
        // Something really bad happened
        return FALSE;
    }
#endif // WIN32_CHICAGO
    if ( dwReason == DLL_PROCESS_ATTACH )
    {
    DisableThreadLibraryCalls ( hInstance );
    return LibAttach ( hInstance, lpReserved );
    }
    else
    return TRUE;

}
#endif // KERNEL_MODE

SECURITY_STATUS
LoadCSystems(void)
{
    //
    // The order here is the order of preference
    //

    CDRegisterCSystem( &csRC4_HMAC);
#ifndef DONT_SUPPORT_OLD_ETYPES
    CDRegisterCSystem( &csRC4_HMAC_OLD);
    CDRegisterCSystem( &csRC4_MD4);
#endif
    CDRegisterCSystem( &csDES_MD5);
    CDRegisterCSystem( &csDES_CRC32);
    CDRegisterCSystem( &csRC4_PLAIN);
    CDRegisterCSystem( &csRC4_PLAIN_EXP);
    CDRegisterCSystem( &csRC4_HMAC_EXP);
#ifndef DONT_SUPPORT_OLD_ETYPES
    CDRegisterCSystem( &csRC4_HMAC_OLD_EXP);
    CDRegisterCSystem( &csRC4_PLAIN_OLD);
    CDRegisterCSystem( &csRC4_PLAIN_OLD_EXP);
#endif
    CDRegisterCSystem( &csDES_PLAIN);


    return(0);

}

SECURITY_STATUS
LoadCheckSums(void)
{
    CDRegisterCheckSum( &csfMD5_HMAC );
    CDRegisterCheckSum( &csfHMAC_MD5 );
    CDRegisterCheckSum( &csfMD4);
    CDRegisterCheckSum( &csfMD5);
    CDRegisterCheckSum( &csfKERB_CRC32);
    CDRegisterCheckSum( &csfDES_MAC_MD5 );
    CDRegisterCheckSum( &csfMD25 );
    CDRegisterCheckSum( &csfDesMac );
    CDRegisterCheckSum( &csfRC4_MD5 );
    CDRegisterCheckSum( &csfCRC32);
#ifndef KERNEL_MODE
    CDRegisterCheckSum( &csfLM );
#endif
    CDRegisterCheckSum( &csfSHA );
    CDRegisterCheckSum( &csfDES_MAC_MD5_1510 );
    CDRegisterCheckSum( &csfDesMac1510 );
    CDRegisterCheckSum( &csfDesMacK );

    return(0);
}

BOOLEAN
LoadRngs(void)
{
    CDRegisterRng(&DefaultRng);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\deswrap.c ===
//+-----------------------------------------------------------------------
//
// File:        DESWRAP.C
//
// Contents:    CryptoSystem wrapper functions for DES
//
//
// History:     06-Sep-1996     MikeSw          Created
//
//------------------------------------------------------------------------

//
// Portions of this code (the key generation code) were taken from the
// MIT kerberos distribution.
//

/*
 *
 * Copyright 1989,1990 by the Massachusetts Institute of Technology.
 * All Rights Reserved.
 *
 * Export of this software from the United States of America may
 *   require a specific license from the United States Government.
 *   It is the responsibility of any person or organization contemplating
 *   export to obtain such a license before exporting.
 *
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of M.I.T. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is" without express
 * or implied warranty.
 *
 *
 * Under U.S. law, this software may not be exported outside the US
 * without license from the U.S. Commerce department.
 *
 * These routines form the library interface to the DES facilities.
 *
 * Originally written 8/85 by Steve Miller, MIT Project Athena.
 */

/* des.c - Routines for implementing the FIPS Data Encryption Standard (DES).
 *
 *         Allan Bjorklund, University of Michigan, ITD/RS/DD.
 *         July 24, 1993.
 *
 *         Revisions for PC memory model portability, July 11, 1994.
 *
 *         Removed model portability header and added Win95 DLL
 *         declarations, May 31, 1995.
 *
 *         Made all declarations Win95 and NT specific, September 18, 1995.
 *
 *         Added quad_cksum, October 9, 1995.
 *
 * Copyright (c) 1995,1996 Regents of The University of Michigan.
 * All Rights Reserved.
 *
 *     Permission to use, copy, modify, and distribute this software and
 *     its documentation for any purpose and without fee is hereby granted,
 *     provided that the above copyright notice appears in all copies and
 *     that both that copyright notice and this permission notice appear
 *     in supporting documentation, and that the name of The University
 *     of Michigan not be used in advertising or publicity pertaining to
 *     distribution of the software without specific, written prior
 *     permission. This software is supplied as is without expressed or
 *     implied warranties of any kind.
 *
 * Research Systems Unix Group
 * The University of Michigan
 * c/o Allan Bjorklund
 * 535 W. William Street
 * Ann Arbor, Michigan
 * kerb95@umich.edu
 */

#ifndef KERNEL_MODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#else 

#include <ntifs.h>
#include <winerror.h>

#endif

#include <string.h>
#include <malloc.h>
#include <align.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>
#ifdef WIN32_CHICAGO
#include <assert.h>
#undef ASSERT
#define ASSERT(x) assert(x)
VOID MyRtlFreeOemString( POEM_STRING OemString );
#define RtlFreeOemString(x) MyRtlFreeOemString(x)
NTSTATUS MyRtlUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );
#define RtlUnicodeStringToOemString(x, y, z) MyRtlUnicodeStringToOemString(x, y, z)
#endif // WIN32_CHICAGO

#include "modes.h"
#include "des.h"
#include "md5.h"

BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    );

#define DES_CONFOUNDER_LEN 8

typedef struct _DES_HEADER {
    UCHAR Confounder[DES_CONFOUNDER_LEN];
    UCHAR Checksum[MD5_LEN];
} DES_HEADER, *PDES_HEADER;



typedef struct _DES_STATE_BUFFER {
    PCHECKSUM_FUNCTION ChecksumFunction;
    DESTable KeyTable;
    UCHAR InitializationVector[DES_BLOCKLEN];
} DES_STATE_BUFFER, *PDES_STATE_BUFFER;

typedef struct _DES_MAC_STATE_BUFFER {
    DESTable KeyTable;
    UCHAR Confounder[DES_BLOCKLEN];
    UCHAR InitializationVector[DES_BLOCKLEN];
} DES_MAC_STATE_BUFFER, *PDES_MAC_STATE_BUFFER;

typedef struct _DES_MAC_1510_STATE_BUFFER {
    DESTable KeyTable;
    UCHAR InitializationVector[DES_BLOCKLEN];
    UCHAR Confounder[DES_BLOCKLEN];
    DESTable FinalKeyTable;
} DES_MAC_1510_STATE_BUFFER, *PDES_MAC_1510_STATE_BUFFER;

NTSTATUS NTAPI desPlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desPlainExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desMd5Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desMd5ExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desCrc32Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desHashPassword(PSECURITY_STRING, PUCHAR);
NTSTATUS NTAPI desInitRandom(ULONG);
NTSTATUS NTAPI desRandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI desFinishRandom(void);
NTSTATUS NTAPI desControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);

NTSTATUS NTAPI desMacGeneralInitializeEx(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMacKInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI desMac1510Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510InitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510InitializeEx2(PUCHAR,ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMac1510Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI desMacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacFinish(PCHECKSUM_BUFFER *);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, desPlainInitialize )
#pragma alloc_text( PAGEMSG, desPlainExpInitialize )
#pragma alloc_text( PAGEMSG, desMd5Initialize )
#pragma alloc_text( PAGEMSG, desMd5ExpInitialize )
#pragma alloc_text( PAGEMSG, desCrc32Initialize )
#pragma alloc_text( PAGEMSG, desEncrypt )
#pragma alloc_text( PAGEMSG, desDecrypt )
#pragma alloc_text( PAGEMSG, desFinish )
#pragma alloc_text( PAGEMSG, desHashPassword )
#pragma alloc_text( PAGEMSG, desInitRandom )
#pragma alloc_text( PAGEMSG, desRandomKey )
#pragma alloc_text( PAGEMSG, desFinishRandom )
#pragma alloc_text( PAGEMSG, desControl )
#pragma alloc_text( PAGEMSG, desMacInitialize )
#pragma alloc_text( PAGEMSG, desMacInitializeEx )
#pragma alloc_text( PAGEMSG, desMacSum )
#pragma alloc_text( PAGEMSG, desMacFinalize )
#pragma alloc_text( PAGEMSG, desMacFinish )
#pragma alloc_text( PAGEMSG, desMacGeneralInitializeEx )
#pragma alloc_text( PAGEMSG, desMacKInitializeEx )
#pragma alloc_text( PAGEMSG, desMac1510Initialize )
#pragma alloc_text( PAGEMSG, desMac1510InitializeEx )
#pragma alloc_text( PAGEMSG, desMac1510InitializeEx2 )
#pragma alloc_text( PAGEMSG, desMac1510Finalize )
#endif


CRYPTO_SYSTEM    csDES_MD5 = {
    KERB_ETYPE_DES_CBC_MD5,     // Etype
    DES_BLOCKLEN,               // Blocksize
    KERB_ETYPE_DES_CBC_MD5, // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    sizeof(DES_HEADER),         // header size
    KERB_CHECKSUM_MD5,          // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME |
        CSYSTEM_INTEGRITY_PROTECTED |
        CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-CBC-MD5",    // Text name
    desMd5Initialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };


CRYPTO_SYSTEM    csDES_CRC32 = {
    KERB_ETYPE_DES_CBC_CRC,     // Etype
    DES_BLOCKLEN,               // Blocksize (stream)
    KERB_ETYPE_DES_CBC_CRC,     // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    sizeof(DES_HEADER),         // header size
    KERB_CHECKSUM_CRC32,        // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME |
        CSYSTEM_INTEGRITY_PROTECTED |
        CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-CBC-CRC",    // Text name
    desCrc32Initialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };

CRYPTO_SYSTEM    csDES_PLAIN = {
    KERB_ETYPE_DES_PLAIN,       // Etype
    DES_BLOCKLEN,               // Blocksize
    KERB_ETYPE_DES_PLAIN,       // exportable version
    DES_KEYSIZE,                // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_CRC32,        // Preferred Checksum
    CSYSTEM_USE_PRINCIPAL_NAME | CSYSTEM_EXPORT_STRENGTH, // Attributes
    L"Kerberos DES-Plain",        // Text name
    desPlainInitialize,
    desEncrypt,
    desDecrypt,
    desFinish,
    desHashPassword,
    desRandomKey,
    desControl
    };



CHECKSUM_FUNCTION    csfDesMac = {
    KERB_CHECKSUM_DES_MAC,                  // Checksum type
    DES_BLOCKLEN,                           // Checksum length
    CKSUM_KEYED,
    desMacInitialize,
    desMacSum,
    desMacFinalize,
    desMacFinish,
    desMacInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDesMacK = {
    KERB_CHECKSUM_KRB_DES_MAC_K,            // Checksum type
    DES_BLOCKLEN,                           // Checksum length
    CKSUM_KEYED,
    desMacInitialize,
    desMacSum,
    desMacFinalize,
    desMacFinish,
    desMacKInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDesMac1510 = {
    KERB_CHECKSUM_KRB_DES_MAC,              // Checksum type
    DES_BLOCKLEN * 2,                       // Checksum length
    CKSUM_KEYED,
    desMac1510Initialize,
    desMacSum,
    desMac1510Finalize,
    desMacFinish,                           // just frees the buffer
    desMac1510InitializeEx,
    desMac1510InitializeEx2};


#define SMASK(step) ((1<<step)-1)
#define PSTEP(x,step) (((x)&SMASK(step))^(((x)>>step)&SMASK(step)))
#define PARITY_CHAR(x, y) \
{\
    UCHAR _tmp1_, _tmp2_; \
    _tmp1_ = (UCHAR) PSTEP((x),4); \
    _tmp2_ = (UCHAR) PSTEP(_tmp1_,2); \
    *(y) = (UCHAR) PSTEP(_tmp2_, 1); \
} \


VOID
desFixupKeyParity(
    PUCHAR Key
    )
{
    ULONG Index;
    UCHAR TempChar;
    for (Index=0; Index < DES_BLOCKLEN; Index++)
    {
        Key[Index] &= 0xfe;
        PARITY_CHAR(Key[Index], &TempChar);
        Key[Index] |= 1 ^ TempChar;
    }

}

typedef UCHAR DES_KEYBLOCK[8];

DES_KEYBLOCK desWeakKeys[] = {
    /* weak keys */
    {0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},
    {0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe},
    {0x1f,0x1f,0x1f,0x1f,0x0e,0x0e,0x0e,0x0e},
    {0xe0,0xe0,0xe0,0xe0,0xf1,0xf1,0xf1,0xf1},

    /* semi-weak */
    {0x01,0xfe,0x01,0xfe,0x01,0xfe,0x01,0xfe},
    {0xfe,0x01,0xfe,0x01,0xfe,0x01,0xfe,0x01},

    {0x1f,0xe0,0x1f,0xe0,0x0e,0xf1,0x0e,0xf1},
    {0xe0,0x1f,0xe0,0x1f,0xf1,0x0e,0xf1,0x0e},

    {0x01,0xe0,0x01,0xe0,0x01,0xf1,0x01,0xf1},
    {0xe0,0x01,0xe0,0x01,0xf1,0x01,0xf1,0x01},

    {0x1f,0xfe,0x1f,0xfe,0x0e,0xfe,0x0e,0xfe},
    {0xfe,0x1f,0xfe,0x1f,0xfe,0x0e,0xfe,0x0e},

    {0x01,0x1f,0x01,0x1f,0x01,0x0e,0x01,0x0e},
    {0x1f,0x01,0x1f,0x01,0x0e,0x01,0x0e,0x01},

    {0xe0,0xfe,0xe0,0xfe,0xf1,0xfe,0xf1,0xfe},
    {0xfe,0xe0,0xfe,0xe0,0xfe,0xf1,0xfe,0xf1}
};

/*
 * mit_des_is_weak_key: returns true iff key is a [semi-]weak des key.
 *
 * Requires: key has correct odd parity.
 */

BOOLEAN
desIsWeakKey(
    PUCHAR Key
    )
{
    ULONG Index;
    DES_KEYBLOCK * WeakKey = desWeakKeys;

    for (Index = 0; Index < sizeof(desWeakKeys)/DES_BLOCKLEN; Index++) {
        if (RtlEqualMemory(
                WeakKey++,
                Key,
                DES_BLOCKLEN
                ))
        {
            return( TRUE );
        }
    }

    return(FALSE);
}


NTSTATUS NTAPI
desInitialize(  PUCHAR          pbKey,
                ULONG           KeySize,
                ULONG           MessageType,
                ULONG           Checksum,
                PCRYPT_STATE_BUFFER *  psbBuffer)
{
    NTSTATUS Status;
    UCHAR LocalKey[DES_KEYSIZE];
    PDES_STATE_BUFFER DesKey = NULL;
    PCHECKSUM_FUNCTION ChecksumFunction = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    RtlCopyMemory(
        LocalKey,
        pbKey,
        KeySize
        );

    //
    // Get the appropriate checksum here.
    //

    if (Checksum != 0)
    {
        Status = CDLocateCheckSum(
                    Checksum,
                    &ChecksumFunction
                    );
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }

    }
    else
    {
        ChecksumFunction = NULL;
    }

    //
    // Create the key buffer
    //


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool (NonPagedPool, sizeof(DES_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }



    deskey(&DesKey->KeyTable, LocalKey);


    //
    // Initialize the checksum function
    //

    DesKey->ChecksumFunction = ChecksumFunction;

    //
    // DES-CBC-CRC uses the key as the ivec, MD5 and MD4 user zero
    //

    if (Checksum == KERB_CHECKSUM_CRC32)
    {
        RtlCopyMemory(
            DesKey->InitializationVector,
            LocalKey,
            DES_BLOCKLEN
            );
    }
    else
    {
        RtlZeroMemory(
            DesKey->InitializationVector,
            DES_BLOCKLEN
            );

    }


    *psbBuffer = (PCRYPT_STATE_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}

#if DBG
void
DumpBuf(
    IN PUCHAR Buf,
    IN ULONG BufSize
    )
{
    ULONG Index;
    for (Index = 0; Index < BufSize ;Index++ )
    {
        DbgPrint("%0.2x ",Buf[Index]);
    }
}

#endif

NTSTATUS NTAPI
desMd5Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_MD5,
                psbBuffer
                ));
}



NTSTATUS NTAPI
desCrc32Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_CRC32,
                psbBuffer
                ));
}

NTSTATUS NTAPI
desPlainInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(desInitialize(
                pbKey,
                KeySize,
                MessageType,
                0,              // no checksum
                psbBuffer
                ));
}




//+-------------------------------------------------------------------------
//
//  Function:   BlockDecrypt
//
//  Synopsis:   Encrypts a data buffer using DES
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      stolen from windows\base\ntcyrpto\scp\nt_crypt.c
//
//
//--------------------------------------------------------------------------



NTSTATUS
BlockEncrypt(
    IN PDES_STATE_BUFFER pKey,
    IN PUCHAR  pbData,
    OUT PULONG pdwDataLen,
    IN ULONG dwBufLen
    )
{
    ULONG   cbPartial, dwPadVal, dwDataLen;
    UCHAR    pbBuf[DES_BLOCKLEN];
    UCHAR   FeedBack[DES_BLOCKLEN];

    dwDataLen = *pdwDataLen;

    //
    // Initialize the feedback buffer to the initialization vector
    //

    memcpy(
        FeedBack,
        pKey->InitializationVector,
        DES_BLOCKLEN
        );

    //
    // check length of the buffer and calculate the pad
    // (if multiple of DES_BLOCKLEN, do a full block of pad)
    //

    cbPartial = (dwDataLen % DES_BLOCKLEN);

    //
    // The original code here put in 8 bytes of padding
    // on an aligned buffer. That is a waste.
    //

    if (cbPartial != 0)
    {
        dwPadVal = DES_BLOCKLEN - cbPartial;
    }
    else
    {
        dwPadVal = 0;
    }

    if (pbData == NULL || dwBufLen < dwDataLen + dwPadVal)
    {
        //
        // set what we need
        //

        *pdwDataLen = dwDataLen + dwPadVal;
        if (pbData == NULL)
        {
            return (STATUS_SUCCESS);
        }
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // allocate memory for a temporary buffer
    //


    //
    // Will this cause MIT clients/servers to flail? The caller
    // should pass in only buffers that are already padded to
    // make MIT clients work.
    //

    if (dwPadVal)
    {
        // Fill the pad with a value equal to the
        // length of the padding, so decrypt will
        // know the length of the original data
        // and as a simple integrity check.

        memset(
            pbData + dwDataLen,
            dwPadVal,
            dwPadVal
            );
    }

    dwDataLen += dwPadVal;
    *pdwDataLen = dwDataLen;

    ASSERT((dwDataLen % DES_BLOCKLEN) == 0);

    //
    // pump the full blocks of data through
    //
    while (dwDataLen)
    {
        ASSERT(dwDataLen >= DES_BLOCKLEN);

        //
        // put the plaintext into a temporary
        // buffer, then encrypt the data
        // back into the caller's buffer
        //

        memcpy(pbBuf, pbData, DES_BLOCKLEN);

        CBC(    des,
                DES_BLOCKLEN,
                pbData,
                pbBuf,
                &pKey->KeyTable,
                ENCRYPT,
                FeedBack
                );


        pbData += DES_BLOCKLEN;
        dwDataLen -= DES_BLOCKLEN;
    }
    memcpy(
        pKey->InitializationVector,
        pbData - DES_BLOCKLEN,
        DES_BLOCKLEN
        );


    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   BlockDecrypt
//
//  Synopsis:   Decrypt a block of data encrypted with BlockEncrypt
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
BlockDecrypt(
    IN PDES_STATE_BUFFER pKey,
    IN OUT PUCHAR  pbData,
    IN OUT PULONG pdwDataLen
    )
{
    UCHAR    pbBuf[DES_BLOCKLEN];
    ULONG   dwDataLen, BytePos;
    UCHAR   FeedBack[DES_BLOCKLEN];

    dwDataLen = *pdwDataLen;

    //
    // Check to see if we are decrypting something already
    //

    memcpy(
        FeedBack,
        pKey->InitializationVector,
        DES_BLOCKLEN
        );

    //
    // The data length must be a multiple of the algorithm
    // pad size.
    //
    if (dwDataLen % DES_BLOCKLEN)
    {
        return(STATUS_INVALID_PARAMETER);
    }


    //
    // pump the data through the decryption, including padding
    // NOTE: the total length is a multiple of DES_BLOCKLEN
    //

    for (BytePos = 0; (BytePos + DES_BLOCKLEN) <= dwDataLen; BytePos += DES_BLOCKLEN)
    {
        //
        // put the encrypted text into a temp buffer
        //

        memcpy (pbBuf, pbData + BytePos, DES_BLOCKLEN);


        CBC(
            des,
            DES_BLOCKLEN,
            pbData + BytePos,
            pbBuf,
            &pKey->KeyTable,
            DECRYPT,
            FeedBack
            );



    }

    memcpy(
        pKey->InitializationVector,
        pbBuf,
        DES_BLOCKLEN
        );

    return STATUS_SUCCESS;
}

NTSTATUS NTAPI
desEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR OutputBuffer,
    OUT PULONG OutputLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) psbBuffer;
    PDES_HEADER CryptHeader = (PDES_HEADER) OutputBuffer;
    PCHECKSUM_BUFFER SumBuffer = NULL;
    ULONG LocalOutputLength;

    //
    // If we aren't doing raw DES, prepare a header structure
    //

    if (StateBuffer->ChecksumFunction != NULL)
    {
        //
        // Relocate the buffer and inserat the header
        //

        RtlMoveMemory(
            OutputBuffer + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize,
            pbInput,
            cbInput
            );
        LocalOutputLength = cbInput + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize;


        //
        // Zero fill the padding space
        //

        RtlZeroMemory(
            OutputBuffer+LocalOutputLength,
            ROUND_UP_COUNT(LocalOutputLength,DES_BLOCKLEN) - LocalOutputLength
            );

        LocalOutputLength = ROUND_UP_COUNT(LocalOutputLength,DES_BLOCKLEN);


        RtlZeroMemory(
            CryptHeader->Checksum,
            StateBuffer->ChecksumFunction->CheckSumSize
            );

        CDGenerateRandomBits(
            CryptHeader->Confounder,
            DES_CONFOUNDER_LEN
            );


        //
        // Checksum the buffer.
        //

        Status = StateBuffer->ChecksumFunction->Initialize(0, &SumBuffer);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        StateBuffer->ChecksumFunction->Sum(
            SumBuffer,
            LocalOutputLength,
            OutputBuffer
            );
        StateBuffer->ChecksumFunction->Finalize(
            SumBuffer,
            CryptHeader->Checksum
            );
        StateBuffer->ChecksumFunction->Finish(
            &SumBuffer
            );

    }
    else
    {
        //
        // Just copy the buffer
        //

        RtlCopyMemory(
            OutputBuffer,
            pbInput,
            cbInput
            );

        LocalOutputLength = ROUND_UP_COUNT(cbInput,DES_BLOCKLEN);

        //
        // Zero fill the padding space
        //

        RtlZeroMemory(
            OutputBuffer+cbInput,
            LocalOutputLength - cbInput
            );

    }

    //
    // Encrypt the buffer.
    //


    *OutputLength = LocalOutputLength;

    Status = BlockEncrypt(
                StateBuffer,
                OutputBuffer,
                OutputLength,
                LocalOutputLength
                );


Cleanup:

    return(Status);
}

NTSTATUS NTAPI
desDecrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) psbBuffer;
    PDES_HEADER CryptHeader;
    UCHAR Checksum[MD5_LEN];
    PCHECKSUM_BUFFER SumBuffer = NULL;

    //
    // First decrypt the whole buffer
    //

    if (*cbOutput < cbInput)
    {
        *cbOutput = cbInput;
        return(STATUS_BUFFER_TOO_SMALL);

    }

    RtlCopyMemory(
        pbOutput,
        pbInput,
        cbInput
        );
    Status = BlockDecrypt(
                StateBuffer,
                pbOutput,
                &cbInput
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (StateBuffer->ChecksumFunction != NULL)
    {
        //
        // Now verify the checksum
        //

        CryptHeader = (PDES_HEADER) pbOutput;
        RtlCopyMemory(
            Checksum,
            CryptHeader->Checksum,
            MD5_LEN
            );

        //
        // Zero the checksum field before computing the checksum of the buffer
        //

        RtlZeroMemory(
            CryptHeader->Checksum,
            StateBuffer->ChecksumFunction->CheckSumSize
            );

        //
        // Checksum the buffer.
        //

        Status = StateBuffer->ChecksumFunction->Initialize(0, &SumBuffer);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        StateBuffer->ChecksumFunction->Sum(
            SumBuffer,
            cbInput,
            pbOutput
            );
        StateBuffer->ChecksumFunction->Finalize(
            SumBuffer,
            CryptHeader->Checksum
            );
        StateBuffer->ChecksumFunction->Finish(
            &SumBuffer
            );


        if (!RtlEqualMemory(
                CryptHeader->Checksum,
                Checksum,
                StateBuffer->ChecksumFunction->CheckSumSize
                ))
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }

        //
        // Copy the input to the output without the header

        *cbOutput = cbInput - (DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize);


        RtlMoveMemory(
            pbOutput,
            pbOutput + DES_CONFOUNDER_LEN + StateBuffer->ChecksumFunction->CheckSumSize,
            *cbOutput
            );

    }
    else
    {
        *cbOutput = cbInput;

    }

Cleanup:

    return(Status);
}

NTSTATUS NTAPI
desFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    PDES_STATE_BUFFER StateBuffer = (PDES_STATE_BUFFER) *psbBuffer;


#ifdef KERNEL_MODE
    ExFreePool(StateBuffer);
#else
    LocalFree(StateBuffer);
#endif
    *psbBuffer = NULL;
    return(S_OK);
}

#define MIN(x,y) (((x) < (y)) ? (x) : (y))

#define XORBLOCK(x,y) \
{ \
    PULONG tx = (PULONG) x; \
    PULONG ty = (PULONG) y; \
    *tx++ ^= *ty++; \
    *tx++ ^= *ty++; \
}

VOID
desCbcChecksum(
    IN PUCHAR Password,
    IN ULONG PasswordLength,
    IN PUCHAR InitialVector,
    IN DESTable * KeyTable,
    OUT PUCHAR OutputKey
    )
{
    ULONG Offset;
    UCHAR Feedback[DES_BLOCKLEN];
    UCHAR Block[DES_BLOCKLEN];

    RtlCopyMemory(
        Feedback,
        InitialVector,
        DES_BLOCKLEN
        );

    for (Offset = 0; Offset < PasswordLength ; Offset+= 8 )
    {
        RtlZeroMemory(
            Block,
            DES_BLOCKLEN
            );

        RtlCopyMemory(
            Block,
            Password+Offset,
            MIN(DES_BLOCKLEN, PasswordLength - Offset)
            );

        XORBLOCK(Block, Feedback);
        des(
            Feedback,
            Block,
            KeyTable,
            ENCRYPT
            );


    }
    RtlCopyMemory(
        OutputKey,
        Feedback,
        DES_BLOCKLEN
        );

}

#define BITREVERSE(c)   ((UCHAR)((((c & 0x01) ? 0x80 : 0x00)\
                                |((c & 0x02) ? 0x40 : 0x00)\
                                |((c & 0x04) ? 0x20 : 0x00)\
                                |((c & 0x08) ? 0x10 : 0x00)\
                                |((c & 0x10) ? 0x08 : 0x00)\
                                |((c & 0x20) ? 0x04 : 0x00)\
                                |((c & 0x40) ? 0x02 : 0x00))\
                                & 0xFE))

//
// This is the core routine that converts a buffer into a key. It is called
// by desHashPassword and desRandomKey
//

VOID
desHashBuffer(
    IN PUCHAR LocalPassword,
    IN ULONG PasswordLength,
    IN OUT PUCHAR Key
    )
{
    ULONG Index;
    BOOLEAN Forward;
    PUCHAR KeyPointer = Key;
    DESTable KeyTable;

    RtlZeroMemory(
        Key,
        DES_BLOCKLEN
        );

    //
    // Initialize our temporary parity vector
    //

    //
    // Start fanfolding the bytes into the key
    //

    Forward = TRUE;
    KeyPointer = Key;
    for (Index = 0; Index < PasswordLength ; Index++ )
    {

        if (!Forward)
        {
            *(--KeyPointer) ^= BITREVERSE(LocalPassword[Index] & 0x7F);
        }
        else
        {
            *KeyPointer++  ^= (LocalPassword[Index] & 0x7F) << 1;
        }
        if (((Index+1) & 0x07) == 0)     /* When MOD 8 equals 0 */
        {
            Forward = !Forward;         /* Change direction.   */
        }

    }

    //
    // Fix key parity
    //

    desFixupKeyParity(Key);

    //
    // Check for weak keys.
    //

    if (desIsWeakKey(Key))
    {
        Key[7] ^= 0xf0;
    }

    //
    // Now calculate the des-cbc-mac of the original string
    //

    deskey(&KeyTable, Key);

    //
    // Now compute the CBC checksum of the string
    //

    desCbcChecksum(
        LocalPassword,
        PasswordLength,
        Key,                    // initial vector
        &KeyTable,
        Key                     // output key
        );

    //
    // Fix key parity
    //

    desFixupKeyParity(Key);

    //
    // Check for weak keys.
    //

    if (desIsWeakKey(Key))
    {
        Key[7] ^= 0xf0;
    }
}

NTSTATUS NTAPI
desHashPassword(
    IN PSECURITY_STRING Password,
    OUT PUCHAR Key
    )
{

    PUCHAR LocalPassword = NULL;
    ULONG PasswordLength;
    OEM_STRING OemPassword;
    NTSTATUS Status;


    //
    // First convert the UNICODE string to an OEM string
    //



    Status = RtlUnicodeStringToOemString(
                &OemPassword,
                Password,
                TRUE            // allocate destination
                );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // We hash the password according to RFC1510
    //
    // This code is derived from the MIT Kerberos code in string2key.c
    //


    PasswordLength = ROUND_UP_COUNT(OemPassword.Length,8);
#ifdef KERNEL_MODE
    LocalPassword = (PUCHAR) ExAllocatePool(NonPagedPool, PasswordLength);
#else
    LocalPassword = (PUCHAR) LocalAlloc(0, PasswordLength);
#endif
    if (LocalPassword == NULL)
    {
        RtlFreeOemString( &OemPassword );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        LocalPassword,
        OemPassword.Buffer,
        OemPassword.Length
        );

    //
    // Zero extend the password
    //

    RtlZeroMemory(
        LocalPassword + OemPassword.Length,
        PasswordLength - OemPassword.Length
        );


    //
    // Initialize our temporary parity vector
    //
    desHashBuffer(
        LocalPassword,
        PasswordLength,
        Key
        );
    RtlFreeOemString( &OemPassword );
#ifdef KERNEL_MODE
    ExFreePool(LocalPassword);
#else
    LocalFree(LocalPassword);
#endif

    return(STATUS_SUCCESS);
}




NTSTATUS NTAPI
desRandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey)
{
    UCHAR Buffer[16];
    do
    {
        CDGenerateRandomBits(Buffer,16);

        desHashBuffer(
            Buffer,
            16,
            pbKey
            );

    } while (desIsWeakKey(pbKey));
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{
    PDES_STATE_BUFFER DesStateBuffer = (PDES_STATE_BUFFER) StateBuffer;

    if (Function != CRYPT_CONTROL_SET_INIT_VECT)
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if (InputBufferSize != DES_BLOCKLEN)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    memcpy(
        DesStateBuffer->InitializationVector,
        InputBuffer,
        DES_BLOCKLEN
        );
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
desMacGeneralInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR IV,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    PDES_MAC_STATE_BUFFER DesKey = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool(NonPagedPool, sizeof(DES_MAC_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_MAC_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create the key buffer
    //


    deskey(&DesKey->KeyTable, Key);


    RtlCopyMemory(
        DesKey->InitializationVector,
        IV,
        DES_BLOCKLEN
        );

    *ppcsBuffer = (PCHECKSUM_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
desMacInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    UCHAR IV[DES_BLOCKLEN];

    RtlZeroMemory(
        IV,
        DES_BLOCKLEN
        );

    return desMacGeneralInitializeEx(
                Key,
                KeySize,
                IV,
                MessageType,
                ppcsBuffer
                );
}

NTSTATUS NTAPI
desMacKInitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return desMacGeneralInitializeEx(
                Key,
                KeySize,
                Key,
                MessageType,
                ppcsBuffer
                );
}

NTSTATUS NTAPI
desMacInitialize(ULONG               dwSeed,
                PCHECKSUM_BUFFER *   ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

//
// NOTE - This function is used with both DES_MAC_STATE_BUFFER and
// DES_MAC_1510_STATE_BUFFER as the pcsBuffer parameter, since the
// DES_MAC_1510_STATE_BUFFER is the same as DES_MAC_STATE_BUFFER
// except with an added confounder this should be OK.
//
NTSTATUS NTAPI
desMacSum(
    PCHECKSUM_BUFFER     pcsBuffer,
    ULONG                cbData,
    PUCHAR               pbData)
{
    PDES_MAC_STATE_BUFFER DesKey = (PDES_MAC_STATE_BUFFER) pcsBuffer;
    UCHAR FeedBack[DES_BLOCKLEN];
    UCHAR TempBuffer[DES_BLOCKLEN];
    UCHAR OutputBuffer[DES_BLOCKLEN];
    ULONG Index;

    //
    // Set up the IV for this round - it may be zero or the output of
    // a previous MAC
    //

    memcpy(
        FeedBack,
        DesKey->InitializationVector,
        DES_BLOCKLEN
        );

    for (Index = 0; Index < cbData ; Index += DES_BLOCKLEN )
    {
        //
        // Compute the input buffer, with padding
        //

        if (Index+DES_BLOCKLEN > cbData)
        {
            memset(
                TempBuffer,
                0,
                DES_BLOCKLEN
                );
            memcpy(
                TempBuffer,
                pbData,
                Index & (DES_BLOCKLEN-1)
                );

        }
        else
        {
            memcpy(
                TempBuffer,
                pbData+Index,
                DES_BLOCKLEN
                );
        }


        CBC(    des,
                DES_BLOCKLEN,
                TempBuffer,
                OutputBuffer,
                &DesKey->KeyTable,
                ENCRYPT,
                FeedBack
                );
    }

    //
    // Copy the feedback back into the IV for the next round
    //

    memcpy(
        DesKey->InitializationVector,
        FeedBack,
        DES_BLOCKLEN
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMacFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    PDES_MAC_STATE_BUFFER DesKey = (PDES_MAC_STATE_BUFFER) pcsBuffer;

    memcpy(pbSum, DesKey->InitializationVector, DES_BLOCKLEN);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMacFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    LocalFree(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
desMac1510Initialize(ULONG               dwSeed,
                     PCHECKSUM_BUFFER *   ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}


NTSTATUS NTAPI
desMac1510InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
desMac1510InitializeEx2(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR ChecksumToVerify,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    ULONG *pul;
    ULONG *pul2;
    UCHAR FinalKey[DES_KEYSIZE];
    PDES_MAC_1510_STATE_BUFFER DesKey = NULL;

    //
    // Make sure we were passed an appropriate keytable
    //


    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }


#ifdef KERNEL_MODE
    DesKey = ExAllocatePool(NonPagedPool, sizeof(DES_MAC_1510_STATE_BUFFER));
#else
    DesKey = LocalAlloc(0, sizeof(DES_MAC_1510_STATE_BUFFER));
#endif
    if (DesKey == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // create the final key table
    //
    pul = (ULONG*)FinalKey;
    pul2 = (ULONG*)Key;
    *pul = *pul2 ^ 0xf0f0f0f0;
    pul = (ULONG*)(FinalKey + sizeof(ULONG));
    pul2 = (ULONG*)(Key + sizeof(ULONG));
    *pul = *pul2 ^ 0xf0f0f0f0;

    deskey(&DesKey->FinalKeyTable, FinalKey);

    //
    // Checksum was not passed in so generate a confounder
    //
    if (NULL == ChecksumToVerify)
    {
        CDGenerateRandomBits(DesKey->Confounder,DES_BLOCKLEN);
    }
    else
    {
        // the IV is all zero so no need to use CBC on first block
        des(DesKey->Confounder, ChecksumToVerify, &DesKey->FinalKeyTable, DECRYPT);
    }

    //
    // Create the key buffer
    //
    deskey(&DesKey->KeyTable, Key);


    // the IV is all zero so no need to use CBC on first block, but the
    // ecncrypted confounder becomes the next IV
    des(DesKey->InitializationVector, DesKey->Confounder, &DesKey->KeyTable, ENCRYPT);

    *ppcsBuffer = (PCHECKSUM_BUFFER) DesKey;

    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
desMac1510Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    UCHAR Feedback[DES_BLOCKLEN];
    PDES_MAC_1510_STATE_BUFFER DesKey = (PDES_MAC_1510_STATE_BUFFER) pcsBuffer;

    // the IV is all zero so no need to use CBC on first block
    des(Feedback, DesKey->Confounder, &DesKey->FinalKeyTable, ENCRYPT);

    memcpy(pbSum, Feedback, DES_BLOCKLEN);

    // use CBC on second block
    CBC(    des,
            DES_BLOCKLEN,
            pbSum + DES_BLOCKLEN,
            DesKey->InitializationVector,
            &DesKey->FinalKeyTable,
            ENCRYPT,
            Feedback
            );

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\csummgr.c ===
//+-----------------------------------------------------------------------
//
// File:        CSUMMGR.c
//
// Contents:    Checksum management functions
//
//
// History:     25 Feb 92,  RichardW,   Created
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>

#define MAX_CHECK_SUMS  16

CHECKSUM_FUNCTION    CheckSumFns[MAX_CHECK_SUMS];
ULONG               cCheckSums = 0;

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDRegisterCheckSum )
#pragma alloc_text( PAGEMSG, CDLocateCheckSum )
#endif 

NTSTATUS NTAPI
CDRegisterCheckSum( PCHECKSUM_FUNCTION   pcsfSum)
{
    if (cCheckSums < MAX_CHECK_SUMS)
    {
        CheckSumFns[cCheckSums++] = *pcsfSum;
        return(S_OK);
    }
    return(STATUS_INSUFFICIENT_RESOURCES);
}

NTSTATUS NTAPI
CDLocateCheckSum(   ULONG               dwCheckSumType,
                    PCHECKSUM_FUNCTION * ppcsfSum)
{
    ULONG   iCS = cCheckSums;
    while (iCS--)
    {
        if (CheckSumFns[iCS].CheckSumType == dwCheckSumType)
        {
            *ppcsfSum = &CheckSumFns[iCS];
            return(S_OK);
        }
    }
    return(SEC_E_CHECKSUM_NOT_SUPP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\lmwrap.c ===
//
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef KERNEL_MODE
#include <ntos.h>
#endif
#include <security.h>
#include <cryptdll.h>
#include <crypt.h>
#include <kerbcon.h>
#include <lmcons.h>

#ifdef WIN32_CHICAGO
NTSTATUS
MyRtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );
#define RtlUpcaseUnicodeStringToOemString(x, y, z)  MyRtlUpcaseUnicodeStringToOemString(x, y, z)
#endif // WIN32_CHICAGO
typedef struct _LM_STATE_BUFFER {
    LM_OWF_PASSWORD Password;
} LM_STATE_BUFFER, *PLM_STATE_BUFFER;


NTSTATUS
LmWrapInitialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS
LmWrapSum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS
LmWrapFinalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS
LmWrapFinish(PCHECKSUM_BUFFER *   ppcsBuffer);



CHECKSUM_FUNCTION csfLM = {
    KERB_CHECKSUM_LM,
    LM_OWF_PASSWORD_LENGTH,
    CKSUM_COLLISION,
    LmWrapInitialize,
    LmWrapSum,
    LmWrapFinalize,
    LmWrapFinish
    // Note : missing last function
};


#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, LmWrapInitialize )
#pragma alloc_text( PAGEMSG, LmWrapSum )
#pragma alloc_text( PAGEMSG, LmWrapFinalize )
#pragma alloc_text( PAGEMSG, LmWrapFinish );
#endif 

NTSTATUS
LmWrapInitialize(
    ULONG   dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PLM_STATE_BUFFER pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( LM_STATE_BUFFER ) );
#else
    pContext = LocalAlloc( LMEM_ZEROINIT, sizeof( LM_STATE_BUFFER ) );
#endif

    if ( pContext != NULL )
    {
        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_INSUFFICIENT_RESOURCES );
}


NTSTATUS
LmCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    )

/*++

Routine Description:

    This service converts an NT password into a LM password.

Parameters:

    NtPassword - The Nt password to be converted.

    LmPasswordBuffer - On successful return, points at the LM password
                The buffer should be freed using MIDL_user_free

Return Values:

    STATUS_SUCCESS - LMPassword contains the LM version of the password.

    STATUS_NULL_LM_PASSWORD - The password is too complex to be represented
        by a LM password. The LM password returned is a NULL string.


--*/
{

#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)

    NTSTATUS       NtStatus;
    ANSI_STRING    LmPassword;

    //
    // Prepare for failure
    //

    *LmPasswordBuffer = NULL;


    //
    // Compute the Ansi version to the Unicode password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

#ifdef KERNEL_MODE
    LmPassword.Buffer = ExAllocatePool(NonPagedPool,LM_BUFFER_LENGTH);
#else
    LmPassword.Buffer = LocalAlloc(0,LM_BUFFER_LENGTH);
#endif
    if (LmPassword.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
    RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    NtStatus = RtlUpcaseUnicodeStringToOemString( &LmPassword, NtPassword, FALSE );


    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // The password is longer than the max LM password length
        //

        NtStatus = STATUS_NULL_LM_PASSWORD; // Informational return code
        RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    }




    //
    // Return a pointer to the allocated LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        *LmPasswordBuffer = LmPassword.Buffer;

    } else {

#ifdef KERNEL_MODE
        ExFreePool(LmPassword.Buffer);
#else
        LocalFree(LmPassword.Buffer);
#endif
    }

    return(NtStatus);
}

NTSTATUS
LmWrapSum(
    PCHECKSUM_BUFFER pcsBuffer,
    ULONG           cbData,
    PUCHAR          pbData )
{
    PLM_STATE_BUFFER pContext = (PLM_STATE_BUFFER) pcsBuffer;
    UNICODE_STRING TempString;
    PUCHAR LmPassword;
    NTSTATUS Status;

    TempString.Length = TempString.MaximumLength = (USHORT) cbData;
    TempString.Buffer = (LPWSTR) pbData;

    Status = LmCalculateLmPassword(
                &TempString,
                &LmPassword
                );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlCalculateLmOwfPassword(
                LmPassword,
                &pContext->Password
                );
#ifdef KERNEL_MODE
    ExFreePool(LmPassword);
#else
    LocalFree(LmPassword);
#endif

    return( Status );

}


NTSTATUS
LmWrapFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum)
{
    PLM_STATE_BUFFER pContext = (PLM_STATE_BUFFER) pcsBuffer;


    RtlCopyMemory(
        pbSum,
        &pContext->Password,
        LM_OWF_PASSWORD_LENGTH
        );

    return( STATUS_SUCCESS );

}

NTSTATUS
LmWrapFinish(
    PCHECKSUM_BUFFER *   ppcsBuffer)
{

    RtlZeroMemory( *ppcsBuffer, sizeof( PLM_STATE_BUFFER ) );

#ifdef KERNEL_MODE
    ExFreePool( *ppcsBuffer );
#else
    LocalFree( *ppcsBuffer );
#endif

    *ppcsBuffer = NULL ;

    return( STATUS_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\mdwrap.c ===
//+-----------------------------------------------------------------------
//
// File:        MDWRAP.C
//
// Contents:    MDx Wrapper functions
//
//
// History:     25 Feb 92,  RichardW    Created
//
//------------------------------------------------------------------------


#ifndef KERNEL_MODE 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntifs.h>

#endif

#include <string.h>
#include <malloc.h>



#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>
#ifdef WIN32_CHICAGO
#include <assert.h>
#undef ASSERT
#define ASSERT(exp) assert(exp)
#endif // WIN32_CHICAGO

#include "md4.h"
#include "md5.h"
#include "des.h"

typedef struct _MD5_DES_STATE_BUFFER {
    PCHECKSUM_BUFFER DesContext;
    MD5_CTX Md5Context;
} MD5_DES_STATE_BUFFER, *PMD5_DES_STATE_BUFFER;

typedef struct _MD5_DES_1510_STATE_BUFFER {
    PCHECKSUM_BUFFER DesContext;
    MD5_CTX Md5Context;
    UCHAR Confounder[DES_BLOCKLEN];
} MD5_DES_1510_STATE_BUFFER, *PMD5_DES_1510_STATE_BUFFER;

typedef struct _MD5_HMAC_STATE_BUFFER {
    MD5_CTX Md5Context;
    ULONG KeySize;
    UCHAR Key[ANYSIZE_ARRAY];
} MD5_HMAC_STATE_BUFFER, *PMD5_HMAC_STATE_BUFFER;


NTSTATUS NTAPI md4Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md4InitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md4Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md4Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md4Finish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Finish(PCHECKSUM_BUFFER *);


NTSTATUS NTAPI md25Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md25InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md25Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md25Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md25Finish(PCHECKSUM_BUFFER *);


NTSTATUS NTAPI md5DesInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5DesInitializeEx(PUCHAR, ULONG, ULONG,  PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5DesSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5DesFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5DesFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Rc4Initialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Rc4InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Rc4Sum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5Rc4Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Rc4Finish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5HmacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5HmacInitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Hmac2InitializeEx(PUCHAR, ULONG, ULONG, PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5HmacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI md5HmacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5HmacFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI md5Des1510InitializeEx(PUCHAR, ULONG, ULONG,  PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Des1510InitializeEx2(PUCHAR, ULONG, PUCHAR, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI md5Des1510Finalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI md5Des1510Finish(PCHECKSUM_BUFFER *);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, md25Initialize )
#pragma alloc_text( PAGEMSG, md25InitializeEx )
#pragma alloc_text( PAGEMSG, md25Sum )
#pragma alloc_text( PAGEMSG, md25Finalize )
#pragma alloc_text( PAGEMSG, md25Finish )
#pragma alloc_text( PAGEMSG, md5DesInitialize )
#pragma alloc_text( PAGEMSG, md5DesInitializeEx )
#pragma alloc_text( PAGEMSG, md5DesSum )
#pragma alloc_text( PAGEMSG, md5DesFinalize )
#pragma alloc_text( PAGEMSG, md5DesFinish )
#pragma alloc_text( PAGEMSG, md5Rc4Initialize )
#pragma alloc_text( PAGEMSG, md5Rc4InitializeEx )
#pragma alloc_text( PAGEMSG, md5Rc4Sum )
#pragma alloc_text( PAGEMSG, md5Rc4Finalize )
#pragma alloc_text( PAGEMSG, md5Rc4Finish )
#pragma alloc_text( PAGEMSG, md5HmacInitialize )
#pragma alloc_text( PAGEMSG, md5HmacInitializeEx )
#pragma alloc_text( PAGEMSG, md5Hmac2InitializeEx )
#pragma alloc_text( PAGEMSG, md5HmacSum )
#pragma alloc_text( PAGEMSG, md5HmacFinalize )
#pragma alloc_text( PAGEMSG, md5HmacFinish )
#pragma alloc_text( PAGEMSG, md5Des1510InitializeEx )
#pragma alloc_text( PAGEMSG, md5Des1510InitializeEx2 )
#pragma alloc_text( PAGEMSG, md5Des1510Finalize )
#pragma alloc_text( PAGEMSG, md5Des1510Finish )
#endif 


CHECKSUM_FUNCTION    csfMD4 = {
    KERB_CHECKSUM_MD4,          // Checksum type
    MD4_LEN,                    // Checksum length
    0,
    md4Initialize,
    md4Sum,
    md4Finalize,
    md4Finish,
    md4InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfMD5 = {
    KERB_CHECKSUM_MD5,          // Checksum type
    MD5_LEN,                    // Checksum length
    0,
    md5Initialize,
    md5Sum,
    md5Finalize,
    md5Finish,
    md5InitializeEx,
    NULL};

CHECKSUM_FUNCTION csfMD25 = {
    KERB_CHECKSUM_MD25,                 // Checksum type
    (MD5_LEN / 2),                      // Checksum length
    CKSUM_KEYED,
    md25Initialize,
    md25Sum,
    md25Finalize,
    md25Finish,
    md25InitializeEx};

CHECKSUM_FUNCTION    csfDES_MAC_MD5 = {
    KERB_CHECKSUM_DES_MAC_MD5,          // Checksum type
    DES_BLOCKLEN,                       // Checksum length
    CKSUM_KEYED,
    md5DesInitialize,
    md5DesSum,
    md5DesFinalize,
    md5DesFinish,
    md5DesInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfRC4_MD5 = {
    KERB_CHECKSUM_RC4_MD5,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5Rc4Initialize,
    md5Rc4Sum,
    md5Rc4Finalize,
    md5Rc4Finish,
    md5Rc4InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfMD5_HMAC = {
    KERB_CHECKSUM_MD5_HMAC,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5HmacInitialize,
    md5HmacSum,
    md5HmacFinalize,
    md5HmacFinish,
    md5HmacInitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfHMAC_MD5 = {
    KERB_CHECKSUM_HMAC_MD5,              // Checksum type
    MD5_LEN,                            // Checksum length
    CKSUM_KEYED,
    md5HmacInitialize,
    md5HmacSum,
    md5HmacFinalize,
    md5HmacFinish,
    md5Hmac2InitializeEx,
    NULL};

CHECKSUM_FUNCTION    csfDES_MAC_MD5_1510 = {
    KERB_CHECKSUM_MD5_DES,              // Checksum type
    DES_BLOCKLEN + MD5_LEN,             // Checksum length
    CKSUM_KEYED,
    md5DesInitialize,
    md5DesSum,
    md5Des1510Finalize,
    md5Des1510Finish,
    md5Des1510InitializeEx,
    md5Des1510InitializeEx2};

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
md4Initialize(  ULONG               dwSeed,
                PCHECKSUM_BUFFER *   ppcsBuffer)
{
    MD4_CTX *   pMD4Context;

#ifdef KERNEL_MODE
    pMD4Context = ExAllocatePool(NonPagedPool, sizeof(MD4_CTX));
#else
    pMD4Context = malloc(sizeof(MD4_CTX));
#endif
    if (!pMD4Context)
    {
        return(STATUS_NO_MEMORY);
    }
    MD4Init(pMD4Context);
    *ppcsBuffer = pMD4Context;
    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
md4InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(md4Initialize(0, ppcsBuffer));
}


NTSTATUS NTAPI
md4Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD4Update((MD4_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md4Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    MD4Final((MD4_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD4_CTX *) pcsBuffer)->digest, 16);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md4Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
md5Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    MD5_CTX *   pMD5Context;

#ifdef KERNEL_MODE
    pMD5Context = ExAllocatePool(NonPagedPool, sizeof(MD5_CTX));
#else
    pMD5Context = malloc(sizeof(MD5_CTX));
#endif
    if (!pMD5Context)
    {
        return(STATUS_NO_MEMORY);
    }
    MD5Init(pMD5Context);
    *ppcsBuffer = pMD5Context;
    return(STATUS_SUCCESS);

}

NTSTATUS NTAPI
md5InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(md5Initialize(0, ppcsBuffer));
}


NTSTATUS NTAPI
md5Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD5Update((MD5_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    MD5Final((MD5_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD5_CTX *) pcsBuffer)->digest, 16);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    free(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI desPlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI desEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI desFinish(PCRYPT_STATE_BUFFER *);

NTSTATUS NTAPI desMacInitialize(ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacInitializeEx(PUCHAR,ULONG, ULONG, PCHECKSUM_BUFFER *);
NTSTATUS NTAPI desMacSum(PCHECKSUM_BUFFER, ULONG, PUCHAR);
NTSTATUS NTAPI desMacFinalize(PCHECKSUM_BUFFER, PUCHAR);
NTSTATUS NTAPI desMacFinish(PCHECKSUM_BUFFER *);

NTSTATUS NTAPI
md25Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md25InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    MD5_CTX *   pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR TempBuffer[16];
    ULONG OutputSize;
    UCHAR TempKey[DES_KEYSIZE];
    PCRYPT_STATE_BUFFER DesContext = NULL;
    PCRYPTO_SYSTEM DesSystem;
    ULONG Index;

    memset(
        TempBuffer,
        0,
        sizeof(TempBuffer)
        );

    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }

#ifdef KERNEL_MODE
    pMD5Context = (MD5_CTX *) ExAllocatePool(NonPagedPool,sizeof(MD5_CTX));
#else
    pMD5Context = (MD5_CTX *) LocalAlloc(0,sizeof(MD5_CTX));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(pMD5Context);

    //
    // Prepare the key by byte reversing it.
    //

    for (Index = 0; Index  < DES_KEYSIZE ; Index++ )
    {
        TempKey[Index] = Key[(DES_KEYSIZE - 1) - Index];
    }

    Status = CDLocateCSystem(
                KERB_ETYPE_DES_PLAIN,
                &DesSystem
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = DesSystem->Initialize(
                TempKey,
                DES_KEYSIZE,
                0,              // no options
                &DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = DesSystem->Encrypt(
                DesContext,
                TempBuffer,
                sizeof(TempBuffer),
                TempBuffer,
                &OutputSize
                );
    ASSERT(OutputSize == sizeof(TempBuffer));
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    (VOID) DesSystem->Discard(&DesContext);

    //
    // Now MD5 update with the encrypted buffer
    //

    MD5Update(
        pMD5Context,
        TempBuffer,
        sizeof(TempBuffer)
        );


    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

Cleanup:
    if (!NT_SUCCESS(Status) && (pMD5Context != NULL))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
    }
    return(Status);
}


NTSTATUS NTAPI
md25Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    MD5Update((MD5_CTX *) pcsBuffer, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md25Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR pbSum)
{
    MD5Final((MD5_CTX *) pcsBuffer);
    memcpy(pbSum, ((MD5_CTX *) pcsBuffer)->digest, MD5_LEN/2);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md25Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*ppcsBuffer);
#else
    LocalFree(*ppcsBuffer);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////


NTSTATUS NTAPI
md5DesInitialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5DesInitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER  pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;

    if (KeySize != DES_KEYSIZE)
    {
        return(STATUS_INVALID_PARAMETER);
    }

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_DES_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_STATE_BUFFER));
#else
    pMD5Context = (PMD5_DES_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_STATE_BUFFER));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(&pMD5Context->Md5Context);

    //
    // Compute the initialization for the MD5
    //

    Status = desPlainInitialize(
                Key,
                KeySize,
                0,
                &pMD5Context->DesContext
                );

    if (!NT_SUCCESS(Status))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
        return(Status);
    }

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5DesSum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5DesFinalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    ULONG OutputLength;
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Final(&Context->Md5Context);

    desEncrypt(
        Context->DesContext,
        Context->Md5Context.digest,
        MD5_LEN,
        Context->Md5Context.digest,
        &OutputLength
        );

    RtlCopyMemory(
        pbSum,
        Context->Md5Context.digest + MD5_LEN-DES_BLOCKLEN,
        DES_BLOCKLEN
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5DesFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) *ppcsBuffer;
    desFinish(&Context->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////


NTSTATUS NTAPI rc4Md4Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4ShaInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Initialize(PUCHAR, ULONG, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Encrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Decrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Finish(PCRYPT_STATE_BUFFER *);

NTSTATUS NTAPI
md5Rc4Initialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5Rc4InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER  pMD5Context;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_DES_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_STATE_BUFFER));
#else
    pMD5Context = (PMD5_DES_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_STATE_BUFFER));
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    MD5Init(&pMD5Context->Md5Context);


    Status = rc4Initialize(
                Key,
                KeySize,
                0,              // no options
                0,
                &pMD5Context->DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (!NT_SUCCESS(Status))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
        return(Status);
    }

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

Cleanup:
    if (!NT_SUCCESS(Status) && (pMD5Context != NULL))
    {
#ifdef KERNEL_MODE
        ExFreePool(pMD5Context);
#else
        LocalFree(pMD5Context);
#endif
    }
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5Rc4Sum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Rc4Finalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) pcsBuffer;
    ULONG OutputSize;
    NTSTATUS Status;

    MD5Final(&Context->Md5Context);

    memcpy(
        pbSum,
        Context->Md5Context.digest,
        MD5_LEN
        );
    Status = rc4Encrypt(
                Context->DesContext,
                pbSum,
                MD5_LEN,
                pbSum,
                &OutputSize
                );


    ASSERT(OutputSize == MD5_LEN);

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }



    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Rc4Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_STATE_BUFFER Context = (PMD5_DES_STATE_BUFFER) *ppcsBuffer;

    (VOID) rc4Finish(&Context->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    );


NTSTATUS NTAPI
md5HmacInitialize(
    ULONG dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5HmacInitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER  pMD5Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_HMAC_STATE_BUFFER) + KeySize);
#else
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_HMAC_STATE_BUFFER) + KeySize);
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        pMD5Context->Key,
        Key,
        KeySize
        );
    pMD5Context->KeySize = KeySize;

    MD5Init(&pMD5Context->Md5Context);
    MD5Update(&pMD5Context->Md5Context, (PUCHAR) &MessageType, sizeof(ULONG));

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Hmac2InitializeEx(
    PUCHAR Key,
    ULONG KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER  pMD5Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef KERNEL_MODE
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_HMAC_STATE_BUFFER) + MD5_LEN);
#else
    pMD5Context = (PMD5_HMAC_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_HMAC_STATE_BUFFER) + MD5_LEN);
#endif
    if (!pMD5Context)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    md5Hmac(
        Key,
        KeySize,
        "signaturekey",
        sizeof("signaturekey"),
        NULL,
        0,
        pMD5Context->Key
        );
    pMD5Context->KeySize = MD5_LEN;

    MD5Init(&pMD5Context->Md5Context);
    MD5Update(&pMD5Context->Md5Context, (PUCHAR) &MessageType, sizeof(ULONG));

    *ppcsBuffer = (PCHECKSUM_BUFFER) pMD5Context;

    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
md5HmacSum( PCHECKSUM_BUFFER     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) pcsBuffer;
    MD5Update(&Context->Md5Context, pbData, cbData);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5HmacFinalize(    PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR           pbSum)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) pcsBuffer;

    MD5Final(&Context->Md5Context);

    if (!md5Hmac(
            Context->Key,
            Context->KeySize,
            Context->Md5Context.digest,
            MD5_LEN,
            NULL,               // no secondary material
            0,
            pbSum))
    {
        return(STATUS_UNSUCCESSFUL);
    }


    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5HmacFinish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_HMAC_STATE_BUFFER Context = (PMD5_HMAC_STATE_BUFFER) *ppcsBuffer;

#ifdef KERNEL_MODE
    ExFreePool(Context);
#else
    LocalFree(Context);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
md5Des1510InitializeEx(
    PUCHAR Key,
    ULONG  KeySize,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS NTAPI
md5Des1510InitializeEx2(
    PUCHAR Key,
    ULONG  KeySize,
    PUCHAR ChecksumToVerify,
    ULONG  MessageType,
    PCHECKSUM_BUFFER * ppcsBuffer
    )
{
    ULONG *pul;
    ULONG *pul2;
    UCHAR FinalKey[DES_KEYSIZE];
    PMD5_DES_1510_STATE_BUFFER  pContext = NULL;
    ULONG cb = DES_BLOCKLEN;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Make sure we were passed an appropriate key
    //

    if (KeySize != DES_KEYSIZE)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#ifdef KERNEL_MODE
    pContext = (PMD5_DES_1510_STATE_BUFFER) ExAllocatePool(NonPagedPool,sizeof(MD5_DES_1510_STATE_BUFFER));
#else
    pContext = (PMD5_DES_1510_STATE_BUFFER) LocalAlloc(0,sizeof(MD5_DES_1510_STATE_BUFFER));
#endif
    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // create the final key table
    //
    pul = (ULONG*)FinalKey;
    pul2 = (ULONG*)Key;
    *pul = *pul2 ^ 0xf0f0f0f0;
    pul = (ULONG*)(FinalKey + sizeof(ULONG));
    pul2 = (ULONG*)(Key + sizeof(ULONG));
    *pul = *pul2 ^ 0xf0f0f0f0;

    Status = desPlainInitialize(
                FinalKey,
                DES_KEYSIZE,
                0,
                &pContext->DesContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Checksum was not passed in so generate a confounder
    //
    if (NULL == ChecksumToVerify)
    {
        CDGenerateRandomBits(pContext->Confounder,DES_BLOCKLEN);
    }
    else
    {
        // the IV is all zero so no need to use CBC on first block
        Status = desEncrypt(
                        pContext->DesContext,
                        ChecksumToVerify,
                        DES_BLOCKLEN,
                        pContext->Confounder,
                        &cb
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    MD5Init(&pContext->Md5Context);

    // hash in the confounder
    MD5Update(&pContext->Md5Context, pContext->Confounder, DES_BLOCKLEN);

    *ppcsBuffer = (PCHECKSUM_BUFFER) pContext;
Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        if (NULL != pContext)
        {
#ifdef KERNEL_MODE
            ExFreePool(pContext);
#else
            LocalFree(pContext);
#endif
        }
    }

    return(Status);

}

NTSTATUS NTAPI
md5Des1510Finalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR           pbSum)
{
    UCHAR TmpBuffer[DES_BLOCKLEN * 2];
    PMD5_DES_1510_STATE_BUFFER pContext = (PMD5_DES_1510_STATE_BUFFER) pcsBuffer;
    ULONG cb = DES_BLOCKLEN * 2;
    NTSTATUS Status = STATUS_SUCCESS;

    memcpy(TmpBuffer, pContext->Confounder, DES_BLOCKLEN);
    memcpy(TmpBuffer + DES_BLOCKLEN, pContext->Md5Context.digest, MD5_LEN);

    Status = desEncrypt(
                    pContext->DesContext,
                    TmpBuffer,
                    DES_BLOCKLEN * 2,
                    pbSum,
                    &cb
                    );

    return(Status);
}

NTSTATUS NTAPI
md5Des1510Finish(  PCHECKSUM_BUFFER *   ppcsBuffer)
{
    PMD5_DES_1510_STATE_BUFFER pContext = (PMD5_DES_1510_STATE_BUFFER) *ppcsBuffer;
    desFinish(&pContext->DesContext);
#ifdef KERNEL_MODE
    ExFreePool(pContext);
#else
    LocalFree(pContext);
#endif
    *ppcsBuffer = 0;
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\nullcs.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        nullcs.c
//
// Contents:    Null Crypto system
//
//
// History:
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <string.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>
#include "md4.h"


NTSTATUS NTAPI ncsInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI ncsEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI ncsDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI ncsFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI ncsHashPassword(PSECURITY_STRING, PUCHAR);
NTSTATUS NTAPI ncsRandomKey(PUCHAR, ULONG, PUCHAR );
NTSTATUS NTAPI ncsFinishRandom(void);


CRYPTO_SYSTEM    csNULL = {
    KERB_ETYPE_NULL,        // Etype
    1,                      // Blocksize (stream)
    0,                      // no exportable version
    0,                      // Key size, in bytes
    0,                      // no header size
    KERB_CHECKSUM_MD4,      // Checksum algorithm
    0,                      // no attributes
    L"Microsoft NULL CS",   // Text name
    ncsInitialize,
    ncsEncrypt,
    ncsDecrypt,
    ncsFinish,
    ncsHashPassword,
    ncsRandomKey
    };


NTSTATUS NTAPI
ncsInitialize(  PUCHAR pbKey,
                ULONG KeySize,
                ULONG dwOptions,
                PCRYPT_STATE_BUFFER * psbBuffer)
{

    *psbBuffer = NULL;
    return(S_OK);
}

NTSTATUS NTAPI
ncsEncrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG           cbOutput)
{
    if (pbInput != pbOutput)
        memcpy(pbOutput, pbInput, cbInput);

    *cbOutput = cbInput;
    return(S_OK);
}

NTSTATUS NTAPI
ncsDecrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG           cbOutput)
{
    if (pbInput != pbOutput)
        memcpy(pbOutput, pbInput, cbInput);
    *cbOutput = cbInput;
    return(S_OK);
}

NTSTATUS NTAPI
ncsFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    *psbBuffer = NULL;
    return(S_OK);
}


NTSTATUS NTAPI
ncsHashPassword(PSECURITY_STRING pbPassword,
                PUCHAR           pbKey)
{

    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
ncsRandomKey(
    IN PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\rc4crypt.c ===
//+-----------------------------------------------------------------------
//
// File:        rc4crypt.c
//
// Contents:    CryptoSystem wrapper functions for RC4 hmac
//
//
// History:     02-Nov-1998     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef KERNEL_MODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntifs.h>

#endif

#include <string.h>
#include <malloc.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>

#include <rc4.h>
#include <md4.h>
#include <md5.h>

typedef struct RC4_KEYSTRUCT  RC4KEY;

#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Checksum[MD5_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;

typedef struct _RC4_STATE_BUFFER {
    UCHAR BaseKey[MD5_LEN];
    RC4KEY Key;
} RC4_STATE_BUFFER, *PRC4_STATE_BUFFER;

typedef struct _RC4_HMAC_STATE_BUFFER {
    UCHAR Key[MD5_LEN];
} RC4_HMAC_STATE_BUFFER, *PRC4_HMAC_STATE_BUFFER;


NTSTATUS NTAPI rc4PlainInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4PlainExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacExpInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacPlainEncrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacPlainDecrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacFinish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacPlainControl(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacRandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI rc4HmacHashPassword(PSECURITY_STRING, PUCHAR );

#ifdef KERNEL_MODE
#pragma alloc_text(PAGEMSG, rc4PlainInitialize)
#pragma alloc_text(PAGEMSG, rc4PlainExpInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacExpInitialize )
#pragma alloc_text(PAGEMSG, rc4HmacEncrypt )
#pragma alloc_text(PAGEMSG, rc4HmacDecrypt )
#pragma alloc_text(PAGEMSG, rc4HmacPlainEncrypt )
#pragma alloc_text(PAGEMSG, rc4HmacPlainDecrypt )
#pragma alloc_text(PAGEMSG, rc4HmacFinish )
#pragma alloc_text(PAGEMSG, rc4HmacControl )
#pragma alloc_text(PAGEMSG, rc4HmacPlainControl )
#pragma alloc_text(PAGEMSG, rc4HmacRandomKey )
#pragma alloc_text(PAGEMSG, rc4HmacHashPassword )
#endif


CRYPTO_SYSTEM    csRC4_HMAC = {
    KERB_ETYPE_RC4_HMAC_NT,     // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED, //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitialize,
    rc4HmacEncrypt,
    rc4HmacDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacControl
    };


//
// This is not actually export strength - it is a signal that the
// plain version is export strength
//

CRYPTO_SYSTEM    csRC4_HMAC_EXP = {
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_NT_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED | CSYSTEM_EXPORT_STRENGTH, //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitialize,
    rc4HmacEncrypt,
    rc4HmacDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacControl
    };


CRYPTO_SYSTEM    csRC4_PLAIN = {
    KERB_ETYPE_RC4_PLAIN,       // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4",              // Text name
    rc4PlainInitialize,
    rc4HmacPlainEncrypt,
    rc4HmacPlainDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacPlainControl
    };

CRYPTO_SYSTEM    csRC4_PLAIN_EXP = {
    KERB_ETYPE_RC4_PLAIN_EXP,   // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_EXPORT_STRENGTH,    // no attributes
    L"RSADSI RC4-EXP",          // Text name
    rc4PlainExpInitialize,
    rc4HmacPlainEncrypt,
    rc4HmacPlainDecrypt,
    rc4HmacFinish,
    rc4HmacHashPassword,
    rc4HmacRandomKey,
    rc4HmacPlainControl
    };



NTSTATUS NTAPI
rc4HmacHashPassword(
    IN PSECURITY_STRING Password,
    OUT PUCHAR Key
    )
{
    PCHECKSUM_FUNCTION   SumFunction;
    PCHECKSUM_BUFFER     Buffer;
    NTSTATUS     Status;


    Status = CDLocateCheckSum(KERB_CHECKSUM_MD4, &SumFunction);
    if (!NT_SUCCESS(Status))
    {
        return(SEC_E_CHECKSUM_NOT_SUPP);
    }


    Status = SumFunction->Initialize(0, &Buffer);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    (void) SumFunction->Sum(Buffer, Password->Length, (PUCHAR) Password->Buffer);
    (void) SumFunction->Finalize(Buffer, Key);
    (void) SumFunction->Finish(&Buffer);
    return(STATUS_SUCCESS);
}




//////////////////////////////////////////////////////////////////////////
//
// RC4 HMAC crypt type
//
//////////////////////////////////////////////////////////////////////////

BOOLEAN static
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    UCHAR Kipad[HMAC_K_PADSIZE];
    UCHAR Kopad[HMAC_K_PADSIZE];
    UCHAR HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(ULONG); dwBlock++)
    {
        ((ULONG*)Kipad)[dwBlock] ^= 0x36363636;
        ((ULONG*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    RtlCopyMemory(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}


NTSTATUS NTAPI
rc4HmacBaseInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = NULL;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = (PRC4_HMAC_STATE_BUFFER) ExAllocatePool(NonPagedPool, sizeof(RC4_HMAC_STATE_BUFFER));
#else
    StateBuffer = (PRC4_HMAC_STATE_BUFFER) LocalAlloc(0, sizeof(RC4_HMAC_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->Key
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fiftysixbits",
            sizeof("fiftysixbits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->Key
            );
        LocalKeySize = 5;       // 40 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    ASSERT(MD5_LEN >= LocalKeySize);

    memset(
        StateBuffer->Key+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitialize(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // not exportable
                psbBuffer
                ));
}


NTSTATUS NTAPI
rc4HmacPlainBaseInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_STATE_BUFFER StateBuffer = NULL;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = (PRC4_STATE_BUFFER) ExAllocatePool(NonPagedPool, sizeof(RC4_STATE_BUFFER));
#else
    StateBuffer = (PRC4_STATE_BUFFER) LocalAlloc(0, sizeof(RC4_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->BaseKey
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fortybits",
            sizeof("fortybits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->BaseKey
            );
        LocalKeySize = 7;       // 56 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    ASSERT(MD5_LEN >= LocalKeySize);

    memset(
        StateBuffer->BaseKey+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    //
    // Create the encryption key
    //

    rc4_key(
        &StateBuffer->Key,
        MD5_LEN,
        StateBuffer->BaseKey
        );

    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4PlainInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacPlainBaseInitialize(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // not exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4PlainExpInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacPlainBaseInitialize(
                pbKey,
                KeySize,                // only use 40 bites
                MessageType,
                TRUE,                   // exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4HmacControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_HMAC_STATE_BUFFER HmacStateBuffer = (PRC4_HMAC_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        md5Hmac(
            HmacStateBuffer->Key,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->Key
            );
    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainControl(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_STATE_BUFFER HmacStateBuffer = (PRC4_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        //
        // create the new initial key
        //

        md5Hmac(
            HmacStateBuffer->BaseKey,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->BaseKey
            );

        //
        // Create the encryption key
        //

        rc4_key(
            &HmacStateBuffer->Key,
            MD5_LEN,
            HmacStateBuffer->BaseKey
            );

    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    UCHAR LocalKey[MD5_LEN];
    ULONG Offset = 0;
    RC4KEY Rc4Key;

    Offset = sizeof(RC4_MDx_HEADER);
    RtlMoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    RtlZeroMemory(
        CryptHeader->Checksum,
        MD5_LEN
        );

    CDGenerateRandomBits(
        CryptHeader->Confounder,
        RC4_CONFOUNDER_LEN
        );

    //
    // Checksum everything but the checksum
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        pbOutput+MD5_LEN,
        *cbOutput-MD5_LEN,
        NULL,
        0,
        CryptHeader->Checksum
        );


    //
    // HMAC the checksum into the key
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        CryptHeader->Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        LocalKey
        );

    //
    // Encrypt everything but the checksum
    //

    rc4(&Rc4Key, *cbOutput-MD5_LEN, pbOutput+MD5_LEN);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacDecrypt( PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    UCHAR TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    UCHAR LocalKey[MD5_LEN];
    RC4KEY Rc4Key;


    if (cbInput < Offset)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Copy the input to the output before decrypting
    //

    RtlCopyMemory(
        &TempHeader,
        pbInput,
        Offset
        );

    *cbOutput = cbInput - Offset;
    RtlMoveMemory(
        pbOutput,
        pbInput + Offset,
        *cbOutput
        );


    //
    // Build the decryption key from the checksum and the
    // real key
    //

    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        TempHeader.Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        LocalKey
        );


    //
    // Now decrypt the two buffers
    //


    rc4(
        &Rc4Key,
        Offset - MD5_LEN,
        TempHeader.Confounder
        );


    rc4(
        &Rc4Key,
        *cbOutput,
        pbOutput
        );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //


    md5Hmac(
        StateBuffer->Key,
        MD5_LEN,
        TempHeader.Confounder,
        Offset-MD5_LEN,
        pbOutput,
        *cbOutput,
        TempChecksum
        );

    if (RtlEqualMemory(
            TempHeader.Checksum,
            TempChecksum,
            MD5_LEN
            ) != TRUE)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainEncrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;

    *cbOutput = cbInput;
    rc4(
        &StateBuffer->Key,
        cbInput,
        pbInput
        );

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacPlainDecrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;

    *cbOutput = cbInput;

    rc4(
        &StateBuffer->Key,
        *cbOutput,
        pbOutput
        );
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacFinish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacRandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    CDGenerateRandomBits(pbKey,MD5_LEN);

    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\rc4cwrap.c ===
//+-----------------------------------------------------------------------
//
// File:        RC4CWRAP.C
//
// Contents:    CryptoSystem wrapper functions for RC4
//
//
// History:     25 Feb 92   RichardW    Created
//
//------------------------------------------------------------------------

#ifndef KERNEL_MODE 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntifs.h>

#endif

#include <string.h>
#include <malloc.h>

#include <kerbcon.h>
#include <security.h>
#include <cryptdll.h>

#include <rc4.h>
#include <md4.h>
#include <md5.h>

//#define DONT_SUPPORT_OLD_ETYPES 1

typedef struct RC4_KEYSTRUCT  RC4KEY;

#define RC4_LEGAL_KEYSIZE   8
#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR Checksum[MD4_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;

typedef struct _RC4_STATE_BUFFER {
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER ChecksumBuffer;
    RC4KEY Key;
} RC4_STATE_BUFFER, *PRC4_STATE_BUFFER;

typedef struct _RC4_HMAC_STATE_BUFFER {
    UCHAR Key[MD5_LEN];
    BOOLEAN IncludeHmac;
} RC4_HMAC_STATE_BUFFER, *PRC4_HMAC_STATE_BUFFER;

NTSTATUS NTAPI rc4Md4Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmInitialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
#ifndef DONT_SUPPORT_OLD_ETYPES
NTSTATUS NTAPI rc4Plain2Initialize(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4LmHashPassword(PSECURITY_STRING, PUCHAR);
#endif
NTSTATUS NTAPI rc4Encrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Decrypt(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4Finish(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4Md4HashPassword(PSECURITY_STRING, PUCHAR);
NTSTATUS NTAPI rc4Md4RandomKey(PUCHAR, ULONG, PUCHAR);
NTSTATUS NTAPI rc4Control(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);

NTSTATUS NTAPI rc4PlainInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4PlainExpInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacExpInitializeOld(PUCHAR, ULONG, ULONG, PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacEncryptOld(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacDecryptOld(PCRYPT_STATE_BUFFER, PUCHAR, ULONG, PUCHAR, PULONG);
NTSTATUS NTAPI rc4HmacFinishOld(PCRYPT_STATE_BUFFER *);
NTSTATUS NTAPI rc4HmacControlOld(ULONG, PCRYPT_STATE_BUFFER, PUCHAR, ULONG);
NTSTATUS NTAPI rc4HmacRandomKeyOld(PUCHAR, ULONG, PUCHAR);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, rc4Md4Initialize )
#pragma alloc_text( PAGEMSG, rc4LmInitialize )
#pragma alloc_text( PAGEMSG, rc4Encrypt )
#pragma alloc_text( PAGEMSG, rc4Decrypt )
#pragma alloc_text( PAGEMSG, rc4Finish )
#pragma alloc_text( PAGEMSG, rc4Md4HashPassword )
#pragma alloc_text( PAGEMSG, rc4Md4RandomKey )
#pragma alloc_text( PAGEMSG, rc4Control )
#pragma alloc_text( PAGEMSG, rc4PlainInitializeOld )
#pragma alloc_text( PAGEMSG, rc4PlainExpInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacExpInitializeOld )
#pragma alloc_text( PAGEMSG, rc4HmacDecryptOld )
#pragma alloc_text( PAGEMSG, rc4HmacEncryptOld )
#pragma alloc_text( PAGEMSG, rc4HmacFinishOld )
#pragma alloc_text( PAGEMSG, rc4HmacControlOld )
#pragma alloc_text( PAGEMSG, rc4HmacRandomKeyOld )
#endif

CRYPTO_SYSTEM    csRC4_MD4 = {
    KERB_ETYPE_RC4_MD4,         // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-MD4",          // Text name
    rc4Md4Initialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4Md4HashPassword,
    rc4Md4RandomKey,
    rc4Control
    };

#ifndef DONT_SUPPORT_OLD_ETYPES

CRYPTO_SYSTEM    csRC4_LM = {
    KERB_ETYPE_RC4_LM,          // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // State buffer size
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_LM,           // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-LM",           // Text name
    rc4LmInitialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4LmHashPassword,
    rc4Md4RandomKey,
    rc4Control
    };

CRYPTO_SYSTEM    csRC4_PLAIN2 = {
    KERB_ETYPE_RC4_PLAIN2,      // Etype
    1,                          // Blocksize (stream)
    0,                          // no exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4-PLAIN",        // Text name
    rc4Plain2Initialize,
    rc4Encrypt,
    rc4Decrypt,
    rc4Finish,
    rc4Md4HashPassword,
    rc4Md4RandomKey,
    rc4Control
    };
#endif

CRYPTO_SYSTEM    csRC4_HMAC_OLD = {
    KERB_ETYPE_RC4_HMAC_OLD,        // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_OLD_EXP,// Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED,   //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };

CRYPTO_SYSTEM    csRC4_HMAC_OLD_EXP = {
    KERB_ETYPE_RC4_HMAC_OLD_EXP,        // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_HMAC_OLD_EXP, // Exportable version
    MD4_LEN,                    // Key size, in bytes
    sizeof(RC4_MDx_HEADER),     // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_INTEGRITY_PROTECTED | CSYSTEM_EXPORT_STRENGTH,   //  attributes
    L"RSADSI RC4-HMAC",          // Text name
    rc4HmacInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };


CRYPTO_SYSTEM    csRC4_PLAIN_OLD = {
    KERB_ETYPE_RC4_PLAIN_OLD,       // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    0,                          // no attributes
    L"RSADSI RC4",              // Text name
    rc4PlainInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };

CRYPTO_SYSTEM    csRC4_PLAIN_OLD_EXP = {
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // Etype
    1,                          // Blocksize (stream)
    KERB_ETYPE_RC4_PLAIN_OLD_EXP,   // exportable version
    MD4_LEN,                    // Key size, in bytes
    0,                          // header size
    KERB_CHECKSUM_MD4,          // Preferred Checksum
    CSYSTEM_EXPORT_STRENGTH,    // no attributes
    L"RSADSI RC4-EXP",          // Text name
    rc4PlainExpInitializeOld,
    rc4HmacEncryptOld,
    rc4HmacDecryptOld,
    rc4HmacFinishOld,
    rc4Md4HashPassword,
    rc4HmacRandomKeyOld,
    rc4HmacControlOld
    };


NTSTATUS NTAPI
rc4Initialize(  PUCHAR          pbKey,
                ULONG           KeySize,
                ULONG           MessageType,
                ULONG           ChecksumFunction,
                PCRYPT_STATE_BUFFER *  psbBuffer)
{
    NTSTATUS Status;
    PRC4_STATE_BUFFER    pRC4Key;
    PCHECKSUM_FUNCTION Checksum = NULL;

    //
    // Get the appropriate checksum here.
    //

    if (ChecksumFunction != 0)
    {
        Status = CDLocateCheckSum(
                    ChecksumFunction,
                    &Checksum
                    );
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }

    }
    //
    // if the key is too short, fail here.
    //

    if (KeySize < RC4_LEGAL_KEYSIZE)
    {
        return(SEC_E_ETYPE_NOT_SUPP);
    }

#ifdef KERNEL_MODE
    pRC4Key = ExAllocatePool(NonPagedPool, sizeof(RC4_STATE_BUFFER));
#else
    pRC4Key = LocalAlloc(0, sizeof(RC4_STATE_BUFFER));
#endif
    if (pRC4Key == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    rc4_key(&pRC4Key->Key, RC4_LEGAL_KEYSIZE, pbKey);

    //
    // Initialize the checksum function, if we have one.
    //

    pRC4Key->ChecksumFunction = Checksum;

    if (Checksum != NULL)
    {

        Status = Checksum->Initialize(
                    0,
                    &pRC4Key->ChecksumBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
#ifdef KERNEL_MODE
            ExFreePool(pRC4Key);
#else
            LocalFree(pRC4Key);
#endif
            return(Status);
        }
    }

    *psbBuffer = (PCRYPT_STATE_BUFFER) pRC4Key;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_MD4,
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4LmInitialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                KERB_CHECKSUM_LM,
                psbBuffer
                ));
}

#ifndef DONT_SUPPORT_OLD_ETYPES
NTSTATUS NTAPI
rc4Plain2Initialize(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4Initialize(
                pbKey,
                KeySize,
                MessageType,
                0,                      // no checksum
                psbBuffer
                ));
}


#endif

NTSTATUS NTAPI
rc4Encrypt(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    ULONG Offset = 0;

    if (StateBuffer->ChecksumFunction != NULL)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }
    RtlMoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;


    RtlZeroMemory(
        CryptHeader,
        Offset
        );

    rc4(&StateBuffer->Key, *cbOutput, pbOutput);

    return( STATUS_SUCCESS );
}

NTSTATUS NTAPI
rc4Decrypt(     PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    ULONG Offset = 0;

    if (*cbOutput < cbInput)
    {
        *cbOutput = cbInput;
        return(STATUS_BUFFER_TOO_SMALL);
    }
    RtlCopyMemory(
        pbOutput,
        pbInput,
        cbInput
        );

    rc4(&StateBuffer->Key, cbInput, pbOutput);

    if (StateBuffer->ChecksumFunction != NULL)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }

    RtlZeroMemory(
        &TempHeader,
        Offset
        );

    if (RtlEqualMemory(
            &TempHeader,
            pbOutput,
            Offset
            ) != TRUE)
    {
        return(STATUS_UNSUCCESSFUL);
    }


    *cbOutput = cbInput - Offset;


    RtlMoveMemory(
        pbOutput,
        pbOutput + Offset,
        *cbOutput
        );


    return( STATUS_SUCCESS );
}

NTSTATUS NTAPI
rc4Finish(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
    PRC4_STATE_BUFFER StateBuffer = (PRC4_STATE_BUFFER) *psbBuffer;


    if (StateBuffer->ChecksumFunction != NULL)
    {
        StateBuffer->ChecksumFunction->Finish(&StateBuffer->ChecksumBuffer);
    }
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
rc4HashPassword(
    IN PSECURITY_STRING Password,
    IN ULONG Checksum,
    OUT PUCHAR Key
    )
{
    PCHECKSUM_FUNCTION   SumFunction;
    PCHECKSUM_BUFFER     Buffer;
    NTSTATUS     Status;


    Status = CDLocateCheckSum(Checksum, &SumFunction);
    if (!NT_SUCCESS(Status))
    {
        return(SEC_E_CHECKSUM_NOT_SUPP);
    }


    Status = SumFunction->Initialize(0, &Buffer);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    (void) SumFunction->Sum(Buffer, Password->Length, (PUCHAR) Password->Buffer);
    (void) SumFunction->Finalize(Buffer, Key);
    (void) SumFunction->Finish(&Buffer);
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4HashPassword(
    PSECURITY_STRING pbPassword,
    PUCHAR           pbKey)
{
    return(rc4HashPassword( pbPassword, KERB_CHECKSUM_MD4, pbKey));
}

NTSTATUS NTAPI
rc4LmHashPassword(
    PSECURITY_STRING pbPassword,
    PUCHAR           pbKey)
{
    return(rc4HashPassword( pbPassword, KERB_CHECKSUM_LM, pbKey));
}


NTSTATUS NTAPI
rc4RandomKey(
    IN ULONG KeyLength,
    OUT PUCHAR pbKey
    )
{

    CDGenerateRandomBits(pbKey,KeyLength);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4Md4RandomKey(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    memset(
        pbKey,
        0xab,
        MD4_LEN
        );
    return(rc4RandomKey(5,pbKey));
}




NTSTATUS NTAPI
rc4Control(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{
    UCHAR TempBuffer[128];

    PRC4_STATE_BUFFER Rc4StateBuffer = (PRC4_STATE_BUFFER) StateBuffer;

    if (Function != CRYPT_CONTROL_SET_INIT_VECT)
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if (InputBufferSize > sizeof(TempBuffer))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // We set the IV by encrypting the supplied buffer and leaving the
    // keystate changed.
    //

    memcpy(
        TempBuffer,
        InputBuffer,
        InputBufferSize
        );
    rc4(&Rc4StateBuffer->Key, InputBufferSize, TempBuffer );

    return(STATUS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////
//
// RC4 HMAC crypt type
//
//////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN PUCHAR pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PUCHAR pbData,
    IN ULONG cbData,
    IN PUCHAR pbData2,
    IN ULONG cbData2,
    OUT PUCHAR HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    UCHAR Kipad[HMAC_K_PADSIZE];
    UCHAR Kopad[HMAC_K_PADSIZE];
    UCHAR HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(ULONG); dwBlock++)
    {
        ((ULONG*)Kipad)[dwBlock] ^= 0x36363636;
        ((ULONG*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    RtlCopyMemory(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}


NTSTATUS NTAPI
rc4HmacBaseInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN BOOLEAN IncludeHmac,
    IN BOOLEAN Exportable,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = NULL;
    LPSTR Direction = NULL;
    ULONG DirectionSize = 0;
    LPSTR Usage = NULL;
    ULONG UsageSize = 0;
    ULONG LocalKeySize = 0;


    //
    // Compute the HMAC pad
    //


#ifdef KERNEL_MODE
    StateBuffer = ExAllocatePool(NonPagedPool, sizeof(RC4_HMAC_STATE_BUFFER));
#else
    StateBuffer = LocalAlloc(0, sizeof(RC4_HMAC_STATE_BUFFER));
#endif
    if (StateBuffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If the key is not exportable, shrink it first
    //

    if (!Exportable)
    {
        md5Hmac(
            pbKey,
            KeySize,
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            NULL,
            0,
            StateBuffer->Key
            );
        LocalKeySize = MD5_LEN;
    }
    else
    {
        md5Hmac(
            pbKey,
            KeySize,
            "fortybits",
            sizeof("fortybits"),
            (PUCHAR) &MessageType,
            sizeof(ULONG),
            StateBuffer->Key
            );
        LocalKeySize = 5;       // 40 bits

    }

    //
    // Pad exportable keys with 0xababab
    //

    memset(
        StateBuffer->Key+LocalKeySize,
        0xab,
        MD5_LEN-LocalKeySize
        );

    StateBuffer->IncludeHmac = IncludeHmac;
    *psbBuffer = StateBuffer;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,
                MessageType,
                TRUE,           // include hmac
                FALSE,          // not exportable
                psbBuffer
                ));
}


NTSTATUS NTAPI
rc4PlainInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,
                MessageType,
                FALSE,          // no hmac
                FALSE,          // not exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4PlainExpInitializeOld(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    OUT PCRYPT_STATE_BUFFER *  psbBuffer
    )
{
    return(rc4HmacBaseInitializeOld(
                pbKey,
                KeySize,                // only use 40 bites
                MessageType,
                FALSE,                  // no hmac
                TRUE,                   // exportable
                psbBuffer
                ));
}

NTSTATUS NTAPI
rc4HmacControlOld(
    IN ULONG Function,
    IN PCRYPT_STATE_BUFFER StateBuffer,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferSize
    )
{

    PRC4_HMAC_STATE_BUFFER HmacStateBuffer = (PRC4_HMAC_STATE_BUFFER) StateBuffer;

    if (Function == CRYPT_CONTROL_SET_INIT_VECT)
    {
        md5Hmac(
            HmacStateBuffer->Key,
            MD5_LEN,
            InputBuffer,
            InputBufferSize,
            NULL,
            0,
            HmacStateBuffer->Key
            );
    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacEncryptOld(
    IN PCRYPT_STATE_BUFFER psbBuffer,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG cbOutput
    )
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    ULONG Offset = 0;
    RC4KEY Rc4Key;

    if (StateBuffer->IncludeHmac)
    {
        Offset = sizeof(RC4_MDx_HEADER);
    }
    else
    {
        Offset = 0;
    }
    RtlMoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *cbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    if (Offset != 0)
    {
        RtlZeroMemory(
            CryptHeader->Checksum,
            MD4_LEN
            );

        CDGenerateRandomBits(
            CryptHeader->Confounder,
            RC4_CONFOUNDER_LEN
            );

        md5Hmac(
            StateBuffer->Key,
            MD5_LEN,
            pbOutput,
            *cbOutput,
            NULL,
            0,
            CryptHeader->Checksum
            );
    }

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        StateBuffer->Key
        );

    rc4(&Rc4Key, *cbOutput, pbOutput);

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacDecryptOld( PCRYPT_STATE_BUFFER    psbBuffer,
                PUCHAR           pbInput,
                ULONG            cbInput,
                PUCHAR           pbOutput,
                PULONG            cbOutput)
{
    PRC4_HMAC_STATE_BUFFER StateBuffer = (PRC4_HMAC_STATE_BUFFER) psbBuffer;
    RC4_MDx_HEADER TempHeader;
    UCHAR TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    RC4KEY Rc4Key;

    if (!StateBuffer->IncludeHmac)
    {
        Offset = 0;
    }

    if (cbInput < Offset)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    rc4_key(
        &Rc4Key,
        MD5_LEN,
        StateBuffer->Key
        );

    //
    // Copy the input to the output before decrypting
    //

    RtlCopyMemory(
        &TempHeader,
        pbInput,
        Offset
        );

    *cbOutput = cbInput - Offset;
    RtlMoveMemory(
        pbOutput,
        pbInput + Offset,
        *cbOutput
        );

    //
    // Now decrypt the two buffers
    //


    if (Offset != 0)
    {
        rc4(
            &Rc4Key,
            Offset,
            (PUCHAR) &TempHeader
            );
    }

    rc4(
        &Rc4Key,
        *cbOutput,
        pbOutput
        );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //

    if (Offset != 0)
    {

        RtlCopyMemory(
            TempChecksum,
            TempHeader.Checksum,
            MD5_LEN
            );

        RtlZeroMemory(
            TempHeader.Checksum,
            MD5_LEN
            );

        md5Hmac(
            StateBuffer->Key,
            MD5_LEN,
            (PUCHAR) &TempHeader,
            Offset,
            pbOutput,
            *cbOutput,
            TempHeader.Checksum
            );

        if (RtlEqualMemory(
                TempHeader.Checksum,
                TempChecksum,
                MD5_LEN
                ) != TRUE)
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacFinishOld(      PCRYPT_STATE_BUFFER *  psbBuffer)
{
#ifdef KERNEL_MODE
    ExFreePool(*psbBuffer);
#else
    LocalFree(*psbBuffer);
#endif
    *psbBuffer = NULL;
    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
rc4HmacRandomKeyOld(
    IN OPTIONAL PUCHAR Seed,
    IN ULONG SeedLength,
    OUT PUCHAR pbKey
    )
{
    return(rc4RandomKey(MD5_LEN,pbKey));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\dbgtool\dbgtool.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dbgtool.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-03-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>

#include <debugp.h>
#include "dialogs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\dbgtool\dbgtool.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dbgtool.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-03-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "dbgtool.h"

HANDLE          hMapping;
PDebugHeader    pHeader;
ULONG_PTR       Xlate ;

#define TranslatePointer( x )   (PVOID) ( (x) ? ((PUCHAR) x + Xlate) : NULL )


PVOID
MapDebugMemory(DWORD    pid)
{
    WCHAR           szMapping[32];
    PDebugHeader    pHeader = NULL;
    PVOID           pvMap;
    DWORD           CommitSize;
    SYSTEM_INFO     SysInfo;
    SECURITY_DESCRIPTOR min ;

    GetSystemInfo(&SysInfo);

    swprintf(szMapping, TEXT("Debug.Memory.%x"), pid);

    hMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS,
                                FALSE,
                                szMapping);

    if ( !hMapping && GetLastError() == ERROR_ACCESS_DENIED )
    {
        hMapping = OpenFileMapping( WRITE_DAC | READ_CONTROL,
                                    FALSE,
                                    szMapping );

        if ( hMapping )
        {
            InitializeSecurityDescriptor(&min, 1);
            SetSecurityDescriptorDacl(&min,FALSE,NULL,FALSE);
            SetKernelObjectSecurity(hMapping, DACL_SECURITY_INFORMATION, &min );

            CloseHandle( hMapping );


            hMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS,
                                        FALSE,
                                        szMapping);
            
        }
        
    }

    if (hMapping)
    {
        pHeader = MapViewOfFileEx(  hMapping,
                                    FILE_MAP_ALL_ACCESS,
                                    0,
                                    0,
                                    0,
                                    NULL);

        if (pHeader && (pHeader != pHeader->pvSection))
        {
            //
            // Rats.  Remap at preferred address:
            //

            pvMap = pHeader->pvSection;
            UnmapViewOfFile(pHeader);
            pHeader = MapViewOfFileEx(  hMapping,
                                        FILE_MAP_READ | FILE_MAP_WRITE,
                                        0,
                                        0,
                                        0,
                                        pvMap);
            if (pHeader)
            {
                CommitSize = pHeader->CommitRange;
            }
            else
            {
                //
                // Can't map at same address, unfortunately.  Set up the translation:
                //

                pHeader = MapViewOfFileEx(  hMapping,
                                            FILE_MAP_READ | FILE_MAP_WRITE,
                                            0,
                                            0,
                                            0,
                                            NULL );

                if ( pHeader )
                {
                    Xlate = (ULONG_PTR) ((PUCHAR) pHeader - (PUCHAR) pHeader->pvSection );
                }
            }
        }
        else
        {


        }
    }
    return(pHeader);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpFindModule
//
//  Synopsis:   Locates a module based on a name
//
//  Arguments:  [pHeader] -- Header to search
//              [pszName] -- module to find
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDebugModule
DbgFindModule(
    PDebugHeader    pHeader,
    CHAR *          pszName)
{
    PDebugModule    pSearch;

    pSearch = TranslatePointer( pHeader->pModules);
    while ( pSearch )
    {
        if (_strcmpi( TranslatePointer( pSearch->pModuleName ), pszName) == 0)
        {
            return(pSearch);
        }
        pSearch = TranslatePointer( pSearch->pNext );
    }

    return(NULL);
}

RenameKeys(
    HWND            hDlg,
    PDebugModule    pModule)
{
    int i;
    DWORD   f;


    for (i = 0, f = 1; i < 32 ; i++, f <<= 1 )
    {
        if (pModule->TagLevels[i])
        {
            SetDlgItemTextA(hDlg, i + IDD_CHECK_0, TranslatePointer( pModule->TagLevels[i] ) );
        }
        else
        {
            SetDlgItemTextA(hDlg, i + IDD_CHECK_0, "");
        }

        CheckDlgButton(hDlg, i + IDD_CHECK_0, (pModule->InfoLevel & f) ? 1 : 0);
    }

    return(0);
}

InitDialog(
    HWND        hDlg)
{
    PDebugModule    pSearch;
    LRESULT         index;
    HWND            hLB;
    CHAR            szText[MAX_PATH];

    //
    // Load Listbox:
    //

    hLB = GetDlgItem(hDlg, IDD_DEBUG_LB);
    pSearch = TranslatePointer( pHeader->pModules );
    while (pSearch)
    {
        index = SendMessageA(
                        hLB,
                        LB_ADDSTRING,
                        0,
                        (LPARAM) TranslatePointer( pSearch->pModuleName ) );

        SendMessage(
            hLB,
            LB_SETITEMDATA,
            index,
            (LPARAM) pSearch );

        pSearch = TranslatePointer( pSearch->pNext );
    }

    SetFocus(hLB);

    SendMessage(hLB, LB_SETSEL, 1, 0);

    ShowWindow(GetDlgItem(hDlg, IDD_MODULE_TEXT), SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDD_MODULE_OUTPUT), SW_HIDE);

    if (pHeader->pszExeName)
    {
        GetWindowTextA(hDlg, szText, MAX_PATH);
        strcat(szText, " : ");
        strcat(szText, TranslatePointer( pHeader->pszExeName ) );
        SetWindowTextA(hDlg, szText);
    }

    return(TRUE);
}

int
ListBoxNotify(
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    LRESULT i;
    PDebugModule    pModule;
    char    Total[16];

    if (HIWORD(wParam) == LBN_SELCHANGE)
    {
        if (!GetWindowLongPtr(hDlg, GWLP_USERDATA))
        {
            ShowWindow(GetDlgItem(hDlg, IDD_MODULE_TEXT), SW_NORMAL);
            ShowWindow(GetDlgItem(hDlg, IDD_MODULE_OUTPUT), SW_NORMAL);
        }

        i = SendMessage(GetDlgItem(hDlg, IDD_DEBUG_LB), LB_GETCURSEL, 0, 0);

        pModule = (PDebugModule) SendMessage(GetDlgItem(hDlg, IDD_DEBUG_LB),
                                        LB_GETITEMDATA, (WPARAM) i, 0);

        RenameKeys(hDlg, pModule);

        sprintf(Total, "%d bytes", pModule->TotalOutput);
        SetDlgItemTextA(hDlg, IDD_MODULE_OUTPUT, Total);

        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM) pModule);

    }

    return(TRUE);

}


HandleCheck(
    HWND        hDlg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    int bit;
    PDebugModule pModule;

    pModule = (PDebugModule) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    bit = 1 << (LOWORD(wParam) - IDD_CHECK_0);

    if (IsDlgButtonChecked(hDlg, LOWORD(wParam)))
    {
        pModule->InfoLevel |= bit;
    }
    else
    {
        pModule->InfoLevel&= ~(bit);
    }

    pModule->fModule |= DEBUGMOD_CHANGE_INFOLEVEL;

    return(0);
}


LRESULT
CALLBACK
DialogProc(
    HWND        hDlg,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    char    Total[16];


    switch (Message)
    {
        case WM_INITDIALOG:
            return(InitDialog(hDlg));

        case WM_COMMAND:
            sprintf(Total, "%d bytes", pHeader->TotalWritten);
            SetDlgItemTextA(hDlg, IDD_TOTAL_OUTPUT, Total);
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg, IDOK);
                    return(TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return(TRUE);

                case IDD_DEBUG_LB:
                    return(ListBoxNotify(hDlg, wParam, lParam));
            }

            if ((LOWORD(wParam) >= IDD_CHECK_0) &&
                (LOWORD(wParam) <= IDD_CHECK_31))
            {
                HandleCheck(hDlg, wParam, lParam);
            }
            return(TRUE);
    }
    return(FALSE);
}

int
ErrorMessage(
    HWND        hWnd,
    PWSTR       pszTitleBar,
    DWORD       Buttons)
{
    WCHAR   szMessage[256];

    FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,                               // ignored
            (GetLastError()),                     // message id
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),   // message language
            szMessage,                  // address of buffer pointer
            199,                                  // minimum buffer size
            NULL );                              // no other arguments

    return(MessageBox(hWnd, szMessage, pszTitleBar, Buttons));

}

int WINAPI WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow)
{
    int pid;
    PCHAR pszPid = lpszCmdParam;
    LRESULT Status ;

    sscanf(pszPid,"%d",&pid);

    pHeader = MapDebugMemory(pid);
    if (!pHeader)
    {
        ErrorMessage(NULL, TEXT("Map Debug Memory"), MB_OK | MB_ICONSTOP);
        return(0);
    }

    Status = DialogBox(  hInstance,
                    MAKEINTRESOURCE(IDD_DEBUG_TOOL),
                    GetDesktopWindow(),
                    DialogProc);

    if ( Status < 0 )
    {
        ErrorMessage(NULL, TEXT("DialogBox"), MB_OK | MB_ICONSTOP);
    }

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\shawrap.c ===
//
//

#ifndef KERNEL_MODE 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#else 

#include <ntddk.h>
#include <winerror.h>

#endif

#include <string.h>
#include <malloc.h>

#include <security.h>
#include <cryptdll.h>

#include <kerbcon.h>

#include "sha.h"


NTSTATUS
ShaWrapInitialize(ULONG dwSeed,
                PCHECKSUM_BUFFER * ppcsBuffer);

NTSTATUS
ShaWrapInitializeEx(PUCHAR Seed, ULONG dwSeedLength, ULONG MessageType,
                PCHECKSUM_BUFFER * ppcsBuffer);


NTSTATUS
ShaWrapSum(   PCHECKSUM_BUFFER pcsBuffer,
            ULONG           cbData,
            PUCHAR          pbData );

NTSTATUS
ShaWrapFinalize(  PCHECKSUM_BUFFER pcsBuffer,
                PUCHAR          pbSum);

NTSTATUS
ShaWrapFinish(PCHECKSUM_BUFFER *   ppcsBuffer);



CHECKSUM_FUNCTION csfSHA = {
    KERB_CHECKSUM_SHA1,
    A_SHA_DIGEST_LEN,
    CKSUM_COLLISION,
    ShaWrapInitialize,
    ShaWrapSum,
    ShaWrapFinalize,
    ShaWrapFinish,
    ShaWrapInitializeEx,
    NULL
};

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, ShaWrapInitialize )
#pragma alloc_text( PAGEMSG, ShaWrapSum )
#pragma alloc_text( PAGEMSG, ShaWrapFinalize )
#pragma alloc_text( PAGEMSG, ShaWrapFinish )
#pragma alloc_text( PAGEMSG, ShaWrapInitializeEx )
#endif 

NTSTATUS
ShaWrapInitialize(
    ULONG   dwSeed,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    A_SHA_CTX * pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( A_SHA_CTX ) );
#else
    pContext = LocalAlloc( LMEM_FIXED, sizeof( A_SHA_CTX ) );
#endif

    if ( pContext )
    {
        A_SHAInit( pContext );

        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_NO_MEMORY );
}

NTSTATUS
ShaWrapInitializeEx(
    PUCHAR Seed,
    ULONG SeedLength,
    ULONG MessageType,
    PCHECKSUM_BUFFER *  ppcsBuffer)
{
    A_SHA_CTX * pContext;

#ifdef KERNEL_MODE
    pContext = ExAllocatePool( NonPagedPool, sizeof( A_SHA_CTX ) );
#else
    pContext = LocalAlloc( LMEM_FIXED, sizeof( A_SHA_CTX ) );
#endif

    if ( pContext )
    {
        A_SHAInit( pContext );

        *ppcsBuffer = pContext;

        return( SEC_E_OK );
    }

    return( STATUS_NO_MEMORY );
}


NTSTATUS
ShaWrapSum(
    PCHECKSUM_BUFFER pcsBuffer,
    ULONG           cbData,
    PUCHAR          pbData )
{
    A_SHA_CTX * pContext;

    pContext = (A_SHA_CTX *) pcsBuffer ;

    A_SHAUpdate( pContext, pbData, cbData );

    return( STATUS_SUCCESS );

}


NTSTATUS
ShaWrapFinalize(
    PCHECKSUM_BUFFER pcsBuffer,
    PUCHAR          pbSum)
{
    A_SHA_CTX * pContext;

    pContext = (A_SHA_CTX *) pcsBuffer ;

    A_SHAFinal( pContext, pbSum );

    return( STATUS_SUCCESS );

}

NTSTATUS
ShaWrapFinish(
    PCHECKSUM_BUFFER *   ppcsBuffer)
{

    RtlZeroMemory( *ppcsBuffer, sizeof( A_SHA_CTX ) );

#ifdef KERNEL_MODE
    ExFreePool( *ppcsBuffer );
#else
    LocalFree( *ppcsBuffer );
#endif

    *ppcsBuffer = NULL ;

    return( STATUS_SUCCESS );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\utest\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved


#define UINT4   unsigned long
#define ULONG	unsigned long


#include "md5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static const unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (z ^ (x & (y^z)))	/* optimized version of (((x) & (y)) | ((~x) & (z))) */
#define G(x, y, z) (y ^ (z & (x^y)))	/* optimized version of (((x) & (z)) | ((y) & (~z))) */
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) _rotl((x), (n))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
const unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\rng.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rng.c
//
//  Contents:   Random Number Generator
//
//  Classes:
//
//  Functions:
//
//  History:    5-12-93   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <security.h>

#include <cryptdll.h>
#include <windows.h>
#include <randlib.h>
#include <crypt.h>

#ifdef KERNEL_MODE
int _fltused = 0x9875;
#endif
#ifdef WIN32_CHICAGO
NTSTATUS MyNtQuerySystemTime (PTimeStamp PTime);
#define NtQuerySystemTime(x) (MyNtQuerySystemTime(x))
#endif // WIN32_CHICAGO


BOOLEAN NTAPI   DefaultRngFn(PUCHAR, ULONG);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, DefaultRngFn )
#endif 

#define MAX_RNGS    4

RANDOM_NUMBER_GENERATOR   Rngs[MAX_RNGS];
ULONG                   cRngs = 0;

RANDOM_NUMBER_GENERATOR   DefaultRng = {CD_BUILTIN_RNG,
                                        RNG_PSEUDO_RANDOM,
                                        0,
                                        DefaultRngFn };


BOOLEAN NTAPI
CDGenerateRandomBits(   PUCHAR  pBuffer,
                        ULONG   cbBuffer);

BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng);

BOOLEAN NTAPI
CDLocateRng(ULONG   Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng);

BOOLEAN NTAPI
DefaultRngFn(   PUCHAR      pbBuffer,
                ULONG       cbBuffer);

#ifdef KERNEL_MODE
#pragma alloc_text( PAGEMSG, CDGenerateRandomBits )
#pragma alloc_text( PAGEMSG, CDRegisterRng )
#pragma alloc_text( PAGEMSG, CDLocateRng )
#pragma alloc_text( PAGEMSG, DefaultRngFn )
#endif 


//
// Management functions:
//

BOOLEAN NTAPI
CDGenerateRandomBits(   PUCHAR  pBuffer,
                        ULONG   cbBuffer)
{
    return(Rngs[cRngs-1].GenerateBitstream(pBuffer, cbBuffer));
}


BOOLEAN NTAPI
CDRegisterRng(PRANDOM_NUMBER_GENERATOR    pRng)
{
    if (cRngs < MAX_RNGS)
    {
        Rngs[cRngs++] = *pRng;
        return(TRUE);
    }
    return(FALSE);
}

BOOLEAN NTAPI
CDLocateRng(ULONG   Id,
            PRANDOM_NUMBER_GENERATOR *    ppRng)
{
    ULONG   i;

    for (i = 0; i < MAX_RNGS ; i++ )
    {
        if (Rngs[i].GeneratorId == Id)
        {
            *ppRng = &Rngs[i];
            return(TRUE);
        }
    }

    *ppRng = NULL;
    return(FALSE);

}


#ifndef KERNEL_MODE

#define RND_A   16807
#define RND_M   2147483647
#define RND_Q   127773
#define RND_R   2836

//+-----------------------------------------------------------------------
//
// Function:    Random, private
//
// Synopsis:    Generates a random number [0,1] based on a seed.
//
// Effects:     Modifies seed parameter for multiple calls
//
// Arguments:   [plSeed] -- Pointer to long seed value
//
// Returns:     random number in the range [0,1]
//
// Algorithm:   see CACM, Oct 1988
//
// History:     10 Dec 91   RichardW    Created
//
//------------------------------------------------------------------------

float
Random(ULONG *  plSeed)
{
    long int    lo, hi, test;

    hi = *plSeed / RND_Q;
    lo = *plSeed % RND_Q;
    test = RND_A * lo - RND_R * hi;
    if (test > 0)
    {
        *plSeed = test;
    } else
    {
        *plSeed = test + RND_M;
    }

// This code is correct.  The compiler has a conniption fit about floating
// point constants, so I am forced to disable this warning for this line.

#pragma warning(disable:4056)

    return((float) *plSeed / (float) RND_M);

}
#endif 

BOOLEAN NTAPI
DefaultRngFn(   PUCHAR      pbBuffer,
                ULONG       cbBuffer)
{

    //
    // use the crypto group provided random number generator.
    //
#ifdef WIN32_CHICAGO
    NewGenRandom(NULL, NULL, pbBuffer, cbBuffer);
    return TRUE;
#else

#ifdef KERNEL_MODE
    NewGenRandom(NULL, NULL, pbBuffer, cbBuffer);
    return TRUE;
#else
    return RtlGenRandom( pbBuffer, cbBuffer );
#endif

#endif // WIN32_CHICAGO

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\utest\cryptest.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        cryptest.cxx
//
// Contents:    test program to test encryption functions
//
//
// History:     07-Oct-1996     MikeSw          Created
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define SECURITY_WIN32
#include <security.h>
#include <cryptdll.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <kerbcomm.h>
#include <align.h>
#include "md5.h"
}


typedef enum _CRYPT_ACTIONS {
    HashPassword,
    EncryptData,
    ChecksumData,
    EnumTypes,
    NoAction
} CRYPT_ACTIONS;

VOID
DoMd5(
    PUCHAR Buffer,
    ULONG BufferLength
    )
{
    MD5_CTX Md5Context;
    MD5Init(&Md5Context);
    MD5Update(&Md5Context, Buffer, BufferLength);
    MD5Final(&Md5Context);
}

void _cdecl
main(int argc, char *argv[])
{
    NTSTATUS Status;
    UNICODE_STRING Password;
    UNICODE_STRING User;
    UNICODE_STRING Domain;
    UNICODE_STRING Salt;
    ULONG CryptType = 0;
    ULONG HashType = 0;
    ULONG SumType = 0;
    WCHAR PasswordBuffer[100];
    WCHAR UserBuffer[100];
    WCHAR DomainBuffer[100];
    KERB_ACCOUNT_TYPE AccountType = UserAccount;
    CRYPT_ACTIONS Command = NoAction;
    int Index;
    ULONG uI;
    KERB_ENCRYPTION_KEY Key;
    KERBERR KerbErr;
    ULONG BlockSize;
    ULONG Overhead;
    ULONG BufferLength;
    ULONG ReqBufferLength;
    UCHAR OriginalBuffer[1000];
    PUCHAR EncryptedBuffer = NULL;
    PUCHAR DecryptedBuffer = NULL;
    PCRYPTO_SYSTEM Crypto;
    PCRYPT_STATE_BUFFER StateBuffer = NULL;






    Index = 1;
    while (Index < argc)
    {
        if (_stricmp(argv[Index],"-hash") == 0)
        {
            Command = HashPassword;
            if (argc < Index+1)
            {
                goto Cleanup;
            }
            sscanf(argv[++Index],"%d",&HashType);
        }
        else if (_stricmp(argv[Index],"-pass") == 0)
        {
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            mbstowcs(PasswordBuffer,argv[++Index],100);
            RtlInitUnicodeString(
                &Password,
                PasswordBuffer
                );

        }
        else if (_stricmp(argv[Index],"-user") == 0)
        {
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            mbstowcs(UserBuffer,argv[++Index],100);
            RtlInitUnicodeString(
                &User,
                UserBuffer
                );

        }
        else if (_stricmp(argv[Index],"-domain") == 0)
        {
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            mbstowcs(DomainBuffer,argv[++Index],100);
            RtlInitUnicodeString(
                &Domain,
                DomainBuffer
                );

        }

        else if (_stricmp(argv[Index],"-type") == 0)
        {
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            if (_stricmp(argv[Index+1],"user") == 0)
            {
                AccountType = UserAccount;
            }
            else if (_stricmp(argv[Index+1],"machine") == 0)
            {
                AccountType = MachineAccount;
            }
            else if (_stricmp(argv[Index+1],"domain") == 0)
            {
                AccountType = DomainTrustAccount;
            }
            else
            {
                printf("Illegal account type: %s\n",argv[Index+1]);
                goto Cleanup;
            }

            Index++;
        }

        else if (_stricmp(argv[Index],"-crypt") == 0)
        {
            Command = EncryptData;
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            sscanf(argv[++Index],"%d",&CryptType);
        }
        else if (_stricmp(argv[Index],"-sum") == 0)
        {
            Command = ChecksumData;
            if (argc < Index + 1)
            {
                goto Cleanup;
            }
            sscanf(argv[++Index],"%d",&SumType);
        }
        else if (_stricmp(argv[Index],"-enum") == 0)
        {
            Command = EnumTypes;
        }
        else
        {
            goto Cleanup;
        }
        Index++;
    }
    if (Command == NoAction)
    {
        goto Cleanup;
    }

    switch(Command)
    {
    case EnumTypes:
        break;
    case HashPassword:
        KerbErr = KerbBuildKeySalt(
                    &Domain,
                    &User,
                    AccountType,
                    &Salt
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to build key salt: 0x%x\n",KerbErr);
            goto Cleanup;
        }
        printf("KeySalt = %wZ\n",&Salt);
        KerbErr = KerbHashPasswordEx(
                    &Password,
                    &Salt,
                    HashType,
                    &Key
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to hash password: 0x%x\n",KerbErr);
            goto Exit;
        }
        printf("Hash: ");
        for (uI = 0; uI < Key.keyvalue.length ; uI++ )
        {
            printf("%0.2x ",Key.keyvalue.value[uI]);
        }
        printf("\n");
        break;
    case EncryptData:
        //
        // First hash the password
        //

        KerbErr= KerbHashPassword(
                    &Password,
                    CryptType,
                    &Key
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to hash password: %0x%x\n",KerbErr);
            goto Exit;
        }

        KerbErr = KerbGetEncryptionOverhead(
                    CryptType,
                    &Overhead,
                    &BlockSize
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to get enc overhead: 0x%x\n",KerbErr);
            goto Exit;
        }

        BufferLength = sizeof(OriginalBuffer);

        memset(OriginalBuffer,'A',BufferLength);
#ifdef notdef
        KerbErr = KerbRandomFill(
                    OriginalBuffer,
                    BufferLength
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            printf("Failed to init random buffer: 0x%x\n",KerbErr);
            goto Exit;
        }
#endif
        ReqBufferLength = ROUND_UP_COUNT(BufferLength + Overhead, BlockSize);
        EncryptedBuffer = (PUCHAR) LocalAlloc(LMEM_ZEROINIT, ReqBufferLength);
        if (EncryptedBuffer == NULL)
        {
            printf("Failed to allocate 0x%x bytes: %d\n",ReqBufferLength, GetLastError());
            goto Exit;
        }

        Status = CDLocateCSystem(
                    CryptType,
                    &Crypto
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to locate crypt system 0x%x: 0x%x\n",CryptType,Status);
            goto Exit;
        }

        Status = Crypto->Initialize(
                    Key.keyvalue.value,
                    (ULONG) Key.keyvalue.length,
                    0,          // no options
                    &StateBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("failed to initialize crypto system: 0x%x\n",Status);
            goto Exit;
        }

        Status = Crypto->Encrypt(
                    StateBuffer,
                    OriginalBuffer,
                    BufferLength,
                    EncryptedBuffer,
                    &ReqBufferLength
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to encrypt data: 0x%x\n",Status);
            goto Exit;
        }
        Status = Crypto->Discard(&StateBuffer);
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to discard state buffer: 0x%x\n",Status);
            goto Exit;
        }

        //
        // Now turn around and decrypt it.
        //


        DecryptedBuffer = (PUCHAR) LocalAlloc(LMEM_ZEROINIT, ReqBufferLength);
        if (EncryptedBuffer == NULL)
        {
            printf("Failed to allocate 0x%x bytes: %d\n",ReqBufferLength, GetLastError());
            goto Exit;
        }


        Status = Crypto->Initialize(
                    Key.keyvalue.value,
                    (ULONG) Key.keyvalue.length,
                    0,          // no options
                    &StateBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("failed to initialize crypto system: 0x%x\n",Status);
            goto Exit;
        }

        Status = Crypto->Decrypt(
                    StateBuffer,
                    EncryptedBuffer,
                    ReqBufferLength,
                    DecryptedBuffer,
                    &ReqBufferLength
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to decrypt data: 0x%x\n",Status);
            goto Exit;
        }
        Status = Crypto->Discard(&StateBuffer);
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to discard state buffer: 0x%x\n",Status);
            goto Exit;
        }

        //
        // Now compare
        //

        if (!RtlEqualMemory(
                OriginalBuffer,
                DecryptedBuffer,
                BufferLength
                ))
        {
            printf("Buffers don't match!\n");
        }
        else
        {
            printf("Encryption/decryption succeeded!\n");
        }

        break;
    case ChecksumData:

        BufferLength = sizeof(OriginalBuffer);

        memset(OriginalBuffer,'A',BufferLength);
        DoMd5(OriginalBuffer,BufferLength);

    }


Exit:
    return;

Cleanup:

    printf("Usage: %s { -crypt cryptalg -sum sumtype -hash cryptalg -enum } -pass password\n",
           argv[0]);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\cryptdll\chicago\ntcalls.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntcalls.cxx
//
// Contents:    Code for rtl support on Win95
//
//
// History:     01-April-1997   Created        ChandanS 
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include <security.h>

NTSTATUS
MyRtlUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    oem string. The translation is done with respect to the OEM code
    page (OCP).

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index;
    NTSTATUS st = STATUS_SUCCESS;

    // Get the size required. Being MBCS safe

    Index = WideCharToMultiByte(
             CP_OEMCP,
             0,
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             0,
             NULL, 
             NULL
             );

    OemLength = Index + 1; // Index is not necesarily SourceString->Length/2

    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    if (Index != 0) // If we don't have a string to translate, don't bother
    {
        Index = WideCharToMultiByte(
                     CP_OEMCP,
                     0,
                     SourceString->Buffer,
                     SourceString->Length / sizeof (WCHAR),
                     DestinationString->Buffer,
                     DestinationString->MaximumLength,
                     NULL, 
                     NULL
                     );

        if (Index == 0)
        {   // There was a problem. Save away the error code to return & cleanup

            st = GetLastError();

            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
                DestinationString->Buffer = NULL;
                DestinationString->MaximumLength = 0;
            }

            DestinationString->Length = 0;
        }
    }

    if (DestinationString->Buffer)
    {
        DestinationString->Buffer[Index] = '\0';
    }

    return st;
}

NTSTATUS
MyRtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This function converts the unicode string to an oem string and then
    upper cases it according to the locale specified at install time.

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    NTSTATUS st = STATUS_SUCCESS;

    // On NT, this function is implemented by upper casing the unicode 
    // string and then converting it to an oem string.
    // On Win95, there does not appear to be a way to uppercase unicode 
    // strings taking the locale into account. So, our best bet here 
    // is to convert to an oem string and then do an inplace locale 
    // dependent upper case.

    st = MyRtlUnicodeStringToOemString(DestinationString,
                                       SourceString,
                                       AllocateDestinationString);

    if (st == STATUS_SUCCESS)
    {
        // we may not be able to upper case all chars

        OemLength = CharUpperBuff (DestinationString->Buffer,
                                   DestinationString->Length);

    }

    return st;
}


VOID
MyRtlFreeOemString(
    IN OUT POEM_STRING OemString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToOemString.  Note that only OemString->Buffer
    is free'd by this routine.

Arguments:

    OemString - Supplies the address of the oem string whose buffer
        was previously allocated by RtlUnicodeStringToOemString.

Return Value:

    None.

--*/

{
    if (OemString->Buffer) {
        LocalFree(OemString->Buffer);
        memset( OemString, 0, sizeof( *OemString ) );
        }
}


//
// Inline functions to convert between FILETIME and TimeStamp
//
#pragma warning( disable : 4035)    // Don't complain about no return

TimeStamp __inline
FileTimeToTimeStamp(
    const FILETIME *pft)
{
    _asm {
        mov edx, pft
        mov eax, [edx].dwLowDateTime
        mov edx, [edx].dwHighDateTime
    }
}

#pragma warning( default : 4035)    // Reenable warning

NTSTATUS
MyNtQuerySystemTime (
    OUT PTimeStamp SystemTimeStamp
    )
/*++

Routine Description:

    This routine returns the current system time (UTC), as a timestamp
    (a 64-bit unsigned integer, in 100-nanosecond increments).

Arguments:

    None.

Return Value:

    The current system time.

--*/

{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);

    *SystemTimeStamp = FileTimeToTimeStamp(&FileTime);

    return STATUS_SUCCESS; // WIN32_CHICAGO do something useful here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\dbgtool\dialogs.h ===
#define IDD_DEBUG_TOOL              100
#define IDD_MODULE_BOX              101
#define IDD_CHECK_BOX               102
#define IDD_CHECK_0                 104
#define IDD_CHECK_1                 105
#define IDD_CHECK_2                 106
#define IDD_CHECK_3                 107
#define IDD_CHECK_4                 108
#define IDD_DEBUG_LB                103
#define IDD_CHECK_5                 109
#define IDD_CHECK_6                 110
#define IDD_CHECK_7                 111
#define IDD_CHECK_8                 112
#define IDD_CHECK_9                 113
#define IDD_CHECK_10                114
#define IDD_CHECK_11                115
#define IDD_CHECK_12                116
#define IDD_CHECK_13                117
#define IDD_CHECK_14                118
#define IDD_CHECK_15                119
#define IDD_CHECK_16                120
#define IDD_CHECK_17                121
#define IDD_CHECK_18                122
#define IDD_CHECK_19                123
#define IDD_CHECK_20                124
#define IDD_CHECK_21                125
#define IDD_CHECK_22                126
#define IDD_CHECK_23                127
#define IDD_CHECK_24                128
#define IDD_CHECK_25                129
#define IDD_CHECK_26                130
#define IDD_CHECK_27                131
#define IDD_CHECK_28                132
#define IDD_CHECK_29                133
#define IDD_CHECK_30                134
#define IDD_CHECK_31                135
#define IDD_APPLY                   137
#define IDD_TOTAL_WRITTEN_TEXT      136
#define IDD_TOTAL_OUTPUT            138
#define IDD_MODULE_TEXT             139
#define IDD_MODULE_OUTPUT           140
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\debuglib\dbglibp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dbglibp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-01-95   RichardW   Created
//
//----------------------------------------------------------------------------

//
// Common defines for the debug library
//

extern  SECURITY_DESCRIPTOR DbgpPartySd;
extern  BOOL                DbgpPartySdInit;
extern  PDebugHeader        DbgpHeader;
extern  DebugModule         __CompatModule;
extern  DebugHeader         __CompatHeader;

extern  DebugModule *       __pCompatModule;
extern  DebugModule *       __pExceptionModule;
extern  DebugModule *       __pAssertModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\debuglib\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

SECURITY_DESCRIPTOR DbgpPartySd;
BOOL                DbgpPartySdInit = FALSE;
PDebugHeader        DbgpHeader = NULL;

DebugModule * *     DbgpFixupModules[] = {  &__pAssertModule,
                                            &__pExceptionModule,
                                            NULL };

CHAR                szDebugSection[] = "DSysDebug";
CHAR                szDebugFlags[] = "DebugFlags";

DEBUG_KEY           DbgpKeys[] = { {DEBUG_NO_DEBUGIO,   "NoDebugger"},
                                   {DEBUG_TIMESTAMP,    "TimeStamp"},
                                   {DEBUG_DEBUGGER_OK,  "DebuggerOk"},
                                   {DEBUG_LOGFILE,      "Logfile"},
                                   {DEBUG_AUTO_DEBUG,   "AutoDebug"},
                                   {DEBUG_USE_KDEBUG,   "UseKD"},
                                   {DEBUG_HEAP_CHECK,   "HeapCheck"},
                                   {DEBUG_MULTI_THREAD, "MultiThread"},
                                   {DEBUG_DISABLE_ASRT, "DisableAssert"},
                                   {DEBUG_PROMPTS,      "AssertPrompts"},
                                   {DEBUG_BREAK_ON_ERROR,"BreakOnError"},
                                   {0,                  NULL }
                                 };

#define DEBUG_NUMBER_OF_KEYS    ((sizeof(DbgpKeys) / sizeof(DEBUG_KEY)) - 1)

#define _ALIGN(x,a) (x & (a-1) ? (x + a) & ~(a - 1) : x);

#define ALIGN_8(x)  _ALIGN(x, 8)
#define ALIGN_16(x) _ALIGN(x, 16)

#ifdef WIN64
#define DBG_ALIGN   ALIGN_16
#else 
#define DBG_ALIGN   ALIGN_8
#endif 

#define DEBUGMEM_ALLOCATED  0x00000001

typedef struct _DebugMemory {
    struct _DebugMemory *   pNext;
    DWORD                   Size;
    DWORD                   Flags;
} DebugMemory, * PDebugMemory;


#ifdef DEBUG_DEBUG
#define LockDebugHeader(p)      EnterCriticalSection(&((p)->csDebug)); OutputDebugStringA("Lock")
#define UnlockDebugHeader(p)    LeaveCriticalSection(&((p)->csDebug)); OutputDebugStringA("Unlock")
#else
#define LockDebugHeader(p)      EnterCriticalSection(&((p)->csDebug))
#define UnlockDebugHeader(p)    LeaveCriticalSection(&((p)->csDebug))
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DbgpComputeMappingName
//
//  Synopsis:   Computes the mapping object name
//
//  Arguments:  [pszName] -- place to stick the name (no more than 32 wchars)
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
DbgpComputeMappingName(PWSTR    pszName)
{
    swprintf(pszName, TEXT("Debug.Memory.%x"), GetCurrentProcessId());
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpInitializeMM
//
//  Synopsis:   Initializes our simple memory manager within the shared mem
//              section.
//
//  Arguments:  [pHeader] -- Header to initialize
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpInitializeMM(PDebugHeader   pHeader)
{
    PDebugMemory    pMem;

    pMem = (PDebugMemory) (pHeader + 1);
    pMem->pNext = NULL;
    pMem->Size = pHeader->CommitRange - (sizeof(DebugHeader) + sizeof(DebugMemory));
    pHeader->pFreeList = pMem;
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpAlloc
//
//  Synopsis:   Very, very simple allocator
//
//  Arguments:  [pHeader] -- Header from which to allocate
//              [cSize]   -- size to allocate
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
DbgpAlloc(
    PDebugHeader    pHeader,
    DWORD           cSize)
{
    PDebugMemory    pSearch;
    PDebugMemory    pLargest = NULL;
    PDebugMemory    pNew;
    DWORD           cLargest;

    cLargest = 0;
    cSize = DBG_ALIGN(cSize);

    //
    // Very, very simple allocator.  Search free list for an exact match,
    //

    pSearch = (PDebugMemory) pHeader->pFreeList;
    while (pSearch)
    {
        if ( ( pSearch->Flags & DEBUGMEM_ALLOCATED ) == 0 )
        {
            if ( pSearch->Size == cSize )
            {
                break;
            }

            if (pSearch->Size > cLargest)
            {
                pLargest = pSearch;
                cLargest = pSearch->Size;
            }
            
        }

        pSearch = pSearch->pNext;

    }

    //
    // If no match yet
    //

    if (!pSearch)
    {
        //
        // If the largest free block is still too small,
        //

        if (cLargest < (cSize + sizeof(DebugMemory) * 2))
        {
            //
            // Extend the mapped range
            //
            if (pHeader->CommitRange < pHeader->ReserveRange)
            {
                if ( VirtualAlloc(
                            (PUCHAR) pHeader + pHeader->CommitRange,
                            pHeader->PageSize,
                            MEM_COMMIT,
                            PAGE_READWRITE ) )
                {
                    pNew = (PDebugMemory) ((PUCHAR) pHeader + pHeader->CommitRange );
                    pHeader->CommitRange += pHeader->PageSize ;
                    pNew->Size = pHeader->PageSize - sizeof( DebugMemory );
                    pNew->pNext = pHeader->pFreeList ;
                    pHeader->pFreeList = pNew ;

                    return DbgpAlloc( pHeader, cSize );
                }
                else 
                {
                    return NULL ;
                }
            }
            return(NULL);
        }

        //
        // Otherwise, split the largest block into something better...
        //

        pNew = (PDebugMemory) ((PUCHAR) pLargest + (cSize + sizeof(DebugMemory)) );

        pNew->Size = pLargest->Size - (cSize + sizeof(DebugMemory) * 2);
        pNew->pNext = pLargest->pNext ;
        pNew->Flags = 0;

        pLargest->Size = cSize;
        pLargest->Flags |= DEBUGMEM_ALLOCATED;
        pLargest->pNext = pNew;

        return((PVOID) (pLargest + 1) );
    }
    else
    {
        pSearch->Flags |= DEBUGMEM_ALLOCATED ;

        return((PVOID) (pSearch + 1) );
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpFree
//
//  Synopsis:   Returns memory to the shared mem segment
//
//  Arguments:  [pHeader] -- Shared memory header
//              [pMemory] -- Memory to free
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:      No compaction.
//
//----------------------------------------------------------------------------
VOID
DbgpFree(
    PDebugHeader    pHeader,
    PVOID           pMemory)
{
    PDebugMemory    pMem;

    pMem = (PDebugMemory) ((PUCHAR) pMemory - sizeof(DebugMemory));
    pMem->Flags &= ~DEBUGMEM_ALLOCATED;
    ZeroMemory( pMemory, pMem->Size );
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpFindModule
//
//  Synopsis:   Locates a module based on a name
//
//  Arguments:  [pHeader] -- Header to search
//              [pszName] -- module to find
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDebugModule
DbgpFindModule(
    PDebugHeader    pHeader,
    CHAR *          pszName)
{
    PDebugModule    pSearch;

    pSearch = pHeader->pModules;
    while (pSearch)
    {
        if (_strcmpi(pSearch->pModuleName, pszName) == 0)
        {
            return(pSearch);
        }
        pSearch = pSearch->pNext;
    }

    return(NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpCopyModule
//
//  Synopsis:   Copies a module into a new module.  Used for the builtins.
//              note, no references to the code module that the builtin lived
//              in is kept.  This way, the module can unload.
//
//  Arguments:  [pHeader] --
//              [pSource] --
//              [ppDest]  --
//
//  Requires:   Header must be locked.
//
//  Returns:    0 for failure, non-zero for success
//
//  History:    7-19-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpCopyModule(
    PDebugHeader    pHeader,
    PDebugModule    pSource,
    PDebugModule *  ppDest)
{
    PDebugModule    pModule;
    DWORD           i;
    DWORD           cStringSpace;
    PCHAR           pStrings;

    *ppDest = NULL;

    cStringSpace = strlen(pSource->pModuleName) + 1;

    for (i = 0; i < 32 ; i++ )
    {
        if (pSource->TagLevels[i])
        {
            cStringSpace += (strlen(pSource->TagLevels[i]) + 1);
        }
    }

    //
    // Allocate an extra DWORD to store the infolevel.
    //

    pModule = DbgpAlloc(pHeader, sizeof(DebugModule) + sizeof( DWORD ) );
    if (!pModule)
    {
        return(0);
    }

    pStrings = DbgpAlloc(pHeader, cStringSpace);

    if ( !pStrings )
    {
        DbgpFree( pHeader, pModule );

        return 0 ;
    }

    pModule->pModuleName = pStrings;

    cStringSpace = strlen(pSource->pModuleName) + 1;

    strcpy(pModule->pModuleName, pSource->pModuleName);

    pStrings += cStringSpace;

    for (i = 0; i < 32 ; i++ )
    {
        if (pSource->TagLevels[i])
        {
            pModule->TagLevels[i] = pStrings;
            cStringSpace = strlen(pSource->TagLevels[i]) + 1;
            strcpy(pStrings, pSource->TagLevels[i]);
            pStrings += cStringSpace;
        }
        else
        {
            pSource->TagLevels[i] = NULL;
        }
    }

    //
    // Add this in to the global list
    //
    pModule->pNext = pHeader->pModules;
    pHeader->pModules = pModule;

    //
    // Do not increment module count - this is a builtin
    //

    //
    // Copy the rest of the interesting stuff
    //
    pModule->pInfoLevel = (PDWORD) (pModule + 1);
    *pModule->pInfoLevel = *pSource->pInfoLevel;

    pModule->InfoLevel = pSource->InfoLevel;
    pModule->fModule = pSource->fModule | DEBUGMOD_BUILTIN_MODULE ;
    pModule->pHeader = pHeader;
    pModule->TotalOutput = pSource->TotalOutput;
    pModule->Reserved = 0;

    *ppDest = pModule;

    return(1);

}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpAttachBuiltinModules
//
//  Synopsis:   Attaches the builtin library modules to the global shared
//              list
//
//  Arguments:  [pHeader] --
//
//  History:    7-19-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DbgpAttachBuiltinModules(
    PDebugHeader    pHeader)
{
    PDebugModule    pModule;
    PDebugModule    pFixup;
    DWORD           i;
    BOOL            Success = FALSE;

    i = 0;
    while (DbgpFixupModules[i])
    {
        pFixup = *DbgpFixupModules[i];

        pModule = DbgpFindModule(pHeader, pFixup->pModuleName);
        if (pModule)
        {
            *DbgpFixupModules[i] = pModule;
            Success = TRUE;
        }
        else
        {
            if (DbgpCopyModule(pHeader, pFixup, &pModule))
            {
                *DbgpFixupModules[i] = pModule;
                Success = TRUE;
            }

        }

        i++;
    }

    return(Success);

}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpBuildModule
//
//  Synopsis:   Initializes a Module, builds the string table
//
//  Arguments:  [pModule]    -- Module pointer
//              [pHeader]    -- Header
//              [pKeys]      -- Key table
//              [pszName]    -- Name
//              [pInfoLevel] -- Pointer to info level
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpBuildModule(
    PDebugModule    pModule,
    PDebugHeader    pHeader,
    PDEBUG_KEY      pKeys,
    PCHAR           pszName,
    PDWORD          pInfoLevel)
{
    PCHAR           pStringData;
    DWORD           cStringData;
    DWORD           cKeys;
    DWORD           i;
    DWORD           KeyIndex;
    DWORD           BitScan;


    //
    // Easy stuff to start..
    //

    pModule->pInfoLevel = pInfoLevel;
    pModule->pHeader = pHeader;


    cStringData = strlen(pszName) + 1;

    //
    // Search through the list of masks and string tags, computing
    // the size needed for containing them all.  If a tag has more
    // than one bit set, reject it.
    //
    for (i = 0; i < 32 ; i++ )
    {
        if (pKeys[i].Mask)
        {
            if (pKeys[i].Mask & (pKeys[i].Mask - 1))
            {
                continue;
            }
        }
        if (pKeys[i].Tag)
        {
            cStringData += strlen(pKeys[i].Tag) + 1;
        }
        else
        {
            break;
        }
    }

    //
    // We know how many keys there are, and how big a space they need.
    //
    cKeys = i;

    pStringData = DbgpAlloc(pHeader, cStringData);

    if ( !pStringData )
    {
        return 0 ;
    }

    pModule->pModuleName = pStringData;
    strcpy(pStringData, pszName);
    pStringData += strlen(pStringData) + 1;

    for (i = 0, KeyIndex = 0; i < cKeys ; i++ )
    {
        if (pKeys[i].Mask & (pKeys[i].Mask - 1))
        {
            continue;
        }

        if (!(pKeys[i].Mask & (1 << KeyIndex)))
        {
            //
            // Grr, out of order.  Do a bit-wise scan.
            //

            KeyIndex = 0;
            BitScan = 1;
            while ((pKeys[i].Mask & BitScan) == 0)
            {
                BitScan <<= 1;
                KeyIndex ++;
            }
        }

        pModule->TagLevels[KeyIndex] = pStringData;
        strcpy(pStringData, pKeys[i].Tag);
        pStringData += strlen(pKeys[i].Tag) + 1;

        KeyIndex++;
    }

    return(cKeys);
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpGetBitmask
//
//  Synopsis:   Based on a parameter line and a key table, builds the bitmask
//
//  Arguments:  [pKeys]          --
//              [cKeys]          --
//              [pszLine]        --
//              [ParameterIndex] --
//              [ParameterValue] --
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DbgpGetBitmask(
    DEBUG_KEY *     pKeys,
    DWORD           cKeys,
    PCHAR           pszLine,
    DWORD           ParameterIndex,
    PCHAR           ParameterValue)
{
    PCHAR   pszSearch;
    PCHAR   pszParam;
    PCHAR   pszScan;
    DWORD   i;
    DWORD   Mask;
    DWORD   cbParameter = 0;
    DWORD   Compare;
    CHAR    Saved;


    if (ParameterIndex < cKeys)
    {
        cbParameter = strlen(pKeys[ParameterIndex].Tag);
    }

    Mask = 0;

    pszSearch = pszLine;

    //
    // Scan through the line, searching for flags.  Note:  do NOT use strtok,
    // since that is not exported by ntdll, and we would not be able to make
    // security.dll
    //

    while (*pszSearch)
    {
        pszScan = pszSearch;
        while ((*pszScan) && (*pszScan != ','))
        {
            pszScan++;
        }
        Saved = *pszScan;
        *pszScan = '\0';

        for (i = 0; i < cKeys ; i++ )
        {
            if (i == ParameterIndex)
            {
                if (_strnicmp(pKeys[i].Tag, pszSearch, cbParameter) == 0)
                {
                    pszParam = strchr(pszSearch, ':');
                    if (pszParam)
                    {
                        strcpy(ParameterValue, pszParam+1);
                    }
                    Mask |= pKeys[i].Mask;
                }

            }
            else
            {
                if (_strcmpi(pKeys[i].Tag, pszSearch) == 0)
                {
                    Mask |= pKeys[i].Mask;
                }

            }
        }

        *pszScan = Saved;
        if (Saved)
        {
            while ((*pszScan) && ((*pszScan == ',') || (*pszScan == ' ')))
            {
                pszScan++;
            }
        }
        pszSearch = pszScan;
    }

    return(Mask);

}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpInitializeDebug
//
//  Synopsis:   Initialize the base memory
//
//  Arguments:  [pHeader] --
//
//  History:    4-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpInitializeDebug(
    PDebugHeader    pHeader)
{
    CHAR    szExeName[MAX_PATH];
    PCHAR   pszExeName;
    PCHAR   dot;
    DWORD   cbExeName;
    CHAR    LogFile[MAX_PATH];
    CHAR    Line[MAX_PATH];
    SECURITY_ATTRIBUTES sa;
    PDebugModule    pModule;
    HANDLE Token ;
    TOKEN_STATISTICS TokenStat ;
    ULONG Size ;
    LUID LocalSys = SYSTEM_LUID ;


    //
    // Plug the debug section in first
    //

    pModule = DbgpAlloc(pHeader, sizeof(DebugModule));
    if (!pModule)
    {
        return;
    }

    DbgpBuildModule(pModule,
                    pHeader,
                    DbgpKeys,
                    DEBUG_MODULE_NAME,
                    &pHeader->fDebug);

    GetModuleFileNameA(NULL, szExeName, MAX_PATH);
    pszExeName = strrchr(szExeName, '\\');
    if (pszExeName)
    {
        pszExeName++;
    }
    else
    {
        pszExeName = szExeName;
    }

    dot = strrchr(pszExeName, '.');
    if (dot)
    {
        *dot = '\0';
    }

    cbExeName = (DWORD) (dot - pszExeName);
    pHeader->pszExeName = DbgpAlloc(pHeader, cbExeName + 1);
    if (pHeader->pszExeName)
    {
        strcpy(pHeader->pszExeName, pszExeName);
    }

    LogFile[0] = '\0';

    if (GetProfileStringA(  szDebugSection,
                            pszExeName,
                            "",
                            Line,
                            MAX_PATH))
    {
        pHeader->fDebug = DbgpGetBitmask(   DbgpKeys,
                                            DEBUG_NUMBER_OF_KEYS,
                                            Line,
                                            3,
                                            LogFile);

    }

    //
    // If running as local system, turn on the kd flag.  That
    // way,

    if ( OpenProcessToken( GetCurrentProcess(),
                           TOKEN_QUERY,
                           &Token ) )
    {
        if ( GetTokenInformation( Token,
                                  TokenStatistics,
                                  &TokenStat,
                                  sizeof( TokenStat ),
                                  &Size ) )
        {
            if ( (TokenStat.AuthenticationId.LowPart == LocalSys.LowPart ) &&
                 (TokenStat.AuthenticationId.HighPart == LocalSys.HighPart ) )
            {
                pHeader->fDebug |= DEBUG_USE_KDEBUG ;
            }
        }

        CloseHandle( Token );
    }

    if (GetProfileStringA(  szDebugSection,
                            szDebugFlags,
                            "",
                            Line,
                            MAX_PATH))
    {
        pHeader->fDebug |= DbgpGetBitmask(  DbgpKeys,
                                            DEBUG_NUMBER_OF_KEYS,
                                            Line,
                                            3,
                                            LogFile);

    }

    if ( pHeader->fDebug & DEBUG_USE_KDEBUG )
    {
        //
        // Verify that there is a kernel debugger
        //

        SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo ;
        NTSTATUS Status ;

        Status = NtQuerySystemInformation(
                    SystemKernelDebuggerInformation,
                    &KdInfo,
                    sizeof( KdInfo ),
                    NULL );

        if ( NT_SUCCESS( Status ) )
        {
            if ( !KdInfo.KernelDebuggerEnabled )
            {
                pHeader->fDebug &= ~(DEBUG_USE_KDEBUG) ;
            }
        }

    }

    if (pHeader->fDebug & DEBUG_LOGFILE)
    {
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = &DbgpPartySd;
        sa.bInheritHandle = FALSE;

        if (LogFile[0] == '\0')
        {
            strcpy(LogFile, szExeName);
            strcat(LogFile, ".log");
        }
        pHeader->hLogFile = CreateFileA(LogFile,
                                        GENERIC_READ | GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        &sa,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL |
                                        FILE_FLAG_WRITE_THROUGH,
                                        NULL);

    }

    pHeader->pModules = pModule;
    pHeader->pGlobalModule = pModule;
    pModule->pInfoLevel = &pHeader->fDebug;
    pModule->InfoLevel = pHeader->fDebug;

    DbgpAttachBuiltinModules(pHeader);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpOpenLogFileRandom
//
//  Synopsis:   Opens the logfile dynamically
//
//  Arguments:  [pHeader] --
//
//  History:    4-27-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DbgpOpenLogFileRandom(
    PDebugHeader        pHeader)
{
    WCHAR   szLogPath[MAX_PATH];
    DWORD   dwPath;
    PWSTR   pszDot;
    SECURITY_ATTRIBUTES sa;

    dwPath = GetModuleFileName(NULL, szLogPath, MAX_PATH);

    pszDot = wcsrchr(szLogPath, L'.');
    if (!pszDot)
    {
        pszDot = &szLogPath[dwPath];
    }

    wcscpy(pszDot, L".log");

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &DbgpPartySd;
    sa.bInheritHandle = FALSE;

    LockDebugHeader(pHeader);

    pHeader->hLogFile = CreateFileW(szLogPath,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    &sa,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL |
                                    FILE_FLAG_WRITE_THROUGH,
                                    NULL);

    if (pHeader->hLogFile == INVALID_HANDLE_VALUE)
    {
        pHeader->fDebug &= ~(DEBUG_LOGFILE);
        UnlockDebugHeader(pHeader);
        return(FALSE);
    }
    UnlockDebugHeader(pHeader);

    return(TRUE);
}



//+---------------------------------------------------------------------------
//
//  Function:   DbgpOpenOrCreateSharedMem
//
//  Synopsis:   Returns a pointer to the shared memory segment,
//              creating it if necessary.  Header is LOCKED on return
//
//  Arguments:  (none)
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
DbgpOpenOrCreateSharedMem(DWORD Flags)
{
    HANDLE              hMapping;
    WCHAR               szMappingName[32];
    SECURITY_ATTRIBUTES sa;
    PDebugHeader        pHeader;
    SYSTEM_INFO         SysInfo;


    if (!DbgpPartySdInit)
    {
        InitializeSecurityDescriptor(&DbgpPartySd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&DbgpPartySd, TRUE, NULL, FALSE);
        DbgpPartySdInit = TRUE;
    }

    if (DbgpHeader)
    {
        LockDebugHeader(DbgpHeader);
        return(DbgpHeader);
    }

    GetSystemInfo(&SysInfo);

    DbgpComputeMappingName(szMappingName);
    hMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS,
                                FALSE,
                                szMappingName);

    if (hMapping)
    {
        //
        // Ok, someone else has created the section.  So, we just need to map
        // it.
        //

        pHeader = MapViewOfFileEx(  hMapping,
                                    FILE_MAP_READ | FILE_MAP_WRITE,
                                    0,
                                    0,
                                    SysInfo.dwPageSize,
                                    NULL);

        if ( pHeader )
        {
            if (pHeader != pHeader->pvSection)
            {
                DbgpHeader = pHeader->pvSection;
            }
            else
            {
                DbgpHeader = pHeader;
            }
            
            UnmapViewOfFile(pHeader);
        }
        else
        {

            DbgpHeader = NULL ;
        }


        //
        // Now that we have the other guy's address, we can throw away this
        // one.
        //
        CloseHandle(hMapping);

        if ( DbgpHeader )
        {
            LockDebugHeader(DbgpHeader);

            DbgpAttachBuiltinModules(DbgpHeader);
            
        }


        return(DbgpHeader);

    }

    if (Flags & DSYSDBG_OPEN_ONLY)
    {
        return(NULL);
    }


    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &DbgpPartySd;
    sa.bInheritHandle = FALSE;

    hMapping = CreateFileMapping(   INVALID_HANDLE_VALUE,
                                    NULL, //&sa,
                                    PAGE_READWRITE | SEC_RESERVE,
                                    0,
                                    SysInfo.dwAllocationGranularity,
                                    szMappingName);
    if (hMapping)
    {
        pHeader = MapViewOfFileEx(hMapping,
                                FILE_MAP_READ | FILE_MAP_WRITE,
                                0,
                                0,
                                SysInfo.dwAllocationGranularity,
                                NULL);

        if (!pHeader)
        {
            return(NULL);
        }

        //
        // Commit the view, so we can initialize the header
        //

        pHeader = (PDebugHeader) VirtualAlloc(  pHeader,
                                                SysInfo.dwPageSize,
                                                MEM_COMMIT,
                                                PAGE_READWRITE);

        pHeader->Tag = DEBUG_TAG;
        pHeader->pvSection = pHeader;
        pHeader->hMapping = hMapping;
        pHeader->hLogFile = INVALID_HANDLE_VALUE;
        pHeader->CommitRange = SysInfo.dwPageSize;
        pHeader->ReserveRange = SysInfo.dwAllocationGranularity;
        pHeader->PageSize = SysInfo.dwPageSize;
        pHeader->pModules = NULL;
        pHeader->pFreeList = NULL;
        pHeader->pBufferList = &pHeader->DefaultBuffer ;
        pHeader->DefaultBuffer.Next = NULL ;

        InitializeCriticalSection(&pHeader->csDebug);

        LockDebugHeader(pHeader);

        DbgpInitializeMM(pHeader);
        DbgpInitializeDebug(pHeader);

        DbgpHeader = pHeader;

        return(pHeader);
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpLoadValidateRoutine
//
//  Synopsis:   Loads RtlValidateProcessHeaps() from ntdll
//
//  Arguments:  [pHeader] --
//
//  History:    5-02-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpLoadValidateRoutine(PDebugHeader    pHeader)
{
    HMODULE hNtDll;

    hNtDll = LoadLibrary(TEXT("ntdll.dll"));
    if (hNtDll)
    {
        pHeader->pfnValidate = (HEAPVALIDATE) GetProcAddress(hNtDll, "RtlValidateProcessHeaps");
        if (!pHeader->pfnValidate)
        {
            pHeader->fDebug &= ~(DEBUG_HEAP_CHECK);
        }

        //
        // We can safely free this handle, since kernel32 and advapi32 DLLs
        // both use ntdll, so the refcount won't go to zero.
        //
        FreeLibrary(hNtDll);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _InitDebug
//
//  Synopsis:   Workhorse of the initializers
//
//  Arguments:  [pInfoLevel]     -- Pointer to module specific infolevel
//              [ppControlBlock] -- Pointer to module specific control pointer
//              [szName]         -- Name
//              [pKeys]          -- Key data
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
_InitDebug(
    DWORD       Flags,
    DWORD *     pInfoLevel,
    PVOID *     ppControlBlock,
    CHAR *      szName,
    PDEBUG_KEY  pKeys)
{
    PDebugHeader    pHeader;
    PDebugModule    pModule;
    CHAR            Line[MAX_PATH];
    DWORD           cKeys;
    DWORD           i;

    if ( (*ppControlBlock) && (*ppControlBlock != INVALID_HANDLE_VALUE) )
    {
        //
        // Already Initialized
        //
        return ;
    }

    *ppControlBlock = NULL;

    //
    // Find the shared section.
    //

    pHeader = DbgpOpenOrCreateSharedMem(Flags);

    if (!pHeader)
    {
        if (Flags & DSYSDBG_DEMAND_OPEN)
        {
            *ppControlBlock = (PVOID) INVALID_HANDLE_VALUE;
        }
        return;
    }

    //
    // See if we have already registered (dll being loaded several times)
    // if not, allocate a new module.
    //

    pModule = DbgpFindModule(pHeader, szName);
    if (!pModule)
    {
        pModule = DbgpAlloc(pHeader, sizeof(DebugModule) );
        if (!pModule)
        {
            UnlockDebugHeader(pHeader);
            return;
        }
    }
    else
    {
        //
        // Found module already loaded.  Check to see that everything
        // lines up:
        //

        if ( pModule->pInfoLevel != pInfoLevel )
        {
            //
            // Uh oh, there's a module with our name already loaded,
            // but the pointers don't match.  So, let's create our
            // own now.
            //

            pModule = DbgpAlloc( pHeader, sizeof( DebugModule ) );

            if ( !pModule )
            {
                UnlockDebugHeader( pHeader );
                return;
            }
        }
        else 
        {
            *ppControlBlock = pModule;
            UnlockDebugHeader(pHeader);
            return;

        }

    }


    //
    // Initialize module
    //
    cKeys = DbgpBuildModule(pModule,
                            pHeader,
                            pKeys,
                            szName,
                            pInfoLevel);


    //
    // Now, load up info levels from ini or registry
    // First, try a module specific entry.
    //

    if (GetProfileStringA(szName, szDebugFlags, "", Line, MAX_PATH))
    {
        pModule->InfoLevel = DbgpGetBitmask(pKeys,
                                            cKeys,
                                            Line,
                                            0xFFFFFFFF,
                                            NULL );
    }

    if (pHeader->pszExeName)
    {
        if (GetProfileStringA(szName, pHeader->pszExeName, "", Line, MAX_PATH))
        {
            pModule->InfoLevel = DbgpGetBitmask(pKeys,
                                                cKeys,
                                                Line,
                                                0xFFFFFFFF,
                                                NULL );

        }
    }

    //  HACK - Make Default DBG / DEBUG_SUPPORT dependent.  See dsysdbg.h
    if (GetProfileStringA(szDebugSection, szName, SZ_DEFAULT_PROFILE_STRING, Line, MAX_PATH))
    {
        pModule->InfoLevel |= DbgpGetBitmask(   pKeys,
                                                cKeys,
                                                Line,
                                                0xFFFFFFFF,
                                                NULL );

    }

    *pModule->pInfoLevel = pModule->InfoLevel;

    pModule->pNext = pHeader->pModules;
    pHeader->pModules = pModule;
    pHeader->ModuleCount++ ;
    *ppControlBlock = pModule;

    UnlockDebugHeader(pHeader);
}

VOID
_UnloadDebug(
    PVOID pControlBlock
    )
{
    PDebugHeader    pHeader;
    PDebugModule    pModule;
    PDebugModule    pScan ;
    BOOL FreeIt = FALSE ;

    pModule = (PDebugModule) pControlBlock ;

    if ( !pModule )
    {
        return ;
    }

    if ( pModule->pInfoLevel == NULL )
    {
        return ;
    }

    pHeader = pModule->pHeader ;

    LockDebugHeader( pHeader );

    pScan = pHeader->pModules ;

    if ( pScan == pModule )
    {
        pHeader->pModules = pModule->pNext ;
    }
    else 
    {
        while ( pScan && ( pScan->pNext != pModule ) )
        {
            pScan = pScan->pNext ;
        }

        if ( pScan )
        {
            pScan->pNext = pModule->pNext ;
        }

        pModule->pNext = NULL ;
    }

    DbgpFree( pHeader, pModule->pModuleName );

    DbgpFree( pHeader, pModule );

    pHeader->ModuleCount-- ;

    if ( pHeader->ModuleCount == 0 )
    {
        FreeIt = TRUE ;
    }

    UnlockDebugHeader( pHeader );

    if ( FreeIt )
    {
        if ( pHeader->hLogFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( pHeader->hLogFile );
        }

        if ( pHeader->hMapping )
        {
            CloseHandle( pHeader->hMapping );
        }

        DeleteCriticalSection( &pHeader->csDebug );

        UnmapViewOfFile( pHeader );

    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DbgpGetTextBuffer
//
//  Synopsis:   Gets a text buffer from the header, allocating if necessary
//
//  Arguments:  [pHeader] --
//
//  History:    3-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDEBUG_TEXT_BUFFER
DbgpGetTextBuffer(
    PDebugHeader pHeader
    )
{
    PDEBUG_TEXT_BUFFER pBuffer ;

    LockDebugHeader( pHeader );

    if ( pHeader->pBufferList )
    {
        pBuffer = pHeader->pBufferList ;

        pHeader->pBufferList = pBuffer->Next ;

    }
    else
    {
        pBuffer = DbgpAlloc( pHeader, sizeof( DEBUG_TEXT_BUFFER ) );
    }

    UnlockDebugHeader( pHeader );

    if ( pBuffer )
    {
        pBuffer->Next = NULL ;
    }

    return pBuffer ;
}

//+---------------------------------------------------------------------------
//
//  Function:   DbgpReleaseTextBuffer
//
//  Synopsis:   Releases a text buffer back to the pool of buffers
//
//  Arguments:  [pHeader] --
//              [pBuffer] --
//
//  History:    3-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
DbgpReleaseTextBuffer(
    PDebugHeader pHeader,
    PDEBUG_TEXT_BUFFER pBuffer
    )
{
    LockDebugHeader( pHeader );

    pBuffer->Next = pHeader->pBufferList ;

    pHeader->pBufferList = pBuffer ;

    UnlockDebugHeader( pHeader );
}

//+---------------------------------------------------------------------------
//
//  Function:   _DebugOut
//
//  Synopsis:   Workhorse for the debug out functions
//
//  Arguments:  [pControl] -- Control pointer
//              [Mask]     -- Event mask
//              [Format]   -- format string
//              [ArgList]  -- va_list...
//
//  History:    3-22-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
_DebugOut(
    PVOID       pControl,
    ULONG       Mask,
    CHAR *      Format,
    va_list     ArgList)
{
    PDebugModule pModule;
    int          Level = 0;
    int          PrefixSize = 0;
    int          TotalSize;
    BOOL         fLocked;
    BOOL         fClean;
    PCHAR        Tag;
    BOOL         Break = FALSE ;
    PDEBUG_TEXT_BUFFER pBuffer ;

    if ( pControl == NULL )
    {
        return ;
    }

    pModule = (PDebugModule) pControl;

    if ( pModule->pInfoLevel == NULL )
    {
        return ;
    }

    if (!pModule || (pModule == INVALID_HANDLE_VALUE))
    {
        if (Mask & DSYSDBG_FORCE)
        {
            NOTHING ;
        }
        else
            return;
    }

    if (pModule->fModule & DEBUGMOD_CHANGE_INFOLEVEL)
    {
        *pModule->pInfoLevel = pModule->InfoLevel;
        pModule->fModule &= ~(DEBUGMOD_CHANGE_INFOLEVEL);
    }

    if (pModule->pHeader->pGlobalModule->fModule & DEBUGMOD_CHANGE_INFOLEVEL)
    {
        pModule->pHeader->fDebug = pModule->pHeader->pGlobalModule->InfoLevel;
        pModule->pHeader->pGlobalModule->fModule &= ~(DEBUGMOD_CHANGE_INFOLEVEL);
    }

    pModule->InfoLevel = *pModule->pInfoLevel;

    if (pModule->pHeader->fDebug & DEBUG_MULTI_THREAD)
    {
        LockDebugHeader(pModule->pHeader);
        fLocked = TRUE;
    }
    else
        fLocked = FALSE;


    if (pModule->pHeader->fDebug & DEBUG_HEAP_CHECK)
    {
        if (!pModule->pHeader->pfnValidate)
        {
            DbgpLoadValidateRoutine(pModule->pHeader);
        }
        if (pModule->pHeader->pfnValidate)
        {
            pModule->pHeader->pfnValidate();
        }
    }

    fClean = ((Mask & DSYSDBG_CLEAN) != 0);

    if ( ( Mask & DEB_ERROR ) &&
         ( pModule->pHeader->fDebug & DEBUG_BREAK_ON_ERROR ) )
    {
        Break = TRUE ;
    }

    pBuffer = DbgpGetTextBuffer( pModule->pHeader );

    if ( !pBuffer )
    {
        OutputDebugStringA( "_DebugOut : Out of memory\n" );
        if ( fLocked )
        {
            UnlockDebugHeader( pModule->pHeader );
            
        }
        return;
    }

    if (Mask & (pModule->InfoLevel | DSYSDBG_FORCE))
    {

        if (Mask & DSYSDBG_FORCE)
        {
            Tag = "FORCE";
        }
        else
        {
            while (!(Mask & 1))
            {
                Level++;
                Mask >>= 1;
            }
            Tag = pModule->TagLevels[Level];
        }


        //
        // Make the prefix first:  "Process.Thread> Module-Tag:
        //

        if (!fClean)
        {
            if (pModule->pHeader->fDebug & DEBUG_TIMESTAMP)
            {
                SYSTEMTIME  stTime;

                GetLocalTime(&stTime);

                PrefixSize = sprintf(pBuffer->TextBuffer,
                        "[%2d/%2d %02d:%02d:%02d] %d.%d> %s-%s: ",
                        stTime.wMonth, stTime.wDay,
                        stTime.wHour, stTime.wMinute, stTime.wSecond,
                        GetCurrentProcessId(),
                        GetCurrentThreadId(), pModule->pModuleName,
                        Tag);

            }
            else

            {

                PrefixSize = sprintf(pBuffer->TextBuffer, "%d.%d> %s-%s: ",
                        GetCurrentProcessId(), GetCurrentThreadId(),
                        pModule->pModuleName, Tag);

            }
        }

        if ((TotalSize = _vsnprintf(&pBuffer->TextBuffer[PrefixSize],
                                    DEBUG_TEXT_BUFFER_SIZE - PrefixSize,
                                    Format, ArgList)) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("dsysdbg:  Could not pack string into 512 bytes\n");
        }
        else
        {
            TotalSize += PrefixSize;

            if ((pModule->pHeader->fDebug & DEBUG_NO_DEBUGIO) == 0 )
            {
                OutputDebugStringA( pBuffer->TextBuffer );
            }

            if ((pModule->pHeader->fDebug & DEBUG_LOGFILE))
            {
                if (pModule->pHeader->hLogFile == INVALID_HANDLE_VALUE)
                {
                    DbgpOpenLogFileRandom(pModule->pHeader);
                }

                WriteFile(  pModule->pHeader->hLogFile,
                            pBuffer->TextBuffer,
                            (DWORD) TotalSize,
                            (PDWORD) &PrefixSize,
                            NULL );
            }

            pModule->pHeader->TotalWritten += TotalSize;
            pModule->TotalOutput += TotalSize;
        }

    }
    if (fLocked)
    {
        UnlockDebugHeader(pModule->pHeader);
    }

    DbgpReleaseTextBuffer( pModule->pHeader, pBuffer );

    if ( Break )
    {
        OutputDebugStringA( "BreakOnError\n" );
        DebugBreak();
    }
}

VOID
_DbgSetOption(
    PVOID   pControl,
    DWORD   Option,
    BOOL    On,
    BOOL    Global
    )
{
    PDebugModule pModule;

    pModule = (PDebugModule) pControl ;

    if ( pModule )
    {
        if ( Global )
        {
            pModule = pModule->pHeader->pGlobalModule ;
        }

        if ( On )
        {
            pModule->InfoLevel |= Option ;
            *pModule->pInfoLevel |= Option ;
        }
        else
        {
            pModule->InfoLevel &= (~Option) ;
            *pModule->pInfoLevel &= (~Option) ;
        }
    }
}

VOID
_DbgSetLoggingOption(
    PVOID   pControl,
    BOOL    On
    )
{
    PDebugModule pModule;

    pModule = (PDebugModule)pControl;

    if ( pModule )
    {   
       if (((pModule->pHeader->fDebug & DEBUG_LOGFILE) == 0) && On )// off, turn it on
       {                                            
          pModule->pHeader->fDebug |= DEBUG_LOGFILE;
       } 
       else if ((pModule->pHeader->fDebug & DEBUG_LOGFILE) && !On) // on, turn it off
       {
          pModule->pHeader->fDebug &= (~DEBUG_LOGFILE);
          if ( pModule->pHeader->hLogFile != INVALID_HANDLE_VALUE )
          {
             CloseHandle( pModule->pHeader->hLogFile );
             pModule->pHeader->hLogFile = INVALID_HANDLE_VALUE;
          }
       }                                               
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\debuglib\debuglib.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debuglib.h
//
//  Contents:   DebugLib includes
//
//  Classes:
//
//  Functions:
//
//  History:    3-28-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <stdio.h>

#include <dsysdbg.h>

#include <debugp.h>

#include "dbglibp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\debuglib\compat.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       compat.c
//
//  Contents:   Compatibility routines for old callers
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"
#include <debnot.h>

DWORD           __CompatInfoLevel = 3;
DebugModule     __CompatGlobal = {NULL, NULL, 0, 0, &__CompatHeader};
DebugHeader     __CompatHeader = {DEBUG_TAG, NULL, INVALID_HANDLE_VALUE,
                                    INVALID_HANDLE_VALUE, 0, &__CompatGlobal};
DebugModule     __CompatModule = {NULL, &__CompatInfoLevel, 0, 3,
                                    &__CompatHeader, 0, 0, "Compat",
                                    {"Error", "Warning", "Trace", "",
                                     "IError", "IWarning", "ITrace", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };
DebugModule *   __pCompatModule = &__CompatModule;


void
vdprintf(
    unsigned long ulCompMask,
    char const *pszComp,
    char const *ppszfmt,
    va_list  ArgList)
{
    __CompatModule.pModuleName = (char *) pszComp;
    if (DbgpHeader)
    {
        __CompatModule.pHeader = DbgpHeader;
    }
    _DebugOut(__pCompatModule, ulCompMask, (char *) ppszfmt, ArgList);
}


void
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    CHAR    szDebug[MAX_PATH];

    if (szMessage)
    {
        _snprintf(szDebug, MAX_PATH, "%d.%d> ASSERTION FAILED: %s, %s:%d\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    szMessage, szFile, iLine);
    }
    else
    {
        _snprintf(szDebug, MAX_PATH, "%d.%d> ASSERTION FAILED %s:%d\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    szFile, iLine);
    }

    OutputDebugStringA(szDebug);

    DebugBreak();

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

unsigned long
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{

    return(ulNewLevel);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

unsigned long
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    return(ulNewMask);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

typedef unsigned long (APINOT * SetWin4AssertLevelFn)( unsigned long ulNewLevel );

unsigned long
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    SetWin4AssertLevelFn OleSetWin4AssertLevel;
    HMODULE Module;

    Module = GetModuleHandle(L"ole32.dll");


    if (Module != NULL)
    {
        OleSetWin4AssertLevel = (SetWin4AssertLevelFn) GetProcAddress(Module, "SetWin4AssertLevel");
        if (OleSetWin4AssertLevel != NULL)
        {
            OleSetWin4AssertLevel(ulNewLevel);
        }
    }

    return(ulNewLevel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\debuglib\assert.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       assert.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-03-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

typedef ULONG (NTAPI * DBGPROMPT)(PCH, PCH, ULONG);

#define DSYSASSERT_FAILED   0x00000001
#define DSYSASSERT_ERROR    0x00000002
#define DSYSASSERT_WARN     0x00000004

DWORD           __AssertInfoLevel = DSYSASSERT_FAILED;
DebugModule     __AssertModule = {NULL, &__AssertInfoLevel, 0, 7,
                                    NULL, 0, 0, "Assert",
                                    {"FAILED", "Error", "Warning", "",
                                     "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };

DebugModule *   __pAssertModule = &__AssertModule;

VOID
__AssertDebugOut(
    ULONG Mask,
    CHAR * Format,
    ... )
{
    va_list ArgList;
    va_start(ArgList, Format);
    _DebugOut( __pAssertModule, Mask, Format, ArgList);
}

BOOL
DbgpStartDebuggerOnMyself(BOOL UseKernelDebugger)
{
    WCHAR   cch[80];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    SECURITY_ATTRIBUTES sa;
    HANDLE  hEvent;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &DbgpPartySd;
    sa.bInheritHandle = TRUE;

    hEvent = CreateEvent(&sa, TRUE, FALSE, NULL);

    swprintf(cch, TEXT("ntsd %s -p %ld -e %ld -g"), (UseKernelDebugger ? "-d" : ""),
                        GetCurrentProcessId(), hEvent);


    ZeroMemory(&StartupInfo, sizeof(STARTUPINFO));

    StartupInfo.cb = sizeof(STARTUPINFO);
    if (!UseKernelDebugger)
    {
        StartupInfo.lpDesktop = TEXT("WinSta0\\Default");
    }

    if (CreateProcess(  NULL,
                        cch,
                        NULL,
                        NULL,
                        TRUE,
                        HIGH_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation) )
    {
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
        WaitForSingleObject(hEvent, 60000);
        CloseHandle(hEvent);
        return(TRUE);
    }
    else
    {
        __AssertDebugOut( DSYSASSERT_ERROR, "Could not start debugger '%ws', %d\n", cch, GetLastError());
        return(FALSE);
    }

}


VOID
_DsysAssertEx(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message,
    ULONG ContinueCode
    )
{
    CHAR        Response[2];
    HMODULE     hNtDll;
    DBGPROMPT   DbgPromptFn;


    if (DbgpHeader)
    {
        __pAssertModule->pHeader = DbgpHeader;
        if (DbgpHeader->fDebug & DEBUG_DISABLE_ASRT)
        {
            __AssertDebugOut( DSYSASSERT_WARN, "Assertion at %s:%d disabled\n",
                            FileName, LineNumber);
            return;
        }
    }

    if (Message)
        __AssertDebugOut( DSYSASSERT_FAILED, "%s: %s (%s:%d)\n",
                    Message, FailedAssertion, FileName, LineNumber);
     else
        __AssertDebugOut( DSYSASSERT_FAILED, "%s (%s:%d)\n",
                    FailedAssertion, FileName, LineNumber);

    switch (ContinueCode)
    {

        case DSYSDBG_ASSERT_BREAK:
            __AssertDebugOut( DSYSASSERT_FAILED, "\tBreakpoint\n");
            DebugBreak();
            break;

        case DSYSDBG_ASSERT_CONTINUE:
            __AssertDebugOut( DSYSASSERT_WARN, "\tContinuing\n");
            return;

        case DSYSDBG_ASSERT_SUSPEND:
            __AssertDebugOut( DSYSASSERT_WARN, "\tSuspending Thread %d\n", GetCurrentThreadId());
            SuspendThread(GetCurrentThread());
            return;

        case DSYSDBG_ASSERT_KILL:
            __AssertDebugOut( DSYSASSERT_WARN, "\tKill Thread (exit %x)\n", NtCurrentTeb()->LastStatusValue);
            TerminateThread(GetCurrentThread(), NtCurrentTeb()->LastStatusValue);
            return;

        case DSYSDBG_ASSERT_DEBUGGER:
            if (IsDebuggerPresent())
            {
                DebugBreak();
            }
            else
            {
                if (DbgpHeader)
                {
                    if ((DbgpHeader->fDebug & DEBUG_PROMPTS) == 0)
                    {
                        DbgpStartDebuggerOnMyself(DbgpHeader->fDebug & DEBUG_USE_KDEBUG);
                        DebugBreak();
                        break;
                    }
                }

                hNtDll = LoadLibrary(TEXT("ntdll.dll"));
                if (hNtDll)
                {
                    DbgPromptFn = (DBGPROMPT) GetProcAddress(hNtDll, "DbgPrompt");
                }
                else
                {
                    DbgPromptFn = NULL;
                }

                while (TRUE)
                {

                    if (DbgPromptFn)
                    {
                        DbgPromptFn( "Start Debugger, Break, Ignore (dbi)?",
                                    Response, sizeof(Response));

                        switch (Response[0])
                        {
                            case 'i':
                            case 'I':
                                return;

                            case 'd':
                            case 'D':
                                DbgpStartDebuggerOnMyself(DbgpHeader ? (DbgpHeader->fDebug & DEBUG_USE_KDEBUG) : TRUE );

                            case 'b':
                            case 'B':
                                DebugBreak();
                                return;
                        }
                    }
                    else
                    {
                        DbgpStartDebuggerOnMyself(TRUE);
                        DebugBreak();
                        return;
                    }
                }


            }
            break;

        default:
            __AssertDebugOut( DSYSASSERT_ERROR, "Unknown continue code for assert: %d\n",
                        ContinueCode);
            return;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\debuglib\safelock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    safelock.c

Abstract:

    Implementation of the safe lock library - a set of
    thin wrappers around critical section and resource
    routines that ensures proper lock ordering.

    Debug spew is generated when locks are acquired out of
    order.

--*/

#include <debuglib.h>
#include <safelock.h>

#ifdef DBG

//
// Uncomment the #define below to assert on locks acquired out
// of order.  Otherwise, only debug spew is generated.
//

#define SAFE_LOCK_ASSERT

#define MAX_SAFE_LOCK_ENTRIES  64

typedef struct _SAFE_LOCK_ENTRY {

    DWORD Enum;
    DWORD Count;

} SAFE_LOCK_ENTRY;

typedef struct _SAFE_LOCK_STACK {

    DWORD Top;
    SAFE_LOCK_ENTRY Entries[MAX_SAFE_LOCK_ENTRIES];

} SAFE_LOCK_STACK, *PSAFE_LOCK_STACK;

DWORD SafeLockThreadState = TLS_OUT_OF_INDEXES;

///////////////////////////////////////////////////////////////////////////////
//
// Helper routines
//
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SafeLockInit()
/*++

Routine Description:

    Called by the user of the safelock code at startup time,
    once per process initialization.

Parameters:

    None

Returns:

    STATUS_INSUFFICIENT_RESOURCES      TlsAlloc failed

    STATUS_SUCCESS                     Otherwise

--*/
{
    if ( SafeLockThreadState == TLS_OUT_OF_INDEXES ) {

        SafeLockThreadState = TlsAlloc();

        if ( SafeLockThreadState == TLS_OUT_OF_INDEXES ) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return STATUS_SUCCESS;
}



VOID
TrackLockEnter(
    DWORD Enum
    )
/*++

Routine Description:

    Used to insert tracking information about a lock into the stack

Parameters:

    Enum       ordinal number associated with the lock

Returns:

    Nothing, but will assert if not happy

--*/
{
    PSAFE_LOCK_STACK Stack;
    DWORD Index;

    //
    // First see if the space for the stack has been allocated
    //

    Stack = ( SAFE_LOCK_STACK * )TlsGetValue( SafeLockThreadState );

    if ( Stack == NULL ) {

        Stack = ( PSAFE_LOCK_STACK )LocalAlloc( 0, sizeof( SAFE_LOCK_STACK ));

        if ( Stack == NULL ) {

            //
            // Got no better way of dealing with this error here
            //
            DbgPrint( "Out of memory allocating lock tracking stack\n" );
#ifdef SAFE_LOCK_ASSERT
            ASSERT( FALSE );
#endif
            return;
        }

        ZeroMemory( Stack, sizeof( SAFE_LOCK_STACK ));

        TlsSetValue( SafeLockThreadState, Stack );
    }

    if ( Stack->Top >= MAX_SAFE_LOCK_ENTRIES ) {

        DbgPrint( "Lock tracking stack is full\n" );
#ifdef SAFE_LOCK_ASSERT
        ASSERT( FALSE );
#endif
        return;
    }

    if ( Stack->Top == 0 ||
         Enum > Stack->Entries[Stack->Top-1].Enum ) {

        //
        // Lock acquired in order; no further checks are necessary
        //

        Stack->Entries[Stack->Top].Enum = Enum;
        Stack->Entries[Stack->Top].Count = 1;
        Stack->Top += 1;

    } else {

        //
        // See if this lock has been acquired already
        //

        for ( Index = 0; Index < Stack->Top; Index++ ) {

            if ( Stack->Entries[Index].Enum == Enum ) {

                Stack->Entries[Index].Count += 1;
                break;
            }
        }

        if ( Index == Stack->Top ) {

            CHAR Buffer[128];
            sprintf( Buffer, "Lock %d acquired out of order: dt %p SAFE_LOCK_STACK\n", Enum, Stack );
            DbgPrint( Buffer );
#ifdef SAFE_LOCK_ASSERT
            ASSERT( FALSE );
#endif

            //
            // To keep the stack consistent, insert the new item
            // as if it was acquired in proper order
            //

            for ( Index = 0; Index < Stack->Top; Index++ ) {

                if ( Enum < Stack->Entries[Index].Enum ) {

                    MoveMemory( &Stack->Entries[Index+1],
                                &Stack->Entries[Index], 
                                sizeof( SAFE_LOCK_ENTRY ) * ( Stack->Top - Index ));

                    break;
                }
            }

            Stack->Entries[Index].Enum = Enum;
            Stack->Entries[Index].Count = 1;
            Stack->Top += 1;
        }
    }

    return;
}



VOID
TrackLockLeave(
    DWORD Enum
    )
/*++

Routine Description:

    Used to remove tracking information about a lock from the stack

Parameters:

    Enum       ordinal number associated with the lock

Returns:

    Nothing, but will assert if not happy

--*/
{
    PSAFE_LOCK_STACK Stack;
    DWORD Index;

    Stack = ( SAFE_LOCK_STACK * )TlsGetValue( SafeLockThreadState );

    if ( Stack == NULL ) {

        DbgPrint( "No lock tracking information available for this thread\n" );
#ifdef SAFE_LOCK_ASSERT
        ASSERT( FALSE );
#endif
        return;
    }

    if ( Stack->Top == 0 ) {

        DbgPrint( "Lock tracking stack is empty\n" );
#ifdef SAFE_LOCK_ASSERT
        ASSERT( FALSE );
#endif
        return;
    }

    //
    // See if this lock has been acquired already
    //

    for ( Index = 0; Index < Stack->Top; Index++ ) {

        if ( Stack->Entries[Index].Enum == Enum ) {

            Stack->Entries[Index].Count -= 1;
            break;
        }
    }

    if ( Index == Stack->Top ) {

        CHAR Buffer[128];
        sprintf( Buffer, "Leaving a lock %d that has not been acquired: dt %p SAFE_LOCK_STACK\n", Enum, Stack );
        DbgPrint( Buffer );
#ifdef SAFE_LOCK_ASSERT
        ASSERT( FALSE );
#endif

    } else if ( Stack->Entries[Index].Count == 0 ) {

        //
        // Compact the stack
        //

        Stack->Top -= 1;
        MoveMemory( &Stack->Entries[Index],
                    &Stack->Entries[Index+1], 
                    sizeof( SAFE_LOCK_ENTRY ) * ( Stack->Top - Index ));
    }

    if ( Stack->Top == 0 ) {

        LocalFree( Stack );
        TlsSetValue( SafeLockThreadState, NULL );
    }

    return;
}

///////////////////////////////////////////////////////////////////////////////
//
// RTL_CRITICAL_SECTION wrappers
//
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SafeEnterCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

    Debug wrapper around RtlEnterCriticalSection.
    Asserts if it is not happy.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to enter

Returns:

    See RtlEnterCriticalSection

--*/
{
    NTSTATUS Status;

    TrackLockEnter( CriticalSection->Enum );

    Status = RtlEnterCriticalSection( &CriticalSection->CriticalSection );

    return Status;
}



NTSTATUS
SafeLeaveCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

    Debug wrapper around RtlLeaveCriticalSection that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to leave

Returns:

    See RtlLeaveCriticalSection

--*/
{
    NTSTATUS Status;

    TrackLockLeave( CriticalSection->Enum );

    Status = RtlLeaveCriticalSection( &CriticalSection->CriticalSection );

    return Status;
}



BOOLEAN
SafeTryEnterCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

    Debug wrapper around RtlTryEnterCriticalSection that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to enter

Returns:

    See RtlTryEnterCriticalSection

--*/
{
    BOOLEAN Result;

    TrackLockEnter( CriticalSection->Enum );

    Result = RtlTryEnterCriticalSection( &CriticalSection->CriticalSection );

    if ( !Result ) {

        TrackLockLeave( CriticalSection->Enum );
    }

    return Result;
}



NTSTATUS
SafeInitializeCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection,
    DWORD Enum
    )
/*++

Routine Description:

    Debug wrapper around RtlInitializeCriticalSection.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to initialize
    Enum               ordinal number associated with the critical section

Returns:

    See RtlInitializeCriticalSection

--*/
{
    NTSTATUS Status;

    CriticalSection->Enum = Enum;
    Status = RtlInitializeCriticalSection( &CriticalSection->CriticalSection );

    return Status;
}



NTSTATUS
SafeInitializeCriticalSectionAndSpinCount(
    PSAFE_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount,
    DWORD Enum
    )
/*++

Routine Description:

    Debug wrapper around RtlInitializeCriticalSectionAndSpinCount.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to initialize
    SpinCount          spin count
    Enum               ordinal number associated with the critical section

Returns:

    See RtlInitializeCriticalSectionAndSpinCount

--*/
{
    NTSTATUS Status;

    CriticalSection->Enum = Enum;
    Status = RtlInitializeCriticalSectionAndSpinCount( &CriticalSection->CriticalSection, SpinCount );

    return Status;
}



ULONG
SafeSetCriticalSectionSpinCount(
    PSAFE_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    )
/*++

Routine Description:

    Debug wrapper around RtlSetCriticalSectionSpinCount.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to modify
    SpinCount          see the definition of RtlSetCriticalSectionSpinCount

Returns:

    See RtlSetCriticalSectionSpinCount

--*/
{
    ULONG Result;

    Result = RtlSetCriticalSectionSpinCount( &CriticalSection->CriticalSection, SpinCount );

    return Result;
}



NTSTATUS
SafeDeleteCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

    Debug wrapper around RtlDeleteCriticalSection.

Arguments:

    CriticalSection    address of a SAFE_CRITICAL_SECTION to delete

Returns:

    See RtlDeleteCriticalSection

--*/
{
    NTSTATUS Status;

    Status = RtlDeleteCriticalSection( &CriticalSection->CriticalSection );

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
//
// RTL_RESOURCE wrappers
//
///////////////////////////////////////////////////////////////////////////////



VOID
SafeInitializeResource(
    PSAFE_RESOURCE Resource,
    DWORD Enum
    )
/*++

Routine Description:

    Debug wrapper around RtlInitializeResource.

Arguments:

    Resource    address of a SAFE_RESOURCE to initialize
    Enum        ordinal number associated with the resource

Returns:

    See RtlInitializeResource

--*/
{
    Resource->Enum = Enum;
    RtlInitializeResource( &Resource->Resource );

    return;
}



BOOLEAN
SafeAcquireResourceShared(
    PSAFE_RESOURCE Resource,
    BOOLEAN Wait
    )
/*++

Routine Description:

    Debug wrapper around RtlAcquireResourceShared that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    Resource    address of a SAFE_RESOURCE to enter
    Wait        see definition of RtlAcquireResourceShared

Returns:

    See RtlAcquireResourceShared

--*/
{
    BOOLEAN Result;

    TrackLockEnter( Resource->Enum );

    Result = RtlAcquireResourceShared( &Resource->Resource, Wait );

    if ( !Result ) {

        TrackLockLeave( Resource->Enum );
    }

    return Result;
}



BOOLEAN
SafeAcquireResourceExclusive(
    PSAFE_RESOURCE Resource,
    BOOLEAN Wait
    )
/*++

Routine Description:

    Debug wrapper around RtlAcquireResourceExclusive that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    Resource    address of a SAFE_RESOURCE to enter
    Wait        see definition of RtlAcquireResourceExclusive

Returns:

    See RtlAcquireResourceExclusive

--*/
{
    BOOLEAN Result;

    TrackLockEnter( Resource->Enum );

    Result = RtlAcquireResourceExclusive( &Resource->Resource, Wait );

    if ( !Result ) {

        TrackLockLeave( Resource->Enum );
    }

    return Result;
}



VOID
SafeReleaseResource(
    PSAFE_RESOURCE Resource
    )
/*++

Routine Description:

    Debug wrapper around RtlReleaseResource that ensures
    proper ordering of locks.
    Asserts if it is not happy.

Arguments:

    Resource    address of a SAFE_RESOURCE to release

Returns:

    See RtlReleaseResource

--*/
{
    TrackLockLeave( Resource->Enum );

    RtlReleaseResource( &Resource->Resource );

    return;
}



VOID
SafeConvertSharedToExclusive(
    PSAFE_RESOURCE Resource
    )
/*++

Routine Description:

    Debug wrapper around RtlConvertSharedToExclusive.

Arguments:

    Resource    address of a SAFE_RESOURCE to convert

Returns:

    See RtlConvertSharedToExclusive

--*/
{
    RtlConvertSharedToExclusive( &Resource->Resource );

    return;
}



VOID
SafeConvertExclusiveToShared(
    PSAFE_RESOURCE Resource
    )
/*++

Routine Description:

    Debug wrapper around RtlConvertExclusiveToShared.

Arguments:

    Resource    address of a SAFE_RESOURCE to convert

Returns:

    See RtlConvertExclusiveToShared

--*/
{
    RtlConvertExclusiveToShared( &Resource->Resource );

    return;
}



VOID
SafeDeleteResource (
    PSAFE_RESOURCE Resource
    )
/*++

Routine Description:

    Debug wrapper around RtlDeleteResource.

Arguments:

    Resource    address of a SAFE_RESOURCE to delete

Returns:

    See RtlDeleteResource

--*/
{
    RtlDeleteResource( &Resource->Resource );

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\wxlpc\client\rng.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

VOID
STInitializeRNG(VOID);

VOID
STShutdownRNG(VOID);


VOID
STGenerateRandomBits(
    PUCHAR      pRandomData,
    ULONG       cRandomData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\debuglib\except.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       except.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-19-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include "debuglib.h"

#define DEB_TRACE           0x00000004
#define DSYS_EXCEPT_BREAK   0x00000008

DWORD           __ExceptionsInfoLevel = 0x1;
DebugModule     __ExceptionsModule = {NULL, &__ExceptionsInfoLevel, 0, 7,
                                    NULL, 0, 0, "Exceptions",
                                    {"Error", "Warning", "Trace", "Break",
                                     "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "",
                                     "", "", "", "", "", "", "", "" }
                                    };

DebugModule *   __pExceptionModule = &__ExceptionsModule;

#define DebugOut(x) __ExceptionsDebugOut x

typedef struct _ExName {
    LONG    ExceptionCode;
    PSTR    Name;
} ExName, * PExName;

ExName  __ExceptNames[] = { {EXCEPTION_ACCESS_VIOLATION,    "Access Violation"},
                            {EXCEPTION_ARRAY_BOUNDS_EXCEEDED, "Bounds Exceeded"},
                            {EXCEPTION_BREAKPOINT,          "Break Point"},
                            {EXCEPTION_DATATYPE_MISALIGNMENT, "Alignment (Data)"},
                            {EXCEPTION_FLT_DENORMAL_OPERAND, "(Float) Denormal Operand"},
                            {EXCEPTION_FLT_DIVIDE_BY_ZERO,  "(Float) Divide By Zero"},
                            {EXCEPTION_FLT_INEXACT_RESULT,  "(Float) Inexact Result"},
                            {EXCEPTION_FLT_INVALID_OPERATION, "(Float) Invalid Op"},
                            {EXCEPTION_FLT_OVERFLOW, "(Float) Overflow"},
                            {EXCEPTION_FLT_STACK_CHECK, "(Float) Stack Check"},
                            {EXCEPTION_FLT_UNDERFLOW, "(Float) Underflow"},
                            {EXCEPTION_ILLEGAL_INSTRUCTION, "Illegal Instruction"},
                            {EXCEPTION_IN_PAGE_ERROR, "In Page Error"},
                            {EXCEPTION_INT_DIVIDE_BY_ZERO, "Divide By Zero"},
                            {EXCEPTION_INT_OVERFLOW, "Overflow"},
                            {EXCEPTION_INVALID_DISPOSITION, "Illegal Disposition"},
                            {EXCEPTION_NONCONTINUABLE_EXCEPTION, "Can't Continue"},
                            {EXCEPTION_PRIV_INSTRUCTION, "Privileged Instruction"},
                            {EXCEPTION_SINGLE_STEP, "Single Step"},
                            {EXCEPTION_STACK_OVERFLOW, "Stack OverFlow"},
                            {0xC0000194, "Deadlock"},

                           };

VOID
__ExceptionsDebugOut(
    ULONG Mask,
    CHAR * Format,
    ... )
{
    va_list ArgList;
    va_start(ArgList, Format);
    _DebugOut( __pExceptionModule, Mask, Format, ArgList);
}

BOOL
DbgpDumpExceptionRecord(
    PEXCEPTION_RECORD   pExceptRecord)
{
    PSTR    pszExcept;
    BOOL    StopOnException;
    DWORD   i;
    ULONG   InfoLevel = NT_SUCCESS(pExceptRecord->ExceptionCode) ? DEB_TRACE : DEB_ERROR;

    StopOnException = FALSE;
    pszExcept = NULL;
    for (i = 0; i < sizeof(__ExceptNames) / sizeof(ExName) ; i++ )
    {
        if (pExceptRecord->ExceptionCode == __ExceptNames[i].ExceptionCode)
        {
            pszExcept = __ExceptNames[i].Name;
            break;
        }
    }

    if (pszExcept)
    {
        DebugOut((InfoLevel, "Exception %#x (%s)\n",
                        pExceptRecord->ExceptionCode, pszExcept));
    }
    else
        DebugOut((InfoLevel, "Exception %#x\n", pExceptRecord->ExceptionCode));

    DebugOut((InfoLevel, "   %s\n",
                pExceptRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE ?
                "Non-Continuable" : "Continuable"));
    DebugOut((InfoLevel, "   Address    %#x\n", pExceptRecord->ExceptionAddress));
    switch (pExceptRecord->ExceptionCode)
    {
        case EXCEPTION_ACCESS_VIOLATION:
        case EXCEPTION_DATATYPE_MISALIGNMENT:
            DebugOut((InfoLevel, "   %s at address %#x\n",
                pExceptRecord->ExceptionInformation[0] ? "Write" : "Read",
                pExceptRecord->ExceptionInformation[1] ));
            StopOnException = TRUE;
            break;

        case STATUS_POSSIBLE_DEADLOCK:
            DebugOut((InfoLevel, "  Resource at %#x\n",
                pExceptRecord->ExceptionInformation[0] ));
            StopOnException = TRUE;
            break;

        default:
            // StopOnException = TRUE;
            DebugOut((InfoLevel, "  %d Parameters\n", pExceptRecord->NumberParameters));
            for (i = 0; i < pExceptRecord->NumberParameters ; i++ )
            {
                DebugOut((InfoLevel, "    [%d] %#x\n", i,
                    pExceptRecord->ExceptionInformation[i] ));
            }
            break;
    }

    return(StopOnException);
}

VOID
DbgpDumpContextRecord(
    PCONTEXT    pContext,
    BOOL        StopOnException)
{
    ULONG InfoLevel = StopOnException ? DEB_ERROR : DEB_TRACE;
#ifdef _MIPS_
    DebugOut((InfoLevel, "MIPS Context Record at %x\n", pContext));
    if (pContext->ContextFlags & CONTEXT_INTEGER)
    {
        DebugOut((InfoLevel, "at=%08x v0=%08x v1=%08x a0=%08x\n",
            pContext->IntAt, pContext->IntV0, pContext->IntV1, pContext->IntA0));
        DebugOut((InfoLevel, "a1=%08x a2=%08x a3=%08x t0=%08x\n",
            pContext->IntA1, pContext->IntA2, pContext->IntA3, pContext->IntT0));
        DebugOut((InfoLevel, "t1=%08x t2=%08x t3=%08x t4=%08x\n",
            pContext->IntT1, pContext->IntT2, pContext->IntT3, pContext->IntT4));
        DebugOut((InfoLevel, "t5=%08x t6=%08x t7=%08x s0=%08x\n",
            pContext->IntT5, pContext->IntT6, pContext->IntT7, pContext->IntS0));
        DebugOut((InfoLevel, "s1=%08x s2=%08x s3=%08x s4=%08x\n",
            pContext->IntS1, pContext->IntS2, pContext->IntS3, pContext->IntS4));
        DebugOut((InfoLevel, "s5=%08x s6=%08x s7=%08x t8=%08x\n",
            pContext->IntS5, pContext->IntS6, pContext->IntS7, pContext->IntT8));
        DebugOut((InfoLevel, "t9=%08x s8=%08x hi=%08x lo=%08x\n",
            pContext->IntT9, pContext->IntS8, pContext->IntLo, pContext->IntHi));
        DebugOut((InfoLevel, "k0=%08x k1=%08x gp=%08x sp=%08x\n",
            pContext->IntK0, pContext->IntK1, pContext->IntGp, pContext->IntSp));
        DebugOut((InfoLevel, "ra=%08x\n",
            pContext->IntRa));

    }
    if (pContext->ContextFlags & CONTEXT_CONTROL)
    {
        DebugOut((InfoLevel, "Fir=%08x Psr=%08x\n", pContext->Fir,
            pContext->Psr));
    }

#elif _X86_
    DebugOut((InfoLevel, "x86 Context Record at %x\n", pContext));
    if (pContext->ContextFlags & CONTEXT_DEBUG_REGISTERS)
    {
        DebugOut((InfoLevel, "Dr0=%08x Dr1=%08x Dr2=%08x Dr3=%08x \n",
                    pContext->Dr0, pContext->Dr1, pContext->Dr2, pContext->Dr3));
        DebugOut((InfoLevel, "Dr6=%08x Dr7=%08x\n",
                    pContext->Dr6, pContext->Dr7));
    }
    if (pContext->ContextFlags & CONTEXT_SEGMENTS)
    {
        DebugOut((InfoLevel, "gs=%08x fs=%08x es=%08x ds=%08x\n",
                    pContext->SegGs, pContext->SegFs, pContext->SegEs,
                    pContext->SegDs));
    }
    if (pContext->ContextFlags & CONTEXT_INTEGER)
    {
        DebugOut((InfoLevel, "edi=%08x esi=%08x ebx=%08x\n",
                pContext->Edi, pContext->Esi, pContext->Ebx));
        DebugOut((InfoLevel, "edx=%08x ecx=%08x eax=%08x\n",
                pContext->Edx, pContext->Ecx, pContext->Eax));
    }
    if (pContext->ContextFlags & CONTEXT_CONTROL)
    {
        DebugOut((InfoLevel, "ebp=%08x eip=%08x cs=%08x\n",
                pContext->Ebp, pContext->Eip, pContext->SegCs));
        DebugOut((InfoLevel, "flags=%08x esp=%08x ss=%08x\n",
                pContext->EFlags, pContext->Esp, pContext->SegSs));
    }

#elif _ALPHA_
    DebugOut((InfoLevel, "ALPHA Context Record at %x\n", pContext));

#elif _PPC_
    DebugOut((InfoLevel, "PPC Context Record at %x\n", pContext));

#else
    DebugOut((InfoLevel, "Unknown Context Record, %x\n", pContext));

#endif

}

VOID
DbgpDumpException(
    PEXCEPTION_POINTERS pExceptInfo)
{
    BOOL StopOnException;

    StopOnException = DbgpDumpExceptionRecord(pExceptInfo->ExceptionRecord);
    DbgpDumpContextRecord( pExceptInfo->ContextRecord, StopOnException );

    if (StopOnException &&
        ((__ExceptionsInfoLevel & DSYS_EXCEPT_BREAK) != 0))
    {
        DsysAssertMsgEx(FALSE, "Skip Exceptions", DSYSDBG_ASSERT_DEBUGGER);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\inc\debugp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debugp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-21-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUGP_H__
#define __DEBUGP_H__

#define DEBUGMOD_CHANGE_INFOLEVEL   0x00000001
#define DEBUGMOD_BUILTIN_MODULE     0x00000002

struct _DebugHeader;

typedef struct _DebugModule {
    struct _DebugModule *   pNext;
    DWORD *                 pInfoLevel;
    DWORD                   fModule;
    DWORD                   InfoLevel;
    struct _DebugHeader *   pHeader;
    DWORD                   TotalOutput;
    DWORD                   Reserved;
    PCHAR                   pModuleName;      
    PCHAR                   TagLevels[32];
} DebugModule, * PDebugModule;


#define DEBUG_TAG   'gubD'

#define DEBUG_NO_DEBUGIO    0x00000001      // Do not use OutputDebugString
#define DEBUG_TIMESTAMP     0x00000002      // Stamp date/time
#define DEBUG_DEBUGGER_OK   0x00000004      // We're running in a debugger
#define DEBUG_LOGFILE       0x00000008      // Send to log file
#define DEBUG_AUTO_DEBUG    0x00000010      // Start up in debugger
#define DEBUG_USE_KDEBUG    0x00000020      // Use KD
#define DEBUG_DISABLE_ASRT  0x00000100      // Disable asserts
#define DEBUG_PROMPTS       0x00000200      // No prompts for asserts

#define DEBUG_MODULE_NAME   "DsysDebug"

typedef BOOLEAN (NTAPI * HEAPVALIDATE)(VOID);

#define DEBUG_TEXT_BUFFER_SIZE  (512 - sizeof( PVOID ))

typedef struct _DEBUG_TEXT_BUFFER {
    struct _DEBUG_TEXT_BUFFER * Next ;
    CHAR TextBuffer[ DEBUG_TEXT_BUFFER_SIZE ];
} DEBUG_TEXT_BUFFER, * PDEBUG_TEXT_BUFFER ;

typedef struct _DebugHeader {
    DWORD               Tag;            // Check tag
    DWORD               fDebug;         // Global Flags
    PVOID               pvSection;      // Base address of section
    HANDLE              hMapping;       // Mapping handle
    HANDLE              hLogFile;       // Log file handle
    PDebugModule        pGlobalModule;  // Global Flags module
    PDebugModule        pModules;       // List of modules
    HEAPVALIDATE        pfnValidate;    // Heap Validator
    PVOID               pFreeList;      // Free list for allocator
    PCHAR               pszExeName;     // Exe Name
    PDEBUG_TEXT_BUFFER  pBufferList ;   // List of debug string buffers
    CRITICAL_SECTION    csDebug;        // Critical section
    DWORD               CommitRange;    // Range of memory committed
    DWORD               ReserveRange;   // Range of memory reserved
    DWORD               PageSize;       // Page size;
    DWORD               TotalWritten;   // Total Output of debug stuff
    DWORD               ModuleCount ;   // Module Count (not including builtins)
    DEBUG_TEXT_BUFFER   DefaultBuffer ; // One default buffer
} DebugHeader, * PDebugHeader;






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\debug\debuglib\test.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       test.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-21-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <wchar.h>
#include <stdio.h>

#include <dsysdbg.h>

#include "debugp.h"

DECLARE_DEBUG2(Test);
DECLARE_DEBUG2(Test2);

DEFINE_DEBUG2(Test);
DEFINE_DEBUG2(Test2);

PVOID
DbgpAlloc(
    PDebugHeader    pHeader,
    DWORD           cSize);

VOID
DbgpFree(
    PDebugHeader    pHeader,
    PVOID           pMemory);


DEBUG_KEY   MyKeys[] = { {  1, "Error" },
                         {  2, "Warning" },
                         {  4, "Trace" },
                         {  8, "Yikes" },
                         {  0, NULL }
                       };

int
ExceptionFilter(
    LPEXCEPTION_POINTERS    p)
{
    DsysException(p);
    return(EXCEPTION_EXECUTE_HANDLER);
}

__cdecl main (int argc, char *argv[])
{
    char wait[40];
    PUCHAR  p;
    CHAR c;
    DWORD ChunkSize = 1024 ;
    PUCHAR Mem[ 16 ];
    ULONG i ;
    PDebugModule Alloc ;


    TestInitDebug(MyKeys);

    p = NULL;

    TestDebugPrint(1, "This is an error %d\n", 10);
    TestDebugPrint(2, "This is a warning!\n");

    Test2InitDebug(MyKeys);

    Test2DebugPrint(4, "Should be a trace\n");

    printf("Waiting...");
    gets(wait);

    try
    {
        c = *p;
    }
    except (ExceptionFilter(GetExceptionInformation()))
    {
        TestDebugPrint(1, "That AV'd\n");
    }

    DsysAssert(p);

    printf("Waiting...");
    gets(wait);

    Test2DebugPrint(8, "This is a yikes!\n");

    DsysAssertMsg(argc == 1, "Test Assertion");

    Test2DebugPrint(4, "yada yada\n");

    //
    // Load and unload:
    //

    Test2UnloadDebug();
    TestUnloadDebug();

    Test2InitDebug( MyKeys );
    Test2DebugPrint( 1, "Reload test2\n");
    TestInitDebug( MyKeys );
    TestDebugPrint( 1, "Reload test\n");

    Test2UnloadDebug();
    TestUnloadDebug();
    Test2DebugPrint(1, "Safe test\n" );
    Test2InitDebug( MyKeys );
    Test2DebugPrint(1, "Prints now\n" );


    //
    // Allocation tests:
    //

    Alloc = (PDebugModule) Test2ControlBlock ;

    for ( i = 0 ; i < 16 ; i++ )
    {
        Mem[ i ] = DbgpAlloc( Alloc->pHeader, ChunkSize );

    }

    for ( i = 0 ; i < 16 ; i++ )
    {
        DbgpFree( Alloc->pHeader, Mem[ i ] );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\lsaitf\lsaitf.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        lsaitf.c
//
// Contents:    Routines for dynamically calling LSA & Sam routines
//
//
// History:     21-February-1997        Created         MikeSw
//
//------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <lsaisrv.h>
#include <samisrv.h>
#include <lsaitf.h>

typedef NTSTATUS (*PI_SamrSetInformationUser)(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    IN                PSAMPR_USER_INFO_BUFFER Buffer
    );

typedef NTSTATUS (*PI_SamrGetGroupsForUser)(
    IN                SAMPR_HANDLE            UserHandle,
    OUT               PSAMPR_GET_GROUPS_BUFFER *Groups
    );

typedef NTSTATUS (*PI_SamrCloseHandle)(
    IN OUT            SAMPR_HANDLE    *       SamHandle
    );

typedef NTSTATUS (*PI_SamrQueryInformationUser)(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    OUT               PSAMPR_USER_INFO_BUFFER *Buffer
    );

typedef NTSTATUS (*PI_SamrOpenUser)(
    IN                SAMPR_HANDLE            DomainHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                ULONG                   UserId,
    OUT               SAMPR_HANDLE    *       UserHandle
    );

typedef NTSTATUS (*PI_SamrLookupNamesInDomain)(
    IN                SAMPR_HANDLE            DomainHandle,
    IN                ULONG                   Count,
    IN                RPC_UNICODE_STRING      Names[],
    OUT               PSAMPR_ULONG_ARRAY      RelativeIds,
    OUT               PSAMPR_ULONG_ARRAY      Use
    );

typedef NTSTATUS (*PI_SamrLookupIdsInDomain)(
    IN                SAMPR_HANDLE DomainHandle,
    IN                ULONG Count,
    IN                PULONG RelativeIds,
    OUT               PSAMPR_RETURNED_USTRING_ARRAY Names,
    OUT               PSAMPR_ULONG_ARRAY Use
    );


typedef NTSTATUS (*PI_SamrOpenDomain)(
    IN                SAMPR_HANDLE            ServerHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                PRPC_SID                DomainId,
    OUT               SAMPR_HANDLE    *       DomainHandle
    );
    
typedef NTSTATUS (*PI_SamrQueryInformationDomain)(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    );




typedef NTSTATUS (*PI_SamIConnect)(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

typedef NTSTATUS (*PI_SamIAccountRestrictions)(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

typedef NTSTATUS (*PI_SamIGetUserLogonInformation)(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

typedef NTSTATUS (*PI_SamIGetUserLogonInformationEx)(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

typedef VOID (*PI_SamIFree_SAMPR_GET_GROUPS_BUFFER )(
    PSAMPR_GET_GROUPS_BUFFER Source
    );

typedef VOID (*PI_SamIFree_SAMPR_USER_INFO_BUFFER )(
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    );

typedef VOID (*PI_SamIFree_SAMPR_ULONG_ARRAY )(
    PSAMPR_ULONG_ARRAY Source
    );

typedef VOID (*PI_SamIFree_SAMPR_RETURNED_USTRING_ARRAY )(
    PSAMPR_RETURNED_USTRING_ARRAY Source
    );

typedef VOID (*PI_SamIFreeSidAndAttributesList)(
    IN  PSID_AND_ATTRIBUTES_LIST List
    );

typedef VOID
(NTAPI *PI_SamIIncrementPerformanceCounter)(
    IN SAM_PERF_COUNTER_TYPE CounterType
    );

typedef VOID (*PI_SamIFreeVoid)(
    IN PVOID ptr
    );

typedef NTSTATUS (*PI_SamIUPNFromUserHandle)(
    IN SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    );

typedef NTSTATUS (*PI_SamIUpdateLogonStatistics)(
    IN SAMPR_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS LogonStats
    );

typedef NTSTATUS (*PI_LsaIOpenPolicyTrusted)(
    OUT PLSAPR_HANDLE PolicyHandle
    );

typedef NTSTATUS (*PI_LsarClose)(
    IN OUT LSAPR_HANDLE *ObjectHandle
    );

typedef NTSTATUS (*PI_LsaIQueryInformationPolicyTrusted)(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    );
typedef NTSTATUS (*PI_LsarQueryInformationPolicy)(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *PolicyInformation
    );

typedef VOID (*PI_LsaIFree_LSAPR_POLICY_INFORMATION )(
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );


typedef NTSTATUS (*PI_LsarCreateSecret)(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    );

typedef NTSTATUS (*PI_LsarOpenSecret)(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    );

typedef NTSTATUS (*PI_LsarSetSecret)(
    IN LSAPR_HANDLE SecretHandle,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedOldValue
    );

typedef NTSTATUS (*PI_LsarQuerySecret)(
    IN LSAPR_HANDLE SecretHandle,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    IN OUT OPTIONAL PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    IN OUT OPTIONAL PLARGE_INTEGER OldValueSetTime
    );

typedef NTSTATUS (*PI_LsarDelete)(
    IN OUT LSAPR_HANDLE ObjectHandle
    );

typedef VOID (*PI_LsaIFree_LSAPR_CR_CIPHER_VALUE) (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    );


typedef NTSTATUS
(NTAPI *PI_LsaIRegisterPolicyChangeNotificationCallback)(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

typedef NTSTATUS
(NTAPI *PI_LsaIUnregisterPolicyChangeNotificationCallback)(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

typedef NTSTATUS
(NTAPI *PI_LsaIAuditAccountLogon)(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             Status          OPTIONAL
    );

typedef
NTSTATUS
(NTAPI *PI_LsaIGetLogonGuid)(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    );

typedef
NTSTATUS
(NTAPI *PI_LsaISetLogonGuidInLogonSession)(
    IN  PLUID  pLogonId,
    IN  LPGUID pLogonGuid
    );


typedef
VOID
(NTAPI *PI_LsaIAuditKerberosLogon)(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID pLogonId,
    IN LPGUID pLogonGuid
    );

typedef
NTSTATUS
(NTAPI *PI_LsaIAuditLogonUsingExplicitCreds)(
    IN USHORT          AuditEventType,
    IN PSID            pUser1Sid,
    IN PUNICODE_STRING pUser1Name,
    IN PUNICODE_STRING pUser1Domain,
    IN PLUID           pUser1LogonId,
    IN LPGUID          pUser1LogonGuid,
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid
    );


typedef NTSTATUS
(NTAPI *PI_LsaICallPackage)(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

typedef NTSTATUS
(NTAPI *PI_LsaIAddNameToLogonSession)(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  PUNICODE_STRING Name
    );


///////////////////////////////////////////////////////////////////////

BOOLEAN SrvDllsLoaded = FALSE;
NTSTATUS DllLoadStatus = STATUS_SUCCESS;

PI_SamrSetInformationUser pI_SamrSetInformationUser;
PI_SamrGetGroupsForUser pI_SamrGetGroupsForUser;
PI_SamrCloseHandle pI_SamrCloseHandle;
PI_SamrQueryInformationUser pI_SamrQueryInformationUser;
PI_SamrOpenUser pI_SamrOpenUser;
PI_SamrLookupNamesInDomain pI_SamrLookupNamesInDomain;
PI_SamrLookupIdsInDomain pI_SamrLookupIdsInDomain;
PI_SamrOpenDomain pI_SamrOpenDomain;
PI_SamrQueryInformationDomain pI_SamrQueryInformationDomain;
PI_SamIConnect pI_SamIConnect;
PI_SamIAccountRestrictions pI_SamIAccountRestrictions;
PI_SamIGetUserLogonInformation pI_SamIGetUserLogonInformation;
PI_SamIGetUserLogonInformationEx pI_SamIGetUserLogonInformationEx;
PI_SamIFree_SAMPR_GET_GROUPS_BUFFER  pI_SamIFree_SAMPR_GET_GROUPS_BUFFER ;
PI_SamIFree_SAMPR_USER_INFO_BUFFER  pI_SamIFree_SAMPR_USER_INFO_BUFFER ;
PI_SamIFree_SAMPR_ULONG_ARRAY pI_SamIFree_SAMPR_ULONG_ARRAY ;
PI_SamIFreeSidAndAttributesList pI_SamIFreeSidAndAttributesList ;
PI_SamIFree_SAMPR_RETURNED_USTRING_ARRAY pI_SamIFree_SAMPR_RETURNED_USTRING_ARRAY;
PI_SamIIncrementPerformanceCounter pI_SamIIncrementPerformanceCounter;
PI_SamIFreeVoid pI_SamIFreeVoid;
PI_SamIUPNFromUserHandle pI_SamIUPNFromUserHandle;
PI_SamIUpdateLogonStatistics pI_SamIUpdateLogonStatistics;


PI_LsaIOpenPolicyTrusted pI_LsaIOpenPolicyTrusted;
PI_LsarClose pI_LsarClose;
PI_LsaIQueryInformationPolicyTrusted pI_LsaIQueryInformationPolicyTrusted;
PI_LsarQueryInformationPolicy pI_LsarQueryInformationPolicy;
PI_LsaIFree_LSAPR_POLICY_INFORMATION pI_LsaIFree_LSAPR_POLICY_INFORMATION ;
PI_LsarCreateSecret pI_LsarCreateSecret;
PI_LsarOpenSecret pI_LsarOpenSecret;
PI_LsarSetSecret pI_LsarSetSecret;
PI_LsarQuerySecret pI_LsarQuerySecret;
PI_LsarDelete pI_LsarDelete;
PI_LsaIFree_LSAPR_CR_CIPHER_VALUE pI_LsaIFree_LSAPR_CR_CIPHER_VALUE;
PI_LsaIRegisterPolicyChangeNotificationCallback pI_LsaIRegisterPolicyChangeNotificationCallback;
PI_LsaIUnregisterPolicyChangeNotificationCallback pI_LsaIUnregisterPolicyChangeNotificationCallback;
PI_LsaIAuditAccountLogon pI_LsaIAuditAccountLogon;
PI_LsaIGetLogonGuid pI_LsaIGetLogonGuid;
PI_LsaISetLogonGuidInLogonSession pI_LsaISetLogonGuidInLogonSession;
PI_LsaIAuditKerberosLogon pI_LsaIAuditKerberosLogon;
PI_LsaIAuditLogonUsingExplicitCreds pI_LsaIAuditLogonUsingExplicitCreds;
PI_LsaICallPackage pI_LsaICallPackage;
PI_LsaIAddNameToLogonSession pI_LsaIAddNameToLogonSession;


///////////////////////////////////////////////////////////////////////

//
// Macro to grab the address of the named procedure from a DLL
//

#if DBG
#define GRAB_ADDRESS( _Y, _X ) \
    pI_##_X = (PI_##_X) GetProcAddress( _Y, #_X ); \
    \
    if ( pI_##_X == NULL ) { \
        DbgPrint("[security process] can't load " #_X " procedure. %ld\n", GetLastError()); \
        Status = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

#else // DBG
#define GRAB_ADDRESS( _Y, _X ) \
    pI_##_X = (PI_##_X) GetProcAddress( _Y, #_X ); \
    \
    if ( pI_##_X == NULL ) { \
        Status = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

#endif // DBG


//+-------------------------------------------------------------------------
//
//  Function:   EnsureSrvDllsLoaded
//
//  Synopsis:   Ensures that lsasrv.dll & samsrv.dll are loaded and
//              looks up function addresses in them.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
EnsureSrvDllsLoaded(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HMODULE SamsrvHandle = NULL;
    HMODULE LsasrvHandle = NULL;

    if (!NT_SUCCESS(DllLoadStatus))
    {
        return(DllLoadStatus);
    }

    //
    // Get handles to the DLLs. We don't want to load the DLLs - just
    // use them if they are present
    //

    SamsrvHandle = GetModuleHandleW(L"samsrv.dll");
    if (SamsrvHandle == NULL)
    {
        Status = STATUS_DLL_NOT_FOUND;
        goto Cleanup;
    }

    LsasrvHandle = GetModuleHandleW(L"lsasrv.dll");
    if (SamsrvHandle == NULL)
    {
        Status = STATUS_DLL_NOT_FOUND;
        goto Cleanup;
    }


    GRAB_ADDRESS( SamsrvHandle, SamrSetInformationUser );
    GRAB_ADDRESS( SamsrvHandle, SamrGetGroupsForUser );
    GRAB_ADDRESS( SamsrvHandle, SamrCloseHandle );
    GRAB_ADDRESS( SamsrvHandle, SamrQueryInformationUser );
    GRAB_ADDRESS( SamsrvHandle, SamrOpenUser );
    GRAB_ADDRESS( SamsrvHandle, SamrLookupNamesInDomain);
    GRAB_ADDRESS( SamsrvHandle, SamrLookupIdsInDomain);
    GRAB_ADDRESS( SamsrvHandle, SamrOpenDomain );
    GRAB_ADDRESS( SamsrvHandle, SamrQueryInformationDomain );
    GRAB_ADDRESS( SamsrvHandle, SamIConnect );
    GRAB_ADDRESS( SamsrvHandle, SamIAccountRestrictions );
    GRAB_ADDRESS( SamsrvHandle, SamIGetUserLogonInformation );
    GRAB_ADDRESS( SamsrvHandle, SamIGetUserLogonInformationEx );
    GRAB_ADDRESS( SamsrvHandle, SamIFree_SAMPR_GET_GROUPS_BUFFER  );
    GRAB_ADDRESS( SamsrvHandle, SamIFree_SAMPR_USER_INFO_BUFFER  );
    GRAB_ADDRESS( SamsrvHandle, SamIFree_SAMPR_ULONG_ARRAY );
    GRAB_ADDRESS( SamsrvHandle, SamIFree_SAMPR_RETURNED_USTRING_ARRAY );
    GRAB_ADDRESS( SamsrvHandle, SamIFreeSidAndAttributesList );
    GRAB_ADDRESS( SamsrvHandle, SamIIncrementPerformanceCounter );
    GRAB_ADDRESS( SamsrvHandle, SamIFreeVoid );
    GRAB_ADDRESS( SamsrvHandle, SamIUPNFromUserHandle );
    GRAB_ADDRESS( SamsrvHandle, SamIUpdateLogonStatistics );
    GRAB_ADDRESS( LsasrvHandle, LsaIOpenPolicyTrusted );
    GRAB_ADDRESS( LsasrvHandle, LsaIQueryInformationPolicyTrusted );
    GRAB_ADDRESS( LsasrvHandle, LsarClose );
    GRAB_ADDRESS( LsasrvHandle, LsarQueryInformationPolicy );
    GRAB_ADDRESS( LsasrvHandle, LsaIFree_LSAPR_POLICY_INFORMATION );
    GRAB_ADDRESS( LsasrvHandle, LsarCreateSecret );
    GRAB_ADDRESS( LsasrvHandle, LsarOpenSecret );
    GRAB_ADDRESS( LsasrvHandle, LsarSetSecret );
    GRAB_ADDRESS( LsasrvHandle, LsarQuerySecret );
    GRAB_ADDRESS( LsasrvHandle, LsarDelete );
    GRAB_ADDRESS( LsasrvHandle, LsaIFree_LSAPR_CR_CIPHER_VALUE );
    GRAB_ADDRESS( LsasrvHandle, LsaIRegisterPolicyChangeNotificationCallback );
    GRAB_ADDRESS( LsasrvHandle, LsaIUnregisterPolicyChangeNotificationCallback );
    GRAB_ADDRESS( LsasrvHandle, LsaIAuditAccountLogon );
    GRAB_ADDRESS( LsasrvHandle, LsaIGetLogonGuid );
    GRAB_ADDRESS( LsasrvHandle, LsaISetLogonGuidInLogonSession );
    GRAB_ADDRESS( LsasrvHandle, LsaIAuditKerberosLogon );
    GRAB_ADDRESS( LsasrvHandle, LsaIAuditLogonUsingExplicitCreds );
    GRAB_ADDRESS( LsasrvHandle, LsaICallPackage );
    GRAB_ADDRESS( LsasrvHandle, LsaIAddNameToLogonSession );
    SrvDllsLoaded = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        DllLoadStatus = Status;
    }
    return(Status);
}


///////////////////////////////////////////////////////////////////////

NTSTATUS
I_SamrSetInformationUser(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    IN                PSAMPR_USER_INFO_BUFFER Buffer
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamrSetInformationUser)(
                UserHandle,
                UserInformationClass,
                Buffer
                ));

}



NTSTATUS
I_SamrGetGroupsForUser(
    IN                SAMPR_HANDLE            UserHandle,
    OUT               PSAMPR_GET_GROUPS_BUFFER *Groups
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamrGetGroupsForUser)(
                UserHandle,
                Groups
                ));
}


NTSTATUS
I_SamrCloseHandle(
    IN OUT            SAMPR_HANDLE    *       SamHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamrCloseHandle)( SamHandle ));
}



NTSTATUS
I_SamrQueryInformationUser(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    OUT               PSAMPR_USER_INFO_BUFFER *Buffer
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamrQueryInformationUser)(
                UserHandle,
                UserInformationClass,
                Buffer
                ));
}


NTSTATUS
I_SamrOpenUser(
    IN                SAMPR_HANDLE            DomainHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                ULONG                   UserId,
    OUT               SAMPR_HANDLE    *       UserHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamrOpenUser)(
            DomainHandle,
            DesiredAccess,
            UserId,
            UserHandle
            ));
}


NTSTATUS
I_SamrLookupNamesInDomain(
    IN                SAMPR_HANDLE            DomainHandle,
    IN                ULONG                   Count,
    IN                RPC_UNICODE_STRING      Names[],
    OUT               PSAMPR_ULONG_ARRAY      RelativeIds,
    OUT               PSAMPR_ULONG_ARRAY      Use
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamrLookupNamesInDomain)(
                DomainHandle,
                Count,
                Names,
                RelativeIds,
                Use
                ));
}

NTSTATUS
I_SamrLookupIdsInDomain(
    IN                SAMPR_HANDLE DomainHandle,
    IN                ULONG Count,
    IN                PULONG RelativeIds,
    OUT               PSAMPR_RETURNED_USTRING_ARRAY Names,
    OUT               PSAMPR_ULONG_ARRAY Use
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamrLookupIdsInDomain)(
                DomainHandle,
                Count,
                RelativeIds,
                Names,
                Use
                ));
}


NTSTATUS
I_SamrOpenDomain(
    IN                SAMPR_HANDLE            ServerHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                PRPC_SID                DomainId,
    OUT               SAMPR_HANDLE    *       DomainHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamrOpenDomain)(
                ServerHandle,
                DesiredAccess,
                DomainId,
                DomainHandle
                ));
}

NTSTATUS
I_SamrQueryInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    ){
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamrQueryInformationDomain)(
                DomainHandle,
                DomainInformationClass,
                Buffer
                ));
}



NTSTATUS
I_SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamIConnect)(
                ServerName,
                ServerHandle,
                DesiredAccess,
                TrustedClient
                ));
}


NTSTATUS
I_SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_SamIAccountRestrictions)(
                UserHandle,
                LogonWorkstation,
                Workstations,
                LogonHours,
                LogoffTime,
                KickoffTime
                ));
}

NTSTATUS
I_SamIGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamIGetUserLogonInformation)(
                DomainHandle,
                Flags,
                AccountName,
                Buffer,
                ReverseMembership,
                UserHandle
                ));
}


NTSTATUS
I_SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_SamIGetUserLogonInformationEx)(
                DomainHandle,
                Flags,
                AccountName,
                WhichFields,
                Buffer,
                ReverseMembership,
                UserHandle
                ));
}



VOID
I_SamIFree_SAMPR_GET_GROUPS_BUFFER (
    PSAMPR_GET_GROUPS_BUFFER Source
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }
    (*pI_SamIFree_SAMPR_GET_GROUPS_BUFFER)( Source );
}


VOID
I_SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFree_SAMPR_USER_INFO_BUFFER)(
            Source,
            Branch
            );
}


VOID
I_SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFree_SAMPR_ULONG_ARRAY)( Source );
}


VOID
I_SamIFree_SAMPR_RETURNED_USTRING_ARRAY(
    PSAMPR_RETURNED_USTRING_ARRAY Source
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFree_SAMPR_RETURNED_USTRING_ARRAY)( Source );
}

VOID
I_SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFreeSidAndAttributesList)( List );
}

VOID
I_SamIIncrementPerformanceCounter(
    IN SAM_PERF_COUNTER_TYPE CounterType
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIIncrementPerformanceCounter)( CounterType );
}

VOID
I_SamIFreeVoid(
    IN PVOID ptr
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_SamIFreeVoid)( ptr );
}

NTSTATUS
I_SamIUPNFromUserHandle(
    IN SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    return (*pI_SamIUPNFromUserHandle)( UserHandle, UPNDefaulted, UPN );
}

NTSTATUS
I_SamIUpdateLogonStatistics(
    IN  SAMPR_HANDLE UserHandle,
    IN  PSAM_LOGON_STATISTICS LogonStats
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    return (*pI_SamIUpdateLogonStatistics)( UserHandle, LogonStats );

}

NTSTATUS
I_LsaIOpenPolicyTrusted(
    OUT PLSAPR_HANDLE PolicyHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_LsaIOpenPolicyTrusted)( PolicyHandle ));
}


NTSTATUS
I_LsaIQueryInformationPolicyTrusted(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_LsaIQueryInformationPolicyTrusted)(
                InformationClass,
                Buffer
                ));
}

NTSTATUS
I_LsarClose(
    IN OUT            LSAPR_HANDLE    *       LsaHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarClose)( LsaHandle ));
}


NTSTATUS
I_LsarQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *PolicyInformation
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    return((*pI_LsarQueryInformationPolicy)(
                PolicyHandle,
                InformationClass,
                PolicyInformation
                ));
}


VOID
I_LsaIFree_LSAPR_POLICY_INFORMATION (
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_LsaIFree_LSAPR_POLICY_INFORMATION)(
            InformationClass,
            PolicyInformation
            );
}


NTSTATUS
I_LsarCreateSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarCreateSecret)(
        PolicyHandle,
        SecretName,
        DesiredAccess,
        SecretHandle ));
}

NTSTATUS
I_LsarOpenSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarOpenSecret)(
        PolicyHandle,
        SecretName,
        DesiredAccess,
        SecretHandle ));
}

NTSTATUS
I_LsarSetSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedOldValue
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarSetSecret)(
            SecretHandle,
            EncryptedCurrentValue,
            EncryptedOldValue
            ));
}

NTSTATUS
I_LsarQuerySecret(
    IN LSAPR_HANDLE SecretHandle,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    IN OUT OPTIONAL PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    IN OUT OPTIONAL PLARGE_INTEGER OldValueSetTime
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarQuerySecret)(
        SecretHandle,
        EncryptedCurrentValue,
        CurrentValueSetTime,
        EncryptedOldValue,
        OldValueSetTime));
}

NTSTATUS
I_LsarDelete(
    IN LSAPR_HANDLE ObjectHandle
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsarDelete)( ObjectHandle ));
}

VOID
I_LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }

    (*pI_LsaIFree_LSAPR_CR_CIPHER_VALUE)(
            CipherValue
            );
}



NTSTATUS NTAPI
I_LsaIRegisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsaIRegisterPolicyChangeNotificationCallback)(
        Callback,
        MonitorInfoClass
        ));

}

NTSTATUS NTAPI
I_LsaIUnregisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    )
{
    NTSTATUS Status;
    if (!SrvDllsLoaded)
    {
        Status = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }
    return((*pI_LsaIUnregisterPolicyChangeNotificationCallback)(
        Callback,
        MonitorInfoClass
        ));

}

NTSTATUS
I_LsaIAuditAccountLogon(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             Status          OPTIONAL
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }
    return((*pI_LsaIAuditAccountLogon)(
                AuditId,
                Successful,
                Source,
                ClientName,
                MappedName,
                Status
                ));
}

NTSTATUS
I_LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }
    return (*pI_LsaIGetLogonGuid)(
                pUserName,
                pUserDomain,
                pBuffer,
                BufferSize,
                pLogonGuid
                );
}

NTSTATUS
I_LsaISetLogonGuidInLogonSession(
    IN  PLUID  pLogonId,
    IN  LPGUID pLogonGuid
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    return (*pI_LsaISetLogonGuidInLogonSession)(
                pLogonId,
                pLogonGuid
                );
}


VOID
I_LsaIAuditKerberosLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID pLogonId,
    IN LPGUID pLogonGuid
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return;
        }
    }
    (*pI_LsaIAuditKerberosLogon)(
           LogonStatus,
           LogonSubStatus,
           AccountName,
           AuthenticatingAuthority,
           WorkstationName,
           UserSid,
           LogonType,
           TokenSource,
           pLogonId,
           pLogonGuid
           );
}

NTSTATUS
I_LsaIAuditLogonUsingExplicitCreds(
    IN USHORT          AuditEventType,
    IN PSID            pUser1Sid,
    IN PUNICODE_STRING pUser1Name,
    IN PUNICODE_STRING pUser1Domain,
    IN PLUID           pUser1LogonId,
    IN LPGUID          pUser1LogonGuid,
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    }
    return (*pI_LsaIAuditLogonUsingExplicitCreds)(
                  AuditEventType,
                  pUser1Sid,
                  pUser1Name,
                  pUser1Domain,
                  pUser1LogonId,
                  pUser1LogonGuid,
                  pUser2Name,
                  pUser2Domain,
                  pUser2LogonGuid
                  );
}

NTSTATUS
I_LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }
    return((*pI_LsaICallPackage)(
                AuthenticationPackage,
                ProtocolSubmitBuffer,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus
                ));
}


NTSTATUS
I_LsaIAddNameToLogonSession(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  PUNICODE_STRING Name
    )
{
    NTSTATUS NtStatus;
    if (!SrvDllsLoaded)
    {
        NtStatus = EnsureSrvDllsLoaded();
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    return((*pI_LsaIAddNameToLogonSession)(
                LogonId,
                NameFormat,
                Name));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\wxlpc\client\rng.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

//
// This file exports four functions: InitializeRNG, ShutdownRNG, GenRandom, and
// GenerateRandomBits, which are used to generate random sequences of bytes.
//

#include <windows.h>
#include <rng.h>
#include <rc4.h>
#include <sha.h>

#define A_SHA_DIGEST_LEN    20
#define RAND_CTXT_LEN       60
#define RC4_REKEY_PARAM     500     // rekey every 500 bytes

#define UNLEN   MAX_PATH

typedef struct _RandContext
{
    DWORD dwBitsFilled;
    BYTE  rgbBitBuffer[RAND_CTXT_LEN];
} RandContext;

#if 0
CRITICAL_SECTION    csRNG;

#define LockRNG()   EnterCriticalSection( &csRNG )
#define UnlockRNG() LeaveCriticalSection( &csRNG )
#else
#define LockRNG()
#define UnlockRNG()
#endif

unsigned char g_rgbStaticBits[A_SHA_DIGEST_LEN];
static DWORD         g_dwRC4BytesUsed = RC4_REKEY_PARAM;     // initially force rekey
static struct RC4_KEYSTRUCT g_rc4key;

static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength);
static void GatherRandomBits(RandContext *prandContext);
static void AppendRand(RandContext* prandContext, void* pv, DWORD dwSize);

/*****************************************************************************/
VOID STInitializeRNG(VOID)
{
    DWORD dwType;
    DWORD dwSize;

    LONG err;

#if 0

    InitializeCriticalSection( &csRNG );

    LockRNG();

    // grab seed from persistent storage

//    SPQueryPersistentSeed(g_rgbStaticBits, A_SHA_DIGEST_LEN);
#endif

    g_dwRC4BytesUsed = RC4_REKEY_PARAM;

#if 0
    UnlockRNG();
#endif

    return;
}

VOID STShutdownRNG(VOID)
{

#if 0
    DeleteCriticalSection( &csRNG );
#endif

    // put seed into persistent storage

//    SPSetPersistentSeed(g_rgbStaticBits, A_SHA_DIGEST_LEN);

    return;
}

/*****************************************************************************/
int STGenRandom(PVOID Reserved,
              UCHAR *pbBuffer,
              size_t dwLength)
{
    STGenerateRandomBits(pbBuffer, dwLength);
    return TRUE;
}

/************************************************************************/
/* GenerateRandomBits generates a specified number of random bytes and        */
/* places them into the specified buffer.                                */
/************************************************************************/
/*                                                                      */
/* Pseudocode logic flow:                                               */
/*                                                                      */
/* if (bits streamed > threshold)                                       */
/* {                                                                    */
/*  Gather_Bits()                                                       */
/*  SHAMix_Bits(User, Gathered, Static -> Static)                       */
/*  RC4Key(Static -> newRC4Key)                                         */
/*  SHABits(Static -> Static)      // hash after RC4 key generation     */
/* }                                                                    */
/* else                                                                 */
/* {                                                                    */
/*  SHAMix_Bits(User, Static -> Static)                                 */
/* }                                                                    */
/*                                                                      */
/* RC4(newRC4Key -> outbuf)                                             */
/* bits streamed += sizeof(outbuf)                                      */
/*                                                                      */
/************************************************************************/
VOID STGenerateRandomBits(PUCHAR pbBuffer,
                        ULONG  dwLength)
{
    DWORD dwBytesThisPass;
    DWORD dwFilledBytes = 0;

    // break request into chunks that we rekey between

    LockRNG();

    while(dwFilledBytes < dwLength)
    {
        dwBytesThisPass = dwLength - dwFilledBytes;

        RandomFillBuffer(pbBuffer + dwFilledBytes, &dwBytesThisPass);
        dwFilledBytes += dwBytesThisPass;
    }

    UnlockRNG();
}

/*****************************************************************************/
static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength)
{
    // Variables from loading and storing the registry...
    DWORD   cbDataLen;

    cbDataLen = A_SHA_DIGEST_LEN;

    if(g_dwRC4BytesUsed >= RC4_REKEY_PARAM) {
        // if we need to rekey

        RandContext randContext;
        randContext.dwBitsFilled = 0;

        GatherRandomBits(&randContext);

        // Mix all bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the gathered bits
            A_SHAUpdate(&SHACtx, randContext.rgbBitBuffer, randContext.dwBitsFilled);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

        // Create RC4 key
        g_dwRC4BytesUsed = 0;
        rc4_key(&g_rc4key, A_SHA_DIGEST_LEN, g_rgbStaticBits);

        // Mix RC4 key bits around
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

    } else {
        // Use current RC4 key, but capture any user-supplied bits.

        // Mix input bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }
    }

    // only use RC4_REKEY_PARAM bytes from each RC4 key
    {
        DWORD dwMaxPossibleBytes = RC4_REKEY_PARAM - g_dwRC4BytesUsed;
        if(*pdwLength > dwMaxPossibleBytes) {
                *pdwLength = dwMaxPossibleBytes;
        }
    }

    FillMemory(pbBuffer, *pdwLength, 0);
    rc4(&g_rc4key, *pdwLength, pbBuffer);

    g_dwRC4BytesUsed += *pdwLength;

    return TRUE;
}

/*****************************************************************************/
static void GatherRandomBits(RandContext *prandContext)
{
    DWORD   dwTmp;
    WORD    wTmp;
    BYTE    bTmp;

    // ** indicates US DoD's specific recommendations for password generation

    // proc id
    dwTmp = GetCurrentProcessId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // thread id
    dwTmp = GetCurrentThreadId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // ** ticks since boot (system clock)
    dwTmp = GetTickCount();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // cursor position
    {
        POINT                        point;
        GetCursorPos(&point);
        bTmp = LOBYTE(point.x) ^ HIBYTE(point.x);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
        bTmp = LOBYTE(point.y) ^ HIBYTE(point.y);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** system time, in ms, sec, min (date & time)
    {
        SYSTEMTIME                sysTime;
        GetLocalTime(&sysTime);
        AppendRand(prandContext, &sysTime.wMilliseconds, sizeof(sysTime.wMilliseconds));
        bTmp = LOBYTE(sysTime.wSecond) ^ LOBYTE(sysTime.wMinute);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** hi-res performance counter (system counters)
    {
        LARGE_INTEGER        liPerfCount;
        if(QueryPerformanceCounter(&liPerfCount)) {
            bTmp = LOBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = LOBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
        }
    }

    // memory status
    {
        MEMORYSTATUS        mstMemStat;
        mstMemStat.dwLength = sizeof(MEMORYSTATUS);     // must-do
        GlobalMemoryStatus(&mstMemStat);
        wTmp = HIWORD(mstMemStat.dwAvailPhys);          // low words seem to be always zero
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        wTmp = HIWORD(mstMemStat.dwAvailPageFile);
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        bTmp = LOBYTE(HIWORD(mstMemStat.dwAvailVirtual));
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // free disk clusters
    {
        DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
        if(GetDiskFreeSpace(NULL, &dwSectorsPerCluster, &dwBytesPerSector,     &dwNumberOfFreeClusters, &dwTotalNumberOfClusters)) {
            AppendRand(prandContext, &dwNumberOfFreeClusters, sizeof(dwNumberOfFreeClusters));
            AppendRand(prandContext, &dwTotalNumberOfClusters, sizeof(dwTotalNumberOfClusters));
            AppendRand(prandContext, &dwBytesPerSector, sizeof(dwBytesPerSector));
        }
    }

    // last messages' timestamp
    {
        LONG lTime;
        lTime = GetMessageTime();
        AppendRand(prandContext, &lTime, sizeof(lTime));
    }

    {
        static DWORD dwComputerNameSize;
        static DWORD dwUserNameSize;
        static char lpComputerName [MAX_COMPUTERNAME_LENGTH + 1];
        static char lpUserName [UNLEN + 1];

        //
        // note use of two temp DWORDs - that's to keep the static DWORDs
        // thread safe
        //

        // **SystemID
        if(dwComputerNameSize == 0) {
            DWORD dwTempComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;

            if(GetComputerNameA(lpComputerName, &dwTempComputerNameSize))
                dwComputerNameSize = dwTempComputerNameSize;
        }

        if(dwComputerNameSize != 0) {
            // dwComputerNameSize = len not including null termination
            AppendRand(prandContext, lpComputerName, dwComputerNameSize);
        }

        // **UserID
        if(dwUserNameSize == 0) {
            DWORD dwTempUserNameSize = UNLEN + 1;

            if(GetUserNameA(lpUserName, &dwTempUserNameSize)) {
                // dwUserNameSize = len including null termination
                dwUserNameSize = dwTempUserNameSize - 1;
            }
        }

        if(dwUserNameSize != 0) {
            AppendRand(prandContext, lpUserName, dwUserNameSize);
        }
    }
}

/*****************************************************************************/
static void AppendRand(RandContext* prandContext, void* pv, DWORD dwSize)
{
    DWORD dwBitsLeft = (RAND_CTXT_LEN - prandContext->dwBitsFilled);

    if(dwBitsLeft > 0) {
        if(dwSize > dwBitsLeft) {
            dwSize = dwBitsLeft;
        }

        CopyMemory(prandContext->rgbBitBuffer + prandContext->dwBitsFilled, pv, dwSize);
        prandContext->dwBitsFilled += dwSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\wxlpc\client\testcli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       testcli.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wxlpc.h>

char _hex[] = "0123456789abcdef" ;
#define fromhex(x)  _hex[x & 0xF]
UCHAR GoodMatch[16] = { 0xf3, 0xd5, 0xae, 0xc5,
                       0x03, 0xa4, 0xde, 0x02,
                       0xb0, 0x74, 0xe2, 0xf9,
                       0xc2, 0x04, 0xd9, 0x06 };

VOID
DumpBits(
    CHAR * Data,
    CHAR * Tag
    )
{
    ULONG i ;
    CHAR Text[ 80 ] ;
    CHAR Text2[ 80 ];
    PCHAR Str ;
    PCHAR Str2 ;

    Str = Text ;
    Str2 = Text2 ;

    for (i = 0 ; i < 16 ; i++ )
    {
        *Str = fromhex( (Data[i] >> 4) );
        Str++;
        *Str = fromhex( Data[i] );
        Str++;
        *Str = ' ';
        Str++ ;

        if ( Data[i] >= 32 && Data[i] < 128 )
        {
            *Str2++ = Data[i] ;
        }
        else
        {
            *Str2++ = '.';
        }
    }
    *Str++ = '\0';
    *Str2++ = '\0';

    DbgPrint( "%s\n", Tag );
    DbgPrint( "%s %s\n", Text, Text2 );

}
void __cdecl main (int argc, char *argv[])
{
    HANDLE hWx ;
    NTSTATUS Status ;
    UCHAR Data[ 16 ];
    ULONG DataLen ;
    ULONG tries = 3;

    Status = WxConnect( &hWx );

    if ( !NT_SUCCESS( Status ) )
    {
        DbgPrint( "Failed to connect, %x\n", Status );
        return;
    }

    WxReportResults( hWx, STATUS_SUCCESS );

    return ;

    while ( tries-- )
    {
        Status = WxGetKeyData( hWx, WxPrompt, sizeof( Data ), Data, &DataLen );

        if ( !NT_SUCCESS( Status ) )
        {
            DbgPrint( "WxGetKeyData FAILED, %x\n", Status );
            NtClose( hWx );
            return;
        }

        DumpBits( Data, "WxGetKeyData returned:" );

        if ( RtlEqualMemory( Data, GoodMatch, 16 ) )
        {
            WxReportResults( hWx, STATUS_SUCCESS );

            NtClose( hWx );

            return;
        }

        WxReportResults( hWx, STATUS_UNSUCCESSFUL );

        DumpBits( GoodMatch, "Wanted");

    }

    NtClose( hWx );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\wxlpc\server\testsrv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       testsrv.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wxlpc.h>
#include <windows.h>

char _hex[] = "0123456789abcdef" ;
#define fromhex(x)  _hex[x & 0xF]


NTSTATUS
WxGetKeyData(
    HANDLE Ignored,
    WX_AUTH_TYPE ExpectedAuth,
    ULONG BufferSize,
    PUCHAR Buffer,
    PULONG BufferData
    )
{
    RtlCopyMemory( Buffer, _hex, BufferSize );
    *BufferData = BufferSize ;
    return STATUS_SUCCESS ;

}

NTSTATUS
WxReportResults(
    HANDLE Ignored,
    NTSTATUS Status
    )
{
    return STATUS_SUCCESS ;
}

VOID
WxClientDisconnect(
    HANDLE ignored
    )
{
    DbgPrint("Client Disconnect\n");
}

ULONG
ThreadWrapper(
    PVOID Ignored
    )
{
    NTSTATUS Status ;

    Status = WxServerThread( Ignored );

    DbgPrint( "WxServerThread returned %x\n", Status );

    return 0 ;

}

void __cdecl main (int argc, char *argv[])
{
    HANDLE Thread ;
    ULONG Tid ;

    DbgPrint( "Starting up server thread:\n" );

    Thread = CreateThread( 0, NULL, ThreadWrapper, NULL, 0, &Tid );

    if ( Thread )
    {
        DbgPrint( "Waiting on thread\n" );
        WaitForSingleObject( Thread, INFINITE );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\wxlpc\client\wxcli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxcli.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <caiseapi.h>

#include <windows.h>
#include <windef.h>
#include <md5.h>

#include <wxlpc.h>
#include <wxlpcp.h>

#include "rng.h"

#define safe_min(x,y)   ( x < y ? x : y )

NTSTATUS
WxConnect(
    PHANDLE Handle
    )
{
    NTSTATUS Status ;
    UNICODE_STRING PortName ;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;




    //
    // Connect to the Winlogon server thread
    //

    RtlInitUnicodeString(&PortName, WX_PORT_NAME );
    Status = NtConnectPort(
                 Handle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );

    if ( !NT_SUCCESS(Status) )
    {
        // DbgPrint("WX: Connection failed %lx\n",Status);
    }


    return Status;
}

NTSTATUS
WxGetKeyData(
    IN HANDLE Handle,
    IN WX_AUTH_TYPE ExpectedAuthSource,
    IN ULONG BufferSize,
    OUT PUCHAR Buffer,
    OUT PULONG BufferData
    )
{
    WXLPC_MESSAGE Message ;
    NTSTATUS Status ;
    WXLPC_GETKEYDATA * Parameters ;

    PREPARE_MESSAGE( Message, WxGetKeyDataApi );

    Parameters = &Message.Parameters.GetKeyData ;

    Parameters->ExpectedAuth = ExpectedAuthSource ;
    Parameters->BufferSize = BufferSize ;

    Status = NtRequestWaitReplyPort(
                    Handle,
                    &Message.Message,
                    &Message.Message );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    if ( NT_SUCCESS( Message.Status ) )
    {
        RtlCopyMemory(  Buffer,
                        Parameters->Buffer,
                        safe_min( Parameters->BufferData, BufferSize ) );
    }

    return Message.Status ;
}

NTSTATUS
WxReportResults(
    IN HANDLE Handle,
    IN NTSTATUS ResultStatus
    )
{
    WXLPC_MESSAGE Message ;
    NTSTATUS Status ;
    WXLPC_REPORTRESULTS * Parameters ;

    PREPARE_MESSAGE( Message, WxReportResultsApi );

    Parameters = &Message.Parameters.ReportResults ;

    Parameters->Status = ResultStatus ;

    Status = NtRequestWaitReplyPort(
                    Handle,
                    &Message.Message,
                    &Message.Message );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    return Message.Status ;

}


/*++

    The following code was moved from syskey to wxcli so as to commonalize this code
    between syskey and samsrv.dll 

--*/
#if DBG
#define HIDDEN
#else
#define HIDDEN static
#endif

HIDDEN
UCHAR KeyShuffle[ 16 ] = { 8, 10, 3, 7, 2, 1, 9, 15, 0, 5, 13, 4, 11, 6, 12, 14 };

HIDDEN
CHAR HexKey[ 17 ] = "0123456789abcdef" ;

#define ToHex( f ) (HexKey[f & 0xF])

#define SYSTEM_KEY L"SecureBoot"



HIDDEN BOOLEAN
WxpDeleteLocalKey(VOID)
/*++

    Routine Description

    Deletes the syskey stored on the local machine

--*/
{
    HKEY LsaKey;
    ULONG err;

    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"System\\CurrentControlSet\\Control\\Lsa",
                      0,
                      KEY_READ | KEY_WRITE,
                      & LsaKey );

    if (0!=err)
    {
        return (FALSE);
    }

    (void) RegDeleteKey( LsaKey, TEXT("Data") );
    (void) RegDeleteKey( LsaKey, TEXT("Skew1") );
    (void) RegDeleteKey( LsaKey, TEXT("GBG") );
    (void) RegDeleteKey( LsaKey, TEXT("JD") );

    RegCloseKey(LsaKey);

    return STATUS_SUCCESS ;

}


HIDDEN BOOLEAN
WxpObfuscateKey(
    PWXHASH   Hash
    )
{
    HKEY Key ;
    HKEY Key2 ;
    int Result ;
    WXHASH H ;
    CHAR Classes[ 9 ];
    int i ;
    WXHASH R ;
    PCHAR Class ;
    DWORD Disp ;
    DWORD FailCount = 0;
    HKEY LsaKey;
    ULONG err=0;
  



     err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"System\\CurrentControlSet\\Control\\Lsa",
                      0,
                      KEY_READ | KEY_WRITE,
                      & LsaKey );

    if (0!=err)
    {
        return (FALSE);
    }

    for (Result = 0 ; Result < 16 ; Result++ )
    {
        H.Digest[Result] = Hash->Digest[ KeyShuffle[ Result ] ];
    }

    WxpDeleteLocalKey();

    Classes[8] = '\0';

    STGenerateRandomBits( R.Digest, 16 );

    Class = Classes ;

    for ( i = 0 ; i < 4 ; i++ )
    {
        *Class++ = ToHex( (H.Digest[ i ] >> 4) );
        *Class++ = ToHex( H.Digest[ i ] );
    }

    Result = RegCreateKeyExA( LsaKey,
                              "JD",
                              0,
                              Classes,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key,
                              &Disp );

    if ( Result == 0 )
    {
        RegSetValueEx( Key, TEXT("Lookup"), 0,
                        REG_BINARY, R.Digest, 6 );

        RegCloseKey( Key );
    }

    else
    {
        RegCloseKey(LsaKey);
        return FALSE ;
    }

    Class = Classes ;

    for ( i = 0 ; i < 4 ; i++ )
    {
        STGenerateRandomBits( R.Digest, 16 );

        *Class++ = ToHex( (H.Digest[ i+4 ] >> 4 ) );
        *Class++ = ToHex( H.Digest[ i+4 ] );
    }

    Result = RegCreateKeyExA( LsaKey,
                              "Skew1",
                              0,
                              Classes,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key,
                              &Disp );

    if ( Result == 0 )
    {
        RegSetValueEx( Key, TEXT("SkewMatrix"), 0,
                        REG_BINARY, R.Digest, 16 );

        RegCloseKey( Key );
    }
    else
    {
        FailCount++;
    }

    STGenerateRandomBits( R.Digest, 16 );

    for ( i = 0, Class = Classes ; i < 4 ; i++ )
    {
        *Class++ = ToHex( (H.Digest[ i+8 ] >> 4 ));
        *Class++ = ToHex( H.Digest[i+8] );
    }

    Result = RegCreateKeyExA( LsaKey,
                              "GBG",
                              0,
                              Classes,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key,
                              &Disp );

    if ( Result == 0 )
    {
        RegSetValueEx( Key, TEXT("GrafBlumGroup"), 0,
                        REG_BINARY, R.Digest, 9 );

        RegCloseKey( Key );
    }
    else
    {
        FailCount++;
    }

    STGenerateRandomBits( H.Digest, 8 );

    Class = Classes ;

    STGenerateRandomBits( R.Digest, 16 );

    for ( i = 0 ; i < 4 ; i++ )
    {
        *Class++ = ToHex( (H.Digest[ i+12 ] >> 4 ) );
        *Class++ = ToHex( H.Digest[ i+12 ] );
    }

    Result = RegCreateKeyExA( LsaKey,
                              "Data",
                              0,
                              Classes,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &Key,
                              &Disp );

    if ( Result == 0 )
    {
        STGenerateRandomBits( H.Digest, 16 );

        RegSetValueEx( Key, TEXT("Pattern"), 0,
                        REG_BINARY, R.Digest, 64 );

        RegCloseKey( Key );
    }
    else
    {
        FailCount++;
    }

    RegCloseKey(LsaKey);
    return TRUE ;

}


#define FromHex( c )    ( ( ( c >= '0' ) && ( c <= '9') ) ? c - '0' :      \
                          ( ( c >= 'a' ) && ( c <= 'f') ) ? c - 'a' + 10:      \
                          ( ( c >= 'A' ) && ( c <= 'F' ) ) ? c - 'A' + 10: -1 )
                          
HIDDEN BOOLEAN
WxpDeObfuscateKey(
    HKEY Keylocation,
    PWXHASH   Hash
    )
{
    WXHASH ProtoHash ;
    int Result ;
    CHAR Class[ 9 ];
    HKEY Key ;
    DWORD Size ;
    DWORD i ;
    PUCHAR j ;
    int t;
    int t2 ;
    HKEY LsaKey;
    ULONG err;


    if (Keylocation!=NULL) {

        DWORD Type=REG_DWORD;
        DWORD Data;
        DWORD cbData=sizeof(DWORD);
        WCHAR Controlset[256];

        err = RegOpenKeyExW( Keylocation,
                          L"Select",
                          0,
                          KEY_READ | KEY_WRITE,
                          & LsaKey );
        if (0!=err)
        {
            return (FALSE);
        }

        err = RegQueryValueExW(
                          LsaKey, 
                          L"Default",
                          NULL,
                          &Type,       
                          (LPBYTE)&Data,
                          &cbData
                        );
        RegCloseKey(LsaKey);
        if (0!=err)
        {
            return (FALSE);
        }

        if(Data==1){   
            err = RegOpenKeyExW( Keylocation,
                              L"ControlSet001\\Control\\Lsa",
                              0,
                              KEY_READ | KEY_WRITE,
                              & LsaKey );
        } else {
            err = RegOpenKeyExW( Keylocation,
                              L"ControlSet002\\Control\\Lsa",
                              0,
                              KEY_READ | KEY_WRITE,
                              & LsaKey );
        }
        if (0!=err)
        {
            RegCloseKey(LsaKey);
            return (FALSE);
        }
    
    } else {
    
        err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                          L"System\\CurrentControlSet\\Control\\Lsa",
                          0,
                          KEY_READ | KEY_WRITE,
                          & LsaKey );
    
        if (0!=err)
        {
             return (FALSE);
        }
    }

    Result = RegOpenKeyEx( LsaKey, TEXT("JD"), 0,
                               KEY_READ, &Key );
    j = ProtoHash.Digest ;

    if ( Result == 0 )
    {
        Size = 9 ;

        Result = RegQueryInfoKeyA( Key,
                                   Class,
                                   &Size,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL );

        RegCloseKey( Key );

        if ( Result == 0 )
        {
            for ( i = 0 ; i < 8 ; i += 2 )
            {
                t = FromHex( Class[ i ] );
                t2 = FromHex( Class[ i+1 ] );
                if ( (t >= 0 ) && ( t2 >= 0 ) )
                {
                    *j++ = (t << 4) + t2 ;
                }
                else
                {
                    RegCloseKey(LsaKey);
                    return FALSE ;
                }
            }

        }

    }

    Result = RegOpenKeyEx( LsaKey, TEXT("Skew1"), 0,
                            KEY_READ, &Key );

    if ( Result == 0 )
    {
        Size = 9 ;

        Result = RegQueryInfoKeyA( Key,
                                   Class,
                                   &Size,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL );

        RegCloseKey( Key );

        if ( Result == 0 )
        {
            for ( i = 0 ; i < 8 ; i += 2 )
            {
                t = FromHex( Class[ i ] );
                t2 = FromHex( Class[ i+1 ] );
                if ( (t >= 0 ) && ( t2 >= 0 ) )
                {
                    *j++ = (t << 4) + t2 ;
                }
                else
                {
                    RegCloseKey(LsaKey);
                    return FALSE ;
                }
            }

        }

    }

    Result = RegOpenKeyEx( LsaKey, TEXT("GBG"), 0,
                            KEY_READ, &Key );

    if ( Result == 0 )
    {
        Size = 9 ;

        Result = RegQueryInfoKeyA( Key,
                                   Class,
                                   &Size,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL );

        RegCloseKey( Key );

        if ( Result == 0 )
        {
            for ( i = 0 ; i < 8 ; i += 2 )
            {
                t = FromHex( Class[ i ] );
                t2 = FromHex( Class[ i+1 ] );
                if ( (t >= 0 ) && ( t2 >= 0 ) )
                {
                    *j++ = (t << 4) + t2 ;
                }
                else
                {
                    RegCloseKey(LsaKey);
                    return FALSE ;
                }
            }

        }

    }

    Result = RegOpenKeyEx( LsaKey, TEXT("Data"), 0,
                            KEY_READ, &Key );

    if ( Result == 0 )
    {
        Size = 9 ;

        Result = RegQueryInfoKeyA( Key,
                                   Class,
                                   &Size,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL,
                                   NULL, NULL, NULL );

        RegCloseKey( Key );

        if ( Result == 0 )
        {
            for ( i = 0 ; i < 8 ; i += 2 )
            {
                t = FromHex( Class[ i ] );
                t2 = FromHex( Class[ i+1 ] );
                if ( (t >= 0 ) && ( t2 >= 0 ) )
                {
                    *j++ = (t << 4) + t2 ;
                }
                else
                {
                    RegCloseKey(LsaKey);
                    return FALSE ;
                }
            }

        }

    }

    for ( i = 0 ; i < 16 ; i++ )
    {
        Hash->Digest[ KeyShuffle[ i ] ] = ProtoHash.Digest[ i ] ;
    }

    RegCloseKey(LsaKey);
    return TRUE ;

}

NTSTATUS
WxSaveSysKey(
    IN ULONG    Keylen,
    IN PVOID    Key
    )
    /*++

    Routine Description

    This routine is used to store the syskey 
    in the registry

    Paramaeters

        Keylen - the length of the key
        Key      the actual key itself

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    WXHASH H;

    //
    // key should be 128 bits
    //

    if (Keylen!=sizeof(H.Digest))
        return (STATUS_INVALID_PARAMETER);

    RtlCopyMemory(&H.Digest,
                  Key,
                  Keylen
                  );

    if (WxpObfuscateKey(&H))
    {
    
        return(STATUS_SUCCESS);

    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }
}



NTSTATUS
WxReadSysKey(
    IN OUT PULONG BufferLength,
    OUT PVOID  Key 
    )
 /*++

    Routine Description

    This routine is used to retrieve the syskey from
    the registry

    Paramaeters

        BufferLength  is filled in with the length required on output
                      is used to indicate the size of the buffer 
                      pointed to by Key.
        Key           Points to a buffer into which the key is recieved

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    return WxReadSysKeyEx(
                        NULL,
                        BufferLength,
                        Key 
                        );
}

NTSTATUS
WxReadSysKeyEx(
    IN HKEY Handle,
    IN OUT PULONG BufferLength,
    OUT PVOID  Key 
    )
 /*++

    Routine Description

    This routine is used to retrieve the syskey from
    the registry

    Paramaeters
    
        Handle        Contains a pointer to the syskey in the old registry

        BufferLength  is filled in with the length required on output
                      is used to indicate the size of the buffer 
                      pointed to by Key.
        Key           Points to a buffer into which the key is recieved

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    WXHASH H;

    if ((NULL==Key) || (*BufferLength <sizeof(H.Digest)))
    {
        *BufferLength = sizeof(H.Digest);
        return(STATUS_BUFFER_OVERFLOW);
    }

    if (WxpDeObfuscateKey(Handle,&H))
    {
          *BufferLength = sizeof(H.Digest);
          RtlCopyMemory(
                  Key,
                  &H.Digest,
                  *BufferLength
                  );

          return(STATUS_SUCCESS);
    }

    return (STATUS_UNSUCCESSFUL);
       
}

NTSTATUS
WxLoadSysKeyFromDisk(OUT PVOID Key,
                     OUT PULONG BufferLength
                     )
/*++

    Routine Description

    This routine is used to read the syskey
    from the Disk
    
    Paramaeters

        Key - buffer where the key will be read into
          
        BufferLength - size of the returned key

    Return Values

        STATUS_OBJECT_NAME_NOT_FOUND
        STATUS_FILE_CORRUPT_ERROR
        STATUS_UNSUCCESSFUL
--*/
{
    HANDLE  hFile ;
    ULONG Actual ;
    ULONG ErrorMode ;

    LPSTR SysKeyFileName = "A:\\startkey.key";
    
    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
    
    hFile = CreateFileA( SysKeyFileName,
                         GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );
    
    
    
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        SetErrorMode( ErrorMode );
    
        return STATUS_OBJECT_NAME_NOT_FOUND ;
    }
    
    if (!ReadFile( hFile, Key, SYSKEY_SIZE, &Actual, NULL ) ||
        (Actual != SYSKEY_SIZE ))
    {
        SetErrorMode( ErrorMode );
    
        CloseHandle( hFile );
    
        return STATUS_FILE_CORRUPT_ERROR ;
    
    }
    
    SetErrorMode( ErrorMode );
    
    CloseHandle( hFile );

    *BufferLength = SYSKEY_SIZE;
    return STATUS_SUCCESS;
}

NTSTATUS
WxHashKey(
    IN OUT LPWSTR key,  //will be killed
    OUT PVOID  SysKey,
    IN  OUT DWORD cbSysKey
    )
/*++

    Routine Description

    This routine is used to store the boot type
    in the registry

    Paramaeters

        NewType Indicates the new boot type

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    MD5_CTX Md5;
    if(cbSysKey<SYSKEY_SIZE) {
        return STATUS_BUFFER_TOO_SMALL;
    }
    cbSysKey=wcslen(key)*sizeof(WCHAR);

    MD5Init( &Md5 );
    MD5Update( &Md5, (PUCHAR) key, cbSysKey );
    MD5Final( &Md5 );

    ZeroMemory( key, cbSysKey );

    cbSysKey=SYSKEY_SIZE;
    CopyMemory( SysKey, Md5.digest, cbSysKey );

    return STATUS_SUCCESS;
}



NTSTATUS
WxSaveBootOption( WX_AUTH_TYPE NewType )
/*++

    Routine Description

    This routine is used to store the boot type
    in the registry

    Paramaeters

        NewType Indicates the new boot type

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    HKEY LsaKey;
    ULONG err;
   
    err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  L"System\\CurrentControlSet\\Control\\Lsa",
                  0,
                  KEY_READ | KEY_WRITE,
                  & LsaKey );

    if (0!=err)
    {
     return (STATUS_UNSUCCESSFUL);
    }

    err = RegSetValueExW( 
                LsaKey,
                SYSTEM_KEY,
                0,
                REG_DWORD,
                (PUCHAR) &NewType,
                sizeof( NewType )
                );

    if (0!=err)
    {
     RegCloseKey(LsaKey);
     return (STATUS_UNSUCCESSFUL);
    }

    RegCloseKey(LsaKey);

    return ( STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\wxlpc\inc\wxlpcp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxlpcp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __WXLPCP_H__
#define __WXLPCP_H__

typedef enum _WXLPC_MTYPE {
    WxGetKeyDataApi,
    WxReportResultsApi,
    WxMaxValueApi
} WXLPC_MTYPE ;

typedef struct _WXLPC_GETKEYDATA {
    WX_AUTH_TYPE ExpectedAuth ;
    ULONG BufferSize ;
    ULONG BufferData ;
    UCHAR Buffer[ 16 ];
} WXLPC_GETKEYDATA ;

typedef struct _WXLPC_REPORTRESULTS {
    NTSTATUS Status ;
} WXLPC_REPORTRESULTS ;

typedef struct _WXLPC_MESSAGE {
    PORT_MESSAGE    Message;
    NTSTATUS        Status ;
    WXLPC_MTYPE     Api ;
    union {
        WXLPC_GETKEYDATA    GetKeyData ;
        WXLPC_REPORTRESULTS ReportResults ;
    } Parameters ;
} WXLPC_MESSAGE, * PWXLPC_MESSAGE ;

#define WX_PORT_NAME    L"\\Security\\WxApiPort"
//#define WX_PORT_NAME L"\\BaseNamedObjects\\WxApiPort"

#define PREPARE_MESSAGE( Message, ApiCode ) \
    (Message).Message.u1.s1.DataLength = sizeof((Message)) - sizeof(PORT_MESSAGE); \
    (Message).Message.u1.s1.TotalLength = sizeof((Message)); \
    (Message).Message.u2.ZeroInit = 0L; \
    (Message).Api = ApiCode ;


#endif // __WXLPCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\common\wxlpc\server\wxsrv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxsrv.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wxlpc.h>
#include <wxlpcp.h>

NTSTATUS
WxpHandleRequest(
    HANDLE Client,
    PWXLPC_MESSAGE Message
    )
{
    WXLPC_GETKEYDATA * GetKey ;
    WXLPC_REPORTRESULTS * ReportResults ;

    switch ( Message->Api )
    {
        case WxGetKeyDataApi:
            GetKey = & Message->Parameters.GetKeyData ;

            if ( ( GetKey->ExpectedAuth != WxNone ) &&
                 ( GetKey->ExpectedAuth != WxStored ) &&
                 ( GetKey->ExpectedAuth != WxPrompt ) &&
                 ( GetKey->ExpectedAuth != WxDisk ) )
            {
                Message->Status = STATUS_INVALID_PARAMETER ;
                break;
            }

            if ( GetKey->BufferSize > 16 )
            {
                Message->Status = STATUS_INVALID_PARAMETER ;
                break;
            }

            Message->Status = WxGetKeyData( NULL,
                                            GetKey->ExpectedAuth,
                                            GetKey->BufferSize,
                                            GetKey->Buffer,
                                            &GetKey->BufferData
                                            );
            break;

        case WxReportResultsApi:
            ReportResults = &Message->Parameters.ReportResults ;

            Message->Status = WxReportResults( NULL,
                                               ReportResults->Status
                                               );

            break;

        default:
            Message->Status = STATUS_NOT_IMPLEMENTED ;
            break;

    }

    return NtReplyPort( Client, &Message->Message );
}


NTSTATUS
WxServerThread(
    PVOID Ignored
    )
{
    HANDLE Port ;
    HANDLE ClientPort = NULL ;
    HANDLE RejectPort ;
    OBJECT_ATTRIBUTES Obja ;
    UNICODE_STRING PortName ;
    NTSTATUS Status ;
    WXLPC_MESSAGE Message ;
    PVOID Context ;


    //
    // Initialize the port:
    //

    RtlInitUnicodeString( &PortName, WX_PORT_NAME );

    InitializeObjectAttributes( &Obja,
                                &PortName,
                                0,
                                NULL,
                                NULL );

    Status = NtCreatePort(  &Port,
                            &Obja,
                            sizeof( ULONG ),
                            sizeof( WXLPC_MESSAGE ),
                            sizeof( WXLPC_MESSAGE )
                            );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    //
    // Now, wait for a connection:
    //

    Context = NULL ;

    while ( Port )
    {
        Status = NtReplyWaitReceivePort(Port,
                                        &Context,
                                        NULL,
                                        &Message.Message );

        if ( !NT_SUCCESS( Status ) )
        {
            NtClose( Port );

            break;

        }

        switch ( Message.Message.u2.s2.Type )
        {
            case LPC_REQUEST:

                //DbgPrint( "Received request\n" );

                WxpHandleRequest( ClientPort, &Message );

                break;

            case LPC_PORT_CLOSED:

                //DbgPrint( "Received Port Close\n" );

                NtClose( ClientPort );

                NtClose( Port );

                WxClientDisconnect( NULL );

                Port = NULL ;

                break;

            case LPC_CONNECTION_REQUEST:

                //DbgPrint( "Received connection request\n" );
                if ( Context != NULL )
                {
                    Status = NtAcceptConnectPort(
                                    &RejectPort,
                                    NULL,
                                    (PPORT_MESSAGE) &Message,
                                    FALSE,
                                    NULL,
                                    NULL);

                    break;

                }
                else
                {
                    Status = NtAcceptConnectPort(
                                    &ClientPort,
                                    &ClientPort,
                                    &Message.Message,
                                    TRUE,
                                    NULL,
                                    NULL );

                    if ( NT_SUCCESS( Status ) )
                    {
                        NtCompleteConnectPort( ClientPort );
                    }

                }
            default:
                break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\catdbsvc\catdbcli.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catdbcli.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include "unicode.h"
#include "catdb.h"
#include "catdbcli.h"
#include "..\..\cryptsvc\service.h"
#include "errlog.h"
#include "waitsvc.h"

#ifndef KEYSVC_LOCAL_ENDPOINT
#define KEYSVC_LOCAL_ENDPOINT              (L"keysvc")
#endif

#ifndef KEYSVC_LOCAL_PROT_SEQ
#define KEYSVC_LOCAL_PROT_SEQ              (L"ncalrpc")
#endif

#define CATDBCLI_LOGERR_LASTERR()          ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBCLI, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE);

#define CATDBCLI_LOGERR(x)                 ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBCLI, \
                                                            __LINE__, \
                                                            x, \
                                                            FALSE, \
                                                            FALSE);

#define MAX_RPCRETRIES 20

void
_SSCatDBTeardownRPCConnection(
    RPC_BINDING_HANDLE    *phRPCBinding)
{
    RpcBindingFree(phRPCBinding);
}


DWORD 
_SSCatDBSetupRPCConnection(
    RPC_BINDING_HANDLE    *phRPCBinding)
{
    unsigned short *pStringBinding = NULL;
    RPC_STATUS  rpcStatus = RPC_S_OK;
    static BOOL fDone = FALSE;

    //
    // wait for the service to be available before attempting bind
    //
    if (!WaitForCryptService(SZSERVICENAME, &fDone, TRUE))
    {
        CATDBCLI_LOGERR_LASTERR()
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // get a binding handle
    //
    if (RPC_S_OK != (rpcStatus = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short *)KEYSVC_LOCAL_PROT_SEQ,
                            NULL, //LPC - no machine name
                            (unsigned short *)KEYSVC_LOCAL_ENDPOINT,
                            0,
                            &pStringBinding)))
    {
        CATDBCLI_LOGERR(rpcStatus)
        goto Ret;
    }

    if (RPC_S_OK != (rpcStatus = RpcBindingFromStringBindingW(
                            pStringBinding,
                            phRPCBinding)))
    {
        CATDBCLI_LOGERR(rpcStatus)
        goto Ret;
    }

    if (RPC_S_OK != (rpcStatus = RpcEpResolveBinding(
                            *phRPCBinding,
                            ICatDBSvc_v1_0_c_ifspec)))
    {
        CATDBCLI_LOGERR(rpcStatus)
        _SSCatDBTeardownRPCConnection(phRPCBinding);
        goto Ret;
    }


Ret:
    if (pStringBinding != NULL)
    {
        RpcStringFreeW(&pStringBinding);
    }

    return ((DWORD) rpcStatus);
}


DWORD
Client_SSCatDBAddCatalog( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile,
    /* [in] */ LPCWSTR pwszCatName,
    /* [out] */ LPWSTR *ppwszCatalogNameUsed)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBAddCatalog(
                        hRPCBinding, 
                        GetCurrentProcessId(), 
                        dwFlags, 
                        pwszSubSysGUID, 
                        pwszCatalogFile, 
                        pwszCatName,
                        ppwszCatalogNameUsed);   
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}


DWORD Client_SSCatDBDeleteCatalog( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBDeleteCatalog( 
                        hRPCBinding, 
                        GetCurrentProcessId(),
                        dwFlags,
                        pwszSubSysGUID,
                        pwszCatalogFile);    
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}


DWORD
Client_SSCatDBEnumCatalogs( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [size_is][in] */ BYTE *pbHash,
    /* [in] */ DWORD cbHash,
    /* [out] */ DWORD *pdwNumCatalogNames,
    /* [size_is][size_is][out] */ LPWSTR **pppwszCatalogNames)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBEnumCatalogs( 
                        hRPCBinding, 
                        GetCurrentProcessId(),
                        dwFlags,
                        pwszSubSysGUID,
                        pbHash,
                        cbHash,
                        pdwNumCatalogNames,
                        pppwszCatalogNames);     
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}


DWORD
Client_SSCatDBRegisterForChangeNotification( 
    /* [in] */ DWORD_PTR EventHandle,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ BOOL fUnRegister)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBRegisterForChangeNotification( 
                        hRPCBinding, 
                        GetCurrentProcessId(),
                        EventHandle,
                        dwFlags,
                        pwszSubSysGUID,
                        fUnRegister);       
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}


DWORD 
Client_SSCatDBPauseResumeService( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL fResume)
{
    RPC_BINDING_HANDLE  hRPCBinding;
    DWORD               dwErr           = 0;
    DWORD               dwRetryCount    = 0;

    dwErr = _SSCatDBSetupRPCConnection(&hRPCBinding);
    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
        return dwErr;
    }

    dwErr = RPC_S_SERVER_TOO_BUSY;

    while ( (dwErr == RPC_S_SERVER_TOO_BUSY) &&
            (dwRetryCount < MAX_RPCRETRIES))
    {
        __try
        {
            dwErr = SSCatDBPauseResumeService( 
                    hRPCBinding, 
                    GetCurrentProcessId(),
                    dwFlags,
                    fResume);        
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            dwErr = _exception_code();
            if (dwErr == RPC_S_SERVER_TOO_BUSY)
            {
                Sleep(100);
            }
        }

        dwRetryCount++;
    }

    if (dwErr != 0)
    {
        CATDBCLI_LOGERR(dwErr)
    }

    _SSCatDBTeardownRPCConnection(&hRPCBinding);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\catdbsvc\catdbcli.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       catdbcli.h
//
//--------------------------------------------------------------------------

#ifndef _CATDBCLI_H_
#define _CATDBCLI_H_


#ifdef __cplusplus
extern "C" {
#endif

DWORD
Client_SSCatDBAddCatalog( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile,
    /* [in] */ LPCWSTR pwszCatName,
    /* [out] */ LPWSTR *ppwszCatalogNameUsed);

DWORD 
Client_SSCatDBDeleteCatalog( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile);

DWORD
Client_SSCatDBEnumCatalogs( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [size_is][in] */ BYTE *pbHash,
    /* [in] */ DWORD cbHash,
    /* [out] */ DWORD *pdwNumCatalogNames,
    /* [size_is][size_is][out] */ LPWSTR **pppwszCatalogNames);

DWORD
Client_SSCatDBRegisterForChangeNotification( 
    /* [in] */ DWORD_PTR EventHandle,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ BOOL fUnRegister);

DWORD Client_SSCatDBPauseResumeService( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL fResume);


#ifdef __cplusplus
}
#endif

#endif // _CATDBCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\dpapi\passrec.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passrec.c

Abstract:

    This module contains client side code to handle the local key recovery case.

Author:

    Pete Skelly (petesk)    May 9, 2000

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <rpc.h>

#include <shlobj.h>
#include <userenv.h>

#include <wincrypt.h>
#include "passrecp.h"
#include "dpapiprv.h"
#include "pasrec.h"
#include "passrec.h"

#define FILETIME_TICKS_PER_SECOND  10000000
#define RECOVERYKEY_LIFETIME 60*60*24*365*5 // 5 Years


DWORD 
PRRecoverPassword(
    IN  LPWSTR pszUsername,
    IN  PBYTE pbRecoveryPrivate,
    IN  DWORD cbRecoveryPrivate,
    IN  LPWSTR pszNewPassword)
{
    DWORD dwError = ERROR_SUCCESS;
    RPC_BINDING_HANDLE h;
    unsigned short *pszBinding;


    if((NULL == pszUsername) ||
       (NULL == pbRecoveryPrivate) ||
       (NULL == pszNewPassword))
    {
        return ERROR_INVALID_PARAMETER;
    }


    dwError = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            &pszBinding
                            );


    if (RPC_S_OK != dwError)
    {
        return(dwError);
    }

    dwError = RpcBindingFromStringBindingW(pszBinding, &h);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    dwError = RpcEpResolveBinding(
                        h,
                        PasswordRecovery_v1_0_c_ifspec);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    __try
    {
        dwError = SSRecoverPassword(h,
                                    (PBYTE)pszUsername,
                                    (wcslen(pszUsername) + 1) * sizeof(WCHAR),
                                    pbRecoveryPrivate,
                                    cbRecoveryPrivate,
                                    (PBYTE)pszNewPassword,
                                    (wcslen(pszNewPassword) + 1) * sizeof(WCHAR));
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwError = _exception_code();
    }

error:

    if(pszBinding)
    {
        RpcStringFreeW(&pszBinding);
    }
    if(h)
    {
        RpcBindingFree(&h);
    }

    return dwError;
}


DWORD
PRQueryStatus(
    IN OPTIONAL LPWSTR pszDomain,
    IN OPTIONAL LPWSTR pszUserName,
    OUT DWORD *pdwStatus)
{
    DWORD dwError = ERROR_SUCCESS;
    RPC_BINDING_HANDLE h;
    WCHAR *pszBinding;
    WCHAR szUserName[UNLEN + 1];
    DWORD cchUserName;

    if(NULL == pdwStatus)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If the caller didn't specify a username, then use the
    // username of the calling thread.
    //

    if(pszUserName == NULL)
    {
        pszUserName = szUserName;

        cchUserName = sizeof(szUserName) / sizeof(WCHAR);
        if(!GetUserNameW(szUserName, &cchUserName))
        {
            return GetLastError();
        }
    }


    dwError = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            &pszBinding
                            );


    if (RPC_S_OK != dwError)
    {
        return(dwError);
    }

    dwError = RpcBindingFromStringBindingW(pszBinding, &h);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    dwError = RpcEpResolveBinding(
                        h,
                        PasswordRecovery_v1_0_c_ifspec);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    __try
    {
        dwError = SSRecoverQueryStatus(
                                        h,
                                        (PBYTE)pszUserName,
                                        (wcslen(pszUserName) + 1) * sizeof(WCHAR),
                                        pdwStatus);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwError = _exception_code();
    }

error:

    if(pszBinding)
    {
        RpcStringFreeW(&pszBinding);
    }
    if(h)
    {
        RpcBindingFree(&h);
    }


    return dwError;
}



DWORD
PRImportRecoveryKey(
    IN LPWSTR pszUsername,
    IN LPWSTR pszCurrentPassword,
    IN BYTE* pbRecoveryPublic,
    IN DWORD cbRecoveryPublic)
{
    DWORD dwError = ERROR_SUCCESS;
    RPC_BINDING_HANDLE h;
    unsigned short *pszBinding;
    HANDLE hToken = NULL;


    //
    // on WinNT5, go to the shared services.exe RPC server
    //

    if((NULL == pbRecoveryPublic) ||
       (0 == cbRecoveryPublic) ||
       (NULL == pszUsername) ||
       (NULL == pszCurrentPassword))
    {
        return ERROR_INVALID_PARAMETER;
    }
    


    dwError = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            &pszBinding
                            );


    if (RPC_S_OK != dwError)
    {
        return(dwError);
    }

    dwError = RpcBindingFromStringBindingW(pszBinding, &h);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    dwError = RpcEpResolveBinding(
                        h,
                        PasswordRecovery_v1_0_c_ifspec);
    if (RPC_S_OK != dwError)
    {
        goto error;
    }

    __try
    {

        dwError = SSRecoverImportRecoveryKey(
                                        h,
                                        (PBYTE)pszUsername,
                                        (wcslen(pszUsername) + 1) * sizeof(WCHAR),
                                        (PBYTE)pszCurrentPassword,
                                        (wcslen(pszCurrentPassword) + 1) * sizeof(WCHAR),
                                        pbRecoveryPublic,
                                        cbRecoveryPublic);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwError = _exception_code();
    }

error:

    if(hToken)
    {
        //
        // Impersonate back, if we were impersonating
        //
        SetThreadToken(NULL, hToken);
    }
    if(pszBinding)
    {
        RpcStringFreeW(&pszBinding);
    }
    if(h)
    {
        RpcBindingFree(&h);
    }


    return dwError;
}


DWORD GenerateRecoveryCert(HCRYPTPROV hCryptProv,
                           HCRYPTKEY hCryptKey,
                           LPWSTR pszUsername,
                           PSID pSid,
                           PBYTE *ppbPublicExportData,
                           DWORD *pcbPublicExportLength)
{

    DWORD           dwError = ERROR_SUCCESS;

    CERT_INFO       CertInfo;
    CERT_PUBLIC_KEY_INFO *pKeyInfo = NULL;
    DWORD                 cbKeyInfo = 0;
    CERT_NAME_BLOB  CertName;
    CERT_RDN_ATTR   RDNAttributes[1];
    CERT_RDN        CertRDN[] = {1, RDNAttributes} ;
    CERT_NAME_INFO  NameInfo = {1, CertRDN};

    GUID GuidKey;


    CertName.pbData = NULL;
    CertName.cbData = 0;

    RDNAttributes[0].Value.pbData = NULL;
    RDNAttributes[0].Value.cbData = 0;

    DWORD cbCertSize = 0;
    PBYTE pbCert = NULL;
    DWORD cSize = 0;


    dwError = UuidCreate( &GuidKey );

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

    // Generate a self-signed cert structure

    RDNAttributes[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    RDNAttributes[0].pszObjId =    szOID_COMMON_NAME;


    RDNAttributes[0].Value.cbData = wcslen(pszUsername) * sizeof(WCHAR);

    RDNAttributes[0].Value.pbData = (PBYTE)pszUsername;


    //
    // Get the actual public key info from the key
    //
    if(!CryptExportPublicKeyInfo(hCryptProv, 
                             AT_KEYEXCHANGE,
                             X509_ASN_ENCODING,
                             NULL,
                             &cbKeyInfo))
    {
        dwError = GetLastError();
        goto error;
    }
    pKeyInfo = (CERT_PUBLIC_KEY_INFO *)midl_user_allocate(cbKeyInfo);
    if(NULL == pKeyInfo)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if(!CryptExportPublicKeyInfo(hCryptProv, 
                             AT_KEYEXCHANGE,
                             X509_ASN_ENCODING,
                             pKeyInfo,
                             &cbKeyInfo))
    {
        dwError = GetLastError();
        goto error;

    }

    // 
    // Generate the certificate name
    //

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          &NameInfo,
                          NULL,
                          &CertName.cbData))
    {
        dwError = GetLastError();
        goto error;
    }

    CertName.pbData = (PBYTE)midl_user_allocate(CertName.cbData);
    if(NULL == CertName.pbData)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          &NameInfo,
                          CertName.pbData,
                          &CertName.cbData))
    {
        dwError = GetLastError();
        goto error;
    }



    CertInfo.dwVersion = CERT_V3;
    CertInfo.SerialNumber.pbData = (PBYTE)&GuidKey;
    CertInfo.SerialNumber.cbData =  sizeof(GUID);
    CertInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;
    CertInfo.SignatureAlgorithm.Parameters.cbData = 0;
    CertInfo.SignatureAlgorithm.Parameters.pbData = NULL;
    CertInfo.Issuer.pbData = CertName.pbData;
    CertInfo.Issuer.cbData = CertName.cbData;

    GetSystemTimeAsFileTime(&CertInfo.NotBefore);
    CertInfo.NotAfter = CertInfo.NotBefore;
    ((LARGE_INTEGER * )&CertInfo.NotAfter)->QuadPart += 
           Int32x32To64(FILETIME_TICKS_PER_SECOND, RECOVERYKEY_LIFETIME);



    CertInfo.Subject.pbData = CertName.pbData;
    CertInfo.Subject.cbData = CertName.cbData;
    CertInfo.SubjectPublicKeyInfo = *pKeyInfo;
    CertInfo.SubjectUniqueId.pbData = (PBYTE)pSid;
    CertInfo.SubjectUniqueId.cbData = GetLengthSid(pSid);
    CertInfo.SubjectUniqueId.cUnusedBits = 0;
    CertInfo.IssuerUniqueId.pbData = (PBYTE)pSid;
    CertInfo.IssuerUniqueId.cbData = GetLengthSid(pSid);
    CertInfo.IssuerUniqueId.cUnusedBits = 0;
    CertInfo.cExtension = 0;
    CertInfo.rgExtension = NULL;

    if(!CryptSignAndEncodeCertificate(hCryptProv, 
                                      AT_KEYEXCHANGE,
                                      X509_ASN_ENCODING,
                                      X509_CERT_TO_BE_SIGNED,
                                      &CertInfo,
                                      &CertInfo.SignatureAlgorithm,
                                      NULL,
                                      NULL,
                                      &cbCertSize))
    {
        dwError = GetLastError();
        goto error;
    }

    pbCert = (PBYTE)midl_user_allocate(cbCertSize);
    if(NULL == pbCert)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(!CryptSignAndEncodeCertificate(hCryptProv, 
                                      AT_KEYEXCHANGE,
                                      X509_ASN_ENCODING,
                                      X509_CERT_TO_BE_SIGNED,
                                      &CertInfo,
                                      &CertInfo.SignatureAlgorithm,
                                      NULL,
                                      pbCert,
                                      &cbCertSize))
    {
        dwError = GetLastError();
        goto error;
    }

    *pcbPublicExportLength = cbCertSize;
  
    *ppbPublicExportData = pbCert;

    if(!CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCertSize))
    {
        dwError = GetLastError();
        goto error;
    }

    pbCert = NULL;

error:
    if(pbCert)
    {
        midl_user_free(pbCert);
    }
    if(pKeyInfo)
    {
        midl_user_free(pKeyInfo);
    }
    if(CertName.pbData)
    {
        midl_user_free(CertName.pbData);
    }


    return dwError;
}

DWORD
PRGenerateRecoveryKey(
    IN  LPWSTR pszUsername,
    IN  LPWSTR pszCurrentPassword,
    OUT PBYTE *ppbRecoveryPrivate,
    OUT DWORD *pcbRecoveryPrivate)
{
    DWORD      dwError = 0;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY  hKey = 0;
    DWORD      dwDefaultKeySize = 2048;
    DWORD      cbPrivateExportLength = 0;
    DWORD      cbPublic = 0;
    PBYTE      pbPublic = NULL;
    PBYTE pbRecoveryPrivate = NULL;
    DWORD cbRecoveryPrivate = 0;
    PSID pSid = NULL;
    DWORD cbSid;
    WCHAR szDomain[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchDomain;
    SID_NAME_USE AcctType;


    //
    // Obtain SID of current user.
    //

    cchDomain = MAX_COMPUTERNAME_LENGTH + 1;
    if(!GetComputerNameW(szDomain, &cchDomain))
    {
        dwError = GetLastError();
        goto error;
    }

    if(!LookupAccountNameW(szDomain,
                           pszUsername,
                           NULL,
                           &cbSid,
                           NULL,
                           &cchDomain,
                           &AcctType)) 
    {
        dwError = GetLastError();

        if(dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto error;
        }
    }

    pSid = (PBYTE)LocalAlloc(LPTR, cbSid);
    if(pSid == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(cchDomain > MAX_COMPUTERNAME_LENGTH + 1)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(!LookupAccountNameW(szDomain,
                           pszUsername,
                           pSid,
                           &cbSid,
                           szDomain,
                           &cchDomain,
                           &AcctType)) 
    {
        dwError = GetLastError();
        goto error;
    }


    //
    // Create recovery private key.
    //

    if(!CryptAcquireContext(&hProv,
                            NULL,
                            MS_STRONG_PROV,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto error;
    }

    if(!CryptGenKey(hProv, 
                    AT_KEYEXCHANGE,
                    CRYPT_EXPORTABLE | dwDefaultKeySize << 16,
                    &hKey))
    {
        dwError = GetLastError();
        goto error;
    }

    dwError = GenerateRecoveryCert(hProv,
                           hKey,
                           pszUsername,
                           pSid,
                           &pbPublic,
                           &cbPublic);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }


    // 
    // Get the private key size
    //

    if(!CryptExportKey(hKey,
                       NULL,
                       PRIVATEKEYBLOB,
                       0,
                       NULL,
                       &cbPrivateExportLength))
    {
        dwError = GetLastError();
        goto error;
    }
    cbRecoveryPrivate = 2*sizeof(DWORD) + cbPrivateExportLength;

    pbRecoveryPrivate = (PBYTE)LocalAlloc(LMEM_FIXED, cbRecoveryPrivate);
    if(NULL == pbRecoveryPrivate)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }


    *(DWORD *)pbRecoveryPrivate = RECOVERY_BLOB_MAGIC;
    *(DWORD *)(pbRecoveryPrivate + sizeof(DWORD)) = RECOVERY_BLOB_VERSION;
    CopyMemory(pbRecoveryPrivate + 2*sizeof(DWORD),
               pbPublic,
               cbPublic);


    // 
    // Export the private key
    //

    if(!CryptExportKey(hKey,
                       NULL,
                       PRIVATEKEYBLOB,
                       0,
                       pbRecoveryPrivate + 2*sizeof(DWORD),
                       &cbPrivateExportLength))
    {
        dwError = GetLastError();
        goto error;
    }

    dwError = PRImportRecoveryKey(
                           pszUsername,
                           pszCurrentPassword,
                           pbPublic,
                           cbPublic);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }
                   
    *ppbRecoveryPrivate = pbRecoveryPrivate;
    *pcbRecoveryPrivate = cbRecoveryPrivate;

    pbRecoveryPrivate = NULL;


error:

    if(pbRecoveryPrivate)
    {
        ZeroMemory(pbRecoveryPrivate, cbRecoveryPrivate);
        LocalFree(pbRecoveryPrivate);
    }

    if(pbPublic)
    {
        LocalFree(pbPublic);
    }

    if(hKey)
    {
        CryptDestroyKey(hKey);
    }
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    if(pSid)
    {
        LocalFree(pSid);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\dpapi\reset.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    reset.c

Abstract:

    This module contains client side code to handle the reset machine
    credentials operation.

Author:

    John Banes (jbanes)    July 5, 2001

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>

#include <wincrypt.h>

extern "C" {
#include <ntsam.h>
#include <ntsamp.h>
}
#include "passrec.h"

DWORD
WINAPI
CryptResetMachineCredentials(
    DWORD dwFlags)
{
    BYTE BufferIn[8] = {0};
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    DWORD dwRetVal;
    NTSTATUS Status;

    //
    // Call SamiChangeKeys to reset syskey and SAM stuff.
    // If this fails, don't bother reseting DPAPI keys.
    //

    Status = SamiChangeKeys();
    if (!NT_SUCCESS(Status))
    {
	//
	// Convert the ntstatus to a winerror
        //

        return(RtlNtStatusToDosError(Status));
    }

    //
    // Reset DPAPI LSA secret and reencrypt all of the local machine
    // master keys.
    //

    DataIn.pbData = BufferIn;
    DataIn.cbData = sizeof(BufferIn);

    if(!CryptProtectData(&DataIn,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         CRYPTPROTECT_CRED_REGENERATE,
                         &DataOut))
    {
        dwRetVal = GetLastError();
        return dwRetVal;
    }

    //
    // Force a flush 
    //

     RegFlushKey(HKEY_LOCAL_MACHINE);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\dpapi\nt5wrap.cpp ===
/*++

Copyright (C) 1996, 1997  Microsoft Corporation

Module Name:

    nt5wrap.cpp

Abstract:

    Client side CryptXXXData calls.

    Client funcs are preceeded by "CS" == Client Side
    Server functions are preceeded by "SS" == Server Side

Author:

    Scott Field (sfield)    14-Aug-97

Revisions:

    Todds                   04-Sep-97       Ported to .dll
    Matt Thomlinson (mattt) 09-Oct-97       Moved to common area for link by crypt32
    philh                   03-Dec-97       Added I_CertProtectFunction
    philh                   29-Sep-98       Renamed I_CertProtectFunction to
                                            I_CertCltProtectFunction.
                                            I_CertProtectFunction was moved to
                                            ..\ispu\pki\certstor\protroot.cpp

--*/

#ifndef _CRYPT32_
#define _CRYPT32_   // use correct Dll Linkage
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <cryptui.h>
#include <sha.h>
#include "crypt.h"

#include <lm.h>
#include <malloc.h>

#include "unicode.h"
#include "certprot.h"

// midl generated files
#include "dprpc.h"

#include "dpapiprv.h"

// fwds
RPC_STATUS BindW(
    WCHAR **pszBinding,
    RPC_BINDING_HANDLE *phBind
    );

RPC_STATUS BindBackupKeyW(
    LPCWSTR szComputerName,
    WCHAR **pszBinding,
    RPC_BINDING_HANDLE *phBind
    );



RPC_STATUS UnbindW(
    WCHAR **pszBinding,
    RPC_BINDING_HANDLE *phBind
    );

BOOL
WINAPI
CryptProtectData(
        DATA_BLOB*      pDataIn,
        LPCWSTR         szDataDescr,
        DATA_BLOB*      pOptionalEntropy,
        PVOID           pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
        DWORD           dwFlags,
        DATA_BLOB*      pDataOut)
{
    RPC_BINDING_HANDLE h = NULL;
    LPWSTR pszBinding;
    RPC_STATUS RpcStatus;

    BYTE rgbPasswordHash[ A_SHA_DIGEST_LEN ];
    LPCWSTR wszDescription = szDataDescr?szDataDescr:L"";
    LPWSTR szAlternateDataDescription = (LPWSTR)wszDescription;
    DWORD dwRetVal = ERROR_INVALID_PARAMETER;

    // check params
    if ((pDataOut == NULL) ||
        (pDataIn == NULL) ||
        (pDataIn->pbData == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RpcStatus = BindW(&pszBinding, &h);
    if(RpcStatus != RPC_S_OK) {
        SetLastError(RpcStatus);
        return FALSE;
    }

    __try {
        PBYTE pbOptionalPassword = NULL;
        DWORD cbOptionalPassword = 0;
        SSCRYPTPROTECTDATA_PROMPTSTRUCT PromptStruct;
        SSCRYPTPROTECTDATA_PROMPTSTRUCT *pLocalPromptStruct = NULL;

        // zero so client stub allocates
        ZeroMemory(pDataOut, sizeof(DATA_BLOB));

        //
        // only call UI function if prompt flags dictate, because we don't
        // want to bring in cryptui.dll unless necessary.
        //

        if( (pPromptStruct != NULL) &&
            ((pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) ||
             (pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT))
            )
        {

            dwRetVal = I_CryptUIProtect(
                                    pDataIn,
                                    pPromptStruct,
                                    dwFlags,
                                    (PVOID*)&szAlternateDataDescription,
                                    TRUE,
                                    rgbPasswordHash
                                    );

            //
            // If UI dictated strong security, then supply the hash.
            //

            if( pPromptStruct->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            {
                cbOptionalPassword = sizeof(rgbPasswordHash);
                pbOptionalPassword = rgbPasswordHash;
            }

        } else {

            dwRetVal = ERROR_SUCCESS;
        }


        if( dwRetVal == ERROR_SUCCESS ) 
        {
            if(pPromptStruct != NULL)
            {
                ZeroMemory(&PromptStruct, sizeof(PromptStruct));
                PromptStruct.cbSize = sizeof(PromptStruct);
                PromptStruct.dwPromptFlags = pPromptStruct->dwPromptFlags;
                pLocalPromptStruct = &PromptStruct;
            }

            dwRetVal = SSCryptProtectData(
                        h,
                        &pDataOut->pbData,
                        &pDataOut->cbData,
                        pDataIn->pbData,
                        pDataIn->cbData,
                        szAlternateDataDescription,
                        (pOptionalEntropy) ? pOptionalEntropy->pbData : NULL,
                        (pOptionalEntropy) ? pOptionalEntropy->cbData : 0,
                        (GUID*)pvReserved,
                        pLocalPromptStruct, 
                        dwFlags,
                        pbOptionalPassword,
                        cbOptionalPassword
                        );
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwRetVal = GetExceptionCode();
    }

    UnbindW(&pszBinding, &h);

    ZeroMemory( rgbPasswordHash, sizeof(rgbPasswordHash) );

    if( szAlternateDataDescription &&
        szAlternateDataDescription != wszDescription )
    {
        LocalFree( szAlternateDataDescription );
    }

    if(dwRetVal != ERROR_SUCCESS) {
        SetLastError(dwRetVal);

        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
CryptUnprotectData(
        DATA_BLOB*      pDataIn,             // in encr blob
        LPWSTR*         ppszDataDescr,       // out
        DATA_BLOB*      pOptionalEntropy,
        PVOID           pvReserved,
        CRYPTPROTECT_PROMPTSTRUCT*  pPromptStruct,
        DWORD           dwFlags,
        DATA_BLOB*      pDataOut)
{
    RPC_BINDING_HANDLE h = NULL;
    LPWSTR pszBinding;
    RPC_STATUS RpcStatus;

    BYTE rgbPasswordHash[ A_SHA_DIGEST_LEN ];
    DWORD dwRetVal;
    DWORD dwRetryCount = 0;

    // check params
    if ((pDataOut == NULL) ||
        (pDataIn == NULL) ||
        (pDataIn->pbData == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    RpcStatus = BindW(&pszBinding, &h);
    if(RpcStatus != RPC_S_OK) {
        SetLastError(RpcStatus);
        return FALSE;
    }

    __try {
        CRYPTPROTECT_PROMPTSTRUCT DerivedPromptStruct;
        PBYTE pbOptionalPassword = NULL;
        DWORD cbOptionalPassword = 0;
        LPCWSTR szDataDescr;
        LPUWSTR szDataDescrUnaligned;
        SSCRYPTPROTECTDATA_PROMPTSTRUCT PromptStruct;
        SSCRYPTPROTECTDATA_PROMPTSTRUCT *pLocalPromptStruct = NULL;

        //
        // define outer+inner wrapper for security blob.
        // this won't be necessary once SAS support is provided by the OS.
        //

        typedef struct {
            DWORD dwOuterVersion;
            GUID guidProvider;

            DWORD dwVersion;
            GUID guidMK;
            DWORD dwPromptFlags;
            DWORD cbDataDescr;
            WCHAR szDataDescr[1];
        } sec_blob, *psec_blob;

        sec_blob UNALIGNED *SecurityBlob = (sec_blob*)(pDataIn->pbData);


        //
        // zero so client stub allocates
        //

        ZeroMemory(pDataOut, sizeof(DATA_BLOB));

        if (ppszDataDescr)
            *ppszDataDescr = NULL;


        //
        // recreate the promptstruct and DataDescr from the security blob.
        //

        DerivedPromptStruct.cbSize = sizeof(DerivedPromptStruct);
        DerivedPromptStruct.dwPromptFlags = SecurityBlob->dwPromptFlags;

	    //
	    // SecurityBlob may be unaligned.  Set szDataDescr to reference
	    // an aligned copy.
	    //

        szDataDescrUnaligned = (SecurityBlob->szDataDescr);
	    WSTR_ALIGNED_STACK_COPY(&szDataDescr,szDataDescrUnaligned);

        if( pPromptStruct )
        {
            DerivedPromptStruct.hwndApp = pPromptStruct->hwndApp;
            DerivedPromptStruct.szPrompt = pPromptStruct->szPrompt;
        } else {
            DerivedPromptStruct.szPrompt = NULL;
            DerivedPromptStruct.hwndApp = NULL;
        }


retry:

        //
        // determine if UI is to be raised, and what type.
        //

        //
        // only call UI function if prompt flags dictate, because we don't
        // want to bring in cryptui.dll unless necessary.
        //

        if( ((DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT) ||
             (DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT))
            )
        {

            dwRetVal = I_CryptUIProtect(
                            pDataIn,
                            &DerivedPromptStruct,
                            dwFlags,
                            (PVOID*)&szDataDescr,
                            FALSE,
                            rgbPasswordHash
                            );

            //
            // If UI dictated strong security, then supply the hash.
            //

            if( DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            {
                cbOptionalPassword = sizeof(rgbPasswordHash);
                pbOptionalPassword = rgbPasswordHash;
            }

        } else {
            if( DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            {
                dwRetVal = ERROR_INVALID_PARAMETER;
            } else {
                dwRetVal = ERROR_SUCCESS;
            }
        }


        //
        // make the RPC call to attempt to unprotect the data.
        //

        if( dwRetVal == ERROR_SUCCESS ) 
        {
            if(pPromptStruct != NULL)
            {
                ZeroMemory(&PromptStruct, sizeof(PromptStruct));
                PromptStruct.cbSize = sizeof(PromptStruct);
                PromptStruct.dwPromptFlags = pPromptStruct->dwPromptFlags;
                pLocalPromptStruct = &PromptStruct;
            }

            dwRetVal = SSCryptUnprotectData(
                        h,
                        &pDataOut->pbData,
                        &pDataOut->cbData,
                        pDataIn->pbData,
                        pDataIn->cbData,
                        ppszDataDescr,
                        (pOptionalEntropy) ? pOptionalEntropy->pbData : NULL,
                        (pOptionalEntropy) ? pOptionalEntropy->cbData : 0,
                        (GUID*)pvReserved,
                        pLocalPromptStruct,
                        dwFlags,
                        pbOptionalPassword,
                        cbOptionalPassword
                        );

            if( dwRetVal == ERROR_INVALID_DATA &&
                DerivedPromptStruct.dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            {
                //
                // The data did not decrypt correctly, so warn the user that 
                // the password might have been entered incorrectly and let them
                // try it again up to 3 times.
                //

                I_CryptUIProtectFailure(
                                &DerivedPromptStruct,
                                dwFlags,
                                (PVOID*)&szDataDescr);

                if( dwRetryCount++ < 3 )
                {
                    goto retry;
                }
            }


            if(dwRetVal == ERROR_SUCCESS || dwRetVal == CRYPT_I_NEW_PROTECTION_REQUIRED)
            {
                if(pDataOut->cbData > 0)
                {
                    NTSTATUS Status;
                    DWORD cbPadding;

                    // Decrypt output buffer.
                    Status = RtlDecryptMemory(pDataOut->pbData,
                                              pDataOut->cbData,
                                              RTL_ENCRYPT_OPTION_SAME_LOGON);
                    if(!NT_SUCCESS(Status))
                    {
                        dwRetVal = ERROR_DECRYPTION_FAILED;
                    }

                    // Remove padding
                    if(dwRetVal == ERROR_SUCCESS)
                    {
                        cbPadding = pDataOut->pbData[pDataOut->cbData - 1];

                        if((cbPadding <= pDataOut->cbData) && (cbPadding <= RTL_ENCRYPT_MEMORY_SIZE))
                        {
                            pDataOut->cbData -= cbPadding;
                        }
                        else
                        {
                            dwRetVal = ERROR_INVALID_DATA;
                        }
                    }
                }
            }
        }


    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwRetVal = GetExceptionCode();
    }

    ZeroMemory( rgbPasswordHash, sizeof(rgbPasswordHash) );

    UnbindW(&pszBinding, &h);

    if((dwFlags &  CRYPTPROTECT_VERIFY_PROTECTION ) &&
       ((CRYPT_I_NEW_PROTECTION_REQUIRED == dwRetVal) || 
        (ERROR_SUCCESS == dwRetVal)))
    {
        SetLastError(dwRetVal);
        return TRUE;
    }


    if(dwRetVal != ERROR_SUCCESS) {
        SetLastError(dwRetVal);
        return FALSE;
    }

    return TRUE;
}






RPC_STATUS BindW(WCHAR **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;



    //
    // on WinNT5, go to the shared services.exe RPC server
    //

    status = RpcStringBindingComposeW(
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned short*)DPAPI_LOCAL_ENDPOINT,
                            NULL,
                            (unsigned short * *)pszBinding
                            );


    if (status)
    {
        return(status);
    }

    status = RpcBindingFromStringBindingW((unsigned short *)*pszBinding, phBind);

    return status;
}





RPC_STATUS UnbindW(WCHAR **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;

    status = RpcStringFreeW((unsigned short **)pszBinding);

    if (status)
    {
        return(status);
    }

    RpcBindingFree(phBind);

    return RPC_S_OK;
}


void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return LocalAlloc(LMEM_FIXED, len);
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    ZeroMemory(ptr, LocalSize( ptr ));
    LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\dpapi\server\makefile.inc ===
$(CRYPTO_INC)\$(O)\pstypes.h: $(O)\pstypes.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@


$(CRYPTO_INC)\$(O)\pstrpc.h: $(O)\pstrpc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@

$(CRYPTO_INC)\$(O)\pasrec.h: $(O)\pasrec.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@


$(CRYPTO_INC)\$(O)\keyrpc.h: $(O)\keyrpc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@

$(CRYPTO_INC)\$(O)\dprpc.h: $(O)\dprpc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\errlog\errlog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       errlog.cpp
//
//  Contents:   generic error logging
//
//  History:    19-Jun-00   reidk   created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <string.h>
#include "errlog.h"
#include "unicode.h"

#define WSZ_ERROR_LOGFILE                   L"%SystemRoot%\\System32\\CatRoot2\\dberr.txt"

#define REG_CRYPTOGRAPHY_KEY                L"Software\\Microsoft\\Cryptography"
#define REG_CATDB_LOGGING_VALUE             L"CatDBLogging"

#define CATDB_LOG_ERRORS_TO_FILE            0x00000001
#define CATDB_LOG_ERRORS_TO_DEBUGGER        0x00000002
#define CATDB_LOG_WARNINGS                  0x00000004

#define MAX_LOGFILE_SIZE                    100000                    
#define TIME_DATE_SIZE                      256

BOOL    g_fErrLogInitialized                = FALSE;
   
BOOL    g_fLogErrorsToFile                  = TRUE;
BOOL    g_fLogErrorsToDebugger              = FALSE;
BOOL    g_fLogWarnings                      = FALSE;

#define WSZ_TIME_STAMP_FILE                 L"TimeStamp"
#define TIME_ALLOWANCE                      ((ULONGLONG) 10000000 * (ULONGLONG) 60 * (ULONGLONG) 5) // 5 minutes

#define TIMESTAMP_LOGERR_LASTERR()          ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_TIMESTAMP, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE);

#define NAME_VALUE_SIZE 28

void
ErrLog_Initialize()
{
    HKEY    hKey;
    DWORD   dwDisposition;
    WCHAR   wszValueName[NAME_VALUE_SIZE];
    DWORD   dwValueNameSize = NAME_VALUE_SIZE;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwValueSize = sizeof(DWORD);
    DWORD   dwIndex;
    LONG    lRet;

    g_fErrLogInitialized = TRUE;

    //
    // See if there is a CatDBLogging value
    //
    if (RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            REG_CRYPTOGRAPHY_KEY,
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE, 
            KEY_READ, 
            NULL,
            &hKey, 
            &dwDisposition) == ERROR_SUCCESS)
    {
        dwIndex = 0;

        lRet = RegEnumValueU(
                    hKey,
                    dwIndex,
                    wszValueName,
                    &dwValueNameSize,
                    NULL,
                    &dwType,
                    (BYTE *) &dwValue,
                    &dwValueSize);

        while ((lRet == ERROR_SUCCESS) || (lRet == ERROR_MORE_DATA))
        {
            if ((lRet == ERROR_SUCCESS) &&
                (dwType == REG_DWORD)   &&
                (_wcsicmp(wszValueName, REG_CATDB_LOGGING_VALUE) == 0))
            {
                g_fLogErrorsToFile = (dwValue & CATDB_LOG_ERRORS_TO_FILE) != 0;
                g_fLogErrorsToDebugger = (dwValue & CATDB_LOG_ERRORS_TO_DEBUGGER) != 0;
                g_fLogWarnings = (dwValue & CATDB_LOG_WARNINGS) != 0;
                break;
            }
            else
            {
                dwValueNameSize = NAME_VALUE_SIZE;
                dwValueSize = sizeof(DWORD);
                dwIndex++;
                lRet = RegEnumValueU(
                            hKey,
                            dwIndex,
                            wszValueName,
                            &dwValueNameSize,
                            NULL,
                            &dwType,
                            (BYTE *) &dwValue,
                            &dwValueSize);
            }            
        }

        RegCloseKey(hKey);
    }
}


void
_WriteErrorOut(
    LPWSTR  pwszLogFileName,
    LPSTR   pwszError,
    BOOL    fLogToFileOnly)
{
    LPWSTR      pwszFileNameToExpand    = pwszLogFileName;
    LPWSTR      pwszExpandedFileName    = NULL;
    DWORD       dwExpanded              = 0;
    HANDLE      hFile                   = INVALID_HANDLE_VALUE;
    DWORD       dwFileSize              = 0;
    DWORD       dwNumBytesWritten       = 0;
    
    //
    // Output the error string to the debugger
    //
    if (g_fLogErrorsToDebugger && !fLogToFileOnly)
    {
        OutputDebugStringA(pwszError);
    }

    //
    // Log string to file
    //
    if (g_fLogErrorsToFile)
    {
        if (pwszFileNameToExpand == NULL)
        {
            pwszFileNameToExpand = WSZ_ERROR_LOGFILE;
        }

        //
        // expand the filename if needed
        //
        dwExpanded = ExpandEnvironmentStringsU(pwszFileNameToExpand, NULL, 0);
    
        pwszExpandedFileName = (LPWSTR) malloc(dwExpanded * sizeof(WCHAR));
        if (pwszExpandedFileName == NULL)
        {
            goto Return;
        }

        if (0 == ExpandEnvironmentStringsU(
                        pwszFileNameToExpand, 
                        pwszExpandedFileName, 
                        dwExpanded))
        {
            goto Return;
        }

        //
        // Get a handle to the file and make sure it isn't took big
        //
        hFile = CreateFileU(
                        pwszExpandedFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        0, //dwShareMode
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            goto Return;
        }

        dwFileSize = GetFileSize(hFile, NULL);
        if (dwFileSize >= MAX_LOGFILE_SIZE)
        {
            //
            // Just nuke the whole thing
            //
            if (SetFilePointer(
                    hFile, 
                    0, 
                    NULL, 
                    FILE_BEGIN) == INVALID_SET_FILE_POINTER)
            {
                goto Return;
            }
        
            if (!SetEndOfFile(hFile))
            {
                goto Return;
            }
        }

        //
        // Write the new error
        //
        if (SetFilePointer(hFile, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER)
        {
            goto Return;
        }

        WriteFile(
            hFile,
            (void *) pwszError,
            strlen(pwszError),
            &dwNumBytesWritten,
            NULL);
    }

Return:

    if (pwszExpandedFileName != NULL)
    {
        free(pwszExpandedFileName);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
}


void
ErrLog_LogError(
    LPWSTR  pwszLogFileName,
    DWORD   dwClient,
    DWORD   dwLine,
    DWORD   dwErr,
    BOOL    fWarning,
    BOOL    fLogToFileOnly)
{
    DWORD       dwLastError             = GetLastError();
    int         numChars                = 0;
    char        szTimeDate[TIME_DATE_SIZE];            
    char        szWriteBuffer[512];
    SYSTEMTIME  st;
    

    if (!g_fErrLogInitialized)
    {
        ErrLog_Initialize();
    }

    //
    // Get out if this is a warning and we are not logging warnings
    //
    if (!g_fLogWarnings && fWarning)
    {
        return;
    }

    //
    // Create the error string to log
    //
    GetLocalTime(&st);
    
    numChars = GetTimeFormatA(
                    LOCALE_USER_DEFAULT, 
                    0, 
                    &st, 
                    NULL, 
                    szTimeDate, 
                    TIME_DATE_SIZE);

    szTimeDate[numChars-1] = ' ';
    
    GetDateFormatA(
            LOCALE_USER_DEFAULT, 
            DATE_SHORTDATE, 
            &st, 
            NULL, 
            &szTimeDate[numChars], 
            TIME_DATE_SIZE-numChars);

    wsprintf(
        szWriteBuffer, 
        "CatalogDB: %s: File #%u at line #%u encountered error 0x%.8lx\r\n", 
        szTimeDate,
        dwClient,
        dwLine,
        (dwErr == 0) ? dwLastError : dwErr);
    
    //
    // Log it
    //
    _WriteErrorOut(pwszLogFileName, szWriteBuffer, fLogToFileOnly);

    //
    // Make sure last error is the same as when we were called
    //
    SetLastError(dwLastError);
}

void
ErrLog_LogString(
    LPWSTR  pwszLogFileName,
    LPWSTR  pwszMessageString,
    LPWSTR  pwszExtraString,
    BOOL    fLogToFileOnly)
{
    DWORD       dwLastError             = GetLastError();
    int         numChars                = 0;
    char        szTimeDate[TIME_DATE_SIZE];            
    SYSTEMTIME  st;
    char        szWriteBuffer[1024];
    
    if (!g_fErrLogInitialized)
    {
        ErrLog_Initialize();
    }

    //
    // Create the error string to log
    //
    GetLocalTime(&st);
    
    numChars = GetTimeFormatA(
                    LOCALE_USER_DEFAULT, 
                    0, 
                    &st, 
                    NULL, 
                    szTimeDate, 
                    TIME_DATE_SIZE);

    szTimeDate[numChars-1] = ' ';
    
    GetDateFormatA(
            LOCALE_USER_DEFAULT, 
            DATE_SHORTDATE, 
            &st, 
            NULL, 
            &szTimeDate[numChars], 
            TIME_DATE_SIZE-numChars);

    if (pwszExtraString != NULL)
    {
        wsprintf(
            szWriteBuffer, 
            "CatalogDB: %s: %S %S\r\n", 
            szTimeDate,
            pwszMessageString,
            pwszExtraString);
    }
    else
    {
        wsprintf(
            szWriteBuffer, 
            "CatalogDB: %s: %S\r\n", 
            szTimeDate,
            pwszMessageString);
    }

    //
    // Log it
    //
    _WriteErrorOut(pwszLogFileName, szWriteBuffer, fLogToFileOnly);

    //
    // Make sure last error is the same as when we were called
    //
    SetLastError(dwLastError);
}


BOOL
TimeStampFile_Touch(
    LPWSTR  pwszDir)
{
    BOOL        fRet                = TRUE;
    LPWSTR      pwszFile            = NULL;
    HANDLE      hFile               = INVALID_HANDLE_VALUE;
    DWORD       dwNumBytesWritten   = 0;
    SYSTEMTIME  st;
    FILETIME    ft;
    DWORD       dwErr;

    //
    // Create fully qaulified file name
    //
    if (NULL == (pwszFile = (LPWSTR) malloc((
                                        wcslen(pwszDir) + 
                                        wcslen(WSZ_TIME_STAMP_FILE) 
                                        + 2) * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;        
    }
    wcscpy(pwszFile, pwszDir);
    if (pwszFile[wcslen(pwszFile)-1] != L'\\')
    {
        wcscat(pwszFile, L"\\");
    }
    wcscat(pwszFile, WSZ_TIME_STAMP_FILE);

    //
    // Get a handle to the file 
    //
    hFile = CreateFileU(
                    pwszFile,
                    GENERIC_READ | GENERIC_WRITE,
                    0, //dwShareMode
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    SetLastError(0);

    //
    // Get the current time
    //
    GetLocalTime(&st);

    if (!SystemTimeToFileTime(&st, &ft))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Write the time
    //
    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!SetEndOfFile(hFile))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!WriteFile(
            hFile,
            (void *) &ft,
            sizeof(ft),
            &dwNumBytesWritten,
            NULL))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    
CommonReturn:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (pwszFile != NULL)
    {
        free(pwszFile);
    }

    return (fRet);

ErrorReturn:

    dwErr = GetLastError();

    if (pwszFile != NULL)
    {
        DeleteFileW(pwszFile);
    }

    SetLastError(dwErr);

    fRet = FALSE;

    goto CommonReturn;
}

BOOL
TimeStampFile_InSync(
    LPWSTR  pwszDir1,
    LPWSTR  pwszDir2,
    BOOL    *pfInSync)
{
    BOOL            fRet                = TRUE;
    LPWSTR          pwszFile1           = NULL;
    HANDLE          hFile1              = INVALID_HANDLE_VALUE;
    LPWSTR          pwszFile2           = NULL;
    HANDLE          hFile2              = INVALID_HANDLE_VALUE;
    DWORD           dwNumBytesRead;
    FILETIME        ft1;
    FILETIME        ft2;
    ULARGE_INTEGER  ul1;
    ULARGE_INTEGER  ul2;
    
    //
    // Initialize out param
    //
    *pfInSync = FALSE;

    //
    // Create fully qaulified file names
    //
    if (NULL == (pwszFile1 = (LPWSTR) malloc((
                                        wcslen(pwszDir1) + 
                                        wcslen(WSZ_TIME_STAMP_FILE) 
                                        + 2) * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;        
    }
    wcscpy(pwszFile1, pwszDir1);
    if (pwszFile1[wcslen(pwszFile1)-1] != L'\\')
    {
        wcscat(pwszFile1, L"\\");
    }
    wcscat(pwszFile1, WSZ_TIME_STAMP_FILE);

    if (NULL == (pwszFile2 = (LPWSTR) malloc((
                                        wcslen(pwszDir2) + 
                                        wcslen(WSZ_TIME_STAMP_FILE) 
                                        + 2) * sizeof(WCHAR))))
    {
        SetLastError(E_OUTOFMEMORY);
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;        
    }
    wcscpy(pwszFile2, pwszDir2);
    if (pwszFile2[wcslen(pwszFile2)-1] != L'\\')
    {
        wcscat(pwszFile2, L"\\");
    }
    wcscat(pwszFile2, WSZ_TIME_STAMP_FILE);

    //
    // Get handles to the files 
    //
    hFile1 = CreateFileU(
                    pwszFile1,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, 
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if (hFile1 == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            SetLastError(0);
            goto CommonReturn; // not an error, a legitimate out of sync
        }
        else
        {
            TIMESTAMP_LOGERR_LASTERR()
            goto ErrorReturn;
        }        
    }

    if (SetFilePointer(hFile1, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    hFile2 = CreateFileU(
                    pwszFile2,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, 
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

    if (hFile2 == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            SetLastError(0);
            goto CommonReturn; // not an error, a legitimate out of sync
        }
        else
        {
            TIMESTAMP_LOGERR_LASTERR()
            goto ErrorReturn;
        }   
    }

    if (SetFilePointer(hFile2, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get the times out of the files
    //
    if (!ReadFile(
            hFile1,
            &ft1,
            sizeof(ft1),
            &dwNumBytesRead,
            NULL))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (dwNumBytesRead != sizeof(ft1))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!ReadFile(
            hFile2,
            &ft2,
            sizeof(ft2),
            &dwNumBytesRead,
            NULL))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (dwNumBytesRead != sizeof(ft2))
    {
        TIMESTAMP_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    memcpy(&ul1, &ft1, sizeof(ft1));
    memcpy(&ul2, &ft2, sizeof(ft2));
   
    if ((ul1.QuadPart <= (ul2.QuadPart + TIME_ALLOWANCE)) &&
        (ul2.QuadPart <= (ul1.QuadPart + TIME_ALLOWANCE)))
    {
        *pfInSync = TRUE;
    }

CommonReturn:

    if (hFile1 != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile1);
    }

    if (pwszFile1 != NULL)
    {
        free(pwszFile1);
    }

    if (hFile2 != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile2);
    }

    if (pwszFile2 != NULL)
    {
        free(pwszFile2);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;

    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\debug\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//	File:		debug.cpp
//
//	Contents:	Debug sub system APIs implementation
//
//
//	03/20/96    kevinr      wrote it
//  04/17/96    kevinr      added OSS init
//  05-Sep-1997 pberkman    added sub-system debug.
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <asn1code.h>

#if DBG

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <memory.h>
#include <string.h>
#include <process.h>
#include <time.h>
#include <crtdbg.h>

#include "pkicrit.h"
#include "dbgdef.h"

// set DEBUG_MASK=0x26
LPSTR pszDEBUG_MASK = "DEBUG_MASK";
#define DEBUG_MASK_DELAY_FREE_MEM   _CRTDBG_DELAY_FREE_MEM_DF /* 0x02 */
#define DEBUG_MASK_CHECK_ALWAYS     _CRTDBG_CHECK_ALWAYS_DF   /* 0x04 */
#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */
#define DEBUG_MASK_MEM \
(DEBUG_MASK_DELAY_FREE_MEM | DEBUG_MASK_CHECK_ALWAYS | DEBUG_MASK_LEAK_CHECK)


// from asn1code.h:
//      #define DEBUGPDU     0x02 /* produce tracing output */
//      #define DEBUG_ERRORS 0x10 /* print decoder errors to output */
// set OSS_DEBUG_MASK=0x02        
// set OSS_DEBUG_MASK=0x10        - only print decoder errors
LPSTR pszOSS_DEBUG_MASK = "OSS_DEBUG_MASK";

// receives trace output
LPSTR pszOSS_DEBUG_TRACEFILE = "OSS_DEBUG_TRACEFILE";

static char  *pszDEBUG_PRINT_MASK   = "DEBUG_PRINT_MASK";
static char  *pszDefualtSSTag       = "ISPU";

static DBG_SS_TAG sSSTags[]         = __DBG_SS_TAGS;

static CRITICAL_SECTION DbgCriticalSection;

#define OSS_SET_DECODING_FLAGS_PROC_IDX     0
#define OSS_SET_ENCODING_FLAGS_PROC_IDX     1
#define OSS_OPEN_TRACE_FILE_PROC_IDX        2
#define OSS_PROC_CNT                        3

static LPSTR rgpszOssProc[OSS_PROC_CNT] = {
    "ossSetDecodingFlags",
    "ossSetEncodingFlags",
    "ossOpenTraceFile"
};

static void *rgpvOssProc[OSS_PROC_CNT];
static HMODULE hmsossDll = NULL;
static BOOL fLoadedOss = FALSE;

static void OssUnload()
{
    if (hmsossDll) {
        FreeLibrary(hmsossDll);
        hmsossDll = NULL;
    }
}

static void OssLoad()
{
    DWORD i;

    if (fLoadedOss)
        return;

    EnterCriticalSection(&DbgCriticalSection);

    if (fLoadedOss)
        goto LeaveReturn;

    if (NULL == (hmsossDll = LoadLibraryA("msoss.dll")))
        goto msossLoadLibraryError;

    for (i = 0; i < OSS_PROC_CNT; i++) {
        if (NULL == (rgpvOssProc[i] = GetProcAddress(
                hmsossDll, rgpszOssProc[i])))
            goto msossGetProcAddressError;
    }

LeaveReturn:
    LeaveCriticalSection(&DbgCriticalSection);
CommonReturn:
    fLoadedOss = TRUE;
    return;

ErrorReturn:
    LeaveCriticalSection(&DbgCriticalSection);
    OssUnload();
    goto CommonReturn;
TRACE_ERROR(msossLoadLibraryError)
TRACE_ERROR(msossGetProcAddressError)
}

typedef int      (DLL_ENTRY* pfnossSetDecodingFlags)(struct ossGlobal *world,
							unsigned long flags);

static int DLL_ENTRY ossSetDecodingFlags(struct ossGlobal *world,
							unsigned long flags)
{
    if (hmsossDll)
        return ((pfnossSetDecodingFlags)
            rgpvOssProc[OSS_SET_DECODING_FLAGS_PROC_IDX])(
                world,
                flags);
    else
        return API_DLL_NOT_LINKED;
}

typedef int      (DLL_ENTRY* pfnossSetEncodingFlags)(struct ossGlobal *world,
							unsigned long flags);

static int DLL_ENTRY ossSetEncodingFlags(struct ossGlobal *world,
							unsigned long flags)
{
    if (hmsossDll)
        return ((pfnossSetEncodingFlags)
            rgpvOssProc[OSS_SET_ENCODING_FLAGS_PROC_IDX])(
                world,
                flags);
    else
        return API_DLL_NOT_LINKED;
}

typedef int  (DLL_ENTRY*  pfnossOpenTraceFile)(struct ossGlobal *world,
				char                    *fileName);

static int  DLL_ENTRY ossOpenTraceFile(struct ossGlobal *world,
				char                    *fileName)
{
    if (hmsossDll)
        return ((pfnossOpenTraceFile)
            rgpvOssProc[OSS_OPEN_TRACE_FILE_PROC_IDX])(
                world,
                fileName);
    else
        return API_DLL_NOT_LINKED;
}

// 
//+-------------------------------------------------------------------------
//
//  Pithy stubs to create stdcall proc from cdecl
//
//--------------------------------------------------------------------------
void*
_stdcall
scMalloc( size_t size)
{
    return malloc(size);
}

void*
_stdcall
scRealloc( void *memblock, size_t size)
{
    return realloc(memblock, size);
}

void
_stdcall
scFree( void *memblock)
{
    free(memblock);
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgGetDebugFlags
//
//  Synopsis:  Get the debug flags.
//
//  Returns:   the debug flags
//
//--------------------------------------------------------------------------
int
WINAPI
DbgGetDebugFlags()
{
    char    *pszEnvVar;
    char    *p;
    int     iDebugFlags = 0;

    if (pszEnvVar = getenv( pszDEBUG_MASK))
        iDebugFlags = strtol( pszEnvVar, &p, 16);

    return iDebugFlags;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgProcessAttach
//
//  Synopsis:  Handle process attach.
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgProcessAttach()
{
    int     tmpFlag;

#ifdef _DEBUG

    tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );    // get current
    tmpFlag |=  DbgGetDebugFlags();     // enable flags
    tmpFlag &= ~_CRTDBG_CHECK_CRT_DF;   // disable CRT block checking
    _CrtSetDbgFlag( tmpFlag);           // set new value
#endif

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgProcessDetach
//
//  Synopsis:  Handle process detach.
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgProcessDetach()
{
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgInitOSS
//
//  Synopsis:  Do OSS init for debug.
//
//  Returns:   TRUE
//
//  Note:      Always FRONT_ALIGN encoding
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgInitOSS(
        OssGlobal   *pog)
{
    char    *pszEnvVar;
    char    *p;

  __try {
    // Attempt to do delay, demand loading of msoss.dll
    OssLoad();

    // from asn1code.h:
    //      #define DEBUGPDU 0x02     /* produce tracing output */
    //      #define DEBUG_ERRORS 0x10 /* print decoder errors to output */
    // set OSS_DEBUG_MASK=0x02
    // set OSS_DEBUG_MASK=0x10        - only print decoder errors
    if (pszEnvVar = getenv( pszOSS_DEBUG_MASK)) {
        unsigned long ulEnvVar;
        ulEnvVar = strtoul( pszEnvVar, &p, 16) & (DEBUGPDU | DEBUG_ERRORS);
        if ( ulEnvVar)
            ossSetDecodingFlags( pog, ulEnvVar | RELAXBER);
        if ( DEBUGPDU & ulEnvVar)
            ossSetEncodingFlags( pog, DEBUGPDU | FRONT_ALIGN);
        else
            ossSetEncodingFlags( pog, FRONT_ALIGN);
    } else {
        ossSetDecodingFlags( pog, DEBUG_ERRORS | RELAXBER);
        ossSetEncodingFlags( pog, FRONT_ALIGN);
    }

    if (pszEnvVar = getenv( pszOSS_DEBUG_TRACEFILE))
        ossOpenTraceFile( pog, pszEnvVar);

#ifdef _DEBUG
    if (DbgGetDebugFlags() & DEBUG_MASK_MEM) {
        pog->mallocp = scMalloc;
        pog->reallocp = scRealloc;
        pog->freep = scFree;
    }
#else
    pog->mallocp = scMalloc;
    pog->reallocp = scRealloc;
    pog->freep = scFree;
#endif
    return TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    return FALSE;
  }
}


//+-------------------------------------------------------------------------
//
//  Function:  DebugDllMain
//
//  Synopsis:  Initialize the debug DLL
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DebugDllMain(
        HMODULE hInst,
        ULONG   ulReason,
        LPVOID  lpReserved)
{
    BOOL    fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = DbgProcessAttach();
        if (fRet) {
            fRet = Pki_InitializeCriticalSection(&DbgCriticalSection);
            if (!fRet)
                DbgProcessDetach();
        }
        break;

    case DLL_PROCESS_DETACH:
        fRet = DbgProcessDetach();
        OssUnload();
        DeleteCriticalSection(&DbgCriticalSection);
        break;

    default:
        break;
    }

  return fRet;
}


const char *DbgGetSSString(DWORD dwSubSystemId)
{
    DBG_SS_TAG  *psSS;

    psSS = &sSSTags[0];

    while (psSS->dwSS > 0)
    {
        if ((psSS->dwSS & dwSubSystemId) > 0)
        {
            if (psSS->pszTag)
            {
                return(psSS->pszTag);
            }

            return(pszDefualtSSTag);
        }

        psSS++;
    }

    return(pszDefualtSSTag);
}

static BOOL DbgIsSSActive(DWORD dwSSIn)
{
    char    *pszEnvVar;
    DWORD   dwEnv;

    dwEnv = 0;

    if (pszEnvVar = getenv(pszDEBUG_PRINT_MASK))
    {
        dwEnv = (DWORD)strtol(pszEnvVar, NULL, 16);
    }


    return((dwEnv & dwSSIn) > 0);
}

//+-------------------------------------------------------------------------
//
//  Function:  DbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------
int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...)
{
    va_list arglist;
    CHAR    ach1[1024];
    CHAR    ach2[1080];
    int     cch;
    HANDLE  hStdOut;
    DWORD   cb;
    DWORD   dwErr;

    dwErr = GetLastError();

    if (!(DbgIsSSActive(dwSubSystemId)))
    {
        SetLastError(dwErr);
        return(0);
    }

    _try 
    {
        va_start(arglist, lpFmt);

        _vsnprintf( ach1, sizeof(ach1), lpFmt, arglist);

        va_end(arglist);

        cch = wsprintf(ach2,"%s: %s", DbgGetSSString(dwSubSystemId), ach1);

        hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

        if (hStdOut != INVALID_HANDLE_VALUE)
        {
            WriteConsole( hStdOut, ach2, strlen(ach2), &cb, NULL);
        }

        OutputDebugString(ach2);

    } _except( EXCEPTION_EXECUTE_HANDLER) 
    {
        // return failure
        cch = 0;
    }
    SetLastError(dwErr);
    return cch;
}

#else

#ifdef __cplusplus
    extern "C"
    {
#endif

BOOL
WINAPI
DbgInitOSS(
        OssGlobal   *pog);

int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...);


#ifdef __cplusplus
    }       // balance of extern "C"
#endif

//+-------------------------------------------------------------------------
//
//  Function:  DbgInitOSS
//
//  Synopsis:  Do OSS init for debug. Do nothing in retail builds
//
//  Returns:   TRUE
//
//  Note:      Always FRONT_ALIGN encoding
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgInitOSS(
        OssGlobal   *pog)
{
    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Function:  DbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//		Nothing in retail builds
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------
int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...)
{

    return(0);
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\keysvc\certpcli.cpp ===
/*++

Copyright (C) 1996, 1997  Microsoft Corporation

Module Name:

    nt5wrap.cpp

Abstract:

    Client side CryptXXXData calls.

    Client funcs are preceeded by "CS" == Client Side
    Server functions are preceeded by "SS" == Server Side

Author:

    Scott Field (sfield)    14-Aug-97

Revisions:

    Todds                   04-Sep-97       Ported to .dll
    Matt Thomlinson (mattt) 09-Oct-97       Moved to common area for link by crypt32
    philh                   03-Dec-97       Added I_CertProtectFunction
    philh                   29-Sep-98       Renamed I_CertProtectFunction to
                                            I_CertCltProtectFunction.
                                            I_CertProtectFunction was moved to
                                            ..\ispu\pki\certstor\protroot.cpp
    petesk                  25-Jan-00       Moved to keysvc

--*/



#include <windows.h>
#include <wincrypt.h>
#include <cryptui.h>
#include "unicode.h"
#include "waitsvc.h"
#include "certprot.h"

// midl generated files

#include "keyrpc.h"
#include "lenroll.h"
#include "keysvc.h"
#include "keysvcc.h"
#include "cerrpc.h"



// fwds
RPC_STATUS CertBindA(
    unsigned char **pszBinding,
    RPC_BINDING_HANDLE *phBind
    );


RPC_STATUS CertUnbindA(
    unsigned char **pszBinding,
    RPC_BINDING_HANDLE *phBind
    );




BOOL
WINAPI
I_CertCltProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    )
{
    BOOL fResult;
    DWORD dwRetVal;
    RPC_BINDING_HANDLE h = NULL;
    unsigned char *pszBinding;
    RPC_STATUS RpcStatus;

    HANDLE  hEvent = NULL;

    BYTE *pbSSOut = NULL;
    DWORD cbSSOut = 0;
    BYTE rgbIn[1];

    if (NULL == pwszIn)
        pwszIn = L"";
    if (NULL == pbIn) {
        pbIn = rgbIn;
        cbIn = 0;
    }

    if (!FIsWinNT5()) {
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        goto ErrorReturn;
    }

    RpcStatus = CertBindA(&pszBinding, &h);
    if (RpcStatus != RPC_S_OK) {
        SetLastError(RpcStatus);
        goto ErrorReturn;
    }


    __try {
        dwRetVal = SSCertProtectFunction(
            h,
            dwFuncId,
            dwFlags,
            pwszIn,
            pbIn,
            cbIn,
            &pbSSOut,
            &cbSSOut
            );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwRetVal = GetExceptionCode();
    }

    CertUnbindA(&pszBinding, &h);

    if (ERROR_SUCCESS != dwRetVal) {
        if (RPC_S_UNKNOWN_IF == dwRetVal)
            dwRetVal = ERROR_CALL_NOT_IMPLEMENTED;
        SetLastError(dwRetVal);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    if (ppbOut)
        *ppbOut = pbSSOut;
    else if (pbSSOut)
        midl_user_free(pbSSOut);

    if (pcbOut)
        *pcbOut = cbSSOut;

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}



static RPC_STATUS CertBindA(unsigned char **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS  status;
    static BOOL fDone = FALSE;

    //
    // wait for the service to be available before attempting bind
    //

    WaitForCryptService(L"CryptSvc", &fDone);


    status = RpcStringBindingComposeA(
                            NULL,
                            (unsigned char*)KEYSVC_LOCAL_PROT_SEQ,
                            NULL,
                            (unsigned char*)KEYSVC_LOCAL_ENDPOINT,
                            NULL,
                            (unsigned char * *)pszBinding
                            );


    if (status)
    {
        return(status);
    }

    status = RpcBindingFromStringBindingA(*pszBinding, phBind);

    return status;
}



static RPC_STATUS CertUnbindA(unsigned char **pszBinding, RPC_BINDING_HANDLE *phBind)
{
    RPC_STATUS status;

    status = RpcStringFreeA(pszBinding);

    if (status)
    {
        return(status);
    }

    RpcBindingFree(phBind);

    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\keysvc\keysvcc.cpp ===
//depot/Lab03_N/DS/security/cryptoapi/common/keysvc/keysvcc.cpp#9 - edit change 6380 (text)
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       keysvcc.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include "keysvc.h"
#include "cryptui.h"
#include "lenroll.h"
#include "keysvcc.h"

#include "unicode.h"
#include "waitsvc.h"

typedef struct _WZR_RPC_BINDING_LIST
{
    LPCSTR pszProtSeq;
    LPCSTR pszEndpoint;
} WZR_RPC_BINDING_LIST;

WZR_RPC_BINDING_LIST g_awzrBindingList[] =
{
    { KEYSVC_LOCAL_PROT_SEQ, KEYSVC_LOCAL_ENDPOINT },
    { KEYSVC_DEFAULT_PROT_SEQ, KEYSVC_DEFAULT_ENDPOINT},
    { KEYSVC_LEGACY_PROT_SEQ,   KEYSVC_LEGACY_ENDPOINT}
};

DWORD g_cwzrBindingList = sizeof(g_awzrBindingList)/sizeof(g_awzrBindingList[0]);

/****************************************
 * Client side Key Service handles
 ****************************************/

typedef struct _KEYSVCC_INFO_ {
    KEYSVC_HANDLE   hKeySvc;
    handle_t        hRPCBinding;
} KEYSVCC_INFO, *PKEYSVCC_INFO;


void InitUnicodeString(
                       PKEYSVC_UNICODE_STRING pUnicodeString,
                       LPCWSTR pszString
                       )
{
    pUnicodeString->Length = wcslen(pszString) * sizeof(WCHAR);
    pUnicodeString->MaximumLength = pUnicodeString->Length + sizeof(WCHAR);
    pUnicodeString->Buffer = (USHORT*)pszString;
}

//*****************************************************
//
//  Implementation of Client API for Key Service
//
//*****************************************************

ULONG KeyOpenKeyServiceEx
(/* [in] */ RPC_IF_HANDLE rpc_ifspec, 
 /* [in] */ LPSTR pszMachineName,
 /* [in] */ KEYSVC_TYPE OwnerType,
 /* [in] */ LPWSTR pwszOwnerName,
 /* [in] */ void *pAuthentication,
 /* [out][in] */ void *pReserved,
 /* [out] */ KEYSVCC_HANDLE *phKeySvcCli)

{
    PKEYSVC_BLOB            pVersion = NULL;
    KEYSVC_BLOB             Authentication;
    PKEYSVC_BLOB            pAuth;
    unsigned char           *pStringBinding = NULL;
    PKEYSVCC_INFO           pKeySvcCliInfo = NULL;
    KEYSVC_UNICODE_STRING   OwnerName;
    ULONG                   ulErr = 0;
    DWORD i;
    static BOOL             fDone = FALSE;


    memset(&Authentication, 0, sizeof(Authentication));
    memset(&OwnerName, 0, sizeof(OwnerName));

    if (NULL != pAuthentication)
    {
        ulErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
    if (NULL != pwszOwnerName)
    {
        InitUnicodeString(&OwnerName, pwszOwnerName);
    }


    // allocate for the client key service handle
    if (NULL == (pKeySvcCliInfo =
        (PKEYSVCC_INFO)LocalAlloc(LMEM_ZEROINIT,
                                  sizeof(KEYSVCC_INFO))))
    {
        ulErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    //
    // before doing the Bind operation, wait for the cryptography
    // service to be available.
    //

    WaitForCryptService(L"ProtectedStorage", &fDone);
    for (i = 0; i < g_cwzrBindingList; i++)
    {
        if (RPC_S_OK != RpcNetworkIsProtseqValid(
                                    (unsigned char *)g_awzrBindingList[i].pszProtSeq))
        {
            continue;
        }

        ulErr = RpcStringBindingComposeA(
                              NULL,
                              (unsigned char *)g_awzrBindingList[i].pszProtSeq,
                              (unsigned char *)pszMachineName,
                              (unsigned char *)g_awzrBindingList[i].pszEndpoint,
                              NULL,
                              &pStringBinding);
        if (RPC_S_OK != ulErr)
        {
            continue;
        }

        ulErr = RpcBindingFromStringBinding(
                                    pStringBinding,
                                    &pKeySvcCliInfo->hRPCBinding);
        if (NULL != pStringBinding)
        {
            RpcStringFree(&pStringBinding);
        }
        if (RPC_S_OK != ulErr)
        {
            continue;
        }

        ulErr = RpcEpResolveBinding(pKeySvcCliInfo->hRPCBinding, rpc_ifspec); 
        if (RPC_S_OK != ulErr)
        {
            continue;
        }


        __try
        {

            ulErr = KeyrOpenKeyService(pKeySvcCliInfo->hRPCBinding,
                                       OwnerType, &OwnerName,
                                       0, &Authentication,
                                       &pVersion, &pKeySvcCliInfo->hKeySvc);

            *phKeySvcCli = (KEYSVCC_HANDLE)pKeySvcCliInfo;
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            ulErr = _exception_code();
        }
        if (RPC_S_OK == ulErr)
        {
            break;
        }

    }

    if(RPC_S_OK != ulErr)
    {
        goto Ret;
    }

    if (NULL != pReserved)
    {
	PKEYSVC_OPEN_KEYSVC_INFO pOpenInfoCaller = (PKEYSVC_OPEN_KEYSVC_INFO)pReserved; 
	if (pOpenInfoCaller->ulSize != sizeof(KEYSVC_OPEN_KEYSVC_INFO))
	{
	    ulErr = ERROR_INVALID_PARAMETER;
	    goto Ret;
	}

	if (NULL == pVersion)
	{
	    pOpenInfoCaller->ulVersion = KEYSVC_VERSION_W2K; 
	}
	else
	{
	    if (NULL == pVersion->pb)
	    {
		ulErr = ERROR_INVALID_PARAMETER; 
		goto Ret;
	    }

	    PKEYSVC_OPEN_KEYSVC_INFO pOpenInfoCallee = (PKEYSVC_OPEN_KEYSVC_INFO)pVersion->pb;
	    if (pOpenInfoCallee->ulSize != sizeof(KEYSVC_OPEN_KEYSVC_INFO))
	    {
		ulErr = ERROR_INVALID_PARAMETER; 
		goto Ret;
	    }
		
	    pOpenInfoCaller->ulVersion = pOpenInfoCallee->ulVersion; 
	}
    }

Ret:
    __try
    {
	if (NULL != pVersion) 
	    midl_user_free(pVersion); 
        if (pStringBinding)
            RpcStringFree(&pStringBinding);
        if (0 != ulErr)
        {
            if (pKeySvcCliInfo)
            {
                // close the RPC binding
                if (pKeySvcCliInfo->hRPCBinding)
                    RpcBindingFree(&pKeySvcCliInfo->hRPCBinding);
                LocalFree(pKeySvcCliInfo);
            }
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
    return ulErr;
}

ULONG KeyOpenKeyService
(/* [in] */ LPSTR pszMachineName,
 /* [in] */ KEYSVC_TYPE OwnerType,
 /* [in] */ LPWSTR pwszOwnerName,
 /* [in] */ void *pAuthentication,
 /* [out][in] */ void *pReserved,
 /* [out] */ KEYSVCC_HANDLE *phKeySvcCli)
{
    return KeyOpenKeyServiceEx
        (IKeySvc_v1_0_c_ifspec, 
         pszMachineName,
         OwnerType,
         pwszOwnerName,
         pAuthentication,
         pReserved,
         phKeySvcCli);
}
         
ULONG KeyEnumerateProviders(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [out][in] */ ULONG *pcProviderCount,
    /* [size_is][size_is][out][in] */ PKEYSVC_PROVIDER_INFO *ppProviders)
{
    PKEYSVC_BLOB    pTmpReserved = NULL;
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr =  KeyrEnumerateProviders(pKeySvcCliInfo->hRPCBinding,
                                        pKeySvcCliInfo->hKeySvc,
                                        &pTmpReserved,
                                        pcProviderCount, ppProviders);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG KeyEnumerateProviderTypes(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [out][in] */ ULONG *pcProviderCount,
    /* [size_is][size_is][out][in] */ PKEYSVC_PROVIDER_INFO *ppProviders)
{
    PKEYSVC_BLOB    pTmpReserved = NULL;
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrEnumerateProviderTypes(pKeySvcCliInfo->hRPCBinding,
                                          pKeySvcCliInfo->hKeySvc,
                                          &pTmpReserved,
                                          pcProviderCount, ppProviders);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG KeyEnumerateProvContainers(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ KEYSVC_PROVIDER_INFO Provider,
    /* [in, out] */ void *pReserved,
    /* [in, out] */ ULONG *pcContainerCount,
    /* [in, out][size_is(,*pcContainerCount)] */
               PKEYSVC_UNICODE_STRING *ppContainers)
{
    PKEYSVC_BLOB    pTmpReserved = NULL;
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        return KeyrEnumerateProvContainers(pKeySvcCliInfo->hRPCBinding,
                                           pKeySvcCliInfo->hKeySvc,
                                           Provider,
                                           &pTmpReserved, pcContainerCount,
                                           ppContainers);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG KeyCloseKeyService(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved)
{
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    PKEYSVC_BLOB    pTmpReserved = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrCloseKeyService(pKeySvcCliInfo->hRPCBinding,
                                   pKeySvcCliInfo->hKeySvc,
                                   &pTmpReserved);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG KeyGetDefaultProvider(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ ULONG ulProvType,
    /* [in] */ ULONG ulFlags,
    /* [out][in] */ void *pReserved,
    /* [out] */ ULONG *pulDefType,
    /* [out] */ PKEYSVC_PROVIDER_INFO *ppProvider)
{
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    PKEYSVC_BLOB    pTmpReserved = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrGetDefaultProvider(pKeySvcCliInfo->hRPCBinding,
                                       pKeySvcCliInfo->hKeySvc,
                                       ulProvType, ulFlags,
                                       &pTmpReserved, pulDefType,
                                       ppProvider);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG KeySetDefaultProvider(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ ULONG ulFlags,
    /* [out][in] */ void *pReserved,
    /* [in] */ KEYSVC_PROVIDER_INFO Provider)
{
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    PKEYSVC_BLOB    pTmpReserved = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrSetDefaultProvider(pKeySvcCliInfo->hRPCBinding,
                                       pKeySvcCliInfo->hKeySvc,
                                       ulFlags, &pTmpReserved,
                                       Provider);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG KeyEnroll
(/* [in] */ KEYSVCC_HANDLE hKeySvcCli, 
 /* [in] */ LPSTR pszMachineName,                    //IN Required: name of the remote machine
 /* [in] */ BOOL fKeyService,                        //IN Required: Whether the function is called remotely
 /* [in] */ DWORD dwPurpose,                         //IN Required: Indicates type of request - enroll/renew
 /* [in] */ LPWSTR pszAcctName,                      //IN Optional: Account name the service runs under
 /* [in] */ void *pAuthentication,                   //RESERVED must be NULL
 /* [in] */ BOOL fEnroll,                            //IN Required: Whether it is enrollment or renew
 /* [in] */ LPWSTR pszCALocation,                    //IN Required: The ca machine name
 /* [in] */ LPWSTR pszCAName,                        //IN Required: The ca name
 /* [in] */ BOOL fNewKey,                            //IN Required: Set the TRUE if new private key is needed
 /* [in] */ PCERT_REQUEST_PVK_NEW pKeyNew,           //IN Required: The private key information
 /* [in] */ CERT_BLOB *pCert,                        //IN Optional: The old certificate if renewing
 /* [in] */ PCERT_REQUEST_PVK_NEW pRenewKey,         //IN Optional: The new private key information
 /* [in] */ LPWSTR pszHashAlg,                       //IN Optional: The hash algorithm
 /* [in] */ LPWSTR pszDesStore,                      //IN Optional: The destination store
 /* [in] */ DWORD dwStoreFlags,                      //IN Optional: Flags for cert store.
 /* [in] */ PCERT_ENROLL_INFO pRequestInfo,          //IN Required: The information about the cert request
 /* [in] */ LPWSTR pszAttributes,                    //IN Optional: Attribute string for request
 /* [in] */ DWORD dwFlags,                           //RESERVED must be 0
 /* [in] */ BYTE *pReserved,                         //RESERVED must be NULL
 /* [out] */ CERT_BLOB *pPKCS7Blob,                  //OUT Optional: The PKCS7 from the CA
 /* [out] */ CERT_BLOB *pHashBlob,                   //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
 /* [out] */ DWORD *pdwStatus)                       //OUT Optional: The status of the enrollment/renewal
{
    PKEYSVC_BLOB                pReservedBlob = NULL;
    KEYSVC_UNICODE_STRING       AcctName;
    KEYSVC_UNICODE_STRING       CALocation;
    KEYSVC_UNICODE_STRING       CAName;
    KEYSVC_UNICODE_STRING       DesStore;
    KEYSVC_UNICODE_STRING       HashAlg;
    KEYSVC_BLOB                 *pPKCS7KeySvcBlob = NULL;
    KEYSVC_BLOB                 *pHashKeySvcBlob = NULL;
    KEYSVC_CERT_ENROLL_INFO     EnrollInfo;
    KEYSVC_CERT_REQUEST_PVK_NEW NewKeyInfo;
    KEYSVC_CERT_REQUEST_PVK_NEW RenewKeyInfo;
    KEYSVC_BLOB                 CertBlob;
    DWORD                       i;
    DWORD                       j;
    PKEYSVCC_INFO               pKeySvcCliInfo = NULL;
    DWORD                       dwErr = 0;
    DWORD                       cbExtensions;
    PBYTE                       pbExtensions;

    __try
    {
        // initialize everything
        memset(pPKCS7Blob, 0, sizeof(CERT_BLOB));
        memset(pHashBlob, 0, sizeof(CERT_BLOB));
        memset(&AcctName, 0, sizeof(AcctName));
        memset(&CALocation, 0, sizeof(CALocation));
        memset(&CAName, 0, sizeof(CAName));
        memset(&HashAlg, 0, sizeof(HashAlg));
        memset(&DesStore, 0, sizeof(DesStore));
        memset(&NewKeyInfo, 0, sizeof(NewKeyInfo));
        memset(&EnrollInfo, 0, sizeof(EnrollInfo));
        memset(&RenewKeyInfo, 0, sizeof(RenewKeyInfo));
        memset(&CertBlob, 0, sizeof(CertBlob));

	if (NULL == hKeySvcCli)
	{
	    dwErr = ERROR_INVALID_PARAMETER; 
	    goto Ret;
	}

	pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli; 

        // set up the key service unicode structs
        if (pszAcctName)
            InitUnicodeString(&AcctName, pszAcctName);
        if (pszCALocation)
            InitUnicodeString(&CALocation, pszCALocation);
        if (pszCAName)
            InitUnicodeString(&CAName, pszCAName);
        if (pszHashAlg)
            InitUnicodeString(&HashAlg, pszHashAlg);
        if (pszDesStore)
            InitUnicodeString(&DesStore, pszDesStore);

        // set up the new key info structure for the remote call
        NewKeyInfo.ulProvType = pKeyNew->dwProvType;
        if (pKeyNew->pwszProvider)
        {
            InitUnicodeString(&NewKeyInfo.Provider, pKeyNew->pwszProvider);
        }
        NewKeyInfo.ulProviderFlags = pKeyNew->dwProviderFlags;
        if (pKeyNew->pwszKeyContainer)
        {
            InitUnicodeString(&NewKeyInfo.KeyContainer,
                              pKeyNew->pwszKeyContainer);
        }
        NewKeyInfo.ulKeySpec = pKeyNew->dwKeySpec;
        NewKeyInfo.ulGenKeyFlags = pKeyNew->dwGenKeyFlags;

        // set up the usage OIDs
        if (pRequestInfo->pwszUsageOID)
        {
            InitUnicodeString(&EnrollInfo.UsageOID, pRequestInfo->pwszUsageOID);
        }

        // set up the cert DN Name
        if (pRequestInfo->pwszCertDNName)
        {
            InitUnicodeString(&EnrollInfo.CertDNName, pRequestInfo->pwszCertDNName);
        }

        // set up the request info structure for the remote call
        EnrollInfo.ulPostOption = pRequestInfo->dwPostOption;
        if (pRequestInfo->pwszFriendlyName)
        {
            InitUnicodeString(&EnrollInfo.FriendlyName,
                              pRequestInfo->pwszFriendlyName);
        }
        if (pRequestInfo->pwszDescription)
        {
            InitUnicodeString(&EnrollInfo.Description,
                              pRequestInfo->pwszDescription);
        }
        if (pszAttributes)
        {
            InitUnicodeString(&EnrollInfo.Attributes, pszAttributes);
        }

        // convert the cert extensions
        // NOTE, the extensions structure cannot be simply cast,
        // as the structures have different packing behaviors in
        // 64 bit systems.


        EnrollInfo.cExtensions = pRequestInfo->dwExtensions;
        cbExtensions = EnrollInfo.cExtensions*(sizeof(PKEYSVC_CERT_EXTENSIONS) +
                                               sizeof(KEYSVC_CERT_EXTENSIONS));

        for(i=0; i < EnrollInfo.cExtensions; i++)
        {
            cbExtensions += pRequestInfo->prgExtensions[i]->cExtension*
	                    sizeof(KEYSVC_CERT_EXTENSION);
        }

        EnrollInfo.prgExtensions = (PKEYSVC_CERT_EXTENSIONS*)midl_user_allocate( cbExtensions);

        if(NULL == EnrollInfo.prgExtensions)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }

        pbExtensions = (PBYTE)(EnrollInfo.prgExtensions + EnrollInfo.cExtensions);




        for(i=0; i < EnrollInfo.cExtensions; i++)
        {
            EnrollInfo.prgExtensions[i] = (PKEYSVC_CERT_EXTENSIONS)pbExtensions;
            pbExtensions += sizeof(KEYSVC_CERT_EXTENSIONS);
            EnrollInfo.prgExtensions[i]->cExtension = pRequestInfo->prgExtensions[i]->cExtension;

            EnrollInfo.prgExtensions[i]->rgExtension = (PKEYSVC_CERT_EXTENSION)pbExtensions;
            pbExtensions += sizeof(KEYSVC_CERT_EXTENSION)*EnrollInfo.prgExtensions[i]->cExtension;


            for(j=0; j < EnrollInfo.prgExtensions[i]->cExtension; j++)
            {

                EnrollInfo.prgExtensions[i]->rgExtension[j].pszObjId = 
                    pRequestInfo->prgExtensions[i]->rgExtension[j].pszObjId;

                EnrollInfo.prgExtensions[i]->rgExtension[j].fCritical = 
                    pRequestInfo->prgExtensions[i]->rgExtension[j].fCritical;

                EnrollInfo.prgExtensions[i]->rgExtension[j].cbData = 
                    pRequestInfo->prgExtensions[i]->rgExtension[j].Value.cbData;

                EnrollInfo.prgExtensions[i]->rgExtension[j].pbData = 
                    pRequestInfo->prgExtensions[i]->rgExtension[j].Value.pbData;
            }
        }

        // if doing renewal then make sure have everything needed
        if ((CRYPTUI_WIZ_CERT_RENEW == dwPurpose) &&
            ((NULL == pRenewKey) || (NULL == pCert)))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        // set up the new key info structure for the remote call
        if (pRenewKey)
        {
            RenewKeyInfo.ulProvType = pRenewKey->dwProvType;
            if (pRenewKey->pwszProvider)
            {
                InitUnicodeString(&RenewKeyInfo.Provider, pRenewKey->pwszProvider);
            }
            RenewKeyInfo.ulProviderFlags = pRenewKey->dwProviderFlags;
            if (pRenewKey->pwszKeyContainer)
            {
                InitUnicodeString(&RenewKeyInfo.KeyContainer,
                                  pRenewKey->pwszKeyContainer);
            }
            RenewKeyInfo.ulKeySpec = pRenewKey->dwKeySpec;
            RenewKeyInfo.ulGenKeyFlags = pRenewKey->dwGenKeyFlags;
        }

        // set up the cert blob for renewal
        if (pCert)
        {
            CertBlob.cb = pCert->cbData;
            CertBlob.pb = pCert->pbData;
        }

        // make the remote enrollment call
        if (0 != (dwErr = KeyrEnroll(pKeySvcCliInfo->hRPCBinding, fKeyService, dwPurpose,
                                    &AcctName, &CALocation, &CAName, fNewKey,
                                    &NewKeyInfo, &CertBlob, &RenewKeyInfo,
                                    &HashAlg, &DesStore, dwStoreFlags,
                                    &EnrollInfo, dwFlags, &pReservedBlob,
                                    &pPKCS7KeySvcBlob,
                                    &pHashKeySvcBlob, pdwStatus)))
            goto Ret;

        // allocate and copy the output parameters
        if (pPKCS7KeySvcBlob->cb)
        {
            pPKCS7Blob->cbData = pPKCS7KeySvcBlob->cb;
            if (NULL == (pPKCS7Blob->pbData =
                (BYTE*)midl_user_allocate(pPKCS7Blob->cbData)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            memcpy(pPKCS7Blob->pbData, pPKCS7KeySvcBlob->pb,
                   pPKCS7Blob->cbData);
        }
        if (pHashKeySvcBlob->cb)
        {
            pHashBlob->cbData = pHashKeySvcBlob->cb;
            if (NULL == (pHashBlob->pbData =
                (BYTE*)midl_user_allocate(pHashBlob->cbData)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            memcpy(pHashBlob->pbData, pHashKeySvcBlob->pb, pHashBlob->cbData);
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        return _exception_code();
    }
Ret:
    __try
    {
        if (pPKCS7KeySvcBlob)
        {
            midl_user_free(pPKCS7KeySvcBlob);
        }
        if (pHashKeySvcBlob)
        {
            midl_user_free(pHashKeySvcBlob);
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        return _exception_code();
    }
    return dwErr;
}

// Params needed for create:
// 
// Params not needed for submit:
//     all except pszMachineName, dwPurpose, dwFlags, fEnroll, dwStoreFlags, hRequest, and dwFlags. 
//
// Params not needed for free:
//     all except pszMachineName, hRequest, and dwFlags. 
//
ULONG KeyEnroll_V2
(/* [in] */ KEYSVCC_HANDLE hKeySvcCli, 
 /* [in] */ LPSTR pszMachineName,                    //IN Required: name of the remote machine
 /* [in] */ BOOL fKeyService,                        //IN Required: Whether the function is called remotely
 /* [in] */ DWORD dwPurpose,                         //IN Required: Indicates type of request - enroll/renew
 /* [in] */ DWORD dwFlags,                           //IN Required: Flags for enrollment
 /* [in] */ LPWSTR pszAcctName,                      //IN Optional: Account name the service runs under
 /* [in] */ void *pAuthentication,                   //RESERVED must be NULL
 /* [in] */ BOOL fEnroll,                            //IN Required: Whether it is enrollment or renew
 /* [in] */ LPWSTR pszCALocation,                    //IN Required: The ca machine names to attempt to enroll with
 /* [in] */ LPWSTR pszCAName,                        //IN Required: The ca names to attempt to enroll with
 /* [in] */ BOOL fNewKey,                            //IN Required: Set the TRUE if new private key is needed
 /* [in] */ PCERT_REQUEST_PVK_NEW pKeyNew,           //IN Required: The private key information
 /* [in] */ CERT_BLOB *pCert,                        //IN Optional: The old certificate if renewing
 /* [in] */ PCERT_REQUEST_PVK_NEW pRenewKey,         //IN Optional: The new private key information
 /* [in] */ LPWSTR pszHashAlg,                       //IN Optional: The hash algorithm
 /* [in] */ LPWSTR pszDesStore,                      //IN Optional: The destination store
 /* [in] */ DWORD dwStoreFlags,                      //IN Optional: Flags for cert store.
 /* [in] */ PCERT_ENROLL_INFO pRequestInfo,          //IN Required: The information about the cert request
 /* [in] */ LPWSTR pszAttributes,                    //IN Optional: Attribute string for request
 /* [in] */ DWORD dwReservedFlags,                   //RESERVED must be 0
 /* [in] */ BYTE *pReserved,                         //RESERVED must be NULL
 /* [in][out] */ HANDLE *phRequest,                      //IN OUT Optional: A handle to a created request
 /* [out] */ CERT_BLOB *pPKCS7Blob,                  //OUT Optional: The PKCS7 from the CA
 /* [out] */ CERT_BLOB *pHashBlob,                   //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
 /* [out] */ DWORD *pdwStatus)                       //OUT Optional: The status of the enrollment/renewal
{
    PKEYSVC_BLOB                    pReservedBlob = NULL;
    KEYSVC_UNICODE_STRING           AcctName;
    KEYSVC_UNICODE_STRING           CALocation;
    KEYSVC_UNICODE_STRING           CAName;
    KEYSVC_UNICODE_STRING           DesStore;
    KEYSVC_UNICODE_STRING           HashAlg;
    KEYSVC_BLOB                     KeySvcRequest; 
    KEYSVC_BLOB                    *pKeySvcRequest   = NULL;
    KEYSVC_BLOB                    *pPKCS7KeySvcBlob = NULL;
    KEYSVC_BLOB                    *pHashKeySvcBlob  = NULL;
    ULONG                           ulKeySvcStatus   = 0; 
    KEYSVC_CERT_ENROLL_INFO         EnrollInfo;
    KEYSVC_CERT_REQUEST_PVK_NEW_V2  NewKeyInfo;
    KEYSVC_CERT_REQUEST_PVK_NEW_V2  RenewKeyInfo;
    KEYSVC_BLOB                     CertBlob;
    DWORD                           i;
    DWORD                           j;
    DWORD                           dwErr = 0;
    DWORD                           cbExtensions;
    PBYTE                           pbExtensions;
    BOOL                            fCreateRequest   = 0 == (dwFlags & (CRYPTUI_WIZ_SUBMIT_ONLY | CRYPTUI_WIZ_FREE_ONLY)); 
    PKEYSVCC_INFO                   pKeySvcCliInfo = NULL;

    __try
    {
        //////////////////////////////////////////////////////////////
        // 
        // INITIALIZATION:
        //
        //////////////////////////////////////////////////////////////

        if (NULL != pPKCS7Blob) { memset(pPKCS7Blob, 0, sizeof(CERT_BLOB)); } 
        if (NULL != pHashBlob)  { memset(pHashBlob, 0, sizeof(CERT_BLOB)); } 
        if (NULL != phRequest && NULL != *phRequest)
        {
            pKeySvcRequest     = &KeySvcRequest; 
            pKeySvcRequest->cb = sizeof(*phRequest); 
            pKeySvcRequest->pb = (BYTE *)phRequest; 
        }

	memset(&AcctName, 0, sizeof(AcctName));
        memset(&CALocation, 0, sizeof(CALocation));
        memset(&CAName, 0, sizeof(CAName));
        memset(&HashAlg, 0, sizeof(HashAlg));
        memset(&DesStore, 0, sizeof(DesStore));
        memset(&NewKeyInfo, 0, sizeof(NewKeyInfo));
        memset(&EnrollInfo, 0, sizeof(EnrollInfo));
        memset(&RenewKeyInfo, 0, sizeof(RenewKeyInfo));
        memset(&CertBlob, 0, sizeof(CertBlob));



        //////////////////////////////////////////////////////////////
        //
        // PROCEDURE BODY:
        //
        //////////////////////////////////////////////////////////////

	if (NULL == hKeySvcCli)
	{
            dwErr = ERROR_INVALID_PARAMETER; 
            goto Ret;
	}

	pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli; 

        // set up the key service unicode structs
        if (pszAcctName)
            InitUnicodeString(&AcctName, pszAcctName);
        if (pszCALocation)
            InitUnicodeString(&CALocation, pszCALocation);
        if (pszCAName)
            InitUnicodeString(&CAName, pszCAName);
        if (pszHashAlg)
            InitUnicodeString(&HashAlg, pszHashAlg);
        if (pszDesStore)
            InitUnicodeString(&DesStore, pszDesStore);

        // set up the new key info structure for the remote call
        // This is only necessary if we are actually _creating_ a request. 
        // Submit-only and free-only operations can skip this operation. 
        // 
        if (TRUE == fCreateRequest)
        {
            NewKeyInfo.ulProvType = pKeyNew->dwProvType;
            if (pKeyNew->pwszProvider)
            {
                InitUnicodeString(&NewKeyInfo.Provider, pKeyNew->pwszProvider);
            }
            NewKeyInfo.ulProviderFlags = pKeyNew->dwProviderFlags;
            if (pKeyNew->pwszKeyContainer)
            {
                InitUnicodeString(&NewKeyInfo.KeyContainer,
                                  pKeyNew->pwszKeyContainer);
            }
            NewKeyInfo.ulKeySpec = pKeyNew->dwKeySpec;
            NewKeyInfo.ulGenKeyFlags = pKeyNew->dwGenKeyFlags;
            
            NewKeyInfo.ulEnrollmentFlags = pKeyNew->dwEnrollmentFlags; 
            NewKeyInfo.ulSubjectNameFlags = pKeyNew->dwSubjectNameFlags;
            NewKeyInfo.ulPrivateKeyFlags = pKeyNew->dwPrivateKeyFlags;
            NewKeyInfo.ulGeneralFlags = pKeyNew->dwGeneralFlags; 

            // set up the usage OIDs
            if (pRequestInfo->pwszUsageOID)
            {
                InitUnicodeString(&EnrollInfo.UsageOID, pRequestInfo->pwszUsageOID);
            }

            // set up the cert DN Name
            if (pRequestInfo->pwszCertDNName)
            {
                InitUnicodeString(&EnrollInfo.CertDNName, pRequestInfo->pwszCertDNName);
            }

            // set up the request info structure for the remote call
            EnrollInfo.ulPostOption = pRequestInfo->dwPostOption;
            if (pRequestInfo->pwszFriendlyName)
            {
                InitUnicodeString(&EnrollInfo.FriendlyName,
                                  pRequestInfo->pwszFriendlyName);
            }
            if (pRequestInfo->pwszDescription)
            {
                InitUnicodeString(&EnrollInfo.Description,
                                  pRequestInfo->pwszDescription);
            }
            if (pszAttributes)
            {
                InitUnicodeString(&EnrollInfo.Attributes, pszAttributes);
            }

            // convert the cert extensions
            // NOTE, the extensions structure cannot be simply cast,
            // as the structures have different packing behaviors in
            // 64 bit systems.
            
            
            EnrollInfo.cExtensions = pRequestInfo->dwExtensions;
            cbExtensions = EnrollInfo.cExtensions*(sizeof(PKEYSVC_CERT_EXTENSIONS) +
                                                   sizeof(KEYSVC_CERT_EXTENSIONS));
            
            for(i=0; i < EnrollInfo.cExtensions; i++)
            {
                cbExtensions += pRequestInfo->prgExtensions[i]->cExtension*
                    sizeof(KEYSVC_CERT_EXTENSION);
            }
            
            EnrollInfo.prgExtensions = (PKEYSVC_CERT_EXTENSIONS*)midl_user_allocate( cbExtensions);
            
            if(NULL == EnrollInfo.prgExtensions)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            
            pbExtensions = (PBYTE)(EnrollInfo.prgExtensions + EnrollInfo.cExtensions);

            for(i=0; i < EnrollInfo.cExtensions; i++)
            {
                EnrollInfo.prgExtensions[i] = (PKEYSVC_CERT_EXTENSIONS)pbExtensions;
                pbExtensions += sizeof(KEYSVC_CERT_EXTENSIONS);
                EnrollInfo.prgExtensions[i]->cExtension = pRequestInfo->prgExtensions[i]->cExtension;
                
                EnrollInfo.prgExtensions[i]->rgExtension = (PKEYSVC_CERT_EXTENSION)pbExtensions;
                pbExtensions += sizeof(KEYSVC_CERT_EXTENSION)*EnrollInfo.prgExtensions[i]->cExtension;
                
                
                for(j=0; j < EnrollInfo.prgExtensions[i]->cExtension; j++)
                {
                    
                    EnrollInfo.prgExtensions[i]->rgExtension[j].pszObjId = 
                        pRequestInfo->prgExtensions[i]->rgExtension[j].pszObjId;
                    
                    EnrollInfo.prgExtensions[i]->rgExtension[j].fCritical = 
                        pRequestInfo->prgExtensions[i]->rgExtension[j].fCritical;
                    
                    EnrollInfo.prgExtensions[i]->rgExtension[j].cbData = 
                        pRequestInfo->prgExtensions[i]->rgExtension[j].Value.cbData;
                    
                    EnrollInfo.prgExtensions[i]->rgExtension[j].pbData = 
                        pRequestInfo->prgExtensions[i]->rgExtension[j].Value.pbData;
                }
            }

            // if doing renewal then make sure have everything needed
            if ((CRYPTUI_WIZ_CERT_RENEW == dwPurpose) &&
                ((NULL == pRenewKey) || (NULL == pCert)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto Ret;
            }
            
            // set up the new key info structure for the remote call
            if (pRenewKey)
            {
                RenewKeyInfo.ulProvType = pRenewKey->dwProvType;
                if (pRenewKey->pwszProvider)
                {
                    InitUnicodeString(&RenewKeyInfo.Provider, pRenewKey->pwszProvider);
                }
                RenewKeyInfo.ulProviderFlags = pRenewKey->dwProviderFlags;
                if (pRenewKey->pwszKeyContainer)
                {
                    InitUnicodeString(&RenewKeyInfo.KeyContainer,
                                      pRenewKey->pwszKeyContainer);
                }
                RenewKeyInfo.ulKeySpec = pRenewKey->dwKeySpec;
                RenewKeyInfo.ulGenKeyFlags = pRenewKey->dwGenKeyFlags;
                RenewKeyInfo.ulEnrollmentFlags = pRenewKey->dwEnrollmentFlags;
                RenewKeyInfo.ulSubjectNameFlags = pRenewKey->dwSubjectNameFlags;
                RenewKeyInfo.ulPrivateKeyFlags = pRenewKey->dwPrivateKeyFlags;
                RenewKeyInfo.ulGeneralFlags = pRenewKey->dwGeneralFlags;
            }
            
            // set up the cert blob for renewal
            if (pCert)
            {
                CertBlob.cb = pCert->cbData;
                CertBlob.pb = pCert->pbData;
            }
        }

        // make the remote enrollment call
        if (0 != (dwErr = KeyrEnroll_V2
                  (pKeySvcCliInfo->hRPCBinding, 
                   fKeyService, 
                   dwPurpose,
                   dwFlags, 
                   &AcctName, 
                   &CALocation, 
                   &CAName, 
                   fNewKey,
                   &NewKeyInfo, 
                   &CertBlob, 
                   &RenewKeyInfo,
                   &HashAlg, 
                   &DesStore, 
                   dwStoreFlags,
                   &EnrollInfo, 
                   dwReservedFlags, 
                   &pReservedBlob,
                   &pKeySvcRequest, 
                   &pPKCS7KeySvcBlob,
                   &pHashKeySvcBlob,
                   &ulKeySvcStatus)))
            goto Ret;

        // allocate and copy the output parameters.
	if ((NULL != pKeySvcRequest)     && 
	    (0     < pKeySvcRequest->cb) && 
	    (NULL != phRequest))
	{
	    memcpy(phRequest, pKeySvcRequest->pb, sizeof(*phRequest));
	}
	    
        if ((NULL != pPKCS7KeySvcBlob)     &&
	    (0     < pPKCS7KeySvcBlob->cb) && 
	    (NULL != pPKCS7Blob))
        {
            pPKCS7Blob->cbData = pPKCS7KeySvcBlob->cb;
            if (NULL == (pPKCS7Blob->pbData =
                (BYTE*)midl_user_allocate(pPKCS7Blob->cbData)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            memcpy(pPKCS7Blob->pbData, pPKCS7KeySvcBlob->pb,
                   pPKCS7Blob->cbData);
        }
        if ((NULL != pHashKeySvcBlob)     &&
	    (0     < pHashKeySvcBlob->cb) &&
	    (NULL != pHashBlob))
        {
            pHashBlob->cbData = pHashKeySvcBlob->cb;
            if (NULL == (pHashBlob->pbData =
                (BYTE*)midl_user_allocate(pHashBlob->cbData)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            memcpy(pHashBlob->pbData, pHashKeySvcBlob->pb, pHashBlob->cbData);
        }
	if (NULL != pdwStatus)
	{
	    *pdwStatus = (DWORD)ulKeySvcStatus; 
	}
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        return _exception_code();
    }
Ret:
    __try
    {
        if(EnrollInfo.prgExtensions)
        {
            midl_user_free(EnrollInfo.prgExtensions);
        }
	if (pKeySvcRequest)
	{
	    midl_user_free(pKeySvcRequest);
	}
        if (pPKCS7KeySvcBlob)
        {
            midl_user_free(pPKCS7KeySvcBlob);
        }
        if (pHashKeySvcBlob)
        {
            midl_user_free(pHashKeySvcBlob);
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        return _exception_code();
    }
    return dwErr;
}

ULONG KeyExportCert(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ LPWSTR pwszPassword,
    /* [in] */ LPWSTR pwszCertStore,
    /* [in] */ ULONG cHashCount,
    /* [size_is][in] */ KEYSVC_CERT_HASH *pHashes,
    /* [in] */ ULONG ulFlags,
    /* [in, out] */ void *pReserved,
    /* [out] */ PKEYSVC_BLOB *ppPFXBlob)
{
    PKEYSVCC_INFO           pKeySvcCliInfo = NULL;
    PKEYSVC_BLOB            pTmpReserved = NULL;
    KEYSVC_UNICODE_STRING   Password;
    KEYSVC_UNICODE_STRING   CertStore;
    ULONG                   ulErr = 0;

    __try
    {
        memset(&Password, 0, sizeof(Password));
        memset(&CertStore, 0, sizeof(CertStore));

        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        InitUnicodeString(&Password, pwszPassword);
        InitUnicodeString(&CertStore, pwszCertStore);

        ulErr = KeyrExportCert(pKeySvcCliInfo->hRPCBinding,
                               pKeySvcCliInfo->hKeySvc,
                               &Password, &CertStore,
                               cHashCount, pHashes,
                               ulFlags, &pTmpReserved, ppPFXBlob);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG KeyImportCert(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [in] */ LPWSTR pwszPassword,
    /* [in] */ LPWSTR pwszCertStore,
    /* [in] */ PKEYSVC_BLOB pPFXBlob,
    /* [in] */ ULONG ulFlags,
    /* [in, out] */ void *pReserved)
{
    PKEYSVCC_INFO           pKeySvcCliInfo = NULL;
    PKEYSVC_BLOB            pTmpReserved = NULL;
    KEYSVC_UNICODE_STRING   Password;
    KEYSVC_UNICODE_STRING   CertStore;
    ULONG                   ulErr = 0;

    __try
    {
        memset(&Password, 0, sizeof(Password));
        memset(&CertStore, 0, sizeof(CertStore));

        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        InitUnicodeString(&Password, pwszPassword);
        InitUnicodeString(&CertStore, pwszCertStore);

        ulErr = KeyrImportCert(pKeySvcCliInfo->hRPCBinding,
                               pKeySvcCliInfo->hKeySvc,
                               &Password, &CertStore,
                               pPFXBlob, ulFlags, &pTmpReserved);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}


ULONG KeyEnumerateAvailableCertTypes(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [out][in] */ ULONG *pcCertTypeCount,
    /* [in, out][size_is(,*pcCertTypeCount)] */
               PKEYSVC_UNICODE_STRING *ppCertTypes)

{
    PKEYSVC_BLOB    pTmpReserved = NULL;
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrEnumerateAvailableCertTypes(pKeySvcCliInfo->hRPCBinding,
                                          pKeySvcCliInfo->hKeySvc,
                                          &pTmpReserved,
                                          pcCertTypeCount, 
                                          ppCertTypes);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}


ULONG KeyEnumerateCAs(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [in] */      ULONG  ulFlags,
    /* [out][in] */ ULONG *pcCACount,
    /* [in, out][size_is(,*pcCACount)] */
               PKEYSVC_UNICODE_STRING *ppCAs)

{
    PKEYSVC_BLOB    pTmpReserved = NULL;
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrEnumerateCAs(pKeySvcCliInfo->hRPCBinding,
                                 pKeySvcCliInfo->hKeySvc,
                                 &pTmpReserved,
                                 ulFlags,
                                 pcCACount, 
                                 ppCAs);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}


extern "C" ULONG KeyQueryRequestStatus
(/* [in] */        KEYSVCC_HANDLE                        hKeySvcCli, 
 /* [in] */        HANDLE                                hRequest, 
 /* [out, ref] */  CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO  *pQueryInfo)
{
    KEYSVC_QUERY_CERT_REQUEST_INFO  ksQueryCertRequestInfo; 
    PKEYSVCC_INFO                   pKeySvcCliInfo          = NULL;
    ULONG                           ulErr                   = 0;

    __try
    {
        if (NULL == hKeySvcCli || NULL == pQueryInfo)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        ZeroMemory(&ksQueryCertRequestInfo, sizeof(ksQueryCertRequestInfo)); 

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = KeyrQueryRequestStatus
          (pKeySvcCliInfo->hRPCBinding,
           (unsigned __int64)hRequest, 
           &ksQueryCertRequestInfo); 
        if (ERROR_SUCCESS == ulErr) 
        {
            pQueryInfo->dwSize   = ksQueryCertRequestInfo.ulSize; 
            pQueryInfo->dwStatus = ksQueryCertRequestInfo.ulStatus; 
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }
Ret:
    return ulErr;
}

ULONG RKeyOpenKeyService
(/* [in] */ LPSTR pszMachineName,
 /* [in] */ KEYSVC_TYPE OwnerType,
 /* [in] */ LPWSTR pwszOwnerName,
 /* [in] */ void *pAuthentication,
 /* [out][in] */ void *pReserved,
 /* [out] */ KEYSVCC_HANDLE *phKeySvcCli)
{
    BOOL           fMustCloseKeyService  = FALSE;  // TRUE if the cleanup code must close key service
    DWORD          dwResult; 
    LPWSTR         pwszServerPrincName   = NULL; 
    PKEYSVCC_INFO  pKeySvcCliInfo        = NULL;

    dwResult = KeyOpenKeyServiceEx
        (IKeySvcR_v1_0_c_ifspec, 
         pszMachineName,
         OwnerType,
         pwszOwnerName,
         pAuthentication,
         pReserved,
         phKeySvcCli);
    if (ERROR_SUCCESS != dwResult) 
        goto error; 
    fMustCloseKeyService = TRUE; 
    
    pKeySvcCliInfo = (PKEYSVCC_INFO)(*phKeySvcCli); 
    dwResult = RpcMgmtInqServerPrincNameW(pKeySvcCliInfo->hRPCBinding, RPC_C_AUTHN_GSS_NEGOTIATE, &pwszServerPrincName); 
    if (RPC_S_OK != dwResult) 
        goto error;

    dwResult = RpcBindingSetAuthInfoW
        (pKeySvcCliInfo->hRPCBinding, 
         pwszServerPrincName,            
         RPC_C_AUTHN_LEVEL_PKT_PRIVACY,  // Calls are authenticated and encrypted
         RPC_C_AUTHN_GSS_NEGOTIATE,   
         NULL, 
         RPC_C_AUTHZ_NONE
         );
    if (ERROR_SUCCESS != dwResult)
        goto error;
    
    fMustCloseKeyService  = FALSE; 
    dwResult              = ERROR_SUCCESS; 
 error:
    if (fMustCloseKeyService)         { RKeyCloseKeyService(phKeySvcCli, 0); }
    if (NULL != pwszServerPrincName)  { RpcStringFreeW(&pwszServerPrincName); }
    return dwResult; 
}

ULONG RKeyCloseKeyService(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved)
{
    return KeyCloseKeyService(hKeySvcCli, pReserved); 
}


ULONG RKeyPFXInstall
(/* [in] */ KEYSVCC_HANDLE          hKeySvcCli,
 /* [in] */ PKEYSVC_BLOB            pPFX,
 /* [in] */ PKEYSVC_UNICODE_STRING  pPassword,
 /* [in] */ ULONG                   ulFlags)
{
    PKEYSVCC_INFO   pKeySvcCliInfo = NULL;
    PKEYSVC_BLOB    pTmpReserved = NULL;
    ULONG           ulErr = 0;

    __try
    {
        if (NULL == hKeySvcCli)
        {
            ulErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        pKeySvcCliInfo = (PKEYSVCC_INFO)hKeySvcCli;

        ulErr = RKeyrPFXInstall(pKeySvcCliInfo->hRPCBinding,
                                pPFX, 
                                pPassword, 
                                ulFlags); 
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ulErr = _exception_code();
    }

Ret:
    return ulErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\ossutil\ossconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ossconv.cpp
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  Functions:  OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//              OssConvToAttribute
//              OssConvToAlgorithmIdentifier
//              OssConvFromAlgorithmIdentifier
//
//  According to the <draft-ietf-pkix-ipki-part1-10.txt> :
//      For UTCTime. Where YY is greater than or equal to 50, the year shall
//      be interpreted as 19YY. Where YY is less than
//      50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//              03-May-96   kevinr  merged from wincrmsg
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater or equal than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1950
#define YEARLAST                2049
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        unsigned short cMax = *pCount;
        unsigned long *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (unsigned long)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        unsigned long *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN short mindiff,
    IN ossBoolean utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = mindiff > 0 ? mindiff : -mindiff;
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }

    // Note, FILETIME is only 32 bit aligned. __int64 is 64 bit aligned.
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        unsigned __int64 uTime;
        unsigned __int64 uDiff;

        memcpy(&uTime, pFileTime, sizeof(uTime));
        memcpy(&uDiff, &ftmDiff, sizeof(uDiff));

        if (mindiff > 0)
            uTime += uDiff;
        else
            uTime -= uDiff;

        memcpy(pFileTime, &uTime, sizeof(*pFileTime));
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pOssTime->year   = t.wYear % 100;
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pOssTime->year >= MAGICYEAR ?
                    (1900 + pOssTime->year) : (2000 + pOssTime->year);
    t.wMonth  = pOssTime->month;
    t.wDay    = pOssTime->day;
    t.wHour   = pOssTime->hour;
    t.wMinute = pOssTime->minute;
    t.wSecond = pOssTime->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pOssTime->mindiff,
        pOssTime->utc
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pOssTime->year   = t.wYear;
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->millisec = t.wMilliseconds;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pOssTime->year;
    t.wMonth  = pOssTime->month;
    t.wDay    = pOssTime->day;
    t.wHour   = pOssTime->hour;
    t.wMinute = pOssTime->minute;
    t.wSecond = pOssTime->second;
    t.wMilliseconds = pOssTime->millisec;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pOssTime->mindiff,
        pOssTime->utc
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = OSS_GENERALIZED_TIME_CHOICE;
        pOssTime->year   = t.wYear;
    } else {
        *pwChoice = OSS_UTC_TIME_CHOICE;
        pOssTime->year = t.wYear % 100;
    }
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    if (OSS_UTC_TIME_CHOICE == wChoice)
        return OssConvFromUTCTime(pOssTime, pFileTime);
    else
        return OssConvFromGeneralizedTime(pOssTime, pFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\keysvc\server\makefile.inc ===
$(CRYPTO_INC)\$(O)\keysvc.h: $(O)\keysvc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@

$(CRYPTO_INC)\$(O)\cerrpc.h: $(O)\cerrpc.h
        -mkdir $(CRYPTO_INC)\$(O)
        copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\ossutil\pkioss.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkioss.cpp
//
//  Contents:   PKI OSS support functions.
//
//  Functions:  PkiOssEncode
//              PkiOssEncode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <msasn1.h>
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  OSS Encode function. The encoded output is allocated and must be freed
//  by calling ossFreeBuf
//--------------------------------------------------------------------------
int
WINAPI
PkiOssEncode(
    IN OssGlobal *Pog,
    IN void *pvOssInfo,
    IN int id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    int iStatus;
    OssBuf ossBuf;

    ossBuf.length = 0;
    ossBuf.value = NULL;
    iStatus = ossEncode(Pog, id, pvOssInfo, &ossBuf);

    if (0 == iStatus) {
        *ppbEncoded = ossBuf.value;
        *pcbEncoded = ossBuf.length;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }

    return iStatus;
}


//+-------------------------------------------------------------------------
//  OSS Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
int
WINAPI
PkiOssEncode2(
    IN OssGlobal *Pog,
    IN void *pvOssInfo,
    IN int id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    int iStatus;
    OssBuf ossBuf;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        ossBuf.length = 0;
        ossBuf.value = NULL;
        iStatus = ossEncode(Pog, id, pvOssInfo, &ossBuf);

        if (0 == iStatus) {
            if (pbEncoded)
                iStatus = (int) ASN1_ERR_OVERFLOW;
            cbEncoded = ossBuf.length;
            if (ossBuf.value)
                ossFreeBuf(Pog, ossBuf.value);
        }
    } else {
        ossBuf.length = cbEncoded;
        ossBuf.value = pbEncoded;
        iStatus = ossEncode(Pog, id, pvOssInfo, &ossBuf);

        if (0 == iStatus)
            cbEncoded = ossBuf.length;
        else if (MORE_BUF == iStatus) {
            // Re-do as length only calculation
            iStatus = PkiOssEncode2(
                Pog,
                pvOssInfo,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (0 == iStatus)
                iStatus = (int) ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return iStatus;
}

//+-------------------------------------------------------------------------
//  OSS Decode function. The allocated, decoded structure, **pvOssInfo, must
//  be freed by calling ossFreePDU().
//--------------------------------------------------------------------------
int
WINAPI
PkiOssDecode(
    IN OssGlobal *Pog,
    OUT void **ppvOssInfo,
    IN int id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    int iStatus;
    OssBuf ossBuf;
    int pdunum = id;

    ossBuf.length = cbEncoded;
    ossBuf.value = (BYTE *) pbEncoded;
    *ppvOssInfo = NULL;
    iStatus = ossDecode(Pog, &pdunum, &ossBuf, ppvOssInfo);
    return iStatus;
}

//+-------------------------------------------------------------------------
//  OSS Decode function. The allocated, decoded structure, **pvOssInfo, must
//  be freed by calling ossFreePDU().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
int
WINAPI
PkiOssDecode2(
    IN OssGlobal *Pog,
    OUT void **ppvOssInfo,
    IN int id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    int iStatus;
    OssBuf ossBuf;
    int pdunum = id;

    ossBuf.length = *pcbEncoded;
    ossBuf.value = *ppbEncoded;
    *ppvOssInfo = NULL;
    iStatus = ossDecode(Pog, &pdunum, &ossBuf, ppvOssInfo);
    if (0 == iStatus) {
        *ppbEncoded = ossBuf.value;
        *pcbEncoded = ossBuf.length;
    } else if (MORE_INPUT == iStatus)
        iStatus = (int) ASN1_ERR_EOD;
    return iStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\ossutil\ossutil.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ossutil.cpp
//
//  Contents:   OSS ASN.1 compiler utility helper functions.
//
//  Functions:  OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilGetBitString
//              OssUtilSetBitStringWithoutTrailingZeroes
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfoEx
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    if (0 == cbIn)
        return;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)OssUtilAlloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = OssLength;
            pInfo->pbData = OssValue;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) OssLength;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, OssValue, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BYTE reversal::
//   - this only needs to be done for little endian processors
//
//  For OssUtilSetInteger, OssUtilFreeInteger must be called to free
//  the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppOssValue = OssUtilAllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pOssLength = 0;
            return FALSE;
        }
    } else
        *ppOssValue = NULL;
    *pOssLength = pInfo->cbData;
    return TRUE;
}

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        )
{
    // Only for BYTE reversal
    OssUtilFree(pOssValue);
}

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    OssUtilGetOctetString(OssLength, pOssValue, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        OssUtilReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by OSS before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//  OssUtilFreeHugeUINT has been #define'd to OssUtilFreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) OssUtilAlloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pOssLength = cb;
    *ppOssValue = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (OssLength > 1 && *pOssValue == 0) {
        pOssValue++;
        OssLength--;
    }
    OssUtilGetHugeInteger(
        OssLength,
        pOssValue,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        )
{
    if (pInfo->cbData) {
        *ppOssValue = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pOssBitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppOssValue = NULL;
        *pOssBitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (OssBitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = OssBitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pOssValue;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) OssBitLength / 8;
        cUnusedBits = OssBitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pOssValue, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        )
{
    DWORD cbData;
    DWORD cUnusedBits;

    cbData = pInfo->cbData;
    cUnusedBits = pInfo->cUnusedBits;
    assert(cUnusedBits <= 7);

    if (cbData) {
        BYTE *pb;

        // Until we find a nonzero byte (starting with the last byte),
        // decrement cbData. For the last byte don't look at any unused bits.
        pb = pInfo->pbData + cbData - 1;
        if (0 == (*pb & rgbUnusedAndMask[cUnusedBits])) {
            cUnusedBits = 0;
            cbData--;
            pb--;

            for ( ; 0 < cbData && 0 == *pb; cbData--, pb--)
                ;
        }
    }

    if (cbData) {
        BYTE b;

        // Determine the number of unused bits in the last byte. Treat any
        // trailing zeroes as unused.
        b = *(pInfo->pbData + cbData - 1);
        assert(b);
        if (cUnusedBits)
            b = b >> cUnusedBits;
        
        for (; 7 > cUnusedBits && 0 == (b & 0x01); cUnusedBits++) {
            b = b >> 1;
        }
        assert(b & 0x01);
        assert(cUnusedBits <= 7);

        *ppOssValue = pInfo->pbData;
        *pOssBitLength = cbData * 8 - cUnusedBits;
    } else {
        *ppOssValue = NULL;
        *pOssBitLength = 0;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) OssLength;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pOssValue, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pOssLength = 0;
        *ppOssValue = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pOssLength = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) OssUtilAlloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppOssValue = psz;
    *pOssLength = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pOssLength = 0;
InvalidIA5:
    *ppOssValue = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        )
{
    OssUtilFree(pOssValue);
}

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pOssValue,
        OssLength,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pOssValue, OssLength,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) OssLength * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pOssValue, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    pOss->encoded = pInfo->pbData;
    pOss->length = pInfo->cbData;
}

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pOss->length;
            pInfo->pbData = (BYTE *) pOss->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pOss->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pOss->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}


//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cbEncoded;
    OssBuf OssEncoded;
    int OssStatus;
    unsigned char *value;

    if (NULL == pvEncoded || (dwFlags & CRYPT_ENCODE_ALLOC_FLAG))
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    OssEncoded.length = cbEncoded;
    if (cbEncoded == 0)
        value = NULL;
    else
        value = (unsigned char *) pvEncoded;
    OssEncoded.value = value;

    ossSetEncodingRules(Pog, OSS_DER);
    OssStatus = ossEncode(
        Pog,
        pdunum,
        pvOssInfo,
        &OssEncoded);
    cbEncoded = OssEncoded.length;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        PFN_CRYPT_ALLOC pfnAlloc;
        BYTE *pbEncoded;

        if (0 != OssStatus || 0 == cbEncoded) {
            ossFreeBuf(Pog, OssEncoded.value);
            *((void **) pvEncoded) = NULL;
            goto OssError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            ossFreeBuf(Pog, OssEncoded.value);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbEncoded, OssEncoded.value, cbEncoded);
        *((BYTE **) pvEncoded) = pbEncoded;
        ossFreeBuf(Pog, OssEncoded.value);
        goto SuccessReturn;
    } else if (value == NULL && OssEncoded.value) {
        // Length only calculation with a throw away allocation
        ossFreeBuf(Pog, OssEncoded.value);
        if (pvEncoded && 0 == OssStatus) {
            // Upon entry *pcbEncoded == 0
            goto LengthError;
        }
    }

    if (0 != OssStatus) {
        // For MORE_BUF:: redo as a length only calculation
        if (OssStatus == MORE_BUF && pvEncoded &&
                OssUtilEncodeInfoEx(
                Pog,
                pdunum,
                pvOssInfo,
                0,                  // dwFlags
                NULL,               // pEncodePara
                NULL,               // pbEncoded
                &cbEncoded))
            goto LengthError;
        else {
            cbEncoded = 0;
            goto OssError;
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(OssError, CRYPT_E_OSS_ERROR + OssStatus)
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        Pog,
        pdunum,
        pvOssInfo,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        )
{
    BOOL fResult;
    OssBuf OssEncoded;
    int OssStatus;

    OssEncoded.length = cbEncoded;
    OssEncoded.value = (unsigned char *) pbEncoded;

    ossSetEncodingRules(Pog, OSS_BER);
    *ppvOssInfo = NULL;
    if (0 != (OssStatus = ossDecode(
                Pog,
                &pdunum,
                &OssEncoded,
                ppvOssInfo)))
        goto OssError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvOssInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(OssError, CRYPT_E_OSS_ERROR + OssStatus)
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        )
{
    if (pvOssInfo) {
        ossFreePDU(Pog, pdunum, pvOssInfo);
    }
}

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvOssInfo,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvOssInfo,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvOssInfo = NULL;

    if (!OssUtilDecodeAndAllocInfo(
            Pog,
            pdunum,
            pbEncoded,
            cbEncoded,
            &pvOssInfo
            )) goto OssDecodeError;

    fResult = OssUtilAllocStructInfoEx(
        pvOssInfo,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    OssUtilFreeInfo(Pog, pdunum, pvOssInfo);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OssDecodeError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkifmt\hex.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        hex.cpp
//
// Contents:    hex encode/decode implementation
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <stdio.h>

#include <dbgdef.h>
#include "pkifmt.h"

#include <tchar.h>	// must be included after dbgdef.h


__inline BOOL
_IsWhiteSpaceChar(
    TCHAR ch)
{
    return(
	TEXT(' ') == ch ||
	TEXT('\t') == ch ||
	TEXT('\r') == ch);
}


DWORD
_DigToHex(
    IN TCHAR ch,
    OUT BYTE *pb)
{
    BYTE b;
    DWORD dwErr = ERROR_SUCCESS;

    if (!_istxdigit(ch))
    {
        dwErr = ERROR_INVALID_DATA;
#if DBG
	DbgPrintf(DBG_SS_TRACE, "bad hex data: %02x\n", ch);
#endif //DBG
        goto BadHexDataError;
    }
    if (_istdigit(ch))
    {
	b = ch - TEXT('0');
    }
    else
    if (_istupper(ch))
    {
	b = ch - TEXT('A') + 10;
    }
    else
    {
	b = ch - TEXT('a') + 10;
    }
    *pb = b;

ErrorReturn:
    return (dwErr);

SET_ERROR(BadHexDataError, dwErr)
}


__inline BOOL
_IsSkipChar(
    TCHAR ch)
{
    return(
	TEXT(' ') == ch ||
	TEXT('\t') == ch ||
	TEXT('\r') == ch ||
	TEXT('\n') == ch ||
	TEXT(',') == ch ||
	TEXT('-') == ch);
}


DWORD
_HexDecodeSimple(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    DWORD dwErr;
    TCHAR const *pch = pchIn;
    TCHAR const *pchEnd;
    DWORD cb = 0;
    BOOL fOverFlow = FALSE;

    pchEnd = &pchIn[cchIn];
    while (pch < pchEnd)
    {
	BYTE blo;
	BYTE bhi;

	if (_IsSkipChar(*pch))
	{
	    pch++;
	    continue;
	}

	dwErr = _DigToHex(*pch, &bhi);
        if (ERROR_SUCCESS != dwErr)
        {
            goto _DigToHexError;
        }

	pch++;
	if (pch >= pchEnd)
	{
	    dwErr = ERROR_INVALID_DATA;
	    goto BadHexDataError;
	}
	dwErr = _DigToHex(*pch, &blo);
        if (ERROR_SUCCESS != dwErr)
        {
            goto _DigToHexError;
        }

	pch++;
	if (NULL != pbOut)
	{
	    if (cb >= *pcbOut)
	    {
		fOverFlow = TRUE;
		pbOut = NULL;
	    }
	    else
	    {
		*pbOut++ = blo | (bhi << 4);
	    }
	}
	cb++;
    }
    *pcbOut = cb;

    if (fOverFlow)
    {
        dwErr = ERROR_MORE_DATA;
	goto MoreDataError;
    }

ErrorReturn:
    return (dwErr);

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(BadHexDataError, dwErr)
TRACE_ERROR(_DigToHexError)
}


DWORD
_HexParse(
    IN OUT TCHAR const **ppch,
    IN TCHAR const *pchEnd,
    IN DWORD cDigitMin,
    IN DWORD cDigitMax,
    OUT DWORD *pdwValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR const *pch = *ppch;
    DWORD Value = 0;
    DWORD cDigit = 0;
    BYTE b;

    *pdwValue = 0;

    while (pch < pchEnd && cDigit <= cDigitMax)
    {
	//printf("HexParse %u/%u-%u, ch=%02x\n", cDigit, cDigitMin, cDigitMax, *pch);
	dwErr = _DigToHex(*pch, &b);
	if (ERROR_SUCCESS != dwErr)
	{
	    break;
	}
	Value = b | (Value << 4);
	pch++;
	cDigit++;

    }
    //printf("HexParse %u/%u-%u, val=%x\n", cDigit, cDigitMin, cDigitMax, Value);
    if (cDigit < cDigitMin || cDigit > cDigitMax)
    {
        dwErr = ERROR_INVALID_DATA;
	goto BadHexDataError;
    }
    *pdwValue = Value;
    *ppch = pch;
    dwErr = ERROR_SUCCESS;

ErrorReturn:
    return (dwErr);

SET_ERROR(BadHexDataError, dwErr)
}


#define HS_ADDRESS	0
#define HS_HEXDATA	1
#define HS_ASCIIDATA	2
#define HS_NEWLINE	3

DWORD
_HexDecodeComplex(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    TCHAR const *pch = pchIn;
    TCHAR const *pchEnd;
    DWORD cb = 0;
    DWORD dwErr;
    DWORD LastAddress = 0;
    DWORD Address;
    DWORD i;
    BOOL fOverFlow = FALSE;
    BOOL fPartialLastLine = FALSE;
    int *pStateBase;
    int *pState;

    int s_aASCIIADDRState[] = { HS_ADDRESS, HS_HEXDATA, HS_ASCIIDATA, HS_NEWLINE };
    int s_aASCIIState[] = { HS_HEXDATA, HS_ASCIIDATA, HS_NEWLINE };
    int s_aADDRState[] = { HS_ADDRESS, HS_HEXDATA, HS_NEWLINE };


    switch (Flags)
    {
    	case CRYPT_STRING_HEXASCII:		// 5
	    pStateBase = s_aASCIIState;
	    break;

    	case CRYPT_STRING_HEXADDR:		// 0xa
	    pStateBase = s_aADDRState;
	    break;

	case CRYPT_STRING_HEXASCIIADDR:		// 0xb
	    pStateBase = s_aASCIIADDRState;
	    break;

	default:
	    dwErr = ERROR_INVALID_DATA; //hr = E_INVALIDARG;
	    goto FlagsError;
    }
    pState = pStateBase;

    pchEnd = &pchIn[cchIn];
    while (pch < pchEnd)
    {
	//printf("f=%x: *pState: %u  ch=%02x\n", Flags, *pState, *pch);
	switch (*pState++)
	{
	    case HS_ADDRESS:
		// decode 4 to 8 digit address:

		while (pch < pchEnd && _IsWhiteSpaceChar(*pch))
		{
		    pch++;
		}
		if (pch >= pchEnd)
		{
		    continue;	// Done: no more data
		}
		dwErr = _HexParse(&pch, pchEnd, 4, 8, &Address);
                if (ERROR_SUCCESS != dwErr)
                {
		    goto _HexParseError;
                }

		//printf("f=%x: Address: %x\n", Flags, Address);
		if (!fPartialLastLine &&
		    0 != LastAddress &&
		    LastAddress + 16 != Address)
		{
		    dwErr = ERROR_INVALID_DATA;
		    goto BadHexDataError;
		}
		LastAddress = Address;
		break;

	    case HS_HEXDATA:
		// decode up to 16 bytes of hex data
		for (i = 0; i < 16; i++)
		{
		    DWORD Data;

		    // decode 2 digit byte value:

		    while (pch < pchEnd && _IsSkipChar(*pch))
		    {
			pch++;
		    }
		    if (pch >= pchEnd)
		    {
			break;	// Done: no more data
		    }
		    if (fPartialLastLine)
		    {
			//printf("f=%x: fPartialLastLine extra data: %02x\n", Flags, *pch);
			dwErr = ERROR_INVALID_DATA;
			goto DataAfterEndError;
		    }
		    dwErr = _HexParse(&pch, pchEnd, 2, 2, &Data);
		    if (ERROR_SUCCESS != dwErr)
		    {
			// Must be a partial last line.  The only additional
			// data should be an optional partial ascii display on
			// the right, a newline, and possibly one more address
			// line.

			//printf("f=%x: fPartialLastLine = TRUE: %02x\n", Flags, *pch);
			fPartialLastLine = TRUE;
			break;
		    }

		    //printf("f=%x: Data[%u]: %02x\n", Flags, i, Data);
		    if (NULL != pbOut)
		    {
			if (cb >= *pcbOut)
			{
			    fOverFlow = TRUE;
			    pbOut = NULL;
			}
			else
			{
			    *pbOut++ = (BYTE) Data;
			}
		    }
		    cb++;
		}
		break;

	    case HS_ASCIIDATA:
		// skip up to 16 non-whitespace characters

		while (pch < pchEnd && _IsWhiteSpaceChar(*pch))
		{
		    pch++;
		}
		for (i = 0; i < 16; i++)
		{
		    if (pch >= pchEnd || TEXT(' ') > *pch || TEXT('~') < *pch)
		    {
			break;
		    }
		    //printf("f=%x: Ascii[%u]: %c\n", Flags, i, *pch);
		    pch++;
		}
		break;

	    case HS_NEWLINE:
		// skip whitespace characters and a newline

		while (pch < pchEnd && _IsWhiteSpaceChar(*pch))
		{
		    //printf("f=%x: NL skip: %02x\n", Flags, *pch);
		    pch++;
		}
		//printf("f=%x: NL: %02x\n", Flags, *pch);
		if (pch >= pchEnd)
		{
		    continue;	// Done: no more data
		}
		if (TEXT('\n') != *pch)
		{
		    //printf("f=%x: Extra Data: %02x\n", Flags, *pch);
		    dwErr = ERROR_INVALID_DATA;
		    goto ExtraDataOnLineError;
		}
		//printf("f=%x: NewLine\n", Flags);
		pch++;
		pState = pStateBase;
		break;

	    default:
		assert(!"Bad *pState");
	}
    }
    *pcbOut = cb;
    if (fOverFlow)
    {
	dwErr = ERROR_MORE_DATA;
	goto MoreDataError;
    }

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return(dwErr);

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(ExtraDataOnLineError, dwErr)
SET_ERROR(BadHexDataError, dwErr)
TRACE_ERROR(_HexParseError)
SET_ERROR(DataAfterEndError, dwErr)
SET_ERROR(FlagsError, dwErr)
}


DWORD
HexDecode(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    DWORD dwErr;

    if (CRYPT_STRING_HEX == Flags)
    {
	dwErr = _HexDecodeSimple(pchIn, cchIn, pbOut, pcbOut);
        if (ERROR_SUCCESS != dwErr)
        {
#if DBG
            //skip ERROR_INVALID_DATA dbg print
            if (ERROR_INVALID_DATA == dwErr)
            {
                SetLastError(dwErr);
                goto ErrorReturn;
            }
#endif
            goto _HexDecodeSimpleError;
        }
    }
    else
    {
	dwErr = _HexDecodeComplex(pchIn, cchIn, Flags, pbOut, pcbOut);
        if (ERROR_SUCCESS != dwErr)
        {
#if DBG
            //skip ERROR_INVALID_DATA dbg print
            if (ERROR_INVALID_DATA == dwErr)
            {
                SetLastError(dwErr);
                goto ErrorReturn;
            }
#endif
            goto _HexDecodeComplexError;
        }
    }

ErrorReturn:
    return(dwErr);

TRACE_ERROR(_HexDecodeSimpleError)
TRACE_ERROR(_HexDecodeComplexError)
}

TCHAR
_IsPrintableChar(TCHAR ch)
{
    if (ch < TEXT(' ') || ch > TEXT('~'))
    {
        ch = TEXT('.');
    }
    return(ch);
}


// Encode a BYTE array into text as a hex dump.
// Use CR-LF pairs for line breaks, unless CRYPT_STRING_NOCR is set.
// Do not '\0' terminate the text string -- that's handled by the caller.

DWORD
HexEncode(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT TCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    TCHAR const *pszsep;
    TCHAR const *psznl;
    DWORD r;
    DWORD i;
    DWORD cbremain;
    DWORD cchOut = 0;
    DWORD cch;
    TCHAR *pch = pchOut;
    DWORD dwErr = ERROR_MORE_DATA;
    BOOL fAscii = FALSE;
    BOOL fAddress = FALSE;
    TCHAR szAddress[32];
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & Flags);

    switch (~CRYPT_STRING_NOCR & Flags)
    {
	case CRYPT_STRING_HEX:
	    break;

	case CRYPT_STRING_HEXASCII:
	    fAscii = TRUE;
	    break;

	case CRYPT_STRING_HEXADDR:
	    fAddress = TRUE;
	    break;

	case CRYPT_STRING_HEXASCIIADDR:
	    fAscii = TRUE;
	    fAddress = TRUE;
	    break;

	default:
	    dwErr = ERROR_INVALID_DATA; //hr = E_INVALIDARG;
	    goto FlagsError;
    }
    for (r = 0; r < cbIn; r += 16)
    {
	DWORD iEnd;

        cbremain = cbIn - r;
	iEnd = min(cbremain, 16);

        for (i = 0; i < iEnd; i++)
        {
            psznl = TEXT("");
	    szAddress[0] = TEXT('\0');
            pszsep = TEXT(" ");
            if ((i % 8) == 0)           // 0 or 8
            {
                pszsep = TEXT("  ");
                if (i == 0)             // 0
                {
		    if (fAddress)
		    {
			_stprintf(szAddress, TEXT("%04x"), r);
		    }
                    pszsep = TEXT("\t");
                    if (r != 0)         // starting new line
                    {
			psznl = fNoCR? TEXT("\n") : TEXT("\r\n");
                        pszsep = TEXT("\t");
                    }
                }
            }
	    cch = _tcslen(psznl) + _tcslen(szAddress) + _tcslen(pszsep) + 2;
	    if (NULL != pchOut)
	    {
		if (cchOut + cch + 1 > *pcchOut)
		{
		    goto MoreDataError;
		}
		_stprintf(
			pch,
			TEXT("%s%s%s%02x"),
			psznl,
			szAddress,
			pszsep,
			pbIn[r + i]);
		pch += cch;
		assert(TEXT('\0') == *pch);
		assert(pch == &pchOut[cchOut + cch]);
	    }
	    cchOut += cch;
        }
        if (fAscii && 0 != i)
        {
	    cch = 3 + (16 - i)*3 + ((i <= 8)? 1 : 0);

	    if (NULL != pchOut)
	    {
		if (cchOut + cch + iEnd + 1 > *pcchOut)
		{
		    goto MoreDataError;
		}
		_stprintf(pch, TEXT("%*s"), cch, TEXT(""));
		pch += cch;
		assert(TEXT('\0') == *pch);
		assert(pch == &pchOut[cchOut + cch]);

		for (i = 0; i < iEnd; i++)
		{
		    *pch++ = _IsPrintableChar(pbIn[r + i]);
		    assert(pch == &pchOut[cchOut + cch + i + 1]);
		}
            }
	    cchOut += cch + iEnd;
        }
    }
    if (r != 0)
    {
	DWORD cchnl = fNoCR? 1 : 2;
	
	if (NULL != pchOut)
	{
	    if (cchOut + cchnl > *pcchOut)
	    {
		goto MoreDataError;
	    }
	    if (!fNoCR)
	    {
		*pch++ = TEXT('\r');
	    }
	    *pch++ = TEXT('\n');
	    assert(pch == &pchOut[cchOut + cchnl]);
	}
	cchOut += cchnl;
    }
    *pcchOut = cchOut;

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return(dwErr);

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(FlagsError, dwErr)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkifmt\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <dbgdef.h>
#include "pkifmt.h"

//#define BASE64_STRICT		// enforce syntax check on input data
#undef BASE64_STRICT		// enforce syntax check on input data


// The following table translates an ascii subset to 6 bit values as follows
// (see RFC 1421 and/or RFC 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte		"xx=="
//     2 bytes		"xxx="
//     3 bytes		"xxxx"

#define CB_BASE64LINEMAX	64	// others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";

#define MOD4(x) ((x) & 3)

__inline BOOL
_IsBase64WhiteSpace(
    IN TCHAR const ch)
{
    return(
	ch == TEXT(' ') ||
	ch == TEXT('\t') ||
	ch == TEXT('\r') ||
	ch == TEXT('\n'));
}


DWORD
Base64DecodeA(
    IN TCHAR const     *pchIn,
    IN DWORD           cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD      *pcbOut)
{
    DWORD dwErr;
    DWORD cchInDecode, cbOutDecode;
    TCHAR const *pchInEnd;
    TCHAR const *pchInT;
    BYTE *pbOutT;

    // Count the translatable characters, skipping whitespace & CR-LF chars.

    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    dwErr = ERROR_INVALID_DATA;
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
	if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
	{
	    // Found a non-base64 character.  Decide what to do.

	    DWORD cch;

	    if (_IsBase64WhiteSpace(*pchInT))
	    {
		continue;		// skip all whitespace
	    }

	    // The length calculation may stop in the middle of the last
	    // translation quantum, because the equal sign padding characters
	    // are treated as invalid input.  If the last translation quantum
	    // is not 4 bytes long, there must be 3, 2 or 1 equal sign(s).

	    if (0 != cchInDecode)
	    {
		cch = MOD4(cchInDecode);
		if (0 != cch)
		{
		    cch = 4 - cch;
		    while (0 != cch && pchInT < pchInEnd && '=' == *pchInT)
		    {
			pchInT++;
			cch--;
		    }
		}
//#ifdef BASE64_STRICT
		if (0 == cch)
//#endif
		{
		    break;
		}
	    }
#if DBG
            DbgPrintf(
                DBG_SS_TRACE,
                "Bad base64 data: \"%.*" szFMTTSTR "...\"\n",
                min(16, SAFE_SUBTRACT_POINTERS(pchInEnd, pchInT)),
                pchInT);
#endif //DBG
	    goto BadBase64Data;
	}
	cchInDecode++;			// only count valid base64 chars
    }
    assert(pchInT <= pchInEnd);
#ifdef BASE64_STRICT
    if (pchInT < pchInEnd)
    {
	TCHAR const *pch;
	DWORD cchEqual = 0;

	for (pch = pchInT; pch < pchInEnd; pch++)
	{
	    if (!_IsBase64WhiteSpace(*pch))
	    {
		// Allow up to 3 extra trailing equal signs.
		if (TEXT('=') == *pch && 3 > cchEqual)
		{
		    cchEqual++;
		    continue;
		}
#if DBG
		DbgPrintf(DBG_SS_TRACE,
		    "Bad trailing base64 data: \"%.*" szFMTTSTR "...\"\n",
		    min(16, SAFE_SUBTRACT_POINTERS(pchInEnd, pch)),
		    pch);
#endif //DBG
		goto BadTrailingBase64Data;
	    }
	}
#if DBG
	if (0 != cchEqual)
	{
	    DbgPrintf(DBG_SS_TRACE,
		"Ignored trailing base64 data: \"%.*" szFMTTSTR "\"\n",
		cchEqual,
		TEXT("==="));
	}
#endif //DBG
    }
#endif
    pchInEnd = pchInT;		// don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.  Compensate for a fractional translation quantum.

    cbOutDecode = ((cchInDecode + 3) >> 2) * 3;
    switch (cchInDecode % 4)
    {
	case 1:
	case 2:
	    cbOutDecode -= 2;
	    break;

	case 3:
	    cbOutDecode--;
	    break;
    }

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
	pbOutT += cbOutDecode;
    }
    else
    {
	// Decode one quantum at a time: 4 bytes ==> 3 bytes

	//assert(cbOutDecode <= *pcbOut);
        if (cbOutDecode > *pcbOut)
        {
            *pcbOut = cbOutDecode;
            dwErr = ERROR_MORE_DATA;
            goto MoreDataError;
        }

	pchInT = pchIn;
	while (cchInDecode > 0)
	{
	    DWORD i;
	    BYTE ab4[4];

	    ZeroMemory(ab4, sizeof(ab4));
	    for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
	    {
		while (
		    sizeof(abDecode) > (unsigned) *pchInT &&
		    63 < abDecode[*pchInT])
		{
		    pchInT++;
		}
		assert(pchInT < pchInEnd);
		ab4[i] = (BYTE) *pchInT++;
	    }

	    // Translate 4 input characters into 6 bits each, and deposit the
	    // resulting 24 bits into 3 output bytes by shifting as appropriate.

	    // out[0] = in[0]:in[1] 6:2
	    // out[1] = in[1]:in[2] 4:4
	    // out[2] = in[2]:in[3] 2:6

	    *pbOutT++ =
		(BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

	    if (i > 2)
	    {
		*pbOutT++ =
		  (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
	    }
	    if (i > 3)
	    {
		*pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
	    }
	    cchInDecode -= i;
	}
	assert((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = SAFE_SUBTRACT_POINTERS(pbOutT, pbOut);

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return dwErr;

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(BadBase64Data, dwErr)
#ifdef BASE64_STRICT
SET_ERROR(BadTrailingBase64Data, dwErr)
#endif
}


// Encode a BYTE array into a Base64 text string.
// Use CR-LF pairs for line breaks, unless CRYPT_STRING_NOCR is set.
// Do not '\0' terminate the text string -- that's handled by the caller.
// Do not add -----BEGIN/END headers -- that's also handled by the caller.

DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT TCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    DWORD dwErr;
    TCHAR *pchOutT;
    DWORD cchOutEncode;
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & Flags);

    // Allocate enough memory for full final translation quantum.

    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.

    cchOutEncode +=
	(fNoCR? 1 : 2) *
	((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
	pchOutT += cchOutEncode;
	//printf("cchOut:       =%x Computed=%x\n", (DWORD) (pchOutT - pchOut), cchOutEncode);
    }
    else
    {
	DWORD cCol;

	if (cchOutEncode > *pcchOut)
	{
            *pcchOut = cchOutEncode;
	    dwErr = ERROR_MORE_DATA;
	    goto MoreDataError;
	}

	cCol = 0;
	while ((long) cbIn > 0)	// signed comparison -- cbIn can wrap
	{
	    BYTE ab3[3];

	    if (cCol == CB_BASE64LINEMAX/4)
	    {
		cCol = 0;
		if (!fNoCR)
		{
		    *pchOutT++ = '\r';
		}
		*pchOutT++ = '\n';
	    }
	    cCol++;
	    ZeroMemory(ab3, sizeof(ab3));

	    ab3[0] = *pbIn++;
	    if (cbIn > 1)
	    {
		ab3[1] = *pbIn++;
		if (cbIn > 2)
		{
		    ab3[2] = *pbIn++;
		}
	    }

	    *pchOutT++ = abEncode[ab3[0] >> 2];
	    *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
	    *pchOutT++ = (cbIn > 1)?
			abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
	    *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

	    cbIn -= 3;
	}

	// Append CR-LF only if there was input data

	if (pchOutT != pchOut)
	{
	    if (!fNoCR)
	    {
		*pchOutT++ = '\r';
	    }
	    *pchOutT++ = '\n';
	}
	//printf("cchOut: Actual=%x Computed=%x Buffer=%x\n", (DWORD) (pchOutT - pchOut), cchOutEncode, *pcchOut);
	assert((DWORD) (pchOutT - pchOut) == cchOutEncode);
    }
    *pcchOut = SAFE_SUBTRACT_POINTERS(pchOutT, pchOut);

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return dwErr;

SET_ERROR(MoreDataError, dwErr)
}


DWORD
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT WCHAR *wszOut,
    OUT DWORD *pcchOut)
{

    DWORD   cchOut;
    CHAR   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    assert(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if (wszOut == NULL)
    {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(pbIn, cbIn, Flags, NULL, pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        pch = (CHAR *) malloc(cchOut);
        if (NULL != pch)
	{
            err = Base64EncodeA(pbIn, cbIn, Flags, pch, &cchOut);
	    if (ERROR_SUCCESS == err)
	    {
		// should not fail!
		cch = MultiByteToWideChar(0, 0, pch, cchOut, wszOut, *pcchOut);

		// check to make sure we did not fail
		assert(*pcchOut == 0 || cch != 0);
	    }
	}
    }

    if(pch != NULL)
        free(pch);

    return(err);
}


DWORD
Base64DecodeW(
    IN const WCHAR * wszIn,
    IN DWORD cch,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut)
{
    CHAR *pch;
    DWORD err = ERROR_SUCCESS;

    // in all cases we need to convert to an ascii string
    // we know the ascii string is less

    if ((pch = (CHAR *) malloc(cch)) == NULL)
    {
        err = ERROR_OUTOFMEMORY;
    }

    // we know no base64 wide char map to more than 1 ascii char
    else if (WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, NULL, NULL) == 0)
    {
        err = ERROR_NO_DATA;
    }

    // get the length of the buffer
    else if (pbOut == NULL)
    {
        *pcbOut = 0;
        err = Base64Decode(pch, cch, NULL, pcbOut);
    }

    // otherwise fill in the buffer
    else {
        err = Base64Decode(pch, cch, pbOut, pcbOut);
    }

    if(pch != NULL)
        free(pch);

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkifmt\pkifmt.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pkifmt.cpp
//
// Contents:    data format conversion
//
// History:     25-Jul-96       vich created
//              2/2000       xtan moved from certsrv to pki
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <wincrypt.h>

#include <dbgdef.h>
#include "pkifmt.h"


#if DBG
# ifdef UNICODE
#  define _DecodeCertSub	_DecodeCertSubW
# else
#  define _DecodeCertSub	_DecodeCertSubA
# endif
#endif //DBG


DWORD
_DecodeCertSub(
    IN TCHAR const *pchIn,
    IN DWORD        cchIn,
    IN DWORD        Flags,
    IN OUT BYTE    *pbOut,
    IN OUT DWORD   *pcbOut,
    OUT OPTIONAL DWORD *pdwSkip)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbOut = 0;

    if (NULL != pbOut)
    {
        cbOut = *pcbOut;
    }

	switch (Flags)
	{
	    case CRYPT_STRING_BASE64HEADER:
	    case CRYPT_STRING_BASE64REQUESTHEADER:
	    case CRYPT_STRING_BASE64X509CRLHEADER:
	    {
		TCHAR const *pchInEnd;
		DWORD cchHeader;
		DWORD cchSkip;

		pchInEnd = &pchIn[cchIn];

		// Skip to the starting '-----....' then skip that line.

		dwErr = ERROR_INVALID_DATA;
		cchHeader = SizeBase64Header(pchIn, cchIn, TRUE, &cchSkip);
		if (MAXDWORD == cchHeader)
		{
		    goto SizeBase64HeaderStartError;
		}
                if (NULL != pdwSkip)
                {
                    *pdwSkip = cchHeader; //for return
                }
		pchIn += cchHeader + cchSkip;
		cchHeader = SizeBase64Header(
					pchIn,
					SAFE_SUBTRACT_POINTERS(pchInEnd, pchIn),
					FALSE,
					&cchSkip);
		if (MAXDWORD == cchHeader)
		{
		    goto SizeBase64HeaderEndError;
		}
		cchIn = cchHeader;
		Flags = CRYPT_STRING_BASE64;	// headers have been removed...
		// FALLTHROUGH
	    }

	    case CRYPT_STRING_BASE64:
		dwErr = Base64Decode(pchIn, cchIn, pbOut, &cbOut);
                if (ERROR_SUCCESS != dwErr)
                {
#if DBG
                    if (ERROR_INVALID_DATA != dwErr)
                    {
                        DbgPrintf(DBG_SS_TRACE,
                                  "Base64Decode err = 0x%x\n", dwErr);
                    }
#endif //DBG
                    goto Base64DecodeError;
                }
		break;

	    case CRYPT_STRING_HEX:
	    case CRYPT_STRING_HEXASCII:
	    case CRYPT_STRING_HEXADDR:
	    case CRYPT_STRING_HEXASCIIADDR:
		dwErr = HexDecode(pchIn, cchIn, Flags, pbOut, &cbOut);
                if (ERROR_SUCCESS != dwErr)
                {
#if DBG
                    if (ERROR_INVALID_DATA != dwErr)
                    {
                        DbgPrintf(DBG_SS_TRACE,
                                  "HexDecode err = 0x%x\n", dwErr);
                    }
#endif //DBG
                    goto HexDecodeError;
                }
		break;

	    case CRYPT_STRING_BINARY:
		if (NULL != pbOut)
		{
		    //assert(sizeof(TCHAR) * cchIn == cbOut);
                    if (*pcbOut < cbOut)
                    {
                        *pcbOut = cbOut;
                        dwErr = ERROR_MORE_DATA;
                        goto MoreDataError;
                    }
		    CopyMemory(pbOut, (BYTE *) pchIn, cbOut);
		}
		else
		{
		    cbOut = sizeof(TCHAR) * cchIn;
		}
		break;

	    default:
		dwErr = ERROR_INVALID_DATA;  //hr = E_INVALIDARG
		break;
	}
    *pcbOut = cbOut;

ErrorReturn:
    return (dwErr);

SET_ERROR(MoreDataError, dwErr)
SET_ERROR(SizeBase64HeaderEndError, dwErr)
SET_ERROR(SizeBase64HeaderStartError, dwErr)
TRACE_ERROR(HexDecodeError)
TRACE_ERROR(Base64DecodeError)
}

BOOL
WINAPI
CryptStringToBinaryA(
    IN     LPCSTR   pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN OUT BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    IN OUT DWORD    *pdwSkip,    //OPTIONAL
    IN OUT DWORD    *pdwFlags)   //OPTIONAL
{
    DWORD   dwErr;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    DWORD const *pFlags;
    DWORD const *pFlagsEnd;

    static DWORD s_aDecodeFlags[] = {
	CRYPT_STRING_BASE64HEADER,
	CRYPT_STRING_BASE64,
	CRYPT_STRING_BINARY		// must be last
    };

    static DWORD s_aHexDecodeFlags[] = {
	CRYPT_STRING_HEXADDR,
	CRYPT_STRING_HEXASCIIADDR,
	CRYPT_STRING_HEX,
	CRYPT_STRING_HEXASCII,
    };

    if (NULL == pszString)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto InvalidDataError;
    }

    if (0 == cchString)
    {
        // assume null terminated string
        cchString = strlen(pszString) + 1; //include null terminator
    }

    //init
    if (NULL != pdwSkip)
    {
        *pdwSkip = 0;
    }
    if (NULL != pdwFlags)
    {
        *pdwFlags = 0;
    }
    if (NULL == pbBinary)
    {
        *pcbBinary = 0;
    }

    pFlags = &dwFlags;
    pFlagsEnd = &pFlags[1];
    if (CRYPT_STRING_BASE64_ANY == dwFlags || CRYPT_STRING_ANY == dwFlags)
    {
	pFlags = s_aDecodeFlags;
	pFlagsEnd = &pFlags[sizeof(s_aDecodeFlags)/sizeof(s_aDecodeFlags[0])];
	if (CRYPT_STRING_BASE64_ANY == dwFlags)
	{
	    pFlagsEnd--;	// Disallow CRYPT_STRING_BINARY
	}
    }
    if (CRYPT_STRING_HEX_ANY == dwFlags)
    {
	pFlags = s_aHexDecodeFlags;
	pFlagsEnd = &pFlags[sizeof(s_aHexDecodeFlags)/sizeof(s_aHexDecodeFlags[0])];
    }

    for ( ; pFlags < pFlagsEnd; pFlags++)
    {
        cbOut = *pcbBinary;
	dwErr = _DecodeCertSub(
                        pszString,
                        cchString,
                        *pFlags,
                        pbBinary,
                        &cbOut,
                        pdwSkip);
	if (ERROR_SUCCESS == dwErr)
	{
            //for return
            *pcbBinary = cbOut;
            if (NULL != pdwFlags)
            {
                *pdwFlags = *pFlags;
            }
	    break;
	}
#if DBG
        if (ERROR_INVALID_DATA != dwErr)
        {
            DbgPrintf(DBG_SS_TRACE, "_DecodeCertSub err = 0x%x\n", dwErr);
        }
#endif //DBG
    }

    if (ERROR_SUCCESS != dwErr)
    {
        goto DecodeCertSubError;
    }

ErrorReturn:
    return (ERROR_SUCCESS == dwErr);

SET_ERROR(DecodeCertSubError, dwErr)
SET_ERROR(InvalidDataError, dwErr)
}

DWORD
BinaryEncode(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT TCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    DWORD dwErr;

    //get size any way
    *pcchOut = cbIn;

    if (NULL != pchOut)
    {
        if (*pcchOut < cbIn)
        {
	    dwErr = ERROR_MORE_DATA;
            goto MoreDataError;
        }
        CopyMemory(pchOut, pbIn, cbIn);
    }

    dwErr = ERROR_SUCCESS;
ErrorReturn:
    return dwErr;

SET_ERROR(MoreDataError, dwErr)
}

static TCHAR const szBeginCert[] = TEXT("-----BEGIN CERTIFICATE-----");
static TCHAR const szEndCert[] = TEXT("-----END CERTIFICATE-----");

#define CB_BEGINCERT	(sizeof(szBeginCert) - sizeof(TCHAR))
#define CB_ENDCERT	(sizeof(szEndCert) - sizeof(TCHAR))

static TCHAR const szBeginCertRequest[] = TEXT("-----BEGIN NEW CERTIFICATE REQUEST-----");
static TCHAR const szEndCertRequest[] = TEXT("-----END NEW CERTIFICATE REQUEST-----");

#define CB_BEGINCERTREQUEST	(sizeof(szBeginCertRequest) - sizeof(TCHAR))
#define CB_ENDCERTREQUEST	(sizeof(szEndCertRequest) - sizeof(TCHAR))

static TCHAR const szBeginCRL[] = TEXT("-----BEGIN X509 CRL-----");
static TCHAR const szEndCRL[] = TEXT("-----END X509 CRL-----");

#define CB_BEGINCRL	(sizeof(szBeginCRL) - sizeof(TCHAR))
#define CB_ENDCRL	(sizeof(szEndCRL) - sizeof(TCHAR))

typedef struct _CERTHEADER
{
    TCHAR const *pszBegin;
    DWORD        cbBegin;
    TCHAR const *pszEnd;
    DWORD        cbEnd;
} CERTHEADER;

static CERTHEADER const CertHeaderCert =
{
    szBeginCert,
    CB_BEGINCERT,
    szEndCert,
    CB_ENDCERT
};

static CERTHEADER const CertHeaderCertRequest =
{
    szBeginCertRequest,
    CB_BEGINCERTREQUEST,
    szEndCertRequest,
    CB_ENDCERTREQUEST
};

static CERTHEADER const CertHeaderCRL =
{
    szBeginCRL,
    CB_BEGINCRL,
    szEndCRL,
    CB_ENDCRL
};


BOOL
WINAPI
CryptBinaryToStringA(
    IN  CONST BYTE  *pbBinary,
    IN  DWORD        cbBinary,
    IN  DWORD        dwFlags,
    OUT LPSTR        pszString,
    OUT DWORD       *pcchString)
{
    DWORD  dwErr;
    TCHAR *pchEncode;
    DWORD cchMax;
    DWORD cchOut;
    DWORD cbTotal;
    CERTHEADER const *pCertHeader = NULL;
    BOOL fNoCR = 0 != (CRYPT_STRING_NOCR & dwFlags);
    DWORD cchnl = fNoCR? 1 : 2;
    BOOL  fBinaryCopy = FALSE;

    if (NULL == pbBinary || 0 == cbBinary || NULL == pcchString)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto InvalidDataError;
    }

    if (NULL == pszString)
    {
        *pcchString = 0;
    }

    switch (~CRYPT_STRING_NOCR & dwFlags)
    {
        case CRYPT_STRING_BASE64HEADER:
	    pCertHeader = &CertHeaderCert;
	    break;

        case CRYPT_STRING_BASE64REQUESTHEADER:
	    pCertHeader = &CertHeaderCertRequest;
	    break;

        case CRYPT_STRING_BASE64X509CRLHEADER:
	    pCertHeader = &CertHeaderCRL;
	    break;
    }

    pchEncode = pszString;
    cchMax = *pcchString;
    cchOut = cchMax;

    if (NULL != pszString && NULL != pCertHeader)
    {
	// Make sure there's room for the BEGIN header and CR-LF sequence
	
	if (pCertHeader->cbBegin + cchnl > cchMax)
	{
            dwErr = ERROR_MORE_DATA;
            goto MoreDataError;
	}
	cchOut -= pCertHeader->cbBegin + cchnl;
	CopyMemory(pchEncode, pCertHeader->pszBegin, pCertHeader->cbBegin);
	pchEncode += pCertHeader->cbBegin/sizeof(TCHAR);
	if (!fNoCR)
	{
	    *pchEncode++ = '\r';
	}
	*pchEncode++ = '\n';
    }

    // first determine size

    switch (~CRYPT_STRING_NOCR & dwFlags)
    {
	case CRYPT_STRING_BINARY:
	    dwErr = BinaryEncode(pbBinary, cbBinary, pchEncode, &cchOut);
	    if (ERROR_SUCCESS != dwErr)
            {
                goto BinaryEncodeError;
            }
            fBinaryCopy = TRUE;
	    break;

	case CRYPT_STRING_HEX:
	case CRYPT_STRING_HEXASCII:
	case CRYPT_STRING_HEXADDR:
	case CRYPT_STRING_HEXASCIIADDR:
	    dwErr = HexEncode(pbBinary, cbBinary, dwFlags, pchEncode, &cchOut);
	    if (ERROR_SUCCESS != dwErr)
            {
                goto HexEncodeError;
            }
	    break;

	default:
	    dwErr = Base64Encode(pbBinary, cbBinary, dwFlags, pchEncode, &cchOut);
            if (ERROR_SUCCESS != dwErr)
            {
                goto Base64EncodeError;
            }
	    break;
    }

    // Compute total size, including the trailing '\0' character.
    if (fBinaryCopy)
    {
        cbTotal = cchOut;
    }
    else
    {
        cbTotal = (cchOut + 1) * sizeof(CHAR);
    }

    // Add space for the BEGIN & END headers, if requested.

    if (NULL != pCertHeader)
    {
	cbTotal += pCertHeader->cbBegin + pCertHeader->cbEnd;
	if (!fNoCR)
	{
	    cbTotal += 2 * sizeof(TCHAR);	// for BEGIN & END '\r' chars
	}
	cbTotal += 2 * sizeof(TCHAR);		// for BEGIN & END '\n' chars
    }

    if (fBinaryCopy)
    {
        *pcchString = cbTotal;
    }
    else
    {
        // if pszString is NULL, set size to include trailing '\0'
        *pcchString = cbTotal / sizeof(CHAR);
    }

    if (NULL == pszString)
    {
        // only determine size, done
        goto done;
    }

    if (NULL != pCertHeader)
    {
	cchOut += pCertHeader->cbBegin/sizeof(CHAR) + cchnl;

	// Make sure there's room for the END header, CR-LF sequence, and '\0'

	if (cchOut + pCertHeader->cbEnd + cchnl + 1 > cchMax)
	{
            dwErr = ERROR_MORE_DATA;
            goto MoreDataError;
	}
	CopyMemory(&pszString[cchOut], pCertHeader->pszEnd, pCertHeader->cbEnd);
	cchOut += pCertHeader->cbEnd/sizeof(CHAR);
	if (!fNoCR)
	{
	    pszString[cchOut++] = '\r';
	}
	pszString[cchOut++] = '\n';
    }

    if (!fBinaryCopy)
    {
        pszString[cchOut] = '\0';
        assert((cchOut + 1) * sizeof(CHAR) == cbTotal);

        // pszString is not NULL, don't include trailing '\0' in length

        *pcchString = cchOut;
    }

done:
    dwErr = ERROR_SUCCESS;

ErrorReturn:
    return(ERROR_SUCCESS == dwErr);

TRACE_ERROR(Base64EncodeError)
TRACE_ERROR(HexEncodeError)
TRACE_ERROR(BinaryEncodeError)
SET_ERROR(InvalidDataError, dwErr)
SET_ERROR(MoreDataError, dwErr)
}


static TCHAR const szBeginMatch[] = TEXT("-----BEGIN ");
static TCHAR const szEndMatch[] = TEXT("-----END ");
static TCHAR const szMinus[] = TEXT("-----");

#define CCH_BEGINMATCH  sizeof(szBeginMatch)/sizeof(szBeginMatch[0]) - 1
#define CCH_ENDMATCH    sizeof(szEndMatch)/sizeof(szEndMatch[0]) - 1
#define CCH_MINUS       sizeof(szMinus)/sizeof(szMinus[0]) - 1

// Returns the count of characters up to the -----BEGIN/-----END delimiter,
//	MAXDWORD on error.
//
// On successful return, *pcchSkip is the count of characters in the delimiter
//	string.

DWORD
SizeBase64Header(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN BOOL fBegin,
    OUT DWORD *pcchSkip)
{
    DWORD cchHeader = MAXDWORD;
    TCHAR const *pchT;
    TCHAR const *pchT2;
    TCHAR const *pchEnd;
    TCHAR const *pchMatch;
    DWORD cchMatch;

    // Skip to the starting '-----....' & return count of skipped characters.

    *pcchSkip = 0;
    if (fBegin)
    {
	pchMatch = szBeginMatch;
	cchMatch = CCH_BEGINMATCH;
    }
    else
    {
	pchMatch = szEndMatch;
	cchMatch = CCH_ENDMATCH;
    }
    pchT = pchIn;
    pchEnd = &pchIn[cchIn];

    while (TRUE)
    {
	// Skip until we match the first character.

	while (pchT < pchEnd && *pchT != *pchMatch)
	{
	    pchT++;
	}

	if (&pchT[cchMatch] > pchEnd)
	{
	    // no room for the "-----BEGIN "/"-----END " string
	    break;
	}
	if (0 == strncmp(pchT, pchMatch, cchMatch))
	{
	    pchT2 = &pchT[cchMatch];
	    while (pchT2 < pchEnd && *pchT2 != szMinus[0])
	    {
		pchT2++;
	    }
	    if (&pchT2[CCH_MINUS] > pchEnd)
	    {
		// no room for the trailing "-----" string
		break;
	    }
	    if (0 == strncmp(pchT2, szMinus, CCH_MINUS))
	    {
		// Allow up to 2 extra leading minus signs

		DWORD cchMinus = 0;

		while (2 > cchMinus && pchT > pchIn)
		{
		    if (TEXT('-') != *--pchT)
		    {
			pchT++;		// oops, went too far
			break;
		    }
		    cchMinus++;
		}

#if DBG
		if (0 != cchMinus)
		{
		    DbgPrintf(DBG_SS_TRACE,
			"Ignored leading data: \"%.*" szFMTTSTR "\"\n",
			cchMinus,
			TEXT("--"));
		}
#endif //DBG

		cchHeader = SAFE_SUBTRACT_POINTERS(pchT, pchIn);
		*pcchSkip = SAFE_SUBTRACT_POINTERS(pchT2, pchT) + CCH_MINUS;
#if DBG
		if (FALSE)
		{
		    DbgPrintf(DBG_SS_TRACE,
			"Skipping(%u, %x, %x):\n[%.*" szFMTTSTR "]\n",
			fBegin,
			cchHeader,
			*pcchSkip,
			cchHeader,
			pchIn);
		}
#endif // DBG
		break;
	    }
	}
	pchT++;
    }
    return(cchHeader);
}

BOOL
WINAPI
CryptBinaryToStringW(
    IN  CONST BYTE  *pbBinary,
    IN  DWORD        cbBinary,
    IN  DWORD        dwFlags,
    OUT LPWSTR       pwszString,
    OUT DWORD       *pcchString)
{
    BOOL  fRet = FALSE;
    BOOL  fConversion = FALSE;
    DWORD dwErr;
    int   len;
    CHAR  *pszString = NULL;

    if (NULL == pwszString)
    {
        //only return size
        fRet = CryptBinaryToStringA(
                    pbBinary,
                    cbBinary,
                    dwFlags,
                    NULL, //for size
                    pcchString);
    }
    else
    {
        if (0 == *pcchString)
        {
            //must bigger than 0
            dwErr = ERROR_INVALID_PARAMETER;
            goto InvalidDataError;
        }

        if (CRYPT_STRING_BINARY == (~CRYPT_STRING_NOCR & dwFlags))
        {
            //no conversion needed
            pszString = (CHAR*)pwszString;
        }
        else
        {
            pszString = (CHAR*)LocalAlloc(LMEM_FIXED, *pcchString * sizeof(CHAR));
            if (NULL == pszString)
            {
                goto LocalAllocError;
            }
            fConversion = TRUE;
        }

        fRet = CryptBinaryToStringA(
                    pbBinary,
                    cbBinary,
                    dwFlags,
                    pszString,
                    pcchString);
        if (!fRet)
        {
            goto CryptBinaryToStringAError;
        }
        //pszString in above call is not NULL, so pcchString can be 1 smaller
        //then IN size after the call for exlucding NULL

        if (fConversion)
        {
            len = MultiByteToWideChar(
                    GetACP(),
                    0, 
                    pszString,
                    (*pcchString + 1) * sizeof(CHAR),
                    pwszString,
                    *pcchString + 1);
            //add 1 to *pcchString to include NULL for the conversion
            //but keep *pcchString for return
            if (0 == len)
            {
                fRet = FALSE;
                goto MultiByteToWideCharError;
            }
            assert(len == (int)(*pcchString + 1));
        }
    }

ErrorReturn:
    if (fConversion && NULL != pszString)
    {
        LocalFree(pszString);
    }
    return fRet;

TRACE_ERROR(MultiByteToWideCharError)
TRACE_ERROR(CryptBinaryToStringAError)
TRACE_ERROR(LocalAllocError)
SET_ERROR(InvalidDataError, dwErr)
}


#define NOTEPAD_UNICODE_SPECIAL_WCHAR   L'\xfeff'

BOOL
WINAPI
CryptStringToBinaryW(
    IN     LPCWSTR   pwszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    IN OUT BYTE     *pbBinary,
    IN OUT DWORD    *pcbBinary,
    IN OUT DWORD    *pdwSkip,    //OPTIONAL
    IN OUT DWORD    *pdwFlags)   //OPTIONAL
{
    BOOL    fRet = FALSE;
    BOOL    fFree = FALSE;
    DWORD   dwErr;
    CHAR   *pszString = NULL;

    if (NULL == pwszString || NULL == pcbBinary)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto InvalidDataError;
    }

    if (dwFlags == CRYPT_STRING_BINARY)
    {
        //its binary, no conversion
        pszString = (CHAR*)pwszString;
    }
    else
    {
        if (0 == cchString)
        {
            //assume null terminated string
            cchString = wcslen(pwszString) + 1;
        }

        // Check for the special Notepad UNICODE character inserted at the
        // beginning and skip past it if present.
        if (0 < cchString && NOTEPAD_UNICODE_SPECIAL_WCHAR == *pwszString)
        {
            cchString--;
            pwszString++;
        }

        pszString = (CHAR*)LocalAlloc(LMEM_FIXED, cchString * sizeof(CHAR));
        if (NULL == pszString)
        {
            dwErr = ERROR_OUTOFMEMORY;
            goto LocalAllocError;
        }

        fFree = TRUE;
        if (0 == WideCharToMultiByte(
                        GetACP(), 
                        0, 
                        pwszString, 
                        cchString, 
                        pszString, 
                        cchString, 
                        NULL, 
                        NULL))
        {
            goto WideCharToMultiByteError;
        }
    }

    fRet = CryptStringToBinaryA(
                pszString,
                cchString,
                dwFlags,
                pbBinary,
                pcbBinary,
                pdwSkip,
                pdwFlags);
    if (!fRet)
    {
        goto CryptStringToBinaryAError;
    }

ErrorReturn:
    if (fFree && NULL != pszString)
    {
        LocalFree(pszString);
    }
    return fRet;

TRACE_ERROR(CryptStringToBinaryAError)
SET_ERROR(LocalAllocError, dwErr)
SET_ERROR(InvalidDataError, dwErr)
TRACE_ERROR(WideCharToMultiByteError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\catutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catutil.cpp
//
//  Contents:   catalog database common functions
//
//  History:    01-may-2000 reidk created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "catutil.h"


//---------------------------------------------------------------------------------------
//
//  CatUtil_CreateCTLContextFromFileName
//
//---------------------------------------------------------------------------------------
BOOL
CatUtil_CreateCTLContextFromFileName(
    LPCWSTR         pwszFileName,
    HANDLE          *phMappedFile,
    BYTE            **ppbMappedFile,
    PCCTL_CONTEXT   *ppCTLContext,
    BOOL            fCreateSorted)
{
    BOOL    fRet = TRUE;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD   cbFile = 0;
    HANDLE  hMappedFile = NULL;
    BYTE    *pbMappedFile = NULL;

    //
    // Initialize out params
    //
    *phMappedFile = NULL;
    *ppbMappedFile = NULL;
    *ppCTLContext = NULL;

    //
    // Open the existing catalog file 
    //
    hFile = CreateFileW(
                    pwszFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {    
        goto ErrorCreateFile;
    }

    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == 0xFFFFFFFF)
    {
        goto ErrorGetFileSize;
    }

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL);
    if (hMappedFile == NULL)
    {
        goto ErrorCreateFileMapping;
    }
    
    pbMappedFile = (BYTE *) MapViewOfFile(
                                hMappedFile, 
                                FILE_MAP_READ, 
                                0, 
                                0, 
                                cbFile);
    if (pbMappedFile == NULL)
    {
        goto ErrorMapViewOfFile;
    }

    //
    // Don't need the file handle since we have a mapped file handle
    //
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    if (NULL == (*ppCTLContext = (PCCTL_CONTEXT) 
                                    CertCreateContext(
                                        CERT_STORE_CTL_CONTEXT,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        pbMappedFile,
                                        cbFile,
                                        fCreateSorted ?
                                            CERT_CREATE_CONTEXT_NOCOPY_FLAG | CERT_CREATE_CONTEXT_SORTED_FLAG :
                                            CERT_CREATE_CONTEXT_NOCOPY_FLAG,
                                        NULL)))
    {
        goto ErrorCertCreateContect;
    }

    *phMappedFile = hMappedFile;
    *ppbMappedFile = pbMappedFile;

CommonReturn:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return fRet;

ErrorReturn:

    if (pbMappedFile != NULL)
    {
        UnmapViewOfFile(pbMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCreateFile)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorGetFileSize)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCreateFileMapping)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMapViewOfFile)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCertCreateContect)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\asn1util.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       asn1util.cpp
//
//  Contents:   ASN.1 utility helper functions.
//
//  Functions:  Asn1UtilDecodeLength
//              Asn1UtilExtractContent
//              Asn1UtilIsPKCS7WithoutContentType
//              Asn1UtilAdjustEncodedLength
//              Asn1UtilExtractValues
//              Asn1UtilExtractPKCS7SignedDataContent
//              Asn1UtilExtractCertificateToBeSignedContent
//              Asn1UtilExtractCertificatePublicKeyInfo
//              Asn1UtilExtractKeyIdFromCertInfo
//
//  History:    04-Dec-96    philh   created from kevinr's wincrmsg version
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a BER encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets if definite
//                       encoding, else CMSG_INDEFINITE_LENGTH
//          pbLength   - points to the first length octet
//          cbDER      - number of bytes remaining in the encoding
//
//  Returns:
//          success - the number of bytes in the length field, >0
//          failure - <0
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilDecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbEncoded)
{
    long        i;
    BYTE        cbLength;
    const BYTE  *pb;

    if (cbEncoded < 1)
        goto TooLittleData;

    if (0x80 == *pbLength) {
        *pcbContent = CMSG_INDEFINITE_LENGTH;
        i = 1;
        goto CommonReturn;
    }

    // determine the number of length octets and contents octets
    if ((cbLength = *pbLength) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        if (cbLength > 4)
            goto LengthTooLargeError;
        if (cbLength >= cbEncoded)
            goto TooLittleData;
        *pcbContent = 0;
        for (i=cbLength, pb=pbLength+1; i>0; i--, pb++)
            *pcbContent = (*pcbContent << 8) + (const DWORD)*pb;
        i = cbLength + 1;
    } else {
        *pcbContent = (DWORD)cbLength;
        i = 1;
    }

CommonReturn:
    return i;   // how many bytes there were in the length field

ErrorReturn:
    i = -1;
    goto CommonReturn;
TooLittleData:
    i = ASN1UTIL_INSUFFICIENT_DATA;
    goto CommonReturn;
TRACE_ERROR(LengthTooLargeError)
}


//+-------------------------------------------------------------------------
//  Point to the content octets in a BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, >=0
//          failure - <0
//
//  NB- If the blob is indefinite-length encoded, *pcbContent is set to
//  CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent)
{
#define TAG_MASK 0x1f
    DWORD       cbIdentifier;
    DWORD       cbContent;
    LONG        cbLength;
    LONG        lHeader;
    const BYTE  *pb = pbEncoded;

    if (0 == cbEncoded--)
        goto TooLittleData;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        cbIdentifier = 2;
        while (TRUE) {
            if (0 == cbEncoded--)
                goto TooLittleData;
            if (0 == (*pb++ & 0x80))
                break;
            cbIdentifier++;
        }
    } else {
        // low-tag-number form
        cbIdentifier = 1;
    }

    if (0 > (cbLength = Asn1UtilDecodeLength( &cbContent, pb, cbEncoded))) {
        lHeader = cbLength;
        goto CommonReturn;
    }

    pb += cbLength;

    *pcbContent = cbContent;
    *ppbContent = pb;

    lHeader = cbLength + cbIdentifier;
CommonReturn:
    return lHeader;

TooLittleData:
    lHeader = ASN1UTIL_INSUFFICIENT_DATA;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Returns TRUE if we believe this is a Bob special that has ommitted the
//  PKCS #7 ContentType.
//
//  For PKCS #7: an Object Identifier tag (0x06) immediately follows the
//  identifier and length octets. For a Bob special: an integer tag (0x02)
//  follows the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilIsPKCS7WithoutContentType(
    IN const BYTE *pbDER,
    IN DWORD cbDER)
{
    DWORD cbContent;
    const BYTE *pbContent;

  // Handle MappedFile Exceptions
  __try {

    if (0 < Asn1UtilExtractContent(pbDER, cbDER, &cbContent, &pbContent) &&
            (pbContent < pbDER + cbDER) &&
            (0x02 == *pbContent))
        return TRUE;
    else
        return FALSE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    SetLastError(GetExceptionCode());
    return FALSE;
  }
}

//+-------------------------------------------------------------------------
//  Decode the Asn1 length bytes to possibly downward adjust the length.
//
//  The returned length is always <= cbDER.
//--------------------------------------------------------------------------
DWORD
WINAPI
Asn1UtilAdjustEncodedLength(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
    // Decode the header to get the real length. I've seen files with extra
    // stuff.

    LONG lLen;
    DWORD cbLen;
    DWORD cbContent;
    const BYTE *pbContent;
    lLen = Asn1UtilExtractContent(pbDER, cbDER, &cbContent, &pbContent);
    if ((lLen >= 0) && (cbContent != CMSG_INDEFINITE_LENGTH)) {
        cbLen = (DWORD)lLen + cbContent;
        if (cbLen < cbDER)
            cbDER = cbLen;
        // else if (cbLen > cbDER)
        //  DER length exceeds input file
    }
    // else
    //  Can't decode DER length
            
    return cbDER;
}

//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (ASN1UTIL_STEP_INTO_VALUE_OP)
//  or steps over the value's tag, length and content octets 
//  (ASN1UTIL_STEP_OVER_VALUE_OP or ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  For tag matching, only supports single byte tags.  STEP_OVER values
//  must be definite-length encoded.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all values successfully extracted. For
//                        STEP_INTO, only the tag and length octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        LastError is updated with the error.
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. For OPTIONAL_STEP_OVER, if tag isn't
//  found, pbData and cbData are set to 0.  If a STEP_INTO value is
//  indefinite-length encoded, cbData is set to CMSG_INDEFINITE_LENGTH.
//  If ASN1UTIL_DEFINITE_LENGTH_FLAG is set, then, all returned lengths
//  are definite-length, ie, CMSG_INDEFINITE_LENGTH is never returned.
//
//  If ASN1UTIL_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If ASN1UTIL_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OUT DWORD *pcValue,
    IN const ASN1UTIL_EXTRACT_VALUE_PARA *rgValuePara,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    )
{
    DWORD cValue = *pcValue;
    const BYTE *pb = pbEncoded;
    DWORD cb = cbEncoded;

    DWORD iValue;
    LONG lAllValues;

    for (iValue = 0; iValue < cValue; iValue++) {
        DWORD dwParaFlags = rgValuePara[iValue].dwFlags;
        DWORD dwOp = dwParaFlags & ASN1UTIL_MASK_VALUE_OP;
        const BYTE *pbParaTag = rgValuePara[iValue].rgbTag;
        BOOL fValueBlob = (dwParaFlags & (ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
                ASN1UTIL_RETURN_CONTENT_BLOB_FLAG)) && rgValueBlob;

        LONG lTagLength;
        DWORD cbContent;
        const BYTE *pbContent;
        DWORD cbValue;

        if (0 == cb) {
            if (ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP != dwOp)
                goto TooLittleData;
            if (fValueBlob) {
                rgValueBlob[iValue].pbData = NULL;
                rgValueBlob[iValue].cbData = 0;
            }
            continue;
        }

        // Assumption: single byte tag for doing comparison
        if (pbParaTag) {
            // Check if the encoded tag matches one of the expected tags

            BYTE bEncodedTag;
            BYTE bParaTag;

            bEncodedTag = *pb;
            while ((bParaTag = *pbParaTag) && bParaTag != bEncodedTag)
                pbParaTag++;

            if (0 == bParaTag) {
                if (ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP != dwOp)
                    goto InvalidTag;
                if (fValueBlob) {
                    rgValueBlob[iValue].pbData = NULL;
                    rgValueBlob[iValue].cbData = 0;
                }
                continue;
            }
        }

        lTagLength = Asn1UtilExtractContent(
            pb,
            cb,
            &cbContent,
            &pbContent
            );
        if (0 >= lTagLength || (DWORD) lTagLength > cb)
            goto InvalidTagOrLength;

        if (CMSG_INDEFINITE_LENGTH == cbContent) {
            if (ASN1UTIL_STEP_INTO_VALUE_OP != dwOp)
                goto UnsupportedIndefiniteLength;
            else if (fValueBlob && (dwFlags & ASN1UTIL_DEFINITE_LENGTH_FLAG))
                goto NotAllowedIndefiniteLength;
            cbValue = CMSG_INDEFINITE_LENGTH;
        } else {
            cbValue = cbContent + lTagLength;
            if (cbValue > cb)
                goto TooLittleData;
        }

        if (fValueBlob) {
            if (dwParaFlags & ASN1UTIL_RETURN_CONTENT_BLOB_FLAG) {
                rgValueBlob[iValue].pbData = (BYTE *) pbContent;
                rgValueBlob[iValue].cbData = cbContent;
            } else if (dwParaFlags & ASN1UTIL_RETURN_VALUE_BLOB_FLAG) {
                rgValueBlob[iValue].pbData = (BYTE *) pb;
                rgValueBlob[iValue].cbData = cbValue;
            }
        }

        switch (dwOp) {
            case ASN1UTIL_STEP_INTO_VALUE_OP:
                pb += lTagLength;
                cb -= lTagLength;
                break;
            case ASN1UTIL_STEP_OVER_VALUE_OP:
            case ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP:
                pb += cbValue;
                cb -= cbValue;
                break;
            default:
                goto InvalidArg;

        }
    }

    lAllValues = (LONG)(pb - pbEncoded);
    assert((DWORD) lAllValues <= cbEncoded);

CommonReturn:
    *pcValue = iValue;
    return lAllValues;

ErrorReturn:
    lAllValues = -((LONG)(pb - pbEncoded)) - 1;
    goto CommonReturn;

SET_ERROR(TooLittleData, ERROR_INVALID_DATA)
SET_ERROR(InvalidTag, ERROR_INVALID_DATA)
SET_ERROR(InvalidTagOrLength, ERROR_INVALID_DATA)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnsupportedIndefiniteLength, ERROR_INVALID_DATA)
SET_ERROR(NotAllowedIndefiniteLength, ERROR_INVALID_DATA)
}

static const BYTE rgbSeqTag[] = {ASN1UTIL_TAG_SEQ, 0};
static const BYTE rgbSetTag[] = {ASN1UTIL_TAG_SET, 0};
static const BYTE rgbOIDTag[] = {ASN1UTIL_TAG_OID, 0};
static const BYTE rgbIntegerTag[] = {ASN1UTIL_TAG_INTEGER, 0};
static const BYTE rgbBitStringTag[] = {ASN1UTIL_TAG_BITSTRING, 0};
static const BYTE rgbConstructedContext0Tag[] =
    {ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0, 0};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractSignedDataContentPara[] = {
    // 0 - ContentInfo ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - contentType ContentType,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - content  [0] EXPLICIT ANY -- OPTIONAL
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbConstructedContext0Tag,
    //     3 - SignedData ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //       4 - version             INTEGER,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //       5 - digestAlgorithms    DigestAlgorithmIdentifiers,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSetTag,
    //       6 - ContentInfo ::= SEQUENCE {
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //       7 - contentType ContentType,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //       8 - content  [0] EXPLICIT ANY -- OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbConstructedContext0Tag,
};

#define SIGNED_DATA_CONTENT_OUTER_OID_VALUE_INDEX   1
#define SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX     4
#define SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX   7
#define SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX    6
#define SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX   8
#define SIGNED_DATA_CONTENT_VALUE_COUNT             \
    (sizeof(rgExtractSignedDataContentPara) / \
        sizeof(rgExtractSignedDataContentPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCertSignedContent[] = {
    // 0 - SignedContent ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - toBeSigned          NOCOPYANY,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, NULL,
    //   2 - algorithm           AlgorithmIdentifier,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   3 - signature           BITSTRING
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbBitStringTag,
};

#define CERT_TO_BE_SIGNED_VALUE_INDEX               1
#define CERT_SIGNED_CONTENT_VALUE_COUNT             \
    (sizeof(rgExtractCertSignedContent) / \
        sizeof(rgExtractCertSignedContent[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCertPublicKeyInfo[] = {
    // 0 - SignedContent ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - CertificateToBeSigned ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //      2 - version                 [0] CertificateVersion DEFAULT v1,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbConstructedContext0Tag,
    //      3 - serialNumber            CertificateSerialNumber,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //      4 - signature               AlgorithmIdentifier,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      5 - issuer                  NOCOPYANY, -- really Name
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      6 - validity                Validity,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      7 - subject                 NOCOPYANY, -- really Name
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //      8 - subjectPublicKeyInfo    SubjectPublicKeyInfo,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag
};

#define CERT_PUBLIC_KEY_INFO_VALUE_INDEX    8
#define CERT_PUBLIC_KEY_INFO_VALUE_COUNT        \
    (sizeof(rgExtractCertPublicKeyInfo) / \
        sizeof(rgExtractCertPublicKeyInfo[0]))


// #define szOID_RSA_signedData    "1.2.840.113549.1.7.2"
static const BYTE rgbOIDSignedData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02};

static const CRYPT_DER_BLOB EncodedOIDSignedData = {
    sizeof(rgbOIDSignedData), (BYTE *) rgbOIDSignedData
};

#ifdef CMS_PKCS7

// #define szOID_RSA_Data    "1.2.840.113549.1.7.1"
static const BYTE rgbOIDData[] =
    {0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01};

static const CRYPT_DER_BLOB EncodedOIDData = {
    sizeof(rgbOIDData), (BYTE *) rgbOIDData
};

#endif // CMS_PKCS7


// The encoded OID only includes the content octets. Excludes the tag and
// length octets.
static BOOL CompareEncodedOID(
    IN const CRYPT_DER_BLOB *pEncodedOID1,
    IN const CRYPT_DER_BLOB *pEncodedOID2
    )
{
    if (pEncodedOID1->cbData == pEncodedOID2->cbData &&
            0 == memcmp(pEncodedOID1->pbData, pEncodedOID2->pbData,
                    pEncodedOID1->cbData))
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//  Skips past PKCS7 ASN.1 encoded values to get to the SignedData content.
//
//  Checks that the outer ContentType has the SignedData OID and optionally
//  checks the inner SignedData content's ContentType.
//
//  Returns:
//      success - the number of bytes skipped, >=0
//      failure - <0
//
//  If the SignedData content is indefinite-length encoded,
//  *pcbContent is set to CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractPKCS7SignedDataContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OPTIONAL const CRYPT_DER_BLOB *pEncodedInnerOID,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    )
{
    LONG lSkipped;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[SIGNED_DATA_CONTENT_VALUE_COUNT];

    DWORD cbContent;
    const BYTE *pbContent;
    DWORD cbSeq;
    const BYTE *pbSeq;

    cValue = SIGNED_DATA_CONTENT_VALUE_COUNT;
    if (0 >= (lSkipped = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &cValue,
            rgExtractSignedDataContentPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    pbContent = rgValueBlob[SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX].pbData;
    cbContent = rgValueBlob[SIGNED_DATA_CONTENT_CONTEXT_0_VALUE_INDEX].cbData;

    // For definite-length encoded, check that the content wasn't
    // omitted.
    //
    // Note, for indefinite-length encoding, if the content was omitted,
    // we would have had a 0 tag instead of the CONTEXT_0 tag.
    cbSeq = rgValueBlob[SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX].cbData;
    pbSeq = rgValueBlob[SIGNED_DATA_CONTENT_INFO_SEQ_VALUE_INDEX].pbData;
    if (CMSG_INDEFINITE_LENGTH != cbSeq && pbContent >= (pbSeq + cbSeq))
        goto NoSignedDataError;

#ifdef CMS_PKCS7
    // For V3 SignedData, non Data types are wrapped, encapsulated with a
    // OCTET string
    if (1 == rgValueBlob[SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX].cbData &&
            CMSG_SIGNED_DATA_V3 <=
                *(rgValueBlob[SIGNED_DATA_CONTENT_VERSION_VALUE_INDEX].pbData)
                        &&
            !CompareEncodedOID(
                &rgValueBlob[SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX],
                &EncodedOIDData)
                        &&
            0 != cbContent && ASN1UTIL_TAG_OCTETSTRING == *pbContent
            ) {
        LONG lTagLength;
        const BYTE *pbInner;
        DWORD cbInner;

        // Advance past the outer OCTET wrapper
        lTagLength = Asn1UtilExtractContent(
            pbContent,
            cbEncoded - lSkipped,
            &cbInner,
            &pbInner
            );
        if (0 < lTagLength) {
            lSkipped += lTagLength;
            cbContent = cbInner;
            pbContent = pbInner;
        }
    }
#endif

    if (CMSG_INDEFINITE_LENGTH == cbContent) {
        // Extract the pbContent and attempt to get its definite length

        LONG lTagLength;
        const BYTE *pbInner;
        DWORD cbInner;

        lTagLength = Asn1UtilExtractContent(
            pbContent,
            cbEncoded - lSkipped,
            &cbInner,
            &pbInner
            );
        if (0 < lTagLength && CMSG_INDEFINITE_LENGTH != cbInner)
            cbContent = cbInner + lTagLength;
    }

    // Verify that the outer ContentType is SignedData and the inner
    // ContentType is the specified type
    if (!CompareEncodedOID(
            &rgValueBlob[SIGNED_DATA_CONTENT_OUTER_OID_VALUE_INDEX],
            &EncodedOIDSignedData
            ))
        goto NotSignedDataContentType;
    if (pEncodedInnerOID && !CompareEncodedOID(
            &rgValueBlob[SIGNED_DATA_CONTENT_INNER_OID_VALUE_INDEX],
            pEncodedInnerOID
            ))
        goto UnexpectedInnerContentTypeError;

    *pcbContent = cbContent;
    *ppbContent = pbContent;

CommonReturn:
    return lSkipped;

ErrorReturn:
    if (0 <= lSkipped)
        lSkipped = -lSkipped - 1;
    *pcbContent = 0;
    *ppbContent = NULL;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
SET_ERROR(NoSignedDataError, ERROR_INVALID_DATA)
SET_ERROR(NotSignedDataContentType, ERROR_INVALID_DATA)
SET_ERROR(UnexpectedInnerContentTypeError, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Verifies this is a certificate ASN.1 encoded signed content.
//  Returns the pointer to and length of the ToBeSigned content.
//
//  Returns an error if the ToBeSigned content isn't definite length
//  encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificateToBeSignedContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    )
{
    BOOL fResult;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[CERT_SIGNED_CONTENT_VALUE_COUNT];

    cValue = CERT_SIGNED_CONTENT_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractCertSignedContent,
            rgValueBlob
            ))
        goto ExtractValuesError;

    *ppbContent = rgValueBlob[CERT_TO_BE_SIGNED_VALUE_INDEX].pbData;
    *pcbContent = rgValueBlob[CERT_TO_BE_SIGNED_VALUE_INDEX].cbData;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *ppbContent = NULL;
    *pcbContent = 0;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
}

//+-------------------------------------------------------------------------
//  Returns the pointer to and length of the SubjectPublicKeyInfo value in
//  a signed and encoded X.509 certificate.
//
//  Returns an error if the value isn't definite length encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificatePublicKeyInfo(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbPublicKeyInfo,
    OUT const BYTE **ppbPublicKeyInfo
    )
{
    BOOL fResult;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_COUNT];

    cValue = CERT_PUBLIC_KEY_INFO_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractCertPublicKeyInfo,
            rgValueBlob
            ))
        goto ExtractValuesError;

    *ppbPublicKeyInfo = rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_INDEX].pbData;
    *pcbPublicKeyInfo = rgValueBlob[CERT_PUBLIC_KEY_INFO_VALUE_INDEX].cbData;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *ppbPublicKeyInfo = NULL;
    *pcbPublicKeyInfo = 0;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
}


// Special RDN containing the KEY_ID. Its value type is CERT_RDN_OCTET_STRING.
//#define szOID_KEYID_RDN                     "1.3.6.1.4.1.311.10.7.1"
static const BYTE rgbOIDKeyIdRDN[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x07, 0x01};

static const CRYPT_DER_BLOB EncodedOIDKeyIdRDN = {
    sizeof(rgbOIDKeyIdRDN), (BYTE *) rgbOIDKeyIdRDN
};

static const BYTE rgbOctetStringTag[] = {ASN1UTIL_TAG_OCTETSTRING, 0};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractNameKeyIdRDNPara[] = {
    // 0 - Name ::= SEQUENCE OF RelativeDistinguishedName
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - RelativeDistinguishedName ::= SET OF AttributeTypeValue
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSetTag,
    //     2 - AttributeTypeValue ::= SEQUENCE
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //       3 - type       EncodedObjectID,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //       4 - value      NOCOPYANY 
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
};

#define NAME_KEYID_RDN_OID_VALUE_INDEX              3
#define NAME_KEYID_RDN_OCTET_VALUE_INDEX            4
#define NAME_KEYID_RDN_VALUE_COUNT                  \
    (sizeof(rgExtractNameKeyIdRDNPara) / \
        sizeof(rgExtractNameKeyIdRDNPara[0]))


//+-------------------------------------------------------------------------
//  If the Issuer and SerialNumber in the CERT_INFO contains a special
//  KeyID RDN attribute returns TRUE with pKeyId's cbData and pbData updated
//  with the RDN attribute's OCTET_STRING value. Otherwise, returns FALSE.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractKeyIdFromCertInfo(
    IN PCERT_INFO pCertInfo,
    OUT PCRYPT_HASH_BLOB pKeyId
    )
{
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[NAME_KEYID_RDN_VALUE_COUNT];

    if (0 == pCertInfo->SerialNumber.cbData ||
            0 != *pCertInfo->SerialNumber.pbData)
        goto NoKeyId;

    cValue = NAME_KEYID_RDN_VALUE_COUNT;
    if (0 > Asn1UtilExtractValues(
            pCertInfo->Issuer.pbData,
            pCertInfo->Issuer.cbData,
            0,                  // dwFlags
            &cValue,
            rgExtractNameKeyIdRDNPara,
            rgValueBlob
            ))
        goto NoKeyId;

    if (!CompareEncodedOID(
            &rgValueBlob[NAME_KEYID_RDN_OID_VALUE_INDEX],
            &EncodedOIDKeyIdRDN))
        goto NoKeyId;

    if (CMSG_INDEFINITE_LENGTH ==
            rgValueBlob[NAME_KEYID_RDN_OCTET_VALUE_INDEX].cbData)
        goto NoKeyId;

    pKeyId->pbData = rgValueBlob[NAME_KEYID_RDN_OCTET_VALUE_INDEX].pbData;
    pKeyId->cbData = rgValueBlob[NAME_KEYID_RDN_OCTET_VALUE_INDEX].cbData;
    return TRUE;

NoKeyId:
    pKeyId->pbData = NULL;
    pKeyId->cbData = 0;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\filever.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       filever.cpp
//
//  Contents:   Get file version
//
//  Functions:  I_CryptGetFileVersion
//
//  History:    22-Oct-97   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include "crypthlp.h"
#include "unicode.h"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptGetFileVersion(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    )
{
    BOOL fResult;
    DWORD dwExceptionCode;
    BYTE rgb1[_MAX_PATH];
    LPSTR pszFilename = NULL;

    DWORD dwHandle = 0;
    DWORD cbInfo;
    void *pvInfo = NULL;
	VS_FIXEDFILEINFO *pFixedFileInfo = NULL;   // not allocated
	UINT ccFixedFileInfo = 0;

    if (!MkMBStr(rgb1, _MAX_PATH, pwszFilename, &pszFilename))
        goto OutOfMemory;

    // The following APIs are in DELAYLOAD'ed version.dll. If the DELAYLOAD
    // fails an exception is raised. 
    __try {
        if (0 == (cbInfo = GetFileVersionInfoSizeA(pszFilename, &dwHandle)))
            goto GetFileVersionInfoSizeError;

        if (NULL == (pvInfo = malloc(cbInfo)))
            goto OutOfMemory;

        if (!GetFileVersionInfoA(
                pszFilename,
                0,          // dwHandle, ignored
                cbInfo,
                pvInfo
                ))
            goto GetFileVersionInfoError;

        if (!VerQueryValueA(
                pvInfo,
                "\\",       // VS_FIXEDFILEINFO
                (void **) &pFixedFileInfo,
                &ccFixedFileInfo
                ))
            goto VerQueryValueError;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto GetFileVersionException;
    }

    *pdwFileVersionMS = pFixedFileInfo->dwFileVersionMS;
    *pdwFileVersionLS = pFixedFileInfo->dwFileVersionLS;

    fResult = TRUE;
CommonReturn:
    FreeMBStr(rgb1, pszFilename);
    if (pvInfo)
        free(pvInfo);
    return fResult;

ErrorReturn:
    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetFileVersionInfoSizeError)
TRACE_ERROR(GetFileVersionInfoError)
TRACE_ERROR(VerQueryValueError)
SET_ERROR_VAR(GetFileVersionException, dwExceptionCode)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkifmt\pkifmt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkifmt.h
//
//  Contents:   Shared types and functions
//              
//  APIs:
//
//  History:    March-2000   xtan   created
//--------------------------------------------------------------------------

#ifndef __PKIFMT_H__
#define __PKIFMT_H__

#include "xelib.h"

#if DBG
# ifdef UNICODE
#  define szFMTTSTR		"ws"
# else
#  define szFMTTSTR		"hs"
# endif
#endif //DBG

DWORD
SizeBase64Header(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN BOOL fBegin,
    OUT DWORD *pcchSkip);

DWORD
HexDecode(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut);

DWORD
HexEncode(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT TCHAR *pchOut,
    IN OUT DWORD *pcchOut);

#ifdef __cplusplus
extern "C" {
#endif


#ifdef UNICODE
#define Base64Decode  Base64DecodeW
#else
#define Base64Decode  Base64DecodeA
#endif // !UNICODE

DWORD			// ERROR_*
Base64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD			// ERROR_*
Base64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

    
#ifdef UNICODE
#define Base64Encode  Base64EncodeW
#else
#define Base64Encode  Base64EncodeA
#endif // !UNICODE

DWORD			// ERROR_*
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut);

DWORD			// ERROR_*
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT WCHAR *pchOut,
    OUT DWORD *pcchOut);

    
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\dir.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dir.cpp
//
//  Contents:   Directory functions
//
//  Functions:  I_RecursiveCreateDirectory
//
//  History:    06-Aug-99   reidk   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include "crypthlp.h"
#include "unicode.h"
#include <dbgdef.h>


BOOL I_RecursiveCreateDirectory(
    IN LPCWSTR pwszDir,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    BOOL fResult;

    DWORD dwAttr;
    DWORD dwErr;
    LPCWSTR pwsz;
    DWORD cch;
    WCHAR wch;
    LPWSTR pwszParent = NULL;

    dwAttr = GetFileAttributesU(pwszDir);

    if (0xFFFFFFFF != dwAttr) {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
            return TRUE;
        goto InvalidDirectoryAttr;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        goto GetFileAttrError;

    if (CreateDirectoryU(
            pwszDir,
            lpSecurityAttributes
            )) {
        SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_SYSTEM);
        return TRUE;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        goto CreateDirectoryError;

    // Peal off the last path name component
    cch = wcslen(pwszDir);
    pwsz = pwszDir + cch;

    while (L'\\' != *pwsz) {
        if (pwsz == pwszDir)
            // Path didn't have a \.
            goto BadDirectoryPath;
        pwsz--;
    }

    cch = (DWORD)(pwsz - pwszDir);
    if (0 == cch)
        // Detected leading \Path
        goto BadDirectoryPath;


    // Check for leading \\ or x:\.
    wch = *(pwsz - 1);
    if ((1 == cch && L'\\' == wch) || (2 == cch && L':' == wch))
        goto BadDirectoryPath;

    if (NULL == (pwszParent = (LPWSTR) PkiNonzeroAlloc((cch + 1) *
            sizeof(WCHAR))))
        goto OutOfMemory;
    memcpy(pwszParent, pwszDir, cch * sizeof(WCHAR));
    pwszParent[cch] = L'\0';

    if (!I_RecursiveCreateDirectory(pwszParent, lpSecurityAttributes))
        goto ErrorReturn;
    if (!CreateDirectoryU(
            pwszDir,
            lpSecurityAttributes
            )) {
        dwErr = GetLastError();
        goto CreateDirectory2Error;
    }
    SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_SYSTEM);

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszParent);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidDirectoryAttr, ERROR_FILE_INVALID)
SET_ERROR_VAR(GetFileAttrError, dwErr)
SET_ERROR_VAR(CreateDirectoryError, dwErr)
SET_ERROR(BadDirectoryPath, ERROR_BAD_PATHNAME)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CreateDirectory2Error, dwErr)
}


BOOL 
I_RecursiveDeleteDirectory(
    IN LPCWSTR pwszDelete
    )
{
    BOOL                fResult = TRUE;
    HANDLE              hFindHandle = INVALID_HANDLE_VALUE;
    LPWSTR              pwszSearch = NULL;
    WIN32_FIND_DATAW    FindData;
    LPWSTR              pwszDirOrFileDelete = NULL;
    DWORD               dwErr = 0;
    
    //
    // Create search string
    //
    pwszSearch = (LPWSTR) malloc((wcslen(pwszDelete) + 3) * sizeof(WCHAR));// length + '\' + '*' + '/0'
    if (pwszSearch == NULL)
    {
        goto ErrorMemory;
    }
    wcscpy(pwszSearch, pwszDelete);

    if ((pwszSearch[wcslen(pwszSearch) - 1] != L'\\'))
    {
        wcscat(pwszSearch, L"\\");
    }
    wcscat(pwszSearch, L"*");

    //
    // Loop for each item (file or dir) in pwszDelete, and delete/remove it 
    //
    hFindHandle = FindFirstFileU(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        // nothing found, get out
        if (GetLastError() == ERROR_NO_MORE_FILES)
        {
            SetFileAttributesU(pwszDelete, FILE_ATTRIBUTE_NORMAL);
            RemoveDirectoryW(pwszDelete);
            goto CommonReturn;
        }
        else
        {
            goto ErrorFindFirstFile;
        }
    }    

    while (1)
    {
        if ((wcscmp(FindData.cFileName, L".") != 0) &&
            (wcscmp(FindData.cFileName, L"..") != 0))
        {
            //
            // name of dir or file to delete
            //
            pwszDirOrFileDelete = (LPWSTR) malloc((wcslen(pwszDelete) + 
                                                   wcslen(FindData.cFileName) + 
                                                   2) * sizeof(WCHAR)); 
            if (pwszDirOrFileDelete == NULL)
            {
                goto ErrorMemory;
            }
            wcscpy(pwszDirOrFileDelete, pwszDelete);
            if ((pwszDirOrFileDelete[wcslen(pwszDirOrFileDelete) - 1] != L'\\'))
            {
                wcscat(pwszDirOrFileDelete, L"\\");
            }
            wcscat(pwszDirOrFileDelete, FindData.cFileName);

            //
            // check to see if this is a dir or a file
            //
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                //
                // Recursive delete
                //
                if (!I_RecursiveDeleteDirectory(pwszDirOrFileDelete))
                {
                    goto ErrorReturn;
                }
            }
            else
            {
                SetFileAttributesU(pwszDirOrFileDelete, FILE_ATTRIBUTE_NORMAL);
                if (!DeleteFileU(pwszDirOrFileDelete))
                {
                    //goto ErrorReturn;
                }
            }

            free(pwszDirOrFileDelete);
            pwszDirOrFileDelete = NULL;
        }

        if (!FindNextFileU(hFindHandle, &FindData))            
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                goto ErrorFindNextFile;
            }
        }
    }

    SetFileAttributesU(pwszDelete, FILE_ATTRIBUTE_NORMAL);
    RemoveDirectoryW(pwszDelete);
    
CommonReturn:

    dwErr = GetLastError();
    
    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszDirOrFileDelete != NULL)
    {
        free(pwszDirOrFileDelete);
    }

    if (hFindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandle);
    }

    SetLastError(dwErr);

    return (fResult);

ErrorReturn:

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_EX(DBG_SS_TRUST, ErrorMemory, ERROR_NOT_ENOUGH_MEMORY)

TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
}


BOOL 
I_RecursiveCopyDirectory(
    IN LPCWSTR pwszDirFrom,
    IN LPCWSTR pwszDirTo
    )
{
    BOOL                fResult = TRUE;
    HANDLE              hFindHandle = INVALID_HANDLE_VALUE;
    LPWSTR              pwszSearch = NULL;
    WIN32_FIND_DATAW    FindData;
    LPWSTR              pwszDirOrFileFrom = NULL;
    LPWSTR              pwszDirOrFileTo = NULL;
    DWORD               dwErr = 0;

    //
    // Create search string
    //
    pwszSearch = (LPWSTR) malloc((wcslen(pwszDirFrom) + 3) * sizeof(WCHAR)); // length + '\' + '*' + '/0'
    if (pwszSearch == NULL)
    {
        goto ErrorMemory;
    }
    wcscpy(pwszSearch, pwszDirFrom);

    if ((pwszSearch[wcslen(pwszSearch) - 1] != L'\\'))
    {
        wcscat(pwszSearch, L"\\");
    }
    wcscat(pwszSearch, L"*");

    //
    // Loop for each item (file or dir) in pwszDirFrom, and
    // copy it to pwszDirTo
    //
    hFindHandle = FindFirstFileU(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        // nothing found, get out
        if (GetLastError() == ERROR_NO_MORE_FILES)
        {
            goto CommonReturn;
        }
        else
        {
            goto ErrorFindFirstFile;
        }
    }    

    while (1)
    {
        if ((wcscmp(FindData.cFileName, L".") != 0) &&
            (wcscmp(FindData.cFileName, L"..") != 0))
        {
            //
            // name of dir or file to copy from 
            //
            pwszDirOrFileFrom = (LPWSTR) malloc((wcslen(pwszDirFrom) + wcslen(FindData.cFileName) + 2) * sizeof(WCHAR)); 
            if (pwszDirOrFileFrom == NULL)
            {
                goto ErrorMemory;
            }
            wcscpy(pwszDirOrFileFrom, pwszDirFrom);
            if ((pwszDirOrFileFrom[wcslen(pwszDirOrFileFrom) - 1] != L'\\'))
            {
                wcscat(pwszDirOrFileFrom, L"\\");
            }
            wcscat(pwszDirOrFileFrom, FindData.cFileName);

            //
            // name of dir or file to copy to
            //
            pwszDirOrFileTo = (LPWSTR) malloc((wcslen(pwszDirTo) + wcslen(FindData.cFileName) + 2) * sizeof(WCHAR));
            if (pwszDirOrFileTo == NULL)
            {
                goto ErrorMemory;
            }
            wcscpy(pwszDirOrFileTo, pwszDirTo);
            if ((pwszDirOrFileTo[wcslen(pwszDirOrFileTo) - 1] != L'\\'))
            {
                wcscat(pwszDirOrFileTo, L"\\");
            }
            wcscat(pwszDirOrFileTo, FindData.cFileName);

            //
            // check to see if this is a dir or a file
            //
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                //
                // Create new dir then recursive copy
                //
                if (!I_RecursiveCreateDirectory(pwszDirOrFileTo, NULL))
                {
                    goto ErrorReturn;
                }

                if (!I_RecursiveCopyDirectory(pwszDirOrFileFrom, pwszDirOrFileTo))
                {
                    goto ErrorReturn;
                }
            }
            else
            {
                if (!CopyFileU(pwszDirOrFileFrom, pwszDirOrFileTo, TRUE))
                {
                    goto ErrorCopyFile;
                }
            }

            free(pwszDirOrFileFrom);
            pwszDirOrFileFrom = NULL;
            free(pwszDirOrFileTo);
            pwszDirOrFileTo = NULL;
        }

        if (!FindNextFileU(hFindHandle, &FindData))            
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                goto CommonReturn;
            }
            else
            {
                goto ErrorFindNextFile;
            }
        }
    }
    
CommonReturn:

    dwErr = GetLastError();
    
    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszDirOrFileFrom != NULL)
    {
        free(pwszDirOrFileFrom);
    }

    if (pwszDirOrFileTo != NULL)
    {
        free(pwszDirOrFileTo);
    }

    if (hFindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(hFindHandle);
    }

    SetLastError(dwErr);

    return (fResult);

ErrorReturn:

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ErrorMemory, ERROR_NOT_ENOUGH_MEMORY)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindFirstFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorCopyFile)
TRACE_ERROR_EX(DBG_SS_TRUST, ErrorFindNextFile)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\list.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       list.cpp
//
//  Contents:   list helper functions.
//
//  History:    27-Nov-96   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"



//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
BOOL CList::InsertHead( CNode *pn)
{
    if (pn == NULL)
        return FALSE;

    pn->SetPrev( NULL);
    pn->SetNext( m_pnHead);
    if (m_pnHead)
        m_pnHead->SetPrev( pn);
    else
        m_pnTail = pn;              // list was empty
    m_pnHead = pn;
    m_cNode++;
    return TRUE;
};


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
BOOL CList::InsertTail( CNode *pn)
{
    if (pn == NULL)
        return FALSE;

    pn->SetPrev( m_pnTail);
    pn->SetNext( NULL);
    if (m_pnTail)
        m_pnTail->SetNext( pn);
    else
        m_pnHead = pn;              // list was empty
    m_pnTail = pn;
    m_cNode++;
    return TRUE;
};


//--------------------------------------------------------------------------
// Remove node from the list. Do not delete the node.
//--------------------------------------------------------------------------
BOOL CList::Remove( CNode *pn)
{
    if (pn == NULL)
        return FALSE;

    CNode *pnPrev = pn->Prev();
    CNode *pnNext = pn->Next();

    if (pnPrev)
        pnPrev->SetNext( pnNext);

    if (pnNext)
        pnNext->SetPrev( pnPrev);

    if (pn == m_pnHead)
        m_pnHead = pnNext;

    if (pn == m_pnTail)
        m_pnTail = pnPrev;

    m_cNode--;
    return TRUE;
};


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
CNode * CList::Nth( DWORD i)
{
    CNode *pn;

    if (i >= m_cNode)
        return NULL;

    for (pn = m_pnHead;
            (i>0) && pn;
            i--, pn=pn->Next())
        ;

    return pn;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\new.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       new.cpp
//
//  Contents:   new and delete operators.
//
//  History:    16-Jan-97   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
extern void * __cdecl operator new(
    IN size_t cb)
{
    void *pv;
    if (NULL == (pv = malloc(cb)))
        goto mallocError;
ErrorReturn:
    return pv;
SET_ERROR(mallocError,ERROR_NOT_ENOUGH_MEMORY)
}

void __cdecl operator delete(
    IN void *pv)
{
    if (pv)
        free(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\pkicrit.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkicrit.cpp
//
//  Contents:   PKI CriticalSection Functions
//
//  Functions:  Pki_InitializeCriticalSection
//
//  History:    23-Aug-99    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"

BOOL
WINAPI
Pki_InitializeCriticalSection(
    OUT LPCRITICAL_SECTION lpCriticalSection
    )
{
    __try {
        InitializeCriticalSection(lpCriticalSection);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        memset(lpCriticalSection, 0, sizeof(*lpCriticalSection));
        SetLastError(GetExceptionCode());
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\pkiasn1.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkiasn1.cpp
//
//  Contents:   PKI ASN.1 support functions.
//
//  Functions:  PkiAsn1Encode
//              PkiAsn1Decode
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1SetBitStringWithoutTrailingZeroes
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfoEx
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  According to the <draft-ietf-pkix-ipki-part1-10.txt> :
//      For UTCTime. Where YY is greater than or equal to 50, the year shall
//      be interpreted as 19YY. Where YY is less than
//      50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define MSASN1_SUPPORTS_NOCOPY  1


//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater or equal than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1950
#define YEARLAST                2049
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    Asn1Err = ASN1_Encode(
        pEnc,
        pvAsn1Info,
        id,
        ASN1ENCODE_ALLOCATEBUFFER,
        NULL,                       // pbBuf
        0                           // cbBufSize
        );

    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded = pEnc->buf;
        *pcbEncoded = pEnc->len;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_ALLOCATEBUFFER,
            NULL,                       // pbBuf
            0                           // cbBufSize
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            if (pbEncoded)
                Asn1Err = ASN1_ERR_OVERFLOW;
            else
                Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
            PkiAsn1FreeEncoded(pEnc, pEnc->buf);
        }
    } else {
        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_SETBUFFER,
            pbEncoded,
            cbEncoded
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
        } else if (ASN1_ERR_OVERFLOW == Asn1Err) {
            // Re-do as length only calculation
            Asn1Err = PkiAsn1Encode2(
                pEnc,
                pvAsn1Info,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (ASN1_SUCCESS == Asn1Err)
                Asn1Err = ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        (BYTE *) pbEncoded,
        cbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err))
        Asn1Err = ASN1_SUCCESS;
    else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        *ppbEncoded,
        *pcbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded += pDec->len;
        *pcbEncoded -= pDec->len;
    } else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ASN1optionparam_s OptParam;

    OptParam.eOption = ASN1OPT_CHANGE_RULE;
    OptParam.eRule = eRule;

    return ASN1_SetEncoderOption(pEnc, &OptParam);
}

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ASN1error_e Asn1Err;
    ASN1encodingrule_e eRule;
    ASN1optionparam_s OptParam;
    OptParam.eOption = ASN1OPT_GET_RULE;

    Asn1Err = ASN1_GetEncoderOption(pEnc, &OptParam);
    if (ASN1_SUCCEEDED(Asn1Err))
        eRule = OptParam.eRule;
    else
        eRule = ASN1_BER_RULE_DER;

    return eRule;
}


//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    if (0 == cbIn)
        return;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)PkiAsn1Alloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1Length;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) Asn1Length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1Value, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  For PkiAsn1SetHugeInteger, PkiAsn1FreeHugeInteger must be called to free
//  the allocated Asn1Value.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppAsn1Value = PkiAsn1AllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pAsn1Length = 0;
            return FALSE;
        }
    } else
        *ppAsn1Value = NULL;
    *pAsn1Length = pInfo->cbData;
    return TRUE;
}

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        )
{
    // Only for BYTE reversal
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    PkiAsn1GetOctetString(Asn1Length, pAsn1Value, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        PkiAsn1ReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by ASN1 before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated Asn1Value.
//  PkiAsn1FreeHugeUINT has been #define'd to PkiAsn1FreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) PkiAsn1Alloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pAsn1Length = cb;
    *ppAsn1Value = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
PkiAsn1GetHugeUINT(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (Asn1Length > 1 && *pAsn1Value == 0) {
        pAsn1Value++;
        Asn1Length--;
    }
    PkiAsn1GetHugeInteger(
        Asn1Length,
        pAsn1Value,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData) {
        *ppAsn1Value = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pAsn1BitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppAsn1Value = NULL;
        *pAsn1BitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (Asn1BitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1BitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) Asn1BitLength / 8;
        cUnusedBits = Asn1BitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pAsn1Value, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    DWORD cbData;
    DWORD cUnusedBits;

    cbData = pInfo->cbData;
    cUnusedBits = pInfo->cUnusedBits;
    assert(cUnusedBits <= 7);

    if (cbData) {
        BYTE *pb;

        // Until we find a nonzero byte (starting with the last byte),
        // decrement cbData. For the last byte don't look at any unused bits.
        pb = pInfo->pbData + cbData - 1;
        if (0 == (*pb & rgbUnusedAndMask[cUnusedBits])) {
            cUnusedBits = 0;
            cbData--;
            pb--;

            for ( ; 0 < cbData && 0 == *pb; cbData--, pb--)
                ;
        }
    }

    if (cbData) {
        BYTE b;

        // Determine the number of unused bits in the last byte. Treat any
        // trailing zeroes as unused.
        b = *(pInfo->pbData + cbData - 1);
        assert(b);
        if (cUnusedBits)
            b = (BYTE) (b >> cUnusedBits);
        
        for (; 7 > cUnusedBits && 0 == (b & 0x01); cUnusedBits++) {
            b = b >> 1;
        }
        assert(b & 0x01);
        assert(cUnusedBits <= 7);

        *ppAsn1Value = pInfo->pbData;
        *pAsn1BitLength = cbData * 8 - cUnusedBits;
    } else {
        *ppAsn1Value = NULL;
        *pAsn1BitLength = 0;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pAsn1Length = 0;
        *ppAsn1Value = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pAsn1Length = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) PkiAsn1Alloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppAsn1Value = psz;
    *pAsn1Length = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pAsn1Length = 0;
InvalidIA5:
    *ppAsn1Value = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        )
{
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pAsn1Value,
        Asn1Length,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pAsn1Value, Asn1Length,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    pAsn1->encoded = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pAsn1->length;
            pInfo->pbData = (BYTE *) pAsn1->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pAsn1->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}


//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        BYTE *pbEncoded;
        BYTE *pbAllocEncoded;
        PFN_CRYPT_ALLOC pfnAlloc;

        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode(
            pEnc,
            pvAsn1Info,
            id,
            &pbEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            *((void **) pvEncoded) = NULL;
            goto Asn1EncodeError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbAllocEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            PkiAsn1FreeEncoded(pEnc, pbEncoded);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        *((BYTE **) pvEncoded) = pbAllocEncoded;
        PkiAsn1FreeEncoded(pEnc, pbEncoded);
    } else {
        cbEncoded = *pcbEncoded;
        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode2(
            pEnc,
            pvAsn1Info,
            id,
            (BYTE *) pvEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            if (ASN1_ERR_OVERFLOW == Asn1Err)
                goto LengthError;
            else
                goto Asn1EncodeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(Asn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        pEnc,
        id,
        pvAsn1Info,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Decode(
            pDec,
            ppvAsn1Info,
            id,
            pbEncoded,
            cbEncoded
            )))
        goto Asn1DecodeError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvAsn1Info = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
}


//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvAsn1Info,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvAsn1Info,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvAsn1Info = NULL;

    if (!PkiAsn1DecodeAndAllocInfo(
            pDec,
            id,
            pbEncoded,
            cbEncoded,
            &pvAsn1Info
            )) goto Asn1DecodeError;

    fResult = PkiAsn1AllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    PkiAsn1FreeInfo(pDec, id, pvAsn1Info);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1DecodeError)
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        ASN1uint16_t cMax = *pCount;
        ASN1uint32_t *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (ASN1uint32_t)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        ASN1uint32_t *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN ASN1int16_t mindiff,
    IN ASN1bool_t utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = (short)( mindiff > 0 ? mindiff : -mindiff );
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }

    // Note, FILETIME is only 32 bit aligned. __int64 is 64 bit aligned.
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        unsigned __int64 uTime;
        unsigned __int64 uDiff;

        memcpy(&uTime, pFileTime, sizeof(uTime));
        memcpy(&uDiff, &ftmDiff, sizeof(uDiff));

        if (mindiff > 0)
            uTime += uDiff;
        else
            uTime -= uDiff;

        memcpy(pFileTime, &uTime, sizeof(*pFileTime));
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pAsn1Time->year   = (ASN1uint8_t) (t.wYear % 100);
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->universal = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = (WORD)( pAsn1Time->year >= MAGICYEAR ?
                    (1900 + pAsn1Time->year) : (2000 + pAsn1Time->year) );
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pAsn1Time->year   = t.wYear;
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->millisecond = t.wMilliseconds;
    pAsn1Time->universal    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pAsn1Time->year;
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;
    t.wMilliseconds = pAsn1Time->millisecond;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = PKI_ASN1_GENERALIZED_TIME_CHOICE;
        memset(pGeneralTime, 0, sizeof(*pGeneralTime));
        pGeneralTime->year   = t.wYear;
        pGeneralTime->month  = (ASN1uint8_t) t.wMonth;
        pGeneralTime->day    = (ASN1uint8_t) t.wDay;
        pGeneralTime->hour   = (ASN1uint8_t) t.wHour;
        pGeneralTime->minute = (ASN1uint8_t) t.wMinute;
        pGeneralTime->second = (ASN1uint8_t) t.wSecond;
        pGeneralTime->universal    = TRUE;
    } else {
        *pwChoice = PKI_ASN1_UTC_TIME_CHOICE;
        memset(pUtcTime, 0, sizeof(*pUtcTime));
        pUtcTime->year = (ASN1uint8_t) (t.wYear % 100);
        pUtcTime->month  = (ASN1uint8_t) t.wMonth;
        pUtcTime->day    = (ASN1uint8_t) t.wDay;
        pUtcTime->hour   = (ASN1uint8_t) t.wHour;
        pUtcTime->minute = (ASN1uint8_t) t.wMinute;
        pUtcTime->second = (ASN1uint8_t) t.wSecond;
        pUtcTime->universal    = TRUE;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    memset(pGeneralTime, 0, sizeof(*pGeneralTime));
    memset(pUtcTime, 0, sizeof(*pUtcTime));
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    if (PKI_ASN1_UTC_TIME_CHOICE == wChoice) {
        return PkiAsn1FromUTCTime(pUtcTime, pFileTime);
    } else
        return PkiAsn1FromGeneralizedTime(pGeneralTime, pFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\utf8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       utf8.cpp
//
//  Contents:   WideChar to/from UTF8 APIs
//
//  Functions:  WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//              28-Aug-99   philh   added surrogate support. Copied from
//                                  nt\private\windows\winnls\utf.c or
//                                  \\rastaman\ntwin\src\winnls\utf.c.
//                                  
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "utf8.h"

#if 1

// NEW SURROGATE VERSION

//
//  Constant Declarations.
//

#define ASCII                 0x007f

#define SHIFT_IN              '+'     // beginning of a shift sequence
#define SHIFT_OUT             '-'     // end       of a shift sequence

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
//  03-20-99    SamerA    Surrogate support.
////////////////////////////////////////////////////////////////////////////

int
WINAPI
UTF8ToWideChar(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar = 0;     // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    char UTF8;

// BEGIN ADDED CHECKS
    if (cchDest < 0)
        goto InvalidParameter;

    if (cchSrc < 0)
        cchSrc = strlen(lpSrcStr) + 1;
// END ADDED CHECKS

    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {

// BEGIN FIX
            if (nTB != 0)
                goto InvalidParameter;
// END FIX

            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            bSurrogatePair = FALSE;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
// BEGIN FIX
                            else
                            {
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }
// END FIX
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                // error - not expecting a trail byte
// BEGIN FIX
//                bSurrogatePair = FALSE;

                goto InvalidParameter;
// END FIX
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
// BEGIN FIX
//                nTB = 0;
//                bSurrogatePair = FALSE;
//                cchWC++;

                goto InvalidParameter;
// END FIX
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // If this is a surrogate unicode pair
                //
                if (nTB == 4)
                {
                    dwSurrogateChar = UTF8 >> nTB;
                    bSurrogatePair = TRUE;
                }
// BEGIN FIX
                else if (nTB >= 5)
                {
                    goto InvalidParameter;
                }
// END FIX

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = (WCHAR) (UTF8 >> nTB);
                }
                nTB--;
            }
        }

        pUTF8++;
    }

// BEGIN FIX
    if (nTB != 0)
        goto InvalidParameter;
// END FIX

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);

// BEGIN FIX
InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return (0);
// END FIX
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
//  03-20-99    SamerA    Surrogate support.
////////////////////////////////////////////////////////////////////////////

int
WINAPI
WideCharToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;

// BEGIN ADDED CHECKS
    if (cchDest < 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    if (cchSrc < 0)
        cchSrc = wcslen(lpSrcStr) + 1;
// END ADDED CHECKS

    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate));
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate));
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    lpDestStr[cchU8] = (char)*lpWC;
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_2 | (*lpWC >> 6));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(*lpWC));
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC));
                        lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(*lpWC));
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = (char) (UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate));
                lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate));
                lpDestStr[cchU8++] = (char) (UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate));
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}

#else

// OLD IMPLEMENTATION NOT SUPPORTING SURROGATE PAIRS

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    )
{
    int cchRemainUTF8;

    if (cchUTF8 < 0)
        goto InvalidParameter;
    cchRemainUTF8 = cchUTF8;

    if (cchWideChar < 0)
        cchWideChar = wcslen(lpWideCharStr) + 1;

    while (cchWideChar--) {
        WCHAR wch = *lpWideCharStr++;
        if (wch <= 0x7F) {
            // 7 bits
            cchRemainUTF8 -= 1;
            if (cchRemainUTF8 >= 0)
                *lpUTF8Str++ = (char) wch;
        } else if (wch <= 0x7FF) {
            // 11 bits
            cchRemainUTF8 -= 2;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xC0 | ((wch >> 6) & 0x1F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        } else {
            // 16 bits
            cchRemainUTF8 -= 3;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xE0 | ((wch >> 12) & 0x0F));
                *lpUTF8Str++ = (char) (0x80 | ((wch >> 6) & 0x3F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        }
    }

    if (cchRemainUTF8 >= 0)
        cchUTF8 = cchUTF8 - cchRemainUTF8;
    else if (cchUTF8 == 0)
        cchUTF8 = -cchRemainUTF8;
    else {
        cchUTF8 = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchUTF8;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int cchRemainWideChar;

    if (cchWideChar < 0)
        goto InvalidParameter;
    cchRemainWideChar = cchWideChar;

    if (cchUTF8 < 0)
        cchUTF8 = strlen(lpUTF8Str) + 1;

    while (cchUTF8--) {
        char ch = *lpUTF8Str++;
        WCHAR wch;
        if (0 == (ch & 0x80))
            // 7 bits, 1 byte
            wch = (WCHAR) ch;
        else if (0xC0 == (ch & 0xE0)) {
            // 11 bits, 2 bytes
            char ch2;

            if (--cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x1F) << 6) | ((WCHAR) ch2 & 0x3F);
        } else if (0xE0 == (ch & 0xF0)) {
            // 16 bits, 3 bytes
            char ch2;
            char ch3;
            cchUTF8 -= 2;
            if (cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            ch3 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0) || 0x80 != (ch3 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x0F) << 12) | (((WCHAR) ch2 & 0x3F) << 6) |
                ((WCHAR) ch3 & 0x3F);
        } else
            goto InvalidParameter;

        if (--cchRemainWideChar >= 0)
            *lpWideCharStr++ = wch;
    }

    if (cchRemainWideChar >= 0)
        cchWideChar = cchWideChar - cchRemainWideChar;
    else if (cchWideChar == 0)
        cchWideChar = -cchRemainWideChar;
    else {
        cchWideChar = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchWideChar;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\pkistr.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkistr.cpp
//
//  Contents:   PKI String Functions
//
//  Functions:  Pki_wcsicmp
//              Pki_wcsnicmp
//              Pki_stricmp
//              Pki_strnicmp
//
//  History:    21-May-99    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#define NO_LOCALE MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)


//+-------------------------------------------------------------------------
//  CompareString is called with the following locale:
//      MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
//--------------------------------------------------------------------------
int __cdecl Pki_wcsicmp(const wchar_t *pwsz1, const wchar_t *pwsz2)
{
    return CompareStringU(
            NO_LOCALE,
            NORM_IGNORECASE,
            pwsz1,
            -1,
            pwsz2,
            -1) - CSTR_EQUAL;
}

int __cdecl Pki_wcsnicmp(const wchar_t *pwsz1, const wchar_t *pwsz2,
                    size_t cch)
{
    const wchar_t *pwsz;

    size_t cch1;
    size_t cch2;


    for (cch1 = 0, pwsz = pwsz1; cch1 < cch && L'\0' != *pwsz; cch1++, pwsz++)
        ;
    for (cch2 = 0, pwsz = pwsz2; cch2 < cch && L'\0' != *pwsz; cch2++, pwsz++)
        ;

    return CompareStringU(
            NO_LOCALE,
            NORM_IGNORECASE,
            pwsz1,
            (int) cch1,
            pwsz2,
            (int) cch2) - CSTR_EQUAL;
}

int __cdecl Pki_stricmp(const char *psz1, const char *psz2)
{
    return CompareStringA(
            NO_LOCALE,
            NORM_IGNORECASE,
            psz1,
            -1,
            psz2,
            -1) - CSTR_EQUAL;
}

int __cdecl Pki_strnicmp(const char *psz1, const char *psz2,
                    size_t cch)
{
    const char *psz;

    size_t cch1;
    size_t cch2;


    for (cch1 = 0, psz = psz1; cch1 < cch && '\0' != *psz; cch1++, psz++)
        ;
    for (cch2 = 0, psz = psz2; cch2 < cch && '\0' != *psz; cch2++, psz++)
        ;

    return CompareStringA(
            NO_LOCALE,
            NORM_IGNORECASE,
            psz1,
            (int) cch1,
            psz2,
            (int) cch2) - CSTR_EQUAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\pkialloc.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pkialloc.cpp
//
//  Contents:   PKI Allocation Functions
//
//  Functions:  PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = malloc(cbBytes)))
#else
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
#if DBG
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    else
        memset(pv, 0, cbBytes);
#else
    // LPTR (OR includes ZEROINIT)
    pv = (LPVOID) LocalAlloc(LPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
#endif
    return pv;
}

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
#if DBG
    pv = malloc(cbBytes);
#else
    pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes);
#endif
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
#else
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    )
{
    if (pv)
#if DBG
        free(pv);
#else
        LocalFree((HLOCAL)pv);
#endif
}

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN size_t cbSize
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbSize)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL) pv);
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_ENCODE_PARA PkiEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(PkiEncodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};


//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnAlloc) +
                sizeof(pEncodePara->pfnAlloc) &&
            pEncodePara->pfnAlloc)
        return pEncodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnFree) +
                sizeof(pEncodePara->pfnFree) &&
            pEncodePara->pfnFree)
        return pEncodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_DECODE_PARA PkiDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(PkiDecodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnAlloc) +
                sizeof(pDecodePara->pfnAlloc) &&
            pDecodePara->pfnAlloc)
        return pDecodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnFree) +
                sizeof(pDecodePara->pfnFree) &&
            pDecodePara->pfnFree)
        return pDecodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pkiutil\voidlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       voidlist.cpp
//
//  Contents:   list functions
//
//  History:    01-Jan-2000 reidk created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "voidlist.h"


void
LIST_Initialize(LIST *pList)
{
    pList->pHead = NULL;
    pList->pTail = NULL;
    pList->dwNumNodes = 0;
}


PLIST_NODE
LIST_AddHead(LIST *pList, void *pElement)
{
    LIST_NODE *pListNode = NULL;

    if (NULL == (pListNode = (PLIST_NODE) malloc(sizeof(LIST_NODE))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // empty list
    if (pList->pHead == NULL)
    {
        pList->pHead = pList->pTail = pListNode;
        pListNode->pNext = NULL;
    }
    else
    {
        pListNode->pNext = pList->pHead;
        pList->pHead = pListNode;
    }

    pList->dwNumNodes++;
    
    pListNode->pElement = pElement;
    
    return(pListNode);
}

PLIST_NODE
LIST_AddTail(LIST *pList, void *pElement)
{
    LIST_NODE *pListNode = NULL;

    if (NULL == (pListNode = (PLIST_NODE) malloc(sizeof(LIST_NODE))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // empty list
    if (pList->pTail == NULL)
    {
        pList->pHead = pList->pTail = pListNode;
    }
    else
    {
        pList->pTail->pNext = pListNode;
        pList->pTail = pListNode;
    }

    pList->dwNumNodes++;
    
    pListNode->pNext = NULL;
    pListNode->pElement = pElement;
    
    return(pListNode);
}


BOOL
LIST_RemoveElement(LIST *pList, void *pElement)
{
    LIST_NODE *pListNodeToDelete = pList->pHead;
    LIST_NODE *pPrevListNode = pList->pHead;

    // empty list
    if (pListNodeToDelete == NULL)
    {
        return FALSE;
    }

    // remove head
    if (pListNodeToDelete->pElement == pElement)
    {
        // one element
        if (pList->pHead == pList->pTail)
        {
            pList->pHead = pList->pTail = NULL;
        }
        else
        {
            pList->pHead = (PLIST_NODE) pListNodeToDelete->pNext;
        }
    }
    else
    {
        pListNodeToDelete = (PLIST_NODE) pListNodeToDelete->pNext;

        while ( (pListNodeToDelete != NULL) && 
                (pListNodeToDelete->pElement != pElement))
        {
            pPrevListNode = pListNodeToDelete;
            pListNodeToDelete = (PLIST_NODE) pListNodeToDelete->pNext;            
        }

        if (pListNodeToDelete == NULL)
        {
            return FALSE;
        }

        pPrevListNode->pNext = pListNodeToDelete->pNext;

        // removing tail
        if (pList->pTail == pListNodeToDelete)
        {
            pList->pTail = pPrevListNode;
        }
    }

    pList->dwNumNodes--;

    free(pListNodeToDelete);

    return(TRUE);
}


BOOL
LIST_RemoveAll(LIST *pList)
{
    LIST_NODE *pListNodeToDelete = pList->pHead;
    LIST_NODE *pNextListNode = NULL;

    while (pListNodeToDelete != NULL)
    {
        pNextListNode = (PLIST_NODE) pListNodeToDelete->pNext;
        free(pListNodeToDelete);
        pListNodeToDelete = pNextListNode;
    }

    pList->pHead = pList->pTail = NULL;
    pList->dwNumNodes = 0;

    return(TRUE);
}


PLIST_NODE
LIST_GetFirst(LIST *pList)
{
    return(pList->pHead);
}


PLIST_NODE
LIST_GetNext(PLIST_NODE pNode)
{
    return((PLIST_NODE) pNode->pNext);
}


void *
LIST_GetElement(PLIST_NODE pNode)
{
    return(pNode->pElement);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pvkhlpr\pvk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pvk.h
//
//  Contents:   Shared types and functions
//              
//  APIs:
//
//  History:    12-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __PVK_H__
#define __PVK_H__

#include "pvkhlpr.h"
#include "pvkdlgs.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Pvk allocation and free routines
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    );
void PvkFree(
    IN void *pv
    );


//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
enum PASSWORD_TYPE {
    ENTER_PASSWORD = 0,
    CREATE_PASSWORD
};

int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pvkhlpr\pvkdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkdlg.cpp
//
//  Contents:   Private Key Dialog Box APIs.
//
//  Functions:  PvkDlgGetKeyPassword
//
//  History:    12-May-96   philh created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include "pvk.h"


// ENTER_PASSWORD:
//  IDC_PASSWORD0 - Password

// CREATE_PASSWORD:
//  IDC_PASSWORD0 - Password
//  IDC_PASSWORD1 - Confirm Password


typedef struct _KEY_PASSWORD_PARAM {
    PASSWORD_TYPE   PasswordType;
    LPWSTR          pwszKey;           // IDC_KEY
    LPSTR           *ppszPassword;
} KEY_PASSWORD_PARAM, *PKEY_PASSWORD_PARAM;


// Where to get the dialog resources from
static HINSTANCE hPvkInst;

// Forward reference to local functions
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            );

static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            );

extern
BOOL
WINAPI
UnicodeDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        hPvkInst = hInstDLL;
        break;
    case DLL_PROCESS_DETACH:
        break;
    }

    return UnicodeDllMain( hInstDLL, fdwReason, lpvReserved);
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            )
{
    int nResult;
    LPSTR pszPassword = NULL;
    KEY_PASSWORD_PARAM KeyPasswordParam = {
        PasswordType,
        (LPWSTR) pwszKeyName,
        &pszPassword
    };

    LPCSTR pszTemplate = PasswordType == ENTER_PASSWORD ?
        MAKEINTRESOURCE(IDD_ENTERKEYPASSWORD) :
        MAKEINTRESOURCE(IDD_CREATEKEYPASSWORD);

    nResult = (BOOL)DialogBoxParam(
        hPvkInst,
        pszTemplate,
        hwndOwner,
        KeyPasswordDlgProc,
        (LPARAM) &KeyPasswordParam
        );

    *ppbPassword = (BYTE *) pszPassword;
    if (pszPassword)
        *pcbPassword = strlen(pszPassword);
    else
        *pcbPassword = 0;

    return nResult;
}

//+-------------------------------------------------------------------------
//  Allocate and get the password(s) from the dialog box
//
//  For no password input, returns NULL
//  pointer for the password. Otherwise, the password is PvkAlloc'ed.
//--------------------------------------------------------------------------
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            )
{
    LPSTR rgpszPassword[2] = {NULL, NULL};

    *ppszPassword = NULL;

    // Get the entered password(s)
    assert(PasswordType < 2);
    int i;
    for (i = 0; i <= PasswordType; i++) {
        LONG cchPassword;
        cchPassword = (LONG)SendDlgItemMessage(
            hwndDlg,
            IDC_PASSWORD0 + i,
            EM_LINELENGTH,
            (WPARAM) 0,
            (LPARAM) 0
            );
        if (cchPassword > 0) {
            rgpszPassword[i] = (LPSTR) PvkAlloc(cchPassword + 1);
            assert(rgpszPassword[i]);
            if (rgpszPassword[i])
                GetDlgItemText(
                    hwndDlg,
                    IDC_PASSWORD0 + i,
                    rgpszPassword[i],
                    cchPassword + 1
                    );
        }
    }

    if (PasswordType == ENTER_PASSWORD) {
        *ppszPassword = rgpszPassword[0];
        return IDOK;
    }

    int nResult = IDOK;
#define MSG_BOX_TITLE_LEN 128
    char szMsgBoxTitle[MSG_BOX_TITLE_LEN];
    GetWindowText(hwndDlg, szMsgBoxTitle, MSG_BOX_TITLE_LEN);

    if (rgpszPassword[0] == NULL && rgpszPassword[1] == NULL) {
        // Didn't enter a password
        nResult = MessageBox(
            hwndDlg,
            "Without password protection ?",
            szMsgBoxTitle,
            MB_YESNOCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2
            );
        if (nResult == IDYES)
            nResult = IDOK;
        else if (nResult == IDNO)
            nResult = IDRETRY;
    } else if (rgpszPassword[0] == NULL || rgpszPassword[1] == NULL ||
               strcmp(rgpszPassword[0], rgpszPassword[1]) != 0) {
        // Confirmed password didn't match
        nResult = MessageBox(
            hwndDlg,
            "Confirm password doesn't match",
            szMsgBoxTitle,
            MB_RETRYCANCEL | MB_ICONEXCLAMATION
            );
        if (nResult == IDRETRY) {
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 0, "");
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 1, "");
        }
    }

    if (nResult == IDOK)
        *ppszPassword = rgpszPassword[0];
    else if (rgpszPassword[0])
        PvkFree(rgpszPassword[0]);
    if (rgpszPassword[1])
        PvkFree(rgpszPassword[1]);

    if (nResult == IDRETRY)
        SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD0));
    return nResult;
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password DialogProc
//--------------------------------------------------------------------------
static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            )
{
    switch (uMsg) {
        case WM_INITDIALOG:
        {
            PKEY_PASSWORD_PARAM pKeyPasswordParam =
                (PKEY_PASSWORD_PARAM) lParam;

            char sz[128];
            WideCharToMultiByte(CP_ACP, 0, pKeyPasswordParam->pwszKey, -1,
                (LPSTR) sz, 128, NULL, NULL);

            SetDlgItemText(hwndDlg, IDC_KEY, sz);
            SetWindowLongPtr(hwndDlg, DWLP_USER, (ULONG_PTR)pKeyPasswordParam);
            return TRUE;
        }
        case WM_COMMAND:
            int nResult = LOWORD(wParam);
            switch (nResult) {
                case IDOK:
                {
                    PKEY_PASSWORD_PARAM pKeyPasswordParam =
                        (PKEY_PASSWORD_PARAM) GetWindowLongPtr(hwndDlg, DWLP_USER);

                    nResult = GetPassword(
                        hwndDlg,
                        pKeyPasswordParam->PasswordType,
                        pKeyPasswordParam->ppszPassword
                        );
                    if (nResult != IDRETRY)
                        EndDialog(hwndDlg, nResult);
                    return TRUE;
                }
                    break;
                case IDC_NONE:
                    nResult = IDOK;     // *ppszPassword == NULL
                    // Fall through
                case IDCANCEL:
                    EndDialog(hwndDlg, nResult);
                    return TRUE;
            }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\trans\cliiis\httptran.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       httptran.h
//
//--------------------------------------------------------------------------


#define TRANREAD	1
#define TRANWRITE	2

typedef DWORD	HTRAN;

extern "C" STTERR HttpOpen(HTRAN * phTran, const TCHAR * tszBinding, DWORD fOpen);
extern "C" STTERR HttpSend(HTRAN hTran, DWORD cbSendBuff, const BYTE * pbSendBuff);
extern "C" STTERR HttpFree(HTRAN hTran, BYTE * pb);
extern "C" STTERR HttpReceive(HTRAN hTran, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff);
extern "C" STTERR HttpClose(HTRAN hTran);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pvkhlpr\pvkdlgs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pvkdlgs.h
//
//--------------------------------------------------------------------------

#define IDC_PASSWORD0               501
#define IDC_PASSWORD1               502
#define IDC_KEY                     504
#define IDC_NONE                    505
#define IDD_ENTERKEYPASSWORD        530
#define IDD_CREATEKEYPASSWORD       540
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pvkhlpr\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pvkdlg.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\trans\srviis\bgihttp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       bgihttp.cxx
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <stdio.h>
#include "httpext.h"
#include "gttran.h"

typedef struct _GPT {
    HINSTANCE       hLib;
    PFNGTRecSend    PfnRecSend;
    PFNGTFree       PfnFree;
} GPT;

static GPT  gpt;

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO  *pVer )
{
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR,
                                         HSE_VERSION_MAJOR );
    lstrcpyn( pVer->lpszExtensionDesc,
              "This is a sample Web Server Application",
               HSE_MAX_EXT_DLL_NAME_LEN );
    return TRUE;
}

DWORD WINAPI   HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB) {

    DWORD   cb = 0;
    BYTE *  pb = NULL;
    TCHAR   tszBuff[1024];
    DWORD   cbBuff;
    DWORD   dwEncodingType;
    TCHAR * tszContentType;

    // assume an error
    pECB->dwHttpStatusCode = 500;

    if(!_tcscmp(TEXT("application/x-octet-stream-asn"), pECB->lpszContentType))
        dwEncodingType = ASN_ENCODING;
    else if(!_tcscmp(TEXT("application/x-octet-stream-idl"), pECB->lpszContentType))
        dwEncodingType = IDL_ENCODING;
    else if(!_tcscmp(TEXT("application/x-octet-stream-tlv"), pECB->lpszContentType))
        dwEncodingType = TLV_ENCODING;
    else if(!_tcscmp(TEXT("application/octet-stream"), pECB->lpszContentType))
        dwEncodingType = OCTET_ENCODING;
    else
        dwEncodingType = ASCII_ENCODING;

    if(dwEncodingType == ASCII_ENCODING)
        tszContentType = TEXT("text/html");
    else
        tszContentType = pECB->lpszContentType;
    
    // only do it if we can.
    if(gpt.PfnRecSend == NULL || gpt.PfnFree == NULL)
        return(HSE_STATUS_ERROR);

    // call the user dlls with the data
    if( gpt.PfnRecSend(dwEncodingType, pECB->cbTotalBytes, pECB->lpbData, &cb, &pb) != ERROR_SUCCESS)
        return(HSE_STATUS_ERROR);

    // we are ok now
    pECB->dwHttpStatusCode = 200;

    // write any return data
    if( cb > 0 ) {
        assert( pb != NULL);

        // write headers
        // we assume the only type of content type we support
        _stprintf(tszBuff, TEXT("Content-Length: %d\r\nContent-Type: %s\r\n\r\n"), cb, tszContentType);
        cbBuff = _tcslen(tszBuff);
        pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER, NULL, &cbBuff, (LPDWORD) tszBuff);

        // write users data
        pECB->WriteClient(pECB->ConnID, pb, &cb, 0);

        // free the users data
        gpt.PfnFree(pb);
    }

    // just write out the headers if no data returned
    else {

        // write headers
        pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER, NULL, NULL, NULL);
    }

    return(HSE_STATUS_SUCCESS);
}

// SHOULD ONLY BE CALLED DURING PROCESS ATTACH
DWORD __stdcall GTInitSrv(TCHAR * tszLibrary) {

    // this is only called on process attach
    // there is only one process attach
    assert(gpt.hLib == NULL);

    memset(&gpt, 0, sizeof(gpt));
    if( (gpt.hLib = LoadLibrary(tszLibrary)) == NULL )
        return(ERROR_DLL_NOT_FOUND);

    gpt.PfnRecSend = (PFNGTRecSend) GetProcAddress(gpt.hLib, TEXT("GTRecSend"));
    gpt.PfnFree    = (PFNGTFree) GetProcAddress(gpt.hLib, TEXT("GTFree"));

    if( gpt.PfnRecSend == NULL || gpt.PfnFree == NULL )  {
        FreeLibrary(gpt.hLib);
        memset(&gpt, 0, sizeof(GPT));
        return(ERROR_PROC_NOT_FOUND);
    }

    return(ERROR_SUCCESS);
}

// SHOULD ONLY BE CALLED DURING PROCESS DETACH
DWORD __stdcall GTUnInitSrv(void) {

    if(gpt.hLib != NULL)
        FreeLibrary(gpt.hLib);

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\pvkhlpr\pvkhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkhlpr.cpp
//
//  Contents:   Private Key Helper APIs
//
//  Functions:  PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>

#include "wincrypt.h"
#include "pvk.h"
#include "unicode.h"

#include <string.h>
#include <memory.h>

//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0
#define PVK_RC4_PASSWORD_ENCRYPT        1
#define PVK_RC2_CBC_PASSWORD_ENCRYPT    2

#define MAX_PVK_FILE_LEN            4096
#define MAX_BOB_FILE_LEN            (4096*4)

typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);



//+-------------------------------------------------------------------------
//  Private key helper allocation and free functions
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return pv;
}
void PvkFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Read  & Write to file function
//--------------------------------------------------------------------------
static BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}

static BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL) && cbBytesRead == cb);
}


//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL WriteToMemory(HANDLE h, void * p, DWORD cb) {

    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if(pMemInfo->cbSeek + cb <= pMemInfo->cb)
        // copy the bytes
        memcpy(&pMemInfo->pb[pMemInfo->cbSeek], p, cb);

    pMemInfo->cbSeek += cb;

    return(TRUE);
}

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

static BOOL GetPasswordKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN PASSWORD_TYPE PasswordType,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN BOOL fNoPassDlg,
    IN BYTE *pbSalt,
    IN DWORD cbSalt,
    OUT HCRYPTKEY *phEncryptKey
    )
{
    BOOL fResult;
    BYTE *pbAllocPassword = NULL;
    BYTE *pbPassword;
    DWORD cbPassword;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hEncryptKey = 0;
    BYTE rgbDefPw []    = { 0x43, 0x52, 0x41, 0x50 };
    DWORD cbDefPw       = sizeof(rgbDefPw);

    if (fNoPassDlg) {
        pbPassword = rgbDefPw;
        cbPassword = cbDefPw;
    } else {
        if (IDOK != PvkDlgGetKeyPassword(
                PasswordType,
                hwndOwner,
                pwszKeyName,
                &pbAllocPassword,
                &cbPassword
                )) {
            SetLastError(PVK_HELPER_PASSWORD_CANCEL);
            goto ErrorReturn;
        }
        pbPassword = pbAllocPassword;
    }

    if (cbPassword) {
        if (!CryptCreateHash(hProv, CALG_SHA, 0, 0, &hHash))
            goto ErrorReturn;
        if (cbSalt) {
            if (!CryptHashData(hHash, pbSalt, cbSalt, 0))
                goto ErrorReturn;
        }
        if (!CryptHashData(hHash, pbPassword, cbPassword, 0))
            goto ErrorReturn;
        if (!CryptDeriveKey(hProv, Algid, hHash, 0, &hEncryptKey))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
CommonReturn:
    if (pbAllocPassword)
        PvkFree(pbAllocPassword);
    if (hHash)
        CryptDestroyHash(hHash);
    *phEncryptKey = hEncryptKey;
    return fResult;
}

// Support backwards compatibility with Bob's storage file which contains
// a snap shot of the keys as they are stored in the registry. Note, for
// win95, the registry values are decrypted before being written to the file.
static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    );

static BOOL LoadKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hDecryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr))) goto BadPvkFile;
    if (Hdr.dwMagic != PVK_MAGIC)
        // Try to load as Bob's storage file containing streams for the
        // private and public keys. Bob made a copy of the cryptography
        // registry key values.
        //
        // Note, Bob now has two different formats for storing the private
        // key information. See LoadBobKey for details.
        fResult = LoadBobKey(hCryptProv, hRead, pfnRead, cbKeyData, hwndOwner,
            pwszKeyName, dwFlags, pdwKeySpec, &Hdr);
    else {
        // Treat as a "normal" private key file
        cbPvk = Hdr.cbPvk;
        if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
            Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
            cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
        goto BadPvkFile;
    
        if (pdwKeySpec) {
            DWORD dwKeySpec = *pdwKeySpec;
            *pdwKeySpec = Hdr.dwKeySpec;
            if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
                SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
                goto ErrorReturn;
            }
        }
    
        if (Hdr.cbEncryptData) {
            // Read the encrypt data
            if (NULL == (pbEncryptData = (BYTE *) PvkAlloc(Hdr.cbEncryptData)))
                goto ErrorReturn;
            if (!pfnRead(hRead, pbEncryptData, Hdr.cbEncryptData))
                goto BadPvkFile;
        }
    
        // Allocate and read the private key
        if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
            goto ErrorReturn;
        if (!pfnRead(hRead, pbPvk, cbPvk))
            goto BadPvkFile;
    
    
        // Get symmetric key to decrypt the private key
        switch (Hdr.dwEncryptType) {
            case PVK_NO_ENCRYPT:
                break;
            case PVK_RC4_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC4,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey))
                    goto ErrorReturn;
                break;
            case PVK_RC2_CBC_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC2,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey))
                    goto ErrorReturn;
                break;
            default:
                goto BadPvkFile;
        }

        // Decrypt and import the private key
        if (!CryptImportKey(hCryptProv, pbPvk, cbPvk, hDecryptKey, dwFlags,
                &hKey))
            goto ErrorReturn;

        fResult = TRUE;
    }
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbEncryptData)
        PvkFree(pbEncryptData);
    if (pbPvk)
        PvkFree(pbPvk);
    if (hDecryptKey)
        CryptDestroyKey(hDecryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL SaveKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hWrite,
    IN PFNREAD pfnWrite,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN BOOL fNoPassDlg
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hEncryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;     // Not allocated
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    BYTE rgbSalt[16];

    // Initialize the header record
    memset(&Hdr, 0, sizeof(Hdr));
    Hdr.dwMagic = PVK_MAGIC;
    Hdr.dwVersion = PVK_FILE_VERSION_0;
    Hdr.dwKeySpec = dwKeySpec;

    // Generate random salt
    if (!CryptGenRandom(hCryptProv, sizeof(rgbSalt), rgbSalt))
        goto ErrorReturn;

    // Get symmetric key to use to encrypt the private key
#if 1
    if (!GetPasswordKey(hCryptProv, CALG_RC4,
#else
    if (!GetPasswordKey(hCryptProv, CALG_RC2,
#endif
            CREATE_PASSWORD, hwndOwner, pwszKeyName,
            fNoPassDlg, rgbSalt, sizeof(rgbSalt), &hEncryptKey))
        goto ErrorReturn;
    if (hEncryptKey) {
#if 1
        Hdr.dwEncryptType = PVK_RC4_PASSWORD_ENCRYPT;
#else
        Hdr.dwEncryptType = PVK_RC2_CBC_PASSWORD_ENCRYPT;
#endif
        Hdr.cbEncryptData = sizeof(rgbSalt);
        pbEncryptData = rgbSalt;
    } else
        Hdr.dwEncryptType = PVK_NO_ENCRYPT;

    // Allocate, encrypt and export the private key
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
        goto ErrorReturn;
    cbPvk = 0;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, NULL,
            &cbPvk))
        goto ErrorReturn;
    if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
        goto ErrorReturn;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, pbPvk,
            &cbPvk))
        goto ErrorReturn;
    Hdr.cbPvk = cbPvk;


    // Write the header, optional encrypt data, and private key to the file
    if (!pfnWrite(hWrite, &Hdr, sizeof(Hdr)))
        goto ErrorReturn;
    if (Hdr.cbEncryptData) {
        if (!pfnWrite(hWrite, pbEncryptData, Hdr.cbEncryptData))
            goto ErrorReturn;
    }
    if (!pfnWrite(hWrite, pbPvk, cbPvk))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        PvkFree(pbPvk);
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from the file into the cryptographic provider.
//
//  If the private key was password encrypted, then, the user is first
//  presented with a dialog box to enter the password.
//
//  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
//  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
//  a mismatch. *pdwKeySpec is updated with the key type.
//
//  dwFlags is passed through to CryptImportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyLoad(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    return LoadKey(
        hCryptProv,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to the specified file.
//
//  The user is presented with a dialog box to enter an optional password to
//  encrypt the private key.
//
//  dwFlags is passed through to CryptExportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeySave(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags
    )
{
    return SaveKey(
        hCryptProv,
        hFile,
        WriteToFile,
        dwKeySpec,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        FALSE           // fNoPassDlg
        );
}

//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from memory into the cryptographic provider.
//
//  Except for the key being loaded from memory, identical to PrivateKeyLoad.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyLoadFromMemory(
    IN HCRYPTPROV hCryptProv,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return LoadKey(
        hCryptProv,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to memory.
//
//  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
//  return an error (also, the user isn't prompted for a password).
//
//  Except for the key being saved to memory, identical to PrivateKeySave.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeySaveToMemory(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    if (pbData == NULL)
        *pcbData = 0;
    MemInfo.cb = *pcbData;
    MemInfo.cbSeek = 0;

    if (fResult = SaveKey(
            hCryptProv,
            (HANDLE) &MemInfo,
            WriteToMemory,
            dwKeySpec,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            *pcbData == 0           // fNoPassDlg
            )) {
        if (MemInfo.cbSeek > MemInfo.cb && *pcbData) {
            fResult = FALSE;
            SetLastError(ERROR_END_OF_MEDIA);
        }
        *pcbData = MemInfo.cbSeek;
    } else
        *pcbData = 0;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(UUID) * 2 + 1) * sizeof(WCHAR))


static BOOL AcquireKeyContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    UUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;
    DWORD dwKeySpec;
    RPC_STATUS RpcStatus;

    // Create a temporary keyset to load the private key into
    RpcStatus = UuidCreate(&TmpContainerUuid);
    if (!(RPC_S_OK == RpcStatus || RPC_S_UUID_LOCAL_ONLY == RpcStatus)) {
        // Use stack randomness
        ;
    }

    if (NULL == (pwszTmpContainer = (LPWSTR) PvkAlloc(
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES)))
        goto ErrorReturn;
    wcscpy(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET
            ))
        goto ErrorReturn;

    if (!LoadKey(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    if (pwszTmpContainer) {
        PvkFree(pwszTmpContainer);
        pwszTmpContainer = NULL;
    }
    fResult = FALSE;

CommonReturn:
    *ppwszTmpContainer = pwszTmpContainer;
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from the specified file.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoad is called to load the private key into the temporary
//  container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyAcquireContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    return AcquireKeyContext(
        pwszProvName,
        dwProvType,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return AcquireKeyContext(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        PvkFree(pwszTmpContainer);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Functions supporting backwards compatibility with Bob's storage file
//  containing a snap shot of the keys as they are stored in the registry.
//  Note, for win95, the registry values are decrypted before being written to
//  the file.
//--------------------------------------------------------------------------

// Return the size of this stream; return 0 if an error
static DWORD CbBobSize(IStream *pStm)
{
    STATSTG stat;
    if (FAILED(pStm->Stat(&stat, STATFLAG_NONAME)))
        return 0;
    return stat.cbSize.LowPart;
}

// Allocate and read this value which has the indicated stream name from the
// storage
static BOOL LoadBobStream(
    IStorage *pStg,
    LPCWSTR pwszStm,
    BYTE **ppbValue,
    DWORD *pcbValue
    )
{
    BOOL fResult;
    HRESULT hr;
    IStream *pStm = NULL;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    DWORD cbRead;

    if (FAILED(hr = pStg->OpenStream(pwszStm, 0,
            STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStm)))
        goto HrError;

    if (0 == (cbValue = CbBobSize(pStm))) goto BadBobFile;

    if (NULL == (pbValue = (BYTE *) PvkAlloc(cbValue))) goto ErrorReturn;

    pStm->Read(pbValue, cbValue, &cbRead);
    if (cbRead != cbValue) goto BadBobFile;

    fResult = TRUE;
    goto CommonReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;
BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    if (pbValue) {
        PvkFree(pbValue);
        pbValue = NULL;
    }
    cbValue = 0;
    fResult = FALSE;
CommonReturn:
    if (pStm)
        pStm->Release();
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
}

// New "Bob" format::
//
// Allocate and read either the Exported Signature or Exchange Private 
// key stream from the storage
static BOOL LoadBobExportedPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"Exported Signature Private Key";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"Exported Exchange Private Key";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

// Old "Bob" format::
//
// Allocate and read either the Signature or Exchange Private
// key streams from the storage
static BOOL LoadBobOldPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"SPvk";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"EPvk";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

///////////////////////////////////////////////////////////////////////////////////////
//
// Key header structures for private key construction
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.
//
//    For more info see Jeff Spellman in the crypto team or look in the
//    source to RsaBase.Dll
//

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY, FAR *PEXPORT_PRV_KEY;

///////////////////////////////////////////////////////////////////////////////////////
//
//  Take a raw exported unshrowded private key from the registry and turn it
//  into a private key export blob.
//
//  This is based on the PreparePrivateKeyForExport routine from rsabase.dll
//
static BOOL ConstructPrivateKeyExportBlob(
        IN DWORD            dwKeySpec,
        IN BSAFE_PRV_KEY *  pPrvKey,            
        IN DWORD            PrvKeyLen,
        OUT PBYTE           *ppbBlob,
        OUT DWORD           *pcbBlob
        )
{
    BOOL fResult;
    PEXPORT_PRV_KEY pExportKey;
    DWORD           cbHalfModLen;
    PBYTE           pbBlob = NULL;
    DWORD           cbBlob;
    PBYTE           pbIn;
    PBYTE           pbOut;

    cbHalfModLen = pPrvKey->bitlen / 16;
    cbBlob = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen +
        sizeof(PUBLICKEYSTRUC);

    if (NULL == (pbBlob = (BYTE *) PvkAlloc(cbBlob))) {
        fResult = FALSE;
        cbBlob = 0;
    } else {
        BYTE* pb = pbBlob;
        PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pb;
        pPubKeyStruc->bType         = PRIVATEKEYBLOB;
        pPubKeyStruc->bVersion      = 2;
        pPubKeyStruc->reserved      = 0;
        if (dwKeySpec == AT_KEYEXCHANGE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        else if (dwKeySpec == AT_SIGNATURE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_SIGN;
        else
            pPubKeyStruc->aiKeyAlg = 0;

        pb = pbBlob + sizeof(PUBLICKEYSTRUC);

        // take most of the header info
        pExportKey = (PEXPORT_PRV_KEY)pb;
        pExportKey->magic  = pPrvKey->magic;
        pExportKey->bitlen = pPrvKey->bitlen;
        pExportKey->pubexp = pPrvKey->pubexp;

        pbIn = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);
        pbOut = pb + sizeof(EXPORT_PRV_KEY);

        // copy all the private key info
        memcpy(pbOut, pbIn, cbHalfModLen * 2);
        pbIn += (cbHalfModLen + sizeof(DWORD)) * 2;
        pbOut += cbHalfModLen * 2;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen * 2);

        fResult = TRUE;
    }
    *ppbBlob = pbBlob;
    *pcbBlob = cbBlob;
    return fResult;
}

static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    )
{
    BOOL fResult;
    DWORD dwErr = 0;
    HRESULT hr;
    HGLOBAL hGlobal = NULL;
    BYTE *pbBobKey;         // not allocated
    ILockBytes *pLkByt = NULL;
    IStorage *pStg = NULL;
    IStorage *pPrivStg = NULL;
    BYTE *pbPvkValue = NULL;
    DWORD cbPvkValue;
    DWORD dwKeySpec;

    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    if (cbBobKey > MAX_BOB_FILE_LEN) goto BadBobFile;

    if (NULL == (hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
            cbBobKey)))
        goto ErrorReturn;

    if (NULL == (pbBobKey = (BYTE *) GlobalLock(hGlobal)))
        goto ErrorReturn;
    memcpy(pbBobKey, (BYTE *) pHdr, sizeof(FILE_HDR));
    if (cbBobKey > sizeof(FILE_HDR))
        fResult = pfnRead(hRead, pbBobKey + sizeof(FILE_HDR),
            cbBobKey - sizeof(FILE_HDR));
    else
        fResult = TRUE;
    GlobalUnlock(hGlobal);
    if (!fResult) goto ErrorReturn;

    // FALSE => don't DeleteOnRelease
    if (FAILED(hr = CreateILockBytesOnHGlobal(hGlobal, FALSE, &pLkByt)))
        goto HrError;

    if (FAILED(hr = StgOpenStorageOnILockBytes(
            pLkByt,
            NULL,       // pStgPriority
            STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE,
            NULL,    // snbExclude
            0,       // dwReserved
            &pStg
            ))) goto HrError;

    if (FAILED(pStg->OpenStorage(
            L"Plain Private Key",
            0,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            NULL,
            0,
            &pPrivStg))) goto BadBobFile;

    if (pdwKeySpec && *pdwKeySpec)
        dwKeySpec = *pdwKeySpec;
    else
        dwKeySpec = AT_SIGNATURE;

    // First, attempt to read the new format where the keys are stored in
    // the private key export format
    fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec, &pbPvkValue,
        &cbPvkValue);
    if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
        dwKeySpec = AT_KEYEXCHANGE;
        fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec,
            &pbPvkValue, &cbPvkValue);
    }
    if (fResult)
        fResult =  PrivateKeyLoadFromMemory(
            hCryptProv,
            pbPvkValue,
            cbPvkValue,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            &dwKeySpec
            );
    else {
        // Try "old" format

        if (pdwKeySpec && *pdwKeySpec)
            dwKeySpec = *pdwKeySpec;
        else
            dwKeySpec = AT_SIGNATURE;

        fResult = LoadBobOldPvk(pPrivStg, dwKeySpec, &pbPvkValue, &cbPvkValue);
        if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
            dwKeySpec = AT_KEYEXCHANGE;
            fResult = LoadBobOldPvk(pPrivStg, dwKeySpec,
                &pbPvkValue, &cbPvkValue);
        }
        if (fResult) {
            BYTE *pbExportPvk;
            DWORD cbExportPvk;
            // Convert Bob's old private key format to the new export private
            // key format
            if ((fResult = ConstructPrivateKeyExportBlob(
                    dwKeySpec,
                    (BSAFE_PRV_KEY *) pbPvkValue,
                    cbPvkValue,
                    &pbExportPvk,
                    &cbExportPvk
                    ))) {
                HCRYPTKEY hKey = 0;
                // Import the private key
                fResult = CryptImportKey(hCryptProv, pbExportPvk, cbExportPvk,
                    0, dwFlags, &hKey);
                if (hKey)
                    CryptDestroyKey(hKey);
                PvkFree(pbExportPvk);
            }
        }
    }
    
    if (fResult) goto CommonReturn;
    goto ErrorReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;

BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    dwKeySpec = 0;
    fResult = FALSE;

    // One of the following Releases may clear it out
    dwErr = GetLastError();
CommonReturn:
    if (pbPvkValue)
        PvkFree(pbPvkValue);
    if (pPrivStg)
        pPrivStg->Release();
    if (pStg)
        pStg->Release();
    if (pLkByt)
        pLkByt->Release();
    if (hGlobal)
        GlobalFree(hGlobal);

    if (pdwKeySpec)
        *pdwKeySpec = dwKeySpec;
    if (dwErr)
        SetLastError(dwErr);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\trans\gen\hgttran.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       hgttran.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <memory.h>
#include <assert.h>
#include <malloc.h>
#include "gttran.h"
#include "ihgttran.h"

DWORD __stdcall GTOpen(HGT * phTran, const TCHAR * szLibrary, const TCHAR * tszBinding, DWORD fOpen) {

	IGTS *	pIGTS;
	DWORD	err = ERROR_SUCCESS;

	assert(phTran != NULL);
	assert(szLibrary != NULL);

	// initialize the return handle
	*phTran = 0;

	// make a data structure for the handle
	if( (pIGTS = (IGTS *) malloc(sizeof(IGTS))) == NULL)
		return(ERROR_NOT_ENOUGH_MEMORY);
	memset(pIGTS, 0, sizeof(IGTS));

	// load the dynamic library
	if( (pIGTS->hLib = LoadLibrary(szLibrary)) == NULL ) {
		free(pIGTS);
		return(ERROR_DLL_NOT_FOUND);
	}

	// now get all of the proc addres
	if( (pIGTS->PfnOpen = (PFNOpen) GetProcAddress(pIGTS->hLib, "Open")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if( (pIGTS->PfnSend = (PFNSend) GetProcAddress(pIGTS->hLib, "Send")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if( (pIGTS->PfnFree = (PFNFree) GetProcAddress(pIGTS->hLib, "Free")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if( (pIGTS->PfnReceive = (PFNReceive) GetProcAddress(pIGTS->hLib, "Receive")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if( (pIGTS->PfnClose = (PFNClose) GetProcAddress(pIGTS->hLib, "Close")) == NULL )
		err = ERROR_PROC_NOT_FOUND;

	if(err != ERROR_SUCCESS) {
		FreeLibrary(pIGTS->hLib );
		free(pIGTS);
		return(err);
	}

	// ok, open the file
	err = pIGTS->PfnOpen(&pIGTS->hTran, tszBinding, fOpen);

	if(err != ERROR_SUCCESS) {
		FreeLibrary(pIGTS->hLib );
		free(pIGTS);
		return(err);
	}

	// return the handle
	*phTran = (HGT) pIGTS;

	return(err);
}

DWORD __stdcall GTSend(HGT hTran, DWORD dwEncoding, DWORD cbSendBuff, const BYTE * pbSendBuff) {

	IGTS *	pIGTS;

	assert(hTran != 0);
	pIGTS = (IGTS *) hTran;


	return(pIGTS->PfnSend(pIGTS->hTran, dwEncoding, cbSendBuff, pbSendBuff));
}

DWORD __stdcall GTFree(HGT hTran, BYTE * pb) {

	IGTS *	pIGTS;

	assert(hTran != 0);
	pIGTS = (IGTS *) hTran;

	return(pIGTS->PfnFree(pIGTS->hTran, pb));
}

DWORD __stdcall GTReceive(HGT hTran,  DWORD * pdwEncoding, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff) {

	IGTS *	pIGTS;

	assert(hTran != 0);
	pIGTS = (IGTS *) hTran;

	return(pIGTS->PfnReceive(pIGTS->hTran, pdwEncoding, pcbReceiveBuff, ppbReceiveBuff));
}

DWORD __stdcall GTClose(HGT hTran) {

	IGTS *	pIGTS;

	assert(hTran != 0);
	pIGTS = (IGTS *) hTran;

	// close and free all ofthe junk
	pIGTS->PfnClose(pIGTS->hTran);
	FreeLibrary(pIGTS->hLib );
	free(pIGTS);

	return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\capi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       capi.cpp
//
//--------------------------------------------------------------------------

#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>

#include "crtem.h"
#include "redir.h"
#include "unicode.h"

#ifndef _M_IX86
BOOL
WINAPI
UnicodeDllMain(
    HMODULE hInst,
    ULONG  ulReason,
    LPVOID lpReserved
    )
{
    return TRUE;
}


#else

#ifdef LINK_REDIR
#define pfnAcquireContextW      CryptAcquireContextW
#define pfnSignHashW            CryptSignHashW
#define pfnVerifySignatureW     CryptVerifySignatureW
#define pfnSetProviderW         CryptSetProviderW
#define pfnEnumProvidersW       CryptEnumProvidersW
#else
static HINSTANCE                hCrypt                  = NULL;
static LPSTR                    pszCryptName            = "advapi32.dll";
static CRYPTACQUIRECONTEXTW     *pfnAcquireContextW     = NULL;
static CRYPTSIGNHASHW           *pfnSignHashW           = NULL;
static CRYPTVERIFYSIGNATUREW    *pfnVerifySignatureW    = NULL;
static CRYPTSETPROVIDERW        *pfnSetProviderW        = NULL;

typedef WINADVAPI BOOL WINAPI CRYPTENUMPROVIDERSW(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR szTypeName,
    DWORD *pcbTypeName
    );

static CRYPTENUMPROVIDERSW      *pfnEnumProvidersW      = NULL;
#endif

BOOL
WINAPI
UnicodeDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
#ifndef LINK_REDIR
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        hCrypt = LoadLibraryA(pszCryptName);

        pfnAcquireContextW = (CRYPTACQUIRECONTEXTW*)GetProcAddress(
                                    hCrypt,
                                    "CryptAcquireContextW");
        pfnSignHashW = (CRYPTSIGNHASHW*)GetProcAddress(
                                    hCrypt,
                                    "CryptSignHashW");
        pfnVerifySignatureW = (CRYPTVERIFYSIGNATUREW*)GetProcAddress(
                                    hCrypt,
                                    "CryptVerifySignatureW");
        pfnSetProviderW = (CRYPTSETPROVIDERW*)GetProcAddress(
                                    hCrypt,
                                    "CryptSetProviderW");
        pfnEnumProvidersW = (CRYPTENUMPROVIDERSW*)GetProcAddress(
                                    hCrypt,
                                    "CryptEnumProvidersW");
        break;

    case DLL_PROCESS_DETACH:
        FreeLibrary( hCrypt);
        pfnAcquireContextW  = NULL;
        pfnSignHashW        = NULL;
        pfnVerifySignatureW = NULL;
        pfnSetProviderW     = NULL;
        pfnEnumProvidersW   = NULL;
        break;

    default:
        break;
    }
#endif

    return TRUE;
}


BOOL WINAPI CryptAcquireContext9x(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szContainer = NULL;
    char *  szProvider = NULL;
    LONG    err;

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpContainer, &szContainer)  &&
        MkMBStr(rgb2, _MAX_PATH, lpProvider, &szProvider)    )
        err = CryptAcquireContextA (
                phProv,
                szContainer,
                szProvider,
                dwProvType,
                dwFlags
               );

    FreeMBStr(rgb1, szContainer);
    FreeMBStr(rgb2, szProvider);

    return(err);
}

BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags) {

    // Bug in CyptAcquireContextW for NT4
    if(FIsWinNT5() && pfnAcquireContextW)
        return( pfnAcquireContextW (
            phProv,
            lpContainer,
            lpProvider,
            dwProvType,
            dwFlags
            ));
    else
        return( CryptAcquireContext9x (
            phProv,
            lpContainer,
            lpProvider,
            dwProvType,
            dwFlags
            ));
}


BOOL WINAPI CryptSignHash9x(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen) {

    BYTE rgb[_MAX_PATH];
    char *  szDescription;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpDescription, &szDescription))
        err = CryptSignHashA (
                hHash,
                dwKeySpec,
                szDescription,
                dwFlags,
                pbSignature,
                pdwSigLen
            );

    FreeMBStr(rgb, szDescription);

    return(err);
}

BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen) {

    if(FIsWinNT())
        return(pfnSignHashW (
            hHash,
            dwKeySpec,
            lpDescription,
            dwFlags,
            pbSignature,
            pdwSigLen
            ));
    else
        return(CryptSignHash9x (
            hHash,
            dwKeySpec,
            lpDescription,
            dwFlags,
            pbSignature,
            pdwSigLen
            ));
}


BOOL WINAPI CryptVerifySignature9x(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags) {

    BYTE rgb[_MAX_PATH];
    char *  szDescription;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpDescription, &szDescription))
        err = CryptVerifySignatureA (
                hHash,
                pbSignature,
                dwSigLen,
                hPubKey,
                szDescription,
                dwFlags
             );

    FreeMBStr(rgb, szDescription);

    return(err);
}

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags) {

    BYTE rgb[_MAX_PATH];
    char *  szDescription;
    LONG    err;

    if(FIsWinNT())
        return(pfnVerifySignatureW (
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            lpDescription,
            dwFlags
            ));
    else
        return(CryptVerifySignature9x (
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            lpDescription,
            dwFlags
            ));
}


BOOL WINAPI CryptSetProvider9x(
    LPCWSTR lpProvName,
    DWORD dwProvType) {

    BYTE rgb[_MAX_PATH];
    char *  szProvName;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpProvName, &szProvName))
        err = CryptSetProviderA (
                szProvName,
                dwProvType
            );

    FreeMBStr(rgb, szProvName);

    return(err);
}

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType) {

    if(FIsWinNT())
        return(pfnSetProviderW (
            lpProvName,
            dwProvType
            ));
    else
        return(CryptSetProvider9x (
            lpProvName,
            dwProvType
            ));
}




/*
 -      CryptEnumProvidersU
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pwszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */

#define PROVREG L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"
#define PROVTYPEREG L"Type"

BOOL
WINAPI CryptEnumProviders9x(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pwszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    HKEY        hRegKey = 0;
    HKEY        hProvRegKey = 0;
    LONG        err;
    DWORD       cbClass;
    FILETIME    ft;
    DWORD       dwKeyType;
    DWORD       cbProvType;
    DWORD       dw;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    LPWSTR      pwszTmpProvName = NULL;
    DWORD       cbTmpProvName;
    BOOL        fRet = CRYPT_FAILED;

    if (NULL != pdwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if (0 != dwFlags)
    {
        SetLastError((DWORD)NTE_BAD_FLAGS);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                                             PROVREG,
                                             0L, KEY_READ, &hRegKey)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegQueryInfoKey(hRegKey,
                                                NULL,
                                                &cbClass,
                                                NULL,
                                                &cSubKeys,
                                                &cbMaxKeyName,
                                                &cbMaxClass,
                                                &cValues,
                                                &cbMaxValName,
                                                &cbMaxValData,
                                                NULL,
                                                &ft)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }
    cbMaxKeyName += sizeof(CHAR);

    if (NULL == (pwszTmpProvName = (LPWSTR) _alloca(cbMaxKeyName * sizeof(WCHAR))))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegEnumKeyExU(hRegKey, dwIndex, pwszTmpProvName,
                                             &cbMaxKeyName, NULL,
                                             NULL, &cbClass, &ft)))
    {
        SetLastError((DWORD)err);
        goto Ret;
    }

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(hRegKey,
                                             pwszTmpProvName,
                                             0L, KEY_READ, &hProvRegKey)))
    {
	    SetLastError((DWORD) err);
        goto Ret;
    }

    cbProvType = sizeof(dw);
    if (ERROR_SUCCESS != (err = RegQueryValueExU(hProvRegKey,
                                                PROVTYPEREG,
                                                NULL, &dwKeyType, (BYTE*)&dw,
                                                &cbProvType)))
    {
	    SetLastError((DWORD) NTE_PROV_TYPE_ENTRY_BAD);
        goto Ret;
    }
    *pdwProvType = dw;

    cbTmpProvName = (wcslen(pwszTmpProvName) + 1) * sizeof(WCHAR);

    if (NULL != pwszProvName)
    {
        if (*pcbProvName < cbTmpProvName)
        {
            *pcbProvName = cbTmpProvName;
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }
        wcscpy(pwszProvName, pwszTmpProvName);
    }

    *pcbProvName = cbTmpProvName;

    fRet = CRYPT_SUCCEED;

Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hProvRegKey)
        RegCloseKey(hProvRegKey);
    return fRet;
}

BOOL
WINAPI CryptEnumProvidersU(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pwszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    if(FIsWinNT5() && pfnEnumProvidersW)
        return(pfnEnumProvidersW (
            dwIndex,
            pdwReserved,
            dwFlags,
            pdwProvType,
            pwszProvName,
            pcbProvName
            ));
    else
        return(CryptEnumProviders9x (
            dwIndex,
            pdwReserved,
            dwFlags,
            pdwProvType,
            pwszProvName,
            pcbProvName
            ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\commctrl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       commctrl.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "unicode.h"
#include "crtem.h"


HTREEITEM WINAPI TreeView_InsertItem9x(
    HWND hwndTV,
    LPTVINSERTSTRUCTW lpis
    )
{
    TVINSERTSTRUCTA   tvItem;
    HTREEITEM           hTreeItem;
    int                 cb;

    memcpy(&tvItem, lpis, sizeof(LPTVINSERTSTRUCTA));

    cb = WideCharToMultiByte(
            0, 
            0, 
            lpis->item.pszText, 
            -1, 
            NULL,
            0,
            NULL,
            NULL);
    
    if (NULL == (tvItem.item.pszText = (LPSTR) malloc(cb))) 
    {
        return NULL;  // this is the unsuccessful return code for this call 
    }

    WideCharToMultiByte(
            0, 
            0, 
            lpis->item.pszText, 
            -1, 
            tvItem.item.pszText,
            cb,
            NULL,
            NULL);

    hTreeItem = (HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEMA, 0, (LPARAM) &tvItem);

    free(tvItem.item.pszText);
    return hTreeItem;
}

HTREEITEM WINAPI TreeView_InsertItemU(
    HWND hwndTV,
    LPTVINSERTSTRUCTW lpis
    )
{
    if (FIsWinNT())
    {
        return((HTREEITEM) SendMessage(hwndTV, TVM_INSERTITEMW, 0, (LPARAM) lpis));
    }
    else
    {
        return (TreeView_InsertItem9x(hwndTV, lpis));
    }
}


int WINAPI ListView_InsertItem9x(
    HWND hwnd, 		
    const LPLVITEMW pitem		
    )
{
    LVITEMA lvItem;
    int     iRet;
    int     cb;

    memcpy(&lvItem, pitem, sizeof(LVITEMA));

    cb = WideCharToMultiByte(
            0, 
            0, 
            pitem->pszText, 
            -1, 
            NULL,
            0,
            NULL,
            NULL);
    
    if (NULL == (lvItem.pszText = (LPSTR) malloc(cb))) 
    {
        return -1;  // this is the unsuccessful return code for this call 
    }

    WideCharToMultiByte(
            0, 
            0, 
            pitem->pszText, 
            -1, 
            lvItem.pszText,
            cb,
            NULL,
            NULL);

    iRet = (int)SendMessage(hwnd, LVM_INSERTITEMA, 0, (LPARAM) &lvItem);

    free(lvItem.pszText);
    return iRet;
}

int WINAPI ListView_InsertItemU(
    HWND hwnd, 		
    const LPLVITEMW pitem		
    )
{
    if (FIsWinNT())
    {
        return ((int)SendMessage(hwnd, LVM_INSERTITEMW, 0, (LPARAM) pitem));
    }
    else
    {
        return (ListView_InsertItem9x(hwnd, pitem));
    }
}


void WINAPI ListView_SetItemTextU(
    HWND hwnd, 		
    int i, 		
    int iSubItem, 		
    LPCWSTR pszText		
    )
{
    LVITEMA lvItemA;
    LVITEMW lvItemW;
    int     cb;

    if ((ULONG_PTR) pszText == (ULONG_PTR) LPSTR_TEXTCALLBACK)
    {
        memset(&lvItemA, 0, sizeof(lvItemA));
        lvItemA.iSubItem = iSubItem;
        lvItemA.pszText = (LPSTR) LPSTR_TEXTCALLBACK;
        SendMessage(hwnd, LVM_SETITEMTEXTA, i, (LPARAM) &lvItemA);
        return;
    }

    if (FIsWinNT())
    {
        memset(&lvItemW, 0, sizeof(lvItemW));
        lvItemW.iSubItem = iSubItem;
        lvItemW.pszText = (LPWSTR) pszText;
        SendMessage(hwnd, LVM_SETITEMTEXTW, i, (LPARAM) &lvItemW);
        return;
    }

    memset(&lvItemA, 0, sizeof(lvItemA));
    lvItemA.iSubItem = iSubItem;
    
    cb = WideCharToMultiByte(
            0, 
            0, 
            pszText, 
            -1, 
            NULL,
            0,
            NULL,
            NULL);
    
    if (NULL == (lvItemA.pszText = (LPSTR) malloc(cb)))
    {
        return;
    }

    WideCharToMultiByte(
            0, 
            0, 
            pszText, 
            -1, 
            lvItemA.pszText,
            cb,
            NULL,
            NULL);
    
    SendMessage(hwnd, LVM_SETITEMTEXTA, i, (LPARAM) &lvItemA);
    free(lvItemA.pszText);
}


int WINAPI ListView_InsertColumn9x(
    HWND hwnd, 
    int i, 
    const LPLVCOLUMNW plvC)
{
    LVCOLUMNA   lvCA;
    int         iRet;
    int         cb;

    memcpy(&lvCA, plvC, sizeof(LVCOLUMNA));

    cb = WideCharToMultiByte(
            0, 
            0, 
            plvC->pszText, 
            -1, 
            NULL,
            0,
            NULL,
            NULL);

    if (NULL == (lvCA.pszText = (LPSTR) malloc(cb)))
    {
        return -1; // failure code for this call
    }

    WideCharToMultiByte(
            0, 
            0, 
            plvC->pszText, 
            -1, 
            lvCA.pszText, 
            cb, 
            NULL, 
            NULL);
    
    iRet = (int)SendMessage(hwnd, LVM_INSERTCOLUMNA, i, (LPARAM) &lvCA);
    
    free(lvCA.pszText);
    return iRet;
}

int WINAPI ListView_InsertColumnU(
    HWND hwnd, 
    int i, 
    const LPLVCOLUMNW plvC)
{
    if (FIsWinNT())
    {   
        return ((int)SendMessage(hwnd, LVM_INSERTCOLUMNW, i, (LPARAM) plvC));
    }
    else
    {
        return (ListView_InsertColumn9x(hwnd, i, plvC));
    }
}


BOOL WINAPI ListView_GetItem9x(
    HWND hwnd, 		
    LPLVITEMW pitem		
    )
{
    LVITEMA lvItemA;
    BOOL    fRet;

    memcpy(&lvItemA, pitem, sizeof(lvItemA));
    if (NULL == (lvItemA.pszText = (LPSTR) malloc(lvItemA.cchTextMax)))
    {
        return FALSE;
    }
    
    fRet = (BOOL)SendMessage(hwnd, LVM_GETITEMA, 0, (LPARAM) &lvItemA);

    if (fRet)
    {
        pitem->state = lvItemA.state; 
        pitem->iImage = lvItemA.iImage; 
        pitem->lParam = lvItemA.lParam;
        pitem->iIndent = lvItemA.iIndent;

        if (pitem->mask & LVIF_TEXT)
        {
            MultiByteToWideChar(
                    CP_ACP, 
                    0, 
                    lvItemA.pszText, 
                    -1, 
                    pitem->pszText,
                    pitem->cchTextMax);
        }
    }

    free(lvItemA.pszText);
    return fRet;
}

BOOL WINAPI ListView_GetItemU(
    HWND hwnd, 		
    LPLVITEMW pitem		
    )
{
    if (FIsWinNT())
    {
        return ((BOOL)SendMessage(hwnd, LVM_GETITEMW, 0, (LPARAM) pitem));
    }
    else
    {
        return (ListView_GetItem9x(hwnd, pitem));
    }
}


#ifdef _M_IX86

HFONT
WINAPI
CreateFontIndirect9x(CONST LOGFONTW *lplf)
{
    LOGFONTA    lfa;
    
    memcpy(&lfa, lplf, sizeof(LOGFONTA));

    WideCharToMultiByte(
            0,
            0,
            lplf->lfFaceName,
            -1,
            lfa.lfFaceName,
            LF_FACESIZE,
            NULL,
            NULL);

    return (CreateFontIndirectA(&lfa));
}

HFONT
WINAPI
CreateFontIndirectU(CONST LOGFONTW *lplf)
{
    if (FIsWinNT())
    {
        return (CreateFontIndirectW(lplf));
    }
    else
    {
        return (CreateFontIndirect9x(lplf));
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\trans\cliiis\httptran.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       httptran.cxx
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "GTTran.h"
#include "IHGTTran.h"
#include "httptran.hxx"

DWORD __stdcall SendExp(HUTTRAN hTran, DWORD dwEncodeType, DWORD cbSendBuff, const BYTE * pbSendBuff) {
    return( ((CHttpTran *) hTran)->Send(dwEncodeType, cbSendBuff, pbSendBuff));
}

DWORD __stdcall ReceiveExp(HUTTRAN hTran, DWORD * pdwEncodeType, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff) {
    return( ((CHttpTran *) hTran)->Receive(pdwEncodeType, pcbReceiveBuff, ppbReceiveBuff));
}

DWORD __stdcall CloseExp(HUTTRAN hTran) {
    return(((CHttpTran *) hTran)->Close());
}

DWORD __stdcall FreeExp(HUTTRAN hTran, BYTE * pb) {
    return(((CHttpTran *) hTran)->Free(pb));
}

DWORD __stdcall OpenExp(HUTTRAN * phTran, const TCHAR * tszBinding, DWORD fOpen) {

    DWORD   err;

    assert(phTran != NULL);

    if( (*phTran = (HUTTRAN) new CHttpTran(tszBinding)) == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    err = ((CHttpTran *) *phTran)->Open(tszBinding, fOpen);

    if(err != ERROR_SUCCESS)
        delete (CHttpTran *) (*phTran);

    return(err);
}

DWORD CHttpTran::Open(const TCHAR * tszURL, DWORD fOpenT) {

    TCHAR   tszDomanName[_MAX_PATH];
    TCHAR   tszPort[12];
    TCHAR * ptch;
    TCHAR * ptchT;
    DWORD   err;

    // did we get a flag?
    if(  (fOpenT & (GTREAD | GTWRITE)) == 0 )
        return(ERROR_INVALID_PARAMETER);

    // is it a readonly flag, then do gets
    fOpen = fOpenT;

    assert(tszURL != NULL);

    // we must have http://
    assert(_tcslen(tszURL) > 7);
    assert(_tcsnicmp(tszURL, TEXT("http://"), 7) == 0);

    // copy the Doman Name
    ptch = (TCHAR *) &tszURL[7];
    ptchT = tszDomanName;
    while(*ptch != _T('/')  && *ptch != _T(':') &&  *ptch != 0)
        *ptchT++ = *ptch++;
    *ptchT = 0;

    // parse out the port number
    tszPort[0] = 0;
    if(*ptch == _T(':')) {
        ptchT = tszPort;
        while(*ptch != _T('/') && *ptch != 0)
            *ptchT++ = *ptch++;
        *ptchT = 0;
    }

    // Note, we don't support port numbers
    assert(tszPort[0] == 0);

    // save away what to look up.
    tszPartURL = new TCHAR[(_tcslen(ptch) + 1)];
    if (NULL == tszPartURL) {
        delete this;
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    _tcscpy(tszPartURL, ptch);

    //                        INTERNET_OPEN_TYPE_DIRECT,
    if( (hIOpen = InternetOpen( TEXT("Transport"),
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0)) == NULL                 ||

        (hIConnect = InternetConnect(hIOpen,
                                    tszDomanName,
                                    INTERNET_INVALID_PORT_NUMBER,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    0)) == NULL     ) {
        err = GetLastError();
        delete this;
        return(err);
    }

    // If this is a GET, do a dummy send
    if( fOpen == GTREAD  &&
        ((hIHttp = HttpOpenRequest(hIConnect,
                                    TEXT("GET"),
                                    tszPartURL,
                                    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL     ||
        HttpSendRequest(hIHttp, TEXT("Accept: */*\r\n"), (DWORD) -1, NULL, 0) == FALSE) ) {
        err = GetLastError();
        delete this;
        return(err);
    }

    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Send(DWORD dwEncodeType, DWORD cbSendBuff, const BYTE * pbSendBuff) {

    TCHAR       tszBuff[1024];
    DWORD       err;
    TCHAR *     tszContentType;


    if( pbRecBuf != NULL || (fOpen & GTWRITE) != GTWRITE)
        return(ERROR_INVALID_PARAMETER);

    switch( dwEncodeType ) {
        case ASN_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-asn");
            break;
        case TLV_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-tlv");
            break;
        case IDL_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-idl");
            break;
        case OCTET_ENCODING:
            tszContentType = TEXT("application/octet-stream");
            break;
        default:
            tszContentType = TEXT("text/*");
            break;
    }

    // say how long the buffer is
    _stprintf(tszBuff, TEXT("Content-Type: %s\r\nContent-Length: %d\r\nAccept: %s\r\n"), tszContentType, cbSendBuff,tszContentType);

    if( (hIHttp = HttpOpenRequest(hIConnect,
                                    TEXT("POST"),
                                    tszPartURL,
                                    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL ) {
        return(GetLastError());
    }

    // send of the request, this will wait for a response
    if( HttpSendRequest(hIHttp, tszBuff, (DWORD) -1, (LPVOID) pbSendBuff, cbSendBuff) == FALSE ) {

        err = GetLastError();
        // close out the handle
        assert(hIHttp != NULL);
        InternetCloseHandle(hIHttp);
        hIHttp = NULL;

        return(err);
    }

    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Receive(DWORD * pdwEncodeType, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff) {

    TCHAR       tszBuff[1024];
    DWORD       cbBuff, cbBuffRead, cbBuffT;
    DWORD       err;


    assert(pcbReceiveBuff != NULL && ppbReceiveBuff != NULL);
    *ppbReceiveBuff = NULL;
    *pcbReceiveBuff = 0;

    if( pbRecBuf != NULL  || (fOpen & GTREAD) != GTREAD || hIHttp == NULL)
        return(ERROR_INVALID_PARAMETER);

    // get the content type
    if( pdwEncodeType != NULL) {

        cbBuff = sizeof(tszBuff);
        if(HttpQueryInfo(   hIHttp,
                            HTTP_QUERY_CONTENT_TYPE,
                            tszBuff,
                            &cbBuff,
                            NULL) == FALSE)
            return(GetLastError());

        assert(cbBuff > 0);

        if(!_tcscmp(TEXT("application/x-octet-stream-asn"), tszBuff))
            *pdwEncodeType = ASN_ENCODING;
        else if(!_tcscmp(TEXT("application/x-octet-stream-idl"), tszBuff))
            *pdwEncodeType = IDL_ENCODING;
        else if(!_tcscmp(TEXT("application/x-octet-stream-tlv"), tszBuff))
            *pdwEncodeType = TLV_ENCODING;
        else if(!_tcscmp(TEXT("application/octet-stream"), tszBuff))
            *pdwEncodeType = OCTET_ENCODING;
        else
            *pdwEncodeType = ASCII_ENCODING;

    }

    // now get the length of the buffer returned
    cbBuff = sizeof(tszBuff);
    if(HttpQueryInfo(   hIHttp,
                        HTTP_QUERY_CONTENT_LENGTH,
                        tszBuff,
                        &cbBuff,
                        NULL) == FALSE)
        return(GetLastError());

    assert(cbBuff > 0);
    cbBuff = _ttol(tszBuff);

    // allocate a buffer
    if( (pbRecBuf = new BYTE[cbBuff]) == NULL )
        return(ERROR_NOT_ENOUGH_MEMORY);

    // read the data
    cbBuffRead = 0;
    while(cbBuffRead < cbBuff) {
        cbBuffT = 0;
        if(InternetReadFile(hIHttp, &pbRecBuf[cbBuffRead], (cbBuff - cbBuffRead), &cbBuffT)  == FALSE  ) {
            err = GetLastError();
            delete [] pbRecBuf;
            pbRecBuf = NULL;
            return(err);
        }
        cbBuffRead += cbBuffT;
    }

    // close out the handle
    InternetCloseHandle(hIHttp);
    hIHttp = NULL;

    // pass back the info
    *ppbReceiveBuff = pbRecBuf;
    *pcbReceiveBuff = cbBuff;
    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Free(BYTE * pb) {
    assert(pb == pbRecBuf);
    delete [] pbRecBuf;
    pbRecBuf = NULL;
    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Close(void) {
    delete this;
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\event.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       event.cpp
//
//--------------------------------------------------------------------------


#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "crtem.h"
#include "unicode.h"

#ifdef _M_IX86

HANDLE 
WINAPI
CreateEvent9x(
	LPSECURITY_ATTRIBUTES lpEventAttributes,
	BOOL bManualReset,
	BOOL bInitialState,
	LPCWSTR lpName)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;
	HANDLE hEvent = NULL;

	if (MkMBStr(rgb, _MAX_PATH, lpName, &sz))
	{
		hEvent = CreateEventA(	lpEventAttributes,
								bManualReset,
								bInitialState,
								sz);
		FreeMBStr(rgb, sz);
	}

	return hEvent;
}

HANDLE 
WINAPI
CreateEventU(
	LPSECURITY_ATTRIBUTES lpEventAttributes,
	BOOL bManualReset,
	BOOL bInitialState,
	LPCWSTR lpName)
{
	if (FIsWinNT())
		return CreateEventW(lpEventAttributes,
							bManualReset,
							bInitialState,
							lpName);
    else
        return CreateEvent9x(lpEventAttributes,
							bManualReset,
							bInitialState,
							lpName);
}


HANDLE 
WINAPI
RegisterEventSource9x(
                    LPCWSTR lpUNCServerName,
					LPCWSTR lpSourceName)
{
	BYTE rgb[_MAX_PATH];
	BYTE rgb2[_MAX_PATH];
	char *sz = NULL;
	char *sz2 = NULL;
	HANDLE hEvent = NULL;

	if ((MkMBStr(rgb, _MAX_PATH, lpUNCServerName, &sz)) &&
		(MkMBStr(rgb2, _MAX_PATH, lpSourceName, &sz2)))
	{
		hEvent = RegisterEventSourceA(	sz,
										sz2);
		FreeMBStr(rgb, sz);
		FreeMBStr(rgb2, sz2);
	}

	return hEvent;
}

HANDLE 
WINAPI
RegisterEventSourceU(
                    LPCWSTR lpUNCServerName,
					LPCWSTR lpSourceName)
{
	if (FIsWinNT())
		return RegisterEventSourceW(lpUNCServerName,
									lpSourceName);
    else
        return RegisterEventSource9x(lpUNCServerName,
									lpSourceName);
}


HANDLE 
WINAPI
OpenEvent9x(
           DWORD dwDesiredAccess,
		   BOOL bInheritHandle,
		   LPCWSTR lpName)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;
	HANDLE hEvent = NULL;

	if (MkMBStr(rgb, _MAX_PATH, lpName, &sz))
	{
		hEvent = OpenEventA(dwDesiredAccess,
							bInheritHandle,
							sz);
		FreeMBStr(rgb, sz);
	}

	return hEvent;
}

HANDLE 
WINAPI
OpenEventU(
           DWORD dwDesiredAccess,
		   BOOL bInheritHandle,
		   LPCWSTR lpName)
{
	if (FIsWinNT())
		return OpenEventW(	dwDesiredAccess,
							bInheritHandle,
							lpName);
    else
        return OpenEvent9x(	dwDesiredAccess,
							bInheritHandle,
							lpName);
}


HANDLE 
WINAPI
CreateMutex9x(
	LPSECURITY_ATTRIBUTES lpMutexAttributes,
	BOOL bInitialOwner,
	LPCWSTR lpName)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;
	HANDLE hMutex = NULL;

	if (MkMBStr(rgb, _MAX_PATH, lpName, &sz))
	{
		hMutex = CreateMutexA(	lpMutexAttributes,
								bInitialOwner,
								sz);
		FreeMBStr(rgb, sz);
	}

	return hMutex;
}

HANDLE 
WINAPI
CreateMutexU(
	LPSECURITY_ATTRIBUTES lpMutexAttributes,
	BOOL bInitialOwner,
	LPCWSTR lpName)
{
	if (FIsWinNT())
		return CreateMutexW(lpMutexAttributes,
							bInitialOwner,
							lpName);
    else
        return CreateMutex9x(lpMutexAttributes,
							bInitialOwner,
							lpName);
}


HANDLE 
WINAPI
OpenMutex9x(
           DWORD dwDesiredAccess,
		   BOOL bInheritHandle,
		   LPCWSTR lpName)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;
	HANDLE hMutex = NULL;

	if (MkMBStr(rgb, _MAX_PATH, lpName, &sz))
	{
		hMutex = OpenMutexA(dwDesiredAccess,
							bInheritHandle,
							sz);
		FreeMBStr(rgb, sz);
	}

	return hMutex;
}

HANDLE 
WINAPI
OpenMutexU(
           DWORD dwDesiredAccess,
		   BOOL bInheritHandle,
		   LPCWSTR lpName)
{
	if (FIsWinNT())
		return OpenMutexW(	dwDesiredAccess,
							bInheritHandle,
							lpName);
    else
        return OpenMutex9x(	dwDesiredAccess,
							bInheritHandle,
							lpName);
}


#endif // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\file.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       file.cpp
//
//--------------------------------------------------------------------------

#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "crtem.h"
#include "unicode.h"


#ifdef _M_IX86
HANDLE WINAPI CreateFile9x (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    HANDLE  hFile;

    hFile = INVALID_HANDLE_VALUE;
    if(MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        hFile = CreateFileA (
            szFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            );

    FreeMBStr(rgb, szFileName);

    return(hFile);
}

HANDLE WINAPI CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    ) {

    if(FIsWinNT())
        return( CreateFileW (
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            ));
    else
        return( CreateFile9x (
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile
            ));
}


BOOL
WINAPI
DeleteFile9x(
    LPCWSTR lpFileName
    )
{
    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    BOOL fResult;

    fResult = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        fResult = DeleteFileA (
            szFileName
            );
    FreeMBStr(rgb, szFileName);
    return(fResult);
}

BOOL
WINAPI
DeleteFileU(
    LPCWSTR lpFileName
    )
{
    if(FIsWinNT())
        return( DeleteFileW (lpFileName) );
    else
        return( DeleteFile9x (lpFileName) );
}


BOOL
WINAPI
CopyFile9x(LPCWSTR lpwExistingFileName, LPCWSTR lpwNewFileName, BOOL bFailIfExists)
{
    BYTE rgbexist[_MAX_PATH];
    BYTE rgbnew[_MAX_PATH];
    char *  szFileNameExist;
    char *  szFileNameNew;
    BOOL fResult;

    fResult = FALSE;

    if (!(MkMBStr(rgbexist, _MAX_PATH, lpwExistingFileName, &szFileNameExist)))
    {
        return(FALSE);
    }

    if (!(MkMBStr(rgbnew, _MAX_PATH, lpwNewFileName, &szFileNameNew)))
    {
        FreeMBStr(rgbexist, szFileNameExist);
        return(FALSE);
    }

    fResult = CopyFileA(szFileNameExist, szFileNameNew, bFailIfExists);

    FreeMBStr(rgbexist, szFileNameExist);
    FreeMBStr(rgbnew, szFileNameNew);

    return(fResult);
}

BOOL
WINAPI
CopyFileU(LPCWSTR lpwExistingFileName, LPCWSTR lpwNewFileName, BOOL bFailIfExists)
{
    if (FIsWinNT())
        return( CopyFileW(lpwExistingFileName, lpwNewFileName, bFailIfExists) );
    else
        return( CopyFile9x(lpwExistingFileName, lpwNewFileName, bFailIfExists) );
}


BOOL
WINAPI
MoveFileEx9x(
	LPCWSTR lpExistingFileName, // address of name of the existing file
	LPCWSTR lpNewFileName,		// address of new name for the file
	DWORD dwFlags)				// flag to determine how to move file
{
	BYTE rgbExisting[_MAX_PATH];
	BYTE rgbNew[_MAX_PATH];
	char * szExisting = NULL;
	char * szNew = NULL;
	BOOL bResult = FALSE;

	if ((MkMBStr(rgbExisting, _MAX_PATH, lpExistingFileName, &szExisting)) &&
		(MkMBStr(rgbNew, _MAX_PATH, lpNewFileName, &szNew)))
	{
		bResult = MoveFileExA(szExisting, szNew, dwFlags);
	}

	FreeMBStr(rgbExisting, szExisting);
	FreeMBStr(rgbNew, szNew);

	return (bResult);
}

BOOL
WINAPI
MoveFileExU(
	LPCWSTR lpExistingFileName, // address of name of the existing file
	LPCWSTR lpNewFileName,		// address of new name for the file
	DWORD dwFlags)				// flag to determine how to move file
{
	if (FIsWinNT())
		return(MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
    else
        return(MoveFileEx9x(lpExistingFileName, lpNewFileName, dwFlags));
}


DWORD
WINAPI
GetFileAttributes9x(
    LPCWSTR lpFileName
    )
{
    if (lpFileName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0xFFFFFFFF);
    }

    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    DWORD dwAttr;

    dwAttr = 0xFFFFFFFF;
    if(MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        dwAttr = GetFileAttributesA (
            szFileName
            );
    FreeMBStr(rgb, szFileName);
    return(dwAttr);
}

DWORD
WINAPI
GetFileAttributesU(
    LPCWSTR lpFileName
    )
{
    if(FIsWinNT())
        return( GetFileAttributesW (lpFileName) );
    else
        return( GetFileAttributes9x (lpFileName) );
}


BOOL
WINAPI
SetFileAttributes9x(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    if (lpFileName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    BYTE rgb[_MAX_PATH];
    char *  szFileName;
    BOOL fResult;

    fResult = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpFileName, &szFileName))
        fResult = SetFileAttributesA (
            szFileName,
            dwFileAttributes
            );
    FreeMBStr(rgb, szFileName);
    return(fResult);
}

BOOL
WINAPI
SetFileAttributesU(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
    if(FIsWinNT())
        return( SetFileAttributesW (lpFileName, dwFileAttributes) );
    else
        return( SetFileAttributes9x (lpFileName, dwFileAttributes) );
}


DWORD
WINAPI
GetCurrentDirectory9x(
	DWORD nBufferLength, // size, in characters, of directory buffer
	LPWSTR lpBuffer)	 // address of buffer for current directory
{
	BYTE rgb[_MAX_PATH];
	char * szDir = NULL;
	DWORD dwResult = 0;

	if (nBufferLength == 0)
    {
        return(GetCurrentDirectoryA(0, NULL));
    }
    else
    {
	    szDir = (char *) malloc(nBufferLength);
        if (szDir == NULL)
        {
            SetLastError(E_OUTOFMEMORY);
            return 0;
        }
        dwResult = GetCurrentDirectoryA(nBufferLength, szDir);

        if (dwResult == 0)
        {
            return 0;
        }

        MultiByteToWideChar(
            0,
            0,
            szDir,
            -1,
            lpBuffer,
            nBufferLength);
    }

    free(szDir);
	return (dwResult);
}

DWORD
WINAPI
GetCurrentDirectoryU(
	DWORD nBufferLength, // size, in characters, of directory buffer
	LPWSTR lpBuffer)	 // address of buffer for current directory
{
	if (FIsWinNT())
		return(GetCurrentDirectoryW(nBufferLength, lpBuffer));
    else
        return(GetCurrentDirectory9x(nBufferLength, lpBuffer));
}


BOOL
WINAPI
CreateDirectory9x(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    if (lpPathName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    BYTE rgb[_MAX_PATH];
    char *  szPathName;
    BOOL fResult;

    fResult = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpPathName, &szPathName))
        fResult = CreateDirectoryA (
            szPathName,
            lpSecurityAttributes
            );
    FreeMBStr(rgb, szPathName);
    return(fResult);
}

BOOL
WINAPI
CreateDirectoryU(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    if(FIsWinNT())
        return( CreateDirectoryW (lpPathName, lpSecurityAttributes) );
    else
        return( CreateDirectory9x (lpPathName, lpSecurityAttributes) );
}


BOOL
WINAPI
RemoveDirectory9x(
    LPCWSTR lpPathName
    )
{
    if (lpPathName == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    BYTE rgb[_MAX_PATH];
    char *  szPathName;
    BOOL fResult;

    fResult = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpPathName, &szPathName))
        fResult = RemoveDirectoryA (
            szPathName
            );
    FreeMBStr(rgb, szPathName);
    return(fResult);
}

BOOL
WINAPI
RemoveDirectoryU(
    LPCWSTR lpPathName
    )
{
    if(FIsWinNT())
        return( RemoveDirectoryW (lpPathName) );
    else
        return( RemoveDirectory9x (lpPathName) );
}


UINT
WINAPI
GetWindowsDirectory9x(
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    char rgch[_MAX_PATH];
    char *  szDir = NULL;
    UINT cchDir;

    int cchConverted;
    UINT cch;

    szDir = rgch;
    cchDir = sizeof(rgch);
    if (0 == (cchDir = GetWindowsDirectoryA (
            szDir,
            cchDir))) goto ErrorReturn;

    // bump to include null terminator
    cchDir++;

    if (cchDir > sizeof(rgch)) {
        szDir = (char *) malloc(cchDir);
        if(!szDir) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto ErrorReturn;
        }
        if (0 == (cchDir = GetWindowsDirectoryA (
                szDir,
                cchDir))) goto ErrorReturn;
        cchDir++;
    }

    // how long is the unicode string
    if (0 >= (cchConverted = MultiByteToWideChar(
            0,
            0,
            szDir,
            cchDir,
            NULL,
            0)))
        goto ErrorReturn;
    if ((UINT) cchConverted <= uSize) {
        if (0 >= (cchConverted = MultiByteToWideChar(
                0,
                0,
                szDir,
                cchDir,
                lpBuffer,
                (int) uSize)))
            goto ErrorReturn;
        else
            // Don't include null terminating char if input buffer was large
            // enough
            cch = (UINT) cchConverted - 1;
    } else
        // Include null terminating if input buffer wasn't large enough
        cch = (UINT) cchConverted;

CommonReturn:
    if (szDir != rgch && szDir)
        free(szDir);
    return cch;
ErrorReturn:
    cch = 0;
    goto CommonReturn;
}

UINT
WINAPI
GetWindowsDirectoryU(
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    if(FIsWinNT())
        return( GetWindowsDirectoryW (lpBuffer, uSize));
    else
        return( GetWindowsDirectory9x (lpBuffer, uSize));
}


UINT WINAPI GetTempFileName9x(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    OUT LPWSTR lpTempFileName
    )
{
    UINT uResult = 0;

    BYTE rgbPathName[_MAX_PATH];
    BYTE rgbPrefixString[_MAX_PATH];

    char* szPathName = NULL;
    char* szPrefixString = NULL;

    char szTempFileName[_MAX_PATH];

	if ((MkMBStr(rgbPathName, _MAX_PATH, lpPathName, &szPathName)) &&
		(MkMBStr(rgbPrefixString, _MAX_PATH, lpPrefixString, &szPrefixString)))
	{
		if ( ( uResult = GetTempFileNameA(
                            szPathName,
                            szPrefixString,
                            uUnique,
                            szTempFileName
                            ) != 0 ) )
        {
            MultiByteToWideChar(
                 CP_ACP,
                 0,
                 szTempFileName,
                 -1,
                 lpTempFileName,
                 MAX_PATH
                 );
        }
	}

	FreeMBStr(rgbPathName, szPathName);
	FreeMBStr(rgbPrefixString, szPrefixString);

    return( uResult );
}

UINT WINAPI GetTempFileNameU(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    OUT LPWSTR lpTempFileName
    )
{
    if(FIsWinNT())
        return( GetTempFileNameW(
                   lpPathName,
                   lpPrefixString,
                   uUnique,
                   lpTempFileName
                   ) );
    else
        return( GetTempFileName9x(
                   lpPathName,
                   lpPrefixString,
                   uUnique,
                   lpTempFileName
                   ) );
}


HINSTANCE WINAPI LoadLibrary9x(
    LPCWSTR lpLibFileName
    )
{
    BYTE rgb[_MAX_PATH];
    char *  szLibFileName;
    HINSTANCE hInst;

    hInst = NULL;
    if(MkMBStr(rgb, _MAX_PATH, lpLibFileName, &szLibFileName))
        hInst = LoadLibraryA (
            szLibFileName
            );

    FreeMBStr(rgb, szLibFileName);

    return(hInst);
}

HINSTANCE WINAPI LoadLibraryU(
    LPCWSTR lpLibFileName
    )
{
    if(FIsWinNT())
        return( LoadLibraryW(lpLibFileName) );
    else
        return( LoadLibrary9x(lpLibFileName) );

}


HINSTANCE WINAPI LoadLibraryEx9x(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    ){

    BYTE rgb[_MAX_PATH];
    char *  szLibFileName;
    HINSTANCE hInst;

    hInst = NULL;
    if(MkMBStr(rgb, _MAX_PATH, lpLibFileName, &szLibFileName))
        hInst = LoadLibraryExA (
            szLibFileName,
            hFile,
            dwFlags
            );

    FreeMBStr(rgb, szLibFileName);

    return(hInst);
}

HINSTANCE WINAPI LoadLibraryExU(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    ){

    if(FIsWinNT())
        return( LoadLibraryExW (
            lpLibFileName,
            hFile,
            dwFlags
            ));
    else
        return( LoadLibraryEx9x (
            lpLibFileName,
            hFile,
            dwFlags
            ));
}


DWORD
WINAPI
ExpandEnvironmentStrings9x(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    )
{
    BYTE rgb1[_MAX_PATH];
    char *  szSrc = NULL;

    char rgch[_MAX_PATH];
    char *  szDst = NULL;
    DWORD cchDst;

    int cbConverted;
    DWORD cch;

    if(!MkMBStr(rgb1, _MAX_PATH, lpSrc, &szSrc))
        goto ErrorReturn;

    szDst = rgch;
    cchDst = sizeof(rgch);
    if (0 == (cchDst = ExpandEnvironmentStringsA(
            szSrc,
            szDst,
            cchDst))) goto ErrorReturn;

    if (cchDst > sizeof(rgch)) {
        szDst = (char *) malloc(cchDst);
        if(!szDst) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto ErrorReturn;
        }
        if (0 == (cchDst = ExpandEnvironmentStringsA(
                szSrc,
                szDst,
                cchDst))) goto ErrorReturn;
    }

    // how long is the unicode string
    if (0 >= (cbConverted = MultiByteToWideChar(
            0,
            0,
            szDst,
            cchDst,
            NULL,
            0)))
        goto ErrorReturn;
    if ((DWORD) cbConverted <= nSize) {
        if (0 >= (cbConverted = MultiByteToWideChar(
                0,
                0,
                szDst,
                cchDst,
                lpDst,
                nSize)))
            goto ErrorReturn;
    }

    cch = (DWORD) cbConverted;

CommonReturn:
    FreeMBStr(rgb1, szSrc);
    if (szDst != rgch && szDst)
        free(szDst);
    return cch;
ErrorReturn:
    cch = 0;
    goto CommonReturn;
}

DWORD
WINAPI
ExpandEnvironmentStringsU(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    )
{
    if (lpSrc == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    if(FIsWinNT())
        return( ExpandEnvironmentStringsW(
            lpSrc,
            lpDst,
            nSize
            ));
    else
        return( ExpandEnvironmentStrings9x(
            lpSrc,
            lpDst,
            nSize
            ));
}


void
ConvertFindDataAToFindDataW(
    IN LPWIN32_FIND_DATAA pFindFileDataA,
    OUT LPWIN32_FIND_DATAW pFindFileDataW
    )
{
    DWORD cchFilename;

    memset(pFindFileDataW, 0, sizeof(*pFindFileDataW));
    pFindFileDataW->dwFileAttributes    = pFindFileDataA->dwFileAttributes;
    pFindFileDataW->ftCreationTime      = pFindFileDataA->ftCreationTime;
    pFindFileDataW->ftLastAccessTime    = pFindFileDataA->ftLastAccessTime;
    pFindFileDataW->ftLastWriteTime     = pFindFileDataA->ftLastWriteTime;
    pFindFileDataW->nFileSizeHigh       = pFindFileDataA->nFileSizeHigh;
    pFindFileDataW->nFileSizeLow        = pFindFileDataA->nFileSizeLow;
    // pFindFileDataW->dwReserved0         = pFindFileDataA->dwReserved0;
    // pFindFileDataW->dwReserved1         = pFindFileDataA->dwReserved1;
    // CHAR   cFileName[ MAX_PATH ];
    // pFindFileDataW->cAlternateFileName  = pFindFileDataA->cAlternateFileName;


    cchFilename = strlen(pFindFileDataA->cFileName);
    if (0 != cchFilename && MAX_PATH > cchFilename)
        MultiByteToWideChar(
            CP_ACP,
            0,                      // dwFlags
            pFindFileDataA->cFileName,
            cchFilename + 1,
            pFindFileDataW->cFileName,
            MAX_PATH
            );
}


HANDLE
WINAPI
FindFirstFile9x(
    IN LPCWSTR pwszDir,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    )
{
    HANDLE hFindFile;
    BYTE rgb[_MAX_PATH];
    WIN32_FIND_DATAA FindFileDataA;
    LPSTR pszDir;

    if (pwszDir == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(INVALID_HANDLE_VALUE);
    }

    if (!MkMBStr(rgb, _MAX_PATH, pwszDir, &pszDir))
        return INVALID_HANDLE_VALUE;

    hFindFile = FindFirstFileA(pszDir, &FindFileDataA);
    if (INVALID_HANDLE_VALUE != hFindFile)
        ConvertFindDataAToFindDataW(&FindFileDataA, lpFindFileData);
    FreeMBStr(rgb, pszDir);
    return hFindFile;
}

HANDLE
WINAPI
FindFirstFileU(
    IN LPCWSTR pwszDir,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    )
{
    if (FIsWinNT())
        return FindFirstFileW(pwszDir, lpFindFileData);
    else
        return FindFirstFile9x(pwszDir, lpFindFileData);
}


BOOL
WINAPI
FindNextFile9x(
    IN HANDLE hFindFile,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    )
{
    BOOL fResult;
    WIN32_FIND_DATAA FindFileDataA;

    fResult = FindNextFileA(hFindFile, &FindFileDataA);
    if (fResult)
        ConvertFindDataAToFindDataW(&FindFileDataA, lpFindFileData);
    return fResult;
}

BOOL
WINAPI
FindNextFileU(
    IN HANDLE hFindFile,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    )
{
    if (FIsWinNT())
        return FindNextFileW(hFindFile, lpFindFileData);
    else
        return FindNextFile9x(hFindFile, lpFindFileData);
}


HANDLE
WINAPI
FindFirstChangeNotification9x(
    LPCWSTR pwszPath,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )
{
    HANDLE hChange;
    BYTE rgb[_MAX_PATH];
    LPSTR pszPath;

    if (pwszPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (!MkMBStr(rgb, _MAX_PATH, pwszPath, &pszPath))
        return INVALID_HANDLE_VALUE;

    hChange = FindFirstChangeNotificationA(pszPath, bWatchSubtree,
        dwNotifyFilter);
    FreeMBStr(rgb, pszPath);
    return hChange;
}

HANDLE
WINAPI
FindFirstChangeNotificationU(
    LPCWSTR pwszPath,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )
{
    if (FIsWinNT())
        return FindFirstChangeNotificationW(
            pwszPath, 
            bWatchSubtree, 
            dwNotifyFilter);
    else
        return FindFirstChangeNotification9x(
            pwszPath, 
            bWatchSubtree, 
            dwNotifyFilter);
}
#endif      // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\reg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       reg.cpp
//
//--------------------------------------------------------------------------

#include "windows.h"
#include <stdio.h>
#include <string.h>
//#include <assert.h>

#include "crtem.h"
#include "unicode.h"

//
// FIsWinNT: check OS type on x86.  On non-x86, assume WinNT
//

#ifdef _M_IX86

BOOL WINAPI FIsWinNTCheck(void) {

    OSVERSIONINFO osVer;

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        return (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
    else
        return (FALSE);
}

BOOL WINAPI FIsWinNT(void) {

    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT = FALSE;

    if(fIKnow)
        return(fIsWinNT);

    fIsWinNT = FIsWinNTCheck();    

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

   return(fIsWinNT);
}

#else

BOOL WINAPI FIsWinNT(void) {
    return(TRUE);
}

#endif

BOOL
WINAPI
FIsWinNT5Check(
    VOID
    )
{
    OSVERSIONINFO osVer;

    memset(&osVer, 0, sizeof(OSVERSIONINFO));
    osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if( GetVersionEx(&osVer) )
        return ( osVer.dwMajorVersion >= 5 );
    else
        return (FALSE);
}

BOOL
WINAPI
FIsWinNT5(
    VOID
    )
{
    static BOOL fIKnow = FALSE;
    static BOOL fIsWinNT5 = FALSE;

    if(!FIsWinNT())
        return FALSE;

    if(fIKnow)
        return(fIsWinNT5);

    fIsWinNT5 = FIsWinNT5Check();

    // even on an error, this is as good as it gets
    fIKnow = TRUE;

    return(fIsWinNT5);
}

// make MBCS from Unicode string
//
// Include parameters specifying the length of the input wide character
// string and return number of bytes converted. An input length of -1 indicates
// null terminated.
//
// This extended version was added to handle REG_MULTI_SZ which contains
// multiple null terminated strings.
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW,
    char ** pszMB, int *pcbConverted) {

    int   cbConverted;

    // sfield: don't bring in crt for assert.  you get free assert via
    // an exception if these are null
//    assert(pszMB != NULL);
    *pszMB = NULL;
//    assert(pcbConverted != NULL);
    *pcbConverted = 0;
    if(wsz == NULL)
        return(TRUE);

    // how long is the mb string
    cbConverted = WideCharToMultiByte(  0,
                                        0,
                                        wsz,
                                        cchW,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);
    if (cbConverted <= 0)
        return(FALSE);

    // get a buffer long enough
    if(pbBuff != NULL  &&  (DWORD) cbConverted <= cbBuff)
        *pszMB = (char *) pbBuff;
    else
        *pszMB = (char *) malloc(cbConverted);

    if(*pszMB == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // now convert to MB
    *pcbConverted = WideCharToMultiByte(0,
                        0,
                        wsz,
                        cchW,
                        *pszMB,
                        cbConverted,
                        NULL,
                        NULL);
    return(TRUE);
}

// make MBCS from Unicode string
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB) {
    int cbConverted;
    return MkMBStrEx(pbBuff, cbBuff, wsz, -1, pszMB, &cbConverted);
}

void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB) {

    if((szMB != NULL) &&  (pbBuff != (PBYTE)szMB))
        free(szMB);
}

// #endif      // _M_IX86

// make Unicode string from MBCS
LPWSTR WINAPI MkWStr(char * szMB) {

    LPWSTR wsz = NULL;
    int   cbConverted;

    if(szMB == NULL)
        goto Ret;

    // how long is the unicode string
    if (0 >= (cbConverted = MultiByteToWideChar(  0,
                                        0,
                                        szMB,
                                        -1,
                                        NULL,
                                        0)))
        goto Ret;

    // get a buffer long enough
    wsz = (LPWSTR) malloc(cbConverted * sizeof(WCHAR));

    if(wsz == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Ret;
    }

    // now convert to MB
    MultiByteToWideChar(0,
                        0,
                        szMB,
                        -1,
                        wsz,
                        cbConverted);
Ret:
    return(wsz);
}

void WINAPI FreeWStr(LPWSTR wsz) {

    if(wsz != NULL)
        free(wsz);
}

#ifdef _M_IX86

LONG WINAPI RegCreateKeyEx9x (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    ) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szSubKey = NULL;
    char *  szClass = NULL;
    LONG    err;

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey)    &&
        MkMBStr(rgb2, _MAX_PATH, lpClass,  &szClass)     )
        err = RegCreateKeyExA (
               hKey,
               szSubKey,
               Reserved,
               szClass,
               dwOptions,
               samDesired,
               lpSecurityAttributes,
               phkResult,
               lpdwDisposition
               );

    FreeMBStr(rgb1, szSubKey);
    FreeMBStr(rgb2, szClass);

    return(err);
}

LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    ) {

    if(FIsWinNT())
        return( RegCreateKeyExW (
            hKey,
            lpSubKey,
            Reserved,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition
            ));
    else
        return( RegCreateKeyEx9x (
            hKey,
            lpSubKey,
            Reserved,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition
            ));   
}


LONG WINAPI RegDeleteKey9x (
    HKEY hKey,
    LPCWSTR lpSubKey
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szSubKey = NULL;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey))
        err = RegDeleteKeyA (
               hKey,
               szSubKey
               );

    FreeMBStr(rgb1, szSubKey);

    return(err);
}

LONG WINAPI RegDeleteKeyU (
    HKEY hKey,
    LPCWSTR lpSubKey
    ) {

    if(FIsWinNT())
        return( RegDeleteKeyW (
            hKey,
            lpSubKey
            ));
    else
        return( RegDeleteKey9x (
            hKey,
            lpSubKey
            ));
}


LONG WINAPI RegEnumKeyEx9x (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   ) {

    char rgch[_MAX_PATH];
    char *  szKeyName;
    DWORD cbKeyName;

    char rgch1[_MAX_PATH];
    char *  szClassName;
    DWORD cbClassName;

    int     cchW;
    LONG    err;

    szKeyName = rgch;
    cbKeyName = sizeof(rgch);
    szClassName = rgch1;
    cbClassName = sizeof(rgch1);

    err = RegEnumKeyExA (
        hKey,
        dwIndex,
        szKeyName,
        &cbKeyName,
        lpReserved,
        szClassName,
        &cbClassName,
        lpftLastWriteTime
        );
    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER))
        return err;
    err = ERROR_SUCCESS;

    cbKeyName++;                      // count the NULL terminator
    cbClassName++;                    // count the NULL terminator
    if ((sizeof(rgch) < cbKeyName) || (sizeof(rgch1) < cbClassName)) {
        szKeyName = (char *) malloc(cbKeyName);
        if(!szKeyName)
            return ERROR_OUTOFMEMORY;

        szClassName = (char *) malloc(cbClassName);
	if(!szClassName) {
	    free(szKeyName);
	    return ERROR_OUTOFMEMORY;
	}

        err = RegEnumKeyExA (
            hKey,
            dwIndex,
            szKeyName,
            &cbKeyName,
            lpReserved,
            szClassName,
            &cbClassName,
            lpftLastWriteTime
            );
        cbKeyName++;                    // count the NULL terminator
        cbClassName++;                  // count the NULL terminator
    }

    if(err == ERROR_SUCCESS) {
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szKeyName,
                            cbKeyName,
                            lpName,
                            *lpcbName);
        if(cchW == 0)
            err = GetLastError();
        else
            *lpcbName = cchW - 1; // does not include NULL
    }

    if(szKeyName != rgch)
        free(szKeyName);

    if(err == ERROR_SUCCESS) {

        //
        // it's legal for lpClass/lpcbClass to be NULL, so only copy if they are not NOT
        //

        if(lpClass != NULL) {
            // note: RegEnumKeyEx specifies that lpcbClass can only be NULL
            // if lpClass is NULL, so the correct behavior is to fault if
            // lpClass is non-null and lpcbClass is NULL; this behavior is
            // does happen here.
            //
            cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szClassName,
                            cbClassName,
                            lpClass,
                            *lpcbClass);
            if(cchW == 0)
                err = GetLastError();
        }

        if(lpcbClass != NULL)
            *lpcbClass = cbClassName - 1; // does not include NULL
    }

    if(szClassName != rgch1)
        free(szClassName);

    return err;
}

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   ) {

    if(FIsWinNT())
        return( RegEnumKeyExW (
                hKey,
                dwIndex,
                lpName,
                lpcbName,
                lpReserved,
                lpClass,
                lpcbClass,
                lpftLastWriteTime
                ));
    else
        return( RegEnumKeyEx9x (
                hKey,
                dwIndex,
                lpName,
                lpcbName,
                lpReserved,
                lpClass,
                lpcbClass,
                lpftLastWriteTime
                ));
}

static LONG WINAPI ConvertRegValue (
    DWORD dwType,
    LPBYTE pbInData,
    DWORD cbInData,
    LPBYTE pbOutData,
    LPDWORD pcbOutData
    ) {

    LONG err = ERROR_SUCCESS;
    DWORD cbOrigOutData;

    if (NULL == pcbOutData)
        return ERROR_SUCCESS;

    cbOrigOutData = *pcbOutData;

    if (0 == cbInData)
        *pcbOutData = 0;
    else if (REG_SZ == dwType || REG_EXPAND_SZ == dwType ||
            REG_MULTI_SZ == dwType) {
        int cchW;
        // First get length needed for wide characters
        cchW = MultiByteToWideChar(
                    0,                      // codepage
                    0,                      // dwFlags
                    (LPCSTR) pbInData,
                    cbInData,
                    NULL,                   // lpWideCharStr
                    0);                     // cchWideChar
        *pcbOutData = cchW * sizeof(WCHAR);
        if(cchW == 0)
            err = GetLastError();
        else if (pbOutData) {
            if (cbOrigOutData < *pcbOutData)
                err = ERROR_MORE_DATA;
            else
                // Convert to Unicode data
                MultiByteToWideChar(
                    0,                      // codepage
                    0,                      // dwFlags
                    (LPCSTR) pbInData,
                    cbInData,
                    (LPWSTR) pbOutData,
                    cchW);
        }
    } else {
        // Copy to output
        *pcbOutData = cbInData;
        if (pbOutData) {
            if (cbOrigOutData < cbInData)
                err = ERROR_MORE_DATA;
            else
                memcpy(pbOutData, pbInData, cbInData);
        }
    }

    return err;
}

#define MAX_REG_VALUE_DATA  256

LONG WINAPI RegEnumValue9x (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    char rgch[_MAX_PATH];
    char *  szValueName;
    DWORD   cbValueName;
    DWORD   dwType;
    LONG    err;

    BYTE rgbData[MAX_REG_VALUE_DATA];
    BYTE *pbData;
    DWORD cbData;

    szValueName = rgch;
    cbValueName = sizeof(rgch);
    pbData = rgbData;
    cbData = sizeof(rgbData);
    err = RegEnumValueA (
        hKey,
        dwIndex,
        szValueName,
        &cbValueName,
        lpReserved,
        &dwType,
        pbData,
        &cbData
        );
    if (lpType)
        *lpType = dwType;
    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER) &&
            (err != ERROR_MORE_DATA))
        goto ErrorReturn;

    err = ERROR_SUCCESS;

    cbValueName++;                      // count the NULL terminator
    if (sizeof(rgch) < cbValueName || sizeof(rgbData) < cbData) {
        if (sizeof(rgch) < cbValueName) {
            szValueName = (char *) malloc( cbValueName);
            if(!szValueName) {
                err = ERROR_OUTOFMEMORY;
                goto ErrorReturn;
            }
        }
        if (sizeof(rgbData) < cbData) {
            pbData = (BYTE *) malloc(cbData);
            if(!pbData) {
                err = ERROR_OUTOFMEMORY;
                goto ErrorReturn;
            }
        }
        err = RegEnumValueA (
            hKey,
            dwIndex,
            szValueName,
            &cbValueName,
            lpReserved,
            lpType,
            pbData,
            &cbData
            );
        cbValueName++;                  // count the NULL terminator
    }

    if (err == ERROR_SUCCESS) {
        int     cchW;
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szValueName,
                            cbValueName,
                            lpValueName,
                            lpValueName ? *lpcchValueName : 0);
        if(cchW == 0)
            err = GetLastError();
        else
            *lpcchValueName = cchW - 1; // does not include NULL
    } else
        *lpcchValueName = 0;

    if (err == ERROR_SUCCESS)
        err = ConvertRegValue (
            dwType,
            pbData,
            cbData,
            lpData,
            lpcbData);
    else if (lpcbData)
        *lpcbData = 0;

CommonReturn:
    if(szValueName != rgch && szValueName)
        free(szValueName);
    if(pbData != rgbData && pbData)
        free(pbData);
    return err;
ErrorReturn:
    *lpcchValueName = 0;
    if (lpcbData)
        *lpcbData = 0;
    goto CommonReturn;
}

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcchValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    if(FIsWinNT())
        return( RegEnumValueW (
                hKey,
                dwIndex,
                lpValueName,
                lpcchValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));
    else
        return( RegEnumValue9x (
                hKey,
                dwIndex,
                lpValueName,
                lpcchValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));
}


LONG RegDeleteValue9x (
    HKEY hKey,
    LPCWSTR lpValueName
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szValueName;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpValueName, &szValueName))
        err = RegDeleteValueA (
            hKey,
            szValueName
            );

    FreeMBStr(rgb, szValueName);

    return(err);
}

LONG RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    ) {

    if(FIsWinNT())
        return(RegDeleteValueW (
            hKey,
            lpValueName
            ));
    else
        return(RegDeleteValue9x (
            hKey,
            lpValueName
            ));
}


LONG RegQueryValueEx9x(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    BYTE    rgb[_MAX_PATH];
    char *  szValueName = NULL;
    LONG    err;
    DWORD   dwType;

    BYTE rgbData[MAX_REG_VALUE_DATA];
    BYTE *pbData;
    DWORD cbData;

    pbData = rgbData;
    cbData = sizeof(rgbData);

    if(MkMBStr(rgb, _MAX_PATH, lpValueName, &szValueName))
        err = RegQueryValueExA (
            hKey,
            szValueName,
            lpReserved,
            &dwType,
            pbData,
            &cbData
            );
    else {
        err = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }


    if (lpType)
        *lpType = dwType;

    if((err != ERROR_SUCCESS) && (err != ERROR_INSUFFICIENT_BUFFER) &&
            (err != ERROR_MORE_DATA))
        goto ErrorReturn;
    err = ERROR_SUCCESS;

    if (sizeof(rgbData) < cbData) {
        pbData = (BYTE *) malloc(cbData);
        if(!pbData) {
            err = ERROR_OUTOFMEMORY;
            goto ErrorReturn;
        }
        err = RegQueryValueExA (
            hKey,
            szValueName,
            lpReserved,
            &dwType,
            pbData,
            &cbData
            );
    }

    if (err == ERROR_SUCCESS)
        err = ConvertRegValue (
            dwType,
            pbData,
            cbData,
            lpData,
            lpcbData);
    else if (lpcbData)
        *lpcbData = 0;

CommonReturn:
    FreeMBStr(rgb, szValueName);
    if(pbData != rgbData && pbData)
        free(pbData);
    return err;
ErrorReturn:
    if (lpcbData)
        *lpcbData = 0;
    goto CommonReturn;
}

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    ) {

    if (lpReserved != NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    
    if(FIsWinNT())
        return(RegQueryValueExW (
                hKey,
                lpValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));
    else
        return(RegQueryValueEx9x (
                hKey,
                lpValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData
                ));
}


LONG WINAPI RegSetValueEx9x (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szValueName;
    LONG    err;

    err = ERROR_OUTOFMEMORY;
    if(MkMBStr(rgb1, _MAX_PATH, lpValueName, &szValueName))
    {
        // convert the data to ascii if necessary
        if (0 != cbData / sizeof(WCHAR) &&
                (REG_SZ == dwType || REG_EXPAND_SZ == dwType ||
                    REG_MULTI_SZ == dwType))
        {
            char *  szData;
            int cbConverted;

            if(MkMBStrEx(NULL, 0, (LPWSTR)lpData, cbData/sizeof(WCHAR),
                &szData, &cbConverted))
            {
                err = RegSetValueExA (
                    hKey,
                    szValueName,
                    Reserved,
                    dwType,
                    (BYTE*)szData,
                    cbConverted
                    );
                FreeMBStr(NULL, szData);
            }
        }
        else
        {
            err = RegSetValueExA (
                hKey,
                szValueName,
                Reserved,
                dwType,
                lpData,
                cbData
                );
        }
        FreeMBStr(rgb1, szValueName);
    }


    return(err);
}

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    ) {

    if(FIsWinNT())
        return(RegSetValueExW (
            hKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData
            ));
    else
        return(RegSetValueEx9x (
            hKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData
            ));
}


LONG WINAPI RegQueryInfoKey9x (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    ) {

    BYTE rgb[_MAX_PATH];
    char *  szClass;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb, _MAX_PATH, lpClass, &szClass))
        err =  RegQueryInfoKeyA (
            hKey,
            szClass,
            lpcbClass,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen,
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            lpcbSecurityDescriptor,
            lpftLastWriteTime
            );
    if (lpcbMaxValueLen)
        // Need to double for converting to unicode characters.
        *lpcbMaxValueLen = *lpcbMaxValueLen * 2;

    FreeMBStr(rgb, szClass);

    return(err);
}

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    ) {

    if(FIsWinNT())
        return( RegQueryInfoKeyW (
            hKey,
            lpClass,
            lpcbClass,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen,
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            lpcbSecurityDescriptor,
            lpftLastWriteTime
            ));
    else
        return( RegQueryInfoKey9x (
            hKey,
            lpClass,
            lpcbClass,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen,
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            lpcbSecurityDescriptor,
            lpftLastWriteTime
            ));
}


LONG WINAPI RegOpenKeyEx9x(
    HKEY hKey,  // handle of open key
    LPCWSTR lpSubKey,   // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    BYTE rgb1[_MAX_PATH];
    char *  szSubKey = NULL;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpSubKey, &szSubKey) )
        err = RegOpenKeyExA(
            hKey,
            szSubKey,
            ulOptions,
            samDesired,
            phkResult);

    FreeMBStr(rgb1, szSubKey);

    return(err);
}

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,  // handle of open key
    LPCWSTR lpSubKey,   // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    if(FIsWinNT())
        return( RegOpenKeyExW(
            hKey,
            lpSubKey,
            ulOptions,
            samDesired,
            phkResult
            ));
    else
        return( RegOpenKeyEx9x(
            hKey,
            lpSubKey,
            ulOptions,
            samDesired,
            phkResult
            ));
}


LONG WINAPI RegConnectRegistry9x (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    ) {

    BYTE rgb1[_MAX_PATH];
    char *  szMachineName = NULL;
    LONG    err;

    err = FALSE;
    if(MkMBStr(rgb1, _MAX_PATH, lpMachineName, &szMachineName) )
        err = RegConnectRegistryA(
            szMachineName,
            hKey,
            phkResult);

    FreeMBStr(rgb1, szMachineName);

    return(err);
}

LONG WINAPI RegConnectRegistryU (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    ) {

    if(FIsWinNT())
        return( RegConnectRegistryW(
            lpMachineName,
            hKey,
            phkResult
            ));
    else
        return( RegConnectRegistry9x(
            lpMachineName,
            hKey,
            phkResult
            ));
}


#endif      // _M_IX86


LONG WINAPI RegCreateHKCUKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegCreateKeyExU(hKey, lpSubKey, Reserved, lpClass, dwOptions,
                               samDesired, lpSecurityAttributes, phkResult,
                               lpdwDisposition));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegCreateKeyExW(hCurUser, lpSubKey, Reserved, lpClass,  dwOptions,
                              samDesired, lpSecurityAttributes, phkResult,
                              lpdwDisposition);
    RegCloseHKCU(hCurUser);
    return(err);
}

LONG WINAPI RegCreateHKCUKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegCreateKeyExA(hKey, lpSubKey, Reserved, lpClass, dwOptions,
                               samDesired, lpSecurityAttributes, phkResult,
                               lpdwDisposition));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegCreateKeyExA(hCurUser, lpSubKey, Reserved, lpClass,  dwOptions,
                              samDesired, lpSecurityAttributes, phkResult,
                              lpdwDisposition);
    RegCloseHKCU(hCurUser);
    return(err);
}


LONG WINAPI RegOpenHKCUKeyExU(
    HKEY hKey,  // handle of open key
    LPCWSTR lpSubKey,   // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegOpenKeyExU(hKey, lpSubKey, ulOptions,
                               samDesired, phkResult));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }


    err = RegOpenKeyExW(hCurUser, lpSubKey, ulOptions, samDesired, phkResult);

    RegCloseHKCU(hCurUser);

    return(err);
}

LONG WINAPI RegOpenHKCUKeyExA(
    HKEY hKey,  // handle of open key
    LPCSTR lpSubKey,    // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
   ) {

    if ((hKey != HKEY_CURRENT_USER) || !(FIsWinNT()))
    {
        return(RegOpenKeyExA(hKey, lpSubKey, ulOptions,
                               samDesired, phkResult));
    }

    HKEY    hCurUser;
    LONG    err;

    if ((err = RegOpenHKCU(&hCurUser)) != ERROR_SUCCESS)
    {
        return(err);
    }

    err = RegOpenKeyExA(hCurUser, lpSubKey, ulOptions, samDesired, phkResult);

    RegCloseHKCU(hCurUser);

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\ole.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ole.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include "unicode.h"

#ifdef _M_IX86

// note: unlike UUidToString, always must LocalFree() returned memory
RPC_STATUS RPC_ENTRY UuidToStringU( 
    UUID *  Uuid, 	
    WCHAR * *  StringUuid	
   ) {

    char *  pszUuid = NULL;
    LONG    err;

    err = FALSE;
    if(RPC_S_OK == 
        (err = UuidToStringA(
               Uuid,
               (unsigned char * *)&pszUuid
               )) )
    {
        // convert A output to W
        LPWSTR sz = MkWStr(pszUuid);
        RpcStringFree((unsigned char * *)&pszUuid);
	if( sz == NULL )
	    return(ERROR_OUTOFMEMORY);

        // copy into output pointer
	*StringUuid = (WCHAR*) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(sz)+1));

	if(*StringUuid != NULL)
	    wcscpy(*StringUuid, sz);
	else
	    err = ERROR_OUTOFMEMORY;
        
        // Do nice free of other buffer
        FreeWStr(sz);
    }

    return(err);
}

#endif // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\nt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       nt.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "unicode.h"
#include "crtem.h" // bring in malloc+free definitions


#ifdef _M_IX86

BOOL WINAPI GetUserName9x(
    LPWSTR lpBuffer,    // address of name buffer
    LPDWORD nSize   // address of size of name buffer
   ) {

    char rgch[_MAX_PATH];
    char *szBuffer;
    DWORD cbBuffer;

    int     cchW;
    BOOL fResult;

    szBuffer = rgch;
    cbBuffer = sizeof(rgch);
    fResult = GetUserNameA(
           szBuffer,
           &cbBuffer);

    if (!fResult)
        return FALSE;

    cbBuffer++;                      // count the NULL terminator
    if (sizeof(rgch) < cbBuffer)
    {
        szBuffer = (char *) malloc(cbBuffer);
        if(!szBuffer)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        fResult = GetUserNameA(
               szBuffer,
               &cbBuffer);
        cbBuffer++;                    // count the NULL terminator
    }

    if(fResult)
    {
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szBuffer,
                            cbBuffer,
                            lpBuffer,
                            *nSize);
        if(cchW == 0)
            fResult = FALSE;
        else
            *nSize = cchW - 1; // does not include NULL
    }

    if(szBuffer != rgch)
        free(szBuffer);

    return(fResult);
}

BOOL WINAPI GetUserNameU(
    LPWSTR lpBuffer,    // address of name buffer
    LPDWORD nSize   // address of size of name buffer
   ) {

    if(FIsWinNT())
        return( GetUserNameW(lpBuffer, nSize));
    else
        return( GetUserName9x(lpBuffer, nSize));
}


BOOL WINAPI GetComputerName9x(
    LPWSTR lpBuffer,    // address of name buffer
    LPDWORD nSize   // address of size of name buffer
   ) {

    char rgch[_MAX_PATH];
    char *szBuffer;
    DWORD cbBuffer;

    int     cchW;
    BOOL fResult;

    szBuffer = rgch;
    cbBuffer = sizeof(rgch);
    fResult = GetComputerNameA(
           szBuffer,
           &cbBuffer);

    if (!fResult)
        return fResult;

    cbBuffer++;                      // count the NULL terminator
    if (sizeof(rgch) < cbBuffer)
    {
        szBuffer = (char *) malloc(cbBuffer);
        if(!szBuffer)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        fResult = GetComputerNameA(
               szBuffer,
               &cbBuffer);
        cbBuffer++;                    // count the NULL terminator
    }

    if(fResult)
    {
        cchW = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szBuffer,
                            cbBuffer,
                            lpBuffer,
                            *nSize);
        if(cchW == 0)
            fResult = FALSE;
        else
            *nSize = cchW - 1; // does not include NULL
    }

    if(szBuffer != rgch)
        free(szBuffer);

    return(fResult);
}

BOOL WINAPI GetComputerNameU(
    LPWSTR lpBuffer,    // address of name buffer
    LPDWORD nSize   // address of size of name buffer
   ) {

    if(FIsWinNT())
        return( GetComputerNameW(lpBuffer, nSize));
    else
        return( GetComputerName9x(lpBuffer, nSize));
}


DWORD WINAPI GetModuleFileName9x(
    HMODULE hModule,    // handle to module to find filename for
    LPWSTR lpFilename,  // pointer to buffer for module path
    DWORD nSize     // size of buffer, in characters
   ) {

    char rgch[_MAX_PATH];
    DWORD cbBuffer;

    DWORD    cch;

    cbBuffer = sizeof(rgch);
    cch = GetModuleFileNameA(
           hModule,
           rgch,
           cbBuffer);

    if(cch == 0)
        return 0;

    return MultiByteToWideChar(
                        0,                      // codepage
                        0,                      // dwFlags
                        rgch,
                        cbBuffer,
                        lpFilename,
                        nSize);
}

DWORD WINAPI GetModuleFileNameU(
    HMODULE hModule,    // handle to module to find filename for
    LPWSTR lpFilename,  // pointer to buffer for module path
    DWORD nSize     // size of buffer, in characters
   ) {

    if(FIsWinNT())
        return( GetModuleFileNameW(hModule, lpFilename, nSize));
    else
        return( GetModuleFileName9x(hModule, lpFilename, nSize));
}


HMODULE WINAPI GetModuleHandle9x(
    LPCWSTR lpModuleName    // address of module name to return handle for
   ) {

    char *  szBuffer = NULL;
    BYTE    rgb1[_MAX_PATH];
    DWORD   cbBuffer;

    HMODULE hModule;

    hModule = NULL;
    if(MkMBStr(rgb1, _MAX_PATH, lpModuleName, &szBuffer) )
        hModule = GetModuleHandleA(
            szBuffer);

    FreeMBStr(rgb1, szBuffer);

    return hModule;
}

HMODULE WINAPI GetModuleHandleU(
    LPCWSTR lpModuleName    // address of module name to return handle for
   ) {

    if(FIsWinNT())
        return( GetModuleHandleW(lpModuleName));
    else
        return( GetModuleHandle9x(lpModuleName));
}

#endif // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\reghkcu.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    reghkcu.c

Abstract:

    This module implements functionality to correctly access the pre-defined
    registry key HKEY_CURRENT_USER.

Author:

    Scott Field (sfield)    03-Jul-97

--*/

#include <windows.h>

#include "crtem.h"
#include "unicode.h"

#define TEXTUAL_SID_LOCAL_SYSTEM    L"S-1-5-18"

BOOL
GetTextualSidHKCU(
    IN      PSID    pSid,           // binary Sid
    IN      LPWSTR  TextualSid,     // buffer for Textual representaion of Sid
    IN  OUT LPDWORD pcchTextualSid  // required/provided TextualSid buffersize
    );

BOOL
GetTokenUserSidHKCU(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    );


static LONG GetStatus()
{
    DWORD dwErr = GetLastError();
    if (ERROR_SUCCESS == dwErr)
        return ERROR_INVALID_DATA;
    else
        return (LONG) dwErr;
}

LONG
WINAPI
RegOpenHKCU(
    HKEY *phKeyCurrentUser
    )
{
    return RegOpenHKCUEx(phKeyCurrentUser, 0);
}

LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    )
{
    WCHAR wszFastBuffer[256];
    LPWSTR wszSlowBuffer = NULL;
    LPWSTR wszTextualSid;
    DWORD cchTextualSid;

    LONG lRet = ERROR_SUCCESS;

    *phKeyCurrentUser = NULL;

    //
    // Win95: just return HKEY_CURRENT_USER, as we don't have
    // multiple security contexts on that platform.
    //

    if(!FIsWinNT()) {
        *phKeyCurrentUser = HKEY_CURRENT_USER;
        return ERROR_SUCCESS;
    }

    //
    // WinNT: first, map the binary Sid associated with the
    // current security context to an textual Sid.
    //

    wszTextualSid = wszFastBuffer;
    cchTextualSid = sizeof(wszFastBuffer) / sizeof(WCHAR);

    if(!GetUserTextualSidHKCU(wszTextualSid, &cchTextualSid)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            return GetStatus();

        //
        // try again with larger buffer.
        //

        wszSlowBuffer = (LPWSTR)malloc(cchTextualSid * sizeof(WCHAR));
        if(wszSlowBuffer == NULL)
            return GetStatus();

        wszTextualSid = wszSlowBuffer;
        if(!GetUserTextualSidHKCU(wszTextualSid, &cchTextualSid)) {
            free(wszSlowBuffer);
            return GetStatus();
        }
    }

    //
    // next, try to open the registry key below HKEY_USERS
    // that corresponds to the textual Sid.
    //

    lRet = RegOpenKeyExW(
                    HKEY_USERS,
                    wszTextualSid,
                    0,      // dwOptions
                    MAXIMUM_ALLOWED,
                    phKeyCurrentUser
                    );

    if(lRet != ERROR_SUCCESS) {

        if (dwFlags & REG_HKCU_DISABLE_DEFAULT_FLAG)
            lRet = ERROR_FILE_NOT_FOUND;
        else if (0 == (dwFlags & REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG) ||
                0 == wcscmp(TEXTUAL_SID_LOCAL_SYSTEM, wszTextualSid)) {
            //
            // If that failed, fall back to HKEY_USERS\.Default.
            // Note: this is correct behavior with respect to the
            // rest of the system, eg, Local System security context
            // has no registry hive loaded by default
            //

            lRet = RegOpenKeyExW(
                            HKEY_USERS,
                            L".Default",
                            0,      // dwOptions
                            MAXIMUM_ALLOWED,
                            phKeyCurrentUser
                            );
        }
    }


    if(wszSlowBuffer)
        free(wszSlowBuffer);

    return lRet;
}


LONG
WINAPI
RegCloseHKCU(
    HKEY hKeyCurrentUser
    )
{
    LONG lRet = ERROR_SUCCESS;

    if( hKeyCurrentUser != NULL && hKeyCurrentUser != HKEY_CURRENT_USER )
        lRet = RegCloseKey( hKeyCurrentUser );

    return lRet;
}



BOOL
WINAPI
GetUserTextualSidHKCU(
    IN      LPWSTR  wszTextualSid,
    IN  OUT LPDWORD pcchTextualSid
    )
{
    HANDLE hToken;
    PSID pSidUser = NULL;
    BOOL fSuccess = FALSE;

    //
    // first, attempt to look at the thread token.  If none exists,
    // which is true if the thread is not impersonating, try the
    // process token.
    //

    if(!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                &hToken
                ))
    {
        if(GetLastError() != ERROR_NO_TOKEN)
            return FALSE;

        if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            return FALSE;
    }

    fSuccess = GetTokenUserSidHKCU(hToken, &pSidUser);

    CloseHandle(hToken);

    if(fSuccess) {

        //
        // obtain the textual representaion of the Sid
        //

        fSuccess = GetTextualSidHKCU(
                        pSidUser,       // user binary Sid
                        wszTextualSid,  // buffer for TextualSid
                        pcchTextualSid  // required/result buffer size in chars (including NULL)
                        );
    }

    if(pSidUser)
        free(pSidUser);

    return fSuccess;
}

BOOL
GetTextualSidHKCU(
    IN      PSID    pSid,           // binary Sid
    IN      LPWSTR  TextualSid,     // buffer for Textual representaion of Sid
    IN  OUT LPDWORD pcchTextualSid  // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidSize;


    //
    // validate Sid validity
    //

    if(!IsValidSid(pSid))
        return FALSE;

    //
    // obtain SidIdentifierAuthority
    //

    psia = GetSidIdentifierAuthority(pSid);

    //
    // obtain sidsubauthority count
    //

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute buffer length in chars (conservative guess)
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) ;

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*pcchTextualSid < cchSidSize) {
        *pcchTextualSid = cchSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidSize = wsprintfW(TextualSid, L"S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
                    L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
                    L"%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidSize += wsprintfW(TextualSid + cchSidSize,
            L"-%lu", *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell caller how many chars copied, including terminal NULL
    //

    *pcchTextualSid = cchSidSize + 1;

    return TRUE;
}

BOOL
GetTokenUserSidHKCU(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    )
/*++

    This function queries the access token specified by the
    hToken parameter, and returns an allocated copy of the
    TokenUser information on success.

    The access token specified by hToken must be opened for
    TOKEN_QUERY access.

    On success, the return value is TRUE.  The caller is
    responsible for freeing the resultant UserSid via a call
    to free().

    On failure, the return value is FALSE.  The caller does
    not need to free any buffer.

--*/
{
    BYTE FastBuffer[256];
    LPBYTE SlowBuffer = NULL;
    PTOKEN_USER ptgUser;
    DWORD cbBuffer;
    BOOL fSuccess = FALSE;

    *ppUserSid = NULL;

    //
    // try querying based on a fast stack based buffer first.
    //

    ptgUser = (PTOKEN_USER)FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    fSuccess = GetTokenInformation(
                    hToken,    // identifies access token
                    TokenUser, // TokenUser info type
                    ptgUser,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    );

    if(!fSuccess) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            //
            // try again with the specified buffer size
            //

            SlowBuffer = (LPBYTE)malloc(cbBuffer);

            if(SlowBuffer != NULL) {
                ptgUser = (PTOKEN_USER)SlowBuffer;

                fSuccess = GetTokenInformation(
                                hToken,    // identifies access token
                                TokenUser, // TokenUser info type
                                ptgUser,   // retrieved info buffer
                                cbBuffer,  // size of buffer passed-in
                                &cbBuffer  // required buffer size
                                );
            }
        }
    }

    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    if(fSuccess) {

        DWORD cbSid;

        // reset to assume failure
        fSuccess = FALSE;

        cbSid = GetLengthSid(ptgUser->User.Sid);

        *ppUserSid = malloc( cbSid );

        if(*ppUserSid != NULL) {
            fSuccess = CopySid(cbSid, *ppUserSid, ptgUser->User.Sid);
        }
    }

    if(!fSuccess) {
        if(*ppUserSid) {
            free(*ppUserSid);
            *ppUserSid = NULL;
        }
    }

    if(SlowBuffer)
        free(SlowBuffer);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\guid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       guid.cpp
//
//  Contents:   Microsoft Internet Security Guid functions
//
//  Functions:  wstr2guid
//              guid2wstr
//
//  History:    05-Sep-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include "windows.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>

#include "crtem.h"
#include "redir.h"
#include "unicode.h"


static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR wszDigits[] = L"0123456789ABCDEF";


static BOOL HexStringToDword(LPCWSTR FAR& pwsz, DWORD FAR& Value,
                             int cDigits, WCHAR chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, pwsz++)
    {
        if (*pwsz >= '0' && *pwsz <= '9')
        {
            Value = (Value << 4) + *pwsz - '0';
        }
        else if (*pwsz >= 'A' && *pwsz <= 'F')
        {
            Value = (Value << 4) + *pwsz - 'A' + 10;
        }
        else if (*pwsz >= 'a' && *pwsz <= 'f')
        {
            Value = (Value << 4) + *pwsz - 'a' + 10;
        }
        else
        {
            return(FALSE);
        }
    }

    if (chDelim != 0)
    {
        return *pwsz++ == chDelim;
    }
    else
    {
        return(TRUE);
    }
}

BOOL WINAPI wstr2guid(const WCHAR *pwszIn, GUID *pgOut)
{
    WCHAR   wsz[9];

    if (!(pwszIn) || !(pgOut))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (*pwszIn != '{') // only support v2 guids!
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (wcslen(pwszIn) != 38)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    WCHAR   *pwsz;

    pwsz = (WCHAR *)&pwszIn[1];  // pass the first {

    memset(pgOut, 0x00, sizeof(GUID));

    DWORD dw;

    if (!(HexStringToDword(pwsz, pgOut->Data1, sizeof(DWORD)*2, '-')))
    {
        return(FALSE);
    }

    if (!(HexStringToDword(pwsz, dw, sizeof(WORD)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data2 = (WORD)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(WORD)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data3 = (WORD)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[0] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, '-')))
    {
        return(FALSE);
    }

    pgOut->Data4[1] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[2] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[3] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[4] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[5] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[6] = (BYTE)dw;

    if (!(HexStringToDword(pwsz, dw, sizeof(BYTE)*2, 0)))
    {
        return(FALSE);
    }

    pgOut->Data4[7] = (BYTE)dw;

    return(TRUE);
}

BOOL WINAPI guid2wstr(const GUID *pgIn, WCHAR *pwszOut)
{
    if (!(pwszOut) || !(pgIn))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    const BYTE  *pBytes;
    int         i;
    LPWSTR      p;

    p       = pwszOut;
    pBytes  = (const BYTE *)pgIn;

    *p++ = L'{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = L'-';
        }
        else
        {
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = L'}';
    *p   = L'\0';

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\unicode\user.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       user.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "unicode.h"
#include "crtem.h"
#include <stddef.h>

#ifdef _M_IX86

#define MAX_STRING_RSC_SIZE 512

int WINAPI LoadString9x(
    HINSTANCE hInstance,	// handle of module containing string resource 
    UINT uID,	// resource identifier 
    LPWSTR lpBuffer,	// address of buffer for resource 
    int nBufferMax 	// size of buffer 
   ) {
    
    char rgch[MAX_STRING_RSC_SIZE];
    int     cchW;
    LONG    err;

    err = LoadStringA(
        hInstance,
        uID,
        rgch,
        MAX_STRING_RSC_SIZE);

    if (err == 0)
        return err;

    return MultiByteToWideChar(
                        0,                      // codepage
                        0,                      // dwFlags
                        rgch,
                        err + 1,
                        lpBuffer,
                        nBufferMax);
}

int WINAPI LoadStringU(
    HINSTANCE hInstance,	// handle of module containing string resource 
    UINT uID,	// resource identifier 
    LPWSTR lpBuffer,	// address of buffer for resource 
    int nBufferMax 	// size of buffer 
   ) {
    
    if(FIsWinNT())
        return( LoadStringW(
            hInstance,
            uID,
            lpBuffer,
            nBufferMax
            ));
    else
        return( LoadString9x(
            hInstance,
            uID,
            lpBuffer,
            nBufferMax
            ));
}


BOOL
WINAPI
InsertMenu9x(
    HMENU       hMenu,
    UINT        uPosition,
    UINT        uFlags,
    UINT_PTR    uIDNewItem,
    LPCWSTR     lpNewItem
    )
{

    LPSTR       pszNewItem=NULL;
    BOOL        fReturn=FALSE;

    if( (0 == (uFlags & MF_BITMAP)) &&
        (0 == (uFlags & MF_OWNERDRAW))
      )
    {

        if(!MkMBStr(NULL, 0, lpNewItem, &pszNewItem))
            return FALSE;

        fReturn=InsertMenuA(
                hMenu,
                uPosition,
                uFlags,
                uIDNewItem,
                (LPCSTR)pszNewItem);
    }
    else
    {
        fReturn=InsertMenuA(
                hMenu,
                uPosition,
                uFlags,
                uIDNewItem,
                (LPCSTR)lpNewItem);
    }

    if(pszNewItem)
         FreeMBStr(NULL, pszNewItem);

    return fReturn;
}

BOOL
WINAPI
InsertMenuU(
    HMENU       hMenu,
    UINT        uPosition,
    UINT        uFlags,
    UINT_PTR    uIDNewItem,
    LPCWSTR     lpNewItem
    )
{
    if(FIsWinNT())
        return InsertMenuW(
                hMenu,
                uPosition,
                uFlags,
                uIDNewItem,
                lpNewItem);
    else
        return InsertMenu9x(
                hMenu,
                uPosition,
                uFlags,
                uIDNewItem,
                lpNewItem);
}


//-------------------------------------------------------------------------
//
//  FormatMessageU 
//      This function assume any patten of !S! or !s! in lpSource are used for 
//  formatting purpose only.
//
//--------------------------------------------------------------------------
DWORD WINAPI FormatMessage9x(
    DWORD dwFlags,	    // source and processing options 
    LPCVOID lpSource,	// pointer to  message source 
    DWORD dwMessageId,	// requested message identifier 
    DWORD dwLanguageId,	// language identifier for requested message 
    LPWSTR lpBuffer,	// pointer to message buffer 
    DWORD nSize,	    // maximum size of message buffer 
    va_list *Arguments 	// address of array of message inserts 
   )
{
    
    DWORD   cb=0;
    LPSTR   pChar=NULL;
    DWORD   dwSize=0;

    LPSTR   pszSource=NULL;
    LPSTR   pszBuffer=NULL;
    LPWSTR  pwszBuffer=NULL;

    //we need to change the lpSource
    if((dwFlags & FORMAT_MESSAGE_FROM_STRING) && 
       (0 == (dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS))
      )
    {
        //get the ascii version of the string
         if((lpSource == NULL) || !MkMBStr(NULL, 0, (LPWSTR)lpSource, &pszSource))
            goto CLEANUP;
         
         //we change "!S!" to "!s!" and "!s!" to "!S!"
         pChar = pszSource;

         while((*pChar) != '\0')
         {
            if((*pChar) == '!')
            {
                if((*(pChar+1)) == 's')
                {
                    if((*(pChar+2)) == '!')
                        *(pChar+1)='S';
                }
                else
                {
                    if((*(pChar+1)) == 'S')
                    {
                        if((*(pChar+2)) == '!')
                           *(pChar+1)='s';
                    }
                }
            }

            pChar++;
         }

    }

    if(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
    {
        cb = FormatMessageA(
            dwFlags,
            pszSource,
            dwMessageId,
            dwLanguageId,
            (LPSTR)&pszBuffer,
            nSize,
            Arguments);

        if(cb)
        {
            if(NULL == (pwszBuffer=MkWStr(pszBuffer)))
            {
                cb=0;
                goto CLEANUP;
            }

            dwSize=sizeof(WCHAR)*(wcslen(pwszBuffer) +1);

            *((LPWSTR *)lpBuffer)=(LPWSTR)LocalAlloc(LPTR, dwSize);

            if(NULL == (*lpBuffer))
            {
                cb=0;
                goto CLEANUP;
            }

            wcscpy((*((LPWSTR *)lpBuffer)), pwszBuffer);

            cb=wcslen(pwszBuffer);
        }

    }
    else
    {   

        pszBuffer=(LPSTR)LocalAlloc(LPTR, sizeof(CHAR) * nSize);

        if (NULL == pszBuffer)
            goto CLEANUP;

        cb = FormatMessageA(
            dwFlags,
            pszSource,
            dwMessageId,
            dwLanguageId,
            pszBuffer,
            nSize,
            Arguments);
       
        if(cb)
        {
            if(NULL == (pwszBuffer=MkWStr(pszBuffer)))
            {
                cb=0;
                goto CLEANUP;
            }

            wcscpy((LPWSTR)lpBuffer, pwszBuffer);

            cb=wcslen(pwszBuffer);
        }
    }   

CLEANUP:

    if(pszSource)
         FreeMBStr(NULL,pszSource);

    if(pszBuffer)
         LocalFree((HLOCAL)pszBuffer);

    if(pwszBuffer)
         FreeWStr(pwszBuffer);

    return(cb);
}

DWORD WINAPI FormatMessageU(
    DWORD dwFlags,	    // source and processing options 
    LPCVOID lpSource,	// pointer to  message source 
    DWORD dwMessageId,	// requested message identifier 
    DWORD dwLanguageId,	// language identifier for requested message 
    LPWSTR lpBuffer,	// pointer to message buffer 
    DWORD nSize,	    // maximum size of message buffer 
    va_list *Arguments 	// address of array of message inserts 
   )
{
    if(FIsWinNT())
        return( FormatMessageW(
            dwFlags,
            lpSource,
            dwMessageId,
            dwLanguageId,
            lpBuffer,
            nSize,
            Arguments
            ));
    else
        return( FormatMessage9x(
            dwFlags,
            lpSource,
            dwMessageId,
            dwLanguageId,
            lpBuffer,
            nSize,
            Arguments
            ));
}


//-------------------------------------------------------------------------
//
//  CompareStringU 
//      This function only handles the case where cchCount1==-1 and cchCount==-1.
//
//--------------------------------------------------------------------------
int
WINAPI
CompareString9x(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR  lpString1,
    int      cchCount1,
    LPCWSTR  lpString2,
    int      cchCount2)
{
	int		iReturn=0;
	int     cb1=0;
	int     cb2=0;

	LPSTR	psz1=NULL;
	LPSTR	psz2=NULL;

    cb1 = WideCharToMultiByte(
            0, 
            0, 
            lpString1, 
            cchCount1, 
            NULL,
            0,
            NULL,
			NULL);

	if(NULL==(psz1=(LPSTR)malloc(cb1)))
	{
		SetLastError(E_OUTOFMEMORY);
		goto CLEANUP;
	}

    if(0 == (cb1 = WideCharToMultiByte(
            0, 
            0, 
            lpString1, 
            cchCount1, 
            psz1,
            cb1,
            NULL,
			NULL)))
		goto CLEANUP;

	 
    cb2 = WideCharToMultiByte(
            0, 
            0, 
            lpString2, 
            cchCount2, 
            NULL,
            0,
            NULL,
			NULL);

	if(NULL == (psz2=(LPSTR)malloc(cb2)))
	{
		SetLastError(E_OUTOFMEMORY);
		goto CLEANUP;
	}

    if(0 == (cb2 = WideCharToMultiByte(
            0, 
            0, 
            lpString2, 
            cchCount2, 
            psz2,
            cb2,
            NULL,
			NULL)))
		goto CLEANUP;

	iReturn = CompareStringA(Locale,
								dwCmpFlags,
								psz1,
								cb1,
								psz2,
								cb2);


CLEANUP:
	
	if(psz1)
		free(psz1);

	if(psz2)
		free(psz2);

	return iReturn;

}

int
WINAPI
CompareStringU(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR  lpString1,
    int      cchCount1,
    LPCWSTR  lpString2,
    int      cchCount2)
{
	if(FIsWinNT())
        return CompareStringW(
                    Locale,
					dwCmpFlags,
					lpString1,
					cchCount1,
					lpString2,
					cchCount2);
	else
        return CompareString9x(
                    Locale,
					dwCmpFlags,
					lpString1,
					cchCount1,
					lpString2,
					cchCount2);
}


//-------------------------------------------------------------------------
//
//  PropertySheetU
//
//--------------------------------------------------------------------------
typedef   INT_PTR   (WINAPI *PFPropertySheetA)(LPCPROPSHEETHEADERA);
typedef   INT_PTR   (WINAPI *PFPropertySheetW)(LPCPROPSHEETHEADERW);

INT_PTR WINAPI PropertySheet9x(
    LPPROPSHEETHEADERW  lppsph)
{
    PROPSHEETHEADERA        PropHeaderA;
    INT_PTR                 iReturn=-1;
    DWORD                   dwIndex=0;
    UINT                    nPages=0; 
    DWORD                   dwSize=0;
 
    LPPROPSHEETPAGEA        pPropSheetA=NULL;
    LPSTR                   pszCaption=NULL;
    LPSTR                   pszTitle=NULL;

    HMODULE                 hModule=NULL;  
    PFPropertySheetA        pfPropertySheetA=NULL;
    
    
    //load the comctl.32 since many dlls in ispu project
    //use unicode.lib, just do not link to comctl32.dll
    if(NULL == (hModule=LoadLibrary("comctl32.dll")))
        return iReturn;

    memcpy(&PropHeaderA, lppsph, sizeof(PROPSHEETHEADERA));

    if(lppsph->pszCaption)
    {
         if(!MkMBStr(NULL, 0, (LPWSTR)(lppsph->pszCaption), &pszCaption))
            goto CLEANUP;

         PropHeaderA.pszCaption=pszCaption;
    }

    //convert the property sheets
    if(PSH_PROPSHEETPAGE & lppsph->dwFlags)
    {
        nPages = lppsph->nPages;

        if(nPages)
        {
            dwSize=sizeof(PROPSHEETPAGEA) * nPages;

            pPropSheetA=(LPPROPSHEETPAGEA)LocalAlloc(LPTR, dwSize);

            if(NULL == pPropSheetA)
                goto CLEANUP;

            memcpy(pPropSheetA, lppsph->ppsp, dwSize);

            //pre-set the title
            for(dwIndex=0; dwIndex < (DWORD)nPages; dwIndex++)
            {
                pPropSheetA[dwIndex].pszTitle=NULL;
            }

            for(dwIndex=0; dwIndex < (DWORD)nPages; dwIndex++)
            {
                if((lppsph->ppsp)[dwIndex].pszTitle)
                {
                     if(!MkMBStr(NULL, 0, (LPWSTR)((lppsph->ppsp)[dwIndex].pszTitle), 
                                &pszTitle))
                        goto CLEANUP;

                     pPropSheetA[dwIndex].pszTitle=pszTitle;
                }

            }

            PropHeaderA.ppsp=pPropSheetA;
        }
    }

    if(NULL != (pfPropertySheetA=(PFPropertySheetA)GetProcAddress(hModule, "PropertySheetA")))
    {
        iReturn=pfPropertySheetA(&PropHeaderA);
    }


CLEANUP:

    if(pszCaption)
        FreeMBStr(NULL, pszCaption);

    //free the title
    if(PropHeaderA.nPages)
    {
        for(dwIndex=0; dwIndex < PropHeaderA.nPages; dwIndex++)
        {
            if(pPropSheetA[dwIndex].pszTitle)
                FreeMBStr(NULL, (LPSTR)((pPropSheetA[dwIndex]).pszTitle));
        }

    }

    if(pPropSheetA)
        LocalFree((HLOCAL)pPropSheetA);


    if(hModule)
        FreeLibrary(hModule);

    return iReturn;
}

INT_PTR WINAPI PropertySheetU(
    LPPROPSHEETHEADERW  lppsph)
{
    INT_PTR             iReturn=-1;
    HMODULE             hModule=NULL; 
    PFPropertySheetW    pfPropertySheetW=NULL;
    
    if(FIsWinNT())
    {
        //load the comctl.32 since many dlls in ispu project
        //use unicode.lib, just do not link to comctl32.dll
        if(NULL == (hModule=LoadLibrary("comctl32.dll")))
            return iReturn;

        if(NULL != (pfPropertySheetW=(PFPropertySheetW)GetProcAddress(hModule, "PropertySheetW")))
        {
            iReturn=pfPropertySheetW(lppsph);
        } 
        
        FreeLibrary(hModule);
    }
    else
    {
        iReturn=PropertySheet9x(lppsph);
    }

    return iReturn;
}

//-------------------------------------------------------------------------
//
//  DragQueryFileU
//
//--------------------------------------------------------------------------
typedef UINT (WINAPI *PFDragQueryFileA)(HDROP,UINT,LPSTR,UINT);
typedef UINT (WINAPI *PFDragQueryFileW)(HDROP,UINT,LPWSTR,UINT);


UINT WINAPI     DragQueryFileU(
    HDROP   hDrop,
    UINT    iFile,
    LPWSTR  lpwszFile,
    UINT    cch)
{
    PFDragQueryFileA        pfA=NULL;
    PFDragQueryFileW        pfW=NULL;
    HMODULE                 hModule=NULL; 
    UINT                    iReturn=0;

    LPSTR                   psz=NULL;


    //load the shell32.dll since many dlls in ispu project
    //use unicode.lib, just do not link to comctl32.dll
    if(NULL == (hModule=LoadLibrary("shell32.dll")))
        return iReturn;


    if(FIsWinNT())
    {

        if(NULL != (pfW=(PFDragQueryFileW)GetProcAddress(hModule, "DragQueryFileW")))
        {
            iReturn=pfW(hDrop, iFile, lpwszFile, cch);
        }

        FreeLibrary(hModule);

        return iReturn;
    }

    //allocate memory
    if(0xFFFFFFFF != iFile)
    {
        if(lpwszFile)
        {
            //allocate a big enough buffer
            psz=(LPSTR)malloc(sizeof(WCHAR) * cch);
            if(NULL == psz)
                goto CLEANUP;
        }
    }

    if(NULL == (pfA=(PFDragQueryFileA)GetProcAddress(hModule, "DragQueryFileA")))
        goto CLEANUP;

    iReturn=pfA(hDrop, iFile, psz, cch);

    if(0 != iReturn)
    {
        if(0xFFFFFFFF != iFile)
        {
            if(lpwszFile && psz)
            {
                iReturn = MultiByteToWideChar(
                                    0,                      // codepage
                                    0,                      // dwFlags
                                    psz,
                                    iReturn+1,
                                    lpwszFile,
                                    cch);

                //we should return the # of characters excluding the NULL terminator
                if(0 != iReturn)
                    iReturn--;
            }
        }
    }


CLEANUP:

    if(psz)
        free(psz);

    return iReturn;

}

//-------------------------------------------------------------------------
//
//  CreatePropertySheetPageU
//
//      Notice: This function assumes that the LPCPROPSHEETPAGEW and 
//      LPCPROPSHEETPAGEA are equivalent.
//
//--------------------------------------------------------------------------
typedef   HPROPSHEETPAGE   (WINAPI *PFCreatePropertySheetPageA)(LPCPROPSHEETPAGEA);
typedef   HPROPSHEETPAGE   (WINAPI *PFCreatePropertySheetPageW)(LPCPROPSHEETPAGEW);

HPROPSHEETPAGE WINAPI CreatePropertySheetPageU(LPCPROPSHEETPAGEW    pPage)
{
    PFCreatePropertySheetPageA      pfA=NULL;
    PFCreatePropertySheetPageW      pfW=NULL;
    HMODULE                         hModule=NULL; 
    HPROPSHEETPAGE                  hPage=NULL;

    //load the comctl.32 since many dlls in ispu project
    //use unicode.lib, just do not link to comctl32.dll
    if(NULL == (hModule=LoadLibrary("comctl32.dll")))
        return hPage;


    if(FIsWinNT())
    {

        if(NULL != (pfW=(PFCreatePropertySheetPageW)GetProcAddress(hModule, "CreatePropertySheetPageW")))
        {
            hPage=pfW(pPage);
        }

        FreeLibrary(hModule);

        return hPage;
    }


    if(NULL != (pfA=(PFCreatePropertySheetPageA)GetProcAddress(hModule, "CreatePropertySheetPageA")))
    {
        hPage=pfA((LPCPROPSHEETPAGEA)pPage);
    }

    FreeLibrary(hModule);

    return hPage;
}


BOOL WINAPI SetWindowText9x(
    HWND hWnd,	// handle of window or control
    LPCWSTR lpString 	// address of string
   ) {
    BYTE rgb1[_MAX_PATH];
    char *  szString = NULL;
    LONG    err = 0;

    if (lpString == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    if( MkMBStr(rgb1, _MAX_PATH, lpString, &szString) &&
        (szString != NULL)) {
        err = SetWindowTextA(
                    hWnd,
                    szString);
    }

    if (szString != NULL)
        FreeMBStr(rgb1, szString);

    return(err);
}

BOOL WINAPI SetWindowTextU(
    HWND hWnd,	// handle of window or control
    LPCWSTR lpString 	// address of string
   ) {
    
    if(FIsWinNT())
        return( SetWindowTextW(hWnd, lpString));
    else
        return( SetWindowText9x(hWnd, lpString));
}


int WINAPI GetWindowText9x(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount
   )
{
    LPSTR   psz;
    int     ret;

    psz = (LPSTR) malloc(nMaxCount);

    if (psz == NULL)
    {
        return (0);
    }   

    ret = GetWindowTextA(hWnd, psz, nMaxCount);

    if (ret != 0)
    {
        MultiByteToWideChar(0, 0, psz, -1, lpString, nMaxCount);
    }
    else
    {
        free(psz);
        return (0);
    }

    free(psz);

    return (ret);
}

int WINAPI GetWindowTextU(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount
   )
{
    if (FIsWinNT())
        return (GetWindowTextW(hWnd, lpString, nMaxCount));
    else
        return (GetWindowText9x(hWnd, lpString, nMaxCount));
    
}


UINT WINAPI GetDlgItemText9x(
    HWND hDlg,	// handle of dialog box
    int nIDDlgItem,	// identifier of control
    LPWSTR lpString,	// address of buffer for text
    int nMaxCount 	// maximum size of string
   ) {

    char *szBuffer;
    int     cchW;
    LONG    err;

    szBuffer = (char *) malloc(nMaxCount);
    if(!szBuffer)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return 0;
    }

    err = GetDlgItemTextA(
        hDlg,
        nIDDlgItem,
        szBuffer,
        nMaxCount);

    if (err != 0)
    {
        err = MultiByteToWideChar(
                            0,                      // codepage
                            0,                      // dwFlags
                            szBuffer,
                            err+1,
                            lpString,
                            nMaxCount);
    }
    else if (nMaxCount >= 1)
    {
        lpString[0] = 0;
    }

    free(szBuffer);

    return(err);
}

UINT WINAPI GetDlgItemTextU(
    HWND hDlg,	// handle of dialog box
    int nIDDlgItem,	// identifier of control
    LPWSTR lpString,	// address of buffer for text
    int nMaxCount 	// maximum size of string
   ) {

    if(FIsWinNT())
        return( GetDlgItemTextW(
            hDlg,
            nIDDlgItem,
            lpString,
            nMaxCount
            ));
    else
        return( GetDlgItemText9x(
            hDlg,
            nIDDlgItem,
            lpString,
            nMaxCount
            ));
}


BOOL WINAPI SetDlgItemText9x(
    HWND hDlg, 
    int nIDDlgItem, 
    LPCWSTR lpString 
    )
{
    LPSTR szString = NULL;
    DWORD cbszString = 0;
    BOOL  fRet;
    
    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpString,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszString == 0)
    {
        return FALSE;
    }

    if (NULL == (szString = (LPSTR) malloc(cbszString)))
    {
        return FALSE;
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpString,
                        -1,
                        szString,
                        cbszString,
                        NULL,
                        NULL);

    if (cbszString == 0)
    {
        free(szString);
        return FALSE;
    }

    fRet = SetDlgItemTextA(
                    hDlg,
                    nIDDlgItem,
                    szString
                    );
    
    free(szString);
        
    return (fRet);
}

BOOL WINAPI SetDlgItemTextU(
    HWND hDlg, 
    int nIDDlgItem, 
    LPCWSTR lpString 
    )
{
    if(FIsWinNT()) 
        return(SetDlgItemTextW(
                    hDlg,
                    nIDDlgItem,
                    lpString
                    ));
    else
        return(SetDlgItemText9x(
                    hDlg,
                    nIDDlgItem,
                    lpString
                    ));
}


int WINAPI DialogBoxParam9x(
    HINSTANCE hInstance, 
    LPCWSTR lpTemplateName, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc, 
    LPARAM dwInitParam 
    )
{
    LPSTR szString = NULL;
    DWORD cbszString = 0;
    int  iRet;
    
    //now, lpTemplateName can either be a WORD from MAKEINTRESOURCE(..)
    //or a NULL terminated string
    if (0xFFFF >= ((DWORD_PTR)lpTemplateName)) 
    {
        return(DialogBoxParamA(
                    hInstance,
                    (LPCSTR)lpTemplateName,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam
                    ));
    }


    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpTemplateName,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszString == 0)
    {
        return FALSE;
    }

    if (NULL == (szString = (LPSTR) malloc(cbszString)))
    {
        return FALSE;
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpTemplateName,
                        -1,
                        szString,
                        cbszString,
                        NULL,
                        NULL);

    if (cbszString == 0)
    {
        free(szString);
        return FALSE;
    }

    iRet = DialogBoxParamA(
                hInstance,
                szString,
                hWndParent,
                lpDialogFunc,
                dwInitParam
                );
    
    free(szString);
        
    return (iRet);
}

int WINAPI DialogBoxParamU(
    HINSTANCE hInstance, 
    LPCWSTR lpTemplateName, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc, 
    LPARAM dwInitParam 
    )
{
    if(FIsWinNT()) 
        return(DialogBoxParamW(
                    hInstance,
                    lpTemplateName,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam
                    ));
    else
        return(DialogBoxParam9x(
                    hInstance,
                    lpTemplateName,
                    hWndParent,
                    lpDialogFunc,
                    dwInitParam
                    ));
}



int WINAPI DialogBox9x(
    HINSTANCE hInstance, 
    LPCWSTR lpTemplateName, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc 
    )
{
    LPSTR szString = NULL;
    DWORD cbszString = 0;
    int  iRet;
    
    //now, lpTemplateName can either be a WORD from MAKEINTRESOURCE(..)
    //or a NULL terminated string
    if (0xFFFF >= ((DWORD_PTR)lpTemplateName)) 
    {
        return(DialogBoxA(
                    hInstance,
                    (LPCSTR)lpTemplateName,
                    hWndParent,
                    lpDialogFunc
                    ));
    }


    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpTemplateName,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszString == 0)
    {
        return FALSE;
    }

    if (NULL == (szString = (LPSTR) malloc(cbszString)))
    {
        return FALSE;
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpTemplateName,
                        -1,
                        szString,
                        cbszString,
                        NULL,
                        NULL);

    if (cbszString == 0)
    {
        free(szString);
        return FALSE;
    }

    iRet = DialogBoxA(
                hInstance,
                szString,
                hWndParent,
                lpDialogFunc
                );
    
    free(szString);
        
    return (iRet);

}

int WINAPI DialogBoxU(
    HINSTANCE hInstance, 
    LPCWSTR lpTemplateName, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc 
    )
{
    if(FIsWinNT()) 
        return(DialogBoxW(
                    hInstance,
                    lpTemplateName,
                    hWndParent,
                    lpDialogFunc
                    ));
    else
        return(DialogBox9x(
                    hInstance,
                    lpTemplateName,
                    hWndParent,
                    lpDialogFunc
                    ));
}


int WINAPI MessageBox9x(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    ) {
    BYTE rgb1[_MAX_PATH];
    char *  szString1 = NULL;
    BYTE rgb2[_MAX_PATH];
    char *  szString2 = NULL;
    int    err;

    if (lpText == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    err = 0;
    if(MkMBStr(rgb1, _MAX_PATH, lpText, &szString1))
    {
        MkMBStr(rgb2, _MAX_PATH, lpCaption, &szString2);

        err = MessageBoxA(
				    hWnd,
				    szString1,
				    szString2,
				    uType);
    }
				    
    if (szString1 != NULL)
        FreeMBStr(rgb1, szString1);

    if (szString2 != NULL)
        FreeMBStr(rgb2, szString2);

    return(err);
}

int WINAPI MessageBoxU(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    ) {
    
    if(FIsWinNT())
        return( MessageBoxW(
				    hWnd,
				    lpText,
				    lpCaption,
				    uType));
    else
        return( MessageBox9x(
				    hWnd,
				    lpText,
				    lpCaption,
				    uType));
}


int WINAPI LCMapString9x(
    LCID Locale,	// locale identifier 
    DWORD dwMapFlags,	// mapping transformation type 
    LPCWSTR lpSrcStr,	// address of source string 
    int cchSrc,	// number of characters in source string 
    LPWSTR lpDestStr,	// address of destination buffer 
    int cchDest 	// size of destination buffer 
   ) {
    BYTE rgb1[_MAX_PATH];
    char *  szBuffer = NULL;
    LPSTR   szBuffer1 = NULL;
    int cbConverted;
    
    LONG    err = GetLastError();
    LONG    cb = 0;

    SetLastError(ERROR_OUTOFMEMORY);

    // translate lpSrcStr to src ANSI szBuffer
    if(MkMBStrEx(rgb1, _MAX_PATH, lpSrcStr, cchSrc, &szBuffer, &cbConverted) )
    {
        // Malloc the intermediate ANSI buf
	if( NULL != (szBuffer1 = (LPSTR) malloc(cchDest)) ) {

	    // do translation from szBuffer into lpDestStr
	    cb = LCMapStringA(
		Locale,
		dwMapFlags,
		szBuffer,
		cbConverted,
		szBuffer1,
		cchDest);
	}
    }

    // free src ANSI szBuffer, handles NULLs
    FreeMBStr(rgb1, szBuffer);

    if(cb != 0) {

	// translate resultant ANSI szBuffer1 to UNICODE
	cb = MultiByteToWideChar(
			    0,			    // codepage
			    0,			    // dwFlags
			    szBuffer1,		    // src (ANSI)
			    cb,		    // already incl NULL
			    lpDestStr,		    // dest (UNICODE)
			    cchDest);
    }

    if(szBuffer1 != NULL)
	free(szBuffer1);

    if(cb != 0)
	SetLastError(err);

    return(cb);
}

int WINAPI LCMapStringU(
    LCID Locale,	// locale identifier 
    DWORD dwMapFlags,	// mapping transformation type 
    LPCWSTR lpSrcStr,	// address of source string 
    int cchSrc,	// number of characters in source string 
    LPWSTR lpDestStr,	// address of destination buffer 
    int cchDest 	// size of destination buffer 
   ) {
    
    if(FIsWinNT())
        return( LCMapStringW(
            Locale,
            dwMapFlags,
            lpSrcStr,
            cchSrc,
            lpDestStr,
            cchDest));
    else
        return( LCMapString9x(
            Locale,
            dwMapFlags,
            lpSrcStr,
            cchSrc,
            lpDestStr,
            cchDest));
}


int WINAPI GetDateFormat9x( 
    LCID Locale, 
    DWORD dwFlags, 
    CONST SYSTEMTIME *lpDate, 
    LPCWSTR lpFormat, 
    LPWSTR lpDateStr, 
    int cchDate
    )
{
    LPSTR szFormatString = NULL;
    LPSTR szDateString  = NULL;
    DWORD cbszFormatString = 0;
    DWORD cbszDateString = 0;
    int  iRet;
    
    if (lpFormat != NULL)
    {
        cbszFormatString = WideCharToMultiByte(
                            0,                      // codepage
                            0,                      // dwFlags
                            lpFormat,
                            -1,
                            NULL,
                            0,
                            NULL,
                            NULL);
    
        if (cbszFormatString == 0)
        {
            return FALSE;
        }

        if (NULL == (szFormatString = (LPSTR) malloc(cbszFormatString)))
        {
            return FALSE;
        }

        cbszFormatString = WideCharToMultiByte(
                            0,                      // codepage
                            0,                      // dwFlags
                            lpFormat,
                            -1,
                            szFormatString,
                            cbszFormatString,
                            NULL,
                            NULL);

        if (cbszFormatString == 0)
        {
            free(szFormatString);
            return FALSE;
        }
    }

    if (cchDate == 0)
    {
        iRet = GetDateFormatA( 
                    Locale, 
                    dwFlags, 
                    lpDate, 
                    szFormatString, 
                    NULL, 
                    0
                    );
    }
    else
    {
        szDateString = (LPSTR) malloc(cchDate);
        if (szDateString == NULL)
        {
            if (szFormatString)
                free(szFormatString);
            return FALSE; 
        }

        iRet = GetDateFormatA( 
                    Locale, 
                    dwFlags, 
                    lpDate, 
                    szFormatString, 
                    szDateString, 
                    cchDate
                    );

        MultiByteToWideChar(
                        0,
                        0,
                        szDateString,
                        -1,
                        lpDateStr,
                        cchDate
                        );
    }

    if (szFormatString)
        free(szFormatString);
    
    if (szDateString)
        free(szDateString);
        
    return (iRet);
}

int WINAPI GetDateFormatU( 
    LCID Locale, 
    DWORD dwFlags, 
    CONST SYSTEMTIME *lpDate, 
    LPCWSTR lpFormat, 
    LPWSTR lpDateStr, 
    int cchDate
    )
{
    if(FIsWinNT()) 
        return(GetDateFormatW( 
                    Locale, 
                    dwFlags, 
                    lpDate, 
                    lpFormat, 
                    lpDateStr, 
                    cchDate
                    ));
    else
        return(GetDateFormat9x( 
                    Locale, 
                    dwFlags, 
                    lpDate, 
                    lpFormat, 
                    lpDateStr, 
                    cchDate
                    ));
}


int WINAPI GetTimeFormat9x( 
    LCID Locale, 
    DWORD dwFlags, 
    CONST SYSTEMTIME *lpTime, 
    LPCWSTR lpFormat, 
    LPWSTR lpTimeStr, 
    int cchTime 
    )
{
    LPSTR szFormatString = NULL;
    LPSTR szTimeString  = NULL;
    DWORD cbszFormatString = 0;
    DWORD cbszTimeString = 0;
    int  iRet;
    
    if (lpFormat != NULL)
    {
        cbszFormatString = WideCharToMultiByte(
                            0,                      // codepage
                            0,                      // dwFlags
                            lpFormat,
                            -1,
                            NULL,
                            0,
                            NULL,
                            NULL);
    
        if (cbszFormatString == 0)
        {
            return FALSE;
        }

        if (NULL == (szFormatString = (LPSTR) malloc(cbszFormatString)))
        {
            return FALSE;
        }

        cbszFormatString = WideCharToMultiByte(
                            0,                      // codepage
                            0,                      // dwFlags
                            lpFormat,
                            -1,
                            szFormatString,
                            cbszFormatString,
                            NULL,
                            NULL);

        if (cbszFormatString == 0)
        {
            free(szFormatString);
            return FALSE;
        }
    }

    if (cchTime == 0)
    {
        iRet = GetTimeFormatA( 
                        Locale, 
                        dwFlags, 
                        lpTime, 
                        szFormatString, 
                        NULL, 
                        0
                        );
    }
    else
    {
        szTimeString = (LPSTR) malloc(cchTime);
        if (szTimeString == NULL)
        {
            if (szFormatString)
                free(szFormatString);
            return FALSE; 
        }

        iRet = GetTimeFormatA( 
                        Locale, 
                        dwFlags, 
                        lpTime, 
                        szFormatString, 
                        szTimeString, 
                        cchTime
                        );

        MultiByteToWideChar(
                        0,
                        0,
                        szTimeString,
                        -1,
                        lpTimeStr,
                        cchTime
                        );
    }

    if (szFormatString != NULL)
        free(szFormatString);

    if (szTimeString != NULL)
        free(szTimeString);
        
    return (iRet);
}

int WINAPI GetTimeFormatU( 
    LCID Locale, 
    DWORD dwFlags, 
    CONST SYSTEMTIME *lpTime, 
    LPCWSTR lpFormat, 
    LPWSTR lpTimeStr, 
    int cchTime 
    )
{
    if(FIsWinNT()) 
        return(GetTimeFormatW( 
                    Locale, 
                    dwFlags, 
                    lpTime, 
                    lpFormat, 
                    lpTimeStr, 
                    cchTime
                    ));
    else
        return(GetTimeFormat9x( 
                    Locale, 
                    dwFlags, 
                    lpTime, 
                    lpFormat, 
                    lpTimeStr, 
                    cchTime
                    ));
}


BOOL WINAPI WinHelp9x( 
    HWND hWndMain, 
    LPCWSTR lpszHelp, 
    UINT uCommand, 
    DWORD dwData 
    )
{
    LPSTR szHelpString = NULL;
    DWORD cbszHelpString = 0;
    BOOL  bRet;
    
    cbszHelpString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpszHelp,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszHelpString == 0)
    {
        return FALSE;
    }

    if (NULL == (szHelpString = (LPSTR) malloc(cbszHelpString)))
    {
        return FALSE;
    }

    cbszHelpString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        lpszHelp,
                        -1,
                        szHelpString,
                        cbszHelpString,
                        NULL,
                        NULL);

    if (cbszHelpString == 0)
    {
        free(szHelpString);
        return FALSE;
    }

    bRet = WinHelpA( 
                hWndMain, 
                szHelpString, 
                uCommand, 
                dwData 
                );
    
    free(szHelpString);
        
    return (bRet);
}

BOOL WINAPI WinHelpU( 
    HWND hWndMain, 
    LPCWSTR lpszHelp, 
    UINT uCommand, 
    DWORD dwData 
    )
{
    if(FIsWinNT()) 
        return(WinHelpW( 
                    hWndMain, 
                    lpszHelp, 
                    uCommand, 
                    dwData 
                    ));
    else
        return(WinHelp9x( 
                    hWndMain, 
                    lpszHelp, 
                    uCommand, 
                    dwData 
                    ));
}


LRESULT WINAPI SendMessageU( 
    HWND hWnd, 
    UINT Msg, 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    if(FIsWinNT()) 
    {
        return(SendMessageW( 
                    hWnd, 
                    Msg, 
                    wParam, 
                    lParam 
                    ));
    }
    else 
    {
        return(SendMessageA( 
                    hWnd, 
                    Msg, 
                    wParam, 
                    lParam 
                    ));
    }
}


LONG 
WINAPI
SendDlgItemMessageU( 
    HWND hDlg, 
    int nIDDlgItem, 
    UINT Msg, 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    LPSTR szString = NULL;
    DWORD cbszString = 0;
    LONG  lRet;

    // only do string conversion for string type messages
    if (Msg != LB_ADDSTRING && 
        Msg != CB_INSERTSTRING &&
        Msg != WM_SETTEXT &&
        Msg != CB_FINDSTRINGEXACT &&
        Msg != CB_ADDSTRING)
    {
        return(SendDlgItemMessageA( 
                    hDlg, 
                    nIDDlgItem, 
                    Msg, 
                    wParam,
                    lParam
                    ));
    }

    if(FIsWinNT()) 
    {
        return(SendDlgItemMessageW( 
                    hDlg, 
                    nIDDlgItem, 
                    Msg, 
                    wParam,
                    lParam
                    ));
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        (LPWSTR) lParam,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL);
    
    if (cbszString == 0)
    {
        return LB_ERR;
    }

    if (NULL == (szString = (LPSTR) malloc(cbszString)))
    {
        return LB_ERR;
    }

    cbszString = WideCharToMultiByte(
                        0,                      // codepage
                        0,                      // dwFlags
                        (LPWSTR) lParam,
                        -1,
                        szString,
                        cbszString,
                        NULL,
                        NULL);

    if (cbszString == 0)
    {
        free(szString);
        return LB_ERR;
    }

    lRet = SendDlgItemMessageA( 
                    hDlg, 
                    nIDDlgItem, 
                    Msg, 
                    wParam,
                    (LPARAM) szString
                    );
    
    free(szString);
        
    return (lRet);
}

LPWSTR 
WINAPI
GetCommandLineU(void)
{
	LPSTR szCmdLine = NULL;
	LPWSTR wszCmdLine = NULL;

	if (FIsWinNT())
		return (GetCommandLineW());

	szCmdLine = GetCommandLineA();

	wszCmdLine = MkWStr(szCmdLine);
	return (wszCmdLine);
}

BOOL 
WINAPI
IsBadStringPtr9x(IN LPWSTR lpsz, UINT ucchMax)
{
	BYTE rgb[2048];
	char *sz = NULL;
	BOOL bResult = FALSE;

	if (MkMBStr(rgb, _MAX_PATH, lpsz, &sz))
		bResult = IsBadStringPtrA(sz, ucchMax);

	FreeMBStr(rgb, sz);

	return (bResult);
}

BOOL 
WINAPI
IsBadStringPtrU(IN LPWSTR lpsz, UINT ucchMax)
{
	if (FIsWinNT())
		return (IsBadStringPtrW(lpsz, ucchMax));
    else
        return (IsBadStringPtr9x(lpsz, ucchMax));
}


void 
WINAPI
OutputDebugString9x(IN LPWSTR lpwsz)
{
	BYTE rgb[_MAX_PATH];
	char *sz = NULL;

    if (MkMBStr(rgb, _MAX_PATH, lpwsz, &sz))
		OutputDebugStringA(sz);

	FreeMBStr(rgb, sz);

	return;
}

void 
WINAPI
OutputDebugStringU(IN LPWSTR lpwsz)
{
	//DSIE: bug 171074.
    if (!lpwsz)
        return;

	if (FIsWinNT())
	    OutputDebugStringW(lpwsz);
	else
        OutputDebugString9x(lpwsz);
}

int 
WINAPI
DrawText9x(
    HDC     hDC, 
    LPCWSTR lpString, 
    int     nCount, 
    LPRECT  lpRect, 
    UINT    uFormat  
)
{
    LPSTR   pszText;
    int     ret;

    if (NULL == (pszText = (LPSTR) malloc(wcslen(lpString)+1)))
    {
	SetLastError(ERROR_OUTOFMEMORY);
	return(0);
    }

    WideCharToMultiByte(
            0,
            0, 
            lpString,
            -1,
            pszText,
            wcslen(lpString)+1,
            NULL,
            NULL);

    ret = DrawTextA(hDC, pszText, nCount, lpRect, uFormat);

    free(pszText);
    return ret;
}

int 
WINAPI
DrawTextU(
    HDC     hDC, 
    LPCWSTR lpString, 
    int     nCount, 
    LPRECT  lpRect, 
    UINT    uFormat  
)
{
    if (FIsWinNT())
    	return (DrawTextW(hDC, lpString, nCount, lpRect, uFormat));
	else
        return (DrawText9x(hDC, lpString, nCount, lpRect, uFormat));
}


void CleanUpOpenFileNameA(LPOPENFILENAMEA pOpenFileNameA)
{
    if (pOpenFileNameA->lpstrFilter != NULL)
        free((void *) pOpenFileNameA->lpstrFilter);

    if (pOpenFileNameA->lpstrCustomFilter != NULL)
        free((void *) pOpenFileNameA->lpstrCustomFilter);

    if (pOpenFileNameA->lpstrFile != NULL)
        free((void *) pOpenFileNameA->lpstrFile);

    if (pOpenFileNameA->lpstrFileTitle)
        free((void *) pOpenFileNameA->lpstrFileTitle);

    if (pOpenFileNameA->lpstrInitialDir)
        free((void *) pOpenFileNameA->lpstrInitialDir);

    if (pOpenFileNameA->lpstrTitle)
        free((void *) pOpenFileNameA->lpstrTitle);

    if (pOpenFileNameA->lpstrDefExt)
        free((void *) pOpenFileNameA->lpstrDefExt);
}

//
// NOTE the following fields in LPOPENFILENAMEW are NOT supported:
//      nFileOffset
//      nFileExtension
//      lpTemplateName
//
BOOL ConvertToOpenFileNameA(LPOPENFILENAMEW pOpenFileNameW, LPOPENFILENAMEA pOpenFileNameA)
{
    int     i;
    int     cb, cb1, cb2;
    LPSTR   pszTemp;
    BOOL    fResult = TRUE;
    
    memset(pOpenFileNameA, 0, sizeof(OPENFILENAMEA));
    pOpenFileNameA->lStructSize = offsetof(OPENFILENAMEA, lpTemplateName) + sizeof(LPCSTR);
    pOpenFileNameA->hwndOwner = pOpenFileNameW->hwndOwner;
    pOpenFileNameA->hInstance = pOpenFileNameW->hInstance;
    
    //
    // the lpstrFilter field is a list of pairs of NULL terminated strings
    //
    if (pOpenFileNameW->lpstrFilter != NULL)
    {
        i = 0;
        cb = 0;
        while (pOpenFileNameW->lpstrFilter[i] != L'\0')
        {
            cb += WideCharToMultiByte(
                    0,
                    0, 
                    &(pOpenFileNameW->lpstrFilter[i]),
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            
            i += wcslen(&(pOpenFileNameW->lpstrFilter[i])) + 1;
        }

        pOpenFileNameA->lpstrFilter = (LPSTR) malloc(cb + 1);
        if (pOpenFileNameA->lpstrFilter == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                    0,
                    0, 
                    pOpenFileNameW->lpstrFilter,
                    i + 1,
                    (LPSTR)pOpenFileNameA->lpstrFilter,
                    cb + 1,
                    NULL,
                    NULL);
    }
    else
    {
        pOpenFileNameA->lpstrFilter = NULL;
    }

    //
    // the lpstrCustomFilter field is a pair of NULL terminated strings
    //
    if (pOpenFileNameW->lpstrCustomFilter != NULL)
    {
        cb1 = WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrCustomFilter,
                -1,
                NULL,
                0,
                NULL,
                NULL);
        cb2 = WideCharToMultiByte(
                0,
                0, 
                &(pOpenFileNameW->lpstrCustomFilter[wcslen(pOpenFileNameW->lpstrCustomFilter)+1]),
                -1,
                NULL,
                0,
                NULL,
                NULL);
        
        pOpenFileNameA->lpstrCustomFilter = (LPSTR) malloc(cb1 + cb2);
        if (pOpenFileNameA->lpstrCustomFilter == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrCustomFilter,
                -1,
                pOpenFileNameA->lpstrCustomFilter,
                cb1,
                NULL,
                NULL);
        WideCharToMultiByte(
                0,
                0, 
                &(pOpenFileNameW->lpstrCustomFilter[wcslen(pOpenFileNameW->lpstrCustomFilter)+1]),
                -1,
                &(pOpenFileNameA->lpstrCustomFilter[cb1]),
                cb2,
                NULL,
                NULL);

        pOpenFileNameA->nMaxCustFilter = cb1 + cb2;
    }
    else
    {
        pOpenFileNameA->lpstrCustomFilter = NULL;
        pOpenFileNameA->nMaxCustFilter = 0;
    }
    
    pOpenFileNameA->nFilterIndex = pOpenFileNameW->nFilterIndex;
    
    pOpenFileNameA->lpstrFile = (LPSTR) malloc(pOpenFileNameW->nMaxFile);
    if (pOpenFileNameA->lpstrFile == NULL)
    {
        goto OutOfMemory;
    }
    WideCharToMultiByte(
            0,
            0, 
            pOpenFileNameW->lpstrFile,
            -1,
            pOpenFileNameA->lpstrFile,
            pOpenFileNameW->nMaxFile,
            NULL,
            NULL);
    pOpenFileNameA->nMaxFile = pOpenFileNameW->nMaxFile;

    if (pOpenFileNameW->lpstrFileTitle != NULL)
    {
        pOpenFileNameA->lpstrFileTitle = (LPSTR) malloc(pOpenFileNameW->nMaxFileTitle);
        if (pOpenFileNameA->lpstrFileTitle == NULL)
        {
            goto OutOfMemory;
        }
    }
    else
    {
        pOpenFileNameA->lpstrFileTitle = NULL;
    }
    pOpenFileNameA->nMaxFileTitle = pOpenFileNameW->nMaxFileTitle;

    if (pOpenFileNameW->lpstrInitialDir != NULL)
    {
        cb = WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrInitialDir,
                -1,
                NULL,
                0,
                NULL,
                NULL);

        pOpenFileNameA->lpstrInitialDir = (LPSTR) malloc(cb);
        if (pOpenFileNameA->lpstrInitialDir == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrInitialDir,
                -1,
                (LPSTR) pOpenFileNameA->lpstrInitialDir,
                cb,
                NULL,
                NULL);
    }
    else
    {
        pOpenFileNameW->lpstrInitialDir = NULL;
    }

    if (pOpenFileNameW->lpstrTitle != NULL)
    {
        cb = WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrTitle,
                -1,
                NULL,
                0,
                NULL,
                NULL);

        pOpenFileNameA->lpstrTitle = (LPSTR) malloc(cb);
        if (pOpenFileNameA->lpstrTitle == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrTitle,
                -1,
                (LPSTR) pOpenFileNameA->lpstrTitle,
                cb,
                NULL,
                NULL);
    }
    else
    {
        pOpenFileNameW->lpstrTitle = NULL;
    }

    pOpenFileNameA->Flags = pOpenFileNameW->Flags;
    pOpenFileNameA->nFileOffset = 0;
    pOpenFileNameA->nFileExtension = 0;

    if (pOpenFileNameW->lpstrDefExt != NULL)
    {
        cb = WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrDefExt,
                -1,
                NULL,
                0,
                NULL,
                NULL);

        pOpenFileNameA->lpstrDefExt = (LPSTR) malloc(cb);
        if (pOpenFileNameA->lpstrDefExt == NULL)
        {
            goto OutOfMemory;
        }

        WideCharToMultiByte(
                0,
                0, 
                pOpenFileNameW->lpstrDefExt,
                -1,
                (LPSTR) pOpenFileNameA->lpstrDefExt,
                cb,
                NULL,
                NULL);
    }
    else
    {
        pOpenFileNameW->lpstrDefExt = NULL;
    }

    pOpenFileNameA->lCustData = pOpenFileNameW->lCustData;
    pOpenFileNameA->lpfnHook = pOpenFileNameW->lpfnHook;
    pOpenFileNameA->lpTemplateName = NULL;


    goto Return;

OutOfMemory:
    
    CleanUpOpenFileNameA(pOpenFileNameA);
    SetLastError(E_OUTOFMEMORY);
    fResult = FALSE;

Return:
    
    return (fResult);
}


typedef BOOL (WINAPI * PFNCGETSAVEFILENAMEW)(LPOPENFILENAMEW pOpenFileName);
typedef BOOL (WINAPI * PFNCGETSAVEFILENAMEA)(LPOPENFILENAMEA pOpenFileName);

BOOL 
GetSaveFileName9x(
    LPOPENFILENAMEW pOpenFileName
)
{
    OPENFILENAMEA           OpenFileNameA;
    HINSTANCE               h_module;
    PFNCGETSAVEFILENAMEA    pfncGetSaveFileNameA;
    BOOL                    fRet;

    h_module = LoadLibraryA("comdlg32.dll");
    if (h_module == NULL)
    {
        return FALSE;
    }
        
    if (!ConvertToOpenFileNameA(pOpenFileName, &OpenFileNameA))
    {
        return FALSE;
    }

    pfncGetSaveFileNameA = (PFNCGETSAVEFILENAMEA) GetProcAddress(h_module, "GetSaveFileNameA");
    if (pfncGetSaveFileNameA == NULL)
    {
        CleanUpOpenFileNameA(&OpenFileNameA);
        return FALSE;
    }
    fRet = pfncGetSaveFileNameA(&OpenFileNameA);
    DWORD dwErr = GetLastError();
    
    if (fRet)
    {
        MultiByteToWideChar(
                0,
                0,
                OpenFileNameA.lpstrFile,
                -1,
                pOpenFileName->lpstrFile,
                pOpenFileName->nMaxFile);
    }

    CleanUpOpenFileNameA(&OpenFileNameA);


    FreeLibrary(h_module);
    return fRet;
}

BOOL 
GetSaveFileNameU(
    LPOPENFILENAMEW pOpenFileName
)
{
    HINSTANCE               h_module;
    PFNCGETSAVEFILENAMEW    pfncGetSaveFileNameW;
    BOOL                    fRet;
    
    if (FIsWinNT())
	{
		h_module = LoadLibraryA("comdlg32.dll");
        if (h_module == NULL)
        {
            return FALSE;
        }

        pfncGetSaveFileNameW = (PFNCGETSAVEFILENAMEW) GetProcAddress(h_module, "GetSaveFileNameW");
        if (pfncGetSaveFileNameW == NULL)
        {
            fRet = FALSE;
        }
        else
        {
            fRet = pfncGetSaveFileNameW(pOpenFileName);
        }

        FreeLibrary(h_module);
	}
    else
    {
        fRet = GetSaveFileName9x(pOpenFileName);
    }

    return fRet;
}


typedef BOOL (WINAPI * PFNCGETOPENFILENAMEW)(LPOPENFILENAMEW pOpenFileName);
typedef BOOL (WINAPI * PFNCGETOPENFILENAMEA)(LPOPENFILENAMEA pOpenFileName);

BOOL 
GetOpenFileName9x(
    LPOPENFILENAMEW pOpenFileName
)
{
    OPENFILENAMEA           OpenFileNameA;
    HINSTANCE               h_module;
    PFNCGETOPENFILENAMEA    pfncGetOpenFileNameA;
    BOOL                    fRet;

    h_module = LoadLibraryA("comdlg32.dll");
    if (h_module == NULL)
    {
        return FALSE;
    }
    
    if (!ConvertToOpenFileNameA(pOpenFileName, &OpenFileNameA))
    {
        return FALSE;
    }

    pfncGetOpenFileNameA = (PFNCGETOPENFILENAMEA) GetProcAddress(h_module, "GetOpenFileNameA");
    if (pfncGetOpenFileNameA == NULL)
    {
        return FALSE;
    }
    fRet = pfncGetOpenFileNameA(&OpenFileNameA);
    DWORD dwErr = GetLastError();
    
    MultiByteToWideChar(
            0,
            0,
            OpenFileNameA.lpstrFile,
            -1,
            pOpenFileName->lpstrFile,
            pOpenFileName->nMaxFile);

    CleanUpOpenFileNameA(&OpenFileNameA);

    FreeLibrary(h_module);
    return fRet;
}

BOOL 
GetOpenFileNameU(
    LPOPENFILENAMEW pOpenFileName
)
{
    HINSTANCE               h_module;
    PFNCGETOPENFILENAMEW    pfncGetOpenFileNameW;
    BOOL                    fRet;

    if (FIsWinNT())
	{
        h_module = LoadLibraryA("comdlg32.dll");
        if (h_module == NULL)
        {
            return FALSE;
        }

		pfncGetOpenFileNameW = (PFNCGETOPENFILENAMEW) GetProcAddress(h_module, "GetOpenFileNameW");
        if (pfncGetOpenFileNameW == NULL)
        {
            fRet = FALSE;
        }
        else
        {
            fRet = pfncGetOpenFileNameW(pOpenFileName);
        }

        FreeLibrary(h_module);
	}
    else
    {
        fRet = GetOpenFileName9x(pOpenFileName);
    }

    return fRet;
}



#endif // _M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\common\waitsvc\waitsvc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wiatsvc.cpp
//
//  Contents:   wait for service to start
//
//  History:    19-Jun-00   reidk   created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "unicode.h"
#include "errlog.h"
#include "waitsvc.h"

#define WAITSVC_LOGERR_LASTERR(x)   if (x) \
                                    { \
                                        ErrLog_LogError(NULL, \
                                                ERRLOG_CLIENT_ID_WAITSVC, \
                                                __LINE__, \
                                                0, \
                                                FALSE, \
                                                FALSE); \
                                    }

BOOL
WaitForCryptService(
    IN      LPWSTR  pwszService,
    IN      BOOL    *pfDone,
    IN      BOOL    fLogErrors 
    )
/*++

    This routine determines if the protected storage service is
    pending start.  If the service is pending start, this routine
    waits until the service is running before returning to the
    caller.

    If the Service is running when this routine returns, the
    return value is TRUE.

    If the service is not running, or an error occurred, the
    return value is FALSE.

    When the return value is FALSE, the value is only advisory, and may not
    indicate the current state of the service.  The reasoning here is that
    if the service did not start the first time this call is made, is will
    not likely be running the next time around, and hence we avoid checking
    on subsequent calls.

    For current situations, the caller should ignore the return value; when
    the return value is FALSE, the caller should just try making the call
    into the service.  If the service is still down, the call into it will fail
    appropriately.

--*/
{
    SC_HANDLE   schSCM;
    SC_HANDLE   schService          = NULL;
    DWORD       dwStopCount         = 0;
    static BOOL fSuccess            = FALSE;
    BOOL        fCheckDisabled      = TRUE;
    HANDLE      hToken              = NULL;
    BOOL        fSystemAccount      = FALSE;
    BOOL        fStartServiceCalled = FALSE;
    DWORD       dwErr               = ERROR_SUCCESS;

    if( !FIsWinNT() )
        return TRUE;

    if( *pfDone )
        return fSuccess;

    schSCM = OpenSCManagerW( NULL, NULL, SC_MANAGER_CONNECT );
    if(schSCM == NULL)
    {
        WAITSVC_LOGERR_LASTERR(fLogErrors)
        return FALSE;
    }

    //
    // open the protected storage service so we can query it's
    // current state.
    //

    schService = OpenServiceW(schSCM, pwszService, SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG);
    if(schService == NULL) 
    {
        WAITSVC_LOGERR_LASTERR(fLogErrors)
        fCheckDisabled = FALSE;
        schService = OpenServiceW(schSCM, pwszService, SERVICE_QUERY_STATUS);
    }

    if(schService == NULL)
    {
        WAITSVC_LOGERR_LASTERR(fLogErrors)
        goto cleanup;
    }



    //
    // check if calling process is SYSTEM account.
    // if it is, use a larger timeout value.
    //

    if( OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) ) {

        do {

            BYTE FastBuffer[ 256 ];
            PTOKEN_USER TokenInformation;
            DWORD cbTokenInformation;
            SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
            PSID psidLocalSystem;

            TokenInformation = (PTOKEN_USER)FastBuffer;
            cbTokenInformation = sizeof(FastBuffer);

            if(!GetTokenInformation(
                                hToken,
                                TokenUser,
                                TokenInformation,
                                cbTokenInformation,
                                &cbTokenInformation
                                )) 
            {
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                break;
            }

            if(!AllocateAndInitializeSid(
                                &sia,
                                1,
                                SECURITY_LOCAL_SYSTEM_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &psidLocalSystem
                                )) 
            {
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                break;
            }

            fSystemAccount = EqualSid(
                                psidLocalSystem,
                                TokenInformation->User.Sid
                                );

            FreeSid( psidLocalSystem );

        } while (FALSE);

        CloseHandle( hToken );
    }



//
// number of seconds to Sleep per loop interation.
//

#define SLEEP_SECONDS (5)


    if( fSystemAccount ) {

        //
        // 15 minutes for SYSTEM account.
        //

        dwStopCount = 900 / SLEEP_SECONDS;

    } else {

        //
        //
        // loop checking the service status every 5 seconds, for up to 2 minutes
        // total (120 seconds, 5*24=120)
        //

        dwStopCount = 120 / SLEEP_SECONDS;
    }

    for( ; dwStopCount != 0 ; dwStopCount--, Sleep(SLEEP_SECONDS*1000) ) {
        SERVICE_STATUS sServiceStatus;
        DWORD dwWaitForStatus = 0;



    //
    // check if the service is disabled.  If it is, bailout.
    //

        if( fCheckDisabled ) {
            LPQUERY_SERVICE_CONFIG pServiceConfig;
            BYTE TempBuffer[ 1024 ];
            DWORD cbServiceConfig;

            pServiceConfig = (LPQUERY_SERVICE_CONFIG)TempBuffer;
            cbServiceConfig = sizeof(TempBuffer);

            if(QueryServiceConfig( schService, pServiceConfig, cbServiceConfig, &cbServiceConfig )) {

                if( pServiceConfig->dwStartType == SERVICE_DISABLED ) 
                {
                    WAITSVC_LOGERR_LASTERR(fLogErrors)
                    goto cleanup;
                }
            }
        }


        //
        // find out current service status
        //

        if(!QueryServiceStatus( schService, &sServiceStatus ))
        {
            WAITSVC_LOGERR_LASTERR(fLogErrors)
            break;
        }

        //
        // if service is running, indicate success
        //

        if( sServiceStatus.dwCurrentState == SERVICE_RUNNING ) {
            
            if (fStartServiceCalled)
            {
                ErrLog_LogString(
                        NULL, 
                        L"WAITSVC: Service is running: ", 
                        pwszService, 
                        TRUE);
            }

            fSuccess = TRUE;
            break;
        } 


        if( sServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ) 
        {
            WAITSVC_LOGERR_LASTERR(fLogErrors)
            // Wait until stopped
            continue;
        } 

        if( sServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING ) 
        {
            WAITSVC_LOGERR_LASTERR(fLogErrors)
            // Wait until paused
            continue;
        } 

        //
        // if start pending, wait and re-query.
        //

        if( sServiceStatus.dwCurrentState == SERVICE_START_PENDING )
        {
            // Wait until started
            continue;
        }

        if(SERVICE_STOPPED == sServiceStatus.dwCurrentState)
        {
            // Attempt to start the service


            SC_HANDLE schManualStartService = NULL;
            DWORD dwError  = ERROR_SUCCESS;

            // The service is manual start
            // so attempt to start it.

            schManualStartService = OpenServiceW(schSCM, 
                                                 pwszService, 
                                                  SERVICE_START);
            if(NULL == schManualStartService)
            {
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }

            
            ErrLog_LogString(
                    NULL, 
                    L"WAITSVC: Calling StartService(): ", 
                    pwszService, 
                    TRUE);
            fStartServiceCalled = TRUE;


            if(!StartService(schManualStartService, 0, NULL))
            {
                dwError  = GetLastError();
            }
            if(ERROR_SERVICE_ALREADY_RUNNING == dwError)
            {
                dwError = ERROR_SUCCESS;
            }           

            CloseServiceHandle(schManualStartService);
            if(ERROR_SUCCESS != dwError)
            {
                SetLastError(dwError);
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }
            continue;

        }

        if(SERVICE_PAUSED == sServiceStatus.dwCurrentState)
        {
            // Attempt to start the service


            SC_HANDLE schManualStartService = NULL;
            DWORD dwError  = ERROR_SUCCESS;

            // The service is manual start
            // so attempt to start it.

            schManualStartService = OpenServiceW(schSCM, 
                                                 pwszService, 
                                                  SERVICE_PAUSE_CONTINUE);
            if(NULL == schManualStartService)
            {
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }


            if(!ControlService(schManualStartService, SERVICE_CONTROL_CONTINUE, &sServiceStatus))
            {
                dwError  = GetLastError();

            }
            if(ERROR_SERVICE_ALREADY_RUNNING == dwError)
            {
                dwError = ERROR_SUCCESS;
            }

            CloseServiceHandle(schManualStartService);
            if(ERROR_SUCCESS != dwError)
            {
                SetLastError(dwError);
                WAITSVC_LOGERR_LASTERR(fLogErrors)
                goto cleanup;
            }

            continue;

        }


        //
        // bail out on any other dwCurrentState
        // eg: service stopped, error condition, etc.
        //

        break;
    }

    *pfDone = TRUE;

cleanup:

    dwErr = GetLastError();

    if(schService)
        CloseServiceHandle(schService);

    CloseServiceHandle(schSCM);

    SetLastError(dwErr);

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\crypstub\crypstub.cpp ===
/*++

Copyright (C) 2000  Microsoft Corporation

Module Name:

    crypstub.cpp

Abstract:

    RPC Proxy Stub to handle downlevel requests to the services.exe 
    pipe

Author:

    petesk   3/1/00

Revisions:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <svcs.h>       // SVCS_

#include "crypstub.h"
#include "keyrpc.h"
#include "keysvc.h"
//
// global module handle used to reference resources contained in this module.
//

HINSTANCE   g_hInst = NULL;


BOOL
WINAPI
DllMain(
    HMODULE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    if( dwReason == DLL_PROCESS_ATTACH ) {
        g_hInst = hInst;
        DisableThreadLibraryCalls(hInst);
    }

    return TRUE;
}


NTSTATUS
WINAPI
StartCryptServiceStubs( 
     PSVCS_START_RPC_SERVER RpcpStartRpcServer,
     LPTSTR SvcsRpcPipeName
    )
{
    NTSTATUS dwStatus = STATUS_SUCCESS;

    //
    // enable negotiate protocol, as, clients expect this to work against the
    // stub.
    //

    RpcServerRegisterAuthInfoW( NULL, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL );

    dwStatus = RpcpStartRpcServer(
                        SvcsRpcPipeName,
                        s_BackupKey_v1_0_s_ifspec
                        );

    if(NT_SUCCESS(dwStatus))
    {
        dwStatus = RpcpStartRpcServer(
                    SvcsRpcPipeName,
                    s_IKeySvc_v1_0_s_ifspec
                    );
    }

    return dwStatus;
}


NTSTATUS
WINAPI
StopCryptServiceStubs( 
    PSVCS_STOP_RPC_SERVER RpcpStopRpcServer
    )

{

    NTSTATUS dwStatus = STATUS_SUCCESS;

    RpcpStopRpcServer(
                        s_BackupKey_v1_0_s_ifspec
                        );

    dwStatus = RpcpStopRpcServer(
                        s_IKeySvc_v1_0_s_ifspec
                        );
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\crypstub\dpapistb.cpp ===
/*++

Copyright (C) 2000  Microsoft Corporation

Module Name:

    dpapistb.cpp

Abstract:

    RPC Proxy Stub to handle downlevel requests to the services.exe 
    pipe

Author:

    petesk   3/1/00

Revisions:


--*/

#define _CRYPT32_   // use correct Dll Linkage

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>


// midl generated files
#include "dpapiprv.h"
#include "keyrpc.h"





DWORD
s_BackuprKey(
    /* [in] */ handle_t h,
    /* [in] */ GUID __RPC_FAR *pguidActionAgent,
    /* [in] */ BYTE __RPC_FAR *pDataIn,
    /* [in] */ DWORD cbDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDataOut,
    /* [out] */ DWORD __RPC_FAR *pcbDataOut,
    /* [in] */ DWORD dwParam
    )
{

    RPC_BINDING_HANDLE hProxy = NULL;
    WCHAR *pStringBinding = NULL;
    RPC_SECURITY_QOS RpcQos;

    RPC_STATUS RpcStatus = RPC_S_OK;


    RpcStatus = RpcImpersonateClient(h);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }

    RpcStatus = RpcStringBindingComposeW(
                          NULL,
                          DPAPI_LOCAL_PROT_SEQ,
                          NULL,
                          DPAPI_LOCAL_ENDPOINT,
                          NULL,
                          &pStringBinding);
    if (RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                                pStringBinding,
                                &hProxy);
    if (NULL != pStringBinding)
    {
        RpcStringFreeW(&pStringBinding);
    }
    if (RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    RpcStatus = RpcEpResolveBinding(
                        hProxy,
                        BackupKey_v1_0_c_ifspec);
    if (RPC_S_OK != RpcStatus)
    {
        goto error;

    }

    __try
    {

        RpcStatus = BackuprKey(
                        hProxy,
                        (GUID*)pguidActionAgent,
                        pDataIn,
                        cbDataIn,
                        ppDataOut,
                        pcbDataOut,
                        dwParam
                        );

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }

error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\dbutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbutils.cpp
//
//  Contents:   utilities
//
//  History:    07-Feb-00    reidk    Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <dbgdef.h>

extern void * _CatDBAlloc(size_t len);
extern void * _CatDBReAlloc(void *p, size_t len);
extern void _CatDBFree(void *p);


LPSTR _CatDBConvertWszToSz(LPCWSTR pwsz)
{
    LPSTR   psz = NULL;
    LONG    cch = 0;

    cch = WideCharToMultiByte(
			GetACP(),
			0,          // dwFlags
			pwsz,
			-1,         // cchWideChar, -1 => null terminated
			NULL,
			0,
			NULL,
			NULL);
	
    if (cch == 0)
    {
        goto ErrorWideCharToMultiByte;
    }

	if (NULL == (psz = (CHAR *) _CatDBAlloc(cch + 1)))
	{
	    goto ErrorMemory;
	}
    
    if (0 == WideCharToMultiByte(
			    GetACP(),
			    0,          // dwFlags
			    pwsz,
			    -1,         // cchWideChar, -1 => null terminated
			    psz,
			    cch,
			    NULL,
			    NULL))
    {
        goto ErrorWideCharToMultiByte;
    }
    
CommonReturn:

    return (psz);

ErrorReturn:

    if (psz != NULL)
    {
        _CatDBFree(psz);
    }
    
    psz = NULL;
    goto CommonReturn; 

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorWideCharToMultiByte)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


LPWSTR _CATDBAllocAndCopyWSTR(LPCWSTR pwsz)
{
    LPWSTR  pwszTemp = NULL;

    if (NULL == (pwszTemp = 
                 (LPWSTR) _CatDBAlloc(sizeof(WCHAR) * (wcslen(pwsz) + 1) )))
    {
        goto ErrorMemory;
    }

    wcscpy(pwszTemp, pwsz);

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn; 

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


LPWSTR _CATDBAllocAndCopyWSTR2(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    LPWSTR  pwszTemp = NULL;

    if (NULL == (pwszTemp = 
                 (LPWSTR) _CatDBAlloc(sizeof(WCHAR) * ( wcslen(pwsz1) +
                                                        wcslen(pwsz2) + 
                                                        1))))
    {
        goto ErrorMemory;
    }

    wcscpy(pwszTemp, pwsz1);
    wcscat(pwszTemp, pwsz2);

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn; 

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


BOOL _CATDBStrCatWSTR(LPWSTR *ppwszAddTo, LPCWSTR pwszAdd)
{
    BOOL    fRet = TRUE;
    LPWSTR  pwszTemp = NULL;

    if (NULL == (pwszTemp = (LPWSTR) _CatDBAlloc(sizeof(WCHAR) * (  wcslen(*ppwszAddTo) +
                                                                    wcslen(pwszAdd) + 
                                                                    1))))
    {
        goto ErrorMemory;
    }

    wcscpy(pwszTemp, *ppwszAddTo);
    wcscat(pwszTemp, pwszAdd);

    _CatDBFree(*ppwszAddTo);
    *ppwszAddTo = pwszTemp;

CommonReturn:

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn; 

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


BOOL _CATDBStrCat(LPSTR *ppszAddTo, LPCSTR pszAdd)
{
    BOOL   fRet = TRUE;
    LPSTR  pszTemp = NULL;

    if (NULL == (pszTemp = (LPSTR) _CatDBAlloc(sizeof(char) * ( strlen(*ppszAddTo) +
                                                                strlen(pszAdd) + 
                                                                1))))
    {
        goto ErrorMemory;
    }

    strcpy(pszTemp, *ppszAddTo);
    strcat(pszTemp, pszAdd);

    _CatDBFree(*ppszAddTo);
    *ppszAddTo = pszTemp;

CommonReturn:

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn; 

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}

LPWSTR _CATDBConstructWSTRPath(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    LPWSTR  pwszTemp    = NULL;
    int     nTotalLen   = 0;
    int     nLenStr1    = 0;

    //
    // Calculate the length of the resultant string as the sum of the length
    // of pwsz1, length of pwsz2, a NULL char, and a possible extra '\' char
    //
    nLenStr1 = wcslen(pwsz1);
    nTotalLen = nLenStr1 + wcslen(pwsz2) + 2;

    //
    // Allocate the string and copy pwsz1 into the buffer
    //
    if (NULL == (pwszTemp = (LPWSTR) _CatDBAlloc(sizeof(WCHAR) * nTotalLen)))
    {
        goto ErrorMemory;
    }

    wcscpy(pwszTemp, pwsz1);

    //
    // Add the extra '\' if needed
    //
    if (pwsz1[nLenStr1 - 1] != L'\\')
    {
        pwszTemp[nLenStr1] = L'\\';
        pwszTemp[nLenStr1 + 1] = L'\0';
    }

    //
    // Tack on pwsz2
    //
    wcscat(pwszTemp, pwsz2);

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn; 

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


LPSTR _CATDBConstructPath(LPCSTR psz1, LPCSTR psz2)
{
    LPSTR   pszTemp     = NULL;
    int     nTotalLen   = 0;
    int     nLenStr1    = 0;

    //
    // Calculate the length of the resultant string as the sum of the length
    // of psz1, length of psz2, a NULL char, and a possible extra '\' char
    //
    nLenStr1 = strlen(psz1);
    nTotalLen = nLenStr1 + strlen(psz2) + 2;

    //
    // Allocate the string and copy pwsz1 into the buffer
    //
    if (NULL == (pszTemp = 
                 (LPSTR) _CatDBAlloc(sizeof(char) * nTotalLen)))
    {
        goto ErrorMemory;
    }

    strcpy(pszTemp, psz1);

    //
    // Add the extra '\' if needed
    //
    if (psz1[nLenStr1 - 1] != '\\')
    {
        pszTemp[nLenStr1] = '\\';
        pszTemp[nLenStr1 + 1] = '\0';
    }

    //
    // Tack on pwsz2
    //
    strcat(pszTemp, psz2);

CommonReturn:

    return (pszTemp);

ErrorReturn:

    goto CommonReturn; 

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\catdbsvc.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    catdbsvc.cpp

Abstract:

    This module contains routines associated with the service
    side of the catalog database

Author:

    Reid Kuhn (reidk)     19-Nov-97

--*/

/*

This comment section gives a picture of an example catalog database,
with example catalog files added and the resulting database tables.
The database schema can be seen clearly by looking at the picture of
the database tables.  This comment section also contains psuedo code
for the add catalog algorithm.


Catalogs added to the catalog database are stored in the FILE SYSTEM
--------------------------------------------------------------------

            --------    --------    --------    --------    --------    --------
Catname:    | CatA |    | CatB |    | CatC |    | CatD |    | CatE |    | CatF |
            --------    --------    --------    --------    --------    --------
HashList:   | 111  |    | 111  |    | 444  |    | 333  |    | 333  |    | 555  |
            | 222  |    | 222  |    |      |    |      |    | 555  |    |      |
            | 333  |    |      |    |      |    |      |    |      |    |      |
            --------    --------    --------    --------    --------    --------


Resulting Database Tables (above catalogs where added in order)
--------------------------------------------------------------------

    HashCatNameTable
    ----------------------------------
    | HashCol   | CatNameListCol     |
    |-----------|--------------------|
    | 111       | CatA - CatB        |
    | 222       | CatA - CatB        |
    | 333       | CatA - CatD - CatE |
    | 444       | CatC               |
    | 555       | CatE - CatF        |
    ----------------------------------

    CatNameBuddyTable
    ---------------------------------------------
    | CatNameCol    | BuddyListCol              |
    ---------------------------------------------
    | CatA          | CatB - CatD - CatE        |
    | CatB          | CatA                      |
    | CatD          | CatA - CatB - CatE        |
    | CatE          | CatA - CatB - CatD - CatF |
    | CatF          | CatE - CatA - CatB - CatD |
    ---------------------------------------------



Add Catalog Algorithm
---------------------

AddCat(<CatToAdd>)
{
    For each hash <i> contained in catalog <CatToAdd>
    {
        if (<i> is not contained in HashCol of HashCatNameTable)
        {
            add row to HashCatNameTable with <i> in HashCol and <CatToAdd> in CatNameListCol
        }
        else
        {
            create row in CatNameBuddyTable with <CatToAdd> in CatNameCol

            for each CatName <CatNameIn-CatNameListCol> contained in <i>'s CatNameListCol
            {
                if (<CatNameIn-CatNameListCol> is not contained in CatNameCol of CatNameBuddyTable
                {
                    create row in CatNameBuddyTable with <CatNameIn-CatNameListCol> in CatNameCol
                }

                add <CatNameIn-CatNameListCol> to <CatToAdd>'s BuddyListCol

                for each CatName <CatNameIn-BuddyListCol> contained in <CatNameIn-CatNameListCol>'s BuddyListCol - (may be empty)
                {
                    add <CatNameIn-BuddyListCol> to <CatToAdd>'s BuddyListCol
                }

                add <CatToAdd> to <CatNameIn-CatNameListCol>'s BuddyListCol
            }

            add <CatToAdd> to <i>'s CatNameListCol
        }
    }
}

*/

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <dbgdef.h>
#include <esent.h>
#include <assert.h>
#include <stdio.h>

#include "catdb.h" // header file generated by MIDL compiler
#include "dbutils.h"
#include "voidlist.h"
#include "catutil.h"
#include "resource.h"
#include "errlog.h"
#include "mscat.h"


#define CATDB_MAX_CATNAME_LENGTH    255

#define WSZ_REG_TEMP_FILES_KEY              L"Software\\Microsoft\\Cryptography\\CatDBTempFiles"
#define WSZ_REG_CATALOGDB_VALUES            L"Software\\Microsoft\\Cryptography\\CatalogDB"
#define WSZ_REG_CALLBACK_TIMER              L"CallbackTime"
#define WSZ_REG_DATABASE_TIMEOUT            L"DatabaseTimeout"

#define SZ_CATALOG_FILE_BASE_DIRECTORY     "CatRoot"
#define WSZ_CATALOG_FILE_BASE_DIRECTORY     L"CatRoot"
#define SZ_DATABASE_FILE_BASE_DIRECTORY     "CatRoot2"
#define WSZ_DATABASE_FILE_BASE_DIRECTORY    L"CatRoot2"

#define SZ_DBFILE_NAME                      "catdb"
#define WSZ_DBFILE_NAME                      L"catdb"

#define WSZ_TIME_STAMP_FILE                  L"TimeStamp"

#define CATDBSVC_LOGERR_LASTERR()           ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBSCV, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE);

#define CATDBSVC_SETERR_LOG_RETURN(x, y)    SetLastError(x); \
                                            ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBSCV, \
                                                            __LINE__, \
                                                            0, \
                                                            FALSE, \
                                                            FALSE); \
                                            goto y;

#define CATDBSVC_LOGERR(x)                  ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBSCV, \
                                                            __LINE__, \
                                                            x, \
                                                            FALSE, \
                                                            FALSE);

#define CATDBSVC_LOGWARN(x)                 ErrLog_LogError(NULL, \
                                                            ERRLOG_CLIENT_ID_CATDBSCV, \
                                                            __LINE__, \
                                                            x, \
                                                            TRUE, \
                                                            FALSE);

#define ALLOCATION_BLOCK_SIZE  8

typedef struct _JET_DB_STRUCT
{
    LPSTR           pszDBFileName;

    JET_SESID       JetSesID;
    JET_DBID        JetDBID;

    // Hash-CatName Table
    JET_TABLEID     JetHashCatNameTableID;
    JET_COLUMNID    JetHashCatNameTable_HashColumnID;
    JET_COLUMNID    JetHashCatNameTable_CatNameColumnID;

    // CatName Buddy Table
    JET_TABLEID     JetCatNameBuddyTableID;
    JET_COLUMNID    JetCatNameBuddyTable_CatNameColumnID;
    JET_COLUMNID    JetCatNameBuddyTable_BuddyColumnID;

} JET_DB_STRUCT, *PJET_DB_STRUCT;

typedef struct _CATALOG_DIR_CACHE_STRUCT
{
    JET_DB_STRUCT   JetDBStruct;
    LPWSTR          pwszSubSysGUID;
    BOOL            fDBCurrentlyInUse;
    BOOL            fReadOnly;
    DWORD           dwTimeLastTouched;
    HANDLE          hRegisterWaitForServiceShutdown;

} CATALOG_DIR_CACHE_STRUCT, *PCATALOG_DIR_CACHE_STRUCT;

typedef struct _NOTIFICATION_STRUCT
{
    DWORD   ProcessID;
    HANDLE  hClientProcess;
    HANDLE  hRegisterWaitFor;
    HANDLE  hNotificationHandle;
    HANDLE  hDuplicatedNotificationHandle;
    LONG    lNotificationID;

} NOTIFICATION_STRUCT, *PNOTIFICATION_STRUCT;


//
// Global variables
//
extern HINSTANCE            g_hInst;
BOOL                        g_fDBSvcInitialized                 = FALSE;
CRITICAL_SECTION            g_CatDBAddDeleteCS;
CRITICAL_SECTION            g_CatDBRegisterNotifyCS;
CRITICAL_SECTION            g_CatDirCashCS;
CRITICAL_SECTION            g_CatClientCountCS;
CRITICAL_SECTION            g_InitializeJetCS;
CRITICAL_SECTION            g_CleanupTempFilesCS;
LONG                        g_lOpenedDBCount                    = 0;
BOOL                        g_fJetInitialized                   = FALSE;
JET_INSTANCE                g_JetInstance                       = 0;
BOOL                        g_fCleaninUpTempFiles               = FALSE;
NOTIFICATION_STRUCT         *g_rgNotificationStructs            = NULL;
DWORD                       g_NumNotificationStructs            = 0;
LIST                        g_CatalogDBCacheList;
HANDLE                      g_hCatalogCacheCallbackEvent        = NULL;
BOOL                        g_fCatalogCacheCallbackEventSet     = FALSE;
DWORD                       g_dwClientCount                     = 0;
LONG                        g_lNotificationID                   = 0;
LPWSTR                      g_pwszCatalogFileBaseDirectory      = NULL;
LPWSTR                      g_pwszDatabaseFileBaseDirectory     = NULL;
DWORD                       g_dwCatalogDatabaseCacheTimeout     = (1000 * 60); // default one minute
DWORD                       g_dwCatalogDatabaseCacheCallbackTime= (1000 * 60 * 2); // default two minutes



//
// Forward declarations
//

//
// General supporting DB file functions
//

BOOL
_CatDBClientEnter(void);

void
_CatDBClientExit(void);

void
_CatDBTouchTimeStampFile(
    LPCWSTR             pwszSubSysGUID);

BOOL
_CatDBInitializeJet(
    BOOL                fInRecursiveCall);

BOOL
_CatDBTermJet();

BOOL
_CatDBAcquireOpenDatabaseFromCache(
    PJET_DB_STRUCT      *ppJetDBStruct,
    LPCWSTR             pwszSubSysGUID,
    BOOL                fReadOnly,
    BOOL                fInRecursiveCall
    );

BOOL
_CatDBReleaseDatabaseToCache(
    PJET_DB_STRUCT      pJetDBStruct
    );

BOOL
_CatDBCloseSingleCachedDatabase(
    CATALOG_DIR_CACHE_STRUCT *pCatDirCacheStruct
    );

BOOL
_CatDBCloseCachedDatabases();

VOID CALLBACK
_CatDBWaitOrTimerCallback(
    PVOID lpParameter,
    BOOLEAN fTimedOut
    );


//
// Supporting functions for s_SSCatDBAddCatalog
//
DWORD _CatDBAddCatalog(
    handle_t            h,
    DWORD               dwFlags,
    LPCWSTR             pwszSubSysGUID,
    LPCWSTR             pwszCatalogFile,
    LPCWSTR             pwszCatName,
    BOOL                fInRecursiveCall,
    LPWSTR __RPC_FAR    *ppwszCatalogNameUsed);

BOOL
_CatDBAddCatalogEntriesToDatabase(
    PJET_DB_STRUCT      pJetDBStruct,
    PCCTL_CONTEXT       pCTLContext,
    LPWSTR              pwszNewCatalogName
    );

BOOL
_CatDBAddHashCatNamePair(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddNewRowToHashCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddValueToExistingHashCatNameRow(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBCatnameAlreadyInHashesListOfCats(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddNewRowToCatNameBuddyTableIfNotExists(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddNewRowToCatNameBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBAddNameToBuddyList(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszNameToAdd,
    LPWSTR              pwszListToAddTo
    );

BOOL
_CatDBAddWholeBuddyList(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszBuddyToAddTo,
    LPWSTR              pwszBuddyListName
    );

BOOL
_CatDBMoveInUseFileToTempLocation(
    LPWSTR              pwszFile
    );

void
_CatDBCleanupTempFiles();


//
// Supporting functions for s_SSCatDBDeleteCatalog
//

BOOL
_CatDBDeleteCatalogEntriesFromDatabase(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatalogName
    );

BOOL
_CatDBRemoveCatNameFromHashesListOfCatNames(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBRemoveCatNameFromMultiValuedColumn(
    PJET_DB_STRUCT      pJetDBStruct,
    JET_TABLEID         jetTableID,
    JET_COLUMNID        jetColumnID,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBRemoveCatNameFromCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName
    );

BOOL
_CatDBRemoveCatNameFromBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName
    );


//
// Supporting functions for s_SSCatDBEnumCatalogs
//

BOOL
_CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatName,
    DWORD __RPC_FAR     *pdwNumCatalogNames,
    LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames,
    BOOL                fRecursiveCall);


BOOL
_CatDBAddCatNameToReturnBuddyListIfNotExist(
    LPWSTR                      pwszBuddy,
    DWORD __RPC_FAR             *pdwNumCatalogNames,
    LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames
    );


//
// More general supporting functions
//

JET_ERR
_CatDBSeekInCatNameBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszBuddyRow
    );

JET_ERR
_CatDBSeekInHashCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob
    );

void
_CatDBNotifyClients(void);

LPWSTR
_CatDBCreateNewCatalogFileName(
    LPCWSTR             pwszCatalogFileDir,
    LPCWSTR             pwszCatName,
    BOOL                *pfFileAlreadyExists
    );

BOOL
_CatDBFindAndDecodeHashInCatEntry(
    PCTL_ENTRY                  pctlEntry,
    SPC_INDIRECT_DATA_CONTENT   **ppIndirectData
    );


DWORD
_CatDBMapJetError(
    JET_ERR         jerr);


BOOL
_CatDBJET_errFailure(
    JET_ERR         jerr);


BOOL
_CatDBInitJetDatabaseParams(
    JET_INSTANCE    *pJetInstance);


BOOL
_CatDBAttachAndOpenDatabase(
    JET_DB_STRUCT   *pJetDBStruct,
    BOOL            fReadOnly);


BOOL
_CatDBCloseDatabaseFile(
    PJET_DB_STRUCT  pJetDBStruct);

BOOL
_CatDBCatalogFileAlreadyInstalled(
    LPCWSTR pwszCatalogToBeAdded,
    LPCWSTR pwszExistingCatalog);

#define LOGEVENT_STRING_PARAMTYPE   1
#define LOGEVENT_INT_PARAMTYPE      2
#define LOGEVENT_NONE_PARAMTYPE     3


//
// Use these for memory that is transferred across an LRPC call
//
extern "C"
{
extern void __RPC_FAR * __RPC_API midl_user_allocate(size_t len);
extern void __RPC_API midl_user_free(void __RPC_FAR * ptr);
extern void __RPC_FAR * __RPC_API midl_user_reallocate(void __RPC_FAR * ptr, size_t len);
}

//
// general allocation routines
//
void * _CatDBAlloc(size_t len)
{
    void *temp;

    temp = LocalAlloc(LMEM_ZEROINIT, len);

    if (temp == NULL)
    {
        SetLastError(E_OUTOFMEMORY);
    }

    return(temp);
}

void * _CatDBReAlloc(void *p, size_t len)
{
    void *temp;

    temp = LocalReAlloc(p, len, LMEM_MOVEABLE | LMEM_ZEROINIT);

    if (temp == NULL)
    {
       SetLastError(E_OUTOFMEMORY);
    }

    return(temp);
}

void _CatDBFree(void *p)
{
    if (p != NULL)
    {
        LocalFree(p);
    }
}

LPSTR
_CatDBGetCatrootDirA()
{
    LPSTR       pszTempPath = NULL;
    char        szDefaultSystemDir[MAX_PATH + 1];
    DWORD       dwLength;

    //
    // Get System default directory
    //
    szDefaultSystemDir[0] = NULL;
    if (0 == GetSystemDirectoryA(&szDefaultSystemDir[0], MAX_PATH))
    {
        CATDBSVC_LOGERR_LASTERR()
        return (NULL);
    }

    //
    // Calculate length
    //
    dwLength = strlen(szDefaultSystemDir) + strlen(SZ_DATABASE_FILE_BASE_DIRECTORY) + 3;

    //
    // Allocate space for the full path
    //
    if (NULL == (pszTempPath = (LPSTR) malloc(sizeof(char) * dwLength)))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        return (NULL);
    }

    //
    // Make the path
    //
    strcpy(pszTempPath, szDefaultSystemDir);
    if ((pszTempPath[0]) &&
        (pszTempPath[strlen(&pszTempPath[0]) - 1] != '\\'))
    {
        strcat(pszTempPath, "\\");
    }

    strcat(pszTempPath, SZ_DATABASE_FILE_BASE_DIRECTORY);
    strcat(pszTempPath, "\\");

ErrorMemory:

    return (pszTempPath);
}


LPWSTR
_CatDBGetCatrootDirW(
    BOOL fCatroot2)
{
    LPWSTR      pwszTempPath = NULL;
    WCHAR       wszDefaultSystemDir[MAX_PATH + 1];
    DWORD       dwLength;

    //
    // Get System default directory
    //
    wszDefaultSystemDir[0] = NULL;
    if (0 == GetSystemDirectoryW(&wszDefaultSystemDir[0], MAX_PATH))
    {
        CATDBSVC_LOGERR_LASTERR()
        return (NULL);
    }

    //
    // Calculate length
    //
    dwLength = wcslen(wszDefaultSystemDir) + 3;
    if (fCatroot2)
    {
        dwLength += wcslen(WSZ_DATABASE_FILE_BASE_DIRECTORY);
    }
    else
    {
        dwLength += wcslen(WSZ_CATALOG_FILE_BASE_DIRECTORY);
    }

    //
    // Allocate space for the full path
    //
    if (NULL == (pwszTempPath = (LPWSTR) malloc(sizeof(WCHAR) * dwLength)))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorMemory)
        return (NULL);
    }

    //
    // Make the path
    //
    wcscpy(pwszTempPath, wszDefaultSystemDir);
    if ((pwszTempPath[0]) &&
        (pwszTempPath[wcslen(&pwszTempPath[0]) - 1] != L'\\'))
    {
        wcscat(pwszTempPath, L"\\");
    }

    if (fCatroot2)
    {
        wcscat(pwszTempPath, WSZ_DATABASE_FILE_BASE_DIRECTORY);
    }
    else
    {
        wcscat(pwszTempPath, WSZ_CATALOG_FILE_BASE_DIRECTORY);
    }

    wcscat(pwszTempPath, L"\\");

ErrorMemory:

    return (pwszTempPath);
}


LPWSTR
_CatDBCreatePath(
    IN LPCWSTR   pwsz1,
    IN LPCWSTR   pwsz2)
{
    LPWSTR  pwszTemp    = NULL;
    int     nTotalLen   = 0;
    int     nLenStr1    = 0;

    //
    // Calculate the length of the resultant string as the sum of the length
    // of psz1, a '\', the length of psz2, and a NULL char
    //
    nLenStr1 = wcslen(pwsz1);
    nTotalLen = nLenStr1 + wcslen(pwsz2) + 2;

    //
    // Allocate the string and copy pwsz1 into the buffer
    //
    if (NULL == (pwszTemp = (LPWSTR) malloc(sizeof(WCHAR) * nTotalLen)))
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_NOT_ENOUGH_MEMORY, ErrorReturn)
    }

    wcscpy(pwszTemp, pwsz1);

    //
    // Add the extra '\' if needed
    //
    if (pwsz1[nLenStr1 - 1] != L'\\')
    {
        wcscat(pwszTemp, L"\\");
    }

    //
    // Tack on psz2
    //
    wcscat(pwszTemp, pwsz2);

CommonReturn:

    return (pwszTemp);

ErrorReturn:

    goto CommonReturn;
}


BOOL
_CatDBDeleteFiles(
    IN LPCWSTR pwszPath,
    IN LPCWSTR pwszSearch)
{
    BOOL                fRet        = TRUE;
    HANDLE              hFindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;
    LPWSTR              pwszDelete  = NULL;

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no files
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no files of this type to delete
            //
            return (TRUE);
        }
        else
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    while (1)
    {
        //
        // Only care about files
        //
        if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            pwszDelete = _CatDBCreatePath(pwszPath, FindData.cFileName);

            if (pwszDelete == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            if (!DeleteFileW(pwszDelete))
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            free(pwszDelete);
            pwszDelete = NULL;
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszDelete != NULL)
    {
        free(pwszDelete);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}

BOOL
_CatDBDeleteJetFiles()
{
    BOOL                fRet         = TRUE;
    LPWSTR              pwszCatroot2 = NULL;
    LPWSTR              pwszDelete   = NULL;
    LPWSTR              pwszSearch   = NULL;
    LPWSTR              pwszPathName = NULL;
    HANDLE              hFindHandle  = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;

    //
    // Get the directory where the jet files live
    //
    pwszCatroot2 = _CatDBGetCatrootDirW(TRUE);

    if (pwszCatroot2 == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // build the search string for jet log files and delete them
    // (there are two forms of log files).
    //
    pwszDelete = _CatDBCreatePath(pwszCatroot2, L"edb*.log");

    if (pwszDelete == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!_CatDBDeleteFiles(pwszCatroot2, pwszDelete))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    free(pwszDelete);
    pwszDelete = NULL;

    pwszDelete = _CatDBCreatePath(pwszCatroot2, L"res*.log");

    if (pwszDelete == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!_CatDBDeleteFiles(pwszCatroot2, pwszDelete))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    free(pwszDelete);
    pwszDelete = NULL;

    //
    // Delete the "catdb" and "timestamp" files in each directory
    //

    //
    // Build a search string for catdb directories
    //
    pwszSearch = _CatDBCreatePath(pwszCatroot2, L"{????????????????????????????????????}");

    if (pwszSearch == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no directories
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_PATH_NOT_FOUND) ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no directories of this form
            //
            goto CommonReturn;
        }
        else
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    while (1)
    {
        //
        // Only care about directories
        //
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            pwszPathName = _CatDBCreatePath(pwszCatroot2, FindData.cFileName);

            if (pwszPathName == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // Delete the "catdb" file
            //
            pwszDelete = _CatDBCreatePath(pwszPathName, WSZ_DBFILE_NAME);

            if (pwszDelete == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            DeleteFileW(pwszDelete);

            free(pwszDelete);
            pwszDelete = NULL;

            //
            // Delete the "timestamp" file
            //
            pwszDelete = _CatDBCreatePath(pwszPathName, WSZ_TIME_STAMP_FILE);

            if (pwszDelete == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            DeleteFileW(pwszDelete);

            free(pwszDelete);
            pwszDelete = NULL;

            free(pwszPathName);
            pwszPathName = NULL;
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszCatroot2 != NULL)
    {
        free(pwszCatroot2);
    }

    if (pwszDelete != NULL)
    {
        free(pwszDelete);
    }

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszPathName != NULL)
    {
        free(pwszPathName);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


BOOL
_CatDBRebuildDB(
    LPCWSTR pwszPathName,
    LPCWSTR pwszDatabaseGUID)
{
    BOOL                fRet                = TRUE;
    LPWSTR              pwszSearch          = NULL;
    LPWSTR              pwszCatalog         = NULL;
    HANDLE              hFindHandle         = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;
    LPWSTR __RPC_FAR    pwszCatalogNameUsed = NULL;
    WCHAR               wszTempFile[MAX_PATH];
    JET_DB_STRUCT       *pJetDBStruct       = NULL;

    //
    // First, just make sure the database gets created by doing
    // an open and close
    //
    if (!_CatDBAcquireOpenDatabaseFromCache(
                &pJetDBStruct,
                pwszDatabaseGUID,
                FALSE,
                TRUE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    _CatDBReleaseDatabaseToCache(pJetDBStruct);

    //
    // Find all catalogs in direcotry and add each one
    //

    //
    // Build a search string for catalog files
    //
    pwszSearch = _CatDBCreatePath(pwszPathName, L"*.cat");

    if (pwszSearch == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no directories
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no files of this form
            //
            goto CommonReturn;
        }
        else
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    //
    // Get a temporary file name which will be used to when adding each catalog
    //
    if (0 == GetTempFileNameW(
                    g_pwszCatalogFileBaseDirectory,
                    L"TMP",
                    0,
                    wszTempFile))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // GetTempFileName actually creates the file, so delete it
    //
    DeleteFileW(wszTempFile);

    while (1)
    {
        //
        // Only care about files
        //
        if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            pwszCatalog = _CatDBCreatePath(pwszPathName, FindData.cFileName);

            if (pwszCatalog == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // Copy the catalog file to a temporary location and add it from there
            //
            if (!CopyFileW(pwszCatalog, wszTempFile, TRUE))
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            _CatDBAddCatalog(
                    NULL,
                    0,
                    pwszDatabaseGUID,
                    wszTempFile,
                    FindData.cFileName,
                    TRUE,
                    &pwszCatalogNameUsed);

            DeleteFileW(wszTempFile);

            if (pwszCatalogNameUsed != NULL)
            {
                MIDL_user_free(pwszCatalogNameUsed);
                pwszCatalogNameUsed = NULL;
            }

            free(pwszCatalog);
            pwszCatalog = NULL;
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszCatalog != NULL)
    {
        free(pwszCatalog);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


BOOL
_CatDBRebuildAllDBs()
{
    BOOL                fRet            = TRUE;
    LPWSTR              pwszCatroot     = NULL;
    LPWSTR              pwszSearch      = NULL;
    LPWSTR              pwszPathName    = NULL;
    HANDLE              hFindHandle     = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    FindData;
    DWORD               dwErr;

    //
    // Get the directory where the catalog files live
    //
    pwszCatroot = _CatDBGetCatrootDirW(FALSE);

    if (pwszCatroot == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Build a search string for the catalog directories
    //
    pwszSearch = _CatDBCreatePath(pwszCatroot, L"{????????????????????????????????????}");

    if (pwszSearch == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Do the initial find
    //
    hFindHandle = FindFirstFileW(pwszSearch, &FindData);
    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        //
        // See if a real error occurred, or just no directories
        //
        dwErr = GetLastError();
        if ((dwErr == ERROR_NO_MORE_FILES)  ||
            (dwErr == ERROR_PATH_NOT_FOUND) ||
            (dwErr == ERROR_FILE_NOT_FOUND))
        {
            //
            // There are no directories of this form
            //
            goto CommonReturn;
        }
        else
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    while (1)
    {
        //
        // Only care about directories
        //
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            pwszPathName = _CatDBCreatePath(pwszCatroot, FindData.cFileName);

            if (pwszPathName == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            if (!_CatDBRebuildDB(pwszPathName, FindData.cFileName))
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            free(pwszPathName);
            pwszPathName = NULL;
        }

        //
        // Get next file
        //
        if (!FindNextFileW(hFindHandle, &FindData))
        {
            if (GetLastError() == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }
        }
    }

CommonReturn:

    if (pwszCatroot != NULL)
    {
        free(pwszCatroot);
    }

    if (pwszSearch != NULL)
    {
        free(pwszSearch);
    }

    if (pwszPathName != NULL)
    {
        free(pwszPathName);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}



/////////////////////////////////////////////////////////////////////////////////////////
//
// LPC-exposed functions
//
// these functions return a DWORD equivalent to GetLastError().  The client side stub
// code will check if the return code is not ERROR_SUCCESS, and if this is the case,
// the client stub will return FALSE and SetLastError() to this DWORD.
//
/////////////////////////////////////////////////////////////////////////////////////////

DWORD _CatDBAddCatalog(
    handle_t h,
    DWORD dwFlags,
    LPCWSTR pwszSubSysGUID,
    LPCWSTR pwszCatalogFile,
    LPCWSTR pwszCatName,
    BOOL fInRecursiveCall,
    LPWSTR __RPC_FAR *ppwszCatalogNameUsed)
{
    DWORD           dwRet                               = ERROR_SUCCESS;
    RPC_STATUS      RpcStatus;
    LPWSTR          pwszCatalogFileDir                  = NULL;
    BOOL            fImpersonating                      = FALSE;
    JET_DB_STRUCT   *pJetDBStruct                       = NULL;
    BOOL            fCatalogDatabaseAcquiredFromCache   = FALSE;
    PCCTL_CONTEXT   pCTLContext                         = NULL;
    LPWSTR          pwszNewCatalogName                  = NULL;
    HANDLE          hMappedFile                         = NULL;
    BYTE            *pbMappedFile                       = NULL;
    BOOL            fTransactionBegun                   = FALSE;
    BOOL            fFileAlreadyExists                  = FALSE;
    WCHAR           wszTempFile[MAX_PATH];
    JET_ERR         jerr;
    BOOL            fTempFileCreated                    = FALSE;
    BOOL            fCSEntered                          = FALSE;

    //
    // Initialize out param
    //
    *ppwszCatalogNameUsed = NULL;

    //
    // Only allow one add or delete at a time
    //
    __try
    {
        EnterCriticalSection(&g_CatDBAddDeleteCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        CATDBSVC_SETERR_LOG_RETURN(GetExceptionCode(), ErrorEnterCS)
    }
    fCSEntered = TRUE;

    //
    // Impersonate client if needed
    //
    if (h != NULL)
    {
        if (ERROR_SUCCESS != (RpcStatus = RpcImpersonateClient(h)))
        {
            CATDBSVC_SETERR_LOG_RETURN(RpcStatus, ErrorImpersonateClient);
        }
        fImpersonating = TRUE;
    }

    //
    // Create the path to the catalog files
    //
    if (NULL == (pwszCatalogFileDir = _CATDBConstructWSTRPath(
                                            g_pwszCatalogFileBaseDirectory,
                                            pwszSubSysGUID)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get the fully qualified path name of the new catalog file
    //
    if (NULL == (pwszNewCatalogName = _CatDBCreateNewCatalogFileName(
                                            pwszCatalogFileDir,
                                            pwszCatName,
                                            &fFileAlreadyExists)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (NULL == (*ppwszCatalogNameUsed = (LPWSTR)
                    midl_user_allocate((wcslen(pwszNewCatalogName) + 1) * sizeof(WCHAR))))
    {
        CATDBSVC_SETERR_LOG_RETURN(E_OUTOFMEMORY, ErrorMemory)
    }
    wcscpy(*ppwszCatalogNameUsed, pwszNewCatalogName);

    //
    // Open a CTL context on the catalog being added
    //
    if (!CatUtil_CreateCTLContextFromFileName(
            pwszCatalogFile,
            &hMappedFile,
            &pbMappedFile,
            &pCTLContext,
            FALSE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // If we are replacing an existing catalog, save a copy of the old one
    // in case the commit fails
    //
    if (fFileAlreadyExists)
    {
        if (0 == GetTempFileNameW(
                        g_pwszCatalogFileBaseDirectory,
                        L"TMP",
                        0,
                        wszTempFile))
        {
            //
            // If the entries couldn't be deleted because the user doesn't
            // have write rights, then do a check to see if the catalog
            // they are trying to add already exists, if it does, then
            // retrun ERROR_ALREADY_EXISTS instead of ACCESS_DENIED
            //
            if (GetLastError() == ERROR_ACCESS_DENIED)
            {
                if (_CatDBCatalogFileAlreadyInstalled(
                            pwszCatalogFile,
                            pwszNewCatalogName))
                {
                    SetLastError(ERROR_ALREADY_EXISTS);
                    goto ErrorReturn;
                }
            }
            else
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorGetTempFileName;
            }
        }

        //
        // Copy the old catalog file to a temporary location
        //
        if (!CopyFileW(pwszNewCatalogName, wszTempFile, FALSE))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorCopyFile;
        }
        fTempFileCreated = TRUE;
    }

    //
    // Open the database file
    //
    if (!_CatDBAcquireOpenDatabaseFromCache(
                &pJetDBStruct,
                pwszSubSysGUID,
                FALSE,
                fInRecursiveCall))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    fCatalogDatabaseAcquiredFromCache = TRUE;

    //
    // Start transaction
    //
    if (_CatDBJET_errFailure(jerr  =
            JetBeginTransaction(pJetDBStruct->JetSesID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetBeginTransaction)
    }
    fTransactionBegun = TRUE;

    if (fFileAlreadyExists)
    {
        if (!_CatDBDeleteCatalogEntriesFromDatabase(
                pJetDBStruct,
                pwszNewCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    //
    // Add the new DB entries
    //
    if (!_CatDBAddCatalogEntriesToDatabase(
            pJetDBStruct,
            pCTLContext,
            pwszNewCatalogName))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Don't need the CTL context anymore
    //
    CertFreeCTLContext(pCTLContext);
    pCTLContext = NULL;
    UnmapViewOfFile(pbMappedFile);
    pbMappedFile = NULL;
    CloseHandle(hMappedFile);
    hMappedFile = NULL;

    //
    // Now, copy the new catalog file to its location
    //
    if (!CopyFileW(pwszCatalogFile, pwszNewCatalogName, FALSE))
    {
        if (!fFileAlreadyExists)
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorCopyFile;
        }

        //
        // Since that failed, try renaming the destination file, and then re-copy.
        // BTW, the above copy will fail if another client already has the
        // destination file memory mapped in their catalog cache.
        //
        if (!_CatDBMoveInUseFileToTempLocation(pwszNewCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Now, retry the copy... this better work!
        //
        if (!CopyFileW(pwszCatalogFile, pwszNewCatalogName, FALSE))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorCopyFile;
        }
    }
    SetFileAttributesW(pwszNewCatalogName, FILE_ATTRIBUTE_SYSTEM);

    //
    // At this stage do the commit.
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCommitTransaction(
                pJetDBStruct->JetSesID,
                0)))
    {
        //
        // Since there was an error doing the commit, copy back the original
        // catalog file
        //
        if (0 == CopyFileW(wszTempFile, pwszNewCatalogName, FALSE))
        {
            // THE ABOVE COOPY FAILED... THE DATABASE IS NOW INCONSISTENT!!!!!
            CATDBSVC_LOGERR_LASTERR()
        }
        else
        {
            SetFileAttributesW(pwszNewCatalogName, FILE_ATTRIBUTE_SYSTEM);
        }

        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetCommitTransaction)
    }
    fTransactionBegun = FALSE;

    _CatDBTouchTimeStampFile(pwszSubSysGUID);

    //
    // Release DB back to the cache
    //
    _CatDBReleaseDatabaseToCache(pJetDBStruct);

    //
    // Notify client of changes
    //
    _CatDBNotifyClients();

CommonReturn:

    if (fTempFileCreated)
    {
        DeleteFileW(wszTempFile);
    }

    if (pwszNewCatalogName != NULL)
    {
        _CatDBFree(pwszNewCatalogName);
    }

    if (pwszCatalogFileDir != NULL)
    {
        _CatDBFree(pwszCatalogFileDir);
    }

    if (pCTLContext != NULL)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if (pbMappedFile != NULL)
    {
        UnmapViewOfFile(pbMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    if (fImpersonating)
    {
        RpcRevertToSelf();
    }

    if (fCSEntered)
    {
        LeaveCriticalSection(&g_CatDBAddDeleteCS);
    }

    return dwRet;

ErrorReturn:

    dwRet = GetLastError();

    if (0 == dwRet)
    {
        dwRet = (DWORD) E_UNEXPECTED;
    }

    if (fTransactionBegun)
    {
        JetRollback(pJetDBStruct->JetSesID, 0);
    }

    if (fCatalogDatabaseAcquiredFromCache)
    {
        _CatDBReleaseDatabaseToCache(pJetDBStruct);
    }

    if (*ppwszCatalogNameUsed != NULL)
    {
        midl_user_free(*ppwszCatalogNameUsed);
        *ppwszCatalogNameUsed = NULL;
    }

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorImpersonateClient)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetBeginTransaction)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetCommitTransaction)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorEnterCS)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCopyFile)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorGetTempFileName)
}


DWORD s_SSCatDBAddCatalog(
    /* [in] */ handle_t h,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile,
    /* [unique][in] */ LPCWSTR pwszCatName,
    /* [out] */ LPWSTR __RPC_FAR *ppwszCatalogNameUsed)
{
    DWORD   dwRet;

    if (!_CatDBClientEnter())
    {
        CATDBSVC_LOGERR_LASTERR()
        return (GetLastError());
    }

    //
    // Check input params
    //
    if (h == NULL)
    {
        CATDBSVC_SETERR_LOG_RETURN(ERROR_BAD_ARGUMENTS, ErrorReturn)
    }

    dwRet = _CatDBAddCatalog(
                    h,
                    dwFlags,
                    pwszSubSysGUID,
                    pwszCatalogFile,
                    pwszCatName,
                    FALSE,
                    ppwszCatalogNameUsed);

    _CatDBClientExit();

CommonReturn:

    return (dwRet);

ErrorReturn:

    dwRet = GetLastError();
    goto CommonReturn;
}


DWORD s_SSCatDBDeleteCatalog(
    /* [in] */ handle_t h,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ LPCWSTR pwszCatalogFile)
{
    DWORD           dwRet                               = 0;
    RPC_STATUS      RpcStatus;
    BOOL            fImpersonating                      = FALSE;
    JET_DB_STRUCT   *pJetDBStruct                       = NULL;
    BOOL            fCatalogDatabaseAcquiredFromCache   = FALSE;
    JET_ERR         jerr;
    BOOL            fCSEntered                          = FALSE;
    LPWSTR          pwszCatalogFileFullPath             = NULL;
    BOOL            fTransactionBegun                   = FALSE;
    LPWSTR          pwszCatalogFileDir                  = NULL;

    if (!_CatDBClientEnter())
    {
        CATDBSVC_LOGERR_LASTERR()
        return (GetLastError());
    }

    //
    // Check input params
    //
    if (h == NULL)
    {
        CATDBSVC_SETERR_LOG_RETURN(E_INVALIDARG, ErrorInvalidArg)
    }

    //
    // Only allow one add or delete at a time
    //
    __try
    {
        EnterCriticalSection(&g_CatDBAddDeleteCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        CATDBSVC_SETERR_LOG_RETURN(GetExceptionCode(), ErrorEnterCS)
    }
    fCSEntered = TRUE;

    //
    // Impersonate client
    //
    if (ERROR_SUCCESS != (RpcStatus = RpcImpersonateClient(h)))
    {
        CATDBSVC_SETERR_LOG_RETURN(RpcStatus, ErrorImpersonateClient)
    }
    fImpersonating = TRUE;

    //
    // Create the path to the catalog files
    //
    if (NULL == (pwszCatalogFileDir = _CATDBConstructWSTRPath(
                                            g_pwszCatalogFileBaseDirectory,
                                            pwszSubSysGUID)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Construct full path to catalog being deleted
    //
    if (NULL == (pwszCatalogFileFullPath =
            _CATDBConstructWSTRPath(pwszCatalogFileDir, pwszCatalogFile)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Open the database file
    //
    if (!_CatDBAcquireOpenDatabaseFromCache(
                &pJetDBStruct,
                pwszSubSysGUID,
                FALSE,
                FALSE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    fCatalogDatabaseAcquiredFromCache = TRUE;

    //
    // Start transaction
    //
    if (_CatDBJET_errFailure(jerr  =
            JetBeginTransaction(pJetDBStruct->JetSesID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetBeginTransaction)
    }
    fTransactionBegun = TRUE;

    //
    // Delete the entries of the catalog file from the DB
    //
    if (!_CatDBDeleteCatalogEntriesFromDatabase(
                pJetDBStruct,
                pwszCatalogFileFullPath))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // At this stage do the commit.
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCommitTransaction(
                pJetDBStruct->JetSesID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetCommitTransaction)
    }
    fTransactionBegun = FALSE;

    if (!DeleteFileW(pwszCatalogFileFullPath))
    {
        //
        // Maybe the delete failed since the file doesn't even exist
        //
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            //
            // If the delete failed for a reason other than NOT_FOUND
            // then another client is probably already accessing the file,
            // so just copy it to a temp location and log it for deletion
            //
            if (!_CatDBMoveInUseFileToTempLocation(pwszCatalogFileFullPath))
            {
                CATDBSVC_LOGERR_LASTERR()

                //
                // Don't return an error, since this isn't fatal
                //
            }
        }
    }

    //
    // Release DB back to the cache
    //
    _CatDBReleaseDatabaseToCache(pJetDBStruct);

    //
    // Notify client of changes
    //
    _CatDBNotifyClients();

    _CatDBTouchTimeStampFile(pwszSubSysGUID);

CommonReturn:

    if (pwszCatalogFileFullPath != NULL)
    {
        _CatDBFree(pwszCatalogFileFullPath);
    }

    if (pwszCatalogFileDir != NULL)
    {
        _CatDBFree(pwszCatalogFileDir);
    }

    if(fImpersonating)
    {
        RpcRevertToSelf();
    }

    if (fCSEntered)
    {
        LeaveCriticalSection(&g_CatDBAddDeleteCS);
    }

    _CatDBClientExit();

    return dwRet;

ErrorReturn:

    dwRet = GetLastError();

    if (0 == dwRet)
    {
        dwRet = (DWORD) E_UNEXPECTED;
    }

    if (fTransactionBegun)
    {
        JetRollback(pJetDBStruct->JetSesID, 0);
    }

    if (fCatalogDatabaseAcquiredFromCache)
    {
        _CatDBReleaseDatabaseToCache(pJetDBStruct);
    }


    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorInvalidArg)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorImpersonateClient)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetBeginTransaction)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetCommitTransaction)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorEnterCS)
}


DWORD s_SSCatDBEnumCatalogs(
    /* [in] */ handle_t h,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [size_is][in] */ BYTE __RPC_FAR *pbHash,
    /* [in] */ DWORD cbHash,
    /* [out] */ DWORD __RPC_FAR *pdwNumCatalogNames,
    /* [size_is][size_is][out] */ LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames)
{
    DWORD           dwRet                               = ERROR_SUCCESS;
    RPC_STATUS      RpcStatus;
    JET_DB_STRUCT   *pJetDBStruct;
    JET_ERR         jerr;
    BOOL            fCatalogDatabaseAcquiredFromCache   = FALSE;
    CRYPT_HASH_BLOB HashBlob;
    JET_RETINFO     JetRetInfo;
    WCHAR           wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD           dwLength;
    DWORD           i;

    if (!_CatDBClientEnter())
    {
        CATDBSVC_LOGERR_LASTERR()
        return (GetLastError());
    }

    if (h == NULL)
    {
        CATDBSVC_SETERR_LOG_RETURN(E_INVALIDARG, ErrorInvalidArg)
    }

    //
    // Init out vars
    //
    *pdwNumCatalogNames = 0;
    *pppwszCatalogNames = NULL;

    //
    // Open the database file
    //
    if (!_CatDBAcquireOpenDatabaseFromCache(
                &pJetDBStruct,
                pwszSubSysGUID,
                TRUE,
                FALSE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    fCatalogDatabaseAcquiredFromCache = TRUE;

    //
    // Try to find the hash
    //
    HashBlob.pbData = pbHash;
    HashBlob.cbData = cbHash;
    jerr = _CatDBSeekInHashCatNameTable(pJetDBStruct, &HashBlob);

    if (jerr == JET_errSuccess)
    {
        //
        // Add all names from the Hashes CatNameList, plus all the buddys
        // of those CatNames
        //
        // NOTE: the order in which the CatNames are added to the list results in
        // only the first CatName of the list being guaranteed to contain the
        // hash... all other CatNames may or may not contain the hash.  This
        // is OK because the client side code only assumes the first CatName
        // contains the hash, and then explicitly searches all others for the hash.
        //
        memset(&JetRetInfo, 0, sizeof(JetRetInfo));
        JetRetInfo.cbStruct = sizeof(JetRetInfo);
        JetRetInfo.itagSequence = 1;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetHashCatNameTableID,
                    pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);

        while (jerr == JET_errSuccess)
        {
            if (!_CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames(
                        pJetDBStruct,
                        wszCatalogName,
                        pdwNumCatalogNames,
                        pppwszCatalogNames,
                        FALSE))
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // Setup for next loop
            //
            JetRetInfo.itagSequence++;
            jerr = JetRetrieveColumn(
                        pJetDBStruct->JetSesID,
                        pJetDBStruct->JetHashCatNameTableID,
                        pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                        wszCatalogName,
                        CATDB_MAX_CATNAME_LENGTH,
                        &dwLength,
                        JET_bitRetrieveCopy,
                        &JetRetInfo);
        }

        //
        // Check to see if a real error occurred and not just a JET_wrnColumnNull
        //
        if (_CatDBJET_errFailure(jerr))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }
    else if ((jerr != JET_errRecordNotFound) && _CatDBJET_errFailure(jerr))
    {
        //
        // Some real error occurred
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    if (fCatalogDatabaseAcquiredFromCache)
    {
        _CatDBReleaseDatabaseToCache(pJetDBStruct);
    }

    _CatDBClientExit();

    return dwRet;

ErrorReturn:

    dwRet = GetLastError();

    if (0 == dwRet)
    {
        dwRet = (DWORD) E_UNEXPECTED;
    }

    for (i=0; i<(*pdwNumCatalogNames); i++)
    {
        midl_user_free((*pppwszCatalogNames)[i]);
    }

    if ((*pppwszCatalogNames) != NULL)
    {
        midl_user_free(*pppwszCatalogNames);
        *pppwszCatalogNames = NULL;
    }
    *pdwNumCatalogNames = 0;

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorInvalidArg)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBProcessExitCallback
//
//---------------------------------------------------------------------------------------
VOID CALLBACK
_CatDBProcessExitCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired)
{
    LONG    lNotificationID = PtrToLong(lpParameter);
    DWORD   i;
    HANDLE  h;

    __try
    {
        EnterCriticalSection(&g_CatDBRegisterNotifyCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }

    //
    // Search through the array to make sure the handle wasn't already unregistered
    //
    i = 0;
    while ( (i < g_NumNotificationStructs) &&
            (g_rgNotificationStructs[i].lNotificationID != lNotificationID))
    {
        i++;
    }

    //
    // If it was found, then clean it up.
    //
    if (i < g_NumNotificationStructs)
    {
        g_rgNotificationStructs[i].ProcessID = 0;

        CloseHandle(g_rgNotificationStructs[i].hClientProcess);
        g_rgNotificationStructs[i].hClientProcess = NULL;

        h = (HANDLE) InterlockedExchangePointer(
                        &(g_rgNotificationStructs[i].hRegisterWaitFor),
                        NULL);
        if (h != NULL)
        {
            UnregisterWait(g_rgNotificationStructs[i].hRegisterWaitFor);
        }

        g_rgNotificationStructs[i].hNotificationHandle = INVALID_HANDLE_VALUE;

        CloseHandle(g_rgNotificationStructs[i].hDuplicatedNotificationHandle);
        g_rgNotificationStructs[i].hDuplicatedNotificationHandle =
                INVALID_HANDLE_VALUE;

        g_rgNotificationStructs[i].lNotificationID = 0;
    }

    LeaveCriticalSection(&g_CatDBRegisterNotifyCS);
}


DWORD s_SSCatDBRegisterForChangeNotification(
    /* [in] */ handle_t h,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DWORD_PTR EventHandle,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszSubSysGUID,
    /* [in] */ BOOL fUnRegister)
{
    DWORD               dwRet                   = ERROR_SUCCESS;
    HANDLE              hDuplicate              = INVALID_HANDLE_VALUE;
    DWORD               i, j;
    BOOL                fCSEntered              = FALSE;
    HANDLE              hWaitForToUnregister    = NULL;
    HANDLE              hClientProcess          = NULL;
    LONG                lLocalNotificationID    = 0;
    NOTIFICATION_STRUCT *rghTemp;

    if (!_CatDBClientEnter())
    {
        CATDBSVC_LOGERR_LASTERR()
        return (GetLastError());
    }

    if (h == NULL)
    {
        CATDBSVC_SETERR_LOG_RETURN(E_INVALIDARG, ErrorInvalidArg)
        goto ErrorInvalidArg;
    }

    //
    // NOTE: this is a implementation that just notifies
    // all clients when an add/delete catalog occurs... regardless
    // of what catalog sub-system has been modified and what sub-system
    // the client is operating in.  Because of this implementation
    // pwszCatalogDir is NOT USED.  If this changes, the client side code
    // will also need to change.  See the NOTE in the
    // _CatAdminRegisterForChangeNotification() function of catadnew.cpp
    //

    __try
    {
        EnterCriticalSection(&g_CatDBRegisterNotifyCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        CATDBSVC_SETERR_LOG_RETURN(GetExceptionCode(), ErrorEnterCS)
    }
    fCSEntered = TRUE;

    //
    // First check to see whether we are registering or unregestering
    //
    if (!fUnRegister)
    {
        //
        // Make sure we can get a slot to add the handle to
        //
        i = 0;
        while ( (i < g_NumNotificationStructs) &&
                (g_rgNotificationStructs[i].hClientProcess != NULL))
        {
            i++;
        }

        //
        // If no space, allocate more
        //
        if (i >= g_NumNotificationStructs)
        {
            if (g_NumNotificationStructs == 0)
            {
                //
                // None allocated yet, so allocate and initialize
                //
                if (NULL == (g_rgNotificationStructs = (NOTIFICATION_STRUCT *)
                                    _CatDBAlloc(sizeof(NOTIFICATION_STRUCT) *
                                                ALLOCATION_BLOCK_SIZE)))
                {
                    CATDBSVC_LOGERR_LASTERR()
                    goto ErrorMemory;
                }

                g_NumNotificationStructs = ALLOCATION_BLOCK_SIZE;

                for (j = 0; j < g_NumNotificationStructs; j++)
                {
                    g_rgNotificationStructs[j].ProcessID = 0;

                    g_rgNotificationStructs[j].hClientProcess = NULL;

                    g_rgNotificationStructs[j].hRegisterWaitFor = NULL;

                    g_rgNotificationStructs[j].hNotificationHandle =
                            INVALID_HANDLE_VALUE;

                    g_rgNotificationStructs[j].hDuplicatedNotificationHandle =
                            INVALID_HANDLE_VALUE;

                    g_rgNotificationStructs[j].lNotificationID = 0;
                }

                // set i so it can just be used as open slot
                i = 0;
            }
            else
            {
                rghTemp = g_rgNotificationStructs;

                if (NULL == (g_rgNotificationStructs = (NOTIFICATION_STRUCT *)
                                    _CatDBReAlloc(g_rgNotificationStructs,
                                                  sizeof(NOTIFICATION_STRUCT) *
                                                        (g_NumNotificationStructs +
                                                        ALLOCATION_BLOCK_SIZE))))
                {
                    g_rgNotificationStructs = rghTemp;
                    CATDBSVC_LOGERR_LASTERR()
                    goto ErrorMemory;
                }

                for (   j = g_NumNotificationStructs;
                        j < (g_NumNotificationStructs + ALLOCATION_BLOCK_SIZE);
                        j++)
                {
                    g_rgNotificationStructs[j].ProcessID = 0;

                    g_rgNotificationStructs[j].hClientProcess = NULL;

                    g_rgNotificationStructs[j].hRegisterWaitFor = NULL;

                    g_rgNotificationStructs[j].hNotificationHandle =
                            INVALID_HANDLE_VALUE;

                    g_rgNotificationStructs[j].hDuplicatedNotificationHandle =
                            INVALID_HANDLE_VALUE;

                    g_rgNotificationStructs[j].lNotificationID = 0;
                }

                // set i so it can just be used as open slot
                i = g_NumNotificationStructs;

                g_NumNotificationStructs += ALLOCATION_BLOCK_SIZE;
            }
        }

        //
        // Open the process' handle that is registering a notification since we need
        // the process handle to duplicate the event handle that they want signaled,
        // plus, we wait on it in case of process exit
        //
        if (NULL == (hClientProcess = OpenProcess(
                                        PROCESS_DUP_HANDLE | SYNCHRONIZE,
                                        FALSE,
                                        ProcessID)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorOpenProcess;
        }

        //
        // Duplicate the handle
        //
        if (0 == (DuplicateHandle(
                        hClientProcess,
                        (HANDLE) EventHandle,
                        GetCurrentProcess(),
                        &hDuplicate,
                        EVENT_MODIFY_STATE, //0,
                        FALSE,
                        0))) //DUPLICATE_SAME_ACCESS)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorDuplicateHandle;
        }

        //
        // Register a callback in cass the process exits without unregistering
        //
        lLocalNotificationID = InterlockedIncrement(&g_lNotificationID);

        if (!RegisterWaitForSingleObject(
                &(g_rgNotificationStructs[i].hRegisterWaitFor),
                hClientProcess,
                _CatDBProcessExitCallback,
                ULongToPtr(lLocalNotificationID),   // use ULongToPtr instead of LongToPtr because
                                                    // ULongToPtr zero extends instead of sign extends
                INFINITE,
                WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE))
        {

            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        g_rgNotificationStructs[i].ProcessID = ProcessID;

        g_rgNotificationStructs[i].hClientProcess = hClientProcess;
        hClientProcess = NULL;

        g_rgNotificationStructs[i].hNotificationHandle = (HANDLE) EventHandle;

        g_rgNotificationStructs[i].hDuplicatedNotificationHandle = hDuplicate;
        hDuplicate = INVALID_HANDLE_VALUE;

        g_rgNotificationStructs[i].lNotificationID = lLocalNotificationID;
    }
    else
    {
        //
        // Search through the array to find the handle being unregisterd
        //
        i = 0;
        while (i < g_NumNotificationStructs)
        {
            //
            // Match client based on ProcessID And EventHandle which is a unique pair
            //
            if ((g_rgNotificationStructs[i].hNotificationHandle == (HANDLE) EventHandle) &&
                (g_rgNotificationStructs[i].ProcessID == ProcessID))
            {
                break;
            }

            i++;
        }

        //
        // Make sure we found the handle
        //
        if (i < g_NumNotificationStructs)
        {
            g_rgNotificationStructs[i].ProcessID = 0;

            hWaitForToUnregister = (HANDLE)
                    InterlockedExchangePointer(
                        &(g_rgNotificationStructs[i].hRegisterWaitFor),
                        NULL);

            hClientProcess = g_rgNotificationStructs[i].hClientProcess;
            g_rgNotificationStructs[i].hClientProcess = NULL;

            g_rgNotificationStructs[i].hNotificationHandle = INVALID_HANDLE_VALUE;

            CloseHandle(g_rgNotificationStructs[i].hDuplicatedNotificationHandle);
            g_rgNotificationStructs[i].hDuplicatedNotificationHandle =
                    INVALID_HANDLE_VALUE;

            g_rgNotificationStructs[i].lNotificationID = 0;

            //
            // Leave the RegisterNotitifyCS before calling UnregisterWait()
            //
            LeaveCriticalSection(&g_CatDBRegisterNotifyCS);
            fCSEntered = FALSE;

            if (hWaitForToUnregister != NULL)
            {
                UnregisterWaitEx(
                    hWaitForToUnregister,
                    INVALID_HANDLE_VALUE);
            }

            CloseHandle(hClientProcess);
            hClientProcess = NULL;
        }
    }

CommonReturn:

    if (fCSEntered)
    {
        LeaveCriticalSection(&g_CatDBRegisterNotifyCS);
    }

    if (hClientProcess != NULL)
    {
        CloseHandle(hClientProcess);
    }

    if (hDuplicate != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hDuplicate);
    }

    _CatDBClientExit();

    return dwRet;

ErrorReturn:

    dwRet = GetLastError();

    if (0 == dwRet)
    {
        dwRet = (DWORD) E_UNEXPECTED;
    }

    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorInvalidArg)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorEnterCS)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorOpenProcess)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorDuplicateHandle)
}


#define CATDB_RETRY_PAUSE_COUNT     10
#define CATDB_PAUSE_RETRY_INTERNVAL 1000

DWORD s_SSCatDBPauseResumeService(
    /* [in] */ handle_t h,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DWORD dwFlags,
    /* [in] */ BOOL fResume)
{
    return (E_NOTIMPL);
}



/////////////////////////////////////////////////////////////////////////////////////////
//
// Supporting functions
//
/////////////////////////////////////////////////////////////////////////////////////////


//---------------------------------------------------------------------------------------
//
//  _CatDBServiceInit
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBServiceInit(BOOL fUnInit)
{
    BOOL                        fRet                                = TRUE;
    DWORD                       dwErr                               = 0;
    JET_ERR                     jerr;
    HKEY                        hKey;
    DWORD                       dwDisposition;
    DWORD                       dw;
    WCHAR                       wszDefaultSystemDir[MAX_PATH + 1];
    DWORD                       dwType;
    DWORD                       dwValue                             = 0;
    DWORD                       cbSize;
    DWORD                       i;
    DWORD                       NumCritSecsInitialized              = 0;
    LIST_NODE                   *pListNode                          = NULL;
    CATALOG_DIR_CACHE_STRUCT    *pCatDirCacheStruct                 = NULL;
    PVOID                       pvoid;
    BOOL                        fLeaveCritSec                       = TRUE;

    if (fUnInit && g_fDBSvcInitialized)
    {
        //
        // Set the g_fCatalogCacheCallbackEventSet BOOL so that no more
        // callbacks are registered
        //
        fLeaveCritSec = TRUE;
        __try
        {
            EnterCriticalSection(&g_CatDirCashCS);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            fLeaveCritSec = FALSE;
            g_fCatalogCacheCallbackEventSet = TRUE;
        }
        g_fCatalogCacheCallbackEventSet = TRUE;

        if (fLeaveCritSec)
        {
            LeaveCriticalSection(&g_CatDirCashCS);
        }

        //
        // This will force all callback threads to be cleared
        //
        SetEvent(g_hCatalogCacheCallbackEvent);

        //
        // Cycle through all open DBs and wait for the registered callbacks
        // to be completed
        //
        pListNode = LIST_GetFirst(&g_CatalogDBCacheList);

        while (pListNode != NULL)
        {
            pCatDirCacheStruct = (CATALOG_DIR_CACHE_STRUCT *) LIST_GetElement(pListNode);

            pvoid = InterlockedExchangePointer(
                        &pCatDirCacheStruct->hRegisterWaitForServiceShutdown,
                        NULL);

            if (pvoid != NULL)
            {
                UnregisterWaitEx((HANDLE) pvoid, INVALID_HANDLE_VALUE);
            }

            pListNode = LIST_GetNext(pListNode);
        }

        CloseHandle(g_hCatalogCacheCallbackEvent);
        g_hCatalogCacheCallbackEvent = NULL;

        //
        // Cleanup the cached catalog dirs
        //
        if (!_CatDBCloseCachedDatabases())
        {
            CATDBSVC_LOGERR_LASTERR()
            //
            // Nothing we can do but log an error
            //
        }

        _CatDBTermJet();

        if (g_pwszCatalogFileBaseDirectory != NULL)
        {
            _CatDBFree(g_pwszCatalogFileBaseDirectory);
            g_pwszCatalogFileBaseDirectory = NULL;
        }

        if (g_pwszDatabaseFileBaseDirectory != NULL)
        {
            _CatDBFree(g_pwszDatabaseFileBaseDirectory);
            g_pwszDatabaseFileBaseDirectory = NULL;
        }

        DeleteCriticalSection(&g_CatDBAddDeleteCS);
        DeleteCriticalSection(&g_CatDBRegisterNotifyCS);
        DeleteCriticalSection(&g_CatDirCashCS);
        DeleteCriticalSection(&g_CatClientCountCS);
        DeleteCriticalSection(&g_InitializeJetCS);
        DeleteCriticalSection(&g_CleanupTempFilesCS);

        g_fDBSvcInitialized = FALSE;
    }
    else if (!fUnInit)
    {
        __try
        {
            InitializeCriticalSection(&g_CatDBAddDeleteCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_CatDBRegisterNotifyCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_CatDirCashCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_CatClientCountCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_InitializeJetCS);
            NumCritSecsInitialized++;
            InitializeCriticalSection(&g_CleanupTempFilesCS);
            NumCritSecsInitialized++;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError(GetExceptionCode());
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        g_fCatalogCacheCallbackEventSet = FALSE;

        //
        // Get System default directory
        //
        wszDefaultSystemDir[0] = NULL;
        if (0 == GetSystemDirectoryW(wszDefaultSystemDir, MAX_PATH))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Create default dirs for catalog files and CatDB files
        //
        if (NULL == (g_pwszCatalogFileBaseDirectory =
                                _CATDBConstructWSTRPath(
                                        wszDefaultSystemDir,
                                        WSZ_CATALOG_FILE_BASE_DIRECTORY)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        if (NULL == (g_pwszDatabaseFileBaseDirectory =
                                _CATDBConstructWSTRPath(
                                        wszDefaultSystemDir,
                                        WSZ_DATABASE_FILE_BASE_DIRECTORY)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Get values to be used for timer callback, and database cache timeout
        //
        if (RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                WSZ_REG_CATALOGDB_VALUES,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                NULL,
                &hKey,
                &dwDisposition) == ERROR_SUCCESS)
        {
            cbSize = sizeof(DWORD);

            if (RegQueryValueExW(
                    hKey,
                    WSZ_REG_DATABASE_TIMEOUT,
                    NULL,
                    &dwType,
                    (BYTE *) &dwValue,
                    &cbSize) == ERROR_SUCCESS)
            {
                g_dwCatalogDatabaseCacheTimeout = dwValue;
            }

            dwValue = 0;
            cbSize = sizeof(DWORD);

            if (RegQueryValueExW(
                    hKey,
                    WSZ_REG_CALLBACK_TIMER,
                    NULL,
                    &dwType,
                    (BYTE *) &dwValue,
                    &cbSize) == ERROR_SUCCESS)
            {
                g_dwCatalogDatabaseCacheCallbackTime = dwValue;
            }

            RegCloseKey(hKey);
        }

        //
        // Create the event to be used in the call to RegisterWaitForSingleObject
        //
        if (NULL == (g_hCatalogCacheCallbackEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        LIST_Initialize(&g_CatalogDBCacheList);

        g_fDBSvcInitialized = TRUE;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (NumCritSecsInitialized >= 1)
    {
        DeleteCriticalSection(&g_CatDBAddDeleteCS);
    }

    if (NumCritSecsInitialized >= 2)
    {
        DeleteCriticalSection(&g_CatDBRegisterNotifyCS);
    }

    if (NumCritSecsInitialized >= 3)
    {
        DeleteCriticalSection(&g_CatDirCashCS);
    }
    if (NumCritSecsInitialized >= 4)
    {
        DeleteCriticalSection(&g_CatClientCountCS);
    }

    if (NumCritSecsInitialized >= 5)
    {
        DeleteCriticalSection(&g_InitializeJetCS);
    }

    if (NumCritSecsInitialized >= 6)
    {
        DeleteCriticalSection(&g_CleanupTempFilesCS);
    }

    if (g_pwszCatalogFileBaseDirectory != NULL)
    {
        _CatDBFree(g_pwszCatalogFileBaseDirectory);
    }

    if (g_pwszDatabaseFileBaseDirectory != NULL)
    {
        _CatDBFree(g_pwszDatabaseFileBaseDirectory);
    }

    if (g_hCatalogCacheCallbackEvent != NULL)
    {
        CloseHandle(g_hCatalogCacheCallbackEvent);
        g_hCatalogCacheCallbackEvent = NULL;
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBClientEnter
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBClientEnter(void)
{
    BOOL    fRet = TRUE;

    __try
    {
        EnterCriticalSection(&g_CatClientCountCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        CATDBSVC_LOGERR_LASTERR()
        return FALSE;
    }

    g_dwClientCount++;

    LeaveCriticalSection(&g_CatClientCountCS);

    return fRet;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBClientExit
//
//---------------------------------------------------------------------------------------
void
_CatDBClientExit(void)
{
    __try
    {
        EnterCriticalSection(&g_CatClientCountCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        CATDBSVC_LOGERR_LASTERR()

        assert(0);
        return;
    }

    g_dwClientCount--;

    LeaveCriticalSection(&g_CatClientCountCS);
}


//---------------------------------------------------------------------------------------
//
//  _CatDBTouchTimeStampFile
//
//---------------------------------------------------------------------------------------
void
_CatDBTouchTimeStampFile(
    LPCWSTR             pwszSubSysGUID)
{
    LPWSTR  pwsz = NULL;

    if (NULL != (pwsz = _CATDBConstructWSTRPath(
                                g_pwszDatabaseFileBaseDirectory,
                                pwszSubSysGUID)))
    {
        TimeStampFile_Touch(pwsz);
        _CatDBFree(pwsz);
    }
    else
    {
        CATDBSVC_LOGERR_LASTERR()
    }
}


//---------------------------------------------------------------------------------------
//
//  _CatDBInitializeJet
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBInitializeJet(
    BOOL fInRecursiveCall)
{
    BOOL    fRet        = TRUE;
    BOOL    fCSEntered  = FALSE;
    JET_ERR jerr;

    __try
    {
        EnterCriticalSection(&g_InitializeJetCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        CATDBSVC_SETERR_LOG_RETURN(GetExceptionCode(), ErrorReturn)
    }

    fCSEntered = TRUE;

    if (g_fJetInitialized)
    {
        goto CommonReturn;
    }

    //
    // Initialize Jets parameters
    //
    if (!_CatDBInitJetDatabaseParams(&g_JetInstance))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Jet will start up at this point
    //
    jerr = JetInit(&g_JetInstance);

	//
    // Check for specific JET errors, if we got one of those errors then
    // the DB is corrupt in some way and we need to try and cleanup the
    // catroot2 dir, and rebuild the DB.
    //
    // Of course we should only do this if we are not already recursing
    //
    if (!fInRecursiveCall &&
            ((jerr == JET_errMissingLogFile)    ||
             (jerr == JET_errLogFileCorrupt)    ||
             (jerr == JET_errReadVerifyFailure) ||
             (jerr == JET_errPageNotInitialized)))
    {
        CATDBSVC_LOGERR(jerr)

        JetTerm(g_JetInstance);
        g_JetInstance = 0;

        //
        // Cleanup the catroot 2 directory and then rebuild the DB
        //
        if (_CatDBDeleteJetFiles() && _CatDBRebuildAllDBs())
        {
            jerr = JET_errSuccess;
        }
    }

    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(jerr, ErrorReturn)
    }

    g_fJetInitialized = TRUE;

CommonReturn:

    if (fCSEntered)
    {
        LeaveCriticalSection(&g_InitializeJetCS);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBTermJet
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBTermJet()
{
    BOOL    fRet        = TRUE;
    BOOL    fCSEntered  = FALSE;
    JET_ERR jerr;

    __try
    {
        EnterCriticalSection(&g_InitializeJetCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        CATDBSVC_SETERR_LOG_RETURN(GetExceptionCode(), ErrorReturn)
    }

    fCSEntered = TRUE;

    if (!g_fJetInitialized ||
        (g_lOpenedDBCount != 0))
    {
        goto CommonReturn;
    }

    //
    // Shut Jet down!!
    //
    jerr = JetTerm(g_JetInstance);
    g_JetInstance = 0;
    g_fJetInitialized = FALSE;

    if (_CatDBJET_errFailure(jerr))
    {
        SetLastError(jerr);
        CATDBSVC_LOGERR(jerr)
    }

CommonReturn:

    if (fCSEntered)
    {
        LeaveCriticalSection(&g_InitializeJetCS);
    }

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAcquireOpenDatabaseFromCache
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAcquireOpenDatabaseFromCache(
    PJET_DB_STRUCT  *ppJetDBStruct,
    LPCWSTR         pwszSubSysGUID,
    BOOL            fReadOnly,
    BOOL            fInRecursiveCall)
{
    BOOL                        fRet                    = TRUE;
    JET_ERR                     jerr;
    LPSTR                       pszDatabaseFileDir      = NULL;
    LPSTR                       pszSubSysGUID           = NULL;
    LPSTR                       pszTemp                 = NULL;
    BOOL                        fJetInitialized         = FALSE;
    BOOL                        fJetSessionBegun        = FALSE;
    BOOL                        fJetDBFileOpen          = FALSE;
    BOOL                        fCSEntered              = FALSE;
    DWORD                       i;
    DWORD                       dwNewCacheStructIndex   = 0;
    BOOL                        fNewCacheStructUsed     = FALSE;
    PJET_DB_STRUCT              pJetDBStruct            = NULL;
    LIST_NODE                   *pListNode              = NULL;
    CATALOG_DIR_CACHE_STRUCT    *pCatDirCacheStruct     = NULL;
    CATALOG_DIR_CACHE_STRUCT    *pNewCatDirCacheStruct  = NULL;
    DWORD                       dwErr                   = 0;

    //
    // Do this here to ensure that JetTerm isn't called after the
    // initialize below is called.  This reference will be removed
    // if an actuall cached DB is used.
    //
    InterlockedIncrement(&g_lOpenedDBCount);

    //
    // Make sure Jet is initialized
    //
    if (!_CatDBInitializeJet(fInRecursiveCall))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // First check to see if there is a cached session available
    //
    __try
    {
        EnterCriticalSection(&g_CatDirCashCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        CATDBSVC_SETERR_LOG_RETURN(GetExceptionCode(), ErrorReturn)
    }
    fCSEntered = TRUE;

    pListNode = LIST_GetFirst(&g_CatalogDBCacheList);

    while (pListNode != NULL)
    {
        pCatDirCacheStruct = (CATALOG_DIR_CACHE_STRUCT *) LIST_GetElement(pListNode);

        if ((!pCatDirCacheStruct->fDBCurrentlyInUse)                            &&
            (_wcsicmp(pCatDirCacheStruct->pwszSubSysGUID, pwszSubSysGUID) == 0)) /*&&
            (pCatDirCacheStruct->fReadOnly == fReadOnly))*/
        {
            break;
        }

        pListNode = LIST_GetNext(pListNode);
    }

    if (pListNode != NULL)
    {
        //
        // Using a cached DB, which already has a ref count, so get rid of the
        // one added at the beginning of the function
        //
        InterlockedDecrement(&g_lOpenedDBCount);

        pCatDirCacheStruct->fDBCurrentlyInUse = TRUE;
        pCatDirCacheStruct->dwTimeLastTouched = GetTickCount();
        *ppJetDBStruct = &(pCatDirCacheStruct->JetDBStruct);
        goto CommonReturn;
    }

    //
    // There are either no cached DBs for this dir, or they are already in use...
    // So open a new instance
    //
    if (NULL == (pNewCatDirCacheStruct = (CATALOG_DIR_CACHE_STRUCT *)
                    _CatDBAlloc(sizeof(CATALOG_DIR_CACHE_STRUCT))))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    memset(&(pNewCatDirCacheStruct->JetDBStruct), 0, sizeof(JET_DB_STRUCT));
    pNewCatDirCacheStruct->pwszSubSysGUID = NULL;
    pNewCatDirCacheStruct->fDBCurrentlyInUse = TRUE;
    pNewCatDirCacheStruct->dwTimeLastTouched = GetTickCount();
    pNewCatDirCacheStruct->fReadOnly = fReadOnly;

    //
    // Make a copy of the catalog database GUID
    //
    if (NULL == (pNewCatDirCacheStruct->pwszSubSysGUID = (LPWSTR)
                    _CatDBAlloc((wcslen(pwszSubSysGUID) + 1) * sizeof(WCHAR))))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    wcscpy(pNewCatDirCacheStruct->pwszSubSysGUID, pwszSubSysGUID);

    pJetDBStruct = &(pNewCatDirCacheStruct->JetDBStruct);

    //
    // Begin a session
    //
    if (_CatDBJET_errFailure(jerr =
            JetBeginSession(
                g_JetInstance,
                &(pJetDBStruct->JetSesID),
                NULL,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fJetSessionBegun = TRUE;

    //
    // Get the fully qualified name of the database file
    //
    pszDatabaseFileDir = _CatDBConvertWszToSz(g_pwszDatabaseFileBaseDirectory);
    if (pszDatabaseFileDir == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    pszSubSysGUID = _CatDBConvertWszToSz(pwszSubSysGUID);
    if (pszSubSysGUID == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (NULL == (pszTemp = _CATDBConstructPath(pszDatabaseFileDir, pszSubSysGUID)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (NULL == (pJetDBStruct->pszDBFileName =
                                    _CATDBConstructPath(pszTemp, SZ_DBFILE_NAME)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Open the DB file... create it if it doesn't already exist
    //
    if (!_CatDBAttachAndOpenDatabase(pJetDBStruct, fReadOnly))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }
    fJetDBFileOpen = TRUE;

    //
    // Register a close callback for this database
    //
    if (!RegisterWaitForSingleObject(
            &(pNewCatDirCacheStruct->hRegisterWaitForServiceShutdown),
            g_hCatalogCacheCallbackEvent,
            _CatDBWaitOrTimerCallback,
            pNewCatDirCacheStruct, // Context
            g_dwCatalogDatabaseCacheCallbackTime,
            WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Add the opened database to the cache list
    //
    if (!LIST_AddTail(&g_CatalogDBCacheList, pNewCatDirCacheStruct))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    *ppJetDBStruct = &(pNewCatDirCacheStruct->JetDBStruct);

CommonReturn:

    if (fCSEntered)
    {
        LeaveCriticalSection(&g_CatDirCashCS);
    }

    if (pszDatabaseFileDir != NULL)
    {
        _CatDBFree(pszDatabaseFileDir);
    }

    if (pszSubSysGUID != NULL)
    {
        _CatDBFree(pszSubSysGUID);
    }

    if (pszTemp != NULL)
    {
        _CatDBFree(pszTemp);
    }

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (fJetDBFileOpen)
    {
        JetCloseDatabase(pJetDBStruct->JetSesID, pJetDBStruct->JetDBID, 0);
    }

    if (fJetSessionBegun)
    {
        JetEndSession(pJetDBStruct->JetSesID, 0);
    }

    if (pNewCatDirCacheStruct != NULL)
    {
        if (pNewCatDirCacheStruct->JetDBStruct.pszDBFileName != NULL)
        {
            _CatDBFree(pNewCatDirCacheStruct->JetDBStruct.pszDBFileName);
        }

        if (pNewCatDirCacheStruct->pwszSubSysGUID != NULL)
        {
            _CatDBFree(pNewCatDirCacheStruct->pwszSubSysGUID);
        }

        _CatDBFree(pNewCatDirCacheStruct);
    }

    InterlockedDecrement(&g_lOpenedDBCount);

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBReleaseDatabaseToCache
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBReleaseDatabaseToCache(
    PJET_DB_STRUCT  pJetDBStruct)
{
    //
    // This cast works because the JET_DB_STRUCT is the first member of the
    // CATALOG_DIR_CACHE_STRUCT
    //
    CATALOG_DIR_CACHE_STRUCT *pCatDirCacheStruct =
        (CATALOG_DIR_CACHE_STRUCT *) pJetDBStruct;

    pCatDirCacheStruct->dwTimeLastTouched = GetTickCount();
    pCatDirCacheStruct->fDBCurrentlyInUse = FALSE;

    return TRUE;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCloseSingleCachedDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCloseSingleCachedDatabase(
    CATALOG_DIR_CACHE_STRUCT    *pCatDirCacheStruct)
{
    BOOL    fRet = TRUE;
    PVOID   pvoid;

    __try
    {
        EnterCriticalSection(&g_CatDirCashCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        CATDBSVC_LOGERR_LASTERR()
        return FALSE;
    }

    //
    // unregister the callback
    //
    pvoid = InterlockedExchangePointer(
                &pCatDirCacheStruct->hRegisterWaitForServiceShutdown,
                NULL);
    if (pvoid != NULL)
    {
        UnregisterWait((HANDLE) pvoid);
    }

    //
    // If the DB is not in use and its timed out, then close
    //
    if (!(pCatDirCacheStruct->fDBCurrentlyInUse) &&
        (((GetTickCount() - pCatDirCacheStruct->dwTimeLastTouched) >
                g_dwCatalogDatabaseCacheTimeout)))
    {
        if (!_CatDBCloseDatabaseFile(&(pCatDirCacheStruct->JetDBStruct)))
        {
            fRet = FALSE;
            CATDBSVC_LOGERR_LASTERR()
        }

        //
        // if that was the last open DB, then terminate Jet
        //
        if (0 == InterlockedDecrement(&g_lOpenedDBCount))
        {
            _CatDBTermJet();
        }

        _CatDBFree(pCatDirCacheStruct->JetDBStruct.pszDBFileName);
        _CatDBFree(pCatDirCacheStruct->pwszSubSysGUID);

        LIST_RemoveElement(&g_CatalogDBCacheList, pCatDirCacheStruct);
        _CatDBFree(pCatDirCacheStruct);
    }
    else
    {
        if (!g_fCatalogCacheCallbackEventSet)
        {
            //
            // Register for another callback if we aren't in shutdown mode
            //
            if (!RegisterWaitForSingleObject(
                        &(pCatDirCacheStruct->hRegisterWaitForServiceShutdown),
                        g_hCatalogCacheCallbackEvent,
                        _CatDBWaitOrTimerCallback,
                        pCatDirCacheStruct, // Context
                        g_dwCatalogDatabaseCacheCallbackTime,
                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE))
            {
                CATDBSVC_LOGERR_LASTERR()
            }
        }
    }

    LeaveCriticalSection(&g_CatDirCashCS);

    return fRet;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCloseCachedDatabases
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCloseCachedDatabases()
{
    BOOL                        fRet = TRUE;
    DWORD                       i;
    BOOL                        fDatabaseFoundThatIsInUse   = FALSE;
    BOOL                        fCloseFailed                = FALSE;
    LIST_NODE                   *pListNode                  = NULL;
    CATALOG_DIR_CACHE_STRUCT    *pCatDirCacheStruct         = NULL;

    __try
    {
        EnterCriticalSection(&g_CatDirCashCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        CATDBSVC_LOGERR_LASTERR()
        return FALSE;
    }

    //
    // Cycle through all open DBs and close them
    //
    pListNode = LIST_GetFirst(&g_CatalogDBCacheList);

    while (pListNode != NULL)
    {
        pCatDirCacheStruct = (CATALOG_DIR_CACHE_STRUCT *) LIST_GetElement(pListNode);

        if (!(pCatDirCacheStruct->fDBCurrentlyInUse))
        {
            if (!_CatDBCloseDatabaseFile(&(pCatDirCacheStruct->JetDBStruct)))
            {
                fCloseFailed = TRUE;
                CATDBSVC_LOGERR_LASTERR()
            }
            _CatDBFree(pCatDirCacheStruct->JetDBStruct.pszDBFileName);
            _CatDBFree(pCatDirCacheStruct->pwszSubSysGUID);

            pListNode = LIST_GetNext(pListNode);
            LIST_RemoveElement(&g_CatalogDBCacheList, pCatDirCacheStruct);
            _CatDBFree(pCatDirCacheStruct);
        }
        else
        {
            fDatabaseFoundThatIsInUse = TRUE;
            pListNode = LIST_GetNext(pListNode);
        }
    }

    if (fDatabaseFoundThatIsInUse || fCloseFailed)
    {
        fRet = FALSE;
    }

    LeaveCriticalSection(&g_CatDirCashCS);

    return fRet;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBWaitOrTimerCallback
//
//---------------------------------------------------------------------------------------
VOID CALLBACK
_CatDBWaitOrTimerCallback(
    PVOID lpParameter,
    BOOLEAN fTimedOut)
{
    //
    // If we are being called because we timed out (the event wasn't set), that
    // means we should close the database if possible... otherwise, the event
    // was set because we are shutting down, so don't do anything and just let the
    // shutdown-cleanup code handle it.
    //
    if (fTimedOut)
    {
        if (!_CatDBCloseSingleCachedDatabase((CATALOG_DIR_CACHE_STRUCT *) lpParameter))
        {
            CATDBSVC_LOGERR_LASTERR()
        }
    }

    //
    // Since we have a thread, try to clean up the temp files
    //
    _CatDBCleanupTempFiles();
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddCatalogEntriesToDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddCatalogEntriesToDatabase(
    PJET_DB_STRUCT  pJetDBStruct,
    PCCTL_CONTEXT   pCTLContext,
    LPWSTR          pwszNewCatalogName)
{
    BOOL                        fRet                = TRUE;
    JET_ERR                     jerr;
    WCHAR                       *pwszCatBaseName;
    DWORD                       i;
    CRYPT_DATA_BLOB             CryptDataBlob;
    SPC_INDIRECT_DATA_CONTENT   *pIndirectData      = NULL;

    CryptDataBlob.pbData = NULL;

    //
    // Extract the base name from the full path name
    //
    if (NULL == (pwszCatBaseName = wcsrchr(pwszNewCatalogName, L'\\')))
    {
        pwszCatBaseName = wcsrchr(pwszNewCatalogName, L':');
    }

    if (pwszCatBaseName != NULL)
    {
        pwszCatBaseName++;
    }
    else
    {
        pwszCatBaseName = pwszNewCatalogName;
    }

    //
    // Loop for each hash in the catalog file
    //
    for (i=0; i<pCTLContext->pCtlInfo->cCTLEntry; i++)
    {
        if (!_CatDBFindAndDecodeHashInCatEntry(
                &(pCTLContext->pCtlInfo->rgCTLEntry[i]),
                &pIndirectData))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        if (!_CatDBAddHashCatNamePair(
                pJetDBStruct,
                &(pIndirectData->Digest),
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        _CatDBFree(pIndirectData);
        pIndirectData = NULL;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    if (pIndirectData != NULL)
    {
        _CatDBFree(pIndirectData);
    }

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddHashCatNamePair
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddHashCatNamePair(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // First, try to find the hash in the HashCatName table.
    //
    jerr = _CatDBSeekInHashCatNameTable(pJetDBStruct, pHashBlob);

    if (jerr == JET_errRecordNotFound)
    {
        //
        // not found
        //
        if (!_CatDBAddNewRowToHashCatNameTable(
                pJetDBStruct,
                pHashBlob,
                pwszCatBaseName))
        {
            goto ErrorReturn;
        }
    }
    else if (jerr == JET_errSuccess)
    {
        //
        // found
        //
        if (!_CatDBAddValueToExistingHashCatNameRow(
                pJetDBStruct,
                pHashBlob,
                pwszCatBaseName))
        {
            goto ErrorReturn;
        }
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }


CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddNewRowToHashCatNameTable
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddNewRowToHashCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_SETINFO JetSetInfo;

    //
    // Create the new row, and insert the values
    //
    if (_CatDBJET_errFailure(jerr  =
            JetPrepareUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                JET_prepInsert)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // hash
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_HashColumnID,
                pHashBlob->pbData,
                pHashBlob->cbData,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // catname
    memset(&JetSetInfo, 0, sizeof(JetSetInfo));
    JetSetInfo.cbStruct = sizeof(JetSetInfo);
    JetSetInfo.itagSequence = 1;
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                (BYTE const *) pwszCatBaseName,
                (wcslen(pwszCatBaseName) + 1) * sizeof(WCHAR),
                0,
                &JetSetInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                NULL,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddValueToExistingHashCatNameRow
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddValueToExistingHashCatNameRow(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_SETINFO JetSetInfo;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;
    JET_RETINFO JetRetInfo;

    //
    // Make sure we are not here because a single hash is in the same catalog twice...
    //
    //
    if (_CatDBCatnameAlreadyInHashesListOfCats(
            pJetDBStruct,
            pHashBlob,
            pwszCatBaseName))
    {
        goto CommonReturn;
    }

    //
    // Create a row in the CatNameBuddy Table for the current catalog if it
    // doesn't already exist
    //
    if (!_CatDBAddNewRowToCatNameBuddyTableIfNotExists(
            pJetDBStruct,
            pwszCatBaseName))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get each catalog name in the current hashes CatNameList and add it to the
    // current catalogs buddy list
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        if (!_CatDBAddNewRowToCatNameBuddyTableIfNotExists(
                pJetDBStruct,
                wszCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Add the buddy that was found to the current catalogs buddy list
        //
        if (!_CatDBAddNameToBuddyList(
                pJetDBStruct,
                wszCatalogName,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Add the buddys of the buddy that was found, to current catalogs buddy list
        //
        if (!_CatDBAddWholeBuddyList(
                pJetDBStruct,
                pwszCatBaseName,
                wszCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Add the current catalog to the buddy list of the buddy that was found
        //
        if (!_CatDBAddNameToBuddyList(
                pJetDBStruct,
                pwszCatBaseName,
                wszCatalogName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Setup for next loop
        //
        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetHashCatNameTableID,
                    pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // Check to see if a real error occurred and not just a JET_wrnColumnNull
    //
    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Add the current catalog to the CatNameList of the current hash
    //
    if (_CatDBJET_errFailure(jerr  =
            JetPrepareUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                JET_prepReplace)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    memset(&JetSetInfo, 0, sizeof(JetSetInfo));
    JetSetInfo.cbStruct = sizeof(JetSetInfo);
    JetSetInfo.itagSequence = 0; // insert into next open position
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                (BYTE const *) pwszCatBaseName,
                (wcslen(pwszCatBaseName) + 1) * sizeof(WCHAR),
                0,
                &JetSetInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                NULL,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCatnameAlreadyInHashesListOfCats
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCatnameAlreadyInHashesListOfCats(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    JET_ERR     jerr;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;
    JET_RETINFO JetRetInfo;

    //
    // Get each catalog name in the current hashes CatNameList see if it is the same
    // as pwszCatBaseName
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        if (_wcsicmp(wszCatalogName, pwszCatBaseName) == 0)
        {
            //
            // Duplicate found
            //
            return TRUE;
        }

        //
        // Setup for next loop
        //
        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetHashCatNameTableID,
                    pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // No duplicates were found
    //
    return FALSE;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddNewRowToCatNameBuddyTableIfNotExists
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddNewRowToCatNameBuddyTableIfNotExists(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // Try to find the CatName in the CatNameBuddy table.
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszCatBaseName);
    if (jerr == JET_errRecordNotFound)
    {
        //
        // not found, so add the row
        //
        if (!_CatDBAddNewRowToCatNameBuddyTable(pJetDBStruct, pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    // else, it was found, so just return successfully

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddNewRowToCatNameBuddyTable
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddNewRowToCatNameBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_SETINFO JetSetInfo;

    //
    // Create the new row, and insert the values
    //
    if (_CatDBJET_errFailure(jerr  =
            JetPrepareUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                JET_prepInsert)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // catname
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_CatNameColumnID,
                (BYTE const *) pwszCatBaseName,
                (wcslen(pwszCatBaseName) + 1) * sizeof(WCHAR),
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                NULL,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddNameToBuddyList
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddNameToBuddyList(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszNameToAdd,
    LPWSTR              pwszListToAddTo)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_SETINFO JetSetInfo;
    JET_RETINFO JetRetInfo;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;

    //
    // Don't add the same name to itself
    //
    if (_wcsicmp(pwszNameToAdd, pwszListToAddTo) == 0)
    {
        goto CommonReturn;
    }

    //
    // seek to the pwszListToAddTo row in the CatNameBuddy table
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszListToAddTo);
    if (jerr == JET_errRecordNotFound)
    {
        //
        // this bad, since we know the row should exist
        //
        CATDBSVC_SETERR_LOG_RETURN(JET_errRecordNotFound, ErrorJetDatabase)
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Check to see if the buddy being added is already there.
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        //
        // Compare to see if this is the name we are supposed to add,
        // if so, we are done, so get out
        //
        if (_wcsicmp(pwszNameToAdd, wszCatalogName) == 0)
        {
            goto CommonReturn;
        }

        //
        // Setup for next loop
        //
        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID,
                    pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // Check to see if a real error occurred and not just a JET_wrnColumnNull
    //
    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Prepare, then insert the new buddy name into the list
    //
    if (_CatDBJET_errFailure(jerr  =
            JetPrepareUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                JET_prepReplace)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    memset(&JetSetInfo, 0, sizeof(JetSetInfo));
    JetSetInfo.cbStruct = sizeof(JetSetInfo);
    JetSetInfo.itagSequence = 0; // insert in next open position
    if (_CatDBJET_errFailure(jerr  =
            JetSetColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                (BYTE const *) pwszNameToAdd,
                (wcslen(pwszNameToAdd) + 1) * sizeof(WCHAR),
                0,
                &JetSetInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetUpdate(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                NULL,
                0,
                NULL)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddWholeBuddyList
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddWholeBuddyList(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszBuddyToAddTo,
    LPWSTR              pwszBuddyListName)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_RETINFO JetRetInfo;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;

    //
    // seek to the pwszBuddyListName row in the CatNameBuddy table
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszBuddyListName);
    if (jerr == JET_errRecordNotFound)
    {
        //
        // this bad, since we know the row should exist
        //
        CATDBSVC_SETERR_LOG_RETURN(JET_errRecordNotFound, ErrorJetDatabase)
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Get each buddy in the list and add it to pwszBuddyToAddTo's buddy list
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        //
        // Add the buddy that was found to the current catalogs buddy list
        //
        if (!_CatDBAddNameToBuddyList(
                pJetDBStruct,
                wszCatalogName,
                pwszBuddyToAddTo))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }


        //
        // setup for next loop
        //

        //
        // NOTE - we have to re-seek since the cursor was reset in
        //        the _CatDBAddNameToBuddyList call
        //
        jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszBuddyListName);
        if (jerr == JET_errRecordNotFound)
        {
            //
            // this bad, since we know the row should exist
            //
            CATDBSVC_SETERR_LOG_RETURN(JET_errRecordNotFound, ErrorJetDatabase)
        }
        else if (jerr != JET_errSuccess)
        {
            //
            // error
            //
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }

        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID,
                    pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // Check to see if a real error occurred and not just a JET_wrnColumnNull
    //
    if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBMoveInUseFileToTempLocation
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBMoveInUseFileToTempLocation(
    LPWSTR              pwszFile
    )
{
    BOOL            fRet                    = TRUE;
    WCHAR           wszTempFile[MAX_PATH];
    HKEY            hKey                    = NULL;
    HKEY            hKey2                   = NULL;
    DWORD           dwDisposition;
    DWORD           i;

    //
    // Get the temp file name that the file will be renamed to
    //
    if (0 == GetTempFileNameW(
                    g_pwszCatalogFileBaseDirectory,
                    L"TMP",
                    0,
                    wszTempFile))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorGetTempFileName;
    }

    //
    // GetTempFileName actually creates the file, so delete it before doing
    // the move
    //
    DeleteFileW(wszTempFile);

    //
    // Move the file to a temporary name
    //
    if (!MoveFileW(pwszFile, wszTempFile))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorMoveFile;
    }

    //
    // The moved copy is still being accessed, so log the name of the file
    // to make sure it gets cleaned up later.
    //
    if (RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            WSZ_REG_TEMP_FILES_KEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition) == ERROR_SUCCESS)
    {
        //
        // convert all '\\' to '*'
        //
        for (i=0; i<wcslen(wszTempFile); i++)
        {
            if (wszTempFile[i] == L'\\')
            {
                wszTempFile[i] = L'*';
            }
        }

        if (RegCreateKeyW(
                hKey,
                wszTempFile,
                &hKey2) == ERROR_SUCCESS)
        {
            RegCloseKey(hKey2);
        }
    }

CommonReturn:

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorGetTempFileName)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMoveFile)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCleanupTempFiles
//
//---------------------------------------------------------------------------------------
void
_CatDBCleanupTempFiles()
{
    HKEY    hKey    = NULL;
    DWORD   dwIndex = 0;
    DWORD   dwRet   = 0;
    DWORD   dwDisposition;
    WCHAR   wszFileToDelete[MAX_PATH + 1];
    DWORD   i;

    //
    // Make sure only one thread does the cleanup at a time
    //
    __try
    {
        EnterCriticalSection(&g_CleanupTempFilesCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        CATDBSVC_LOGERR_LASTERR()
        return;
    }

    if (g_fCleaninUpTempFiles)
    {
        LeaveCriticalSection(&g_CleanupTempFilesCS);
        return;
    }

    g_fCleaninUpTempFiles = TRUE;
    LeaveCriticalSection(&g_CleanupTempFilesCS);

    //
    // Open the key that contains all the tempfile name keys
    //
    if (RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            WSZ_REG_TEMP_FILES_KEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition) == ERROR_SUCCESS)
    {
        //
        // Query to see how many keys there are
        //
        if (RegQueryInfoKey(
                hKey,
                NULL,
                NULL,
                NULL,
                &dwIndex,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL) == ERROR_SUCCESS)
        {
            dwIndex--;

            //
            // Enumerate through all the keys and try to delete the
            // corresponding temp files
            //
            while (RegEnumKeyW(
                        hKey,
                        dwIndex,
                        wszFileToDelete,
                        MAX_PATH + 1) == ERROR_SUCCESS)
            {
                //
                // convert all '*' back to '\\'
                //
                for (i=0; i<wcslen(wszFileToDelete); i++)
                {
                    if (wszFileToDelete[i] == L'*')
                    {
                        wszFileToDelete[i] = L'\\';
                    }
                }

                dwRet = DeleteFileW(wszFileToDelete);

                if ((dwRet != 0) || (GetLastError() == ERROR_FILE_NOT_FOUND))
                {
                    //
                    // convert all '\\' back to '*' and get delete the key
                    // that represents the file which has now been deleted
                    //
                    for (i=0; i<wcslen(wszFileToDelete); i++)
                    {
                        if (wszFileToDelete[i] == L'\\')
                        {
                            wszFileToDelete[i] = L'*';
                        }
                    }
                    RegDeleteKey(hKey, wszFileToDelete);
                }

                dwIndex--;
            }
        }

        RegCloseKey(hKey);
    }

    __try
    {
        EnterCriticalSection(&g_CleanupTempFilesCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        CATDBSVC_LOGERR_LASTERR()
        g_fCleaninUpTempFiles = FALSE;
        return;
    }

    g_fCleaninUpTempFiles = FALSE;
    LeaveCriticalSection(&g_CleanupTempFilesCS);
}



//---------------------------------------------------------------------------------------
//
//  _CatDBDeleteCatalogEntriesFromDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBDeleteCatalogEntriesFromDatabase(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatalogName)
{
    BOOL                        fRet                = TRUE;
    PCCTL_CONTEXT               pCTLContext         = NULL;
    HANDLE                      hMappedFile         = NULL;
    BYTE                        *pbMappedFile       = NULL;
    WCHAR                       *pwszCatBaseName;
    DWORD                       i;
    SPC_INDIRECT_DATA_CONTENT   *pIndirectData      = NULL;
    BOOL                        fDeleteUsingName    = TRUE;
    DWORD                       dwErr               = 0;

    //
    // Extract the base name from the full path name
    //
    if (NULL == (pwszCatBaseName = wcsrchr(pwszCatalogName, L'\\')))
    {
        pwszCatBaseName = wcsrchr(pwszCatalogName, L':');
    }

    if (pwszCatBaseName != NULL)
    {
        pwszCatBaseName++;
    }
    else
    {
        pwszCatBaseName = pwszCatalogName;
    }

    //
    // Open a CTL context on the catalog file whose entries are being deleted
    //
    if (CatUtil_CreateCTLContextFromFileName(
            pwszCatalogName,
            &hMappedFile,
            &pbMappedFile,
            &pCTLContext,
            FALSE))
    {
        //
        // Since we can create a CTL context on the catalog, first try to
        // delete without walking the whole HashCatnameTable, which we will
        // have to do if we delete using the catalog name only
        //
        fDeleteUsingName = FALSE;

        //
        // Loop for each hash in the catalog file
        //
        for (i=0; i<pCTLContext->pCtlInfo->cCTLEntry; i++)
        {
            if (!_CatDBFindAndDecodeHashInCatEntry(
                    &(pCTLContext->pCtlInfo->rgCTLEntry[i]),
                    &pIndirectData))
            {
                //
                // Since this failed, fallback and try to delete the catalog
                // from the DB using the catalogs name only
                //
                fDeleteUsingName = TRUE;
                break;
            }

            if (!_CatDBRemoveCatNameFromHashesListOfCatNames(
                    pJetDBStruct,
                    &(pIndirectData->Digest),
                    pwszCatBaseName))
            {
                //
                // Since this failed, fallback and try to delete the catalog
                // from the DB using the catalogs name only
                //
                fDeleteUsingName = TRUE;
                break;
            }

            _CatDBFree(pIndirectData);
            pIndirectData = NULL;
        }
    }

    if (fDeleteUsingName)
    {
        //
        // Since that failed, the catalog is most likely corrupt, so just use
        // the catalog name to delete its entries from the HashCatName table
        //
        if (!_CatDBRemoveCatNameFromCatNameTable(
                pJetDBStruct,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }

    //
    // Delete all occurences of CatName from buddy table
    //
    if (!_CatDBRemoveCatNameFromBuddyTable(
            pJetDBStruct,
            pwszCatBaseName))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

CommonReturn:

    dwErr = GetLastError();

    if (pIndirectData != NULL)
    {
        _CatDBFree(pIndirectData);
    }

    if (pCTLContext != NULL)
    {
        CertFreeCTLContext(pCTLContext);
    }
    if (pbMappedFile != NULL)
    {
        UnmapViewOfFile(pbMappedFile);
    }

    if (hMappedFile != NULL)
    {
        CloseHandle(hMappedFile);
    }

    SetLastError(dwErr);

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBRemoveCatNameFromHashesListOfCatNames
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBRemoveCatNameFromHashesListOfCatNames(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // First, try to find the hash in the HashCatName table.
    //
    jerr = _CatDBSeekInHashCatNameTable(pJetDBStruct, pHashBlob);

    if (jerr == JET_errRecordNotFound)
    {
        //
        // Not found, this is OK since a single catalog may contain the same hash
        // twice, in which case by the second time the hash is being looked for
        // the row may already be gone.
        //
        goto CommonReturn;
    }
    else if (jerr == JET_errSuccess)
    {
        //
        // found
        //
        if (!_CatDBRemoveCatNameFromMultiValuedColumn(
                pJetDBStruct,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        //
        // error
        //
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBRemoveCatNameFromMultiValuedColumn
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBRemoveCatNameFromMultiValuedColumn(
    PJET_DB_STRUCT      pJetDBStruct,
    JET_TABLEID         jetTableID,
    JET_COLUMNID        jetColumnID,
    LPWSTR              pwszCatBaseName)
{
    BOOL            fRet            = TRUE;
    JET_ERR         jerr;
    JET_SETINFO     JetSetInfo;
    WCHAR           wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD           dwLength;
    JET_RETINFO     JetRetInfo;
    BOOL            fDeleteRow      = FALSE;
    unsigned long   iValueToDelete  = 0;

    //
    // Search for the CatName in the current row
    //
    memset(&JetRetInfo, 0, sizeof(JetRetInfo));
    JetRetInfo.cbStruct = sizeof(JetRetInfo);
    JetRetInfo.itagSequence = 1;
    jerr = JetRetrieveColumn(
                pJetDBStruct->JetSesID,
                jetTableID,
                jetColumnID,
                wszCatalogName,
                CATDB_MAX_CATNAME_LENGTH,
                &dwLength,
                JET_bitRetrieveCopy,
                &JetRetInfo);

    while (jerr == JET_errSuccess)
    {
        //
        // See if this is the one
        //
        if (0 == _wcsicmp(pwszCatBaseName, wszCatalogName))
        {
            iValueToDelete = JetRetInfo.itagSequence;

            if (JetRetInfo.itagSequence == 1)
            {
                //
                // If this CatName is the only one in the row, then
                //  set a flag to just delete the row
                //
                JetRetInfo.itagSequence = 2;
                jerr = JetRetrieveColumn(
                            pJetDBStruct->JetSesID,
                            jetTableID,
                            jetColumnID,
                            wszCatalogName,
                            CATDB_MAX_CATNAME_LENGTH,
                            &dwLength,
                            JET_bitRetrieveCopy,
                            &JetRetInfo);

                if (jerr == JET_wrnColumnNull)
                {
                    jerr = JET_errSuccess;
                    fDeleteRow = TRUE;
                }
            }
            break;
        }

        //
        // Setup for next loop
        //
        JetRetInfo.itagSequence++;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    jetTableID,
                    jetColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);
    }

    //
    // Make sure the CatName was found
    //
    if (jerr == JET_wrnColumnNull)
    {
        //
        // Not found, this is OK
        //
        goto CommonReturn;

    }
    else if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // If this CatName is the only one in the row, then just delete the row,
    // otherwise, remove it from the multi-valued column
    //
    if (fDeleteRow)
    {
        if (_CatDBJET_errFailure(jerr  =
                JetDelete(
                    pJetDBStruct->JetSesID,
                    jetTableID)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }
    else
    {
        //
        // Remove the CatName from the current row
        //
        if (_CatDBJET_errFailure(jerr  =
                JetPrepareUpdate(
                    pJetDBStruct->JetSesID,
                    jetTableID,
                    JET_prepReplace)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }

        memset(&JetSetInfo, 0, sizeof(JetSetInfo));
        JetSetInfo.cbStruct = sizeof(JetSetInfo);
        JetSetInfo.itagSequence = iValueToDelete;
        if (_CatDBJET_errFailure(jerr  =
                JetSetColumn(
                    pJetDBStruct->JetSesID,
                    jetTableID,
                    jetColumnID,
                    NULL,
                    0,
                    0,
                    &JetSetInfo)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }

        if (_CatDBJET_errFailure(jerr  =
                JetUpdate(
                    pJetDBStruct->JetSesID,
                    jetTableID,
                    NULL,
                    0,
                    NULL)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBRemoveCatNameFromCatNameTable
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBRemoveCatNameFromCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // Delete this CatName from every row that contains it
    //
    jerr = JetMove(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                JET_MoveFirst,
                0);

    while (jerr == JET_errSuccess)
    {
        if (!_CatDBRemoveCatNameFromMultiValuedColumn(
                pJetDBStruct,
                pJetDBStruct->JetHashCatNameTableID,
                pJetDBStruct->JetHashCatNameTable_CatNameColumnID,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Setup for next loop
        //
        jerr = JetMove(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetHashCatNameTableID,
                    JET_MoveNext,
                    0);
    }

    //
    // See if this was a real error, or just no more records
    //
    if ((jerr != JET_errNoCurrentRecord) && _CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBRemoveCatNameFromBuddyTable
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBRemoveCatNameFromBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszCatBaseName)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    //
    // First, delete this CatName's buddy list
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszCatBaseName);

    if (jerr == JET_errSuccess)
    {
        if (_CatDBJET_errFailure(jerr  =
                JetDelete(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

    //
    // Second, delete this CatName from everyone elses buddy list
    //
    jerr = JetMove(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                JET_MoveFirst,
                0);

    while (jerr == JET_errSuccess)
    {
        if (!_CatDBRemoveCatNameFromMultiValuedColumn(
                pJetDBStruct,
                pJetDBStruct->JetCatNameBuddyTableID,
                pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                pwszCatBaseName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // Setup for next loop
        //
        jerr = JetMove(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID,
                    JET_MoveNext,
                    0);
    }

    //
    // See if this was a real error, or just no more records
    //
    if ((jerr != JET_errNoCurrentRecord) && _CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames(
    PJET_DB_STRUCT              pJetDBStruct,
    LPWSTR                      pwszCatName,
    DWORD __RPC_FAR             *pdwNumCatalogNames,
    LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames,
    BOOL                        fRecursiveCall)
{
    BOOL        fRet = TRUE;
    JET_ERR     jerr;
    JET_RETINFO JetRetInfo;
    WCHAR       wszCatalogName[CATDB_MAX_CATNAME_LENGTH];
    DWORD       dwLength;

    //
    // First add the original catname
    //
    if (!_CatDBAddCatNameToReturnBuddyListIfNotExist(
            pwszCatName,
            pdwNumCatalogNames,
            pppwszCatalogNames))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Seek to the catname's buddy list
    //
    jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszCatName);

    if (jerr == JET_errSuccess)
    {
        //
        // Add all the catname's buddies, and catname's buddies' buddies (only do one recursion)
        //
        memset(&JetRetInfo, 0, sizeof(JetRetInfo));
        JetRetInfo.cbStruct = sizeof(JetRetInfo);
        JetRetInfo.itagSequence = 1;
        jerr = JetRetrieveColumn(
                    pJetDBStruct->JetSesID,
                    pJetDBStruct->JetCatNameBuddyTableID,
                    pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                    wszCatalogName,
                    CATDB_MAX_CATNAME_LENGTH,
                    &dwLength,
                    JET_bitRetrieveCopy,
                    &JetRetInfo);

        while (jerr == JET_errSuccess)
        {
            if (fRecursiveCall)
            {
                if (!_CatDBAddCatNameToReturnBuddyListIfNotExist(
                        wszCatalogName,
                        pdwNumCatalogNames,
                        pppwszCatalogNames))
                {
                    CATDBSVC_LOGERR_LASTERR()
                    goto ErrorReturn;
                }
            }
            else
            {
                //
                // Recurse to get the buddies' buddies
                //
                if (!_CatDBAddCatNameAndCatNamesBuddyListToReturnCatNames(
                        pJetDBStruct,
                        wszCatalogName,
                        pdwNumCatalogNames,
                        pppwszCatalogNames,
                        TRUE))
                {
                    CATDBSVC_LOGERR_LASTERR()
                    goto ErrorReturn;
                }
            }

            //
            // Re-seek to the catname's buddy list, since it could have moved in the
            // recursive call to this function
            //
            jerr = _CatDBSeekInCatNameBuddyTable(pJetDBStruct, pwszCatName);
            if (_CatDBJET_errFailure(jerr))
            {
                CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
            }

            //
            // Setup for next loop
            //
            JetRetInfo.itagSequence++;
            jerr = JetRetrieveColumn(
                        pJetDBStruct->JetSesID,
                        pJetDBStruct->JetCatNameBuddyTableID,
                        pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID,
                        wszCatalogName,
                        CATDB_MAX_CATNAME_LENGTH,
                        &dwLength,
                        JET_bitRetrieveCopy,
                        &JetRetInfo);
        }

        //
        // Check to see if a real error occurred and not just a JET_wrnColumnNull
        //
        if (_CatDBJET_errFailure(jerr))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAddCatNameToReturnBuddyListIfNotExist
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAddCatNameToReturnBuddyListIfNotExist(
    LPWSTR                      pwszBuddy,
    DWORD __RPC_FAR             *pdwNumCatalogNames,
    LPWSTR __RPC_FAR *__RPC_FAR *pppwszCatalogNames)
{
    BOOL        fRet            = TRUE;
    DWORD       i;
    BOOL        fAlreadyExists  = FALSE;
    LPWSTR      *rgTemp         = NULL;

    //
    // First, see if the name already exists in the list
    //
    for (i=0; i<(*pdwNumCatalogNames); i++)
    {
        if (_wcsicmp((*pppwszCatalogNames)[i], pwszBuddy) == 0)
        {
            fAlreadyExists = TRUE;
            break;
        }
    }

    //
    // Add it if it doesn't already exist
    //
    if (!fAlreadyExists)
    {
        //
        // Allocate a new slot in the array of buddy names
        //
        if ((*pdwNumCatalogNames) == 0)
        {
            *pppwszCatalogNames = (LPWSTR __RPC_FAR *)
                    midl_user_allocate(sizeof(LPWSTR));
        }
        else
        {
            rgTemp = *pppwszCatalogNames;
            *pppwszCatalogNames =   (LPWSTR __RPC_FAR *)
                                    midl_user_reallocate(
                                        *pppwszCatalogNames,
                                        ((*pdwNumCatalogNames) + 1) * sizeof(LPWSTR));
        }

        //
        // Make sure allocation worked
        //
        if ((*pppwszCatalogNames) == NULL)
        {
            *pppwszCatalogNames = rgTemp;
            CATDBSVC_SETERR_LOG_RETURN(E_OUTOFMEMORY, ErrorMemory)
        }

        (*pppwszCatalogNames)[(*pdwNumCatalogNames)] = (LPWSTR)
                midl_user_allocate((wcslen(pwszBuddy) + 1) * sizeof(WCHAR));

        if ((*pppwszCatalogNames)[(*pdwNumCatalogNames)] == NULL)
        {
            CATDBSVC_SETERR_LOG_RETURN(E_OUTOFMEMORY, ErrorMemory)
        }
        wcscpy((*pppwszCatalogNames)[(*pdwNumCatalogNames)], pwszBuddy);
        (*pdwNumCatalogNames)++;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBSeekInCatNameBuddyTable
//
//---------------------------------------------------------------------------------------
JET_ERR
_CatDBSeekInCatNameBuddyTable(
    PJET_DB_STRUCT      pJetDBStruct,
    LPWSTR              pwszBuddyRow)
{
    JET_ERR jerr;

    if (_CatDBJET_errFailure(jerr  =
            JetMakeKey(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                (BYTE const *) pwszBuddyRow,
                (wcslen(pwszBuddyRow) + 1) * sizeof(WCHAR),
                JET_bitNewKey)))
    {
        return jerr;
    }

    jerr = JetSeek(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                JET_bitSeekEQ);

    return jerr;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBSeekInHashCatNameTable
//
//---------------------------------------------------------------------------------------
JET_ERR
_CatDBSeekInHashCatNameTable(
    PJET_DB_STRUCT      pJetDBStruct,
    PCRYPT_DATA_BLOB    pHashBlob)
{
    JET_ERR jerr;

    if (_CatDBJET_errFailure(jerr  =
            JetMakeKey(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                pHashBlob->pbData,
                pHashBlob->cbData,
                JET_bitNewKey)))
    {
        return jerr;
    }

    jerr = JetSeek(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                JET_bitSeekEQ);

    return jerr;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBNotifyClients
//
//---------------------------------------------------------------------------------------
void
_CatDBNotifyClients(void)
{
    DWORD i = 0;

    while (i < g_NumNotificationStructs)
    {
        if (g_rgNotificationStructs[i].hDuplicatedNotificationHandle !=
                INVALID_HANDLE_VALUE)
        {
            SetEvent(g_rgNotificationStructs[i].hDuplicatedNotificationHandle);
        }
        i++;
    }
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCreateNewCatalogFileName
//
//---------------------------------------------------------------------------------------
#define SZ_UNIQUE_CAT_FILENAME_FORMAT   L"%X.CAT"
#define MAX_UNIQUE_CAT_FILES            0xffffffff

LPWSTR
_CatDBCreateNewCatalogFileName(
    LPCWSTR pwszCatalogFileDir,
    LPCWSTR pwszCatName,
    BOOL    *pfFileAlreadyExists)
{
    LPWSTR  pwszFullyQualifiedCatName   = NULL;
    WCHAR   pwszTempBaseName[56];
    BOOL    fUniqueFileNameFound;
    DWORD   dw;
    HANDLE  hTestFile                   = INVALID_HANDLE_VALUE;
    DWORD   dwLastErr                   = 0;

    if (pwszCatName != NULL)
    {
        //
        // The caller specified the cat name to use, so just concatenate the
        // the path and the name
        //
        if (NULL == (pwszFullyQualifiedCatName = _CATDBConstructWSTRPath(
                                                        pwszCatalogFileDir,
                                                        pwszCatName)))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }

        //
        // See if this file already exists by trying to create the file
        //
        hTestFile = CreateFileW(
                        pwszFullyQualifiedCatName,
                        GENERIC_WRITE | GENERIC_READ,
                        0, // dwShareMode
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL); // hTemplateFile

        dwLastErr = GetLastError();

        if ((hTestFile == INVALID_HANDLE_VALUE) &&
            (   (dwLastErr == ERROR_FILE_NOT_FOUND) ||
                (dwLastErr == ERROR_PATH_NOT_FOUND) ||
                (dwLastErr == ERROR_BAD_NETPATH)))
        {
            *pfFileAlreadyExists = FALSE;
        }
        else if (hTestFile == INVALID_HANDLE_VALUE)
        {
            *pfFileAlreadyExists = TRUE;
        }
        else
        {
            *pfFileAlreadyExists = TRUE;
            CloseHandle(hTestFile);
        }
    }
    else
    {
        *pfFileAlreadyExists = FALSE;

        //
        // Create a unique name for the directory in question
        //
        fUniqueFileNameFound = FALSE;
        dw = 1;

        while ((!fUniqueFileNameFound) && (dw != 0))  // (dw == 0) after rollover.
        {
            wsprintfW(pwszTempBaseName, SZ_UNIQUE_CAT_FILENAME_FORMAT, dw);
            if (NULL == (pwszFullyQualifiedCatName = _CATDBConstructWSTRPath(
                                                            pwszCatalogFileDir,
                                                            pwszTempBaseName)))

            if (pwszFullyQualifiedCatName == NULL)
            {
                CATDBSVC_LOGERR_LASTERR()
                goto ErrorReturn;
            }

            //
            // See if this is a unique file name by trying to create the file
            //
            hTestFile = CreateFileW(
                            pwszFullyQualifiedCatName,
                            GENERIC_WRITE | GENERIC_READ,
                            0, // dwShareMode
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL); // hTemplateFile

            if (hTestFile == INVALID_HANDLE_VALUE)
            {
                fUniqueFileNameFound = TRUE;
            }
            else
            {
                CloseHandle(hTestFile);

                //
                // Setup for next iteration
                //
                _CatDBFree(pwszFullyQualifiedCatName);
                pwszFullyQualifiedCatName = NULL;
                dw++;
            }
        }
    }

CommonReturn:

    return pwszFullyQualifiedCatName;

ErrorReturn:

    if (pwszFullyQualifiedCatName != NULL)
    {
        _CatDBFree(pwszFullyQualifiedCatName);
    }
    pwszFullyQualifiedCatName = NULL;

    goto CommonReturn;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBFindAndDecodeHashInCatEntry
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBFindAndDecodeHashInCatEntry(
    PCTL_ENTRY                  pctlEntry,
    SPC_INDIRECT_DATA_CONTENT   **ppIndirectData)
{
    BOOL    fRet            = TRUE;
    DWORD   i;
    DWORD   cbIndirectData  = 0;

    *ppIndirectData = NULL;

    //
    // Search for the hash in the attributes
    //
    for (i=0; i<pctlEntry->cAttribute; i++)
    {
        if (strcmp(pctlEntry->rgAttribute[i].pszObjId, SPC_INDIRECT_DATA_OBJID) == 0)
        {
            break;
        }
    }

    //
    // Make sure the hash was found
    //
    if (i >= pctlEntry->cAttribute)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorInvalidCatalogFormat;
    }

    //
    // decode the indirect data
    //
    if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                pctlEntry->rgAttribute[i].rgValue[0].pbData,
                pctlEntry->rgAttribute[i].rgValue[0].cbData,
                0,
                NULL,
                &cbIndirectData))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorCryptDecodeObject;
    }

    if (NULL == (*ppIndirectData = (SPC_INDIRECT_DATA_CONTENT *)
                    _CatDBAlloc(cbIndirectData)))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorMemory;
    }

    if (!CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                SPC_INDIRECT_DATA_CONTENT_STRUCT,
                pctlEntry->rgAttribute[i].rgValue[0].pbData,
                pctlEntry->rgAttribute[i].rgValue[0].cbData,
                0,
                *ppIndirectData,
                &cbIndirectData))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorCryptDecodeObject;
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorInvalidCatalogFormat)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorCryptDecodeObject)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorMemory)
}



#define SZ_HASH_CATNAME_TABLE               "HashCatNameTable"
#define SZ_HASH_CATNAME_TABLE_HASHCOL       "HashCatNameTable_HashCol"
#define SZ_HASH_CATNAME_TABLE_CATNAMECOL    "HashCatNameTable_CatNameCol"
#define SZ_HASH_CATNAME_TABLE_INDEX         "HashCatNameTable_Index"
#define SZ_HASH_CATNAME_TABLE_INDEX_DEF     "+HashCatNameTable_HashCol\0"

#define SZ_CATNAME_BUDDY_TABLE              "CatNameBuddyTable"
#define SZ_CATNAME_BUDDY_TABLE_CATNAMECOL   "CatNameBuddyTable_CatNameCol"
#define SZ_CATNAME_BUDDY_TABLE_BUDDYCOL     "CatNameBuddyTable_BuddyCol"
#define SZ_CATNAME_BUDDY_TABLE_INDEX        "CatNameBuddyTable_Index"
#define SZ_CATNAME_BUDDY_TABLE_INDEX_DEF    "+CatNameBuddyTable_CatNameCol\0"


//---------------------------------------------------------------------------------------
//
//  _CatDBInitJetDatabaseParams
//
//---------------------------------------------------------------------------------------
typedef struct _DBJETPARAM
{
    DWORD paramid;
    DWORD lParam;
    char *pszParam;
} DBJETPARAM;


DBJETPARAM g_rgJetParams[] = {

#define JP_LOGPATH  0
    { JET_paramLogFilePath,        0,               NULL},

#define JP_SYSTEMPATH   1
    { JET_paramSystemPath,         0,               NULL},

#define JP_TEMPPATH 2
    { JET_paramTempPath,           0,               NULL},

    { JET_paramEventSource,        0,               "Catalog Database"},

    { JET_paramMaxVerPages,          1024,          NULL},

#if !defined(_M_IA64) && !defined(_M_AXP64)
    { JET_paramEventLogCache,        32768,         NULL},
#endif

    { JET_paramCircularLog,         1,              NULL},

    { JET_paramNoInformationEvent,  1,              NULL},

    { JET_paramAccessDeniedRetryPeriod, 1000,        NULL}
};
#define CDBPARAM    (sizeof(g_rgJetParams)/sizeof(g_rgJetParams[0]))


BOOL
_CatDBInitJetDatabaseParams(
    JET_INSTANCE    *pJetInstance)
{
    BOOL        fRet        = TRUE;
    JET_ERR     jerr;
    DWORD       dw;
    LPSTR       pszTempPath = NULL;

    DBJETPARAM  const *pjp;

    //
    // Create a temp path for cat db
    //
    if (NULL == (pszTempPath = _CatDBGetCatrootDirA()))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorGetSystemDirectory;
    }

    //
    // Initialize the Jet Parameters
    //
    g_rgJetParams[JP_LOGPATH].pszParam = pszTempPath;
    g_rgJetParams[JP_SYSTEMPATH].pszParam = pszTempPath;
    g_rgJetParams[JP_TEMPPATH].pszParam = pszTempPath;

    for (pjp = g_rgJetParams; pjp < &g_rgJetParams[CDBPARAM]; pjp++)
    {
        if (_CatDBJET_errFailure(jerr  =
                JetSetSystemParameter(
                    pJetInstance,
                    0,
                    pjp->paramid,
                    pjp->lParam,
                    pjp->pszParam)))
        {
            CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
        }
    }

CommonReturn:

    if (pszTempPath != NULL)
    {
        free(pszTempPath);
    }

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorGetSystemDirectory)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBGetColumnIDs
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBGetColumnIDs(
    PJET_DB_STRUCT  pJetDBStruct)
{
    BOOL            fRet                    = TRUE;
    JET_ERR         jerr;
    JET_COLUMNDEF   JetColumnDef;
    BOOL            fHashCatNameTableOpen   = FALSE;
    BOOL            fCatNameBuddyTableOpen  = FALSE;
    DWORD           dwErr                   = 0;

    //
    // Hash-CatName table and columns
    //
    if (_CatDBJET_errFailure(jerr  =
            JetOpenTable(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_HASH_CATNAME_TABLE,
                NULL,
                0,
                0,
                &(pJetDBStruct->JetHashCatNameTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fHashCatNameTableOpen = TRUE;

    if (_CatDBJET_errFailure(jerr  =
            JetGetColumnInfo(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_HASH_CATNAME_TABLE,
                SZ_HASH_CATNAME_TABLE_HASHCOL,
                &JetColumnDef,
                sizeof(JetColumnDef),
                JET_ColInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    pJetDBStruct->JetHashCatNameTable_HashColumnID = JetColumnDef.columnid;

    if (_CatDBJET_errFailure(jerr  =
            JetGetColumnInfo(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_HASH_CATNAME_TABLE,
                SZ_HASH_CATNAME_TABLE_CATNAMECOL,
                &JetColumnDef,
                sizeof(JetColumnDef),
                JET_ColInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    pJetDBStruct->JetHashCatNameTable_CatNameColumnID = JetColumnDef.columnid;

    //
    // CatNameBuddy table and columns
    //
    if (_CatDBJET_errFailure(jerr  =
            JetOpenTable(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                NULL,
                0,
                0,
                &(pJetDBStruct->JetCatNameBuddyTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fCatNameBuddyTableOpen = TRUE;

    if (_CatDBJET_errFailure(jerr  =
            JetGetColumnInfo(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                SZ_CATNAME_BUDDY_TABLE_CATNAMECOL,
                &JetColumnDef,
                sizeof(JetColumnDef),
                JET_ColInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    pJetDBStruct->JetCatNameBuddyTable_CatNameColumnID = JetColumnDef.columnid;

    if (_CatDBJET_errFailure(jerr  =
            JetGetColumnInfo(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                SZ_CATNAME_BUDDY_TABLE_BUDDYCOL,
                &JetColumnDef,
                sizeof(JetColumnDef),
                JET_ColInfo)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    pJetDBStruct->JetCatNameBuddyTable_BuddyColumnID = JetColumnDef.columnid;


CommonReturn:

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (fHashCatNameTableOpen)
    {
        JetCloseTable(pJetDBStruct->JetSesID, pJetDBStruct->JetHashCatNameTableID);
    }

    if (fCatNameBuddyTableOpen)
    {
        JetCloseTable(pJetDBStruct->JetSesID, pJetDBStruct->JetCatNameBuddyTableID);
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCreateDBFile
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCreateDBFile(
    PJET_DB_STRUCT  pJetDBStruct,
    LPSTR           pszDBFileName)
{
    BOOL            fRet                                        = TRUE;
    JET_ERR         jerr;
    JET_COLUMNDEF   JetColumnDef;
    BOOL            fDBFileOpen                                 = FALSE;
    BOOL            fDBFileCreated                              = FALSE;
    BOOL            fTransactionBegun                           = FALSE;
    DWORD           dwErr                                       = 0;
    JET_DBID        LocalJetDBID                                = 0;
    JET_TABLEID     LocalJetHashCatNameTableID                  = 0;
    JET_COLUMNID    LocalJetHashCatNameTable_HashColumnID       = 0;
    JET_COLUMNID    LocalJetHashCatNameTable_CatNameColumnID    = 0;
    JET_TABLEID     LocalJetCatNameBuddyTableID                 = 0;
    JET_COLUMNID    LocalJetCatNameBuddyTable_CatNameColumnID   = 0;
    JET_COLUMNID    LocalJetCatNameBuddyTable_BuddyColumnID     = 0;

    //
    // Create the actual db file
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCreateDatabase(
                pJetDBStruct->JetSesID,
                pszDBFileName,
                NULL,
                &(LocalJetDBID),
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fDBFileCreated = TRUE;
    fDBFileOpen = TRUE;

    if (_CatDBJET_errFailure(jerr  =
            JetCloseDatabase(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fDBFileOpen = FALSE;

    if (_CatDBJET_errFailure(jerr  =
            JetOpenDatabase(
                pJetDBStruct->JetSesID,
                pszDBFileName,
                NULL,
                &(LocalJetDBID),
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fDBFileOpen = TRUE;

    //
    // Add the whole schema to the db file (tables, columns, indexes)
    //

    if (_CatDBJET_errFailure(jerr  =
            JetBeginTransaction(pJetDBStruct->JetSesID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fTransactionBegun = TRUE;

    //
    // Create the hash-catname table, columns, and indexes
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCreateTable(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                SZ_HASH_CATNAME_TABLE,
                4,
                100,
                &(LocalJetHashCatNameTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetCloseTable(
                pJetDBStruct->JetSesID,
                LocalJetHashCatNameTableID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetOpenTable(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                SZ_HASH_CATNAME_TABLE,
                NULL,
                0,
                0,
                &(LocalJetHashCatNameTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // Hash column
    memset(&JetColumnDef, 0, sizeof(JetColumnDef));
    JetColumnDef.cbStruct = sizeof(JetColumnDef);
    JetColumnDef.langid = 0x409;
    JetColumnDef.wCountry = 1;
    JetColumnDef.coltyp = JET_coltypBinary;
    JetColumnDef.grbit = JET_bitColumnNotNULL;

    if (_CatDBJET_errFailure(jerr  =
            JetAddColumn(
                pJetDBStruct->JetSesID,
                LocalJetHashCatNameTableID,
                SZ_HASH_CATNAME_TABLE_HASHCOL,
                &JetColumnDef,
                NULL,
                0,
                &(LocalJetHashCatNameTable_HashColumnID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // CatName column
    memset(&JetColumnDef, 0, sizeof(JetColumnDef));
    JetColumnDef.cbStruct = sizeof(JetColumnDef);
    JetColumnDef.cp = 1200; // unicode (1200) instead of Ascii (1252)
    JetColumnDef.langid = 0x409;
    JetColumnDef.wCountry = 1;
    JetColumnDef.coltyp = JET_coltypText;
    JetColumnDef.cbMax = 255;
    JetColumnDef.grbit = JET_bitColumnMultiValued | JET_bitColumnTagged;

    if (_CatDBJET_errFailure(jerr  =
            JetAddColumn(
                pJetDBStruct->JetSesID,
                LocalJetHashCatNameTableID,
                SZ_HASH_CATNAME_TABLE_CATNAMECOL,
                &JetColumnDef,
                NULL,
                0,
                &(LocalJetHashCatNameTable_CatNameColumnID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // Hash-CatName table index
    if (_CatDBJET_errFailure(jerr  =
            JetCreateIndex(
                pJetDBStruct->JetSesID,
                LocalJetHashCatNameTableID,
                SZ_HASH_CATNAME_TABLE_INDEX,
                JET_bitIndexPrimary,
                SZ_HASH_CATNAME_TABLE_INDEX_DEF,
                strlen(SZ_HASH_CATNAME_TABLE_INDEX_DEF) + 2,
                80)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Create the CatName-Buddy table, columns, and indexes
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCreateTable(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                4,
                100,
                &(LocalJetCatNameBuddyTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetCloseTable(
                pJetDBStruct->JetSesID,
                LocalJetCatNameBuddyTableID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetOpenTable(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                SZ_CATNAME_BUDDY_TABLE,
                NULL,
                0,
                0,
                &(LocalJetCatNameBuddyTableID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // CatName column
    memset(&JetColumnDef, 0, sizeof(JetColumnDef));
    JetColumnDef.cbStruct = sizeof(JetColumnDef);
    JetColumnDef.cp = 1200; // unicode (1200) instead of Ascii (1252)
    JetColumnDef.langid = 0x409;
    JetColumnDef.wCountry = 1;
    JetColumnDef.coltyp = JET_coltypText;
    JetColumnDef.cbMax = 255;
    JetColumnDef.grbit = JET_bitColumnNotNULL;

    if (_CatDBJET_errFailure(jerr  =
            JetAddColumn(
                pJetDBStruct->JetSesID,
                LocalJetCatNameBuddyTableID,
                SZ_CATNAME_BUDDY_TABLE_CATNAMECOL,
                &JetColumnDef,
                NULL,
                0,
                &(LocalJetCatNameBuddyTable_CatNameColumnID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // Buddy column
    memset(&JetColumnDef, 0, sizeof(JetColumnDef));
    JetColumnDef.cbStruct = sizeof(JetColumnDef);
    JetColumnDef.cp = 1200; // unicode (1200) instead of Ascii (1252)
    JetColumnDef.langid = 0x409;
    JetColumnDef.wCountry = 1;
    JetColumnDef.coltyp = JET_coltypText;
    JetColumnDef.cbMax = 255;
    JetColumnDef.grbit = JET_bitColumnMultiValued | JET_bitColumnTagged;

    if (_CatDBJET_errFailure(jerr  =
            JetAddColumn(
                pJetDBStruct->JetSesID,
                LocalJetCatNameBuddyTableID,
                SZ_CATNAME_BUDDY_TABLE_BUDDYCOL,
                &JetColumnDef,
                NULL,
                0,
                &(LocalJetCatNameBuddyTable_BuddyColumnID))))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    // CatName-Buddy table index
    if (_CatDBJET_errFailure(jerr  =
            JetCreateIndex(
                pJetDBStruct->JetSesID,
                LocalJetCatNameBuddyTableID,
                SZ_CATNAME_BUDDY_TABLE_INDEX,
                JET_bitIndexPrimary,
                SZ_CATNAME_BUDDY_TABLE_INDEX_DEF,
                strlen(SZ_CATNAME_BUDDY_TABLE_INDEX_DEF) + 2,
                80)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    //
    // Now that all the schema has been successfully added, COMMIT
    //
    if (_CatDBJET_errFailure(jerr  =
            JetCommitTransaction(
                pJetDBStruct->JetSesID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr  =
            JetCloseDatabase(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (fTransactionBegun)
    {
        JetRollback(pJetDBStruct->JetSesID, 0);
    }

    if (fDBFileOpen)
    {
        JetCloseDatabase(
                pJetDBStruct->JetSesID,
                LocalJetDBID,
                0);
    }

    if (fDBFileCreated)
    {
        DeleteFileA(pszDBFileName);
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBAttachAndOpenDatabase
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBAttachAndOpenDatabase(
    JET_DB_STRUCT   *pJetDBStruct,
    BOOL            fReadOnly)
{
    BOOL    fRet            = TRUE;
    JET_ERR jerr;
    BOOL    fJetDBFileOpen  = FALSE;
    DWORD   dwErr           = 0;

    //
    // Try to attach the existing database, if it doesn't already exist,
    // then create it
    //
    jerr = JetAttachDatabase(
                pJetDBStruct->JetSesID,
                pJetDBStruct->pszDBFileName,
                0); //fReadOnly ? JET_bitDbReadOnly : 0);

    if (jerr == JET_errFileNotFound)
    {
        //
        // The DB file doesn't exist yet, so create it
        //
        if (!_CatDBCreateDBFile(
                pJetDBStruct,
                pJetDBStruct->pszDBFileName))
        {
            CATDBSVC_LOGERR_LASTERR()
            goto ErrorReturn;
        }
    }
    else if (_CatDBJET_errFailure(jerr))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetOpenDatabase(
                pJetDBStruct->JetSesID,
                pJetDBStruct->pszDBFileName,
                NULL,
                &(pJetDBStruct->JetDBID),
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
    fJetDBFileOpen = TRUE;

    if (!_CatDBGetColumnIDs(pJetDBStruct))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Set the current indexes for both tables so all seeks work
    //
    if (_CatDBJET_errFailure(jerr =
            JetSetCurrentIndex(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID,
                NULL))) // NULL == primary index
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetSetCurrentIndex(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID,
                NULL))) // NULL == primary index
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }
CommonReturn:

    return fRet;

ErrorReturn:

    dwErr = GetLastError();

    if (fJetDBFileOpen)
    {
        JetCloseDatabase(pJetDBStruct->JetSesID, pJetDBStruct->JetDBID, 0);
    }

    SetLastError(dwErr);

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}



//---------------------------------------------------------------------------------------
//
//  _CatDBCloseDatabaseFile
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCloseDatabaseFile(
    PJET_DB_STRUCT  pJetDBStruct)
{
    BOOL    fRet = TRUE;
    JET_ERR jerr;

    if (_CatDBJET_errFailure(jerr =
            JetCloseTable(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetHashCatNameTableID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetCloseTable(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetCatNameBuddyTableID)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetCloseDatabase(
                pJetDBStruct->JetSesID,
                pJetDBStruct->JetDBID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

    if (_CatDBJET_errFailure(jerr =
            JetDetachDatabase(
                pJetDBStruct->JetSesID,
                pJetDBStruct->pszDBFileName)))
    {
        //
        // Only log the error it it isn't a JET_errDatabaseInUse error
        //
        if (jerr != JET_errDatabaseInUse)
        {
            CATDBSVC_LOGERR(_CatDBMapJetError(jerr))
        }
    }

    if (_CatDBJET_errFailure(jerr =
            JetEndSession(
                pJetDBStruct->JetSesID,
                0)))
    {
        CATDBSVC_SETERR_LOG_RETURN(_CatDBMapJetError(jerr), ErrorJetDatabase)
    }

CommonReturn:

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR_EX(DBG_SS_CATDBSVC, ErrorJetDatabase)
}


//---------------------------------------------------------------------------------------
//
//  _CatDBCatalogFileAlreadyInstalled
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBCatalogFileAlreadyInstalled(
    LPCWSTR pwszCatalogToBeAdded,
    LPCWSTR pwszExistingCatalog)
{
    BOOL    fRet            = TRUE;
    HANDLE  h1              = NULL;
    HANDLE  h2              = NULL;
    BYTE    rgbHash1[20];
    BYTE    rgbHash2[20];
    DWORD   cbHash1         = 20;
    DWORD   cbHash2         = 20;

    //
    // Open both files
    //

    h1 = CreateFileW(
                pwszCatalogToBeAdded,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL); // hTemplateFile

    if (h1 == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    h2 = CreateFileW(
                pwszExistingCatalog,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL); // hTemplateFile

    if (h1 == NULL)
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Get the hash for each file
    //

    if (!CryptCATAdminCalcHashFromFileHandle(
                h1,
                &cbHash1,
                rgbHash1,
                0))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    if (!CryptCATAdminCalcHashFromFileHandle(
                h2,
                &cbHash2,
                rgbHash2,
                0))
    {
        CATDBSVC_LOGERR_LASTERR()
        goto ErrorReturn;
    }

    //
    // Compare the hashes to see if they are the same
    //
    if (memcmp(rgbHash1, rgbHash2, 20) == 0)
    {
        fRet = TRUE;
    }

Return:

    if (h1 != NULL)
    {
        CloseHandle(h1);
    }

    if (h2 != NULL)
    {
        CloseHandle(h2);
    }

    return fRet;

ErrorReturn:

    fRet = FALSE;
    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  _CatDBJET_errFailure
//
//---------------------------------------------------------------------------------------
BOOL
_CatDBJET_errFailure(
    JET_ERR             jerr)
{
    if (jerr == JET_errSuccess)
    {
        return FALSE;
    }
    else if (jerr & 0x80000000)
    {
        //
        // Jet errors are negative numbers, jet warnings are positive
        //
        return TRUE;
    }
    else
    {
        CATDBSVC_LOGWARN(_CatDBMapJetError(jerr))
        return FALSE;
    }
}


//---------------------------------------------------------------------------------------
//
//  _CatDBMapJetError
//
//---------------------------------------------------------------------------------------
DWORD
_CatDBMapJetError(JET_ERR jerr)
{
    // FIX FIX
    return jerr;//ERROR_DATABASE_FAILURE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\crypstub\keysvr.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsecapi.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lmcons.h>
#include <certca.h>
#include "keysvc.h"
#include "cryptui.h"
#include "lenroll.h"
#include "keysvcc.h"

DWORD BindLocalKeyService(handle_t *hProxy);



// key service stub functions
ULONG       s_KeyrOpenKeyService(
/* [in]  */     handle_t                        hRPCBinding,
/* [in]  */     KEYSVC_TYPE                     OwnerType,
/* [in]  */     PKEYSVC_UNICODE_STRING          pOwnerName,
/* [in]  */     ULONG                           ulDesiredAccess,
/* [in]  */     PKEYSVC_BLOB                    pAuthentication,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [out] */     KEYSVC_HANDLE                   *phKeySvc)
{
    RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrOpenKeyService(
                                        hProxy,
                                        OwnerType,
                                        pOwnerName,
                                        ulDesiredAccess,
                                        pAuthentication,
                                        ppReserved,
                                        phKeySvc);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;

}

ULONG       s_KeyrEnumerateProviders(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcProviderCount,
/* [in, out][size_is(,*pcProviderCount)] */
                PKEYSVC_PROVIDER_INFO           *ppProviders)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnumerateProviders(
                                                hProxy,
                                                hKeySvc,
                                                ppReserved,
                                                pcProviderCount,
                                                ppProviders);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG       s_KeyrEnumerateProviderTypes(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcProviderCount,
/* [in, out][size_is(,*pcProviderCount)] */
                PKEYSVC_PROVIDER_INFO           *ppProviders)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {

        RpcStatus = s_KeyrEnumerateProviderTypes(
                                                hProxy,
                                                hKeySvc,
                                                ppReserved,
                                                pcProviderCount,
                                                ppProviders);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}


ULONG       s_KeyrEnumerateProvContainers(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      KEYSVC_PROVIDER_INFO            Provider,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcContainerCount,
/* [in, out][size_is(,*pcContainerCount)] */
                PKEYSVC_UNICODE_STRING          *ppContainers)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnumerateProvContainers(
                                                hProxy,
                                                hKeySvc,
                                                Provider,
                                                ppReserved,
                                                pcContainerCount,
                                                ppContainers);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}


ULONG       s_KeyrCloseKeyService(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrCloseKeyService(
                                            hProxy,
                                            hKeySvc,
                                            ppReserved);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG       s_KeyrGetDefaultProvider(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      ULONG                           ulProvType,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [out] */     ULONG                           *pulDefType,
/* [out] */     PKEYSVC_PROVIDER_INFO           *ppProvider)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrGetDefaultProvider(
                                        hProxy,
                                        hKeySvc,
                                        ulProvType,
                                        ulFlags,
                                        ppReserved,
                                        pulDefType,
                                        ppProvider);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG       s_KeyrSetDefaultProvider(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in] */      KEYSVC_PROVIDER_INFO            Provider)
{
    RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {

        RpcStatus = s_KeyrSetDefaultProvider(
                                            hProxy,
                                            hKeySvc,
                                            ulFlags,
                                            ppReserved,
                                            Provider);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG s_KeyrEnroll(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      BOOL                            fKeyService,
/* [in] */      ULONG                           ulPurpose,
/* [in] */      PKEYSVC_UNICODE_STRING          pAcctName,
/* [in] */      PKEYSVC_UNICODE_STRING          pCALocation,
/* [in] */      PKEYSVC_UNICODE_STRING          pCAName,
/* [in] */      BOOL                            fNewKey,
/* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW    pKeyNew,
/* [in] */      PKEYSVC_BLOB __RPC_FAR          pCert,
/* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW    pRenewKey,
/* [in] */      PKEYSVC_UNICODE_STRING          pHashAlg,
/* [in] */      PKEYSVC_UNICODE_STRING          pDesStore,
/* [in] */      ULONG                           ulStoreFlags,
/* [in] */      PKEYSVC_CERT_ENROLL_INFO        pRequestInfo,
/* [in] */      ULONG                           ulFlags,
/* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppReserved,
/* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppPKCS7Blob,
/* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppHashBlob,
/* [out] */     ULONG __RPC_FAR                 *pulStatus)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnroll(
                                hProxy,
                                fKeyService,
                                ulPurpose,
                                pAcctName,
                                pCALocation,
                                pCAName,
                                fNewKey,
                                pKeyNew,
                                pCert,
                                pRenewKey,
                                pHashAlg,
                                pDesStore,
                                ulStoreFlags,
                                pRequestInfo,
                                ulFlags,
                                ppReserved,
                                ppPKCS7Blob,
                                ppHashBlob,
                                pulStatus);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}


ULONG s_KeyrExportCert(
/* [in] */      handle_t hRPCBinding,
/* [in] */      KEYSVC_HANDLE hKeySvc,
/* [in] */      PKEYSVC_UNICODE_STRING pPassword,
/* [in] */      PKEYSVC_UNICODE_STRING pCertStore,
/* [in] */      ULONG cHashCount,
/* [size_is][in] */
                KEYSVC_CERT_HASH *pHashes,
/* [in] */      ULONG ulFlags,
/* [in, out] */ PKEYSVC_BLOB *ppReserved,
/* [out] */     PKEYSVC_BLOB *ppPFXBlob)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {


        RpcStatus = s_KeyrExportCert(
                                    hProxy,
                                    hKeySvc,
                                    pPassword,
                                    pCertStore,
                                    cHashCount,
                                    pHashes,
                                    ulFlags,
                                    ppReserved,
                                    ppPFXBlob);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}


ULONG       s_KeyrImportCert(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in] */      PKEYSVC_UNICODE_STRING          pPassword,
/* [in] */      KEYSVC_UNICODE_STRING           *pCertStore,
/* [in] */      PKEYSVC_BLOB                    pPFXBlob,
/* [in] */      ULONG                           ulFlags,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved)
{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrImportCert(
                                    hProxy,
                                    hKeySvc,
                                    pPassword,
                                    pCertStore,
                                    pPFXBlob,
                                    ulFlags,
                                    ppReserved);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG s_KeyrEnumerateAvailableCertTypes(

    /* [in] */      handle_t                        hRPCBinding,
    /* [in] */      KEYSVC_HANDLE                   hKeySvc,
    /* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
    /* [out][in] */ ULONG *pcCertTypeCount,
    /* [in, out][size_is(,*pcCertTypeCount)] */
                     PKEYSVC_UNICODE_STRING *ppCertTypes)

{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnumerateAvailableCertTypes(
                                                        hProxy,
                                                        hKeySvc,
                                                        ppReserved,
                                                        pcCertTypeCount,
                                                        ppCertTypes);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}




ULONG s_KeyrEnumerateCAs(

    /* [in] */      handle_t                        hRPCBinding,
    /* [in] */      KEYSVC_HANDLE                   hKeySvc,
    /* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
    /* [in] */      ULONG                           ulFlags,
    /* [out][in] */ ULONG                           *pcCACount,
    /* [in, out][size_is(,*pcCACount)] */
               PKEYSVC_UNICODE_STRING               *ppCAs)

{
        RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrEnumerateCAs(
                                hProxy,
                                hKeySvc,
                                ppReserved,
                                ulFlags,
                                pcCACount,
                                ppCAs);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}


DWORD BindLocalKeyService(handle_t *hProxy)
{

    WCHAR *pStringBinding = NULL;
    *hProxy = NULL;

    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcStringBindingComposeW(
                          NULL,
                          KEYSVC_LOCAL_PROT_SEQ,
                          NULL,
                          KEYSVC_LOCAL_ENDPOINT,
                          NULL,
                          &pStringBinding);
    if (RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                                pStringBinding,
                                hProxy);

    if (RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    RpcStatus = RpcEpResolveBinding(
                        *hProxy,
                        IKeySvc_v1_0_c_ifspec);
    if (RPC_S_OK != RpcStatus)
    {
        if(*hProxy)
        {
            RpcBindingFree(hProxy);
            *hProxy = NULL;
        }
        goto error;

    }

error:
    if (NULL != pStringBinding)
    {
        RpcStringFreeW(&pStringBinding);
    }
    return RpcStatus;
}

ULONG s_KeyrEnroll_V2
 (/* [in] */      handle_t                        hRPCBinding,
 /* [in] */      BOOL                            fKeyService,
 /* [in] */      ULONG                           ulPurpose,
 /* [in] */      ULONG                           ulFlags,
 /* [in] */      PKEYSVC_UNICODE_STRING          pAcctName,
 /* [in] */      PKEYSVC_UNICODE_STRING          pCALocation,
 /* [in] */      PKEYSVC_UNICODE_STRING          pCAName,
 /* [in] */      BOOL                            fNewKey,
 /* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW_V2 pKeyNew,
 /* [in] */      PKEYSVC_BLOB __RPC_FAR          pCert,
 /* [in] */      PKEYSVC_CERT_REQUEST_PVK_NEW_V2 pRenewKey,
 /* [in] */      PKEYSVC_UNICODE_STRING          pHashAlg,
 /* [in] */      PKEYSVC_UNICODE_STRING          pDesStore,
 /* [in] */      ULONG                           ulStoreFlags,
 /* [in] */      PKEYSVC_CERT_ENROLL_INFO        pRequestInfo,
 /* [in] */      ULONG                           ulReservedFlags,
 /* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppReserved,
 /* [out][in] */ PKEYSVC_BLOB __RPC_FAR          *ppRequest,
 /* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppPKCS7Blob,
 /* [out] */     PKEYSVC_BLOB __RPC_FAR          *ppHashBlob,
 /* [out] */     ULONG __RPC_FAR                 *pulStatus)
 {
     RPC_BINDING_HANDLE hProxy = NULL;


     RPC_STATUS RpcStatus = RPC_S_OK;

     RpcStatus = RpcImpersonateClient(hRPCBinding);

     if (RPC_S_OK != RpcStatus)
     {
         return RpcStatus;
     }
     RpcStatus = BindLocalKeyService(&hProxy);
     if(RPC_S_OK != RpcStatus)
     {
         goto error;
     }

     __try
     {
         RpcStatus = s_KeyrEnroll_V2(
                                 hProxy,
                                 fKeyService,
                                 ulPurpose,
                                 ulFlags,
                                 pAcctName,
                                 pCALocation,
                                 pCAName,
                                 fNewKey,
                                 pKeyNew,
                                 pCert,
                                 pRenewKey,
                                 pHashAlg,
                                 pDesStore,
                                 ulStoreFlags,
                                 pRequestInfo,
                                 ulReservedFlags,
                                 ppReserved,
                                 ppRequest,
                                 ppPKCS7Blob,
                                 ppHashBlob,
                                 pulStatus);

     }
     __except ( EXCEPTION_EXECUTE_HANDLER )
     {
         RpcStatus = _exception_code();
     }
 error:

     if(hProxy)
     {
         RpcBindingFree(&hProxy);
     }

     RpcRevertToSelf();

     return RpcStatus;
 }

ULONG s_KeyrQueryRequestStatus
(/* [in] */        handle_t                         hRPCBinding, 
 /* [in] */        unsigned __int64                 u64Request, 
 /* [out, ref] */  KEYSVC_QUERY_CERT_REQUEST_INFO  *pQueryInfo)
{
    RPC_BINDING_HANDLE hProxy = NULL;


    RPC_STATUS RpcStatus = RPC_S_OK;

    RpcStatus = RpcImpersonateClient(hRPCBinding);

    if (RPC_S_OK != RpcStatus)
    {
        return RpcStatus;
    }
    RpcStatus = BindLocalKeyService(&hProxy);
    if(RPC_S_OK != RpcStatus)
    {
        goto error;
    }

    __try
    {
        RpcStatus = s_KeyrQueryRequestStatus(
                                hProxy,
                                u64Request, 
                                pQueryInfo); 
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        RpcStatus = _exception_code();
    }
error:

    if(hProxy)
    {
        RpcBindingFree(&hProxy);
    }

    RpcRevertToSelf();

    return RpcStatus;
}

ULONG s_RKeyrPFXInstall
(/* [in] */        handle_t                        hRPCBinding,
 /* [in] */        PKEYSVC_BLOB                    pPFX,
 /* [in] */        PKEYSVC_UNICODE_STRING          pPassword,
 /* [in] */        ULONG                           ulFlags)
 {
     RPC_BINDING_HANDLE hProxy = NULL;


     RPC_STATUS RpcStatus = RPC_S_OK;

     RpcStatus = RpcImpersonateClient(hRPCBinding);

     if (RPC_S_OK != RpcStatus)
     {
         return RpcStatus;
     }
     RpcStatus = BindLocalKeyService(&hProxy);
     if(RPC_S_OK != RpcStatus)
     {
         goto error;
     }

     __try
     {
         RpcStatus = s_RKeyrPFXInstall(
                                 hProxy,
                                 pPFX,
                                 pPassword,
                                 ulFlags);

     }
     __except ( EXCEPTION_EXECUTE_HANDLER )
     {
         RpcStatus = _exception_code();
     }
 error:

     if(hProxy)
     {
         RpcBindingFree(&hProxy);
     }

     RpcRevertToSelf();

     return RpcStatus;
 }


ULONG       s_RKeyrOpenKeyService(
/* [in]  */     handle_t                       hRPCBinding,
/* [in]  */     KEYSVC_TYPE                    OwnerType,
/* [in]  */     PKEYSVC_UNICODE_STRING         pOwnerName,
/* [in]  */     ULONG                          ulDesiredAccess,
/* [in]  */     PKEYSVC_BLOB                   pAuthentication,
/* [in, out] */ PKEYSVC_BLOB                  *ppReserved,
/* [out] */     KEYSVC_HANDLE                 *phKeySvc)
{
    return s_KeyrOpenKeyService
        (hRPCBinding,
         OwnerType,
         pOwnerName,
         ulDesiredAccess,
         pAuthentication,
         ppReserved,
         phKeySvc);
}

ULONG       s_RKeyrCloseKeyService(
/* [in] */      handle_t         hRPCBinding,
/* [in] */      KEYSVC_HANDLE    hKeySvc,
/* [in, out] */ PKEYSVC_BLOB    *ppReserved)
{
    return s_KeyrCloseKeyService
        (hRPCBinding,
         hKeySvc,
         ppReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\certprot.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    certprot.cpp

Abstract:

    This module contains routines associated with server side 
    I_CertProtectFunctions operations.

Author:

    Phil Hallin (philh)     19-Nov-97

--*/

#include <windows.h>
#include <wincrypt.h>

#include "cerrpc.h" // header file generated by MIDL compiler
#include "certprot.h"



///////////////////////////////////////////////////////////////////////
// LPC-exposed functions

//
// these functions return a DWORD equivalent to GetLastError().
// the client side stub code will check if the return code is not
// ERROR_SUCCESS, and if this is the case, the client stub will return
// FALSE and SetLastError() to this DWORD.
//

DWORD s_SSCertProtectFunction( 
    /* [in] */ handle_t h,
    /* [in] */ DWORD dwFuncId,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwszIn,
    /* [size_is][in] */ BYTE __RPC_FAR *pbIn,
    /* [in] */ DWORD cbIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbOut,
    /* [out] */ DWORD __RPC_FAR *pcbOut)
{
    DWORD dwRet;

    __try {

        {
            HINSTANCE hCrypt32Dll;
            PFN_CERT_SRV_PROTECT_FUNCTION pfnCertSrvProtectFunction;

            *ppbOut = NULL;
            *pcbOut = 0;
            hCrypt32Dll = LoadLibraryW(L"crypt32.dll");
            if (hCrypt32Dll == NULL) {
                dwRet = GetLastError();
                goto Ret;
            }

            if (NULL == (pfnCertSrvProtectFunction =
                    (PFN_CERT_SRV_PROTECT_FUNCTION) GetProcAddress(
                        hCrypt32Dll, "I_CertSrvProtectFunction")))
                dwRet = ERROR_PROC_NOT_FOUND;
            else
                dwRet = pfnCertSrvProtectFunction(
                    h,
                    dwFuncId,
                    dwFlags,
                    pwszIn,
                    pbIn,
                    cbIn,
                    ppbOut,
                    pcbOut,
                    midl_user_allocate,
                    midl_user_free
                    );
            FreeLibrary(hCrypt32Dll);
            goto Ret;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwRet = GetExceptionCode();
        // TODO: for NT, convert exception code to winerror.
        //       for 95, just override to access violation.
    }

Ret:
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\dbutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbutils.h
//
//  Contents:   utilities header
//
//  History:    07-Feb-00    reidk    Created
//
//----------------------------------------------------------------------------

#if !defined(__CATDBUTILS_H__)
#define __CATDBUTILS_H__

LPSTR _CatDBConvertWszToSz(LPCWSTR pwsz);

LPWSTR _CATDBAllocAndCopyWSTR(LPCWSTR pwsz);

LPWSTR _CATDBAllocAndCopyWSTR2(LPCWSTR  pwsz1, LPCWSTR pwsz2);

BOOL _CATDBStrCatWSTR(LPWSTR *ppwszAddTo, LPCWSTR pwszAdd);

BOOL _CATDBStrCat(LPSTR *ppszAddTo, LPCSTR pszAdd);

LPWSTR _CATDBConstructWSTRPath(LPCWSTR pwsz1, LPCWSTR pwsz2);

LPSTR _CATDBConstructPath(LPCSTR psz1, LPCSTR psz2);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\keysvr.h ===
#ifndef _KEYSVR_H_
#define _KEYSVR_H_


#ifdef __cplusplus
extern "C" {
#endif

typedef struct __KEYSVC_CONTEXT__ {
    DWORD       dwType;
    LONG        iRefCount;
    DWORD       dwAccess;
    HANDLE      hProfile;
    LPWSTR      pszServiceName;
    HANDLE      hLogonToken;
} KEYSVC_CONTEXT, *PKEYSVC_CONTEXT;


// provider information
typedef struct _TMP_LIST_INFO_ {
    void *pInfo;
    struct _TMP_LIST_INFO_ *pNext;
} TMP_LIST_INFO, *PTMP_LIST_INFO;



DWORD
StartKeyService(
    VOID
    );

DWORD
StopKeyService(
    VOID
    );



#ifdef __cplusplus
}
#endif

#endif // _KEYSVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\service.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: service.h
//
//  AUTHOR: Craig Link
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and 
//  implement the ServiceStart() and ServiceStop() functions.
//  
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            L"cryptsvc"
// internal name of the service
#define SZSERVICENAME        L"CryptSvc"
// displayed name of the service
#define SZSERVICEDISPLAYNAME L"Cryptographic Services"
#define SZSERVICEDISPLAYNAMEA "Cryptographic Services"
// list of service dependencies - "dep1\0dep2\0\0"
// RPC must be running for us to work!
#define SZDEPENDENCIES       L"RpcSs\0" // doubly null terminated
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
DWORD ServiceStart (HINSTANCE hInstance, int nCmdShow);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPWSTR lpszMsg);
//////////////////////////////////////////////////////////////////////////////

void StopRPCServer();


// entry point to start the service from install stub.

DWORD WINAPI Start( LPVOID lpV );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\forwardr\mscat32\mscat32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mscat32.cpp
//
//--------------------------------------------------------------------------

#ifdef _M_IX86

#include <windows.h>
#include <wincrypt.h>
#include <mscat.h>

STDAPI mscat32DllRegisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllRegisterServer()
{
    __asm {
        jmp mscat32DllRegisterServer
    }
}

STDAPI mscat32DllUnregisterServer(void);
EXTERN_C
__declspec(naked)
HRESULT
STDAPICALLTYPE
DllUnregisterServer()
{
    __asm {
        jmp mscat32DllUnregisterServer
    }
}


EXTERN_C
__declspec(naked)
HANDLE WINAPI ForwardrCryptCATOpen(IN          LPWSTR pwszFileName,
                                  IN          DWORD fdwOpenFlags,
                                  IN OPTIONAL HCRYPTPROV hProv,
                                  IN OPTIONAL DWORD dwPublicVersion,
                                  IN OPTIONAL DWORD dwEncodingType)
{
    __asm {
        jmp CryptCATOpen
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATClose(IN HANDLE hCatalog)
{
    __asm {
        jmp CryptCATClose
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATSTORE * WINAPI ForwardrCryptCATStoreFromHandle(IN HANDLE hCatalog)
{
    __asm {
        jmp CryptCATStoreFromHandle
    }
}

EXTERN_C
__declspec(naked)
HANDLE WINAPI ForwardrCryptCATHandleFromStore(IN CRYPTCATSTORE *pCatStore)
{
    __asm {
        jmp CryptCATHandleFromStore
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATPersistStore(IN HANDLE hCatalog)
{
    __asm {
        jmp CryptCATPersistStore
    }
}


EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATGetCatAttrInfo(IN HANDLE hCatalog,
                                                         IN LPWSTR pwszReferenceTag)
{
    __asm {
        jmp CryptCATGetCatAttrInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATPutCatAttrInfo(IN HANDLE hCatalog,
                                                         IN LPWSTR pwszReferenceTag,
                                                         IN DWORD dwAttrTypeAndAction,
                                                         IN DWORD cbData,
                                                         IN BYTE *pbData)
{
    __asm {
        jmp CryptCATPutCatAttrInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATEnumerateCatAttr(IN HANDLE hCatalog,
                                                           IN CRYPTCATATTRIBUTE *pPrevAttr)
{
    __asm {
        jmp CryptCATEnumerateCatAttr
    }
}


EXTERN_C
__declspec(naked)
CRYPTCATMEMBER * WINAPI ForwardrCryptCATGetMemberInfo(IN HANDLE hCatalog,
                                                     IN LPWSTR pwszReferenceTag)
{
    __asm {
        jmp CryptCATGetMemberInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATMEMBER * WINAPI ForwardrCryptCATPutMemberInfo(IN HANDLE hCatalog,
                                                     IN OPTIONAL LPWSTR pwszFileName,
                                                     IN          LPWSTR pwszReferenceTag,
                                                     IN          GUID *pgSubjectType,
                                                     IN          DWORD dwCertVersion,
                                                     IN          DWORD cbSIPIndirectData,
                                                     IN          BYTE *pbSIPIndirectData)
{
    __asm {
        jmp CryptCATPutMemberInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATMEMBER * WINAPI ForwardrCryptCATEnumerateMember(IN HANDLE hCatalog,
                                                       IN CRYPTCATMEMBER *pPrevMember)
{
    __asm {
        jmp CryptCATEnumerateMember
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATGetAttrInfo(IN HANDLE hCatalog,
                                                      IN CRYPTCATMEMBER *pCatMember,
                                                      IN LPWSTR pwszReferenceTag)
{
    __asm {
        jmp CryptCATGetAttrInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATPutAttrInfo(IN HANDLE hCatalog,
                                                      IN CRYPTCATMEMBER *pCatMember,
                                                      IN LPWSTR pwszReferenceTag,
                                                      IN DWORD dwAttrTypeAndAction,
                                                      IN DWORD cbData,
                                                      IN BYTE *pbData)
{
    __asm {
        jmp CryptCATPutAttrInfo
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATEnumerateAttr(IN HANDLE hCatalog,
                                                        IN CRYPTCATMEMBER *pCatMember,
                                                        IN CRYPTCATATTRIBUTE *pPrevAttr)
{
    __asm {
        jmp CryptCATEnumerateAttr
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATAdminReleaseCatalogContext(IN HCATADMIN hCatAdmin,
                                                      IN HCATINFO hCatInfo,
                                                      IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminReleaseCatalogContext
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATCDF * WINAPI ForwardrCryptCATCDFOpen(IN LPWSTR pwszFilePath,
                                            IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFOpen
    }
}


EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATCDFClose(IN CRYPTCATCDF *pCDF)
{
    __asm {
        jmp CryptCATCDFClose
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATCDFEnumCatAttributes(CRYPTCATCDF *pCDF,
                                                               CRYPTCATATTRIBUTE *pPrevAttr,
                                                                PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFEnumCatAttributes
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATMEMBER * WINAPI ForwardrCryptCATCDFEnumMembers(IN          CRYPTCATCDF *pCDF,
                                                      IN          CRYPTCATMEMBER *pPrevMember,
                                                      IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFEnumMembers
    }
}

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE *WINAPI ForwardrCryptCATCDFEnumAttributes(IN          CRYPTCATCDF *pCDF,
                                                           IN          CRYPTCATMEMBER *pMember,
                                                           IN          CRYPTCATATTRIBUTE *pPrevAttr,
                                                           IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFEnumAttributes
    }
}



EXTERN_C
__declspec(naked)
BOOL WINAPI      ForwardrCryptCATAdminAcquireContext(OUT HCATADMIN *phCatAdmin,
                                                    IN const GUID *pgSubsystem,
                                                    IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminAcquireContext
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI      ForwardrCryptCATAdminReleaseContext(IN HCATADMIN hCatAdmin,
                                                    IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminReleaseContext
    }
}

EXTERN_C
__declspec(naked)
HCATINFO WINAPI ForwardrCryptCATAdminEnumCatalogFromHash(IN HCATADMIN hCatAdmin,
                                                        IN BYTE *pbHash,
                                                        IN DWORD cbHash,
                                                        IN DWORD dwFlags,
                                                        IN OUT HCATINFO *phPrevCatInfo)
{
    __asm {
        jmp CryptCATAdminEnumCatalogFromHash
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATAdminCalcHashFromFileHandle(IN HANDLE hFile,
                                                       IN OUT DWORD *pcbHash,
                                                       OUT OPTIONAL BYTE *pbHash,
                                                       IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminCalcHashFromFileHandle
    }
}

EXTERN_C
__declspec(naked)
BOOL WINAPI ForwardrCryptCATCatalogInfoFromContext(IN HCATINFO hCatInfo,
                                                  IN OUT CATALOG_INFO *psCatInfo,
                                                  IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATCatalogInfoFromContext
    }
}

EXTERN_C
__declspec(naked)
HCATINFO WINAPI ForwardrCryptCATAdminAddCatalog(IN HCATADMIN hCatAdmin,
                                               IN WCHAR *pwszCatalogFile,
                                               IN OPTIONAL WCHAR *pwszSelectBaseName,
                                               IN DWORD dwFlags)
{
    __asm {
        jmp CryptCATAdminAddCatalog
    }
}


EXTERN_C
__declspec(naked)
BOOL WINAPI      ForwardrIsCatalogFile(IN OPTIONAL HANDLE hFile,
                                      IN OPTIONAL WCHAR *pwszFileName)
{
    __asm {
        jmp IsCatalogFile
    }
}

EXTERN_C
BOOL WINAPI
CatalogCompactHashDatabase (
       IN LPCWSTR pwszDbLock,
       IN LPCWSTR pwszDbDirectory,
       IN LPCWSTR pwszDbName,
       IN OPTIONAL LPCWSTR pwszUnwantedCatalog
       );

EXTERN_C
__declspec(naked)
void
ForwardrCatalogCompactHashDatabase (
       IN LPCWSTR pwszDbLock,
       IN LPCWSTR pwszDbDirectory,
       IN LPCWSTR pwszDbName,
       IN OPTIONAL LPCWSTR pwszUnwantedCatalog
       )
{
    __asm {
        jmp CatalogCompactHashDatabase
    }
}



EXTERN_C
LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember);

EXTERN_C
__declspec(naked)
LPWSTR WINAPI ForwardrCryptCATCDFEnumMembersByCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember)
{
    __asm {
        jmp CryptCATCDFEnumMembersByCDFTag
    }
}

EXTERN_C
LPWSTR WINAPI CryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved);

EXTERN_C
__declspec(naked)
LPWSTR WINAPI ForwardrCryptCATCDFEnumMembersByCDFTagEx(CRYPTCATCDF *pCDF, LPWSTR pwszPrevCDFTag,
                                       PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError,
                                       CRYPTCATMEMBER** ppMember, BOOL fContinueOnError,
                                       LPVOID pvReserved)
{
    __asm {
        jmp CryptCATCDFEnumMembersByCDFTagEx
    }
}

EXTERN_C
CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

EXTERN_C
__declspec(naked)
CRYPTCATATTRIBUTE * WINAPI ForwardrCryptCATCDFEnumAttributesWithCDFTag(CRYPTCATCDF *pCDF, LPWSTR pwszMemberTag, CRYPTCATMEMBER *pMember,
                                             CRYPTCATATTRIBUTE *pPrevAttr,
                                             PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError)
{
    __asm {
        jmp CryptCATCDFEnumAttributesWithCDFTag
    }
}


EXTERN_C
BOOL MsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag);

EXTERN_C
__declspec(naked)
BOOL ForwardrMsCatConstructHashTag (IN DWORD cbDigest, IN LPBYTE pbDigest, OUT LPWSTR* ppwszHashTag)
{
    __asm {
        jmp MsCatConstructHashTag
    }
}

EXTERN_C
VOID MsCatFreeHashTag (IN LPWSTR pwszHashTag);
EXTERN_C
__declspec(naked)
VOID ForwardrMsCatFreeHashTag (IN LPWSTR pwszHashTag)
{
    __asm {
        jmp MsCatFreeHashTag
    }
}


BOOL WINAPI CryptCATVerifyMember(HANDLE hCatalog,
                                 CRYPTCATMEMBER *pCatMember,
                                 HANDLE hFileOrMemory);

__declspec(naked)
BOOL WINAPI ForwardrCryptCATVerifyMember(HANDLE hCatalog,
                                 CRYPTCATMEMBER *pCatMember,
                                 HANDLE hFileOrMemory)
{
    __asm {
        jmp CryptCATVerifyMember
    }
}
#else

static void Dummy()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\service.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            and takes into account dumbed-down win95 services
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    CryptServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);
//    WinNTDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//  MODIFIED: Matt Thomlinson
//            Scott Field
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <svcs.h>       // SVCS_
#include <wincrypt.h>
#include <cryptui.h>
#include "keysvr.h"
#include "lenroll.h"
#include "keysvc.h"
#include "keysvcc.h"
#include "cerrpc.h"
#include "service.h"
#include "unicode.h"
#include "unicode5.h"
#include "catdb.h"


#define CRYPTSVC_EVENT_STOP "CRYPTSVC_EVENT_STOP"


#define RTN_OK                  0   // no errors
#define RTN_USAGE               1   // usage error (invalid commandline)
#define RTN_ERROR_INIT          2   // error during service initialization
#define RTN_ERROR_INSTALL       13  // error during -install or -remove
#define RTN_ERROR_INSTALL_SIG   14  // error installing signature(s)
#define RTN_ERROR_INSTALL_START 15  // could not start service during install
#define RTN_ERROR_INSTALL_SHEXT 16  // error installing shell extension

//
// global module handle used to reference resources contained in this module.
//

HINSTANCE   g_hInst = NULL;


// internal variables
static SERVICE_STATUS   ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;


// internal function prototypes
void WINAPI service_ctrl(DWORD dwCtrlCode);
void WINAPI CryptServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);

extern BOOL _CatDBServiceInit(BOOL fUnInit);


//
// forward declaration for security callbacks
//
RPC_IF_CALLBACK_FN CryptSvcSecurityCallback;

long __stdcall
CryptSvcSecurityCallback(void * Interface, void *Context)
{
    RPC_STATUS          Status;
    unsigned int        RpcClientLocalFlag;

    Status = I_RpcBindingIsClientLocal(NULL, &RpcClientLocalFlag);
    if (Status != RPC_S_OK) 
    {
        return (RPC_S_ACCESS_DENIED);
    }

    if (RpcClientLocalFlag == 0) 
    {
        return (RPC_S_ACCESS_DENIED);
    }

    return (RPC_S_OK);
}

BOOL
WINAPI
DllMain(
    HMODULE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    if( dwReason == DLL_PROCESS_ATTACH ) {
        g_hInst = hInst;
        DisableThreadLibraryCalls(hInst);
    }

    return TRUE;
}


DWORD
WINAPI
Start(
    LPVOID lpV
    )
{
    BOOL fIsNT = FIsWinNT();
    int iRet;


    //
    // surpress dialog boxes generated by missing files, etc.
    //

    SetErrorMode(SEM_NOOPENFILEERRORBOX);

    SERVICE_TABLE_ENTRYW dispatchTable[] =
    {
        { SZSERVICENAME, (LPSERVICE_MAIN_FUNCTIONW)CryptServiceMain },
        { NULL, NULL }
    };

#ifdef WIN95_LEGACY

    if (!fIsNT)
        goto dispatch95;

#endif  // WIN95_LEGACY

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher

    if(!FIsWinNT5()) {
        if (!StartServiceCtrlDispatcherW(dispatchTable))
            AddToMessageLog(L"StartServiceCtrlDispatcher failed.");
    } else {
        CryptServiceMain( 0, NULL );
    }

    return RTN_OK;

#ifdef WIN95_LEGACY

dispatch95:


    //
    // Win95 doesn't support services, except as pseudo-.exe files
    //

    HMODULE hKernel = GetModuleHandleA("kernel32.dll");
    if (NULL == hKernel)
    {
        AddToMessageLog(L"RegisterServiceProcess module handle failed");
        return RTN_ERROR_INIT;
    }

    // inline typedef: COOL!
    typedef DWORD REGISTERSERVICEPROCESS(
        DWORD dwProcessId,
        DWORD dwServiceType);

    REGISTERSERVICEPROCESS* pfnRegSvcProc = NULL;

    // Make sure Win95 Logoff won't stop our .exe
    if (NULL == (pfnRegSvcProc = (REGISTERSERVICEPROCESS*)GetProcAddress(hKernel, "RegisterServiceProcess")))
    {
        AddToMessageLog(L"RegisterServiceProcess failed");
        return RTN_ERROR_INIT;
    }

    pfnRegSvcProc(GetCurrentProcessId(), TRUE);  // register this process ID as a service process

    //
    // call re-entry point and return with result of it.
    //

    iRet = ServiceStart(0, 0);

    if(iRet != ERROR_SUCCESS)
        AddToMessageLog(L"ServiceStart error!");

    return iRet;

#endif  // WIN95_LEGACY

}

//
//  FUNCTION: CryptServiceMain
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI CryptServiceMain(DWORD dwArgc, LPWSTR * /*lpszArgv*/)
{
    DWORD dwLastError = ERROR_SUCCESS;

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandlerW( SZSERVICENAME, service_ctrl);

    if (!sshStatusHandle)
        return;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //

    if (!ReportStatusToSCMgr(
                    SERVICE_START_PENDING, // service state
                    NO_ERROR,              // exit code
                    3000                   // wait hint
                    )) return ;

    dwLastError = ServiceStart(0, 0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:

            //
            // tell the SCM we are stopping before triggering StopService() code
            // to avoid potential race condition during STOP_PENDING -> STOPPED transition
            //

            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
            ServiceStop();
            return;

        case SERVICE_CONTROL_SHUTDOWN:
            ServiceStop();
            return;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if (dwCurrentState == SERVICE_START_PENDING)
        ssStatus.dwControlsAccepted = 0;
    else
        ssStatus.dwControlsAccepted =   SERVICE_ACCEPT_STOP | 
                                        SERVICE_ACCEPT_SHUTDOWN;

    ssStatus.dwCurrentState = dwCurrentState;
    if(dwWin32ExitCode == 0) {
        ssStatus.dwWin32ExitCode = 0;
    } else {
        ssStatus.dwServiceSpecificExitCode = dwWin32ExitCode;
        ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    }

    ssStatus.dwWaitHint = dwWaitHint;

    if ( ( dwCurrentState == SERVICE_RUNNING ) ||
         ( dwCurrentState == SERVICE_STOPPED ) )
        ssStatus.dwCheckPoint = 0;
    else
        ssStatus.dwCheckPoint = dwCheckPoint++;


    // Report the status of the service to the service control manager.
    //
    if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
        AddToMessageLog(L"SetServiceStatus");
    }

    return fResult;
}



//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPWSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();

    if(FIsWinNT()) {

        //
        // WinNT: Use event logging to log the error.
        //

        WCHAR   szMsg[512];
        HANDLE  hEventSource;
        LPWSTR  lpszStrings[2];

        hEventSource = RegisterEventSourceW(NULL, SZSERVICENAME);

        if(hEventSource == NULL)
            return;

        wsprintfW(szMsg, L"%s error: %lu", SZSERVICENAME, dwLastError);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        ReportEventW(hEventSource, // handle of event source
            EVENTLOG_ERROR_TYPE,  // event type
            0,                    // event category
            0,                    // event ID
            NULL,                 // current user's SID
            2,                    // strings in lpszStrings
            0,                    // no bytes of raw data
            (LPCWSTR*)lpszStrings,          // array of error strings
            NULL);                // no raw data

        (VOID) DeregisterEventSource(hEventSource);

    }
#ifdef WIN95_LEGACY
    else {

        //
        // Win95: log error to file
        //

        HANDLE hFile;
        SYSTEMTIME st;
        CHAR szMsgOut[512];
        DWORD cchMsgOut;
        DWORD dwBytesWritten;

        hFile = CreateFileA(
            "pstore.log",
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            0,
            NULL
            );

        if(hFile == INVALID_HANDLE_VALUE)
            return;

        GetSystemTime( &st );

        cchMsgOut = wsprintfA(szMsgOut, "%.2u-%.2u-%.2u %.2u:%.2u:%.2u %ls (rc=%lu)\015\012",
            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond,
            lpszMsg,
            dwLastError
            );

        //
        // seek to EOF
        //

        SetFilePointer(hFile, 0, NULL, FILE_END);

        WriteFile(hFile, szMsgOut, cchMsgOut, &dwBytesWritten, NULL);
        CloseHandle(hFile);
    }
#endif  // WIN95_LEGACY

}

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;




extern DWORD GlobalSecurityMask;
extern BOOL g_bAudit;



//
// waitable thread pool handle.
//

HANDLE hRegisteredWait = NULL;


VOID
TeardownServer(
    DWORD dwLastError
    );

VOID
NTAPI
TerminationNotify(
    PVOID Context,
    BOOLEAN TimerOrWaitFired
    );



//
//  FUNCTION: ServiceStart
//
//  COMMENTS:
//    The service
//    stops when hServerStopEvent is signalled

DWORD
ServiceStart(
    HINSTANCE hInstance,
    int nCmdShow
    )
{

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fStartedKeyService = FALSE;
    BOOL bListConstruct = FALSE;

    LPWSTR pwszServerPrincipalName = NULL; 
 
    // Only on Win95 do we use a named event, in order to support shutting
    // down the server cleanly on that platform, since Win95 does not support
    // real services.

    hServerStopEvent = CreateEventA(
            NULL,
            TRUE,           // manual reset event
            FALSE,          // not-signalled
            (FIsWinNT() ? NULL : CRYPTSVC_EVENT_STOP)    // WinNT: unnamed, Win95 named
            );

    //
    // if event already exists, terminate quietly so that only one instance
    // of the service is allowed.
    //

    if(hServerStopEvent && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(hServerStopEvent);
        hServerStopEvent = NULL;
    }

    if(hServerStopEvent == NULL) {
        dwLastError = GetLastError();
        goto cleanup;
    }


    


    //
    // report the status to the service control manager.
    // (service start still pending).
    //

    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING,  // service state
            NO_ERROR,               // exit code
            3000                    // wait hint
            )) {
        dwLastError = GetLastError();
        goto cleanup;
    }


    dwLastError = StartKeyService();
    if(ERROR_SUCCESS != dwLastError)
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if (!_CatDBServiceInit(FALSE))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }


    //
    // Initialize the RPC interfaces for
    // Key Service, ICertProt, etc.

    RPC_STATUS status;

    status = RpcServerUseProtseqEpW(KEYSVC_DEFAULT_PROT_SEQ,   
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    KEYSVC_DEFAULT_ENDPOINT, 
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerUseProtseqEpW(KEYSVC_LOCAL_PROT_SEQ,   //ncalrpc 
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    KEYSVC_LOCAL_ENDPOINT,   //keysvc
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_IKeySvc_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   NULL);
    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_IKeySvcR_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   NULL);
    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_ICertProtectFunctions_v1_0_s_ifspec,
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   CryptSvcSecurityCallback);

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_ICatDBSvc_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   CryptSvcSecurityCallback);
    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    //
    // report the status to the service control manager.
    //

    if (!ReportStatusToSCMgr(
            SERVICE_RUNNING,       // service state
            NO_ERROR,              // exit code
            0                      // wait hint
            )) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    // allow clients to make authenticated requests
    status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &pwszServerPrincipalName);
    if (RPC_S_OK != status) 
    {
        //BUGBUG: Shouldn't prevent service from startin just because auth failed.
        //        We should log an event here. 
    }
    else 
    { 
        status = RpcServerRegisterAuthInfo
            (pwszServerPrincipalName, 
             RPC_C_AUTHN_GSS_NEGOTIATE,  
             NULL,                       // Use default key acquisiting function
             NULL                        // Use default creds
             );
        if (RPC_S_OK != status) 
        {
            //BUGBUG: Shouldn't prevent service from startin just because auth failed.
            //        We should log an event here. 
        }
    }

    //
    // on WinNT5, ask services.exe to notify us when the service is shutting
    // down, and return this thread to the work item queue.
    //

    if(!RegisterWaitForSingleObject(
                            &hRegisteredWait,
                            hServerStopEvent,   // wait handle
                            TerminationNotify,  // callback fcn
                            NULL,               // parameter
                            INFINITE,           // timeout
                            WT_EXECUTELONGFUNCTION | WT_EXECUTEONLYONCE
                            )) {

        hRegisteredWait = NULL;
        dwLastError = GetLastError();
    }

    if (NULL != pwszServerPrincipalName) { RpcStringFreeW(&pwszServerPrincipalName); }
    return dwLastError;



cleanup:

    TeardownServer( dwLastError );

    if (NULL != pwszServerPrincipalName) { RpcStringFreeW(&pwszServerPrincipalName); }
    return dwLastError;
}

VOID
NTAPI
TerminationNotify(
    PVOID Context,
    BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    This function gets called by a services worker thread when the
    termination event gets signaled.

Arguments:

Return Value:

--*/
{
    //
    // per JSchwart:
    // safe to unregister during callback.
    //

    if( hRegisteredWait ) {
        UnregisterWaitEx( hRegisteredWait, NULL );
        hRegisteredWait = NULL;
    }

    TeardownServer( ERROR_SUCCESS );
}

VOID
TeardownServer(
    DWORD dwLastError
    )
{
    RPC_STATUS  rpcStatus;
    DWORD       dwErrToReport = dwLastError;


    //
    // Unregister RPC Interfaces

    rpcStatus = RpcServerUnregisterIf(s_IKeySvc_v1_0_s_ifspec, 0, 0);
    if ((rpcStatus != RPC_S_OK) && (dwErrToReport == ERROR_SUCCESS))
    {
        dwErrToReport = rpcStatus;
    }

    rpcStatus = RpcServerUnregisterIf(s_IKeySvcR_v1_0_s_ifspec, 0, 0);
    if ((rpcStatus != RPC_S_OK) && (dwErrToReport == ERROR_SUCCESS))
    {
        dwErrToReport = rpcStatus;
    }

    rpcStatus = RpcServerUnregisterIf(s_ICertProtectFunctions_v1_0_s_ifspec, 0, 0);
    if ((rpcStatus != RPC_S_OK) && (dwErrToReport == ERROR_SUCCESS))
    {
        dwErrToReport = rpcStatus;
    }

    rpcStatus = RpcServerUnregisterIf(s_ICatDBSvc_v1_0_s_ifspec, 0, 0);
    if ((rpcStatus != RPC_S_OK) && (dwErrToReport == ERROR_SUCCESS))
    {
        dwErrToReport = rpcStatus;
    }

    //
    // stop backup key server
    // Note:  this function knows internally whether the backup key server
    // really started or not.
    //

    StopKeyService();


    _CatDBServiceInit(TRUE);


    if(hServerStopEvent) {
        SetEvent(hServerStopEvent); // make event signalled to release anyone waiting for termination
        CloseHandle(hServerStopEvent);
        hServerStopEvent = NULL;
    }

    ReportStatusToSCMgr(
                        SERVICE_STOPPED,
                        dwErrToReport,
                        0
                        );

}

//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{

    if(hServerStopEvent)
    {
        PulseEvent(hServerStopEvent); // signal waiting threads and reset to non-signalled        
    }
}


extern "C" 
{


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return(LocalAlloc(LMEM_ZEROINIT, len));
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    //
    // sfield: zero memory before freeing it.
    // do this because RPC allocates alot on our behalf, and we want to
    // be as sanitary as possible with respect to not letting anything
    // sensitive go to pagefile.
    //

    ZeroMemory( ptr, LocalSize( ptr ) );
    LocalFree(ptr);
}

void __RPC_FAR * __RPC_API midl_user_reallocate(void __RPC_FAR * ptr, size_t len)
{
    return(LocalReAlloc(ptr, len, LMEM_MOVEABLE | LMEM_ZEROINIT));
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\cryptsvc\keysvr.cpp ===
//depot/Lab03_N/DS/security/cryptoapi/cryptsvc/keysvr.cpp#9 - edit change 6380 (text)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <svcs.h>       // SVCS_
#include <ntsecapi.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <wintrustp.h>
#include <userenv.h>
#include <lmcons.h>
#include <certca.h>
#include "keysvc.h"
#include "keysvr.h"
#include "pfx.h"
#include "cryptui.h"
#include "lenroll.h"

#include "unicode.h"
#include "unicode5.h"
#include <crypt.h>


// Link List structure
typedef struct _ContextList
{
    KEYSVC_HANDLE hKeySvc;
    KEYSVC_CONTEXT *pContext;
    _ContextList *pNext;
} CONTEXTLIST, *PCONTEXTLIST;

static PCONTEXTLIST g_pContextList = NULL;

// critical section for context linked list
static CRITICAL_SECTION g_ListCritSec;

BOOL
GetTextualSid(
    IN      PSID    pSid,          // binary Sid
    IN  OUT LPWSTR  TextualSid,  // buffer for Textual representaion of Sid
    IN  OUT LPDWORD dwBufferLen // required/provided TextualSid buffersize
    );

BOOL
GetUserTextualSid(
    IN  OUT LPWSTR  lpBuffer,
    IN  OUT LPDWORD nSize
    );

static BOOL g_fStartedKeyService = FALSE;


#define KEYSVC_DEFAULT_ENDPOINT            TEXT("\\pipe\\keysvc")
#define KEYSVC_DEFAULT_PROT_SEQ            TEXT("ncacn_np")
#define MAXPROTSEQ    20

#define ARRAYSIZE(rg) (sizeof(rg) / sizeof((rg)[0]))

RPC_BINDING_VECTOR  *pKeySvcBindingVector = NULL;

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPWSTR String                  // source (Unicode)
    );


void *MyAlloc(size_t len)
{
    return LocalAlloc(LMEM_ZEROINIT, len);
}

void MyFree(void *p)
{
   LocalFree(p);
}




DWORD
StartKeyService(
    VOID
    )
{
    DWORD dwLastError = ERROR_SUCCESS;

    //
    // WinNT4, Win95:  do nothing, just return success
    //

    if( !FIsWinNT5() )
        return ERROR_SUCCESS;



    // initialize the context list critical section
    __try { 
        InitializeCriticalSection(&g_ListCritSec);
    } __except (EXCEPTION_EXECUTE_HANDLER) { 
        dwLastError =  _exception_code();
    }

    if( dwLastError == ERROR_SUCCESS )
        g_fStartedKeyService = TRUE;

    return dwLastError;
}

DWORD
StopKeyService(
    VOID
    )
{
    DWORD dwLastError = ERROR_SUCCESS;

    if( !g_fStartedKeyService )
        return ERROR_SUCCESS;

    // delete the context list critical section which was inited in startup
    DeleteCriticalSection(&g_ListCritSec);


    return dwLastError;
}

BOOL
IsAdministrator2(
    VOID
    )
/*++

    This function determines if the calling user is an Administrator.

    On Windows 95, this function always returns FALSE, as there is
    no difference between users on that platform.

  NOTE : This function originally returned TRUE on Win95, but since this
  would allow machine key administration by anyone this was changed to
  FALSE.

    On Windows NT, the caller of this function must be impersonating
    the user which is to be queried.  If the caller is not impersonating,
    this function will always return FALSE.

--*/
{
    HANDLE hAccessToken;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID psidAdministrators = NULL;
    BOOL bSuccess;

    //
    // If we aren't on WinNT (on Win95) just return TRUE
    //

    if(!FIsWinNT())
        return FALSE;

    if(!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &hAccessToken
            )) return FALSE;

    bSuccess = AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            );

    if( bSuccess ) {
        BOOL fIsMember = FALSE;

        bSuccess = CheckTokenMembership( hAccessToken, psidAdministrators, &fIsMember );

        if( bSuccess && !fIsMember )
            bSuccess = FALSE;

    }

    CloseHandle( hAccessToken );

    if(psidAdministrators)
        FreeSid(psidAdministrators);

    return bSuccess;

}

// Use QueryServiceConfig() to get the service user name and domain
DWORD GetServiceDomain(
                       LPWSTR pszServiceName,
                       LPWSTR *ppszUserName,
                       LPWSTR *ppszDomainName
                       )
{
    SC_HANDLE               hSCManager = 0;
    SC_HANDLE               hService = 0;
    QUERY_SERVICE_CONFIGW   serviceConfigIgnore;  
    QUERY_SERVICE_CONFIGW   *pServiceConfig = NULL;
    DWORD                   cbServiceConfig;
    DWORD                   i;
    DWORD                   cch;
    WCHAR                   *pch;
    DWORD                   dwErr = 0;

    // Initialization:
    memset(&serviceConfigIgnore, 0, sizeof(serviceConfigIgnore));

    // open the service control manager
    if (0 == (hSCManager = OpenSCManagerW(NULL, NULL, SC_MANAGER_CONNECT)))
    {
        dwErr = NTE_FAIL;
        goto Ret;
    }

    // open the service
    if (0 == (hService = OpenServiceW(hSCManager, pszServiceName,
                                     SERVICE_QUERY_CONFIG)))
    {
        dwErr = NTE_FAIL;
        goto Ret;
    }

    QueryServiceConfigW(hService, &serviceConfigIgnore, 0, &cbServiceConfig);
    if (NULL == (pServiceConfig =
        (QUERY_SERVICE_CONFIGW*)MyAlloc(cbServiceConfig)))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    if (FALSE == QueryServiceConfigW(hService, pServiceConfig,
                                     cbServiceConfig, &cbServiceConfig))
    {
        dwErr = NTE_FAIL;
        goto Ret;
    }

    // get the domain name and the user name
    cch = wcslen((LPWSTR)pServiceConfig->lpServiceStartName);
    pch = (LPWSTR)pServiceConfig->lpServiceStartName;
    for(i=1;i<=cch;i++)
    {
        // quit when the \ is hit
        if (0x005C == pch[i-1])
            break;
    }
    pch = pServiceConfig->lpServiceStartName;
    if (NULL == (*ppszDomainName =
        (WCHAR*)MyAlloc((i + 1) * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    memcpy(*ppszDomainName, pch, (i - 1) * sizeof(WCHAR));
    if (NULL == (*ppszUserName =
        (WCHAR*)MyAlloc(((cch - i) + 1) * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    memcpy(*ppszUserName, &pch[i], (cch - i) * sizeof(WCHAR));
Ret:
    if (pServiceConfig)
        MyFree(pServiceConfig);
    return dwErr;
}


//*************************************************************
//
//  TestIfUserProfileLoaded()
//
//  Purpose:    Test to see if this user's profile is loaded.
//
//  Parameters: hToken          -   user's token
//              *pfLoaded       - OUT - TRUE if loaded false if not
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//*************************************************************

BOOL TestIfUserProfileLoaded(
                             HANDLE hToken,
                             BOOL *pfLoaded
                             )
{
    WCHAR   szSID[MAX_PATH+1];
    DWORD   cchSID = sizeof(szSID) / sizeof(WCHAR);
    HKEY    hRegKey = 0;;
    BOOL    fRet = FALSE;

    *pfLoaded = FALSE;

    //
    // Get the Sid string for the user
    //

    if(!ImpersonateLoggedOnUser( hToken ))
        goto Ret;

    fRet = GetUserTextualSid(szSID, &cchSID);

    RevertToSelf();

    if( !fRet )
        goto Ret;

    fRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_USERS, szSID, 0,
                                      MAXIMUM_ALLOWED, &hRegKey))
    {
        *pfLoaded = TRUE;
    }
    fRet = TRUE;
Ret:
    if(hRegKey)
        RegCloseKey(hRegKey);
    return fRet;
}

#define     SERVICE_KEYNAME_PREFIX      L"_SC_"

DWORD LogonToService(
                     LPWSTR pszServiceName,
                     HANDLE *phLogonToken,
                     HANDLE *phProfile
                     )
{
    DWORD                   dwErr = 0;
    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    NTSTATUS                Status;
    LSA_HANDLE              hPolicy = 0;
    LSA_UNICODE_STRING      KeyName;
    LPWSTR                  pszTmpKeyName = NULL;
    LSA_UNICODE_STRING      *pServicePassword = NULL;
    PROFILEINFOW            ProfileInfoW;
    LPWSTR                  pszUserName = NULL;
    LPWSTR                  pszDomainName = NULL;
    WCHAR                   rgwchPassword[PWLEN + 1];
    BOOL                    fProfileLoaded = FALSE;

    *phLogonToken = 0;
    *phProfile = 0;
    memset(&ObjectAttributes, 0, sizeof(ObjectAttributes));
    memset(&rgwchPassword, 0, sizeof(rgwchPassword));

    // set up the key name
    if (NULL == (pszTmpKeyName =
        (LPWSTR)MyAlloc((sizeof(SERVICE_KEYNAME_PREFIX) +
                         wcslen(pszServiceName) + 1)
                        * sizeof(WCHAR))))
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    wcscpy(pszTmpKeyName, SERVICE_KEYNAME_PREFIX);
    wcscat(pszTmpKeyName, pszServiceName);
    InitLsaString(&KeyName, pszTmpKeyName);

    // open the policy
    if (STATUS_SUCCESS != (Status = LsaOpenPolicy(NULL, &ObjectAttributes,
                                        POLICY_GET_PRIVATE_INFORMATION,
                                        &hPolicy)))
    {
        dwErr = NTE_FAIL;
        goto Ret;
    }

    // get the service password
    if ((STATUS_SUCCESS != (Status = LsaRetrievePrivateData(hPolicy, &KeyName, &pServicePassword))) ||
        (NULL == pServicePassword))
        
    {
        dwErr = NTE_FAIL;
        goto Ret;
    }

    if(pServicePassword->Length > sizeof(rgwchPassword)) {
        dwErr = NTE_FAIL;
        goto Ret;
    }

    memcpy(rgwchPassword, pServicePassword->Buffer,
           pServicePassword->Length);

    // get the username + domain name
    if (0 != (dwErr = GetServiceDomain(pszServiceName,
                                       &pszUserName, &pszDomainName)))
    {
        goto Ret;
    }

    // log the service on
    if (0 == LogonUserW(pszUserName,
                            pszDomainName,
                            rgwchPassword,
                            LOGON32_LOGON_SERVICE,
                            LOGON32_PROVIDER_DEFAULT,
                            phLogonToken))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // check if the profile is already loaded
    if (!TestIfUserProfileLoaded(*phLogonToken, &fProfileLoaded))
    {
        dwErr = GetLastError();
        goto Ret;
    }

    // if necessary load the hive associated with the service
    if (!fProfileLoaded)
    {
        memset(&ProfileInfoW, 0, sizeof(ProfileInfoW));
        ProfileInfoW.dwSize = sizeof(ProfileInfoW);
        ProfileInfoW.lpUserName = pszServiceName;
        ProfileInfoW.dwFlags = PI_NOUI;
        if (FALSE == LoadUserProfileW(*phLogonToken, &ProfileInfoW))
        {
            dwErr = GetLastError();
            goto Ret;
        }
        *phProfile = ProfileInfoW.hProfile;
    }

    // impersonate the service
    if (FALSE == ImpersonateLoggedOnUser(*phLogonToken))
    {
        dwErr = GetLastError();
    }
Ret:
    if (0 != dwErr)
    {
        if (*phProfile)
            UnloadUserProfile(*phLogonToken, *phProfile);
        *phProfile = 0;
        if (*phLogonToken)
            CloseHandle(*phLogonToken);
        *phLogonToken = 0;
    }
    if (pServicePassword) {
        ZeroMemory( pServicePassword->Buffer, pServicePassword->Length );
        LsaFreeMemory(pServicePassword);
    }
    if (pszUserName)
        MyFree(pszUserName);
    if (pszDomainName)
        MyFree(pszDomainName);
    if (pszTmpKeyName)
        MyFree(pszTmpKeyName);
    if (hPolicy)
        LsaClose(hPolicy);
    return dwErr;
}

DWORD LogoffService(
                    HANDLE hLogonToken,
                    HANDLE hProfile
                    )
{
    DWORD   dwErr = 0;

    // revert to self
    RevertToSelf();

    // unload the profile
    if (hProfile)
        UnloadUserProfile(hLogonToken, hProfile);

    // close the Token handle gotten with LogonUser
    if (hLogonToken)
        CloseHandle(hLogonToken);

    return dwErr;
}

DWORD CheckIfAdmin(
                   handle_t hRPCBinding
                   )
{
    DWORD   dwErr = 0;

    if (0 != (dwErr = RpcImpersonateClient((RPC_BINDING_HANDLE)hRPCBinding)))
        goto Ret;

    if (!IsAdministrator2())
        dwErr = (DWORD)NTE_PERM;
Ret:
    RpcRevertToSelfEx((RPC_BINDING_HANDLE)hRPCBinding);
    return dwErr;
}

DWORD KeySvrImpersonate(
                        handle_t hRPCBinding,
                        KEYSVC_CONTEXT *pContext
                        )
{
    DWORD   dwErr = 0;

    switch(pContext->dwType)
    {
        case KeySvcMachine:
            dwErr = CheckIfAdmin(hRPCBinding);
            break;

        case KeySvcService:
            if (0 != (dwErr = CheckIfAdmin(hRPCBinding)))
                goto Ret;

            dwErr = LogonToService(pContext->pszServiceName,
                                   &pContext->hLogonToken,
                                   &pContext->hProfile);
            break;
    }
Ret:
    return dwErr;
}

DWORD KeySvrRevert(
                   handle_t hRPCBinding,
                   KEYSVC_CONTEXT  *pContext
                   )
{
    DWORD   dwErr = 0;

    if (pContext)
    {
        switch(pContext->dwType)
        {
            case KeySvcService:
                dwErr = LogoffService(pContext->hLogonToken,
                                      pContext->hProfile);
                pContext->hProfile = 0;
                pContext->hLogonToken = 0;
                break;
        }
    }

    return dwErr;
}

// 
// Function: MakeNewHandle
//
// Description: Creates a random key service handle.
//
KEYSVC_HANDLE MakeNewHandle()
{
    KEYSVC_HANDLE   hKeySvc = 0;

    // get a random handle value
    RtlGenRandom((BYTE*)&hKeySvc, sizeof(KEYSVC_HANDLE));

    return hKeySvc;
}

// 
// Function: CheckIfHandleInList
//
// Description: Goes through the link list of contexts and checks
//              if the passed in handle is in the list.  If so
//              the list entry is returned.
//
PCONTEXTLIST CheckIfHandleInList(
                                 KEYSVC_HANDLE hKeySvc
                                 )
{
    PCONTEXTLIST    pContextList = g_pContextList;

    while (1)
    {
        if ((NULL == pContextList) || (pContextList->hKeySvc == hKeySvc))
        {
            break;
        }

        pContextList = pContextList->pNext;
    }

    return pContextList;
}

// 
// Function: MakeKeySvcHandle
//
// Description: The function takes a context pointer and returns a handle
//              to that context.  An element in the context list is added
//              with the handle and the context pointer.
//
KEYSVC_HANDLE MakeKeySvcHandle(
                               KEYSVC_CONTEXT *pContext
                               )
{
    DWORD           dwRet                = ERROR_INVALID_PARAMETER;
    KEYSVC_HANDLE   hKeySvc              = 0;
    BOOL            fIncrementedRefCount = FALSE; 
    BOOL            fInCritSec           = FALSE;
    PCONTEXTLIST    pContextList         = NULL;

    // allocate a new element for the list
    if (NULL == (pContextList = (PCONTEXTLIST)MyAlloc(sizeof(CONTEXTLIST))))
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Error; 
    }
    pContextList->pContext = pContext;
    if (0 >= InterlockedIncrement(&(pContext->iRefCount)))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Error; 
    }
    fIncrementedRefCount = TRUE; 

    // enter critical section
    EnterCriticalSection(&g_ListCritSec);
    fInCritSec = TRUE;

    __try
    {
        pContextList->pNext = g_pContextList;

        while (1)
        {
            hKeySvc = MakeNewHandle();

            if (NULL == CheckIfHandleInList(hKeySvc))
                break;
        }

        // add new element to the front of the list
        pContextList->hKeySvc = hKeySvc;
        g_pContextList = pContextList;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        hKeySvc = 0;
        goto Error;
    }
    dwRet = ERROR_SUCCESS;

Ret:
    // leave critical section
    if (fInCritSec)
    {
        LeaveCriticalSection(&g_ListCritSec);
    }
    SetLastError(dwRet);

    return hKeySvc;

 Error:
    if (NULL != pContextList) { 
        MyFree(pContextList); 
    }
    if (fIncrementedRefCount) { 
        InterlockedDecrement(&(pContext->iRefCount));
    }

    goto Ret; 
}

// 
// Function: CheckKeySvcHandle
//
// Description: The function takes a handle and returns the context pointer
//              associated with that handle.  If the handle is not in the
//              list then the function returns NULL.
//
KEYSVC_CONTEXT *CheckKeySvcHandle(
                                  KEYSVC_HANDLE hKeySvc
                                  )
{
    PCONTEXTLIST    pContextList = NULL;
    KEYSVC_CONTEXT *pContext = NULL;

    // enter critical section
    EnterCriticalSection(&g_ListCritSec);

    __try
    {
        if (NULL != (pContextList = CheckIfHandleInList(hKeySvc)))
        {
            pContext = pContextList->pContext;

            // increment the ref count
            if (0 >= InterlockedIncrement(&(pContext->iRefCount)))
            {
                pContext = NULL;
            }
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        goto Ret;
    }
Ret:
    // leave critical section
    LeaveCriticalSection(&g_ListCritSec);

    return pContext;
}

// 
// Function: FreeContext
//
// Description: The function frees a context pointer.
//
void FreeContext(
                 KEYSVC_CONTEXT *pContext
                 )
{
    if (NULL != pContext->pszServiceName)
        MyFree(pContext->pszServiceName);
    MyFree(pContext);
}

// 
// Function: FreeContext
//
// Description: The function frees a context pointer if the ref count is 0.
//
void ReleaseContext(
                    IN KEYSVC_CONTEXT *pContext
                    )
{
    if (NULL != pContext)
    {
        if (0 >= InterlockedDecrement(&(pContext->iRefCount)))
        {
            FreeContext(pContext);
        }
    }
}

// 
// Function: RemoveKeySvcHandle
//
// Description: The function takes a handle and removes the element in
//              the list associated with this handle.
//
DWORD RemoveKeySvcHandle(
                         KEYSVC_HANDLE hKeySvc
                         )
{
    PCONTEXTLIST    pContextList = g_pContextList;
    PCONTEXTLIST    pPrevious = NULL;
    DWORD           dwErr = ERROR_INVALID_PARAMETER;

    // enter critical section
    EnterCriticalSection(&g_ListCritSec);

    __try
    {
        while (1)
        {
            // have we hit the end, if so exit without removing anything
            if (NULL == pContextList)
            {
                break;
            }

            // have we found the list entry
            if (hKeySvc == pContextList->hKeySvc)
            {
                if (pContextList == g_pContextList)
                {
                    g_pContextList = pContextList->pNext;
                }
                else
                {
                    pPrevious->pNext = pContextList->pNext;
                }

                // free the memory
                ReleaseContext(pContextList->pContext);
                MyFree(pContextList);
                dwErr = 0;
                break;
            }

            pPrevious = pContextList;
            pContextList = pContextList->pNext;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        goto Ret;
    }
Ret:
    // leave critical section
    LeaveCriticalSection(&g_ListCritSec);

    return dwErr;
}

DWORD AllocAndAssignString(
                           IN PKEYSVC_UNICODE_STRING pUnicodeString,
                           OUT LPWSTR *ppwsz
                           )
{
    DWORD   dwErr = 0;

    if ((NULL != pUnicodeString->Buffer) && (0 != pUnicodeString->Length))
    {
        if ((pUnicodeString->Length > pUnicodeString->MaximumLength) ||
            (pUnicodeString->Length & 1) || (pUnicodeString->MaximumLength & 1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if (NULL == (*ppwsz = (LPWSTR)MyAlloc(pUnicodeString->MaximumLength +
                                              sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        memcpy(*ppwsz, pUnicodeString->Buffer, pUnicodeString->Length);
    }
Ret:
    return dwErr;
}

// key service functions
ULONG       s_KeyrOpenKeyService(
/* [in]  */     handle_t                        hRPCBinding,
/* [in]  */     KEYSVC_TYPE                     OwnerType,
/* [in]  */     PKEYSVC_UNICODE_STRING          pOwnerName,
/* [in]  */     ULONG                           ulDesiredAccess,
/* [in]  */     PKEYSVC_BLOB                    pAuthentication,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [out] */     KEYSVC_HANDLE                   *phKeySvc)
{
    KEYSVC_CONTEXT  *pContext = NULL;
    BOOL            fImpersonated = FALSE;
    HANDLE          hThread = 0;
    HANDLE          hToken = 0;
    WCHAR           pszUserName[UNLEN + 1];
    DWORD           cbUserName;
    DWORD           dwErr = 0;

    __try
    {
        *phKeySvc = 0;

        if (NULL == ppReserved || NULL != *ppReserved)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }
        
        // Return a blob representing the version: 
        (*ppReserved) = (PKEYSVC_BLOB)MyAlloc(sizeof(KEYSVC_BLOB) + sizeof(KEYSVC_OPEN_KEYSVC_INFO)); 
        if (NULL == (*ppReserved))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY; 
            goto Ret;
        }
        (*ppReserved)->cb = sizeof(KEYSVC_OPEN_KEYSVC_INFO); 
        (*ppReserved)->pb = ((LPBYTE)(*ppReserved)) + sizeof(KEYSVC_BLOB); 

        KEYSVC_OPEN_KEYSVC_INFO sOpenKeySvcInfo = { 
            sizeof(KEYSVC_OPEN_KEYSVC_INFO), KEYSVC_VERSION_WHISTLER 
	}; 
        memcpy((*ppReserved)->pb, &sOpenKeySvcInfo, sizeof(sOpenKeySvcInfo)); 

        // allocate a new context structure
        if (NULL == (pContext = (KEYSVC_CONTEXT*)MyAlloc(sizeof(KEYSVC_CONTEXT))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Ret;
        }
        pContext->dwType = OwnerType;

        // take action depending on type of key owner
        switch(OwnerType)
        {
            case KeySvcMachine:
                if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
                    goto Ret;
                fImpersonated = TRUE;
                break;

            case KeySvcService:
                if (0 == pOwnerName->Length)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto Ret;
                }


                if (0 != (dwErr = AllocAndAssignString(
                           pOwnerName, &pContext->pszServiceName)))
                {
                    goto Ret;
                }

                // impersonate the service
                if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
                    goto Ret;
                fImpersonated = TRUE;

                break;

            default:
                dwErr = ERROR_INVALID_PARAMETER;
                goto Ret;
        }

        pContext->dwAccess = ulDesiredAccess;

        if (0 == (*phKeySvc = MakeKeySvcHandle(pContext)))
        {
            dwErr = GetLastError();
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (hToken)
            CloseHandle(hToken);
        if (hThread)
            CloseHandle(hThread);
        if (fImpersonated)
            KeySvrRevert(hRPCBinding, pContext);

        // if error then free the context if necessary
        if (dwErr)
        {
            if(pContext)
            {
                FreeContext(pContext);
            }
            if((*ppReserved))
            {
                MyFree((*ppReserved));
                (*ppReserved) = NULL; 
            }
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    return dwErr;
}

ULONG       s_KeyrEnumerateProviders(
/* [in] */      handle_t                        hRPCBinding,
/* [in] */      KEYSVC_HANDLE                   hKeySvc,
/* [in, out] */ PKEYSVC_BLOB                    *ppReserved,
/* [in, out] */ ULONG                           *pcProviderCount,
/* [in, out][size_is(,*pcProviderCount)] */
                PKEYSVC_PROVIDER_INFO           *ppProviders)
{
    PTMP_LIST_INFO          pStart = NULL;
    PTMP_LIST_INFO          pTmpList = NULL;
    PTMP_LIST_INFO          pPrevious = NULL;
    PKEYSVC_PROVIDER_INFO   pProvInfo;
    DWORD                   dwProvType;
    DWORD                   cbName;
    DWORD                   cbTotal = 0;
    DWORD                   cTypes = 0;
    DWORD                   i;
    DWORD                   j;
    BYTE                    *pb;
    KEYSVC_CONTEXT          *pContext = NULL;
    BOOL                    fImpersonated = FALSE;
    DWORD                   dwErr = 0;

    __try
    {
        *pcProviderCount = 0;
        *ppProviders = NULL;

        if (NULL == (pContext = CheckKeySvcHandle(hKeySvc)))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if (0 != (dwErr = KeySvrImpersonate(hRPCBinding, pContext)))
            goto Ret;
        fImpersonated = TRUE;

        // CryptoAPI enumerates one at a time
        // so we must accumulate for total enumeration
        for (i=0;;i++)
        {
            if (!CryptEnumProvidersW(i, NULL, 0, &dwProvType,
                                     NULL, &cbName))
            {
                if (ERROR_NO_MORE_ITEMS != GetLastError())
                {
                    dwErr = NTE_FAIL; 
                    goto Ret;
                }
                break;
            }
            if (NULL == (pTmpList = (PTMP_LIST_INFO)MyAlloc(sizeof(TMP_LIST_INFO))))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            if (NULL == (pTmpList->pInfo = MyAlloc(sizeof(KEYSVC_PROVIDER_INFO) +
                                                   cbName)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            pProvInfo = (PKEYSVC_PROVIDER_INFO)pTmpList->pInfo;
            pProvInfo->Name.Length = (USHORT)cbName;
            pProvInfo->Name.MaximumLength = (USHORT)cbName;
            pProvInfo->Name.Buffer = (USHORT*)((BYTE*)(pProvInfo) +
                                               sizeof(KEYSVC_PROVIDER_INFO));
            if (!CryptEnumProvidersW(i, 
                                     NULL, 
                                     0, 
                                     &pProvInfo->ProviderType,
                                     pProvInfo->Name.Buffer, &cbName))
            {
                if (ERROR_NO_MORE_ITEMS != GetLastError())
                {
                    MyFree(pProvInfo);
                    dwErr = NTE_FAIL;  
                    goto Ret;
                }
                break;
            }
            cbTotal += cbName;
            if (0 == i)
            {
                pStart = pTmpList;
            }
            else
            {
                pPrevious->pNext = pTmpList;
            }
            pPrevious = pTmpList;
            pTmpList = NULL;
        }

        // now copy into one big structure
        pPrevious = pStart;
        if (0 != i)
        {
            *pcProviderCount = i;
            if (NULL == (*ppProviders =
                (PKEYSVC_PROVIDER_INFO)MyAlloc((i * sizeof(KEYSVC_PROVIDER_INFO)) +
                                               cbTotal)))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto Ret;
            }
            pb = (BYTE*)(*ppProviders) + i * sizeof(KEYSVC_PROVIDER_INFO);

            // copy the provider information over
            for (j=0;j<i;j++)
            {
                pProvInfo = (PKEYSVC_PROVIDER_INFO)pPrevious->pInfo;
                (*ppProviders)[j].ProviderType = pProvInfo->ProviderType;
                (*ppProviders)[j].Name.Length = pProvInfo->Name.Length;
                (*ppProviders)[j].Name.MaximumLength = pProvInfo->Name.MaximumLength;
                memcpy(pb, (BYTE*)(pProvInfo->Name.Buffer),
                       (*ppProviders)[j].Name.Length);
                (*ppProviders)[j].Name.Buffer = (USHORT*)pb;
                pb += (*ppProviders)[j].Name.Length;
                pPrevious = pPrevious->pNext;
            }
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Ret;
    }
Ret:
    __try
    {
        if (pTmpList)
            MyFree(pTmpList);
        // free the list
        for (i=0;;i++)
        {
            if (NULL == pStart)
                break;
            pPrevious = pStart;
            pStart = pPrevious->pNext;
            if (pPrevious->pInfo)
       